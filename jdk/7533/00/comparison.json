{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -61,2 +61,2 @@\n- * Examples on how to write tests with IR rules can be found in {@link jdk.test.lib.hotspot.ir_framework.examples.IRExample}\n- * and also as part of the internal testing in {@link jdk.test.lib.hotspot.ir_framework.tests.TestIRMatching}.\n+ * Examples on how to write tests with IR rules can be found in {@link ir_framework.examples.IRExample}\n+ * and also as part of the internal testing in {@link ir_framework.tests.TestIRMatching}.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import compiler.lib.ir_framework.driver.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -606,1 +608,1 @@\n-                builder.append(errors.toString());\n+                builder.append(errors);\n@@ -610,1 +612,1 @@\n-        System.err.println(builder.toString());\n+        System.err.println(builder);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,504 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver;\n-\n-import compiler.lib.ir_framework.*;\n-import compiler.lib.ir_framework.shared.*;\n-import compiler.lib.ir_framework.test.*;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Parse the hotspot pid file of the test VM to match all @IR rules.\n- *\/\n-public class IRMatcher {\n-    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n-\n-    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n-    private static final Pattern IR_ENCODING_PATTERN =\n-            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n-    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n-\n-    private final Map<String, IRMethod> compilations;\n-    private final Class<?> testClass;\n-    private final Map<Method, List<String>> fails;\n-    private final Pattern compileIdPatternForTestClass;\n-    private final String hotspotPidFileName;\n-    private IRMethod irMethod; \/\/ Current IR method to which rules are applied\n-    private Method method; \/\/ Current method to which rules are applied\n-    private IR irAnno; \/\/ Current IR annotation that is processed.\n-    private int irRuleIndex; \/\/ Current IR rule index;\n-\n-    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n-        this.compilations = new HashMap<>();\n-        this.fails = new HashMap<>();\n-        this.testClass = testClass;\n-        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName())\n-                                                            + \" (\\\\S+)\");\n-        this.hotspotPidFileName = hotspotPidFileName;\n-        setupTestMethods(irEncoding);\n-        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n-            System.out.println(\"Read IR encoding from test VM:\");\n-            System.out.println(irEncoding);\n-        }\n-        if (!compilations.isEmpty()) {\n-            parseHotspotPidFile();\n-            applyRules();\n-        }\n-    }\n-\n-    \/**\n-     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n-     *\/\n-    private void setupTestMethods(String irEncoding) {\n-        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n-        for (Method m : testClass.getDeclaredMethods()) {\n-            method = m;\n-            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n-            if (irAnnos.length > 0) {\n-                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n-                int[] ids = irRulesMap.get(m.getName());\n-                TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n-                TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n-                TestFramework.check(ids[ids.length - 1] < irAnnos.length, \"Invalid IR rule index found in validIrRulesMap for \" + m);\n-                if (ids[0] != IREncodingPrinter.NO_RULE_APPLIED) {\n-                    \/\/ If -1, than there was no matching IR rule for the given conditions.\n-                    compilations.put(m.getName(), new IRMethod(m, ids, irAnnos));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n-     *\/\n-    private Map<String, int[]> parseIREncoding(String irEncoding) {\n-        Map<String, int[]> irRulesMap = new HashMap<>();\n-        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n-        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n-        String[] lines = matcher.group(0).split(\"\\\\R\");\n-\n-        \/\/ Skip first line containing information about the format only\n-        for (int i = 1; i < lines.length; i++) {\n-            String line = lines[i].trim();\n-            String[] splitComma = line.split(\",\");\n-            if (splitComma.length < 2) {\n-                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitComma[0]);\n-            }\n-            String testName = splitComma[0];\n-            int[] irRulesIdx = new int[splitComma.length - 1];\n-            for (int j = 1; j < splitComma.length; j++) {\n-                try {\n-                    irRulesIdx[j - 1] = Integer.parseInt(splitComma[j]);\n-                } catch (NumberFormatException e) {\n-                    throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitComma[j]);\n-                }\n-            }\n-            irRulesMap.put(testName, irRulesIdx);\n-        }\n-        return irRulesMap;\n-    }\n-\n-    \/**\n-     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly entries for all\n-     * methods of the test class that need to be IR matched (according to IR encoding).\n-     *\/\n-    private void parseHotspotPidFile() {\n-        Map<Integer, String> compileIdMap = new HashMap<>();\n-        try (var br = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n-            String line;\n-            StringBuilder builder = new StringBuilder();\n-            boolean append = false;\n-            String currentMethod = \"\";\n-            while ((line = br.readLine()) != null) {\n-                if (append && line.startsWith(\"<\/\")) {\n-                    flushOutput(line, builder, currentMethod);\n-                    append = false;\n-                    currentMethod = \"\";\n-                    continue;\n-                } else if (append) {\n-                    appendLine(builder, line);\n-                    continue;\n-                }\n-\n-                if (maybeTestEntry(line)) {\n-                    addTestMethodCompileId(compileIdMap, line);\n-                } else if (isPrintIdealStart(line)) {\n-                    String methodName = getMethodName(compileIdMap, line);\n-                    if (methodName != null) {\n-                        currentMethod = methodName;\n-                        append = true; \/\/ Append all following lines until we hit the closing <\/ideal> tag.\n-                    }\n-                } else if (isPrintOptoAssemblyStart(line)) {\n-                    String methodName = getMethodName(compileIdMap, line);\n-                    if (methodName != null) {\n-                        TestFramework.check(compilations.containsKey(methodName), \"Must be second entry of \" + methodName);\n-                        currentMethod = methodName;\n-                        append = true; \/\/ Append all following lines until we hit the closing <\/opto_assembly> tag.\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n-        }\n-    }\n-\n-    \/**\n-     * Write the input to the IR method and reset the builder.\n-     *\/\n-    private void flushOutput(String line, StringBuilder builder, String currentMethod) {\n-        TestFramework.check(!currentMethod.isEmpty(), \"current method must be set\");\n-        IRMethod irMethod = compilations.get(currentMethod);\n-        if (line.startsWith(\"<\/i\")) {\n-            \/\/ PrintIdeal\n-            irMethod.setIdealOutput(builder.toString());\n-        } else {\n-            \/\/ PrintOptoAssembly\n-            irMethod.setOptoAssemblyOutput(builder.toString());\n-        }\n-        builder.setLength(0);\n-    }\n-\n-    \/**\n-     * Only consider non-osr (no \"compile_kind\") and compilations with C2 (no \"level\")\n-     *\/\n-    private boolean maybeTestEntry(String line) {\n-        return line.startsWith(\"<task_queued\") && !line.contains(\"compile_kind='\") && !line.contains(\"level='\");\n-    }\n-\n-    \/**\n-     * Need to escape XML special characters.\n-     *\/\n-    private static void appendLine(StringBuilder builder, String line) {\n-        if (line.contains(\"&\")) {\n-            line = line.replace(\"&lt;\", \"<\");\n-            line = line.replace(\"&gt;\", \">\");\n-            line = line.replace(\"&quot;\", \"\\\"\");\n-            line = line.replace(\"&apos;\", \"'\");\n-            line = line.replace(\"&amp;\", \"&\");\n-        }\n-        builder.append(line).append(System.lineSeparator());\n-    }\n-\n-    private static int getCompileId(Matcher matcher) {\n-        int compileId;\n-        try {\n-            compileId = Integer.parseInt(matcher.group(1));\n-        } catch (NumberFormatException e) {\n-            throw new TestRunException(\"Could not parse compile id\", e);\n-        }\n-        return compileId;\n-    }\n-\n-    \/**\n-     * Parse the compile id from this line if it belongs to a method that needs to be IR tested (part of test class\n-     * and IR encoding from the test VM specifies that this method has @IR rules to be checked).\n-     *\/\n-    private void addTestMethodCompileId(Map<Integer, String> compileIdMap, String line) {\n-        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n-        if (matcher.find()) {\n-            \/\/ Only care about test class entries. Might have non-class entries as well if user specified additional\n-            \/\/ compile commands. Ignore these.\n-            String methodName = matcher.group(2);\n-            if (compilations.containsKey(methodName)) {\n-                \/\/ We only care about methods that we are actually gonna IR match based on IR encoding.\n-                int compileId = getCompileId(matcher);\n-                TestRun.check(!methodName.isEmpty(), \"method name cannot be empty\");\n-                compileIdMap.put(compileId, methodName);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n-     * interested in.\n-     *\/\n-    private static boolean isPrintIdealStart(String line) {\n-        return line.startsWith(\"<ideal\") && !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Make sure that line does not contain compile_kind which is used for OSR compilations which we are not\n-     * interested in.\n-     *\/\n-    private static boolean isPrintOptoAssemblyStart(String line) {\n-        return line.startsWith(\"<opto_assembly\") && !line.contains(\"compile_kind='\");\n-    }\n-\n-    \/**\n-     * Get method name for this line by looking up the compile id.\n-     * Returns null if not an interesting method (i.e. from test class).\n-     *\/\n-    private String getMethodName(Map<Integer, String> compileIdMap, String line) {\n-        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n-        TestFramework.check(matcher.find(), \"Is \" + hotspotPidFileName + \" corrupted?\");\n-        int compileId = getCompileId(matcher);\n-        return compileIdMap.get(compileId);\n-    }\n-\n-    \/**\n-     * Do an IR matching of all methods with appliable @IR rules fetched during parsing of the hotspot pid file.\n-     *\/\n-    private void applyRules() {\n-        compilations.values().forEach(this::applyRulesForMethod);\n-        reportFailuresIfAny();\n-    }\n-\n-    private void applyRulesForMethod(IRMethod irMethod) {\n-        this.irMethod = irMethod;\n-        method = irMethod.getMethod();\n-        String testOutput = irMethod.getOutput();\n-        if (testOutput.isEmpty()) {\n-            String msg = \"Method was not compiled. Did you specify any compiler directives preventing a compilation or used a \" +\n-                         \"@Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 compilation \" +\n-                         \"by invoking the test enough times.\";\n-            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(msg);\n-            return;\n-        }\n-\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"Output of \" + method + \":\");\n-            System.out.println(testOutput);\n-        }\n-        Arrays.stream(irMethod.getRuleIds()).forEach(this::applyIRRule);\n-    }\n-\n-    \/**\n-     * Apply a single @IR rule as part of a method.\n-     *\/\n-    private void applyIRRule(int id) {\n-        irAnno = irMethod.getIrAnno(id);\n-        irRuleIndex = id;\n-        StringBuilder failMsg = new StringBuilder();\n-        applyFailOn(failMsg);\n-        try {\n-            applyCounts(failMsg);\n-        } catch (TestFormatException e) {\n-            \/\/ Logged. Continue to check other rules.\n-        }\n-        if (!failMsg.isEmpty()) {\n-            failMsg.insert(0, \"@IR rule \" + (id + 1) + \": \\\"\" + irAnno + \"\\\"\" + System.lineSeparator());\n-            fails.computeIfAbsent(method, k -> new ArrayList<>()).add(failMsg.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Apply the failOn regexes of the @IR rule.\n-     *\/\n-    private void applyFailOn(StringBuilder failMsg) {\n-        if (irAnno.failOn().length != 0) {\n-            String failOnRegex = String.join(\"|\", IRNode.mergeNodes(irAnno.failOn()));\n-            Pattern pattern = Pattern.compile(failOnRegex);\n-            Matcher matcher = pattern.matcher(irMethod.getOutput());\n-            long matchCount = matcher.results().count();\n-            if (matchCount > 0) {\n-                addFailOnFailsForOutput(failMsg, pattern, matchCount);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A failOn regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n-     * to the user.\n-     *\/\n-    private void addFailOnFailsForOutput(StringBuilder failMsg, Pattern pattern, long matchCount) {\n-        long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n-        long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n-        if (matchCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n-            \/\/ Report with Ideal and Opto Assembly\n-            addFailOnFailsForOutput(failMsg, irMethod.getOutput());\n-            irMethod.needsAllOutput();\n-        } else if (optoAssemblyCount == 0) {\n-            \/\/ Report with Ideal only\n-            addFailOnFailsForOutput(failMsg, irMethod.getIdealOutput());\n-            irMethod.needsIdeal();\n-        } else {\n-            \/\/ Report with Opto Assembly only\n-            addFailOnFailsForOutput(failMsg, irMethod.getOptoAssemblyOutput());\n-            irMethod.needsOptoAssembly();\n-        }\n-    }\n-\n-    \/**\n-     * Apply the regexes to the testOutput and log the failures.\n-     *\/\n-    private void addFailOnFailsForOutput(StringBuilder failMsg, String testOutput) {\n-        List<String> failOnNodes = IRNode.mergeNodes(irAnno.failOn());\n-        Pattern pattern;\n-        Matcher matcher;\n-        failMsg.append(\"- failOn: Graph contains forbidden nodes:\").append(System.lineSeparator());\n-        int nodeId = 1;\n-        for (String nodeRegex : failOnNodes) {\n-            pattern = Pattern.compile(nodeRegex);\n-            matcher = pattern.matcher(testOutput);\n-            long matchCount = matcher.results().count();\n-            if (matchCount > 0) {\n-                matcher.reset();\n-                failMsg.append(\"    Regex \").append(nodeId).append(\": \").append(nodeRegex).append(System.lineSeparator());\n-                failMsg.append(\"    Matched forbidden node\").append(matchCount > 1 ? \"s (\" + matchCount + \")\" : \"\")\n-                       .append(\":\").append(System.lineSeparator());\n-                matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n-            }\n-            nodeId++;\n-        }\n-    }\n-\n-    \/**\n-     * Apply the counts regexes of the @IR rule.\n-     *\/\n-    private void applyCounts(StringBuilder failMsg) {\n-        if (irAnno.counts().length != 0) {\n-            boolean hasFails = false;\n-            String testOutput = irMethod.getOutput();\n-            int countsId = 1;\n-            final List<String> nodesWithCount = IRNode.mergeNodes(irAnno.counts());\n-            for (int i = 0; i < nodesWithCount.size(); i += 2) {\n-                String node = nodesWithCount.get(i);\n-                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\" + getPostfixErrorMsg(node));\n-                String countString = nodesWithCount.get(i + 1);\n-                long expectedCount;\n-                ParsedComparator<Long> parsedComparator;\n-                try {\n-                    parsedComparator = ParsedComparator.parseComparator(countString);\n-                    expectedCount = Long.parseLong(parsedComparator.getStrippedString());\n-                } catch (NumberFormatException e) {\n-                    TestFormat.fail(\"Provided invalid count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n-                    return;\n-                } catch (CheckedTestFrameworkException e) {\n-                    TestFormat.fail(\"Invalid comparator \\\"\" + e.getMessage() + \"\\\" in \\\"\" + countString + \"\\\" for count\" + getPostfixErrorMsg(node));\n-                    return;\n-                } catch (IndexOutOfBoundsException e) {\n-                    TestFormat.fail(\"Provided empty value\" + getPostfixErrorMsg(node));\n-                    return;\n-                }\n-                TestFormat.check(expectedCount >= 0,\"Provided invalid negative count \\\"\" + countString + \"\\\"\" + getPostfixErrorMsg(node));\n-\n-                Pattern pattern = Pattern.compile(node);\n-                Matcher matcher = pattern.matcher(testOutput);\n-                long actualCount = matcher.results().count();\n-                if (!parsedComparator.getPredicate().test(actualCount, expectedCount)) {\n-                    if (!hasFails) {\n-                        failMsg.append(\"- counts: Graph contains wrong number of nodes:\").append(System.lineSeparator());\n-                        hasFails = true;\n-                    }\n-                    addCountsFail(failMsg, node, pattern, expectedCount, actualCount, countsId);\n-                }\n-                countsId++;\n-            }\n-        }\n-    }\n-\n-    private String getPostfixErrorMsg(String node) {\n-        return \" for IR rule \" + irRuleIndex + \", node \\\"\" + node + \"\\\" at \" + method;\n-    }\n-\n-    \/**\n-     * A counts regex failed. Apply all regexes again to log the exact regex which failed. The failure is later reported\n-     * to the user.\n-     *\/\n-    private void addCountsFail(StringBuilder failMsg, String node, Pattern pattern, long expectedCount, long actualCount, int countsId) {\n-        failMsg.append(\"    Regex \").append(countsId).append(\": \").append(node).append(System.lineSeparator());\n-        failMsg.append(\"    Expected \").append(expectedCount).append(\" but found \").append(actualCount);\n-\n-        if (actualCount > 0) {\n-            Matcher matcher = pattern.matcher(irMethod.getOutput());\n-            long idealCount = pattern.matcher(irMethod.getIdealOutput()).results().count();\n-            long optoAssemblyCount = pattern.matcher(irMethod.getOptoAssemblyOutput()).results().count();\n-            if (actualCount != idealCount + optoAssemblyCount || (idealCount != 0 && optoAssemblyCount != 0)) {\n-                irMethod.needsAllOutput();\n-            } else if (optoAssemblyCount == 0) {\n-                irMethod.needsIdeal();\n-            } else {\n-                irMethod.needsOptoAssembly();\n-            }\n-            failMsg.append(\" node\").append(actualCount > 1 ? \"s\" : \"\").append(\":\").append(System.lineSeparator());\n-            matcher.results().forEach(r -> failMsg.append(\"      \").append(r.group()).append(System.lineSeparator()));\n-        } else {\n-            irMethod.needsAllOutput();\n-            failMsg.append(\" nodes.\").append(System.lineSeparator());\n-        }\n-    }\n-\n-    \/**\n-     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n-     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n-     * in both outputs than the entire output is reported. Throws IRViolationException from which the compilation\n-     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n-     * failures.\n-     *\/\n-    private void reportFailuresIfAny() {\n-        TestFormat.reportIfAnyFailures();\n-        if (!fails.isEmpty()) {\n-            StringBuilder failuresBuilder = new StringBuilder();\n-            StringBuilder compilationsBuilder = new StringBuilder();\n-            int failures = 0;\n-            for (Map.Entry<Method, List<String>> entry : fails.entrySet()) {\n-                Method method = entry.getKey();\n-                compilationsBuilder.append(\">>> Compilation of \").append(method).append(\":\").append(System.lineSeparator());\n-                IRMethod irMethod = compilations.get(method.getName());\n-                String output;\n-                if (irMethod.usesIdeal() && irMethod.usesOptoAssembly()) {\n-                    output = irMethod.getOutput();\n-                } else if (irMethod.usesIdeal()) {\n-                    output = irMethod.getIdealOutput();\n-                } else if (irMethod.usesOptoAssembly()) {\n-                    output = irMethod.getOptoAssemblyOutput();\n-                } else {\n-                    output = \"<empty>\";\n-                }\n-                compilationsBuilder.append(output).append(System.lineSeparator()).append(System.lineSeparator());\n-                List<String> list = entry.getValue();\n-                failuresBuilder.append(\"- Method \\\"\").append(method).append(\"\\\":\").append(System.lineSeparator());\n-                failures += list.size();\n-                list.forEach(s -> failuresBuilder.append(\"  * \")\n-                                                 .append(s.replace(System.lineSeparator(),\n-                                                                   System.lineSeparator() + \"    \").trim())\n-                                                 .append(System.lineSeparator()));\n-                failuresBuilder.append(System.lineSeparator());\n-            }\n-            failuresBuilder.insert(0, (\"One or more @IR rules failed:\" + System.lineSeparator()\n-                                       + System.lineSeparator() + \"Failed IR Rules (\" + failures + \")\"\n-                                       + System.lineSeparator()) + \"-----------------\"\n-                                       + \"-\".repeat(String.valueOf(failures).length()) + System.lineSeparator());\n-            failuresBuilder.append(\">>> Check stdout for compilation output of the failed methods\")\n-                           .append(System.lineSeparator()).append(System.lineSeparator());\n-\n-            \/\/ In some very rare cases, the VM output to regex match on contains \"<!-- safepoint while printing -->\"\n-            \/\/ (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n-            \/\/ Do not throw an exception in this case (i.e. bailout).\n-            String compilations = compilationsBuilder.toString();\n-            if (!compilations.contains(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n-                throw new IRViolationException(failuresBuilder.toString(), compilations);\n-            } else {\n-                System.out.println(\"Found \" + SAFEPOINT_WHILE_PRINTING_MESSAGE + \", bail out of IR matching\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMatcher.java","additions":0,"deletions":504,"binary":false,"changes":504,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver;\n-\n-import compiler.lib.ir_framework.IR;\n-\n-import java.lang.reflect.Method;\n-\n-\/**\n- * Helper class to store information about a method that needs to be IR matched.\n- *\/\n-class IRMethod {\n-    private final Method method;\n-    private final int[] ruleIds;\n-    private final IR[] irAnnos;\n-    private final StringBuilder outputBuilder;\n-    private String output;\n-    private String idealOutput;\n-    private String optoAssemblyOutput;\n-    private boolean needsIdeal;\n-    private boolean needsOptoAssembly;\n-\n-    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n-        this.method = method;\n-        this.ruleIds = ruleIds;\n-        this.irAnnos = irAnnos;\n-        this.outputBuilder = new StringBuilder();\n-        this.output = \"\";\n-        this.idealOutput = \"\";\n-        this.optoAssemblyOutput = \"\";\n-    }\n-\n-    public Method getMethod() {\n-        return method;\n-    }\n-\n-    public int[] getRuleIds() {\n-        return ruleIds;\n-    }\n-\n-    public IR getIrAnno(int idx) {\n-        return irAnnos[idx];\n-    }\n-\n-    \/**\n-     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n-     * Only keep the very last one by overriding 'output'.\n-     *\/\n-    public void setIdealOutput(String idealOutput) {\n-        outputBuilder.setLength(0);\n-        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n-        outputBuilder.append(this.idealOutput);\n-    }\n-\n-    \/**\n-     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n-     *\/\n-    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n-        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n-        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n-        output = outputBuilder.toString();\n-    }\n-\n-    public String getOutput() {\n-        return output;\n-    }\n-\n-    public String getIdealOutput() {\n-        return idealOutput;\n-    }\n-\n-    public String getOptoAssemblyOutput() {\n-        return optoAssemblyOutput;\n-    }\n-\n-    public void needsAllOutput() {\n-        needsIdeal();\n-        needsOptoAssembly();\n-    }\n-\n-    public void needsIdeal() {\n-        needsIdeal = true;\n-    }\n-\n-    public boolean usesIdeal() {\n-        return needsIdeal;\n-    }\n-\n-    public void needsOptoAssembly() {\n-        needsOptoAssembly = true;\n-    }\n-\n-    public boolean usesOptoAssembly() {\n-        return needsOptoAssembly;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMethod.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,1 +197,1 @@\n-                System.out.println(testListBuilder.toString());\n+                System.out.println(testListBuilder);\n@@ -203,1 +203,1 @@\n-                System.out.println(messagesBuilder.toString());\n+                System.out.println(messagesBuilder);\n@@ -229,1 +229,1 @@\n-        if (stdErr.contains(\"TestFormat.reportIfAnyFailures\")) {\n+        if (stdErr.contains(\"TestFormat.throwIfAnyFailures\")) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the compilation output of IR matching failures.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class CompilationOutputBuilder {\n+\n+    public static String build(List<IRMethodMatchResult> results) {\n+        StringBuilder compilationsBuilder = new StringBuilder();\n+        for (IRMethodMatchResult result : results) {\n+            if (result.fail()) {\n+                compilationsBuilder.append(buildMatchedCompilationMessage(result));\n+            }\n+        }\n+        return compilationsBuilder.toString();\n+    }\n+\n+    private static String buildMatchedCompilationMessage(IRMethodMatchResult result) {\n+        return result.getMatchedCompilationOutput() + System.lineSeparator() + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/CompilationOutputBuilder.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.parser.IRMethodParser;\n+\n+import java.util.*;\n+\n+\/**\n+ * This class parses the hotspot_pid* file of the test VM to match all applicable @IR rules afterwards.\n+ *\/\n+public class IRMatcher {\n+    public static final String SAFEPOINT_WHILE_PRINTING_MESSAGE = \"<!-- safepoint while printing -->\";\n+\n+    public IRMatcher(String hotspotPidFileName, String irEncoding, Class<?> testClass) {\n+        IRMethodParser irMethodParser = new IRMethodParser(testClass);\n+        Collection<IRMethod> irMethods = irMethodParser.parse(hotspotPidFileName, irEncoding);\n+        if (irMethods != null) {\n+            applyIRRules(irMethods);\n+        }\n+    }\n+\n+    \/**\n+     * Do an IR matching of all methods with applicable @IR rules prepared with by the {@link IRMethodParser}.\n+     *\/\n+    private void applyIRRules(Collection<IRMethod> irMethods) {\n+        List<IRMethodMatchResult> results = new ArrayList<>();\n+        irMethods.forEach(irMethod -> applyIRRule(irMethod, results));\n+        if (!results.isEmpty()) {\n+            reportFailures(results);\n+        }\n+    }\n+\n+    private void applyIRRule(IRMethod irMethod, List<IRMethodMatchResult> results) {\n+        if (TestFramework.VERBOSE) {\n+            printMethodOutput(irMethod);\n+        }\n+        IRMethodMatchResult result = irMethod.applyIRRules();\n+        if (result.fail()) {\n+            results.add(result);\n+        }\n+    }\n+\n+    private void printMethodOutput(IRMethod irMethod) {\n+        System.out.println(\"Output of \" + irMethod.getOutput() + \":\");\n+        System.out.println(irMethod.getOutput());\n+    }\n+\n+    \/**\n+     * Report all IR violations in a pretty format to the user. Depending on the failed regex, we only report\n+     * PrintIdeal or PrintOptoAssembly if the match failed there. If there were failures that matched things\n+     * in both outputs then the entire output is reported. Throws IRViolationException from which the compilation\n+     * can be read and reported to the stdout separately. The exception message only includes the summary of the\n+     * failures.\n+     *\/\n+    private void reportFailures(List<IRMethodMatchResult> results) {\n+        Collections.sort(results); \/\/ Alphabetically\n+        throwIfNoSafepointWhilePrinting(IRMatcherFailureMessageBuilder.build(results),\n+                                        CompilationOutputBuilder.build(results));\n+    }\n+\n+    \/\/ In some very rare cases, the VM output to regex match on contains \"<!-- safepoint while printing -->\"\n+    \/\/ (emitted by ttyLocker::break_tty_for_safepoint) which might be the reason for a matching error.\n+    \/\/ Do not throw an exception in this case (i.e. bailout).\n+    private void throwIfNoSafepointWhilePrinting(String failures, String compilations) {\n+        if (!compilations.contains(SAFEPOINT_WHILE_PRINTING_MESSAGE)) {\n+            throw new IRViolationException(failures, compilations);\n+        } else {\n+            System.out.println(\"Found \" + SAFEPOINT_WHILE_PRINTING_MESSAGE + \", bail out of IR matching\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcher.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethodMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the failure message output of IR matching failures.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class IRMatcherFailureMessageBuilder {\n+\n+    public static String build(List<IRMethodMatchResult> results) {\n+        StringBuilder failuresBuilder = new StringBuilder();\n+        failuresBuilder.append(buildHeaderMessage(results));\n+        int failureNumber = 1;\n+        for (IRMethodMatchResult irMethodResult : results) {\n+            if (irMethodResult.fail()) {\n+                failuresBuilder.append(buildIRMethodFailureMessage(failureNumber, irMethodResult));\n+                failureNumber++;\n+            }\n+        }\n+        failuresBuilder.append(buildFooterMessage());\n+        return failuresBuilder.toString();\n+    }\n+\n+    private static String buildHeaderMessage(List<IRMethodMatchResult> results) {\n+        int failedIRRulesCount = getFailedIRRulesCount(results);\n+        long failedMethodCount = getFailedMethodCount(results);\n+        return \"One or more @IR rules failed:\" + System.lineSeparator() + System.lineSeparator()\n+               + \"Failed IR Rules (\" + failedIRRulesCount + \") of Methods (\" + failedMethodCount + \")\"\n+               + System.lineSeparator()\n+               +  \"-\".repeat(32 + digitCount(failedIRRulesCount) + digitCount(failedMethodCount))\n+               + System.lineSeparator();\n+    }\n+\n+    private static int getFailedIRRulesCount(List<IRMethodMatchResult> results) {\n+        return results.stream().map(IRMethodMatchResult::getFailedIRRuleCount).reduce(0, Integer::sum);\n+    }\n+\n+    private static long getFailedMethodCount(List<IRMethodMatchResult> results) {\n+        return results.stream().filter(IRMethodMatchResult::fail).count();\n+    }\n+\n+    private static int digitCount(long digit) {\n+        return String.valueOf(digit).length();\n+    }\n+\n+    private static String buildIRMethodFailureMessage(int failureNumber, IRMethodMatchResult result) {\n+        return failureNumber + \")\" + result.buildFailureMessage() + System.lineSeparator();\n+    }\n+\n+    private static String buildFooterMessage() {\n+        return \">>> Check stdout for compilation output of the failed methods\" + System.lineSeparator() + System.lineSeparator();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRMatcherFailureMessageBuilder.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-package compiler.lib.ir_framework.driver;\n+package compiler.lib.ir_framework.driver.irmatching;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/IRViolationException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRViolationException.java","status":"renamed"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+\/**\n+ * Interface used by all classes which represent a IR match result. A result should also provide a failure message\n+ * in a pretty format to be used by the {@link IRMatcher}.\n+ *\/\n+public interface MatchResult {\n+    \/**\n+     * Does this match result represent a failure?\n+     *\/\n+    boolean fail();\n+\n+    \/**\n+     * Builds a failure message in a pretty format to be used by the IR matching failure reporting.\n+     *\/\n+    String buildFailureMessage();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/MatchResult.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * Enum to describe what kind of compilation output that was matched for a method during IR matching.\n+ *\n+ * @see IRRuleMatchResult\n+ *\/\n+public enum OutputMatch {\n+    \/**\n+     * There was no compilation output. Should not happen and results in a failure.\n+     *\/\n+    NONE,\n+    \/**\n+     * Matched on PrintIdeal.\n+     *\/\n+    IDEAL,\n+    \/**\n+     * Matched on PrintOptoAssembly.\n+     *\/\n+    OPTO_ASSEMBLY,\n+    \/**\n+     * Matched on PrintIdeal and PrintOptoAssembly.\n+     *\/\n+    BOTH\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/OutputMatch.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Base class to build the failure message output for an IR method.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+abstract class FailureMessageBuilder {\n+    protected final IRMethod irMethod;\n+\n+    public FailureMessageBuilder(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+    }\n+\n+    abstract public String build();\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/FailureMessageBuilder.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRule;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Helper class to store information about a method that needs to be IR matched.\n+ *\/\n+public class IRMethod {\n+    private final Method method;\n+    private final List<IRRule> irRules;\n+    private final StringBuilder outputBuilder;\n+    private String output;\n+    private String idealOutput;\n+    private String optoAssemblyOutput;\n+\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+        this.method = method;\n+        this.irRules = new ArrayList<>();\n+        for (int i : ruleIds) {\n+            irRules.add(new IRRule(this, i, irAnnos[i - 1]));\n+        }\n+        this.outputBuilder = new StringBuilder();\n+        this.output = \"\";\n+        this.idealOutput = \"\";\n+        this.optoAssemblyOutput = \"\";\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+\n+    \/**\n+     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n+     * Only keep the very last one by overriding 'output'.\n+     *\/\n+    public void setIdealOutput(String idealOutput) {\n+        outputBuilder.setLength(0);\n+        this.idealOutput = \"PrintIdeal:\" + System.lineSeparator() + idealOutput;\n+        outputBuilder.append(this.idealOutput);\n+    }\n+\n+    \/**\n+     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     *\/\n+    public void setOptoAssemblyOutput(String optoAssemblyOutput) {\n+        this.optoAssemblyOutput = \"PrintOptoAssembly:\" + System.lineSeparator() + optoAssemblyOutput;\n+        outputBuilder.append(System.lineSeparator()).append(System.lineSeparator()).append(this.optoAssemblyOutput);\n+        output = outputBuilder.toString();\n+    }\n+\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public String getIdealOutput() {\n+        return idealOutput;\n+    }\n+\n+    public String getOptoAssemblyOutput() {\n+        return optoAssemblyOutput;\n+    }\n+\n+    \/**\n+     * Apply all IR rules of this IR method.\n+     *\/\n+    public IRMethodMatchResult applyIRRules() {\n+        TestFramework.check(!irRules.isEmpty(), \"IRMethod cannot be created if there are no IR rules to apply\");\n+        List<IRRuleMatchResult> results = new ArrayList<>();\n+        if (!output.isEmpty()) {\n+            return getNormalMatchResult(results);\n+        } else {\n+            return new MissingCompilationResult(this, irRules.size());\n+        }\n+    }\n+\n+    private NormalMatchResult getNormalMatchResult(List<IRRuleMatchResult> results) {\n+        for (IRRule irRule : irRules) {\n+            IRRuleMatchResult result = irRule.applyCheckAttribute();\n+            if (result.fail()) {\n+                results.add(result);\n+            }\n+        }\n+        return new NormalMatchResult(this, results);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethod.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * This base class represents an IR matching result of all IR rules of a method.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+abstract public class IRMethodMatchResult implements Comparable<IRMethodMatchResult>, MatchResult {\n+    protected final IRMethod irMethod;\n+\n+    IRMethodMatchResult(IRMethod irMethod) {\n+        this.irMethod = irMethod;\n+    }\n+\n+    abstract public String getMatchedCompilationOutput();\n+\n+    abstract public int getFailedIRRuleCount();\n+\n+    \/**\n+     * Used to sort the failed IR methods alphabetically.\n+     *\/\n+    @Override\n+    public int compareTo(IRMethodMatchResult other) {\n+        return this.irMethod.getMethod().getName().compareTo(other.irMethod.getMethod().getName());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/IRMethodMatchResult.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the compilation output for an IR method.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class MatchedCompilationOutputBuilder {\n+    private final IRMethod irMethod;\n+    private final OutputMatch outputMatch;\n+\n+    public MatchedCompilationOutputBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        this.irMethod = irMethod;\n+        this.outputMatch = getOutputMatch(irRulesMatchResults);\n+    }\n+\n+    private OutputMatch getOutputMatch(List<IRRuleMatchResult> irRulesMatchResults) {\n+        OutputMatch outputMatch;\n+        if (allMatchesOn(irRulesMatchResults, OutputMatch.IDEAL)) {\n+            outputMatch = OutputMatch.IDEAL;\n+        } else if (allMatchesOn(irRulesMatchResults, OutputMatch.OPTO_ASSEMBLY)) {\n+            outputMatch = OutputMatch.OPTO_ASSEMBLY;\n+        } else {\n+            outputMatch = OutputMatch.BOTH;\n+        }\n+        return outputMatch;\n+    }\n+\n+    private boolean allMatchesOn(List<IRRuleMatchResult> irRulesMatchResults, OutputMatch outputMatch) {\n+        return irRulesMatchResults.stream().allMatch(r -> r.getOutputMatch() == outputMatch);\n+    }\n+\n+    public String build() {\n+        StringBuilder builder = new StringBuilder();\n+        builder.append(getMethodLine());\n+        switch (outputMatch) {\n+            case IDEAL -> builder.append(irMethod.getIdealOutput());\n+            case OPTO_ASSEMBLY -> builder.append(irMethod.getOptoAssemblyOutput());\n+            case BOTH -> builder.append(irMethod.getOutput());\n+            default -> throw new TestFrameworkException(\"found unexpected OutputMatch \" + outputMatch.name());\n+        }\n+        return builder.toString();\n+    }\n+\n+    private String getMethodLine() {\n+        return \">>> Compilation of \" + irMethod.getMethod() + \":\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MatchedCompilationOutputBuilder.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class to build the failure message output for an IR method with a missing compilation output.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class MissingCompilationMessageBuilder extends FailureMessageBuilder {\n+\n+    public MissingCompilationMessageBuilder(IRMethod irMethod) {\n+        super(irMethod);\n+    }\n+\n+    @Override\n+    public String build() {\n+        return getMethodLine() + getMissingCompilationMessage();\n+    }\n+\n+    private String getMissingCompilationMessage() {\n+        return \"   * Method was not compiled. Did you specify any compiler directives preventing a compilation \"\n+               + \"or used a @Run method in STANDALONE mode? In the latter case, make sure to always trigger a C2 \"\n+               + \"compilation by \" + \"invoking the test enough times.\";\n+    }\n+    private String getMethodLine() {\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationMessageBuilder.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+\/**\n+ * This class represents an IR matching result where the compilation output was empty.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+public class MissingCompilationResult extends IRMethodMatchResult {\n+    private final int failedIRRules;\n+    private final MissingCompilationMessageBuilder failureMessageBuilder;\n+\n+    MissingCompilationResult(IRMethod irMethod, int failedIRRules) {\n+        super(irMethod);\n+        this.failedIRRules = failedIRRules;\n+        this.failureMessageBuilder = new MissingCompilationMessageBuilder(irMethod);\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getMatchedCompilationOutput() {\n+        return \"<empty>\";\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return failureMessageBuilder.build();\n+    }\n+\n+    private String getMethodLine() {\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\":\" + System.lineSeparator();\n+    }\n+\n+    @Override\n+    public int getFailedIRRuleCount() {\n+        return failedIRRules;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/MissingCompilationResult.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Class to build the failure message output for an IR method for failed IR rules.\n+ *\n+ * @see IRMethodMatchResult\n+ *\/\n+class NormalFailureMessageBuilder extends FailureMessageBuilder {\n+    private final List<IRRuleMatchResult> irRulesMatchResults;\n+\n+    public NormalFailureMessageBuilder(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        super(irMethod);\n+        this.irRulesMatchResults = irRulesMatchResults.stream()\n+                                                      .filter(IRRuleMatchResult::fail)\n+                                                      .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public String build() {\n+        return getMethodLine() + getIRRulesFailureMessage();\n+    }\n+\n+    private String getMethodLine() {\n+        int failures = irRulesMatchResults.size();\n+        return \" Method \\\"\" + irMethod.getMethod() + \"\\\" - [Failed IR rules: \" + failures + \"]:\"\n+               + System.lineSeparator();\n+    }\n+\n+    private String getIRRulesFailureMessage() {\n+        StringBuilder failMsg = new StringBuilder();\n+        for (IRRuleMatchResult irRuleResult : irRulesMatchResults) {\n+            failMsg.append(irRuleResult.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalFailureMessageBuilder.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irmethod;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irrule.IRRuleMatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents a normal IR matching result of all IR rules of a method.\n+ *\n+ * @see IRRuleMatchResult\n+ * @see IRMethod\n+ *\/\n+class NormalMatchResult extends IRMethodMatchResult {\n+    private final List<IRRuleMatchResult> irRulesMatchResults;\n+    private final NormalFailureMessageBuilder failureMessageBuilder;\n+    private final MatchedCompilationOutputBuilder matchedCompilationOutputBuilder;\n+\n+    NormalMatchResult(IRMethod irMethod, List<IRRuleMatchResult> irRulesMatchResults) {\n+        super(irMethod);\n+        this.irRulesMatchResults = irRulesMatchResults;\n+        this.failureMessageBuilder = new NormalFailureMessageBuilder(irMethod, irRulesMatchResults);\n+        this.matchedCompilationOutputBuilder = new MatchedCompilationOutputBuilder(irMethod, irRulesMatchResults);\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return !irRulesMatchResults.isEmpty();\n+    }\n+\n+    @Override\n+    public String getMatchedCompilationOutput() {\n+        return matchedCompilationOutputBuilder.build();\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return failureMessageBuilder.build();\n+    }\n+\n+    @Override\n+    public int getFailedIRRuleCount() {\n+        return irRulesMatchResults.size();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irmethod\/NormalMatchResult.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+\n+\/**\n+ * Base class representing a check attribute of an IR rule.\n+ *\n+ * @see IR\n+ *\/\n+abstract class CheckAttribute {\n+\n+    abstract public CheckAttributeMatchResult apply(String compilation);\n+\n+    protected List<String> getMatchedNodes(Matcher m) {\n+        List<String> matches = new ArrayList<>();\n+        do {\n+            matches.add(m.group());\n+        } while (m.find());\n+        return matches;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttribute.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+\n+import java.util.List;\n+\n+\/**\n+ * Base class representing a result of an applied check attribute of an IR rule.\n+ *\n+ * @see IR\n+ *\/\n+abstract class CheckAttributeMatchResult implements MatchResult {\n+    protected List<RegexFailure> regexFailures = null;\n+\n+    @Override\n+    public boolean fail() {\n+        return regexFailures != null;\n+    }\n+\n+    public int getMatchesCount() {\n+        if (fail()) {\n+            return regexFailures.stream().map(RegexFailure::getMatchesCount).reduce(0, Integer::sum);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    protected String collectRegexFailureMessages() {\n+        StringBuilder failMsg = new StringBuilder();\n+        for (RegexFailure regexFailure : regexFailures) {\n+            failMsg.append(regexFailure.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CheckAttributeMatchResult.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.shared.Comparison;\n+import compiler.lib.ir_framework.shared.ComparisonConstraintParser;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a counts attribute of an IR rule.\n+ *\n+ * @see IR#counts()\n+ *\/\n+class Counts extends CheckAttribute {\n+    public List<Constraint> constraints;\n+\n+    private Counts(List<Constraint> constraints) {\n+        this.constraints = constraints;\n+    }\n+\n+    public static Counts create(List<String> nodesWithCountConstraint, IRRule irRule) {\n+        List<Constraint> constraints = new ArrayList<>();\n+        int nodeId = 1;\n+        for (int i = 0; i < nodesWithCountConstraint.size(); i += 2, nodeId++) {\n+            String node = nodesWithCountConstraint.get(i);\n+            TestFormat.check(i + 1 < nodesWithCountConstraint.size(),\n+                             \"Missing count \" + getPostfixErrorMsg(irRule, node));\n+            String countConstraint = nodesWithCountConstraint.get(i + 1);\n+            Comparison<Long> comparison = parseComparison(irRule, node, countConstraint);\n+            constraints.add(new Constraint(node, comparison, nodeId));\n+        }\n+        return new Counts(constraints);\n+    }\n+\n+    private static String getPostfixErrorMsg(IRRule irRule, String node) {\n+        return \"for IR rule \" + irRule.getRuleId() + \", node \\\"\" + node + \"\\\" at \" + irRule.getMethod();\n+    }\n+\n+    private static Comparison<Long> parseComparison(IRRule irRule, String node, String constraint) {\n+        String postfixErrorMsg = \"in count constraint \" + getPostfixErrorMsg(irRule, node);\n+        return ComparisonConstraintParser.parse(constraint, Long::parseLong, postfixErrorMsg);\n+    }\n+\n+    @Override\n+    public CheckAttributeMatchResult apply(String compilation) {\n+        CountsMatchResult result = new CountsMatchResult();\n+        checkConstraints(result, compilation);\n+        return result;\n+    }\n+\n+    private void checkConstraints(CountsMatchResult result, String compilation) {\n+        for (Constraint constraint : constraints) {\n+            checkConstraint(result, compilation, constraint);\n+        }\n+    }\n+\n+    private void checkConstraint(CountsMatchResult result, String compilation, Constraint constraint) {\n+        long foundCount = getFoundCount(compilation, constraint);\n+        Comparison<Long> comparison = constraint.comparison;\n+        if (!comparison.compare(foundCount)) {\n+            result.addFailure(createRegexFailure(compilation, constraint, foundCount));\n+        }\n+    }\n+\n+    private long getFoundCount(String compilation, Constraint constraint) {\n+        Pattern pattern = Pattern.compile(constraint.nodeRegex);\n+        Matcher matcher = pattern.matcher(compilation);\n+        return matcher.results().count();\n+    }\n+\n+    private CountsRegexFailure createRegexFailure(String compilation, Constraint constraint, long foundCount) {\n+        Pattern p = Pattern.compile(constraint.nodeRegex);\n+        Matcher m = p.matcher(compilation);\n+        List<String> matches;\n+        if (m.find()) {\n+            matches = getMatchedNodes(m);\n+        } else {\n+            matches = new ArrayList<>();\n+        }\n+        return new CountsRegexFailure(constraint.nodeRegex, constraint.nodeId, foundCount, constraint.comparison, matches);\n+    }\n+\n+    static class Constraint {\n+        final String nodeRegex;\n+        final Comparison<Long> comparison;\n+        private final int nodeId;\n+\n+        Constraint(String nodeRegex, Comparison<Long> comparison, int nodeId) {\n+            this.nodeRegex = nodeRegex;\n+            this.comparison = comparison;\n+            this.nodeId = nodeId;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/Counts.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+\n+\/**\n+ * Class representing a result of an applied counts attribute of an IR rule.\n+ *\n+ * @see IR#counts()\n+ *\/\n+class CountsMatchResult extends CheckAttributeMatchResult {\n+\n+    public void addFailure(RegexFailure regexFailure) {\n+        if (regexFailures == null) {\n+            regexFailures = new ArrayList<>();\n+        }\n+        regexFailures.add(regexFailure);\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return \"     - counts: Graph contains wrong number of nodes:\" + System.lineSeparator()\n+               + collectRegexFailureMessages();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsMatchResult.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.shared.Comparison;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents an IR matching failure of a regex of a counts attribute of an IR rule.\n+ *\n+ * @see Counts\n+ *\/\n+class CountsRegexFailure extends RegexFailure {\n+    String failedComparison;\n+\n+    public CountsRegexFailure(String nodeRegex, int nodeId, long foundValue, Comparison<Long> comparison, List<String> matches) {\n+        super(nodeRegex, nodeId, matches);\n+        this.failedComparison = \"[found] \" + foundValue + \" \" + comparison.getComparator() + \" \"\n+                                + comparison.getGivenValue() + \" [given]\";\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return getRegexLine()\n+               + getFailedComparison()\n+               + getMatchedNodesBlock();\n+    }\n+\n+    private String getFailedComparison() {\n+        return \"         - Failed comparison: \" + failedComparison + System.lineSeparator();\n+    }\n+\n+    @Override\n+    protected String getMatchedNodesBlock() {\n+        if (matches.isEmpty()) {\n+            return getEmptyNodeMatchesLine();\n+        } else {\n+            return super.getMatchedNodesBlock();\n+        }\n+    }\n+\n+    private String getEmptyNodeMatchesLine() {\n+        return getMatchedNodesWhiteSpace() + \"- No nodes matched!\" + System.lineSeparator();\n+    }\n+\n+    @Override\n+    protected String getMatchedPrefix() {\n+        return \"Matched\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/CountsRegexFailure.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a failOn attribute of an IR rule.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+class FailOn extends CheckAttribute {\n+    private final Pattern quickPattern;\n+    private final List<String> nodes;\n+\n+    public FailOn(List<String> nodes) {\n+        this.nodes = nodes;\n+        this.quickPattern = Pattern.compile(String.join(\"|\", nodes));\n+    }\n+\n+    @Override\n+    public CheckAttributeMatchResult apply(String compilation) {\n+        FailOnMatchResult result = new FailOnMatchResult();\n+        Matcher matcher = quickPattern.matcher(compilation);\n+        if (matcher.find()) {\n+            result.setFailures(createFailOnFailures(compilation));\n+        }\n+        return result;\n+    }\n+\n+    private List<RegexFailure> createFailOnFailures(String compilation) {\n+        List<RegexFailure> regexFailures = new ArrayList<>();\n+        for (int i = 0; i < nodes.size(); i++) {\n+            checkNode(regexFailures, compilation, nodes.get(i), i + 1);\n+        }\n+        return regexFailures;\n+    }\n+\n+    private void checkNode(List<RegexFailure> regexFailures, String compilation, String node, int nodeId) {\n+        Pattern p = Pattern.compile(node);\n+        Matcher m = p.matcher(compilation);\n+        if (m.find()) {\n+            List<String> matches = getMatchedNodes(m);\n+            regexFailures.add(new FailOnRegexFailure(node, nodeId, matches));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOn.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+\n+import java.util.List;\n+\n+\/**\n+ * Class representing a result of an applied failOn attribute of an IR rule.\n+ *\n+ * @see IR#failOn()\n+ *\/\n+class FailOnMatchResult extends CheckAttributeMatchResult {\n+    public void setFailures(List<RegexFailure> regexFailures) {\n+        this.regexFailures = regexFailures;\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return \"     - failOn: Graph contains forbidden nodes:\" + System.lineSeparator()\n+               + collectRegexFailureMessages();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnMatchResult.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import java.util.List;\n+\n+\/**\n+ * This class represents an IR matching failure of a regex of a failOn attribute of an IR rule.\n+ *\n+ * @see FailOn\n+ *\/\n+class FailOnRegexFailure extends RegexFailure {\n+\n+    public FailOnRegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n+        super(nodeRegex, nodeId, matches);\n+    }\n+\n+    @Override\n+    public String buildFailureMessage() {\n+        return getRegexLine()\n+               + getMatchedNodesBlock();\n+    }\n+\n+    @Override\n+    protected String getMatchedPrefix() {\n+        return \"Matched forbidden\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/FailOnRegexFailure.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+import compiler.lib.ir_framework.shared.*;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.Consumer;\n+\n+public class IRRule {\n+    private final IRMethod irMethod;\n+    private final int ruleId;\n+    private final IR irAnno;\n+    private final FailOn failOn;\n+    private final Counts counts;\n+\n+    public IRRule(IRMethod irMethod, int ruleId, IR irAnno) {\n+        this.irMethod = irMethod;\n+        this.ruleId = ruleId;\n+        this.irAnno = irAnno;\n+        this.failOn = initFailOn(irAnno);\n+        this.counts = initCounts(irAnno);\n+    }\n+\n+    private Counts initCounts(IR irAnno) {\n+        String[] countsConstraints = irAnno.counts();\n+        if (countsConstraints.length != 0) {\n+            try {\n+                return Counts.create(IRNode.mergeNodes(countsConstraints), this);\n+            } catch (TestFormatException e) {\n+                \/\/ Logged and reported later. Continue.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private FailOn initFailOn(IR irAnno) {\n+        String[] failOnNodes = irAnno.failOn();\n+        if (failOnNodes.length != 0) {\n+            return new FailOn(IRNode.mergeNodes(failOnNodes));\n+        }\n+        return null;\n+    }\n+\n+    public int getRuleId() {\n+        return ruleId;\n+    }\n+\n+    public IR getIRAnno() {\n+        return irAnno;\n+    }\n+\n+    public Method getMethod() {\n+        return irMethod.getMethod();\n+    }\n+\n+    \/**\n+     * Apply this IR rule by checking any failOn and counts attributes.\n+     *\/\n+    public IRRuleMatchResult applyCheckAttribute() {\n+        IRRuleMatchResult result = new IRRuleMatchResult(this);\n+        if (failOn != null) {\n+            applyCheckAttribute(failOn, result, result::setFailOnFailures);\n+        }\n+        if (counts != null) {\n+            applyCheckAttribute(counts, result, result::setCountsFailures);\n+        }\n+        return result;\n+    }\n+\n+    private void applyCheckAttribute(CheckAttribute checkAttribute, IRRuleMatchResult result,\n+                                     Consumer<CheckAttributeMatchResult> setFailures) {\n+        CheckAttributeMatchResult checkAttributeResult = checkAttribute.apply(irMethod.getOutput());\n+        if (checkAttributeResult.fail()) {\n+            setFailures.accept(checkAttributeResult);\n+            result.updateOutputMatch(getOutputMatch(checkAttribute, checkAttributeResult));\n+        }\n+    }\n+\n+    \/**\n+     * Determine how the output was matched by reapplying the check attribute for the PrintIdeal and PrintOptoAssembly\n+     * output separately.\n+     *\/\n+    private OutputMatch getOutputMatch(CheckAttribute checkAttribute, CheckAttributeMatchResult checkAttributeResult) {\n+        int totalMatches = checkAttributeResult.getMatchesCount();\n+        int idealFailuresCount = getMatchesCount(checkAttribute, irMethod.getIdealOutput());\n+        int optoAssemblyFailuresCount = getMatchesCount(checkAttribute, irMethod.getOptoAssemblyOutput());\n+        return findOutputMatch(totalMatches, idealFailuresCount, optoAssemblyFailuresCount);\n+    }\n+\n+    private int getMatchesCount(CheckAttribute checkAttribute, String compilation) {\n+        CheckAttributeMatchResult result = checkAttribute.apply(compilation);\n+        return result.getMatchesCount();\n+    }\n+\n+    \/**\n+     * Compare different counts to find out, on what output a failure was matched.\n+     *\/\n+    private OutputMatch findOutputMatch(int totalMatches, int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        if (totalMatches == 0\n+            || someRegexMatchOnlyEntireOutput(totalMatches, idealFailuresCount, optoAssemblyFailuresCount)\n+            || anyMatchOnIdealAndOptoAssembly(idealFailuresCount, optoAssemblyFailuresCount)) {\n+            return OutputMatch.BOTH;\n+        } else if (optoAssemblyFailuresCount == 0) {\n+            return OutputMatch.IDEAL;\n+        } else {\n+            return OutputMatch.OPTO_ASSEMBLY;\n+        }\n+    }\n+\n+    \/**\n+     * Do we have a regex that is only matched on the entire ideal + opto assembly output?\n+     *\/\n+    private boolean someRegexMatchOnlyEntireOutput(int totalCount, int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        return totalCount != idealFailuresCount + optoAssemblyFailuresCount;\n+    }\n+\n+    \/**\n+     * Do we have a match on ideal and opto assembly for this rule?\n+     *\/\n+    private boolean anyMatchOnIdealAndOptoAssembly(int idealFailuresCount, int optoAssemblyFailuresCount) {\n+        return idealFailuresCount > 0 && optoAssemblyFailuresCount > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRule.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.MatchResult;\n+import compiler.lib.ir_framework.driver.irmatching.OutputMatch;\n+\n+\/**\n+ * This class represents an IR matching result of an IR rule.\n+ *\n+ * @see CheckAttributeMatchResult\n+ * @see IRRule\n+ *\/\n+public class IRRuleMatchResult implements MatchResult {\n+    private final IRRule irRule;\n+    private CheckAttributeMatchResult failOnFailures = null;\n+    private CheckAttributeMatchResult countsFailures = null;\n+    private OutputMatch outputMatch;\n+\n+    public IRRuleMatchResult(IRRule irRule) {\n+        this.irRule = irRule;\n+        this.outputMatch = OutputMatch.NONE;\n+    }\n+\n+    private boolean hasFailOnFailures() {\n+        return failOnFailures != null;\n+    }\n+\n+    public void setFailOnFailures(CheckAttributeMatchResult failOnFailures) {\n+        this.failOnFailures = failOnFailures;\n+    }\n+\n+    private boolean hasCountsFailures() {\n+        return countsFailures != null;\n+    }\n+\n+    public void setCountsFailures(CheckAttributeMatchResult countsFailures) {\n+        this.countsFailures = countsFailures;\n+    }\n+\n+    public OutputMatch getOutputMatch() {\n+        return outputMatch;\n+    }\n+\n+    @Override\n+    public boolean fail() {\n+        return failOnFailures != null || countsFailures != null;\n+    }\n+\n+    public void updateOutputMatch(OutputMatch newOutputMatch) {\n+        TestFramework.check(newOutputMatch != OutputMatch.NONE, \"must be valid state\");\n+        switch (outputMatch) {\n+            case NONE -> outputMatch = newOutputMatch;\n+            case IDEAL -> outputMatch = newOutputMatch != OutputMatch.IDEAL\n+                    ? OutputMatch.BOTH : OutputMatch.IDEAL;\n+            case OPTO_ASSEMBLY -> outputMatch = newOutputMatch != OutputMatch.OPTO_ASSEMBLY\n+                    ? OutputMatch.BOTH : OutputMatch.OPTO_ASSEMBLY;\n+        }\n+    }\n+\n+    \/**\n+     * Build a failure message based on the collected failures of this object.\n+     *\/\n+    @Override\n+    public String buildFailureMessage() {\n+        StringBuilder failMsg = new StringBuilder();\n+        failMsg.append(getIRRuleLine());\n+        if (hasFailOnFailures()) {\n+            failMsg.append(failOnFailures.buildFailureMessage());\n+        }\n+        if (hasCountsFailures()) {\n+            failMsg.append(countsFailures.buildFailureMessage());\n+        }\n+        return failMsg.toString();\n+    }\n+\n+    private String getIRRuleLine() {\n+        return \"   * @IR rule \" + irRule.getRuleId() + \": \\\"\" + irRule.getIRAnno() + \"\\\"\" + System.lineSeparator();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/IRRuleMatchResult.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.irrule;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Base class representing an IR matching failure of a regex of a check attribute of an IR rule.\n+ *\n+ * @see CheckAttributeMatchResult\n+ * @see CheckAttribute\n+ * @see IRRule\n+ *\/\n+abstract class RegexFailure {\n+    protected final String nodeRegex;\n+    protected final int nodeId;\n+    protected final List<String> matches;\n+\n+    public RegexFailure(String nodeRegex, int nodeId, List<String> matches) {\n+        this.nodeRegex = nodeRegex;\n+        this.nodeId = nodeId;\n+        this.matches = addWhiteSpacePrefixForEachLine(matches);\n+    }\n+\n+    private List<String> addWhiteSpacePrefixForEachLine(List<String> matches) {\n+        return matches\n+                .stream()\n+                .map(s -> s.replaceAll(System.lineSeparator(), System.lineSeparator()\n+                                                               + getMatchedNodesItemWhiteSpace() + \"  \"))\n+                .collect(Collectors.toList());\n+    }\n+\n+    abstract public String buildFailureMessage();\n+\n+    public int getMatchesCount() {\n+        return matches.size();\n+    }\n+\n+    protected String getRegexLine() {\n+        return \"       * Regex \" + nodeId + \": \" + nodeRegex + System.lineSeparator();\n+    }\n+\n+    protected String getMatchedNodesBlock() {\n+        return getMatchedNodesHeader() + getMatchesNodeLines();\n+    }\n+\n+    protected String getMatchedNodesHeader() {\n+        int matchCount = matches.size();\n+        return \"\" + getMatchedNodesWhiteSpace() + \"- \" + getMatchedPrefix() + \" node\"\n+               + (matchCount != 1 ? \"s (\" + matchCount + \")\" : \"\") + \":\" + System.lineSeparator();\n+    }\n+\n+    protected String getMatchedNodesWhiteSpace() {\n+        return \"         \";\n+    }\n+\n+    abstract protected String getMatchedPrefix();\n+\n+    protected String getMatchesNodeLines() {\n+        StringBuilder builder = new StringBuilder();\n+        matches.forEach(match -> builder.append(getMatchedNodesItemWhiteSpace()).append(\"* \").append(match).append(System.lineSeparator()));\n+        return builder.toString();\n+    }\n+\n+    private String getMatchedNodesItemWhiteSpace() {\n+        return \"           \";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/RegexFailure.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+\/**\n+ * Base class of a read line from the hotspot_pid* file.\n+ *\/\n+abstract class AbstractLine {\n+    private final BufferedReader reader;\n+    protected String line;\n+\n+    public AbstractLine(BufferedReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    public String getLine() {\n+        return line;\n+    }\n+\n+    \/**\n+     * Read next line and return it. If we've reached the end of the file, return NULL instead.\n+     *\/\n+    public boolean readLine() throws IOException {\n+        line = reader.readLine();\n+        return line != null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/AbstractLine.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+\n+\/**\n+ * Class representing a block line inside a PrintIdeal or PrintOptoAssembly output block read from the hotspot_pid* file.\n+ *\/\n+class BlockLine extends AbstractLine {\n+\n+    public BlockLine(BufferedReader reader) {\n+        super(reader);\n+    }\n+\n+    \/**\n+     * Is this line an end of a PrintIdeal or PrintOptoAssembly output block?\n+     *\/\n+    public boolean isBlockEnd() {\n+        return line.startsWith(\"<\/\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockLine.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+\/**\n+ * Class to read all lines of a PrintIdeal or PrintOptoAssembly block.\n+ *\/\n+class BlockOutputReader {\n+    private final BufferedReader reader;\n+\n+    public BlockOutputReader(BufferedReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    \/**\n+     * Read all lines belonging to a PrintIdeal or PrintOptoAssembly output block.\n+     *\/\n+    public String readBlock() throws IOException {\n+        BlockLine line = new BlockLine(reader);\n+        StringBuilder builder = new StringBuilder();\n+        while (line.readLine() && !line.isBlockEnd()) {\n+            builder.append(escapeXML(line.getLine())).append(System.lineSeparator());\n+        }\n+        return builder.toString();\n+    }\n+\n+    \/**\n+     * Need to escape XML special characters.\n+     *\/\n+    private static String escapeXML(String line) {\n+        if (line.contains(\"&\")) {\n+            line = line.replace(\"&lt;\", \"<\");\n+            line = line.replace(\"&gt;\", \">\");\n+            line = line.replace(\"&quot;\", \"\\\"\");\n+            line = line.replace(\"&apos;\", \"'\");\n+            line = line.replace(\"&amp;\", \"&\");\n+        }\n+        return line;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/BlockOutputReader.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+\/**\n+ * Exception thrown when facing an unexpected format during parsing of the hotspot-pid* file\n+ *\/\n+class FileCorruptedException extends RuntimeException {\n+    public FileCorruptedException(String s) {\n+        super(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/FileCorruptedException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class from the hotspot_pid* file and add them\n+ * to the collection of {@link IRMethod} created by {@link IREncodingParser}.\n+ *\n+ * @see IRMethod\n+ * @see IREncodingParser\n+ *\/\n+class HotSpotPidFileParser {\n+    private static final Pattern COMPILE_ID_PATTERN = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n+    private final Pattern compileIdPatternForTestClass;\n+    private Map<String, IRMethod> compilationsMap;\n+\n+    public HotSpotPidFileParser(String testClass) {\n+        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass) + \" (\\\\S+)\");\n+    }\n+\n+    public void setCompilationsMap(Map<String, IRMethod> compilationsMap) {\n+        this.compilationsMap = compilationsMap;\n+    }\n+    \/**\n+     * Parse the hotspot_pid*.log file from the test VM. Read the PrintIdeal and PrintOptoAssembly outputs for all\n+     * methods of the test class that need to be IR matched (found in compilations map).\n+     *\/\n+    public Collection<IRMethod> parseCompilations(String hotspotPidFileName) {\n+        try {\n+            processFileLines(hotspotPidFileName);\n+            return compilationsMap.values();\n+        } catch (IOException e) {\n+            throw new TestFrameworkException(\"Error while reading \" + hotspotPidFileName, e);\n+        } catch (FileCorruptedException e) {\n+            throw new TestFrameworkException(\"Unexpected format of \" + hotspotPidFileName, e);\n+        }\n+    }\n+\n+    private void processFileLines(String hotspotPidFileName) throws IOException {\n+        Map<Integer, IRMethod> compileIdMap = new HashMap<>();\n+        try (var reader = Files.newBufferedReader(Paths.get(hotspotPidFileName))) {\n+            Line line = new Line(reader, compileIdPatternForTestClass);\n+            BlockOutputReader blockOutputReader = new BlockOutputReader(reader);\n+            while (line.readLine()) {\n+                if (line.isTestClassCompilation()) {\n+                    parseTestMethodCompileId(compileIdMap, line.getLine());\n+                } else if (isTestMethodBlockStart(line, compileIdMap)) {\n+                    String blockOutput = blockOutputReader.readBlock();\n+                    setIRMethodOutput(blockOutput, line, compileIdMap);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void parseTestMethodCompileId(Map<Integer, IRMethod> compileIdMap, String line) {\n+        String methodName = parseMethodName(line);\n+        if (isTestAnnotatedMethod(methodName)) {\n+            int compileId = getCompileId(line);\n+            compileIdMap.put(compileId, getIrMethod(methodName));\n+        }\n+    }\n+\n+    private String parseMethodName(String line) {\n+        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+        TestFramework.check(matcher.find(), \"must find match\");\n+        return matcher.group(2);\n+    }\n+\n+    private boolean isTestAnnotatedMethod(String testMethodName) {\n+        return compilationsMap.containsKey(testMethodName);\n+    }\n+\n+    private IRMethod getIrMethod(String testMethodName) {\n+        return compilationsMap.get(testMethodName);\n+    }\n+\n+\n+\n+    private int getCompileId(String line) {\n+        Matcher matcher = COMPILE_ID_PATTERN.matcher(line);\n+        if (!matcher.find()) {\n+            throw new FileCorruptedException(\"Unexpected format found on this line: \" + line);\n+        }\n+        return Integer.parseInt(matcher.group(1));\n+    }\n+\n+    private boolean isTestMethodBlockStart(Line line, Map<Integer, IRMethod> compileIdMap) {\n+      return line.isBlockStart() && isTestClassMethodBlock(line, compileIdMap);\n+    }\n+\n+    private boolean isTestClassMethodBlock(Line line, Map<Integer, IRMethod> compileIdMap) {\n+        return compileIdMap.containsKey(getCompileId(line.getLine()));\n+    }\n+\n+    public void setIRMethodOutput(String blockOutput, Line blockStartLine, Map<Integer, IRMethod> compileIdMap) {\n+        IRMethod irMethod = compileIdMap.get(getCompileId(blockStartLine.getLine()));\n+        setIRMethodOutput(blockOutput, blockStartLine, irMethod);\n+    }\n+\n+    private void setIRMethodOutput(String blockOutput, Line blockStartLine, IRMethod irMethod) {\n+        if (blockStartLine.isPrintIdealStart()) {\n+            irMethod.setIdealOutput(blockOutput);\n+        } else {\n+            irMethod.setOptoAssemblyOutput(blockOutput);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/HotSpotPidFileParser.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.test.IREncodingPrinter;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class to parse the IR encoding emitted by the test VM and creating {@link IRMethod} objects for each entry.\n+ *\n+ * @see IRMethod\n+ *\/\n+class IREncodingParser {\n+\n+    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n+    private static final Pattern IR_ENCODING_PATTERN =\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n).*\\\\R([\\\\s\\\\S]*)(?=\" + IREncodingPrinter.END + \")\");\n+\n+    private final Map<String, IRMethod> compilations;\n+    private final Class<?> testClass;\n+\n+    public IREncodingParser(Class<?> testClass) {\n+        this.testClass = testClass;\n+        this.compilations = new HashMap<>();\n+    }\n+\n+    public Map<String, IRMethod> parseIRMethods(String irEncoding) {\n+        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n+            System.out.println(\"Read IR encoding from test VM:\");\n+            System.out.println(irEncoding);\n+        }\n+        createCompilationsMap(irEncoding, testClass);\n+        \/\/ We could have found format errors in @IR annotations. Report them now with an exception.\n+        TestFormat.throwIfAnyFailures();\n+        return compilations;\n+    }\n+\n+    \/**\n+     * Sets up a map testname -> IRMethod (containing the PrintIdeal and PrintOptoAssembly output for testname).\n+     *\/\n+    private void createCompilationsMap(String irEncoding, Class<?> testClass) {\n+        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n+        createIRMethodsWithEncoding(testClass, irRulesMap);\n+    }\n+\n+    \/**\n+     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n+     *\/\n+    private Map<String, int[]> parseIREncoding(String irEncoding) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        String[] irEncodingLines = getIREncodingLines(irEncoding);\n+        for (String s : irEncodingLines) {\n+            String line = s.trim();\n+            String[] splitLine = line.split(\",\");\n+            if (splitLine.length < 2) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitLine[0]);\n+            }\n+            String testName = splitLine[0];\n+            int[] irRulesIdx = getRuleIndexes(splitLine);\n+            irRulesMap.put(testName, irRulesIdx);\n+        }\n+        return irRulesMap;\n+    }\n+\n+    \/**\n+     * Parse the IR encoding lines without header, explanation line and footer and return them in an array.\n+     *\/\n+    private String[] getIREncodingLines(String irEncoding) {\n+        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n+        TestFramework.check(matcher.find(), \"Did not find IR encoding\");\n+        String lines = matcher.group(1).trim();\n+        if (lines.isEmpty()) {\n+            \/\/ Nothing to IR match.\n+            return new String[0];\n+        }\n+        return lines.split(\"\\\\R\");\n+    }\n+\n+    \/**\n+     * Parse rule indexes from IR encoding line of the format: <method,idx1,idx2,...>\n+     *\/\n+    private int[] getRuleIndexes(String[] splitLine) {\n+        int[] irRulesIdx = new int[splitLine.length - 1];\n+        for (int i = 1; i < splitLine.length; i++) {\n+            try {\n+                irRulesIdx[i - 1] = Integer.parseInt(splitLine[i]);\n+            } catch (NumberFormatException e) {\n+                throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitLine[i]);\n+            }\n+        }\n+        return irRulesIdx;\n+    }\n+\n+    private void createIRMethodsWithEncoding(Class<?> testClass, Map<String, int[]> irRulesMap) {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+            if (irAnnos.length > 0) {\n+                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n+                int[] irRuleIds = irRulesMap.get(m.getName());\n+                validateIRRuleIds(m, irAnnos, irRuleIds);\n+                if (hasAnyApplicableIRRules(irRuleIds)) {\n+                    compilations.put(m.getName(), new IRMethod(m, irRuleIds, irAnnos));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void validateIRRuleIds(Method m, IR[] irAnnos, int[] ids) {\n+        TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n+        TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n+        TestFramework.check((ids[0] >= 1 || ids[0] == IREncodingPrinter.NO_RULE_APPLIED)\n+                            && ids[ids.length - 1] <= irAnnos.length,\n+                            \"Invalid IR rule index found in validIrRulesMap for \" + m);\n+    }\n+\n+    \/**\n+     * Does the list of IR rules contain any applicable IR rules for the given conditions?\n+     *\/\n+    private boolean hasAnyApplicableIRRules(int[] irRuleIds) {\n+        return irRuleIds[0] != IREncodingPrinter.NO_RULE_APPLIED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IREncodingParser.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.driver.irmatching.irmethod.IRMethod;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+\/**\n+ * Class to parse the PrintIdeal and PrintOptoAssembly outputs of the test class and store them into a collection\n+ * of dedicated IRMethod objects used throughout IR matching.\n+ *\n+ * @see IRMethod\n+ *\/\n+public class IRMethodParser {\n+    private final IREncodingParser irEncodingParser;\n+    private final HotSpotPidFileParser hotSpotPidFileParser;\n+\n+    public IRMethodParser(Class<?> testClass) {\n+        this.irEncodingParser = new IREncodingParser(testClass);\n+        this.hotSpotPidFileParser = new HotSpotPidFileParser(testClass.getName());\n+    }\n+\n+    \/**\n+     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n+     * Return null if there are no applicable @IR rules in any method of the test class.\n+     *\/\n+    public Collection<IRMethod> parse(String hotspotPidFileName, String irEncoding) {\n+        Map<String, IRMethod> compilationsMap = irEncodingParser.parseIRMethods(irEncoding);\n+        if (!compilationsMap.isEmpty()) {\n+            hotSpotPidFileParser.setCompilationsMap(compilationsMap);\n+            return hotSpotPidFileParser.parseCompilations(hotspotPidFileName);\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodParser.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import java.io.BufferedReader;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class representing a normal line read from the hotspot_pid* file.\n+ *\/\n+class Line extends AbstractLine {\n+    private final Pattern compileIdPatternForTestClass;\n+\n+    public Line(BufferedReader reader, Pattern compileIdPatternForTestClass) {\n+        super(reader);\n+        this.compileIdPatternForTestClass = compileIdPatternForTestClass;\n+    }\n+\n+    \/**\n+     * Is this line a start of a @Test annotated method? We only care about test class entries. There might be non-class\n+     * entries as well if user specified additional compile commands. Ignore these.\n+     *\/\n+    public boolean isTestClassCompilation() {\n+        if (isCompilation()) {\n+            Matcher matcher = compileIdPatternForTestClass.matcher(line);\n+            return matcher.find();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Is this header a C2 non-OSR compilation header entry?\n+     *\/\n+    public boolean isCompilation() {\n+        return line.startsWith(\"<task_queued\") && notOSRCompilation() && notC2Compilation();\n+    }\n+\n+    \/**\n+     * OSR compilations have compile_kind set.\n+     *\/\n+    private boolean notOSRCompilation() {\n+        return !line.contains(\"compile_kind='\");\n+    }\n+\n+    \/**\n+     * Non-C2 compilations have level set.\n+     *\/\n+    private boolean notC2Compilation() {\n+        return !line.contains(\"level='\");\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintIdeal or PrintOptoAssembly output block?\n+     *\/\n+    public boolean isBlockStart() {\n+        return isPrintIdealStart() || isPrintOptoAssemblyStart();\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintIdeal output block?\n+     *\/\n+    public boolean isPrintIdealStart() {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<ideal\") && notOSRCompilation();\n+    }\n+\n+    \/**\n+     * Is this line a start of a PrintOptoAssembly output block?\n+     *\/\n+    private boolean isPrintOptoAssemblyStart() {\n+        \/\/ Ignore OSR compilations which have compile_kind set.\n+        return line.startsWith(\"<opto_assembly\") && notOSRCompilation();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/Line.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+\/**\n+ * Comparison result of parsing a constraint with {@link ComparisonConstraintParser#parse(String, Function, String)}.\n+ *\/\n+public class Comparison<T extends Comparable<T>> {\n+    private final T givenValue; \/\/ Right hand side\n+    private final BiPredicate<T, T> comparisonPredicate;\n+    private final String comparator;\n+\n+    public Comparison(T givenValue, String comparator, BiPredicate<T, T> comparisonPredicate) {\n+        this.givenValue = givenValue;\n+        this.comparator = comparator;\n+        this.comparisonPredicate = comparisonPredicate;\n+    }\n+\n+    public T getGivenValue() {\n+        return givenValue;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+\n+    \/**\n+     * Comparison: foundValue OP givenValue\n+     *\/\n+    public boolean compare(T foundValue) {\n+        return comparisonPredicate.test(foundValue, givenValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/Comparison.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+\/**\n+ * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n+ *\/\n+public class ComparisonConstraintParser<T extends Comparable<T>> {\n+\n+    private enum Comparator {\n+        ONE_CHAR, TWO_CHARS\n+    }\n+\n+    public static <T extends Comparable<T>> Comparison<T> parse(String constraint, Function<String, T> parseFunction,\n+                                                                String postfixErrorMsg) {\n+        try {\n+            return parseConstraintAndValue(constraint, parseFunction);\n+        } catch (EmptyConstraintException e) {\n+            TestFormat.fail(\"Provided empty value \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (MissingConstraintValueException e) {\n+            TestFormat.fail(\"Provided empty value after comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (InvalidComparatorException e) {\n+            TestFormat.fail(\"Provided invalid comparator \\\"\" + e.getComparator() + \"\\\" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        } catch (InvalidConstraintValueException e) {\n+            String comparator = e.getComparator();\n+            if (!comparator.isEmpty()) {\n+                comparator = \" after comparator \\\"\" + comparator + \"\\\"\";\n+            }\n+            TestFormat.fail(\"Provided invalid value \\\"\" + e.getInvalidValue() + \"\\\"\"\n+                                   + comparator + \" \" + postfixErrorMsg);\n+            throw new UnreachableCodeException();\n+        }\n+    }\n+\n+    private static <T extends Comparable<T>> Comparison<T> parseConstraintAndValue(String constraint,\n+                                                                                   Function<String, T> parseFunction) throws\n+            EmptyConstraintException, MissingConstraintValueException,\n+            InvalidComparatorException, InvalidConstraintValueException {\n+        ParsedResult<T> result = parse(constraint);\n+        T givenValue = parseGivenValue(parseFunction, result);\n+        return new Comparison<>(givenValue, result.comparator, result.comparisonPredicate);\n+    }\n+\n+    private static <T extends Comparable<T>> ParsedResult<T> parse(String constraint) throws\n+            EmptyConstraintException, MissingConstraintValueException, InvalidComparatorException {\n+        constraint = constraint.trim();\n+        if (constraint.isEmpty()) {\n+            throw new EmptyConstraintException();\n+        }\n+        switch (constraint.charAt(0)) {\n+            case '<' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) == '=') {\n+                    throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                    return new ParsedResult<>(constraint.substring(2).trim(), \"<=\", (x, y) -> x.compareTo(y) <= 0);\n+                } else {\n+                    return new ParsedResult<>(constraint.substring(1).trim(), \"<\", (x, y) -> x.compareTo(y) < 0);\n+                }\n+            }\n+            case '>' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) == '=') {\n+                    throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                    return new ParsedResult<>(constraint.substring(2).trim(), \">=\", (x, y) -> x.compareTo(y) >= 0);\n+                } else {\n+                    return new ParsedResult<>(constraint.substring(1).trim(), \">\", (x, y) -> x.compareTo(y) > 0);\n+                }\n+            }\n+            case '!' -> {\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                if (constraint.charAt(1) != '=') {\n+                    throw new InvalidComparatorException(\"!\");\n+                }\n+                throwIfNoValueAfterComparator(constraint, Comparator.TWO_CHARS);\n+                return new ParsedResult<>(constraint.substring(2).trim(), \"!=\", (x, y) -> x.compareTo(y) != 0);\n+            }\n+            case '=' -> { \/\/ Allowed syntax, equivalent to not using any symbol.\n+                throwIfNoValueAfterComparator(constraint, Comparator.ONE_CHAR);\n+                return new ParsedResult<>(constraint.substring(1).trim(), \"=\", (x, y) -> x.compareTo(y) == 0);\n+            }\n+            default -> {\n+                return new ParsedResult<>(constraint.trim(), \"=\", (x, y) -> x.compareTo(y) == 0);\n+            }\n+        }\n+    }\n+\n+    private static void throwIfNoValueAfterComparator(String constraint, Comparator comparator) throws MissingConstraintValueException {\n+        switch (comparator) {\n+            case ONE_CHAR -> {\n+                if (constraint.length() == 1) {\n+                    throw new MissingConstraintValueException(constraint);\n+                }\n+            }\n+            case TWO_CHARS -> {\n+                if (constraint.length() == 2) {\n+                    throw new MissingConstraintValueException(constraint);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static <T extends Comparable<T>> T parseGivenValue(Function<String, T> parseFunction, ParsedResult<T> result)\n+            throws InvalidConstraintValueException {\n+        try {\n+            return parseFunction.apply(result.value);\n+        }\n+        catch (NumberFormatException e) {\n+            throw new InvalidConstraintValueException(result.value, result.comparator);\n+        }\n+    }\n+\n+    static class ParsedResult<T> {\n+        public String value;\n+        public BiPredicate<T, T> comparisonPredicate;\n+        public String comparator;\n+\n+        public ParsedResult(String value, String comparator,BiPredicate<T, T> comparisonPredicate) {\n+            this.value = value;\n+            this.comparator = comparator;\n+            this.comparisonPredicate = comparisonPredicate;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ComparisonConstraintParser.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} cannot find a constraint.\n+ *\/\n+class EmptyConstraintException extends Exception {\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/EmptyConstraintException.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception threw when {@link ComparisonConstraintParser} parses an invalid comparator.\n+ *\/\n+public class InvalidComparatorException extends Exception {\n+    private final String comparator;\n+\n+    public InvalidComparatorException(String comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/InvalidComparatorException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} parses an invalid value.\n+ *\/\n+class InvalidConstraintValueException extends Exception {\n+    private final String invalidValue;\n+    private final String comparator;\n+\n+    public InvalidConstraintValueException(String invalidValue, String comparator) {\n+        this.invalidValue = invalidValue;\n+        this.comparator = comparator;\n+    }\n+\n+    public String getInvalidValue() {\n+        return invalidValue;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/InvalidConstraintValueException.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception thrown when {@link ComparisonConstraintParser} cannot find a value in a constraint after a comparator.\n+ *\/\n+class MissingConstraintValueException extends Exception {\n+    private final String comparator;\n+\n+    public MissingConstraintValueException(String comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    public String getComparator() {\n+        return comparator;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/MissingConstraintValueException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.shared;\n-\n-import java.util.function.BiPredicate;\n-\n-\/**\n- * Utility class to parse a comparator either in the applyIf* or in the counts properties of an @IR rules.\n- *\/\n-public class ParsedComparator<T extends Comparable<T>> {\n-    private final String strippedString;\n-    private final BiPredicate<T, T> predicate;\n-    private final String comparator;\n-\n-    public ParsedComparator(String strippedString, BiPredicate<T, T> predicate, String comparator) {\n-        this.strippedString = strippedString;\n-        this.predicate = predicate;\n-        this.comparator = comparator;\n-    }\n-\n-    public String getStrippedString() {\n-        return strippedString;\n-    }\n-\n-    public BiPredicate<T, T> getPredicate() {\n-        return predicate;\n-    }\n-\n-    public String getComparator() {\n-        return comparator;\n-    }\n-\n-    \/**\n-     * Return parsed comparator object which provides the predicate to perform the test.\n-     * Allowed comparators: <, <=, >, =>, =, !=\n-     *\/\n-    public static <T extends Comparable<T>> ParsedComparator<T> parseComparator(String value) throws CheckedTestFrameworkException {\n-        BiPredicate<T, T> comparison;\n-        value = value.trim();\n-        String comparator = \"\";\n-        switch (value.charAt(0)) {\n-            case '<':\n-                if (value.charAt(1) == '=') {\n-                    comparator = \"<=\";\n-                    comparison = (x, y) -> x.compareTo(y) <= 0;\n-                    value = value.substring(2).trim();\n-                } else {\n-                    comparator = \"<\";\n-                    comparison = (x, y) -> x.compareTo(y) < 0;\n-                    value = value.substring(1).trim();\n-                }\n-                break;\n-            case '>':\n-                if (value.charAt(1) == '=') {\n-                    comparator = \">=\";\n-                    comparison = (x, y) -> x.compareTo(y) >= 0;\n-                    value = value.substring(2).trim();\n-                } else {\n-                    comparator = \">\";\n-                    comparison = (x, y) -> x.compareTo(y) > 0;\n-                    value = value.substring(1).trim();\n-                }\n-                break;\n-            case '!':\n-                if (value.charAt(1) != '=') {\n-                    throw new CheckedTestFrameworkException(value.substring(0, 1));\n-                }\n-                comparator = \"!=\";\n-                comparison = (x, y) -> x.compareTo(y) != 0;\n-                value = value.substring(2).trim();\n-                break;\n-            case '=': \/\/ Allowed syntax, equivalent to not using any symbol.\n-                comparator = \"=\";\n-                value = value.substring(1).trim();\n-                \/\/ Fall through\n-            default:\n-                comparison = (x, y) -> x.compareTo(y) == 0;\n-                value = value.trim();\n-                break;\n-        }\n-        return new ParsedComparator<>(value, comparison, comparator);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ParsedComparator.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    public static void reportIfAnyFailures() {\n+    public static void throwIfAnyFailures() {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * The error reporting of the IR framework is throwing exceptions unconditionally in separate methods. The calling methods,\n+ * however, do not see these exceptions. As a result, Java and\/or some IDEs could complain about impossible states\n+ * (e.g. uninitialized variables, null pointer dereferences etc. even though an exception will be thrown earlier).\n+ * To avoid that, throw an instance of this class instead.\n+ *\/\n+class UnreachableCodeException extends RuntimeException {\n+    public UnreachableCodeException() {\n+        super(\"Unreachable code\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/UnreachableCodeException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * and checked by the IRMatcher class in the driver VM after the termination of the test VM.\n+ * and checked by the IRMatcher class in the driver VM after the termination of the test VM. IR rule indices start at 1.\n@@ -76,1 +76,1 @@\n-                        validRules.add(i);\n+                        validRules.add(ruleIndex);\n@@ -209,1 +209,1 @@\n-            return checkLongFlag(flag, value, (Long) actualFlagValue);\n+            return checkFlag(Long::parseLong, \"integer\", flag, value, (Long) actualFlagValue);\n@@ -213,1 +213,1 @@\n-            return checkDoubleFlag(flag, value, (Double) actualFlagValue);\n+            return checkFlag(Double::parseDouble, \"floating point\", flag, value, (Double) actualFlagValue);\n@@ -245,3 +245,2 @@\n-    private boolean checkLongFlag(String flag, String value, long actualFlagValue) {\n-        long longValue;\n-        ParsedComparator<Long> parsedComparator;\n+    private <T extends Comparable<T>> boolean checkFlag(Function<String, T> parseFunction, String kind, String flag,\n+                                                        String value, T actualFlagValue) {\n@@ -249,43 +248,5 @@\n-            parsedComparator = ParsedComparator.parseComparator(value);\n-        } catch (CheckedTestFrameworkException e) {\n-            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for integer based flag \" + flag + failAt());\n-            return false;\n-        }  catch (IndexOutOfBoundsException e) {\n-            TestFormat.failNoThrow(\"Provided empty value for integer based flag \" + flag + failAt());\n-            return false;\n-        }\n-        try {\n-            longValue = Long.parseLong(parsedComparator.getStrippedString());\n-        } catch (NumberFormatException e) {\n-            String comparator = parsedComparator.getComparator();\n-            if (!comparator.isEmpty()) {\n-                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n-            }\n-            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n-                            + comparator + \" for integer based flag \" + flag + failAt());\n-            return false;\n-        }\n-        return parsedComparator.getPredicate().test(actualFlagValue, longValue);\n-    }\n-\n-    private boolean checkDoubleFlag(String flag, String value, double actualFlagValue) {\n-        double doubleValue;\n-        ParsedComparator<Double> parsedComparator;\n-        try {\n-            parsedComparator = ParsedComparator.parseComparator(value);\n-        } catch (CheckedTestFrameworkException e) {\n-            TestFormat.failNoThrow(\"Invalid comparator in \\\"\" + value + \"\\\" for floating point based flag \" + flag + failAt());\n-            return false;\n-        } catch (IndexOutOfBoundsException e) {\n-            TestFormat.failNoThrow(\"Provided empty value for floating point based flag \" + flag + failAt());\n-            return false;\n-        }\n-        try {\n-            doubleValue = Double.parseDouble(parsedComparator.getStrippedString());\n-        } catch (NumberFormatException e) {\n-            String comparator = parsedComparator.getComparator();\n-            if (!comparator.isEmpty()) {\n-                comparator = \"after comparator \\\"\" + parsedComparator.getComparator() + \"\\\"\";\n-            }\n-            TestFormat.failNoThrow(\"Invalid value \\\"\" + parsedComparator.getStrippedString() + \"\\\" \"\n-                    + comparator + \" for floating point based flag \" + flag + failAt());\n+            String postFixErrorMsg = \"for \" + kind + \" based flag \\\"\" + flag + \"\\\"\" + failAt();\n+            Comparison<T> comparison = ComparisonConstraintParser.parse(value, parseFunction, postFixErrorMsg);\n+            return comparison.compare(actualFlagValue);\n+        } catch (TestFormatException e) {\n+            \/\/ Format exception, do not apply rule.\n@@ -294,1 +255,0 @@\n-        return parsedComparator.getPredicate().test(actualFlagValue, doubleValue);\n@@ -298,1 +258,1 @@\n-        return \" for @IR rule \" + ruleIndex + \" at \" + method;\n+        return \" in @IR rule \" + ruleIndex + \" at \" + method;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":13,"deletions":53,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,1 @@\n-        TestFormat.reportIfAnyFailures();\n+        TestFormat.throwIfAnyFailures();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Asserts;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestMaskedMacroLogicVector.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/examples\/IRExample.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCheckedTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestCompileThreshold.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n@@ -63,1 +63,1 @@\n-        exceptions.put(e, baos.toString() + System.lineSeparator() + baosErr.toString());\n+        exceptions.put(e, baos + System.lineSeparator() + baosErr);\n@@ -288,1 +288,1 @@\n-        findIrIds(output, \"testMatchAllIf50\", 0, 21);\n+        findIrIds(output, \"testMatchAllIf50\", 1, 22);\n@@ -294,2 +294,2 @@\n-        findIrIds(output, \"testMatchAllIf50\", 4, 6, 13, 18);\n-        findIrIds(output, \"testMatchNoneIf50\", 0, 3, 8, 10, 17, 22);\n+        findIrIds(output, \"testMatchAllIf50\", 5, 7, 14, 19);\n+        findIrIds(output, \"testMatchNoneIf50\", 1, 4, 9, 11, 18, 23);\n@@ -300,2 +300,2 @@\n-        findIrIds(output, \"testMatchAllIf50\", 7, 12, 19, 21);\n-        findIrIds(output, \"testMatchNoneIf50\", 4, 7, 11, 16, 20, 22);\n+        findIrIds(output, \"testMatchAllIf50\", 8, 13, 20, 22);\n+        findIrIds(output, \"testMatchNoneIf50\", 5, 8, 12, 17, 21, 23);\n@@ -398,1 +398,1 @@\n-            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder.toString() + System.lineSeparator()));\n+            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder + System.lineSeparator()));\n@@ -553,1 +553,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"50\"}) \/\/ Index 1\n@@ -557,1 +557,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=50\"}) \/\/ Index 5\n@@ -560,1 +560,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 7\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=50\"}) \/\/ Index 8\n@@ -566,1 +566,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 13\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<51\"}) \/\/ Index 14\n@@ -574,1 +574,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 21\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  49\"}) \/\/ Index 22\n@@ -579,1 +579,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 0\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"49\"}) \/\/ Index 1\n@@ -583,1 +583,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 4\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"51\"}) \/\/ Index 5\n@@ -587,1 +587,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 8\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<=49\"}) \/\/ Index 9\n@@ -590,1 +590,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 11\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \">=51\"}) \/\/ Index 12\n@@ -596,1 +596,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 17\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \"<50\"}) \/\/ Index 18\n@@ -601,1 +601,1 @@\n-    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 22\n+    @IR(failOn = IRNode.CALL, applyIf = {\"TLABRefillWasteFraction\", \" !=  50\"}) \/\/ Index 23\n@@ -817,1 +817,1 @@\n-    @IR(counts = {IRNode.LOAD, \"!= 1\"})\n+    @IR(counts = {IRNode.LOAD, \"!= 1\"}) \/\/ fail\n@@ -824,1 +824,1 @@\n-    @IR(counts = {IRNode.LOAD, \"1\"})\n+    @IR(counts = {IRNode.LOAD, \"1\"}) \/\/ fail\n@@ -832,2 +832,2 @@\n-    @IR(counts = {IRNode.LOAD, \"0\"})\n-    @IR(counts = {IRNode.STORE, \" <= 0\"})\n+    @IR(counts = {IRNode.LOAD, \"0\"}) \/\/ fail\n+    @IR(counts = {IRNode.STORE, \" <= 0\"}) \/\/ fail\n@@ -1517,1 +1517,1 @@\n-        Asserts.assertTrue(matched, toString() + \" should have been matched\");\n+        Asserts.assertTrue(matched, this + \" should have been matched\");\n@@ -1735,1 +1735,1 @@\n-        matchesList.add(\"but found \" + foundCount);\n+        matchesList.add(\"Failed comparison: [found] \" + foundCount);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestRunTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import compiler.lib.ir_framework.driver.IRMatcher;\n-import compiler.lib.ir_framework.driver.TestVMProcess;\n+import compiler.lib.ir_framework.driver.irmatching.IRMatcher;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/Utils.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}