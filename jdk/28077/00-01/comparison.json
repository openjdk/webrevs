{"files":[{"patch":"@@ -146,1 +146,1 @@\n-                    output.matches (\"CompressedClassSpaceBaseAddress=0x[0-9a-f]* given with shift .*, cannot be used to encode class pointers\")) {\n+                    output.matches (\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given with shift .*, cannot be used to encode class pointers\")) {\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,0 +220,63 @@\n+        {\n+            \/\/ Multi-line output: OutputAnalyzer uses MULTILINE but not DOTALL, so \".\" doesn't match newline, but\n+            \/\/ \"^\" and \"$\" matches just after or just before, respectively, a newline.\n+            stdout = \"aaaaaa\\nxxxxxx\\n\";\n+            stderr = \"bbbbbb\\nyyyyyy\\n\";\n+\n+            OutputAnalyzer out = new OutputAnalyzer(stdout, stderr);\n+\n+            out.shouldMatch(\"aaa\");\n+            out.shouldMatch(\"xxx\");\n+            out.shouldMatch(\"bbb\");\n+            out.shouldMatch(\"yyy\");\n+\n+            out.stdoutShouldMatch(\"aaaaaa\");\n+            out.stdoutShouldMatch(\"xxxxxx\");\n+            out.stderrShouldMatch(\"bbbbbb\");\n+            out.stderrShouldMatch(\"yyyyyy\");\n+\n+            out.shouldMatch(\"^aaaaaa$\");\n+            out.shouldMatch(\"^xxxxxx$\");\n+            out.shouldMatch(\"^bbbbbb$\");\n+            out.shouldMatch(\"^yyyyyy$\");\n+\n+            out.stdoutShouldMatch(\"^aaaaaa$\");\n+            out.stdoutShouldMatch(\"^xxxxxx$\");\n+            out.stderrShouldMatch(\"^bbbbbb$\");\n+            out.stderrShouldMatch(\"^yyyyyy$\");\n+\n+            out.shouldMatch   (\"a.*\");\n+            out.shouldNotMatch(\"a.*x\");\n+            out.shouldMatch   (\"b.*\");\n+            out.shouldNotMatch(\"b.*y\");\n+            out.stdoutShouldMatch   (\"a.*\");\n+            out.stdoutShouldNotMatch(\"a.*x\");\n+            out.stderrShouldMatch   (\"b.*\");\n+            out.stderrShouldNotMatch(\"b.*y\");\n+\n+            check(out.matches(\"^aaaaaa$\"));\n+            check(out.matches(\"^yyyyyy$\"));\n+            check(out.stdoutMatches(\"^aaaaaa$\"));\n+            check(out.stderrMatches(\"^yyyyyy$\"));\n+\n+            check( out.matches(\"a.*\"));\n+            check(!out.matches(\"a.*x\"));\n+\n+            check( out.stdoutMatches(\"a.*\"));\n+            check(!out.stdoutMatches(\"a.*x\"));\n+\n+            check( out.stderrMatches(\"b.*\"));\n+            check(!out.stderrMatches(\"b.*y\"));\n+\n+            \/\/ Test the \"contains\" methods as well\n+            check(out.contains(\"aaa\\nxxx\"));\n+            check(out.contains(\"bbb\\nyyy\"));\n+            check(out.stdoutContains(\"aaa\\nxxx\"));\n+            check(out.stderrContains(\"bbb\\nyyy\"));\n+\n+            check(!out.contains(\"X\"));\n+            check(!out.contains(\"X\"));\n+            check(!out.stdoutContains(\"X\"));\n+            check(!out.stderrContains(\"X\"));\n+        }\n+\n@@ -247,0 +310,5 @@\n+    private static void check(boolean b) {\n+        if (!b) {\n+            throw new RuntimeException(\"Check failed\");\n+        }\n+    }\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/OutputAnalyzerTest.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -361,0 +361,4 @@\n+    \/\/ NOTE: The meaning of \"match\" in OutputAnalyzer is NOT the same as String.matches().\n+    \/\/ Rather it means \"can the pattern be found in stdout and\/or stderr\".\n+    \/\/ The pattern is comiled with MULTILINE but without DOTALL, so \".\" doesn't match newline, but\n+    \/\/ \"^\" and \"$\" matches just after or just before, respectively, a newline.\n@@ -395,6 +399,1 @@\n-        String stdout = getStdout();\n-        String stderr = getStderr();\n-        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n-        Matcher stdoutMatcher = pattern.matcher(stdout);\n-        Matcher stderrMatcher = pattern.matcher(stderr);\n-        if (!stdoutMatcher.find() && !stderrMatcher.find()) {\n+        if (!matches(regexp)) {\n@@ -416,3 +415,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (!matcher.find()) {\n+        if (!stdoutMatches(regexp)) {\n@@ -433,4 +430,2 @@\n-    public OutputAnalyzer stderrShouldMatch(String pattern) {\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);\n-        if (!matcher.find()) {\n+    public OutputAnalyzer stderrShouldMatch(String regexp) {\n+        if (!stderrMatches(regexp)) {\n@@ -438,1 +433,1 @@\n-            throw new RuntimeException(\"'\" + pattern\n+            throw new RuntimeException(\"'\" + regexp\n@@ -480,3 +475,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (matcher.find()) {\n+        if (stdoutMatches(regexp)) {\n@@ -498,3 +491,1 @@\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stderr);\n-        if (matcher.find()) {\n+        if (stderrMatches(regexp)) {\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"}]}