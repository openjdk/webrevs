{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,0 +220,63 @@\n+        {\n+            \/\/ Multi-line output: OutputAnalyzer uses MULTILINE but not DOTALL, so \".\" doesn't match newline, but\n+            \/\/ \"^\" and \"$\" matches just after or just before, respectively, a newline.\n+            stdout = \"aaaaaa\\nxxxxxx\\n\";\n+            stderr = \"bbbbbb\\nyyyyyy\\n\";\n+\n+            OutputAnalyzer out = new OutputAnalyzer(stdout, stderr);\n+\n+            out.shouldMatch(\"aaa\");\n+            out.shouldMatch(\"xxx\");\n+            out.shouldMatch(\"bbb\");\n+            out.shouldMatch(\"yyy\");\n+\n+            out.stdoutShouldMatch(\"aaaaaa\");\n+            out.stdoutShouldMatch(\"xxxxxx\");\n+            out.stderrShouldMatch(\"bbbbbb\");\n+            out.stderrShouldMatch(\"yyyyyy\");\n+\n+            out.shouldMatch(\"^aaaaaa$\");\n+            out.shouldMatch(\"^xxxxxx$\");\n+            out.shouldMatch(\"^bbbbbb$\");\n+            out.shouldMatch(\"^yyyyyy$\");\n+\n+            out.stdoutShouldMatch(\"^aaaaaa$\");\n+            out.stdoutShouldMatch(\"^xxxxxx$\");\n+            out.stderrShouldMatch(\"^bbbbbb$\");\n+            out.stderrShouldMatch(\"^yyyyyy$\");\n+\n+            out.shouldMatch   (\"a.*\");\n+            out.shouldNotMatch(\"a.*x\");\n+            out.shouldMatch   (\"b.*\");\n+            out.shouldNotMatch(\"b.*y\");\n+            out.stdoutShouldMatch   (\"a.*\");\n+            out.stdoutShouldNotMatch(\"a.*x\");\n+            out.stderrShouldMatch   (\"b.*\");\n+            out.stderrShouldNotMatch(\"b.*y\");\n+\n+            check(out.matches(\"^aaaaaa$\"));\n+            check(out.matches(\"^yyyyyy$\"));\n+            check(out.stdoutMatches(\"^aaaaaa$\"));\n+            check(out.stderrMatches(\"^yyyyyy$\"));\n+\n+            check( out.matches(\"a.*\"));\n+            check(!out.matches(\"a.*x\"));\n+\n+            check( out.stdoutMatches(\"a.*\"));\n+            check(!out.stdoutMatches(\"a.*x\"));\n+\n+            check( out.stderrMatches(\"b.*\"));\n+            check(!out.stderrMatches(\"b.*y\"));\n+\n+            \/\/ Test the \"contains\" methods as well\n+            check(out.contains(\"aaa\\nxxx\"));\n+            check(out.contains(\"bbb\\nyyy\"));\n+            check(out.stdoutContains(\"aaa\\nxxx\"));\n+            check(out.stderrContains(\"bbb\\nyyy\"));\n+\n+            check(!out.contains(\"X\"));\n+            check(!out.contains(\"X\"));\n+            check(!out.stdoutContains(\"X\"));\n+            check(!out.stderrContains(\"X\"));\n+        }\n+\n@@ -247,0 +310,5 @@\n+    private static void check(boolean b) {\n+        if (!b) {\n+            throw new RuntimeException(\"Check failed\");\n+        }\n+    }\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/OutputAnalyzerTest.java","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -357,0 +357,13 @@\n+    private boolean matchesHelper(String s, Pattern pattern) {\n+        return s != null && pattern.matcher(s).find();\n+    }\n+\n+    \/\/ NOTE: The meaning of \"match\" in OutputAnalyzer is NOT the same as String.matches().\n+    \/\/ Rather it means \"can the pattern be found in stdout and\/or stderr\".\n+    \/\/ The pattern is comiled with MULTILINE but without DOTALL, so \".\" doesn't match newline, but\n+    \/\/ \"^\" and \"$\" matches just after or just before, respectively, a newline.\n+    private boolean matchesHelper(String stdout, String stderr, String regexp) {\n+        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n+        return matchesHelper(stdout, pattern) || matchesHelper(stderr, pattern);\n+    }\n+\n@@ -361,1 +374,1 @@\n-        return getStdout().matches(regexp);\n+        return matchesHelper(getStdout(), null, regexp);\n@@ -368,1 +381,1 @@\n-        return getStderr().matches(regexp);\n+        return matchesHelper(null, getStderr(), regexp);\n@@ -375,1 +388,1 @@\n-        return stdoutMatches(regexp) || stderrMatches(regexp);\n+        return matchesHelper(getStdout(), getStderr(), regexp);\n@@ -386,6 +399,1 @@\n-        String stdout = getStdout();\n-        String stderr = getStderr();\n-        Pattern pattern = Pattern.compile(regexp, Pattern.MULTILINE);\n-        Matcher stdoutMatcher = pattern.matcher(stdout);\n-        Matcher stderrMatcher = pattern.matcher(stderr);\n-        if (!stdoutMatcher.find() && !stderrMatcher.find()) {\n+        if (!matches(regexp)) {\n@@ -407,3 +415,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (!matcher.find()) {\n+        if (!stdoutMatches(regexp)) {\n@@ -424,4 +430,2 @@\n-    public OutputAnalyzer stderrShouldMatch(String pattern) {\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);\n-        if (!matcher.find()) {\n+    public OutputAnalyzer stderrShouldMatch(String regexp) {\n+        if (!stderrMatches(regexp)) {\n@@ -429,1 +433,1 @@\n-            throw new RuntimeException(\"'\" + pattern\n+            throw new RuntimeException(\"'\" + regexp\n@@ -471,3 +475,1 @@\n-        String stdout = getStdout();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stdout);\n-        if (matcher.find()) {\n+        if (stdoutMatches(regexp)) {\n@@ -489,3 +491,1 @@\n-        String stderr = getStderr();\n-        Matcher matcher = Pattern.compile(regexp, Pattern.MULTILINE).matcher(stderr);\n-        if (matcher.find()) {\n+        if (stderrMatches(regexp)) {\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"}]}