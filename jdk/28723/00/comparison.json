{"files":[{"patch":"@@ -1333,1 +1333,0 @@\n-  _cm_thread(nullptr),\n@@ -1577,1 +1576,0 @@\n-  _cm_thread = _cm->cm_thread();\n@@ -1654,1 +1652,3 @@\n-  _cm_thread->stop();\n+  if (_cm->is_fully_initialized()) {\n+    _cm->cm_thread()->stop();\n+  }\n@@ -1851,1 +1851,1 @@\n-    _cm_thread->set_idle();\n+    _cm->cm_thread()->set_idle();\n@@ -2429,1 +2429,3 @@\n-  tc->do_thread(_cm_thread);\n+  if (_cm->is_fully_initialized()) {\n+    tc->do_thread(_cm->cm_thread());\n+  }\n@@ -2550,2 +2552,2 @@\n-  assert(!_cm_thread->in_progress(), \"Can not start concurrent operation while in progress\");\n-\n+  assert(!_cm->in_progress(), \"Can not start concurrent operation while in progress\");\n+  assert(_cm->is_fully_initialized(), \"sanity\");\n@@ -2555,1 +2557,1 @@\n-    _cm_thread->start_full_mark();\n+    _cm->cm_thread()->start_full_mark();\n@@ -2558,1 +2560,1 @@\n-    _cm_thread->start_undo_mark();\n+    _cm->cm_thread()->start_undo_mark();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -827,1 +827,0 @@\n-  G1ConcurrentMarkThread* _cm_thread;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  \/\/ _cm_thread set inside the constructor\n+  _cm_thread(nullptr),\n@@ -484,1 +484,1 @@\n-  \/\/ _finger set in set_non_marking_state\n+  _finger(nullptr), \/\/ _finger set in set_non_marking_state\n@@ -488,3 +488,2 @@\n-  \/\/ _num_active_tasks set in set_non_marking_state()\n-  \/\/ _tasks set inside the constructor\n-\n+  _num_active_tasks(0), \/\/ _num_active_tasks set in set_non_marking_state()\n+  _tasks(nullptr), \/\/ _tasks set inside late_init()\n@@ -524,0 +523,26 @@\n+}\n+\n+void G1ConcurrentMark::reset() {\n+  _has_aborted = false;\n+\n+  reset_marking_for_restart();\n+\n+  \/\/ Reset all tasks, since different phases will use different number of active\n+  \/\/ threads. So, it's easiest to have all of them ready.\n+  for (uint i = 0; i < _max_num_tasks; ++i) {\n+    _tasks[i]->reset(mark_bitmap());\n+  }\n+\n+  uint max_num_regions = _g1h->max_num_regions();\n+  for (uint i = 0; i < max_num_regions; i++) {\n+    _top_at_rebuild_starts[i] = nullptr;\n+    _region_mark_stats[i].clear();\n+  }\n+\n+  _root_regions.reset();\n+}\n+\n+void G1ConcurrentMark::fully_initialize() {\n+  if (is_fully_initialized()) {\n+    return;\n+  }\n@@ -559,18 +584,2 @@\n-void G1ConcurrentMark::reset() {\n-  _has_aborted = false;\n-\n-  reset_marking_for_restart();\n-\n-  \/\/ Reset all tasks, since different phases will use different number of active\n-  \/\/ threads. So, it's easiest to have all of them ready.\n-  for (uint i = 0; i < _max_num_tasks; ++i) {\n-    _tasks[i]->reset(mark_bitmap());\n-  }\n-\n-  uint max_num_regions = _g1h->max_num_regions();\n-  for (uint i = 0; i < max_num_regions; i++) {\n-    _top_at_rebuild_starts[i] = nullptr;\n-    _region_mark_stats[i].clear();\n-  }\n-\n-  _root_regions.reset();\n+bool G1ConcurrentMark::in_progress() const {\n+  return is_fully_initialized() ? _cm_thread->in_progress() : false;\n@@ -741,1 +750,1 @@\n-        assert(!suspendible() || _cm->cm_thread()->in_progress(), \"invariant\");\n+        assert(!suspendible() || _cm->in_progress(), \"invariant\");\n@@ -797,1 +806,2 @@\n-  guarantee(cm_thread()->in_progress(), \"invariant\");\n+  guarantee(is_fully_initialized(), \"should be initializd\");\n+  guarantee(in_progress(), \"invariant\");\n@@ -808,1 +818,2 @@\n-  guarantee(cm_thread()->in_progress(), \"invariant\");\n+  guarantee(is_fully_initialized(), \"should be initializd\");\n+  guarantee(in_progress(), \"invariant\");\n@@ -1886,1 +1897,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n+  if (!is_fully_initialized() || (!cm_thread()->in_progress() && !_g1h->is_shutting_down())) {\n@@ -1948,0 +1959,4 @@\n+  if (!is_fully_initialized()) {\n+    log.trace(\"    has not been initialized yet\");\n+    return;\n+  }\n@@ -1964,1 +1979,3 @@\n-  _concurrent_workers->threads_do(tc);\n+  if (is_fully_initialized()) { \/\/ they are initialized late\n+    _concurrent_workers->threads_do(tc);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":45,"deletions":28,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -585,0 +585,4 @@\n+  void fully_initialize();\n+  bool is_fully_initialized() const { return _cm_thread != nullptr; }\n+  bool in_progress() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+  \/\/ We should not start a concurrent gc if concurrent marking has not been initialized yet\n+  if (!g1h->concurrent_mark()->is_fully_initialized()) {\n+    log_debug(gc, periodic)(\"Concurrent marking has not been initialized. Skipping.\");\n+    return false;\n+  }\n+\n@@ -42,1 +48,1 @@\n-  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n+  if (g1h->concurrent_mark()->in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -743,1 +743,4 @@\n-  return _g1h->concurrent_mark()->cm_thread()->in_progress() || collector_state()->in_young_gc_before_mixed();\n+  if (!_g1h->concurrent_mark()->is_fully_initialized()) {\n+    return false;\n+  }\n+  return _g1h->concurrent_mark()->in_progress() || collector_state()->in_young_gc_before_mixed();\n@@ -1242,1 +1245,1 @@\n-  bool during_cycle = _g1h->concurrent_mark()->cm_thread()->in_progress();\n+  bool during_cycle = _g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+  _cache(NEW_C_HEAP_ARRAY(G1RegionMarkStatsCacheEntry, num_cache_entries, mtGC)),\n@@ -37,1 +38,0 @@\n-  _cache = NEW_C_HEAP_ARRAY(G1RegionMarkStatsCacheEntry, _num_cache_entries, mtGC);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  _cycle_already_in_progress = g1h->concurrent_mark()->cm_thread()->in_progress();\n+  _cycle_already_in_progress = g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1127,0 +1127,1 @@\n+  _g1h->_cm->fully_initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-    return g1h->concurrent_mark()->cm_thread()->in_progress();\n+    return g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}