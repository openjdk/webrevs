{"files":[{"patch":"@@ -1323,1 +1323,0 @@\n-  _cm_thread(nullptr),\n@@ -1567,1 +1566,0 @@\n-  _cm_thread = _cm->cm_thread();\n@@ -1639,1 +1637,3 @@\n-  return _cm_thread->should_terminate();\n+  assert(_cm != nullptr, \"_cm must have been created\");\n+  assert(_cm->is_fully_initialized(), \"thread must exist in order to check if mark is terminating\");\n+  return _cm->cm_thread()->should_terminate();\n@@ -1648,1 +1648,3 @@\n-  _cm_thread->stop();\n+  if (_cm->is_fully_initialized()) {\n+    _cm->cm_thread()->stop();\n+  }\n@@ -1845,1 +1847,1 @@\n-    _cm_thread->set_idle();\n+    _cm->cm_thread()->set_idle();\n@@ -2424,1 +2426,0 @@\n-  tc->do_thread(_cm_thread);\n@@ -2545,2 +2546,2 @@\n-  assert(!_cm_thread->in_progress(), \"Can not start concurrent operation while in progress\");\n-\n+  assert(_cm->is_fully_initialized(), \"sanity\");\n+  assert(!_cm->in_progress(), \"Can not start concurrent operation while in progress\");\n@@ -2550,1 +2551,1 @@\n-    _cm_thread->start_full_mark();\n+    _cm->cm_thread()->start_full_mark();\n@@ -2553,1 +2554,1 @@\n-    _cm_thread->start_undo_mark();\n+    _cm->cm_thread()->start_undo_mark();\n@@ -2729,0 +2730,2 @@\n+  _cm->fully_initialize();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -827,1 +827,0 @@\n-  G1ConcurrentMarkThread* _cm_thread;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  \/\/ _cm_thread set inside the constructor\n+  _cm_thread(nullptr),\n@@ -484,1 +484,1 @@\n-  \/\/ _finger set in set_non_marking_state\n+  _finger(nullptr), \/\/ _finger set in set_non_marking_state\n@@ -488,3 +488,2 @@\n-  \/\/ _num_active_tasks set in set_non_marking_state()\n-  \/\/ _tasks set inside the constructor\n-\n+  _num_active_tasks(0), \/\/ _num_active_tasks set in set_non_marking_state()\n+  _tasks(nullptr), \/\/ _tasks set inside late_init()\n@@ -524,0 +523,26 @@\n+}\n+\n+void G1ConcurrentMark::reset() {\n+  _has_aborted = false;\n+\n+  reset_marking_for_restart();\n+\n+  \/\/ Reset all tasks, since different phases will use different number of active\n+  \/\/ threads. So, it's easiest to have all of them ready.\n+  for (uint i = 0; i < _max_num_tasks; ++i) {\n+    _tasks[i]->reset(mark_bitmap());\n+  }\n+\n+  uint max_num_regions = _g1h->max_num_regions();\n+  for (uint i = 0; i < max_num_regions; i++) {\n+    _top_at_rebuild_starts[i] = nullptr;\n+    _region_mark_stats[i].clear();\n+  }\n+\n+  _root_regions.reset();\n+}\n+\n+void G1ConcurrentMark::fully_initialize() {\n+  if (is_fully_initialized()) {\n+    return;\n+  }\n@@ -559,18 +584,2 @@\n-void G1ConcurrentMark::reset() {\n-  _has_aborted = false;\n-\n-  reset_marking_for_restart();\n-\n-  \/\/ Reset all tasks, since different phases will use different number of active\n-  \/\/ threads. So, it's easiest to have all of them ready.\n-  for (uint i = 0; i < _max_num_tasks; ++i) {\n-    _tasks[i]->reset(mark_bitmap());\n-  }\n-\n-  uint max_num_regions = _g1h->max_num_regions();\n-  for (uint i = 0; i < max_num_regions; i++) {\n-    _top_at_rebuild_starts[i] = nullptr;\n-    _region_mark_stats[i].clear();\n-  }\n-\n-  _root_regions.reset();\n+bool G1ConcurrentMark::in_progress() const {\n+  return is_fully_initialized() ? _cm_thread->in_progress() : false;\n@@ -741,1 +750,1 @@\n-        assert(!suspendible() || _cm->cm_thread()->in_progress(), \"invariant\");\n+        assert(!suspendible() || _cm->in_progress(), \"invariant\");\n@@ -797,1 +806,2 @@\n-  guarantee(cm_thread()->in_progress(), \"invariant\");\n+  guarantee(is_fully_initialized(), \"should be initializd\");\n+  guarantee(in_progress(), \"invariant\");\n@@ -808,1 +818,2 @@\n-  guarantee(cm_thread()->in_progress(), \"invariant\");\n+  guarantee(is_fully_initialized(), \"should be initializd\");\n+  guarantee(in_progress(), \"invariant\");\n@@ -1886,1 +1897,2 @@\n-  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n+\n+  if (!is_fully_initialized() || (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating())) {\n@@ -1948,0 +1960,4 @@\n+  if (!is_fully_initialized()) {\n+    log.trace(\"    has not been initialized yet\");\n+    return;\n+  }\n@@ -1964,1 +1980,4 @@\n-  _concurrent_workers->threads_do(tc);\n+  if (is_fully_initialized()) { \/\/ they are initialized late\n+    tc->do_thread(_cm_thread);\n+    _concurrent_workers->threads_do(tc);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":47,"deletions":28,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -585,0 +585,4 @@\n+  void fully_initialize();\n+  bool is_fully_initialized() const { return _cm_thread != nullptr; }\n+  bool in_progress() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  if (g1h->concurrent_mark()->cm_thread()->in_progress()) {\n+  if (g1h->concurrent_mark()->in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-  return _g1h->concurrent_mark()->cm_thread()->in_progress() || collector_state()->in_young_gc_before_mixed();\n+  return _g1h->concurrent_mark()->in_progress() || collector_state()->in_young_gc_before_mixed();\n@@ -1238,1 +1238,1 @@\n-  bool during_cycle = _g1h->concurrent_mark()->cm_thread()->in_progress();\n+  bool during_cycle = _g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+  _cache(NEW_C_HEAP_ARRAY(G1RegionMarkStatsCacheEntry, num_cache_entries, mtGC)),\n@@ -37,1 +38,0 @@\n-  _cache = NEW_C_HEAP_ARRAY(G1RegionMarkStatsCacheEntry, _num_cache_entries, mtGC);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  _cycle_already_in_progress = g1h->concurrent_mark()->cm_thread()->in_progress();\n+  _cycle_already_in_progress = g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,0 +96,14 @@\n+bool WorkerThreads::allow_inject_creation_failure() const {\n+  if (!is_init_completed()) {\n+    \/\/ Never allow creation failures during VM init\n+    return false;\n+  }\n+\n+  if (_created_workers == 0) {\n+    \/\/ Never allow creation failures of the first worker, it will cause the VM to exit\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -97,1 +111,1 @@\n-  if (is_init_completed() && InjectGCWorkerCreationFailure) {\n+  if (InjectGCWorkerCreationFailure && allow_inject_creation_failure()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  bool allow_inject_creation_failure() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-    return g1h->concurrent_mark()->cm_thread()->in_progress();\n+    return g1h->concurrent_mark()->in_progress();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}