{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,5 +217,13 @@\n-static bool shared_base_too_high(char* specified_base, char* aligned_base, size_t cds_max) {\n-  if (specified_base != nullptr && aligned_base < specified_base) {\n-    \/\/ SharedBaseAddress is very high (e.g., 0xffffffffffffff00) so\n-    \/\/ align_up(SharedBaseAddress, MetaspaceShared::core_region_alignment()) has wrapped around.\n-    return true;\n+\/\/ If p is not aligned, move it up to the next address that's aligned with alignment.\n+\/\/ If this is not possible (because p is too high), return nullptr. Example:\n+\/\/     p = 0xffffffffffff0000, alignment= 0x10000    => return nullptr.\n+static char* align_up_or_null(char* p, size_t alignment) {\n+  assert(p != nullptr, \"sanity\");\n+  if (is_aligned(p, alignment)) {\n+    return p;\n+  }\n+\n+  char* down = align_down(p, alignment);\n+  if (max_uintx - uintx(down) < uintx(alignment)) {\n+    \/\/ Run out of address space to align up.\n+    return nullptr;\n@@ -223,0 +231,13 @@\n+\n+  char* aligned = align_up(p, alignment);\n+  assert(aligned >= p, \"sanity\");\n+  assert(aligned != nullptr, \"sanity\");\n+  return aligned;\n+}\n+\n+static bool shared_base_too_high(char* specified_base, char* aligned_base, size_t cds_max) {\n+  \/\/ Caller should have checked if align_up_or_null( returns nullptr (comparing specified_base\n+  \/\/ with nullptr is UB).\n+  assert(aligned_base != nullptr, \"sanity\");\n+  assert(aligned_base >= specified_base, \"sanity\");\n+\n@@ -224,1 +245,1 @@\n-    \/\/ The end of the archive will wrap around\n+    \/\/ Not enough address space to hold an archive of cds_max bytes from aligned_base.\n@@ -226,0 +247,2 @@\n+  } else {\n+    return false;\n@@ -227,2 +250,0 @@\n-\n-  return false;\n@@ -233,1 +254,1 @@\n-  char* aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n+  size_t alignment = MetaspaceShared::core_region_alignment();\n@@ -235,1 +256,1 @@\n-    aligned_base = align_up(specified_base, Metaspace::reserve_alignment());\n+    alignment = MAX2(alignment, Metaspace::reserve_alignment());\n@@ -238,0 +259,7 @@\n+  if (SharedBaseAddress == 0) {\n+    \/\/ Special meaning of -XX:SharedBaseAddress=0 -> Always map archive at os-selected address.\n+    return specified_base;\n+  }\n+\n+  char* aligned_base = align_up_or_null(specified_base, alignment);\n+\n@@ -244,1 +272,3 @@\n-  if (shared_base_too_high(specified_base, aligned_base, cds_max)) {\n+  if (aligned_base == nullptr) {\n+    err = \"too high\";\n+  } else if (shared_base_too_high(specified_base, aligned_base, cds_max)) {\n@@ -252,0 +282,3 @@\n+  \/\/ Arguments::default_SharedBaseAddress() is hard-coded in cds_globals.hpp. It must be carefully\n+  \/\/ picked that (a) the align_up() below will always return a valid value; (b) none of\n+  \/\/ the following asserts will fail.\n@@ -257,1 +290,1 @@\n-  aligned_base = align_up(specified_base, MetaspaceShared::core_region_alignment());\n+  aligned_base = align_up(specified_base, alignment);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":46,"deletions":13,"binary":false,"changes":59,"status":"modified"}]}