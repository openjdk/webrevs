{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1217,2 +1217,4 @@\n-                \/\/ If we stay on the same wall-clock time, try the next or previous hour.\n-                if (internalGet(HOUR_OF_DAY) == d.getHours()) {\n+                \/\/ If the rolled amount is not a full HOUR\/HOUR_OF_DAY (12\/24-hour) cycle and\n+                \/\/ if we stay on the same wall-clock time, try the next or previous hour.\n+                if (((field == HOUR_OF_DAY && amount % 24 != 0) || (field == HOUR && amount % 12 != 0))\n+                        && internalGet(HOUR_OF_DAY) == d.getHours()) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/GregorianCalendar.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8367901\n+ * @summary Ensure hour rolling is correct. Particularly, when the HOUR\/HOUR_OF_DAY\n+ *          amount rolled would cause the calendar to originate on the same hour as before\n+ *          the call.\n+ * @run junit RollHoursTest\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.FieldSource;\n+\n+import java.text.DateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+import java.util.TimeZone;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class RollHoursTest {\n+\n+    \/\/ Should trigger multiple full HOUR\/HOUR_OF_DAY cycles\n+    private static final List<Integer> hours =\n+            IntStream.rangeClosed(-55, 55).boxed().toList();\n+    \/\/ Various calendars to test against\n+    private static final List<Calendar> calendars = List.of(\n+            \/\/ GMT, independent of daylight saving time transitions\n+            new GregorianCalendar(TimeZone.getTimeZone(\"GMT\")),\n+            \/\/ Daylight saving observing calendars\n+            new GregorianCalendar(TimeZone.getTimeZone(\"America\/Chicago\")),\n+            new GregorianCalendar(TimeZone.getTimeZone(\"America\/Chicago\")),\n+            new GregorianCalendar(TimeZone.getTimeZone(\"America\/Los_Angeles\")),\n+            new GregorianCalendar(TimeZone.getTimeZone(\"America\/Los_Angeles\"))\n+    );\n+\n+    \/\/ Reset the times of each calendar. These calendars provide testing under\n+    \/\/ daylight saving transitions (or the lack thereof) and different AM\/PM hours.\n+    @BeforeEach\n+    void clear() {\n+        \/\/ Reset all calendars each iteration for clean slate\n+        calendars.forEach(Calendar::clear);\n+\n+        \/\/ Basic test, independent of daylight saving transitions\n+        calendars.get(0).set(2005, 8, 20, 12, 10, 25);\n+\n+        \/\/ Transition to daylight saving time (CST\/CDT) ---\n+        \/\/ Day of transition: 03\/13\/2016 (Sunday)\n+        \/\/      Most interesting test case due to 2 AM skip\n+        calendars.get(1).set(2016, 2, 13, 3, 30, 55);\n+        \/\/ Day before transition: 03\/12\/2016 (Saturday)\n+        calendars.get(2).set(2016, 2, 12, 15, 20, 45);\n+\n+        \/\/ Transition back to standard time (PST\/PDT) ----\n+        \/\/ Day of transition: 11\/06\/2016 (Sunday)\n+        calendars.get(3).set(2016, 10, 6, 4, 15, 20);\n+        \/\/ Day before transition: 11\/05\/2016 (Saturday)\n+        calendars.get(4).set(2016, 10, 5, 12, 25, 30);\n+    }\n+\n+    \/\/ Rolling the HOUR_OF_DAY field.\n+    @ParameterizedTest\n+    @FieldSource(\"hours\")\n+    void HourOfDayTest(int hoursToRoll) {\n+        for (var cal : calendars) {\n+            var savedTime = cal.getTime();\n+            var savedHour = cal.get(Calendar.HOUR_OF_DAY);\n+            cal.roll(Calendar.HOUR_OF_DAY, hoursToRoll);\n+            assertEquals(getExpectedHour(hoursToRoll, savedHour, 24, cal, savedTime),\n+                    cal.get(Calendar.HOUR_OF_DAY),\n+                    getMessage(cal.getTimeZone(), savedTime, hoursToRoll));\n+        }\n+    }\n+\n+    \/\/ Rolling the HOUR field.\n+    @ParameterizedTest\n+    @FieldSource(\"hours\")\n+    void HourTest(int hoursToRoll) {\n+        for (var cal : calendars) {\n+            var savedTime = cal.getTime();\n+            var savedHour = cal.get(Calendar.HOUR_OF_DAY);\n+            cal.roll(Calendar.HOUR, hoursToRoll);\n+            assertEquals(getExpectedHour(hoursToRoll, savedHour, 12, cal, savedTime),\n+                    cal.get(Calendar.HOUR),\n+                    getMessage(cal.getTimeZone(), savedTime, hoursToRoll));\n+        }\n+    }\n+\n+    \/\/ Gets the expected hour after rolling by X hours. Supports 12\/24-hour cycle.\n+    \/\/ Special handling for non-existent 2 AM case on transition day.\n+    private static int getExpectedHour(int roll, int hour, int hourCycle, Calendar cal, Date oldDate) {\n+        \/\/ For example with HOUR_OF_DAY at 15 and a 24-hour cycle\n+        \/\/ For rolling forwards 50 hours -> (50 + 15) % 24 = 17\n+        \/\/ For hour backwards 50 hours -> (24 + (15 - 50) % 24) % 24\n+        \/\/                             -> (24 - 11) % 24 = 13\n+        var result = (roll >= 0 ? (hour + roll) : (hourCycle + (hour + roll) % hourCycle)) % hourCycle;\n+\n+        \/\/ 2 AM does not exist on transition day. Calculate normalized value accordingly\n+        if (cal.getTimeZone().inDaylightTime(oldDate) && cal.get(Calendar.MONTH) == Calendar.MARCH && result == 2) {\n+            return roll > 0 ? result + 1 : result - 1;\n+        } else {\n+            \/\/ Normal return value\n+            return result;\n+        }\n+    }\n+\n+    \/\/ Get a TimeZone adapted error message\n+    private static String getMessage(TimeZone tz, Date date, int hoursToRoll) {\n+        var fmt = DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL);\n+        fmt.setTimeZone(tz);\n+        return fmt.format(date) + \" incorrectly rolled \" + hoursToRoll;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Calendar\/RollHoursTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"}]}