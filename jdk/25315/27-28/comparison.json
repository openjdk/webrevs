{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -4662,0 +4663,8 @@\n+void IdealLoopTree::register_reachability_fence(ReachabilityFenceNode* rf) {\n+  if (_reachability_fences == nullptr) {\n+    _reachability_fences = new Node_List();\n+  }\n+  assert(!_reachability_fences->contains(rf), \"already registered\");\n+  _reachability_fences->push(rf);\n+}\n+\n@@ -6116,4 +6125,1 @@\n-        if (innermost->_reachability_fences == nullptr) {\n-          innermost->_reachability_fences = new Node_List();\n-        }\n-        innermost->_reachability_fences->push(n);\n+        innermost->register_reachability_fence(n->as_ReachabilityFence());\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -853,0 +853,3 @@\n+  \/\/ Registers a reachability fence node in the loop.\n+  void register_reachability_fence(ReachabilityFenceNode* rf);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2055,10 +2055,0 @@\n-  if (n->is_ReachabilityFence()) {\n-    \/\/ ReachabilityFencesNode::Identity() walks CFG to determine whether the node is redundant or not.\n-    \/\/ But since there's no accurate dominance information avaialble, it reports a conservative answer.\n-    \/\/ So, any change in CFG can potentially expose a ReachabilityFence node as redundant.\n-    \/\/\n-    \/\/ Found with:\n-    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp -XX:+StressReachabilityFences\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,2 +72,8 @@\n- * After loop opts are over, it becomes possible to reliably enumerate all interfering safe points and\n- * to ensure that the referent is present in their oop maps.\n+ * compiler\/c2\/TestReachabilityFence.java demonstrates a situation where a load is hoisted out of a loop thus\n+ * extending the live range of the value it produces beyond the safepoint on loop-back edge.\n+ *\n+ * After loop opts are over, it becomes possible to reliably enumerate all interfering safepoints and\n+ * to ensure that the referent is present in their oop maps. Current assumption is that after loop opts the IR graph\n+ * is stable enough, so relative order of memory operations and safepoints is preserved and only safepoints between\n+ * a referent and it's uses are taken into account. A more conservative analysis can be employed -- any safepoint dominated\n+ * by a referent is treated as interfering with it -- if it turns out that the assumption doesn't hold.\n@@ -159,1 +165,1 @@\n-  Node* new_rf = new ReachabilityFenceNode(C, ctrl, referent);\n+  auto new_rf = new ReachabilityFenceNode(C, ctrl, referent);\n@@ -163,4 +169,1 @@\n-  if (lpt->_reachability_fences == nullptr) {\n-    lpt->_reachability_fences = new Node_List();\n-  }\n-  lpt->_reachability_fences->push(new_rf);\n+  lpt->register_reachability_fence(new_rf);\n@@ -223,1 +226,1 @@\n-    Node* loop_exit = lpt->unique_loop_exit_or_null();\n+    IfFalseNode* loop_exit = lpt->unique_loop_exit_or_null();\n@@ -439,0 +442,6 @@\n+\/\/\n+\/\/ NB! As of now, a special care is needed to properly enumerage reachability edges because\n+\/\/ there are other use cases for non-debug safepoint edges. expand_reachability_fences() runs\n+\/\/ after macro expansion where runtime calls during array allocation are annotated with\n+\/\/ valid_length_test_input as an extra edges. Until there's a mechanism to distinguish between\n+\/\/ different types of non-debug edges, unrelated cases are filtered out explicitly and in ad-hoc manner.\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"}]}