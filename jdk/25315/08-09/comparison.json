{"files":[{"patch":"@@ -496,4 +496,0 @@\n-  \/\/ Are we guaranteed that this node is a safepoint?  Not true for leaf calls and\n-  \/\/ for some macro nodes whose expansion does not have a safepoint on the fast path.\n-  virtual bool guaranteed_safepoint()  { return true; }\n-\n@@ -719,0 +715,3 @@\n+  \/\/ Are we guaranteed that this node is a safepoint?  Not true for leaf calls and\n+  \/\/ for some macro nodes whose expansion does not have a safepoint on the fast path.\n+  virtual bool        guaranteed_safepoint()  { return true; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5005,1 +5005,1 @@\n-  bool do_reachability_fences = (C->reachability_fences_count() > 0);\n+  bool do_reachability_fences = OptimizeReachabilityFences && (C->reachability_fences_count() > 0);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2042,0 +2042,10 @@\n+  if (n->is_ReachabilityFence()) {\n+    \/\/ ReachabilityFencesNode::Identity() walks CFG to determine whether the node is redundant or not.\n+    \/\/ But since there's no accurate dominance information avaialble, it reports a conservative answer.\n+    \/\/ So, any change in CFG can potentially expose a ReachabilityFence node as redundant.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp -XX:+StressReachabilityFences\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -173,1 +173,1 @@\n-    if (!sfpt->guaranteed_safepoint()) {\n+    if (sfpt->jvms() == nullptr) {\n@@ -322,3 +322,1 @@\n-  if (!OptimizeReachabilityFences) {\n-    return false;\n-  }\n+  assert(OptimizeReachabilityFences, \"required\");\n@@ -429,10 +427,2 @@\n-static uint rf_start_offset(SafePointNode* sfpt) {\n-  uint nof_extra_edges = 0;\n-  if (sfpt->is_Call()) {\n-    address entry = sfpt->as_Call()->entry_point();\n-    if (entry == OptoRuntime::new_array_Java() ||\n-        entry == OptoRuntime::new_array_nozero_Java()) {\n-      nof_extra_edges = 1; \/\/ valid_length_test_input\n-    }\n-  }\n-  return sfpt->jvms()->oopoff() + nof_extra_edges;\n+static uint rf_base_offset(SafePointNode* sfpt) {\n+  return sfpt->jvms()->oopoff();\n@@ -463,1 +453,1 @@\n-        assert(sfpt->req() == rf_start_offset(sfpt), \"\");\n+        assert(sfpt->req() == rf_base_offset(sfpt), \"no extra edges allowed\");\n@@ -518,1 +508,1 @@\n-    uint rf_offset = rf_start_offset(sfpt);\n+    uint rf_offset = rf_base_offset(sfpt);\n@@ -524,0 +514,12 @@\n+      Node* extra_edge = nullptr;\n+      if (sfpt->is_Call()) {\n+        address entry = sfpt->as_Call()->entry_point();\n+        if (entry == OptoRuntime::new_array_Java() ||\n+            entry == OptoRuntime::new_array_nozero_Java()) {\n+          \/\/ valid_length_test_input is appended during macro expansion at the very end\n+          int last_idx = sfpt->req() - 1;\n+          extra_edge = sfpt->in(last_idx);\n+          sfpt->del_req(last_idx);\n+        }\n+      }\n+\n@@ -533,0 +535,4 @@\n+\n+      if (extra_edge != nullptr) {\n+        sfpt->add_req(extra_edge); \/\/ Add valid_length_test_input edge back\n+      }\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+    assert(referent->bottom_type()->isa_oopptr() ||\n+           referent->bottom_type()->isa_narrowoop() != nullptr ||\n+           referent->bottom_type() == TypePtr::NULL_PTR,\n+           \"%s\", Type::str(referent->bottom_type()));\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}