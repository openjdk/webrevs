{"files":[{"patch":"@@ -470,0 +470,3 @@\n+  do_intrinsic(_Reference_reachabilityFence, java_lang_ref_Reference, reachabilityFence_name, object_void_signature, F_S)  \\\n+   do_name(reachabilityFence_name, \"reachabilityFence\")                                                                 \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  \/\/ Keep ReachabilityFence for diagnostic purposes.\n@@ -184,1 +185,2 @@\n-         !get_node(end_idx)->is_BoxLock()) {\n+         !get_node(end_idx)->is_BoxLock() &&\n+         !get_node(end_idx)->is_ReachabilityFence()) {\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,9 @@\n+  product(bool, OptimizeReachabilityFences, true, DIAGNOSTIC,               \\\n+          \"Optimize reachability fences\")                                   \\\n+                                                                            \\\n+  product(bool, PreserveReachabilityFencesOnConstants, false, DIAGNOSTIC,   \\\n+          \"Preserve reachability fences on constants\")                      \\\n+                                                                            \\\n+  product(bool, StressReachabilityFences, false, DIAGNOSTIC,                \\\n+          \"Randomly insert ReachabilityFence nodes\")                        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -778,0 +778,1 @@\n+  case vmIntrinsics::_Reference_reachabilityFence:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -614,0 +614,11 @@\n+\n+  uint endoff = call->jvms()->endoff();\n+  if (C->inlining_incrementally()) {\n+    assert(endoff == call->req(), \"\"); \/\/ assert in SafePointNode::grow_stack\n+  } else {\n+    if (call->req() > endoff) {\n+      assert(OptimizeReachabilityFences, \"\");\n+      return; \/\/ keep the original call node as the holder of reachability info\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-bool CallNode::has_non_debug_use(Node *n) {\n+bool CallNode::has_non_debug_use(const Node *n) {\n@@ -946,5 +946,6 @@\n-            if (cpn->_con == CatchProjNode::fall_through_index)\n-              projs->fallthrough_catchproj = cpn;\n-            else {\n-              assert(cpn->_con == CatchProjNode::catch_all_index, \"must be correct index.\");\n-              projs->catchall_catchproj = cpn;\n+            switch (cpn->_con) {\n+              case CatchProjNode::fall_through_index: projs->fallthrough_catchproj = cpn; break;\n+              case CatchProjNode::catch_all_index:    projs->catchall_catchproj    = cpn; break;\n+              default: {\n+                assert(cpn->_con > 1, \"\"); \/\/ exception table; rethrow case\n+              }\n@@ -964,2 +965,6 @@\n-          assert(projs->exobj == nullptr, \"only one\");\n-          projs->exobj = e;\n+          if (e->in(0)->as_CatchProj()->_con == CatchProjNode::catch_all_index) {\n+            assert(projs->exobj == nullptr, \"only one\");\n+            projs->exobj = e;\n+          } else  {\n+            assert(e->in(0)->as_CatchProj()->_con > 1, \"\"); \/\/ exception table for rethrow case\n+          }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -496,0 +496,4 @@\n+  \/\/ Are we guaranteed that this node is a safepoint?  Not true for leaf calls and\n+  \/\/ for some macro nodes whose expansion does not have a safepoint on the fast path.\n+  virtual bool guaranteed_safepoint()  { return true; }\n+\n@@ -715,3 +719,0 @@\n-  \/\/ Are we guaranteed that this node is a safepoint?  Not true for leaf calls and\n-  \/\/ for some macro nodes whose expansion does not have a safepoint on the fast path.\n-  virtual bool        guaranteed_safepoint()  { return true; }\n@@ -726,1 +727,1 @@\n-  bool                has_non_debug_use(Node* n);\n+  bool                has_non_debug_use(const Node* n);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"opto\/reachability.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+macro(ReachabilityFence)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -399,0 +399,3 @@\n+  if (dead->is_ReachabilityFence()) {\n+    remove_reachability_fence(dead);\n+  }\n@@ -462,0 +465,1 @@\n+  remove_useless_nodes(_reachability_fences, useful); \/\/ remove useless node recorded for post loop opts IGVN pass\n@@ -667,0 +671,1 @@\n+      _reachability_fences(comp_arena(), 8, 0, nullptr),\n@@ -935,0 +940,1 @@\n+      _reachability_fences(comp_arena(), 8, 0, nullptr),\n@@ -2507,1 +2513,6 @@\n-  if (failing())  return;\n+  { \/\/ No more loop opts. It is safe to eliminate reachability fence nodes.\n+    TracePhase tp(_t_idealLoop);\n+    PhaseIdealLoop::optimize(igvn, LoopOptsEliminateRFs);\n+    print_method(PHASE_ELIMINATE_REACHABILITY_FENCES, 2);\n+    if (failing())  return;\n+  }\n@@ -3968,0 +3979,2 @@\n+  expand_reachability_fences(sfpt);\n+\n@@ -3973,0 +3986,14 @@\n+  \/\/ Go over ReachabilityFence nodes to skip DecodeN nodes for referents.\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    Node* rf = C->reachability_fence(i);\n+    Node* in = rf->in(1);\n+    if (in->is_DecodeN()) {\n+      if (!in->has_non_debug_uses() || Matcher::narrow_oop_use_complex_address()) {\n+        rf->set_req(1, in->in(1));\n+        if (in->outcnt() == 0) {\n+          in->disconnect_inputs(this);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -3986,15 +4013,2 @@\n-      if (in->is_DecodeNarrowPtr()) {\n-        bool safe_to_skip = true;\n-        if (!is_uncommon ) {\n-          \/\/ Is it safe to skip?\n-          for (uint i = 0; i < in->outcnt(); i++) {\n-            Node* u = in->raw_out(i);\n-            if (!u->is_SafePoint() ||\n-                (u->is_Call() && u->as_Call()->has_non_debug_use(n))) {\n-              safe_to_skip = false;\n-            }\n-          }\n-        }\n-        if (safe_to_skip) {\n-          n->set_req(j, in->in(1));\n-        }\n+      if (in->is_DecodeNarrowPtr() && (is_uncommon || !in->has_non_debug_uses())) {\n+        n->set_req(j, in->in(1));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  LoopOptsEliminateRFs,\n@@ -380,0 +381,1 @@\n+  GrowableArray<Node*>  _reachability_fences;   \/\/ List of reachability fences\n@@ -705,1 +707,0 @@\n-\n@@ -710,0 +711,3 @@\n+  Node*         reachability_fence(int idx) const { return _reachability_fences.at(idx); }\n+  int           reachability_fences_count() const { return _reachability_fences.length(); }\n+\n@@ -731,0 +735,8 @@\n+  void add_reachability_fence(Node *n) {\n+    _reachability_fences.append(n);\n+  }\n+\n+  void remove_reachability_fence(Node* n) {\n+    _reachability_fences.remove_if_existing(n);\n+  }\n+\n@@ -1281,0 +1293,2 @@\n+  void expand_reachability_fences(Unique_Node_List& safepoints);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4626,0 +4626,1 @@\n+              op == Op_ReachabilityFence ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -155,3 +155,7 @@\n-  bool result = (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) || (n->is_Proj() && n->as_Proj()->bottom_type() == Type::CONTROL);\n-  assert(!result || (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint)\n-          || (n->is_Proj() && n->as_Proj()->_con == 0), \"If control projection, it must be projection 0\");\n+  bool result = n->is_ReachabilityFence() ||\n+                (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) ||\n+                (n->is_Proj() && n->as_Proj()->bottom_type() == Type::CONTROL);\n+  assert(!result ||\n+         (n->is_ReachabilityFence()) ||\n+         (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) ||\n+         (n->is_Proj() && n->as_Proj()->_con == 0), \"If control projection, it must be projection 0\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -3458,0 +3459,8 @@\n+\/\/------------------------------insert_reachability_fence----------------------\n+Node* GraphKit::insert_reachability_fence(Node* referent) {\n+  assert(!referent->is_top(), \"\");\n+  Node* rf = _gvn.transform(new ReachabilityFenceNode(C, control(), referent));\n+  set_control(rf);\n+  return rf;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -799,0 +799,1 @@\n+  Node* insert_reachability_fence(Node* referent);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -570,0 +570,1 @@\n+  case vmIntrinsics::_Reference_reachabilityFence: return inline_reference_reachabilityFence();\n@@ -7083,0 +7084,8 @@\n+\/\/-----------------------inline_reference_reachabilityFence-----------------\n+\/\/ bool java.lang.ref.Reference.reachabilityFence();\n+bool LibraryCallKit::inline_reference_reachabilityFence() {\n+  Node* referent = argument(0);\n+  insert_reachability_fence(referent);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+  bool inline_reference_reachabilityFence();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,16 @@\n+\/\/------------------------------unique_loop_exit_or_null----------------------\n+\/\/ Return the loop-exit projection if it is unique.\n+Node* IdealLoopTree::unique_loop_exit_or_null() {\n+  Node* unique_loop_exit = nullptr;\n+  if (is_loop()) {\n+    if (head()->is_BaseCountedLoop()) {\n+      unique_loop_exit = head()->as_BaseCountedLoop()->loopexit()->proj_out_or_null(0 \/* false *\/);\n+    } else if (head()->is_OuterStripMinedLoop()) {\n+      unique_loop_exit = head()->as_OuterStripMinedLoop()->outer_loop_exit();\n+    } else {\n+      \/\/ For now, conservatively report multiple loop exits exist.\n+    }\n+  }\n+  return unique_loop_exit;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4677,0 +4677,3 @@\n+  if (_rfs != nullptr && _rfs->size() > 0) {\n+    tty->print(\" has_rf\");\n+  }\n@@ -4684,0 +4687,3 @@\n+    if (_rfs != nullptr && _rfs->size() > 0) {\n+      tty->print(\" rfs={\"); _rfs->dump_simple(); tty->print(\" }\");\n+    }\n@@ -4929,1 +4935,1 @@\n-\n+  bool eliminate_rfs = (_mode == LoopOptsEliminateRFs);\n@@ -4999,0 +5005,1 @@\n+  bool do_reachability_fences = (C->reachability_fences_count() > 0);\n@@ -5000,1 +5007,1 @@\n-  if (stop_early && !do_expensive_nodes) {\n+  if (stop_early && !do_expensive_nodes && !do_reachability_fences) {\n@@ -5106,2 +5113,10 @@\n-    assert(do_expensive_nodes, \"why are we here?\");\n-    if (process_expensive_nodes()) {\n+    assert(do_expensive_nodes || do_reachability_fences, \"why are we here?\");\n+    if (do_reachability_fences) {\n+      bool progress = optimize_reachability_fences();\n+      progress |= eliminate_reachability_fences();\n+      if (progress) {\n+        recompute_dom_depth();\n+        DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n+      }\n+    }\n+    if (do_expensive_nodes && process_expensive_nodes()) {\n@@ -5135,0 +5150,5 @@\n+  if (optimize_reachability_fences()) {\n+    recompute_dom_depth();\n+    DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n+  }\n+\n@@ -5161,0 +5181,6 @@\n+  if (eliminate_rfs) {\n+    eliminate_reachability_fences();\n+    C->restore_major_progress(old_progress);\n+    return;\n+  }\n+\n@@ -6036,0 +6062,5 @@\n+      } else if (n->is_ReachabilityFence()) {\n+        if (innermost->_rfs == nullptr) {\n+          innermost->_rfs = new Node_List();\n+        }\n+        innermost->_rfs->push(n);\n@@ -7238,1 +7269,1 @@\n-  } else if (_curnt->_next != nullptr) {\n+  } else if (_curnt != _root && _curnt->_next != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -670,0 +670,1 @@\n+  Node_List* _rfs;              \/\/ List of reachability fences in this loop\n@@ -682,0 +683,1 @@\n+      _rfs(nullptr),\n@@ -742,0 +744,3 @@\n+  \/\/ Return unique loop-exit projection or null if there are multiple exits exist.\n+  Node* unique_loop_exit_or_null();\n+\n@@ -1143,0 +1148,11 @@\n+  void remove_dead_node(Node* dead) {\n+    assert(dead->outcnt() == 0 && !dead->is_top(), \"node must be dead\");\n+    Node* c = get_ctrl(dead);\n+    IdealLoopTree* lpt = get_loop(c);\n+    _loop_or_ctrl.map(dead->_idx, nullptr); \/\/ This node is useless\n+    if (!lpt->is_root()) {\n+      lpt->_body.yank(dead);\n+    }\n+    igvn().remove_dead_node(dead);\n+  }\n+\n@@ -1482,1 +1498,14 @@\n- public:\n+  \/\/ Reachability fence support.\n+  bool optimize_reachability_fences();\n+  bool eliminate_reachability_fences();\n+\n+  bool is_redundant_rf(Node* rf, bool rf_only);\n+  bool find_redundant_rfs(Unique_Node_List& redundant_rfs);\n+  void insert_rf(Node* ctrl, Node* referent);\n+  void replace_rf(Node* old_node, Node* new_node);\n+  void remove_rf(Node* rf);\n+#ifdef ASSERT\n+  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n+#endif \/\/ ASSERT\n+\n+public:\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -615,0 +615,2 @@\n+      } else if (use->is_ReachabilityFence()) {\n+        \/\/ ok to eliminate\n@@ -969,0 +971,2 @@\n+      } else if (use->is_ReachabilityFence() && OptimizeReachabilityFences) {\n+        _igvn.replace_input_of(use, 1, _igvn.makecon(TypePtr::NULL_PTR)); \/\/ reset; redundant fence\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3958,1 +3958,1 @@\n-    if (x->Opcode() == Op_SCMemProj) {\n+    if (x->Opcode() == Op_SCMemProj || x->is_ReachabilityFence()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,0 +506,3 @@\n+  if (is_ReachabilityFence()) {\n+    C->add_reachability_fence(n);\n+  }\n@@ -617,0 +620,3 @@\n+  if (is_ReachabilityFence()) {\n+    compile->remove_reachability_fence(this);\n+  }\n@@ -2958,0 +2964,19 @@\n+\/\/--------------------------has_non_debug_uses------------------------------\n+\/\/ Checks whether the node has any non-debug uses or not.\n+bool Node::has_non_debug_uses() const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* u = fast_out(i);\n+    if (u->is_SafePoint()) {\n+      if (u->is_Call() && u->as_Call()->has_non_debug_use(this)) {\n+        return true;\n+      }\n+      \/\/ Non-call safepoints have only debug uses.\n+    } else if (u->is_ReachabilityFence()) {\n+      \/\/ Reachability fence is treated as debug use.\n+    } else {\n+      return true; \/\/ everything else is conservatively treated as non-debug use\n+    }\n+  }\n+  return false; \/\/ no non-debug uses found\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+class ReachabilityFenceNode;\n@@ -446,0 +447,3 @@\n+  \/\/ Does the node have any immediate non-debug uses?\n+  bool has_non_debug_uses() const;\n+\n@@ -698,2 +702,3 @@\n-        DEFINE_CLASS_ID(Initialize,       MemBar, 0)\n-        DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)\n+        DEFINE_CLASS_ID(Initialize,        MemBar, 0)\n+        DEFINE_CLASS_ID(MemBarStoreStore,  MemBar, 1)\n+      DEFINE_CLASS_ID(ReachabilityFence, Multi, 4)\n@@ -1002,0 +1007,1 @@\n+  DEFINE_CLASS_QUERY(ReachabilityFence)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -361,0 +361,1 @@\n+  Node*         _stress_rf_hook; \/\/ StressReachabilityFences support\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -373,0 +373,7 @@\n+    if (StressReachabilityFences && type->isa_oopptr() != nullptr) {\n+      Node* loc = local(index);\n+      if (loc->bottom_type() != TypePtr::NULL_PTR) {\n+        assert(loc->bottom_type()->isa_oopptr() != nullptr, \"%s\", Type::str(loc->bottom_type()));\n+        _stress_rf_hook->add_req(loc);\n+      }\n+    }\n@@ -381,0 +388,7 @@\n+    if (StressReachabilityFences && type->isa_oopptr() != nullptr) {\n+      Node* stk = stack(index);\n+      if (stk->bottom_type() != TypePtr::NULL_PTR) {\n+        assert(stk->bottom_type()->isa_oopptr() != nullptr, \"%s\", Type::str(stk->bottom_type()));\n+        _stress_rf_hook->add_req(stk);\n+      }\n+    }\n@@ -415,0 +429,1 @@\n+  _stress_rf_hook = (StressReachabilityFences ? new Node(1) : nullptr);\n@@ -646,0 +661,5 @@\n+\n+  if (StressReachabilityFences) {\n+    _stress_rf_hook->destruct(&_gvn);\n+    _stress_rf_hook = nullptr;\n+  }\n@@ -1204,0 +1224,11 @@\n+  if (StressReachabilityFences) {\n+    \/\/ Keep all oop arguments alive until method return.\n+    int max_locals = jvms()->loc_size();\n+    for (int idx = 0; idx < max_locals; idx++) {\n+      Node* loc = local(idx);\n+      if (loc->bottom_type()->isa_oopptr() != nullptr) {\n+        _stress_rf_hook->add_req(loc);\n+      }\n+    }\n+  }\n+\n@@ -2190,0 +2221,9 @@\n+  if (StressReachabilityFences) {\n+    \/\/ Keep all oop arguments alive until method return.\n+    for (uint i = 1; i < _stress_rf_hook->req(); i++) {\n+      Node* referent = _stress_rf_hook->in(i);\n+      assert(referent->bottom_type()->isa_oopptr(), \"%s\", Type::str(referent->bottom_type()));\n+      insert_reachability_fence(referent);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    tty->print_cr (\"           ReachabilityFence: %7.3f s\", timers[_t_reachability].seconds());\n","filename":"src\/hotspot\/share\/opto\/phase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+    f(       _t_reachability,        \"reachabilityFence\")        \\\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  flags(ELIMINATE_REACHABILITY_FENCES,  \"Eliminate Reachability Fences\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/phaseX.hpp\"\n+#include \"opto\/reachability.hpp\"\n+#include \"opto\/regalloc.hpp\"\n+#include \"opto\/runtime.hpp\"\n+\n+\/*\n+ * Reference::reachabilityFence support.\n+ *\n+ * Reachability fences (RFs) are intended to be used in performance critical code,\n+ * so the primary goal for C2 support is to reduce their runtime overhead as much as possible.\n+ *\n+ * Reference::reachabilityFence() calls are intrinsified into ReachabilityFence CFG nodes\n+ * and transition through multiple phases:\n+ *   (0) initial set of RFs is materialized during parsing;\n+ *   (1) optimization pass during loop opts which eliminates redundant nodes and\n+ *     moves loop-invariant ones outside loops;\n+ *   (2) reachability information is transferred to safepoint nodes (appended as edges after debug info);\n+ *   (3) reachability information from safepoints materialized as RF nodes attached to the safepoint node.\n+ *\n+ * Some implementation considerations.\n+ *\n+ * It looks attractive to get rid of RF nodes early and transfer to safepoint-attached representation,\n+ * but it is not correct until loop opts are done.\n+ *\n+ * RF nodes may interfere with RA, so stand-alone RF nodes are eliminated and reachability information is\n+ * transferred to corresponding safepoints. When safepoints are pruned during macro expansion, corresponding\n+ * reachability info also goes away.\n+ *\n+ * Unfortunately, it's not straightforward to stay with safepoint-attached representation till the very end,\n+ * because information about derived oops is attached to safepoints in a similar way. So, for now RFs are\n+ * rematerialized at safepoints before RA.\n+ *\/\n+\n+\/\/ RF is redundant for some referent oop when the referent has another user which keeps it alive across the RF.\n+\/\/ In terms of dominance relation it can be formulated as \"a referent has a user which is dominated by the redundant RF\".\n+\/\/ Until loop opts are over, only RF nodes are considered as usages (controlled by rf_only flag).\n+static bool is_redundant_rf_helper(Node* ctrl, Node* referent, PhaseIdealLoop* phase, PhaseGVN& gvn, bool rf_only) {\n+  const Type* t = gvn.type(referent);\n+  if (!PreserveReachabilityFencesOnConstants && t->singleton()) {\n+    return true; \/\/ no-op fence\n+  }\n+  if (t == TypePtr::NULL_PTR) {\n+    return true; \/\/ no-op fence\n+  }\n+  if (referent->is_Proj() && referent->in(0)->is_CallJava()) {\n+    ciMethod* m = referent->in(0)->as_CallJava()->method();\n+    if (m != nullptr && m->is_boxing_method()) {\n+      return true;\n+    }\n+  }\n+  for (Node* cur = referent;\n+       cur != nullptr;\n+       cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n+    for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n+      Node* use = cur->fast_out(i);\n+      if (rf_only && !use->is_ReachabilityFence()) {\n+        continue; \/\/ skip non-RF uses\n+      }\n+      if (use != ctrl) {\n+        if (phase != nullptr) {\n+          Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n+          if (phase->is_dominator(ctrl, use_ctrl)) {\n+            return true;\n+          }\n+        } else {\n+          assert(rf_only, \"\");\n+          if (gvn.is_dominator(ctrl, use)) {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+Node* ReachabilityFenceNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return (remove_dead_region(phase, can_reshape) ? this : nullptr);\n+}\n+\n+Node* ReachabilityFenceNode::Identity(PhaseGVN* phase) {\n+  if (is_redundant_rf_helper(this, in(1), nullptr, *phase, true \/*rf_only*\/)) {\n+    return in(0);\n+  }\n+  return this;\n+}\n+\n+#ifndef PRODUCT\n+static void rf_desc(outputStream* st, const ReachabilityFenceNode* rf, PhaseRegAlloc* ra) {\n+  char buf[50];\n+  ra->dump_register(rf->in(1), buf, sizeof(buf));\n+  st->print(\"reachability fence [%s]\", buf);\n+}\n+\n+void ReachabilityFenceNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  rf_desc(st, this, ra);\n+}\n+\n+void ReachabilityFenceNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra) const {\n+  ResourceMark rm;\n+  stringStream ss;\n+  rf_desc(&ss, this, ra);\n+  const char* desc = masm->code_string(ss.freeze());\n+  masm->block_comment(desc);\n+}\n+#endif\n+\n+\/\/ Detect safepoint nodes which are important for reachability tracking purposes.\n+static bool is_significant_sfpt(Node* n) {\n+  if (n->is_SafePoint()) {\n+    SafePointNode* sfpt = n->as_SafePoint();\n+    if (!sfpt->guaranteed_safepoint()) {\n+      return false; \/\/ not a real safepoint\n+    } else if (sfpt->is_CallStaticJava() && sfpt->as_CallStaticJava()->is_uncommon_trap()) {\n+      return false; \/\/ uncommon traps are exit points\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void PhaseIdealLoop::insert_rf(Node* ctrl, Node* referent) {\n+  IdealLoopTree* lpt = get_loop(ctrl);\n+  Node* ctrl_end = ctrl->unique_ctrl_out();\n+\n+  Node* new_rf = new ReachabilityFenceNode(C, ctrl, referent);\n+\n+  register_control(new_rf, lpt, ctrl);\n+  set_idom(new_rf, ctrl, dom_depth(ctrl) + 1);\n+  if (lpt->_rfs == nullptr) {\n+    lpt->_rfs = new Node_List();\n+  }\n+  lpt->_rfs->push(new_rf);\n+\n+  igvn().rehash_node_delayed(ctrl_end);\n+  ctrl_end->replace_edge(ctrl, new_rf);\n+\n+  if (idom(ctrl_end) == ctrl) {\n+    set_idom(ctrl_end, new_rf, dom_depth(new_rf) + 1);\n+  } else {\n+    assert(ctrl_end->is_Region(), \"\");\n+  }\n+}\n+\n+void PhaseIdealLoop::replace_rf(Node* old_node, Node* new_node) {\n+  assert(old_node->is_ReachabilityFence() ||\n+         (old_node->is_Proj() && old_node->in(0)->is_ReachabilityFence()),\n+         \"%s\", NodeClassNames[old_node->Opcode()]);\n+\n+  IdealLoopTree* lpt = get_loop(old_node);\n+  if (!lpt->is_root()) {\n+    lpt->_body.yank(old_node);\n+  }\n+  assert(lpt->_rfs != nullptr, \"missing\");\n+  assert(lpt->_rfs->contains(old_node), \"missing\");\n+  lpt->_rfs->yank(old_node);\n+  lazy_replace(old_node, new_node);\n+}\n+\n+void PhaseIdealLoop::remove_rf(Node* rf) {\n+  assert(rf->is_ReachabilityFence(), \"\");\n+  Node* referent = rf->in(1);\n+  if (igvn().type(referent) != TypePtr::NULL_PTR) {\n+    igvn().replace_input_of(rf, 1, makecon(TypePtr::NULL_PTR));\n+    if (referent->outcnt() == 0) {\n+      remove_dead_node(referent);\n+    }\n+  }\n+  Node* rf_ctrl_in = rf->in(0);\n+  replace_rf(rf, rf_ctrl_in);\n+}\n+\n+bool PhaseIdealLoop::is_redundant_rf(Node* rf, bool rf_only) {\n+  assert(rf->is_ReachabilityFence(), \"\");\n+  Node* referent = rf->in(1);\n+  return is_redundant_rf_helper(rf, referent, this, igvn(), rf_only);\n+}\n+\n+\/\/ Updates the unique list of redundant RFs.\n+\/\/ Returns true if new instances of redundant fences are found.\n+bool PhaseIdealLoop::find_redundant_rfs(Unique_Node_List& redundant_rfs) {\n+  bool found = false;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    Node* rf = C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    assert(rf->outcnt() > 0, \"dead node\");\n+    if (!redundant_rfs.member(rf) && is_redundant_rf(rf, true \/*rf_only*\/)) {\n+      redundant_rfs.push(rf);\n+      found = true;\n+    }\n+  }\n+  return found;\n+}\n+\n+#ifdef ASSERT\n+static void dump_rfs_on(outputStream* st, PhaseIdealLoop* phase, Unique_Node_List& redundant_rfs, bool rf_only) {\n+  for (int i = 0; i < phase->C->reachability_fences_count(); i++) {\n+    Node* rf = phase->C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    bool detected = redundant_rfs.member(rf);\n+    bool redundant = is_redundant_rf_helper(rf, referent, phase, phase->igvn(), rf_only);\n+\n+    st->print(\" %3d: %s%s \", i, (redundant ? \"R\" : \" \"), (detected ? \"D\" : \" \"));\n+    rf->dump(\"\", false, st);\n+    st->cr();\n+\n+    st->print(\"         \");\n+    referent->dump(\"\", false, st);\n+    st->cr();\n+    if (redundant != detected) {\n+      for (Node* cur = referent;\n+           cur != nullptr;\n+           cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n+        bool first = true;\n+        for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n+          Node* use = cur->fast_out(i);\n+          if (rf_only && !use->is_ReachabilityFence()) {\n+            continue; \/\/ skip non-RF uses\n+          }\n+          if (use != rf) {\n+            Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n+            if (phase->is_dominator(rf, use_ctrl)) {\n+              if (first) {\n+                st->print(\"=====REF \"); cur->dump(\"\", false, st); st->cr();\n+                first = false;\n+              }\n+              st->print(\"     D \"); use_ctrl->dump(\"\", false, st); st->cr();\n+              if (use != use_ctrl) {\n+                st->print(\"         \"); use->dump(\"\", false, st); st->cr();\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+bool PhaseIdealLoop::has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only) {\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    Node* rf = C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    assert(rf->outcnt() > 0, \"dead node\");\n+    if (ignored_rfs.member(rf)) {\n+      continue; \/\/ skip\n+    } else if (is_redundant_rf(rf, rf_only)) {\n+      dump_rfs_on(tty, this, ignored_rfs, rf_only);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+#endif \/\/ ASSERT\n+\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 1 ---------------------------------\n+\/\/ Optimization pass over reachability fences during loop opts.\n+\/\/ Eliminate redundant RFs and move RFs with loop-invariant referent out of the loop.\n+bool PhaseIdealLoop::optimize_reachability_fences() {\n+  Compile::TracePhase tp(_t_reachability);\n+\n+  if (!OptimizeReachabilityFences) {\n+    return false;\n+  }\n+\n+  Unique_Node_List redundant_rfs;\n+  find_redundant_rfs(redundant_rfs);\n+\n+  Node_List worklist;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    Node* rf = C->reachability_fence(i);\n+    if (!redundant_rfs.member(rf)) {\n+      \/\/ Move RFs out of counted loops when possible.\n+      IdealLoopTree* lpt = get_loop(rf);\n+      Node* referent = rf->in(1);\n+      Node* loop_exit = lpt->unique_loop_exit_or_null();\n+      if (lpt->is_invariant(referent) && loop_exit != nullptr) {\n+        \/\/ Switch to the outermost loop.\n+        for (IdealLoopTree* outer_loop = lpt->_parent;\n+             outer_loop->is_invariant(referent) && outer_loop->unique_loop_exit_or_null() != nullptr;\n+             outer_loop = outer_loop->_parent) {\n+          assert(is_member(outer_loop, rf), \"\");\n+          loop_exit = outer_loop->unique_loop_exit_or_null();\n+        }\n+        assert(loop_exit != nullptr, \"\");\n+        worklist.push(referent);\n+        worklist.push(loop_exit);\n+        redundant_rfs.push(rf);\n+      }\n+    }\n+  }\n+\n+  \/\/ Populate RFs outside counted loops.\n+  while (worklist.size() > 0) {\n+    Node* ctrl_out = worklist.pop();\n+    Node* referent = worklist.pop();\n+    insert_rf(ctrl_out, referent);\n+  }\n+\n+  \/\/ Redundancy is determined by dominance relation.\n+  \/\/ Sometimes it becomes evident that an RF is redundant once it is moved out of the loop.\n+  \/\/ Also, newly introduced RF can make some existing RFs redundant.\n+  find_redundant_rfs(redundant_rfs);\n+\n+  \/\/ Eliminate redundant RFs.\n+  bool progress = (redundant_rfs.size() > 0);\n+  while (redundant_rfs.size() > 0) {\n+    remove_rf(redundant_rfs.pop());\n+  }\n+\n+  assert(redundant_rfs.size() == 0, \"\");\n+  assert(!has_redundant_rfs(redundant_rfs, true \/*rf_only*\/), \"\");\n+\n+  return progress;\n+}\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 2 ---------------------------------\n+\n+\/\/ Linearly traverse CFG upwards starting at n until first merge point.\n+\/\/ All encountered safepoints are recorded in safepoints list.\n+static void linear_traversal(Node* n, Node_Stack& worklist, VectorSet& visited, Node_List& safepoints) {\n+  for (Node* ctrl = n; ctrl != nullptr; ctrl = ctrl->in(0)) {\n+    assert(ctrl->is_CFG(), \"\");\n+    if (visited.test_set(ctrl->_idx)) {\n+      return;\n+    } else {\n+      if (ctrl->is_Region()) {\n+        worklist.push(ctrl, 1);\n+        return; \/\/ stop at merge points\n+      } else if (is_significant_sfpt(ctrl)) {\n+        safepoints.push(ctrl);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Enumerate all safepoints which are reachable from the RF to its referent through CFG.\n+\/\/ Start at rf node and traverse CFG upwards until referent's control node is reached.\n+static void enumerate_interfering_sfpts(Node* rf, PhaseIdealLoop* phase, Node_List& safepoints) {\n+  Node* referent = rf->in(1);\n+  Node* referent_ctrl = phase->get_ctrl(referent);\n+  assert(phase->is_dominator(referent_ctrl, rf), \"sanity\");\n+\n+  VectorSet visited;\n+  visited.set(referent_ctrl->_idx); \/\/ end point\n+\n+  Node_Stack stack(0);\n+  linear_traversal(rf, stack, visited, safepoints); \/\/ start point\n+  while (stack.is_nonempty()) {\n+    Node* cur = stack.node();\n+    uint  idx = stack.index();\n+\n+    assert(cur != nullptr, \"\");\n+    assert(cur->is_Region(), \"%s\", NodeClassNames[cur->Opcode()]);\n+    assert(phase->is_dominator(referent_ctrl, cur), \"\");\n+    assert(idx > 0 && idx <= cur->req(), \"%d %d\", idx, cur->req());\n+\n+    if (idx < cur->req()) {\n+      stack.set_index(idx + 1);\n+      linear_traversal(cur->in(idx), stack, visited, safepoints);\n+    } else {\n+      stack.pop();\n+    }\n+  }\n+}\n+\n+\/\/ Start offset for reachability info on a safepoint node.\n+static uint rf_start_offset(SafePointNode* sfpt) {\n+  uint nof_extra_edges = 0;\n+  if (sfpt->is_Call()) {\n+    address entry = sfpt->as_Call()->entry_point();\n+    if (entry == OptoRuntime::new_array_Java() ||\n+        entry == OptoRuntime::new_array_nozero_Java()) {\n+      nof_extra_edges = 1; \/\/ valid_length_test_input\n+    }\n+  }\n+  return sfpt->jvms()->oopoff() + nof_extra_edges;\n+}\n+\n+\/\/ Phase 2: migrate reachability info to safepoints.\n+\/\/ All RFs are replaced with edges from corresponding referents to interfering safepoints.\n+\/\/ Interfering safepoints are safepoint nodes which are reachable from the RF to its referent through CFG.\n+bool PhaseIdealLoop::eliminate_reachability_fences() {\n+  Compile::TracePhase tp(_t_reachability);\n+\n+  if (!OptimizeReachabilityFences) {\n+    return false;\n+  }\n+\n+  Unique_Node_List redundant_rfs;\n+  Node_List worklist;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* rf = C->reachability_fence(i)->as_ReachabilityFence();\n+    assert(!is_redundant_rf(rf, true \/*rf_only*\/), \"missed\");\n+    if (!is_redundant_rf(rf, false \/*rf_only*\/)) {\n+      Node_List safepoints;\n+      enumerate_interfering_sfpts(rf, this, safepoints);\n+\n+      Node* referent = rf->in(1);\n+      while (safepoints.size() > 0) {\n+        SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n+        assert(is_dominator(get_ctrl(referent), sfpt), \"\");\n+        assert(sfpt->req() == rf_start_offset(sfpt), \"\");\n+        if (sfpt->find_edge(referent) == -1) {\n+          worklist.push(sfpt);\n+          worklist.push(referent);\n+        }\n+      }\n+    }\n+    redundant_rfs.push(rf);\n+  }\n+\n+  while (worklist.size() > 0) {\n+    Node* referent = worklist.pop();\n+    Node* sfpt     = worklist.pop();\n+    sfpt->add_req(referent);\n+    igvn()._worklist.push(sfpt);\n+  }\n+\n+  bool progress =  (redundant_rfs.size() > 0);\n+  while (redundant_rfs.size() > 0) {\n+    remove_rf(redundant_rfs.pop());\n+  }\n+\n+  assert(C->reachability_fences_count() == 0, \"\");\n+  return progress;\n+}\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 3 ---------------------------------\n+\n+\/\/ Find a point in CFG right after safepoint node to insert reachability fence.\n+static Node* sfpt_ctrl_out(SafePointNode* sfpt) {\n+  if (sfpt->is_Call()) {\n+    CallProjections callprojs;\n+    sfpt->as_Call()->extract_projections(&callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+    if (callprojs.fallthrough_catchproj != nullptr) {\n+      return callprojs.fallthrough_catchproj;\n+    } else if (callprojs.catchall_catchproj != nullptr) {\n+      return callprojs.catchall_catchproj; \/\/ rethrow stub \/\/ TODO: safe to ignore?\n+    } else if (callprojs.fallthrough_proj != nullptr) {\n+      return callprojs.fallthrough_proj; \/\/ no exceptions thrown\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else {\n+    return sfpt;\n+  }\n+}\n+\n+\/\/ Phase 3: expand reachability fences from safepoint info.\n+\/\/ Turn extra safepoint edges into reachability fences immediately following the safepoint.\n+void Compile::expand_reachability_fences(Unique_Node_List& safepoints) {\n+  for (uint i = 0; i < safepoints.size(); i++) {\n+    SafePointNode* sfpt = safepoints.at(i)->as_SafePoint();\n+\n+    uint rf_offset = rf_start_offset(sfpt);\n+    if (sfpt->jvms() != nullptr && sfpt->req() > rf_offset) {\n+      assert(is_significant_sfpt(sfpt), \"\");\n+      Node* ctrl_out = sfpt_ctrl_out(sfpt);\n+      Node* ctrl_end = ctrl_out->unique_ctrl_out();\n+\n+      while (sfpt->req() > rf_offset) {\n+        int idx = sfpt->req() - 1;\n+        Node* referent = sfpt->in(idx);\n+        sfpt->del_req(idx);\n+\n+        Node* new_rf = new ReachabilityFenceNode(C, ctrl_out, referent);\n+        ctrl_end->replace_edge(ctrl_out, new_rf);\n+        ctrl_end = new_rf;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_OPTO_REACHABILITY_HPP\n+#define SHARE_OPTO_REACHABILITY_HPP\n+\n+#include \"opto\/multnode.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/opcodes.hpp\"\n+#include \"opto\/type.hpp\"\n+\n+\/\/------------------------ReachabilityFenceNode--------------------------\n+class ReachabilityFenceNode : public MultiNode {\n+public:\n+  ReachabilityFenceNode(Compile* C, Node* ctrl, Node* referent)\n+      : MultiNode(1) {\n+    init_class_id(Class_ReachabilityFence);\n+    init_req(TypeFunc::Control, ctrl);\n+    add_req(referent);\n+    C->add_reachability_fence(this);\n+  }\n+  virtual int   Opcode() const;\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  virtual const Type* bottom_type() const { return Type::CONTROL; }\n+  const RegMask &in_RegMask(uint idx) const {\n+    \/\/ Fake input register mask for the referent: accepts all registers and all stack slots.\n+    \/\/ This avoids redundant register moves around reachability fences.\n+    return RegMask::All;\n+  }\n+\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+  virtual void emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra) const;\n+#endif\n+};\n+\n+#endif \/\/ SHARE_OPTO_REACHABILITY_HPP\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -653,1 +653,1 @@\n-    @ForceInline\n+    @IntrinsicCandidate\n@@ -655,5 +655,3 @@\n-        \/\/ Does nothing. This method is annotated with @ForceInline to eliminate\n-        \/\/ most of the overhead that using @DontInline would cause with the\n-        \/\/ HotSpot JVM, when this fence is used in a wide variety of situations.\n-        \/\/ HotSpot JVM retains the ref and does not GC it before a call to\n-        \/\/ this method, because the JIT-compilers do not have GC-only safepoints.\n+        \/\/ Does nothing. HotSpot JVM retains the ref and does not GC it before a call to this method.\n+        \/\/ NB! Some of the optimizations JIT-compilers perform may break that invariant,\n+        \/\/ so the method is intrinsified when the invariant doesn't hold.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8290892\n+ * @summary Tests to ensure that reachabilityFence() correctly keeps objects from being collected prematurely.\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -Xbatch compiler.c2.TestReachabilityFence\n+ *\/\n+public class TestReachabilityFence {\n+    private static final int SIZE = 100;\n+\n+    static final boolean[] STATUS = new boolean[2];\n+\n+    interface MyBuffer {\n+        byte get(int offset);\n+    }\n+    static class MyBufferOnHeap implements MyBuffer {\n+\n+        private static int current = 0;\n+        private final static byte[][] payload = new byte[10][];\n+\n+        private final int id;\n+\n+        public MyBufferOnHeap() {\n+            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            id = current++;\n+            payload[id] = new byte[SIZE];\n+\n+            \/\/ Initialize buffer\n+            for (int i = 0; i < SIZE; ++i) {\n+                put(i, (byte) 42);\n+            }\n+\n+            \/\/ Register a cleaner to free the memory when the buffer is garbage collected\n+            int lid = id; \/\/ Capture current value\n+            Cleaner.create().register(this, () -> { free(lid); });\n+\n+            System.out.println(\"Created new buffer of size = \" + SIZE + \" with id = \" + id);\n+        }\n+\n+        private static void free(int id) {\n+            System.out.println(\"Freeing buffer with id = \" + id);\n+            for (int i = 0; i < SIZE; ++i) {\n+                payload[id][i] = (byte)0;\n+            }\n+            payload[id] = null;\n+\n+            synchronized (STATUS) {\n+                STATUS[0] = true;\n+                STATUS.notifyAll();\n+            }\n+        }\n+\n+        public void put(int offset, byte b) {\n+            payload[id][offset] = b;\n+        }\n+\n+        public byte get(int offset) {\n+            try {\n+                return payload[id][offset];\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        }\n+    }\n+\n+    static class MyBufferOffHeap implements MyBuffer {\n+        private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+        private static int current = 0;\n+        private static long payload[] = new long[10];\n+\n+        private final int id;\n+\n+        public MyBufferOffHeap() {\n+            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            id = current++;\n+            payload[id] = UNSAFE.allocateMemory(SIZE);\n+\n+            \/\/ Initialize buffer\n+            for (int i = 0; i < SIZE; ++i) {\n+                put(i, (byte) 42);\n+            }\n+\n+            \/\/ Register a cleaner to free the memory when the buffer is garbage collected\n+            int lid = id; \/\/ Capture current value\n+            Cleaner.create().register(this, () -> { free(lid); });\n+\n+            System.out.println(\"Created new buffer of size = \" + SIZE + \" with id = \" + id);\n+        }\n+\n+        private static void free(int id) {\n+            System.out.println(\"Freeing buffer with id = \" + id);\n+            \/\/UNSAFE.freeMemory(payload[id]);\n+            for (int i = 0; i < SIZE; ++i) {\n+                UNSAFE.putByte(payload[id] + i, (byte)0);\n+            }\n+            payload[id] = 0;\n+\n+            synchronized (STATUS) {\n+                STATUS[1] = true;\n+                STATUS.notifyAll();\n+            }\n+        }\n+\n+        public void put(int offset, byte b) {\n+            UNSAFE.putByte(payload[id] + offset, b);\n+        }\n+\n+        public byte get(int offset) {\n+            try {\n+                return UNSAFE.getByte(payload[id] + offset);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        }\n+    }\n+\n+    static MyBuffer bufferOff = new MyBufferOffHeap();\n+    static MyBuffer bufferOn = new MyBufferOnHeap();\n+\n+    static long counter1 = 0;\n+    static long counter2 = 0;\n+\n+    static long test1(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBuffer myBuffer = bufferOff;\n+            if (myBuffer == null) {\n+                return j;\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                byte b = myBuffer.get(i);\n+                if (b != 42) {\n+                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            counter1 = j;\n+            \/\/ Keep the buffer live while we read from it\n+            Reference.reachabilityFence(myBuffer);\n+        }\n+        return limit;\n+    }\n+\n+    static long test2(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBuffer myBuffer = bufferOn;\n+            if (myBuffer == null) {\n+                return j;\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                byte b = myBuffer.get(i);\n+                if (b != 42) {\n+                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            counter2 = j;\n+            \/\/ Keep the buffer live while we read from it\n+            Reference.reachabilityFence(myBuffer);\n+        }\n+        return limit;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ Warmup to trigger compilation\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(10);\n+            test2(10);\n+        }\n+\n+        CountDownLatch latch = new CountDownLatch(3);\n+        final Throwable[] result = new Throwable[2];\n+\n+        Thread compThread1 = new Thread(() -> {\n+            latch.countDown(); \/\/ synchronize with main thread\n+            try {\n+                System.out.printf(\"Computation thread #1 has started\\n\");\n+                long cnt = test1(100_000_000);\n+                System.out.printf(\"#1 Finished after %d iterations\\n\", cnt);\n+            } catch (Throwable e) {\n+                System.out.printf(\"#1 Finished with an exception %s\\n\", e);\n+                result[0] = e;\n+            }\n+        });\n+\n+        Thread compThread2 = new Thread(() -> {\n+            latch.countDown(); \/\/ synchronize with main thread\n+            try {\n+                System.out.printf(\"Computation thread #2 has started\\n\");\n+                long cnt = test2(100_000_000);\n+                System.out.printf(\"#2 Finished after %d iterations\\n\", cnt);\n+            } catch (Throwable e) {\n+                System.out.printf(\"#2 Finished with an exception %s\\n\", e);\n+                result[1] = e;\n+            }\n+        });\n+\n+        compThread1.start();\n+        compThread2.start();\n+\n+        latch.countDown(); \/\/ synchronize with comp thread\n+\n+        Thread.sleep(100); \/\/ let compThread proceed\n+\n+        \/\/ Clear reference to 'buffer' and make sure it's garbage collected\n+        System.out.printf(\"Buffer set to null. Waiting for garbage collection. (counter1 = %d; counter2 = %d)\\n\",\n+                          counter1, counter2);\n+        bufferOn = null;\n+        bufferOff = null;\n+\n+        System.gc();\n+\n+        synchronized (STATUS) {\n+            do {\n+                if (STATUS[0] && STATUS[1] ) {\n+                    break;\n+                } else {\n+                    System.out.printf(\"Waiting for cleanup... (counter1 = %d; counter2 = %d)\\n\", counter1, counter2);\n+                    System.gc();\n+                    STATUS.wait(100);\n+                }\n+            } while (true);\n+        }\n+\n+        compThread1.join();\n+        compThread2.join();\n+        if (result[0] != null) {\n+            System.out.println(\"TEST FAILED\");\n+            throw result[0];\n+        }\n+        if (result[1] != null) {\n+            System.out.println(\"TEST FAILED\");\n+            throw result[0];\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFence.java","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -100,0 +100,1 @@\n+    ELIMINATE_REACHABILITY_FENCES(  \"Eliminate Reachability Fences\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+        List<Node> reachabilityFences = new ArrayList<>();\n+        List<Node> projections = new ArrayList<>();\n@@ -84,0 +86,4 @@\n+                } else if (header.endsWith(\"ReachabilityFence\")) {\n+                    reachabilityFences.add(new Node(\"ReachabilityFence\", line));\n+                } else if (header.endsWith(\"Proj\")) {\n+                    projections.add(new Node(\"Proj\", line));\n@@ -89,6 +95,13 @@\n-        for (Node loopEnd : loopEnds) {\n-            found |= loopEnd.to.stream()\n-                                 .filter(id -> nodeListHasElementWithId(safePoints, id))\n-                                 .findAny()\n-                                 .isPresent();\n-        }\n+\n+        \/\/ CountedLoopEnd -> SafePoint\n+        found |= loopEnds.stream()\n+                .flatMap(n -> n.to.stream()).flatMap(id -> safePoints.stream().filter(node -> node.id == id))\n+                .findAny().isPresent();\n+\n+        \/\/ CountedLoopEnd -> Proj -> ReachabilityFence -> SafePoint\n+        found |= loopEnds.stream()\n+                .flatMap(n -> n.to.stream()).flatMap(id -> projections.stream().filter(node -> node.id == id))\n+                .flatMap(n -> n.to.stream()).flatMap(id -> reachabilityFences.stream().filter(node -> node.id == id))\n+                .flatMap(n -> n.to.stream()).flatMap(id -> safePoints.stream().filter(node -> node.id == id))\n+                .findAny().isPresent();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/UseCountedLoopSafepointsTest.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"}]}