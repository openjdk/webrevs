{"files":[{"patch":"@@ -162,1 +162,1 @@\n-int Block::is_Empty(Compile* C) const {\n+int Block::is_Empty() const {\n@@ -185,1 +185,1 @@\n-  \/\/ Keep ReachabilityFence info when printing nmethod assembly.\n+  \/\/ Keep ReachabilityFence for diagnostic purposes.\n@@ -189,1 +189,1 @@\n-         !(get_node(end_idx)->is_ReachabilityFence() && C->print_assembly())) {\n+         !get_node(end_idx)->is_ReachabilityFence()) {\n@@ -707,1 +707,1 @@\n-  int e = b->is_Empty(C);\n+  int e = b->is_Empty();\n@@ -779,1 +779,1 @@\n-    if (block->is_Empty(C) != Block::not_empty) {\n+    if (block->is_Empty() != Block::not_empty) {\n@@ -858,1 +858,1 @@\n-    assert(block->is_Empty(C) != Block::completely_empty, \"Empty blocks should be connectors\");\n+    assert(block->is_Empty() != Block::completely_empty, \"Empty blocks should be connectors\");\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  int is_Empty(Compile* C) const;\n+  int is_Empty() const;\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-bool CallNode::has_non_debug_use(Node *n) {\n+bool CallNode::has_non_debug_use(const Node *n) {\n@@ -969,1 +969,1 @@\n-            \/\/ exception table for rethrow case\n+            assert(e->in(0)->as_CatchProj()->_con > 1, \"\"); \/\/ exception table for rethrow case\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-  bool                has_non_debug_use(Node* n);\n+  bool                has_non_debug_use(const Node* n);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"utilities\/macros.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2586,1 +2586,1 @@\n-  \/\/ A method with only infinite loops has no edges entering loops from root\n+ \/\/ A method with only infinite loops has no edges entering loops from root\n@@ -3911,14 +3911,0 @@\n-\n-static bool has_non_debug_uses(Node* n) {\n-  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-    Node* u = n->fast_out(i);\n-    if (u->is_Call() && u->as_Call()->has_non_debug_use(n)) {\n-      return false;\n-    }\n-    if (!u->is_SafePoint() && !u->is_ReachabilityFence()) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -3973,1 +3959,1 @@\n-      if (!has_non_debug_uses(in) || Matcher::narrow_oop_use_complex_address()) {\n+      if (!in->has_non_debug_uses() || Matcher::narrow_oop_use_complex_address()) {\n@@ -3995,1 +3981,1 @@\n-      if (in->is_DecodeNarrowPtr() && (is_uncommon || has_non_debug_uses(in))) {\n+      if (in->is_DecodeNarrowPtr() && (is_uncommon || !in->has_non_debug_uses())) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  while (null_block->is_Empty(C) == Block::empty_with_goto) {\n+  while (null_block->is_Empty() == Block::empty_with_goto) {\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1479,1 +1479,1 @@\n-  bool is_redundant_rf(Node* rf, bool cfg_only);\n+  bool is_redundant_rf(Node* rf, bool rf_only);\n@@ -1485,1 +1485,1 @@\n-  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool cfg_only);\n+  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2975,0 +2975,19 @@\n+\/\/--------------------------has_non_debug_uses------------------------------\n+\/\/ Checks whether the node has any non-debug uses or not.\n+bool Node::has_non_debug_uses() const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* u = fast_out(i);\n+    if (u->is_SafePoint()) {\n+      if (u->is_Call() && u->as_Call()->has_non_debug_use(this)) {\n+        return true;\n+      }\n+      \/\/ Non-call safepoints have only debug uses.\n+    } else if (u->is_ReachabilityFence()) {\n+      \/\/ Reachability fence is treated as debug use.\n+    } else {\n+      return true; \/\/ everything else is conservatively treated as non-debug use\n+    }\n+  }\n+  return false; \/\/ no non-debug uses found\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -446,0 +446,3 @@\n+  \/\/ Does the node have any immediate non-debug uses?\n+  bool has_non_debug_uses() const;\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,0 +73,6 @@\n+  if (referent->is_Proj() && referent->in(0)->is_CallJava()) {\n+    ciMethod* m = referent->in(0)->as_CallJava()->method();\n+    if (m != nullptr && m->is_boxing_method()) {\n+      return true;\n+    }\n+  }\n@@ -104,1 +110,1 @@\n-  if (is_redundant_rf_helper(this, in(1), nullptr, *phase, true \/*cfg_only*\/)) {\n+  if (is_redundant_rf_helper(this, in(1), nullptr, *phase, true \/*rf_only*\/)) {\n@@ -195,1 +201,1 @@\n-bool PhaseIdealLoop::is_redundant_rf(Node* rf, bool cfg_only) {\n+bool PhaseIdealLoop::is_redundant_rf(Node* rf, bool rf_only) {\n@@ -198,1 +204,1 @@\n-  return is_redundant_rf_helper(rf, referent, this, igvn(), cfg_only);\n+  return is_redundant_rf_helper(rf, referent, this, igvn(), rf_only);\n@@ -201,0 +207,2 @@\n+\/\/ Updates the unique list of redundant RFs.\n+\/\/ Returns true if new instances of redundant fences are found.\n@@ -207,1 +215,1 @@\n-    if (!redundant_rfs.member(rf) && is_redundant_rf(rf, true \/*cfg_only*\/)) {\n+    if (!redundant_rfs.member(rf) && is_redundant_rf(rf, true \/*rf_only*\/)) {\n@@ -209,0 +217,1 @@\n+      found = true;\n@@ -258,1 +267,1 @@\n-bool PhaseIdealLoop::has_redundant_rfs(Unique_Node_List& ignored_rfs, bool cfg_only) {\n+bool PhaseIdealLoop::has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only) {\n@@ -265,2 +274,2 @@\n-    } else if (is_redundant_rf(rf, cfg_only)) {\n-      dump_rfs_on(tty, this, ignored_rfs, cfg_only);\n+    } else if (is_redundant_rf(rf, rf_only)) {\n+      dump_rfs_on(tty, this, ignored_rfs, rf_only);\n@@ -332,1 +341,1 @@\n-  assert(!has_redundant_rfs(redundant_rfs, true \/*cfg_only*\/), \"\");\n+  assert(!has_redundant_rfs(redundant_rfs, true \/*rf_only*\/), \"\");\n@@ -415,2 +424,2 @@\n-    assert(!is_redundant_rf(rf, true \/*cfg_only*\/), \"missed\");\n-    if (!is_redundant_rf(rf, false \/*cfg_only*\/)) {\n+    assert(!is_redundant_rf(rf, true \/*rf_only*\/), \"missed\");\n+    if (!is_redundant_rf(rf, false \/*rf_only*\/)) {\n@@ -467,2 +476,0 @@\n-  } else if (sfpt->unique_ctrl_out()->is_OuterStripMinedLoopEnd()) {\n-    return sfpt->unique_ctrl_out()->as_OuterStripMinedLoopEnd()->proj_out_or_null(0 \/*false*\/); \/\/ outer_loop_exit()\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -46,3 +46,2 @@\n-    \/\/ Fake the incoming arguments mask for blackholes: accept all registers\n-    \/\/ and all stack slots. This would avoid any redundant register moves\n-    \/\/ for blackhole inputs.\n+    \/\/ Fake input register mask for the referent: accepts all registers and all stack slots.\n+    \/\/ This avoids redundant register moves around reachability fences.\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-\/\/                Reference.reachabilityFence(this);\n+                Reference.reachabilityFence(this);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFence.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}