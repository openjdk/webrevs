{"files":[{"patch":"@@ -1230,1 +1230,1 @@\n-    \/\/ All sfpt inputs are implicitly included into debug info during the scalarisaction process below.\n+    \/\/ All sfpt inputs are implicitly included into debug info during the scalarization process below.\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1542,2 +1542,0 @@\n-  bool is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only);\n-  bool find_redundant_rfs(Unique_Node_List& redundant_rfs);\n@@ -1547,3 +1545,0 @@\n-#ifdef ASSERT\n-  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -929,1 +929,1 @@\n-    \/\/ All sfpt inputs are implicitly included into debug info during the scalarisaction process below.\n+    \/\/ All sfpt inputs are implicitly included into debug info during the scalarization process below.\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1222,0 +1222,8 @@\n+\/\/-----------------------is_auto_boxed_primitive------------------------------\n+\/\/ Helper method to detect auto-boxed primitives (result of valueOf() call).\n+static bool is_auto_boxed_primitive(Node* n) {\n+  return (n->is_Proj() && n->as_Proj()->_con == TypeFunc::Parms &&\n+          n->in(0)->is_CallJava() &&\n+          n->in(0)->as_CallJava()->method()->is_boxing_method());\n+}\n+\n@@ -1241,1 +1249,2 @@\n-      if (loc->bottom_type()->isa_oopptr() != nullptr) {\n+      if (loc->bottom_type()->isa_oopptr() != nullptr &&\n+          !is_auto_boxed_primitive(loc)) { \/\/ ignore auto-boxed primitives\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -87,9 +87,3 @@\n-\/\/ RF is redundant for some referent oop when the referent has another user which keeps it alive across the RF.\n-\/\/ In terms of dominance relation it can be formulated as \"a referent has a user which is dominated by the redundant RF\".\n-\/\/ Until loop opts are over, only RF nodes are considered as usages (controlled by rf_only flag).\n-static bool is_redundant_rf_helper(ReachabilityFenceNode* rf, PhaseIdealLoop* phase, PhaseGVN& gvn, bool rf_only) {\n-  assert(phase != nullptr || rf_only, \"only RFs during GVN\");\n-\n-  Node* referent = rf->referent();\n-  const Type* t = gvn.type(referent);\n-  if (t == TypePtr::NULL_PTR) {\n+bool ReachabilityFenceNode::is_redundant(PhaseGVN& gvn) {\n+  const Type* referent_t = gvn.type(referent());\n+  if (referent_t == TypePtr::NULL_PTR) {\n@@ -101,1 +95,1 @@\n-  if (!PreserveReachabilityFencesOnConstants && t->singleton()) {\n+  if (!PreserveReachabilityFencesOnConstants && referent_t->singleton()) {\n@@ -104,29 +98,0 @@\n-  if (referent->is_Proj() && referent->in(0)->is_CallJava()) {\n-    ciMethod* m = referent->in(0)->as_CallJava()->method();\n-    if (m != nullptr && m->is_boxing_method()) {\n-      return true; \/\/ ignore fences on boxed primitives produced by valueOf methods\n-    }\n-  }\n-  for (Node* cur = referent;\n-       cur != nullptr;\n-       cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n-    for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n-      Node* use = cur->fast_out(i);\n-      if (rf_only && !use->is_ReachabilityFence()) {\n-        continue; \/\/ skip non-RF uses\n-      }\n-      if (use != rf) {\n-        if (phase != nullptr) {\n-          Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n-          if (phase->is_dominator(rf, use_ctrl)) {\n-            return true; \/\/ redundant fence: dominates another reachabilty fence with the same referent\n-          }\n-        } else {\n-          assert(use->is_ReachabilityFence(), \"only RFs during GVN\");\n-          if (gvn.is_dominator(rf, use)) {\n-            return true; \/\/ redundant fence: dominates another reachabilty fence with the same referent\n-          }\n-        }\n-      }\n-    }\n-  }\n@@ -141,1 +106,1 @@\n-  if (is_redundant_rf_helper(this, nullptr, *phase, true \/*rf_only*\/)) {\n+  if (is_redundant(*phase)) {\n@@ -147,1 +112,1 @@\n-\/\/ Turn the RF node into a no-op by setting it's referent to null.\n+\/\/ Turn the RF node into a no-op by setting its referent to null.\n@@ -187,1 +152,1 @@\n-  return true; \/\/ a full-blown safepoint can interfere with a reachability fence and it's referent\n+  return true; \/\/ a full-blown safepoint can interfere with a reachability fence and its referent\n@@ -240,79 +205,0 @@\n-bool PhaseIdealLoop::is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only) {\n-  return is_redundant_rf_helper(rf, this, igvn(), rf_only);\n-}\n-\n-\/\/ Updates the unique list of redundant RFs.\n-\/\/ Returns true if new instances of redundant fences are found.\n-bool PhaseIdealLoop::find_redundant_rfs(Unique_Node_List& redundant_rfs) {\n-  bool found = false;\n-  for (int i = 0; i < C->reachability_fences_count(); i++) {\n-    ReachabilityFenceNode* rf = C->reachability_fence(i);\n-    assert(rf->outcnt() > 0, \"dead node\");\n-    if (!redundant_rfs.member(rf) && is_redundant_rf(rf, true \/*rf_only*\/)) {\n-      redundant_rfs.push(rf);\n-      found = true;\n-    }\n-  }\n-  return found;\n-}\n-\n-#ifdef ASSERT\n-static void dump_rfs_on(outputStream* st, PhaseIdealLoop* phase, Unique_Node_List& redundant_rfs, bool rf_only) {\n-  for (int i = 0; i < phase->C->reachability_fences_count(); i++) {\n-    ReachabilityFenceNode* rf = phase->C->reachability_fence(i);\n-    Node* referent = rf->referent();\n-    bool detected = redundant_rfs.member(rf);\n-    bool redundant = is_redundant_rf_helper(rf, phase, phase->igvn(), rf_only);\n-\n-    st->print(\" %3d: %s%s \", i, (redundant ? \"R\" : \" \"), (detected ? \"D\" : \" \"));\n-    rf->dump(\"\", false, st);\n-    st->cr();\n-\n-    st->print(\"         \");\n-    referent->dump(\"\", false, st);\n-    st->cr();\n-    if (redundant != detected) {\n-      for (Node* cur = referent;\n-           cur != nullptr;\n-           cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n-        bool first = true;\n-        for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n-          Node* use = cur->fast_out(i);\n-          if (rf_only && !use->is_ReachabilityFence()) {\n-            continue; \/\/ skip non-RF uses\n-          }\n-          if (use != rf) {\n-            Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n-            if (phase->is_dominator(rf, use_ctrl)) {\n-              if (first) {\n-                st->print(\"=====REF \"); cur->dump(\"\", false, st); st->cr();\n-                first = false;\n-              }\n-              st->print(\"     D \"); use_ctrl->dump(\"\", false, st); st->cr();\n-              if (use != use_ctrl) {\n-                st->print(\"         \"); use->dump(\"\", false, st); st->cr();\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-bool PhaseIdealLoop::has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only) {\n-  for (int i = 0; i < C->reachability_fences_count(); i++) {\n-    ReachabilityFenceNode* rf = C->reachability_fence(i);\n-    assert(rf->outcnt() > 0, \"dead node\");\n-    if (ignored_rfs.member(rf)) {\n-      continue; \/\/ skip\n-    } else if (is_redundant_rf(rf, rf_only)) {\n-      dump_rfs_on(tty, this, ignored_rfs, rf_only);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif \/\/ ASSERT\n-\n-\n@@ -328,0 +214,1 @@\n+  \/\/ ResourceMark rm; \/\/ NB! not safe because insert_rf may trigger _idom reallocation\n@@ -329,3 +216,1 @@\n-  find_redundant_rfs(redundant_rfs);\n-\n-  Node_List worklist;\n+  GrowableArray<Pair<Node*,Node*>> worklist;\n@@ -334,17 +219,12 @@\n-    if (!redundant_rfs.member(rf)) {\n-      \/\/ Move RFs out of counted loops when possible.\n-      IdealLoopTree* lpt = get_loop(rf);\n-      Node* referent = rf->referent();\n-      Node* loop_exit = lpt->unique_loop_exit_or_null();\n-      if (lpt->is_invariant(referent) && loop_exit != nullptr) {\n-        \/\/ Switch to the outermost loop.\n-        for (IdealLoopTree* outer_loop = lpt->_parent;\n-             outer_loop->is_invariant(referent) && outer_loop->unique_loop_exit_or_null() != nullptr;\n-             outer_loop = outer_loop->_parent) {\n-          assert(is_member(outer_loop, rf), \"\");\n-          loop_exit = outer_loop->unique_loop_exit_or_null();\n-        }\n-        assert(loop_exit != nullptr, \"\");\n-        worklist.push(referent);\n-        worklist.push(loop_exit);\n-        redundant_rfs.push(rf);\n+    assert(!rf->is_redundant(igvn()), \"required\");\n+    \/\/ Move RFs out of counted loops when possible.\n+    IdealLoopTree* lpt = get_loop(rf);\n+    Node* referent = rf->referent();\n+    Node* loop_exit = lpt->unique_loop_exit_or_null();\n+    if (lpt->is_invariant(referent) && loop_exit != nullptr) {\n+      \/\/ Switch to the outermost loop.\n+      for (IdealLoopTree* outer_loop = lpt->_parent;\n+           outer_loop->is_invariant(referent) && outer_loop->unique_loop_exit_or_null() != nullptr;\n+           outer_loop = outer_loop->_parent) {\n+        assert(is_member(outer_loop, rf), \"\");\n+        loop_exit = outer_loop->unique_loop_exit_or_null();\n@@ -352,0 +232,4 @@\n+      assert(loop_exit != nullptr, \"\");\n+      Pair<Node*,Node*> p(referent, loop_exit);\n+      worklist.push(p);\n+      redundant_rfs.push(rf);\n@@ -356,3 +240,4 @@\n-  while (worklist.size() > 0) {\n-    Node* ctrl_out = worklist.pop();\n-    Node* referent = worklist.pop();\n+  while (worklist.is_nonempty()) {\n+    Pair<Node*,Node*> p = worklist.pop();\n+    Node* referent = p.first;\n+    Node* ctrl_out = p.second;\n@@ -362,5 +247,0 @@\n-  \/\/ Redundancy is determined by dominance relation.\n-  \/\/ Sometimes it becomes evident that an RF is redundant once it is moved out of the loop.\n-  \/\/ Also, newly introduced RF can make some existing RFs redundant.\n-  find_redundant_rfs(redundant_rfs);\n-\n@@ -373,3 +253,0 @@\n-  assert(redundant_rfs.size() == 0, \"\");\n-  assert(!has_redundant_rfs(redundant_rfs, true \/*rf_only*\/), \"\");\n-\n@@ -432,1 +309,1 @@\n-  \/\/ reset temporary structures to initial state\n+  \/\/ Reset temporary structures to their initial state.\n@@ -442,0 +319,14 @@\n+static bool dominates_another_rf(ReachabilityFenceNode* rf, PhaseIdealLoop* phase) {\n+  assert(!rf->is_redundant(phase->igvn()), \"\");\n+\n+  for (int i = 0; i < phase->C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* other_rf = phase->C->reachability_fence(i);\n+    assert(other_rf->outcnt() > 0, \"dead node\");\n+    if (rf != other_rf && rf->referent()->eqv_uncast(other_rf->referent()) &&\n+        phase->is_dominator(rf, other_rf)) {\n+      return true; \/\/ dominates another reachability fence with the same referent\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -464,1 +355,1 @@\n-      assert(!is_redundant_rf(rf, true \/*rf_only*\/), \"missed\");\n+      assert(!rf->is_redundant(igvn()), \"missed\");\n@@ -474,1 +365,11 @@\n-      if (!is_redundant_rf(rf, false \/*rf_only*\/)) {\n+      if (dominates_another_rf(rf, this)) {\n+        \/\/ Redundant fence: dominates another RF with the same referent.\n+        \/\/ RF is redundant for some referent oop when the referent has another RF which\n+        \/\/ keeps it alive across the RF. In terms of dominance relation it can be formulated\n+        \/\/ as \"a referent has another RF which is dominated by the redundant RF\".\n+        \/\/\n+        \/\/ NB! It is safe to assume that dominating RF is redundant only during expansion.\n+        \/\/ Otherwise, there's a chance for the superseding RF node to go away before expansion.\n+        \/\/ Non-RF users are ignored for a similar reason: they can go away before or after expansion\n+        \/\/ takes place, so no guarantees reachability information is preserved.\n+      } else {\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":56,"deletions":155,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  bool is_redundant(PhaseGVN& gvn);\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}