{"files":[{"patch":"@@ -617,1 +617,1 @@\n-    assert(endoff == call->req(), \"\"); \/\/ assert in SafePointNode::grow_stack\n+    assert(endoff == call->req(), \"reachability edge present\"); \/\/ asserted in SafePointNode::grow_stack\n@@ -620,1 +620,1 @@\n-      assert(OptimizeReachabilityFences, \"\");\n+      assert(OptimizeReachabilityFences, \"reachability edge present\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -400,1 +401,1 @@\n-    remove_reachability_fence(dead);\n+    remove_reachability_fence(dead->as_ReachabilityFence());\n@@ -2513,1 +2514,3 @@\n-  { \/\/ No more loop opts. It is safe to eliminate reachability fence nodes.\n+  \/\/ No more loop opts. It is safe to get rid of all reachability fence nodes\n+  \/\/ and migrate reachability edges to safepoints.\n+  if (OptimizeReachabilityFences && _reachability_fences.length() > 0) {\n@@ -2518,0 +2521,1 @@\n+    assert(_reachability_fences.length() == 0, \"no RF nodes allowed\");\n@@ -3987,0 +3991,2 @@\n+  \/\/ The sole purpose of RF node is to keep the referent oop alive and\n+  \/\/ decoding the oop for that is not needed.\n@@ -3988,7 +3994,7 @@\n-    Node* rf = C->reachability_fence(i);\n-    Node* in = rf->in(1);\n-    if (in->is_DecodeN()) {\n-      if (!in->has_non_debug_uses() || Matcher::narrow_oop_use_complex_address()) {\n-        rf->set_req(1, in->in(1));\n-        if (in->outcnt() == 0) {\n-          in->disconnect_inputs(this);\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n+    DecodeNNode* dn = rf->in(1)->isa_DecodeN();\n+    if (dn != nullptr) {\n+      if (!dn->has_non_debug_uses() || Matcher::narrow_oop_use_complex_address()) {\n+        rf->set_req(1, dn->in(1));\n+        if (dn->outcnt() == 0) {\n+          dn->disconnect_inputs(this);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+class ReachabilityFenceNode;\n@@ -381,1 +382,1 @@\n-  GrowableArray<Node*>  _reachability_fences;   \/\/ List of reachability fences\n+  GrowableArray<ReachabilityFenceNode*> _reachability_fences; \/\/ List of reachability fences\n@@ -711,2 +712,2 @@\n-  Node*         reachability_fence(int idx) const { return _reachability_fences.at(idx); }\n-  int           reachability_fences_count() const { return _reachability_fences.length(); }\n+  ReachabilityFenceNode* reachability_fence(int idx) const { return _reachability_fences.at(idx); }\n+  int                    reachability_fences_count() const { return _reachability_fences.length(); }\n@@ -735,2 +736,2 @@\n-  void add_reachability_fence(Node *n) {\n-    _reachability_fences.append(n);\n+  void add_reachability_fence(ReachabilityFenceNode* rf) {\n+    _reachability_fences.append(rf);\n@@ -739,1 +740,1 @@\n-  void remove_reachability_fence(Node* n) {\n+  void remove_reachability_fence(ReachabilityFenceNode* n) {\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  Node* unique_loop_exit = nullptr;\n@@ -70,1 +69,1 @@\n-      unique_loop_exit = head()->as_BaseCountedLoop()->loopexit()->proj_out_or_null(0 \/* false *\/);\n+      return head()->as_BaseCountedLoop()->loopexit()->proj_out_or_null(0 \/* false *\/);\n@@ -72,1 +71,1 @@\n-      unique_loop_exit = head()->as_OuterStripMinedLoop()->outer_loop_exit();\n+      return head()->as_OuterStripMinedLoop()->outer_loop_exit();\n@@ -77,1 +76,1 @@\n-  return unique_loop_exit;\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ReachabilityFenceNode;\n@@ -1479,0 +1480,14 @@\n+  \/\/ Reachability Fence (RF) support.\n+ private:\n+  bool is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only);\n+  bool find_redundant_rfs(Unique_Node_List& redundant_rfs);\n+  void insert_rf(Node* ctrl, Node* referent);\n+  void replace_rf(Node* old_node, Node* new_node);\n+  void remove_rf(ReachabilityFenceNode* rf);\n+#ifdef ASSERT\n+  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n+#endif \/\/ ASSERT\n+ public:\n+  bool optimize_reachability_fences();\n+  bool eliminate_reachability_fences();\n+\n@@ -1498,14 +1513,1 @@\n-  \/\/ Reachability fence support.\n-  bool optimize_reachability_fences();\n-  bool eliminate_reachability_fences();\n-\n-  bool is_redundant_rf(Node* rf, bool rf_only);\n-  bool find_redundant_rfs(Unique_Node_List& redundant_rfs);\n-  void insert_rf(Node* ctrl, Node* referent);\n-  void replace_rf(Node* old_node, Node* new_node);\n-  void remove_rf(Node* rf);\n-#ifdef ASSERT\n-  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n-#endif \/\/ ASSERT\n-\n-public:\n+ public:\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -972,1 +973,1 @@\n-        _igvn.replace_input_of(use, 1, _igvn.makecon(TypePtr::NULL_PTR)); \/\/ reset; redundant fence\n+        use->as_ReachabilityFence()->clear_referent(_igvn); \/\/ redundant fence\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -507,1 +508,1 @@\n-    C->add_reachability_fence(n);\n+    C->add_reachability_fence(n->as_ReachabilityFence());\n@@ -621,1 +622,1 @@\n-    compile->remove_reachability_fence(this);\n+    compile->remove_reachability_fence(as_ReachabilityFence());\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -702,2 +702,2 @@\n-        DEFINE_CLASS_ID(Initialize,        MemBar, 0)\n-        DEFINE_CLASS_ID(MemBarStoreStore,  MemBar, 1)\n+        DEFINE_CLASS_ID(Initialize,       MemBar, 0)\n+        DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -374,0 +374,2 @@\n+      \/\/ Keep all oop locals alive until the method returns as if there are\n+      \/\/ reachability fences for them at the end of the method.\n@@ -389,0 +391,2 @@\n+      \/\/ Keep all oops on stack alive until the method returns as if there are\n+      \/\/ reachability fences for them at the end of the method.\n@@ -1225,1 +1229,2 @@\n-    \/\/ Keep all oop arguments alive until method return.\n+    \/\/ Keep all oop arguments alive until the method returns as if there are\n+    \/\/ reachability fences for them at the end of the method.\n@@ -2222,1 +2227,1 @@\n-    \/\/ Keep all oop arguments alive until method return.\n+    \/\/ Insert reachability fences for all oop arguments at the end of the method.\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n- * Reachability fences (RFs) are intended to be used in performance critical code,\n- * so the primary goal for C2 support is to reduce their runtime overhead as much as possible.\n+ * Reachability Fence (RF) ensures that the given object (referent) remains strongly reachable\n+ * regardless of any optimizing transformations the virtual machine may perform that might otherwise\n+ * allow the object to become unreachable.\n@@ -40,2 +41,11 @@\n- * Reference::reachabilityFence() calls are intrinsified into ReachabilityFence CFG nodes\n- * and transition through multiple phases:\n+ * RFs are intended to be used in performance-critical code, so the primary goal for C2 support is\n+ * to reduce their runtime overhead as much as possible.\n+ *\n+ * Reference::reachabilityFence() calls are intrinsified into ReachabilityFence CFG nodes. RF node keeps\n+ * its referent alive, so the referent's location is recorded at every safepoint (in its oop map) which\n+ * interferes with referent's live range.\n+ *\n+ * It is tempting to directly attach referents to interfering safepoints right from the beginning, but it\n+ * doesn't play well with some optimizations C2 does.\n+ *\n+ * Instead, reachability representation transitions through multiple phases:\n@@ -43,4 +53,6 @@\n- *   (1) optimization pass during loop opts which eliminates redundant nodes and\n- *     moves loop-invariant ones outside loops;\n- *   (2) reachability information is transferred to safepoint nodes (appended as edges after debug info);\n- *   (3) reachability information from safepoints materialized as RF nodes attached to the safepoint node.\n+ *   (1) optimization pass during loop opts eliminates redundant RF nodes and\n+ *       moves the ones with loop-invariant referents outside loops;\n+ *   (2) after loop opts are over, RF nodes are eliminated and their referents are transferred to\n+ *       safepoint nodes (appended as edges after debug info);\n+ *   (3) during final graph reshaping, referent edges are removed from safepoints and materialized as RF nodes\n+ *       attached to their safepoint node (closely following it in CFG graph).\n@@ -53,3 +65,3 @@\n- * RF nodes may interfere with RA, so stand-alone RF nodes are eliminated and reachability information is\n- * transferred to corresponding safepoints. When safepoints are pruned during macro expansion, corresponding\n- * reachability info also goes away.\n+ * RF nodes may interfere with RA, so stand-alone RF nodes are eliminated and their referents are\n+ * transferred to corresponding safepoints (phase #2). When safepoints are pruned during macro expansion,\n+ * corresponding reachability edges also go away.\n@@ -58,2 +70,2 @@\n- * because information about derived oops is attached to safepoints in a similar way. So, for now RFs are\n- * rematerialized at safepoints before RA.\n+ * because information about derived oops is attached to safepoints the very same similar way. So, for now RFs are\n+ * rematerialized at safepoints before RA (phase #3).\n@@ -116,0 +128,10 @@\n+\/\/ Turn the RF node into an no-op by setting it's referent to null.\n+bool ReachabilityFenceNode::clear_referent(PhaseIterGVN& phase) {\n+  if (phase.type(in(1)) == TypePtr::NULL_PTR) {\n+    return false;\n+  } else {\n+    phase.replace_input_of(this, 1, phase.makecon(TypePtr::NULL_PTR));\n+    return true;\n+  }\n+}\n+\n@@ -188,2 +210,1 @@\n-void PhaseIdealLoop::remove_rf(Node* rf) {\n-  assert(rf->is_ReachabilityFence(), \"\");\n+void PhaseIdealLoop::remove_rf(ReachabilityFenceNode* rf) {\n@@ -201,2 +222,1 @@\n-bool PhaseIdealLoop::is_redundant_rf(Node* rf, bool rf_only) {\n-  assert(rf->is_ReachabilityFence(), \"\");\n+bool PhaseIdealLoop::is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only) {\n@@ -212,1 +232,1 @@\n-    Node* rf = C->reachability_fence(i);\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n@@ -269,1 +289,1 @@\n-    Node* rf = C->reachability_fence(i);\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n@@ -337,1 +357,1 @@\n-    remove_rf(redundant_rfs.pop());\n+    remove_rf(redundant_rfs.pop()->as_ReachabilityFence());\n@@ -368,1 +388,1 @@\n-\/\/ Start at rf node and traverse CFG upwards until referent's control node is reached.\n+\/\/ Start at RF node and traverse CFG upwards until referent's control node is reached.\n@@ -423,1 +443,1 @@\n-    ReachabilityFenceNode* rf = C->reachability_fence(i)->as_ReachabilityFence();\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n@@ -450,1 +470,2 @@\n-  bool progress =  (redundant_rfs.size() > 0);\n+  \/\/ Eliminate redundant RFs.\n+  bool progress = (redundant_rfs.size() > 0);\n@@ -452,1 +473,1 @@\n-    remove_rf(redundant_rfs.pop());\n+    remove_rf(redundant_rfs.pop()->as_ReachabilityFence());\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":45,"deletions":24,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  bool clear_referent(PhaseIterGVN& phase);\n+\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}