{"files":[{"patch":"@@ -2522,1 +2522,1 @@\n-    assert(_reachability_fences.length() == 0, \"no RF nodes allowed\");\n+    assert(_reachability_fences.length() == 0 || PreserveReachabilityFencesOnConstants, \"no RF nodes allowed\");\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5340,1 +5340,2 @@\n-    assert(C->reachability_fences_count() == 0, \"no RF nodes allowed\");\n+    assert(C->reachability_fences_count() == 0 ||\n+           PreserveReachabilityFencesOnConstants, \"no RF nodes allowed\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -719,1 +719,1 @@\n-    jvms->set_endoff(sfpt_done->req());\n+    jvms->set_endoff(sfpt_done->req()); \/\/ NB! problematic when reachability fences are present?\n@@ -871,0 +871,2 @@\n+    assert(sfpt->jvms()->endoff() == sfpt->req(), \"reachability edges not supported\");\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,0 +438,1 @@\n+  DEBUG_ONLY( int no_of_constant_rfs = 0; )\n@@ -445,0 +446,9 @@\n+    if (PreserveReachabilityFencesOnConstants) {\n+      const Type* referent_t = igvn().type(rf->in(1));\n+      assert(referent_t != TypePtr::NULL_PTR, \"redundant rf\");\n+      bool is_constant_rf = referent_t->singleton();\n+      if (is_constant_rf) {\n+        DEBUG_ONLY( no_of_constant_rfs += 1; )\n+        continue; \/\/ don't eliminate constant rfs\n+      }\n+    }\n@@ -476,1 +486,1 @@\n-  assert(C->reachability_fences_count() == 0, \"\");\n+  assert(C->reachability_fences_count() == no_of_constant_rfs, \"\");\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+\/*\n+ * @test\n+ * @bug 8290892\n+ * @summary Tests to ensure that reachabilityFence() correctly keeps objects from being collected prematurely.\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileCommand=quiet\n+ *                                 -XX:CompileCommand=compileonly,*::test\n+ *                                 -XX:+UnlockDiagnosticVMOptions -XX:+PreserveReachabilityFencesOnConstants\n+ *                                 compiler.c2.TestReachabilityFenceOnConstant\n+ *\/\n+public class TestReachabilityFenceOnConstant {\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n+    static final long BUFFER_SIZE = 1024;\n+    static @Stable MyBuffer BUFFER = new MyBuffer();\n+\n+    static volatile boolean isCleaned = false;\n+\n+    static class MyBuffer {\n+        final @Stable long address;\n+        final @Stable long limit;\n+\n+        MyBuffer() {\n+            final long adr = U.allocateMemory(BUFFER_SIZE);\n+            U.setMemory(adr, BUFFER_SIZE, (byte)0);\n+            address = adr;\n+            limit = BUFFER_SIZE;\n+            System.out.printf(\"Allocated memory (%d bytes): 0x%016x\\n\", BUFFER_SIZE, adr);\n+            Cleaner.create().register(this, () -> {\n+                System.out.printf(\"Freed memory (%d bytes): 0x%016x\\n\", BUFFER_SIZE, adr);\n+                U.setMemory(adr, BUFFER_SIZE, (byte)-1); \/\/ clear\n+                U.freeMemory(adr);\n+                isCleaned = true;\n+            });\n+        }\n+\n+        byte getByte(long offset) {\n+            return U.getByte(null, address + offset);\n+        }\n+    }\n+\n+    static int test() {\n+        int acc = 0;\n+        MyBuffer buf = BUFFER;\n+        try {\n+            for (long i = 0; i < buf.limit; i++) {\n+                acc += buf.getByte(i);\n+            }\n+        } finally {\n+            Reference.reachabilityFence(buf);\n+        }\n+        return acc;\n+    }\n+\n+    static void runTest() {\n+        for (int i = 0; i < 20_000; i++) {\n+            if (test() != 0) {\n+                throw new AssertionError(\"observed stale buffer: TestConstantOop::isCleaned=\" + isCleaned);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n+        runTest(); \/\/ run test() and constant fold accesses to BUFFER (and it's state) during JIT-compilation\n+\n+        BUFFER = null; \/\/ remove last strong root\n+\n+        \/\/ Ensure the instance is GCed.\n+        while (!isCleaned) {\n+            try {\n+                System.gc();\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        try {\n+            runTest(); \/\/ repeat to ensure stale BUFFER contents is not accessed\n+        } catch (NullPointerException e) {\n+            \/\/ expected; ignore\n+        }\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFenceOnConstant.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}