{"files":[{"patch":"@@ -470,0 +470,3 @@\n+  do_intrinsic(_Reference_reachabilityFence, java_lang_ref_Reference, reachabilityFence_name, object_void_signature, F_S)  \\\n+   do_name(reachabilityFence_name, \"reachabilityFence\")                                                                 \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  \/\/ Keep ReachabilityFence for diagnostic purposes.\n@@ -184,1 +185,2 @@\n-         !get_node(end_idx)->is_BoxLock()) {\n+         !get_node(end_idx)->is_BoxLock() &&\n+         !get_node(end_idx)->is_ReachabilityFence()) {\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,9 @@\n+  product(bool, OptimizeReachabilityFences, true, DIAGNOSTIC,               \\\n+          \"Optimize reachability fences\")                                   \\\n+                                                                            \\\n+  product(bool, PreserveReachabilityFencesOnConstants, false, DIAGNOSTIC,   \\\n+          \"Preserve reachability fences on constants\")                      \\\n+                                                                            \\\n+  product(bool, StressReachabilityFences, false, DIAGNOSTIC,                \\\n+          \"Aggressively insert reachability fences for all oop arguments\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -778,0 +778,1 @@\n+  case vmIntrinsics::_Reference_reachabilityFence:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -614,0 +614,14 @@\n+\n+  uint endoff = call->jvms()->endoff();\n+  if (C->inlining_incrementally()) {\n+    \/\/ No reachability edges should be present when incremental inlining takes place.\n+    \/\/ Inlining logic doesn't expect any extra edges past debug info and fails with\n+    \/\/ an assert in SafePointNode::grow_stack.\n+    assert(endoff == call->req(), \"reachability edges not supported\");\n+  } else {\n+    if (call->req() > endoff) { \/\/ reachability edges present\n+      assert(OptimizeReachabilityFences, \"required\");\n+      return; \/\/ keep the original call node as the holder of reachability info\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-bool CallNode::has_non_debug_use(Node *n) {\n+bool CallNode::has_non_debug_use(const Node *n) {\n@@ -963,5 +963,6 @@\n-            if (cpn->_con == CatchProjNode::fall_through_index)\n-              projs->fallthrough_catchproj = cpn;\n-            else {\n-              assert(cpn->_con == CatchProjNode::catch_all_index, \"must be correct index.\");\n-              projs->catchall_catchproj = cpn;\n+            switch (cpn->_con) {\n+              case CatchProjNode::fall_through_index: projs->fallthrough_catchproj = cpn; break;\n+              case CatchProjNode::catch_all_index:    projs->catchall_catchproj    = cpn; break;\n+              default: {\n+                assert(cpn->_con > 1, \"not an exception table projection\"); \/\/ exception table; rethrow case\n+              }\n@@ -981,2 +982,6 @@\n-          assert(projs->exobj == nullptr, \"only one\");\n-          projs->exobj = e;\n+          if (e->in(0)->as_CatchProj()->_con == CatchProjNode::catch_all_index) {\n+            assert(projs->exobj == nullptr, \"only one\");\n+            projs->exobj = e;\n+          } else  {\n+            assert(e->in(0)->as_CatchProj()->_con > 1, \"not an exception table projection\"); \/\/ exception table for rethrow case\n+          }\n@@ -1580,0 +1585,19 @@\n+void SafePointNode::remove_non_debug_edges(GrowableArray<Node*>& non_debug_edges) {\n+  assert(non_debug_edges.is_empty(), \"edges not processed\");\n+  while (req() > jvms()->endoff()) {\n+    uint last = req() - 1;\n+    non_debug_edges.push(in(last));\n+    del_req(last);\n+  }\n+  assert(jvms()->endoff() == req(), \"no extra edges past debug info allowed\");\n+}\n+\n+void SafePointNode::restore_non_debug_edges(GrowableArray<Node*>& non_debug_edges) {\n+  assert(jvms()->endoff() == req(), \"no extra edges past debug info allowed\");\n+  while (non_debug_edges.is_nonempty()) {\n+    Node* non_debug_edge = non_debug_edges.pop();\n+    add_req(non_debug_edge);\n+  }\n+  assert(non_debug_edges.is_empty(), \"edges not processed\");\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -508,0 +508,3 @@\n+  void remove_non_debug_edges(GrowableArray<Node*>& non_debug_edges);\n+  void restore_non_debug_edges(GrowableArray<Node*>& non_debug_edges);\n+\n@@ -740,1 +743,1 @@\n-  bool                has_non_debug_use(Node* n);\n+  bool                has_non_debug_use(const Node* n);\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"opto\/reachability.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+macro(ReachabilityFence)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -399,0 +400,3 @@\n+  if (dead->is_ReachabilityFence()) {\n+    remove_reachability_fence(dead->as_ReachabilityFence());\n+  }\n@@ -462,0 +466,1 @@\n+  remove_useless_nodes(_reachability_fences, useful); \/\/ remove useless node recorded for post loop opts IGVN pass\n@@ -666,0 +671,1 @@\n+      _reachability_fences(comp_arena(), 8, 0, nullptr),\n@@ -935,0 +941,1 @@\n+      _reachability_fences(comp_arena(), 8, 0, nullptr),\n@@ -2515,2 +2522,0 @@\n-  if (failing())  return;\n-\n@@ -2521,0 +2526,11 @@\n+  \/\/ Once loop optimizations are over, it is safe to get rid of all reachability fence nodes and\n+  \/\/ migrate reachability edges to safepoints.\n+  if (OptimizeReachabilityFences && _reachability_fences.length() > 0) {\n+    TracePhase tp1(_t_idealLoop);\n+    TracePhase tp2(_t_reachability);\n+    PhaseIdealLoop::optimize(igvn, PostLoopOptsEliminateReachabilityFences);\n+    print_method(PHASE_ELIMINATE_REACHABILITY_FENCES, 2);\n+    if (failing())  return;\n+    assert(_reachability_fences.length() == 0 || PreserveReachabilityFencesOnConstants, \"no RF nodes allowed\");\n+  }\n+\n@@ -3976,0 +3992,2 @@\n+  expand_reachability_fences(sfpt);\n+\n@@ -3981,0 +3999,16 @@\n+  \/\/ Go over ReachabilityFence nodes to skip DecodeN nodes for referents.\n+  \/\/ The sole purpose of RF node is to keep the referent oop alive and\n+  \/\/ decoding the oop for that is not needed.\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n+    DecodeNNode* dn = rf->in(1)->isa_DecodeN();\n+    if (dn != nullptr) {\n+      if (!dn->has_non_debug_uses() || Matcher::narrow_oop_use_complex_address()) {\n+        rf->set_req(1, dn->in(1));\n+        if (dn->outcnt() == 0) {\n+          dn->disconnect_inputs(this);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -3994,15 +4028,2 @@\n-      if (in->is_DecodeNarrowPtr()) {\n-        bool safe_to_skip = true;\n-        if (!is_uncommon ) {\n-          \/\/ Is it safe to skip?\n-          for (uint i = 0; i < in->outcnt(); i++) {\n-            Node* u = in->raw_out(i);\n-            if (!u->is_SafePoint() ||\n-                (u->is_Call() && u->as_Call()->has_non_debug_use(n))) {\n-              safe_to_skip = false;\n-            }\n-          }\n-        }\n-        if (safe_to_skip) {\n-          n->set_req(j, in->in(1));\n-        }\n+      if (in->is_DecodeNarrowPtr() && (is_uncommon || !in->has_non_debug_uses())) {\n+        n->set_req(j, in->in(1));\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+class ReachabilityFenceNode;\n@@ -110,1 +111,2 @@\n-  LoopOptsVerify\n+  LoopOptsVerify,\n+  PostLoopOptsEliminateReachabilityFences\n@@ -378,0 +380,1 @@\n+  GrowableArray<ReachabilityFenceNode*> _reachability_fences; \/\/ List of reachability fences\n@@ -705,1 +708,0 @@\n-\n@@ -710,0 +712,3 @@\n+  ReachabilityFenceNode* reachability_fence(int idx) const { return _reachability_fences.at(idx); }\n+  int                    reachability_fences_count() const { return _reachability_fences.length(); }\n+\n@@ -731,0 +736,8 @@\n+  void add_reachability_fence(ReachabilityFenceNode* rf) {\n+    _reachability_fences.append(rf);\n+  }\n+\n+  void remove_reachability_fence(ReachabilityFenceNode* n) {\n+    _reachability_fences.remove_if_existing(n);\n+  }\n+\n@@ -1283,0 +1296,2 @@\n+  void expand_reachability_fences(Unique_Node_List& safepoints);\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1226,0 +1226,1 @@\n+  GrowableArray<Node*> non_debug_edges_worklist;\n@@ -1228,3 +1229,6 @@\n-    JVMState *jvms      = sfpt->jvms();\n-    uint merge_idx      = (sfpt->req() - jvms->scloff());\n-    int debug_start     = jvms->debug_start();\n+\n+    sfpt->remove_non_debug_edges(non_debug_edges_worklist);\n+\n+    JVMState* jvms  = sfpt->jvms();\n+    uint merge_idx  = (sfpt->req() - jvms->scloff());\n+    int debug_start = jvms->debug_start();\n@@ -1236,0 +1240,2 @@\n+    assert(sfpt->jvms()->endoff() == sfpt->req(), \"no extra edges past debug info allowed\");\n+\n@@ -1240,1 +1246,3 @@\n-    \/\/ See more details of these fields in the declaration of SafePointScalarMergeNode\n+    \/\/ See more details of these fields in the declaration of SafePointScalarMergeNode.\n+    \/\/ It is safe to include them into debug info straight away since create_scalarized_object_description()\n+    \/\/ will include all newly added inputs into debug info anyway.\n@@ -1243,0 +1251,1 @@\n+    sfpt->jvms()->set_endoff(sfpt->req());\n@@ -1257,1 +1266,1 @@\n-        return false;\n+        return false; \/\/ non-recoverable failure; recompile\n@@ -1264,0 +1273,1 @@\n+      non_debug_edges_worklist.remove_if_existing(ccpp); \/\/ drop scalarized input from non-debug info\n@@ -1271,0 +1281,1 @@\n+    non_debug_edges_worklist.remove_if_existing(original_sfpt_parent); \/\/ drop scalarized input from non-debug info\n@@ -1276,0 +1287,3 @@\n+\n+    sfpt->restore_non_debug_edges(non_debug_edges_worklist);\n+\n@@ -4633,0 +4647,1 @@\n+              op == Op_ReachabilityFence ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -155,3 +155,7 @@\n-  bool result = (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) || (n->is_Proj() && n->as_Proj()->bottom_type() == Type::CONTROL);\n-  assert(!result || (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint)\n-          || (n->is_Proj() && n->as_Proj()->_con == 0), \"If control projection, it must be projection 0\");\n+  bool result = n->is_ReachabilityFence() ||\n+                (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) ||\n+                (n->is_Proj() && n->as_Proj()->bottom_type() == Type::CONTROL);\n+  assert(!result ||\n+         (n->is_ReachabilityFence()) ||\n+         (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_SafePoint) ||\n+         (n->is_Proj() && n->as_Proj()->_con == 0), \"If control projection, it must be projection 0\");\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -3458,0 +3459,9 @@\n+\/\/------------------------------insert_reachability_fence----------------------\n+Node* GraphKit::insert_reachability_fence(Node* referent) {\n+  assert(!referent->is_top(), \"\");\n+  Node* rf = _gvn.transform(new ReachabilityFenceNode(C, control(), referent));\n+  set_control(rf);\n+  C->record_for_igvn(rf);\n+  return rf;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -799,0 +799,1 @@\n+  Node* insert_reachability_fence(Node* referent);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -570,0 +570,1 @@\n+  case vmIntrinsics::_Reference_reachabilityFence: return inline_reference_reachabilityFence();\n@@ -7075,0 +7076,8 @@\n+\/\/-----------------------inline_reference_reachabilityFence-----------------\n+\/\/ bool java.lang.ref.Reference.reachabilityFence();\n+bool LibraryCallKit::inline_reference_reachabilityFence() {\n+  Node* referent = argument(0);\n+  insert_reachability_fence(referent);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -332,0 +332,1 @@\n+  bool inline_reference_reachabilityFence();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,18 @@\n+\/\/------------------------------unique_loop_exit_or_null----------------------\n+\/\/ Return the loop-exit projection if it is unique.\n+IfFalseNode* IdealLoopTree::unique_loop_exit_or_null() {\n+  if (is_loop()) {\n+    if (head()->is_BaseCountedLoop()) {\n+      ProjNode* loop_exit = head()->as_BaseCountedLoop()->loopexit()->proj_out_or_null(0 \/* false *\/);\n+      if (loop_exit != nullptr) {\n+        return loop_exit->as_IfFalse();\n+      }\n+    } else if (head()->is_OuterStripMinedLoop()) {\n+      return head()->as_OuterStripMinedLoop()->outer_loop_exit();\n+    } else {\n+      \/\/ For now, conservatively report multiple loop exits exist.\n+    }\n+  }\n+  return nullptr; \/\/ not found or multiple loop exists exist\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4683,0 +4683,3 @@\n+  if (_reachability_fences != nullptr && _reachability_fences->size() > 0) {\n+    tty->print(\" has_rf\");\n+  }\n@@ -4690,0 +4693,3 @@\n+    if (_reachability_fences != nullptr && _reachability_fences->size() > 0) {\n+      tty->print(\" rfs={\"); _reachability_fences->dump_simple(); tty->print(\" }\");\n+    }\n@@ -4930,2 +4936,0 @@\n-  assert(!C->post_loop_opts_phase(), \"no loop opts allowed\");\n-\n@@ -4935,1 +4939,1 @@\n-\n+  bool do_eliminate_reachability_fences = (_mode == PostLoopOptsEliminateReachabilityFences);\n@@ -5002,2 +5006,3 @@\n-  bool stop_early = !C->has_loops() && !skip_loop_opts && !do_split_ifs && !do_max_unroll && !_verify_me &&\n-          !_verify_only && !bs->is_gc_specific_loop_opts_pass(_mode);\n+  bool stop_early = !C->has_loops() && !skip_loop_opts && !do_split_ifs && !do_max_unroll &&\n+                    !do_eliminate_reachability_fences && !_verify_me && !_verify_only &&\n+                    !bs->is_gc_specific_loop_opts_pass(_mode) ;\n@@ -5005,0 +5010,1 @@\n+  bool do_optimize_reachability_fences = OptimizeReachabilityFences && (C->reachability_fences_count() > 0);\n@@ -5006,1 +5012,1 @@\n-  if (stop_early && !do_expensive_nodes) {\n+  if (stop_early && !do_expensive_nodes && !do_optimize_reachability_fences) {\n@@ -5082,1 +5088,1 @@\n-  if (!_verify_me && !_verify_only && !strip_mined_loops_expanded) {\n+  if (!_verify_me && !_verify_only && !strip_mined_loops_expanded && !do_eliminate_reachability_fences) {\n@@ -5112,2 +5118,6 @@\n-    assert(do_expensive_nodes, \"why are we here?\");\n-    if (process_expensive_nodes()) {\n+    assert(do_expensive_nodes || do_optimize_reachability_fences, \"why are we here?\");\n+    if (do_optimize_reachability_fences && optimize_reachability_fences()) {\n+      recompute_dom_depth();\n+      DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n+    }\n+    if (do_expensive_nodes && process_expensive_nodes()) {\n@@ -5141,0 +5151,16 @@\n+  if (do_optimize_reachability_fences && optimize_reachability_fences()) {\n+    recompute_dom_depth();\n+    DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n+  }\n+\n+  if (do_eliminate_reachability_fences) {\n+    assert(C->post_loop_opts_phase(), \"required\");\n+    if (eliminate_reachability_fences()) {\n+      recompute_dom_depth();\n+      DEBUG_ONLY( if (VerifyLoopOptimizations) { verify(); } );\n+    }\n+    return;\n+  }\n+\n+  assert(!C->post_loop_opts_phase(), \"required\");\n+\n@@ -6031,0 +6057,5 @@\n+      } else if (n->is_ReachabilityFence()) {\n+        if (innermost->_reachability_fences == nullptr) {\n+          innermost->_reachability_fences = new Node_List();\n+        }\n+        innermost->_reachability_fences->push(n);\n@@ -7233,1 +7264,1 @@\n-  } else if (_curnt->_next != nullptr) {\n+  } else if (_curnt != _root && _curnt->_next != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+class ReachabilityFenceNode;\n@@ -670,0 +671,1 @@\n+  Node_List* _reachability_fences; \/\/ List of reachability fences in this loop\n@@ -682,0 +684,1 @@\n+      _reachability_fences(nullptr),\n@@ -742,0 +745,3 @@\n+  \/\/ Return unique loop-exit projection or null if there are multiple exits exist.\n+  IfFalseNode* unique_loop_exit_or_null();\n+\n@@ -1143,0 +1149,11 @@\n+  void remove_dead_node(Node* dead) {\n+    assert(dead->outcnt() == 0 && !dead->is_top(), \"node must be dead\");\n+    Node* c = get_ctrl(dead);\n+    IdealLoopTree* lpt = get_loop(c);\n+    _loop_or_ctrl.map(dead->_idx, nullptr); \/\/ This node is useless\n+    if (!lpt->is_root()) {\n+      lpt->_body.yank(dead);\n+    }\n+    igvn().remove_dead_node(dead);\n+  }\n+\n@@ -1466,0 +1483,14 @@\n+  \/\/ Reachability Fence (RF) support.\n+ private:\n+  bool is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only);\n+  bool find_redundant_rfs(Unique_Node_List& redundant_rfs);\n+  void insert_rf(Node* ctrl, Node* referent);\n+  void replace_rf(Node* old_node, Node* new_node);\n+  void remove_rf(ReachabilityFenceNode* rf);\n+#ifdef ASSERT\n+  bool has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only);\n+#endif \/\/ ASSERT\n+ public:\n+  bool optimize_reachability_fences();\n+  bool eliminate_reachability_fences();\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -615,0 +616,2 @@\n+      } else if (use->is_ReachabilityFence() && OptimizeReachabilityFences) {\n+        \/\/ ok to eliminate\n@@ -708,0 +711,1 @@\n+  GrowableArray<Node*> non_debug_edges_worklist;\n@@ -710,0 +714,3 @@\n+\n+    sfpt_done->remove_non_debug_edges(non_debug_edges_worklist);\n+\n@@ -711,0 +718,1 @@\n+    assert(sfpt_done->jvms()->endoff() == sfpt_done->req(), \"no extra edges past debug info allowed\");\n@@ -731,0 +739,3 @@\n+\n+    sfpt_done->restore_non_debug_edges(non_debug_edges_worklist);\n+\n@@ -736,0 +747,2 @@\n+  assert(sfpt->jvms()->endoff() == sfpt->req(), \"no extra edges past debug info allowed\");\n+\n@@ -860,2 +873,3 @@\n-bool PhaseMacroExpand::scalar_replacement(AllocateNode *alloc, GrowableArray <SafePointNode *>& safepoints) {\n-  GrowableArray <SafePointNode *> safepoints_done;\n+bool PhaseMacroExpand::scalar_replacement(AllocateNode* alloc, GrowableArray<SafePointNode*>& safepoints) {\n+  GrowableArray<SafePointNode*> safepoints_done;\n+  GrowableArray<Node*> non_debug_edges_worklist;\n@@ -868,0 +882,3 @@\n+\n+    sfpt->remove_non_debug_edges(non_debug_edges_worklist);\n+\n@@ -871,0 +888,1 @@\n+      sfpt->restore_non_debug_edges(non_debug_edges_worklist);\n@@ -879,0 +897,2 @@\n+    non_debug_edges_worklist.remove_if_existing(res); \/\/ drop scalarized input from non-debug info\n+    sfpt->restore_non_debug_edges(non_debug_edges_worklist);\n@@ -969,0 +989,2 @@\n+      } else if (use->is_ReachabilityFence() && OptimizeReachabilityFences) {\n+        use->as_ReachabilityFence()->clear_referent(_igvn); \/\/ redundant fence; will be removed during IGVN\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3958,1 +3958,1 @@\n-    if (x->Opcode() == Op_SCMemProj) {\n+    if (x->Opcode() == Op_SCMemProj || x->is_ReachabilityFence()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"opto\/reachability.hpp\"\n@@ -506,0 +507,3 @@\n+  if (is_ReachabilityFence()) {\n+    C->add_reachability_fence(n->as_ReachabilityFence());\n+  }\n@@ -625,0 +629,3 @@\n+  if (is_ReachabilityFence()) {\n+    compile->remove_reachability_fence(as_ReachabilityFence());\n+  }\n@@ -2969,0 +2976,19 @@\n+\/\/--------------------------has_non_debug_uses------------------------------\n+\/\/ Checks whether the node has any non-debug uses or not.\n+bool Node::has_non_debug_uses() const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* u = fast_out(i);\n+    if (u->is_SafePoint()) {\n+      if (u->is_Call() && u->as_Call()->has_non_debug_use(this)) {\n+        return true;\n+      }\n+      \/\/ Non-call safepoints have only debug uses.\n+    } else if (u->is_ReachabilityFence()) {\n+      \/\/ Reachability fence is treated as debug use.\n+    } else {\n+      return true; \/\/ everything else is conservatively treated as non-debug use\n+    }\n+  }\n+  return false; \/\/ no non-debug uses found\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -169,0 +169,1 @@\n+class ReachabilityFenceNode;\n@@ -446,0 +447,3 @@\n+  \/\/ Does the node have any immediate non-debug uses?\n+  bool has_non_debug_uses() const;\n+\n@@ -700,0 +704,1 @@\n+      DEFINE_CLASS_ID(ReachabilityFence, Multi, 4)\n@@ -1002,0 +1007,1 @@\n+  DEFINE_CLASS_QUERY(ReachabilityFence)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  Node*         _stress_rf_hook; \/\/ StressReachabilityFences support\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -373,0 +373,9 @@\n+    if (StressReachabilityFences && type->isa_oopptr() != nullptr) {\n+      \/\/ Keep all oop locals alive until the method returns as if there are\n+      \/\/ reachability fences for them at the end of the method.\n+      Node* loc = local(index);\n+      if (loc->bottom_type() != TypePtr::NULL_PTR) {\n+        assert(loc->bottom_type()->isa_oopptr() != nullptr, \"%s\", Type::str(loc->bottom_type()));\n+        _stress_rf_hook->add_req(loc);\n+      }\n+    }\n@@ -381,0 +390,9 @@\n+    if (StressReachabilityFences && type->isa_oopptr() != nullptr) {\n+      \/\/ Keep all oops on stack alive until the method returns as if there are\n+      \/\/ reachability fences for them at the end of the method.\n+      Node* stk = stack(index);\n+      if (stk->bottom_type() != TypePtr::NULL_PTR) {\n+        assert(stk->bottom_type()->isa_oopptr() != nullptr, \"%s\", Type::str(stk->bottom_type()));\n+        _stress_rf_hook->add_req(stk);\n+      }\n+    }\n@@ -415,0 +433,1 @@\n+  _stress_rf_hook = (StressReachabilityFences ? new Node(1) : nullptr);\n@@ -646,0 +665,5 @@\n+\n+  if (StressReachabilityFences) {\n+    _stress_rf_hook->destruct(&_gvn);\n+    _stress_rf_hook = nullptr;\n+  }\n@@ -1211,0 +1235,12 @@\n+  if (StressReachabilityFences) {\n+    \/\/ Keep all oop arguments alive until the method returns as if there are\n+    \/\/ reachability fences for them at the end of the method.\n+    int max_locals = jvms()->loc_size();\n+    for (int idx = 0; idx < max_locals; idx++) {\n+      Node* loc = local(idx);\n+      if (loc->bottom_type()->isa_oopptr() != nullptr) {\n+        _stress_rf_hook->add_req(loc);\n+      }\n+    }\n+  }\n+\n@@ -2197,0 +2233,9 @@\n+  if (StressReachabilityFences) {\n+    \/\/ Insert reachability fences for all oop arguments at the end of the method.\n+    for (uint i = 1; i < _stress_rf_hook->req(); i++) {\n+      Node* referent = _stress_rf_hook->in(i);\n+      assert(referent->bottom_type()->isa_oopptr(), \"%s\", Type::str(referent->bottom_type()));\n+      insert_reachability_fence(referent);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -93,0 +93,3 @@\n+    tty->print_cr (\"           ReachabilityFence: %7.3f s\", timers[_t_reachability].seconds());\n+    tty->print_cr (\"             Optimize:        %7.3f s\", timers[_t_reachability_optimize].seconds());\n+    tty->print_cr (\"             Eliminate:       %7.3f s\", timers[_t_reachability_eliminate].seconds());\n","filename":"src\/hotspot\/share\/opto\/phase.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+    f(       _t_reachability,        \"reachabilityFence\")        \\\n+    f(         _t_reachability_optimize,  \"reachabilityFence_optimize\") \\\n+    f(         _t_reachability_eliminate, \"reachabilityFence_eliminate\") \\\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2043,0 +2043,10 @@\n+  if (n->is_ReachabilityFence()) {\n+    \/\/ ReachabilityFencesNode::Identity() walks CFG to determine whether the node is redundant or not.\n+    \/\/ But since there's no accurate dominance information avaialble, it reports a conservative answer.\n+    \/\/ So, any change in CFG can potentially expose a ReachabilityFence node as redundant.\n+    \/\/\n+    \/\/ Found with:\n+    \/\/   java -XX:VerifyIterativeGVN=1000 -Xcomp -XX:+StressReachabilityFences\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  flags(ELIMINATE_REACHABILITY_FENCES,  \"Eliminate Reachability Fences\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,554 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/phaseX.hpp\"\n+#include \"opto\/reachability.hpp\"\n+#include \"opto\/regalloc.hpp\"\n+#include \"opto\/runtime.hpp\"\n+\n+\/*\n+ * java.lang.ref.Reference::reachabilityFence support.\n+ *\n+ * Reachability Fence (RF) ensures that the given object (referent) remains strongly reachable\n+ * regardless of any optimizing transformations the virtual machine may perform that might otherwise\n+ * allow the object to become unreachable.\n+ *\n+ * RFs are intended to be used in performance-critical code, so the primary goal for C2 support is\n+ * to reduce their runtime overhead as much as possible.\n+ *\n+ * Reference::reachabilityFence() calls are intrinsified into ReachabilityFence CFG nodes. RF node keeps\n+ * its referent alive, so the referent's location is recorded at every safepoint (in its oop map) which\n+ * interferes with referent's live range.\n+ *\n+ * It is tempting to directly attach referents to interfering safepoints right from the beginning, but it\n+ * doesn't play well with some optimizations C2 does (e.g., during loop-invariant code motion a safepoint\n+ * can become interfering once a load is hoisted).\n+ *\n+ * Instead, reachability representation transitions through multiple phases:\n+ *   (0) initial set of RFs is materialized during parsing (as a result of\n+ *       Reference.reachabilityFence intrinsification);\n+ *   (1) optimization pass during loop opts eliminates redundant RF nodes and\n+ *       moves the ones with loop-invariant referents outside (after) loops;\n+ *   (2) after loop opts are over, RF nodes are eliminated and their referents are transferred to\n+ *       safepoint nodes (appended as edges after debug info);\n+ *   (3) during final graph reshaping, referent edges are removed from safepoints and materialized as RF nodes\n+ *       attached to their safepoint node (closely following it in CFG graph).\n+ *\n+ * Some implementation considerations.\n+ *\n+ * (a) It looks attractive to get rid of RF nodes early and transfer to safepoint-attached representation,\n+ * but it is not correct until loop opts are done.\n+ *\n+ * Live ranges of values are routinely extended during loop opts. And it can break the invariant that\n+ * all interfering safepoints contain the referent in their oop map. (If an interfering safepoint doesn't\n+ * keep the referent alive, then it becomes possible for the referent to be prematurely GCed.)\n+ *\n+ * After loop opts are over, it becomes possible to reliably enumerate all interfering safe points and\n+ * to ensure that the referent is present in their oop maps.\n+ *\n+ * (b) RF nodes may interfere with Register Allocator (RA). If a safepoint is pruned during macro expansion,\n+ * it can make some RF nodes redundant, but we don't have information about their relations anymore to detect that.\n+ * Redundant RF node unnecessarily extends referent's live range and increases register pressure.\n+ *\n+ * Hence, we eliminate RF nodes and transfer their referents to corresponding safepoints (phase #2).\n+ * When safepoints are pruned, corresponding reachability edges also go away.\n+ *\n+ * (c) Unfortunately, it's not straightforward to stay with safepoint-attached representation till the very end,\n+ * because information about derived oops is attached to safepoints in a similar way. So, for now RFs are\n+ * rematerialized at safepoints before RA (phase #3).\n+ *\/\n+\n+\/\/ RF is redundant for some referent oop when the referent has another user which keeps it alive across the RF.\n+\/\/ In terms of dominance relation it can be formulated as \"a referent has a user which is dominated by the redundant RF\".\n+\/\/ Until loop opts are over, only RF nodes are considered as usages (controlled by rf_only flag).\n+static bool is_redundant_rf_helper(Node* ctrl, Node* referent, PhaseIdealLoop* phase, PhaseGVN& gvn, bool rf_only) {\n+  const Type* t = gvn.type(referent);\n+  if (!PreserveReachabilityFencesOnConstants && t->singleton()) {\n+    return true; \/\/ no-op fence\n+  }\n+  if (t == TypePtr::NULL_PTR) {\n+    return true; \/\/ no-op fence\n+  }\n+  if (referent->is_Proj() && referent->in(0)->is_CallJava()) {\n+    ciMethod* m = referent->in(0)->as_CallJava()->method();\n+    if (m != nullptr && m->is_boxing_method()) {\n+      return true;\n+    }\n+  }\n+  for (Node* cur = referent;\n+       cur != nullptr;\n+       cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n+    for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n+      Node* use = cur->fast_out(i);\n+      if (rf_only && !use->is_ReachabilityFence()) {\n+        continue; \/\/ skip non-RF uses\n+      }\n+      if (use != ctrl) {\n+        if (phase != nullptr) {\n+          Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n+          if (phase->is_dominator(ctrl, use_ctrl)) {\n+            return true;\n+          }\n+        } else {\n+          assert(rf_only, \"\");\n+          if (gvn.is_dominator(ctrl, use)) {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+Node* ReachabilityFenceNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return (remove_dead_region(phase, can_reshape) ? this : nullptr);\n+}\n+\n+Node* ReachabilityFenceNode::Identity(PhaseGVN* phase) {\n+  if (is_redundant_rf_helper(this, in(1), nullptr, *phase, true \/*rf_only*\/)) {\n+    return in(0);\n+  }\n+  return this;\n+}\n+\n+\/\/ Turn the RF node into a no-op by setting it's referent to null.\n+\/\/ Subsequent IGVN pass removes cleared nodes.\n+bool ReachabilityFenceNode::clear_referent(PhaseIterGVN& phase) {\n+  if (phase.type(in(1)) == TypePtr::NULL_PTR) {\n+    return false;\n+  } else {\n+    phase.replace_input_of(this, 1, phase.makecon(TypePtr::NULL_PTR));\n+    return true;\n+  }\n+}\n+\n+#ifndef PRODUCT\n+static void rf_desc(outputStream* st, const ReachabilityFenceNode* rf, PhaseRegAlloc* ra) {\n+  char buf[50];\n+  ra->dump_register(rf->in(1), buf, sizeof(buf));\n+  st->print(\"reachability fence [%s]\", buf);\n+}\n+\n+void ReachabilityFenceNode::format(PhaseRegAlloc* ra, outputStream* st) const {\n+  rf_desc(st, this, ra);\n+}\n+\n+void ReachabilityFenceNode::emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra) const {\n+  ResourceMark rm;\n+  stringStream ss;\n+  rf_desc(&ss, this, ra);\n+  const char* desc = masm->code_string(ss.freeze());\n+  masm->block_comment(desc);\n+}\n+#endif\n+\n+\/\/ Detect safepoint nodes which are important for reachability tracking purposes.\n+static bool is_significant_sfpt(Node* n) {\n+  if (n->is_SafePoint()) {\n+    SafePointNode* sfpt = n->as_SafePoint();\n+    if (sfpt->jvms() == nullptr) {\n+      return false; \/\/ not a real safepoint\n+    } else if (sfpt->is_CallStaticJava() && sfpt->as_CallStaticJava()->is_uncommon_trap()) {\n+      return false; \/\/ uncommon traps are exit points\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n+void PhaseIdealLoop::insert_rf(Node* ctrl, Node* referent) {\n+  IdealLoopTree* lpt = get_loop(ctrl);\n+  Node* ctrl_end = ctrl->unique_ctrl_out();\n+\n+  Node* new_rf = new ReachabilityFenceNode(C, ctrl, referent);\n+\n+  register_control(new_rf, lpt, ctrl);\n+  set_idom(new_rf, ctrl, dom_depth(ctrl) + 1);\n+  if (lpt->_reachability_fences == nullptr) {\n+    lpt->_reachability_fences = new Node_List();\n+  }\n+  lpt->_reachability_fences->push(new_rf);\n+\n+  igvn().rehash_node_delayed(ctrl_end);\n+  ctrl_end->replace_edge(ctrl, new_rf);\n+\n+  if (idom(ctrl_end) == ctrl) {\n+    set_idom(ctrl_end, new_rf, dom_depth(new_rf) + 1);\n+  } else {\n+    assert(ctrl_end->is_Region(), \"\");\n+  }\n+}\n+\n+void PhaseIdealLoop::replace_rf(Node* old_node, Node* new_node) {\n+  assert(old_node->is_ReachabilityFence() ||\n+         (old_node->is_Proj() && old_node->in(0)->is_ReachabilityFence()),\n+         \"%s\", NodeClassNames[old_node->Opcode()]);\n+\n+  IdealLoopTree* lpt = get_loop(old_node);\n+  if (!lpt->is_root()) {\n+    lpt->_body.yank(old_node);\n+  }\n+  assert(lpt->_reachability_fences != nullptr, \"missing\");\n+  assert(lpt->_reachability_fences->contains(old_node), \"missing\");\n+  lpt->_reachability_fences->yank(old_node);\n+  lazy_replace(old_node, new_node);\n+}\n+\n+void PhaseIdealLoop::remove_rf(ReachabilityFenceNode* rf) {\n+  Node* referent = rf->in(1);\n+  if (igvn().type(referent) != TypePtr::NULL_PTR) {\n+    igvn().replace_input_of(rf, 1, makecon(TypePtr::NULL_PTR));\n+    if (referent->outcnt() == 0) {\n+      remove_dead_node(referent);\n+    }\n+  }\n+  Node* rf_ctrl_in = rf->in(0);\n+  replace_rf(rf, rf_ctrl_in);\n+}\n+\n+bool PhaseIdealLoop::is_redundant_rf(ReachabilityFenceNode* rf, bool rf_only) {\n+  Node* referent = rf->in(1);\n+  return is_redundant_rf_helper(rf, referent, this, igvn(), rf_only);\n+}\n+\n+\/\/ Updates the unique list of redundant RFs.\n+\/\/ Returns true if new instances of redundant fences are found.\n+bool PhaseIdealLoop::find_redundant_rfs(Unique_Node_List& redundant_rfs) {\n+  bool found = false;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    assert(rf->outcnt() > 0, \"dead node\");\n+    if (!redundant_rfs.member(rf) && is_redundant_rf(rf, true \/*rf_only*\/)) {\n+      redundant_rfs.push(rf);\n+      found = true;\n+    }\n+  }\n+  return found;\n+}\n+\n+#ifdef ASSERT\n+static void dump_rfs_on(outputStream* st, PhaseIdealLoop* phase, Unique_Node_List& redundant_rfs, bool rf_only) {\n+  for (int i = 0; i < phase->C->reachability_fences_count(); i++) {\n+    Node* rf = phase->C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    bool detected = redundant_rfs.member(rf);\n+    bool redundant = is_redundant_rf_helper(rf, referent, phase, phase->igvn(), rf_only);\n+\n+    st->print(\" %3d: %s%s \", i, (redundant ? \"R\" : \" \"), (detected ? \"D\" : \" \"));\n+    rf->dump(\"\", false, st);\n+    st->cr();\n+\n+    st->print(\"         \");\n+    referent->dump(\"\", false, st);\n+    st->cr();\n+    if (redundant != detected) {\n+      for (Node* cur = referent;\n+           cur != nullptr;\n+           cur = (cur->is_ConstraintCast() ? cur->in(1) : nullptr)) {\n+        bool first = true;\n+        for (DUIterator_Fast imax, i = cur->fast_outs(imax); i < imax; i++) {\n+          Node* use = cur->fast_out(i);\n+          if (rf_only && !use->is_ReachabilityFence()) {\n+            continue; \/\/ skip non-RF uses\n+          }\n+          if (use != rf) {\n+            Node* use_ctrl = (rf_only ? use : phase->ctrl_or_self(use));\n+            if (phase->is_dominator(rf, use_ctrl)) {\n+              if (first) {\n+                st->print(\"=====REF \"); cur->dump(\"\", false, st); st->cr();\n+                first = false;\n+              }\n+              st->print(\"     D \"); use_ctrl->dump(\"\", false, st); st->cr();\n+              if (use != use_ctrl) {\n+                st->print(\"         \"); use->dump(\"\", false, st); st->cr();\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+bool PhaseIdealLoop::has_redundant_rfs(Unique_Node_List& ignored_rfs, bool rf_only) {\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n+    Node* referent = rf->in(1);\n+    assert(rf->outcnt() > 0, \"dead node\");\n+    if (ignored_rfs.member(rf)) {\n+      continue; \/\/ skip\n+    } else if (is_redundant_rf(rf, rf_only)) {\n+      dump_rfs_on(tty, this, ignored_rfs, rf_only);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+#endif \/\/ ASSERT\n+\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 1 ---------------------------------\n+\/\/ Optimization pass over reachability fences during loop opts.\n+\/\/ Eliminate redundant RFs and move RFs with loop-invariant referent out of the loop.\n+bool PhaseIdealLoop::optimize_reachability_fences() {\n+  Compile::TracePhase tp(_t_reachability_optimize);\n+\n+  assert(OptimizeReachabilityFences, \"required\");\n+\n+  Unique_Node_List redundant_rfs;\n+  find_redundant_rfs(redundant_rfs);\n+\n+  Node_List worklist;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    Node* rf = C->reachability_fence(i);\n+    if (!redundant_rfs.member(rf)) {\n+      \/\/ Move RFs out of counted loops when possible.\n+      IdealLoopTree* lpt = get_loop(rf);\n+      Node* referent = rf->in(1);\n+      Node* loop_exit = lpt->unique_loop_exit_or_null();\n+      if (lpt->is_invariant(referent) && loop_exit != nullptr) {\n+        \/\/ Switch to the outermost loop.\n+        for (IdealLoopTree* outer_loop = lpt->_parent;\n+             outer_loop->is_invariant(referent) && outer_loop->unique_loop_exit_or_null() != nullptr;\n+             outer_loop = outer_loop->_parent) {\n+          assert(is_member(outer_loop, rf), \"\");\n+          loop_exit = outer_loop->unique_loop_exit_or_null();\n+        }\n+        assert(loop_exit != nullptr, \"\");\n+        worklist.push(referent);\n+        worklist.push(loop_exit);\n+        redundant_rfs.push(rf);\n+      }\n+    }\n+  }\n+\n+  \/\/ Populate RFs outside counted loops.\n+  while (worklist.size() > 0) {\n+    Node* ctrl_out = worklist.pop();\n+    Node* referent = worklist.pop();\n+    insert_rf(ctrl_out, referent);\n+  }\n+\n+  \/\/ Redundancy is determined by dominance relation.\n+  \/\/ Sometimes it becomes evident that an RF is redundant once it is moved out of the loop.\n+  \/\/ Also, newly introduced RF can make some existing RFs redundant.\n+  find_redundant_rfs(redundant_rfs);\n+\n+  \/\/ Eliminate redundant RFs.\n+  bool progress = (redundant_rfs.size() > 0);\n+  while (redundant_rfs.size() > 0) {\n+    remove_rf(redundant_rfs.pop()->as_ReachabilityFence());\n+  }\n+\n+  assert(redundant_rfs.size() == 0, \"\");\n+  assert(!has_redundant_rfs(redundant_rfs, true \/*rf_only*\/), \"\");\n+\n+  return progress;\n+}\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 2 ---------------------------------\n+\n+\/\/ Linearly traverse CFG upwards starting at n until first merge point.\n+\/\/ All encountered safepoints are recorded in safepoints list.\n+static void linear_traversal(Node* n, Node_Stack& worklist, VectorSet& visited, Node_List& safepoints) {\n+  for (Node* ctrl = n; ctrl != nullptr; ctrl = ctrl->in(0)) {\n+    assert(ctrl->is_CFG(), \"\");\n+    if (visited.test_set(ctrl->_idx)) {\n+      return;\n+    } else {\n+      if (ctrl->is_Region()) {\n+        worklist.push(ctrl, 1);\n+        return; \/\/ stop at merge points\n+      } else if (is_significant_sfpt(ctrl)) {\n+        safepoints.push(ctrl);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Enumerate all safepoints which are reachable from the RF to its referent through CFG.\n+\/\/ Start at RF node and traverse CFG upwards until referent's control node is reached.\n+static void enumerate_interfering_sfpts(Node* rf, PhaseIdealLoop* phase, Node_List& safepoints) {\n+  Node* referent = rf->in(1);\n+  Node* referent_ctrl = phase->get_ctrl(referent);\n+  assert(phase->is_dominator(referent_ctrl, rf), \"sanity\");\n+\n+  VectorSet visited;\n+  visited.set(referent_ctrl->_idx); \/\/ end point\n+\n+  Node_Stack stack(0);\n+  linear_traversal(rf, stack, visited, safepoints); \/\/ start point\n+  while (stack.is_nonempty()) {\n+    Node* cur = stack.node();\n+    uint  idx = stack.index();\n+\n+    assert(cur != nullptr, \"\");\n+    assert(cur->is_Region(), \"%s\", NodeClassNames[cur->Opcode()]);\n+    assert(phase->is_dominator(referent_ctrl, cur), \"\");\n+    assert(idx > 0 && idx <= cur->req(), \"%d %d\", idx, cur->req());\n+\n+    if (idx < cur->req()) {\n+      stack.set_index(idx + 1);\n+      linear_traversal(cur->in(idx), stack, visited, safepoints);\n+    } else {\n+      stack.pop();\n+    }\n+  }\n+}\n+\n+\/\/ Start offset for reachability info on a safepoint node.\n+static uint rf_base_offset(SafePointNode* sfpt) {\n+  return sfpt->jvms()->oopoff();\n+}\n+\n+\/\/ Phase 2: migrate reachability info to safepoints.\n+\/\/ All RFs are replaced with edges from corresponding referents to interfering safepoints.\n+\/\/ Interfering safepoints are safepoint nodes which are reachable from the RF to its referent through CFG.\n+bool PhaseIdealLoop::eliminate_reachability_fences() {\n+  Compile::TracePhase tp(_t_reachability_eliminate);\n+\n+  assert(OptimizeReachabilityFences, \"required\");\n+  assert(C->post_loop_opts_phase(), \"required\");\n+  DEBUG_ONLY( int no_of_constant_rfs = 0; )\n+\n+  ResourceMark rm;\n+  Unique_Node_List redundant_rfs;\n+  Node_List worklist;\n+  for (int i = 0; i < C->reachability_fences_count(); i++) {\n+    ReachabilityFenceNode* rf = C->reachability_fence(i);\n+    assert(!is_redundant_rf(rf, true \/*rf_only*\/), \"missed\");\n+    if (PreserveReachabilityFencesOnConstants) {\n+      const Type* referent_t = igvn().type(rf->in(1));\n+      assert(referent_t != TypePtr::NULL_PTR, \"redundant rf\");\n+      bool is_constant_rf = referent_t->singleton();\n+      if (is_constant_rf) {\n+        DEBUG_ONLY( no_of_constant_rfs += 1; )\n+        continue; \/\/ don't eliminate constant rfs\n+      }\n+    }\n+    if (!is_redundant_rf(rf, false \/*rf_only*\/)) {\n+      Node_List safepoints;\n+      enumerate_interfering_sfpts(rf, this, safepoints);\n+\n+      Node* referent = rf->in(1);\n+      while (safepoints.size() > 0) {\n+        SafePointNode* sfpt = safepoints.pop()->as_SafePoint();\n+        assert(is_dominator(get_ctrl(referent), sfpt), \"\");\n+        assert(sfpt->req() == rf_base_offset(sfpt), \"no extra edges allowed\");\n+        if (sfpt->find_edge(referent) == -1) {\n+          worklist.push(sfpt);\n+          worklist.push(referent);\n+        }\n+      }\n+    }\n+    redundant_rfs.push(rf);\n+  }\n+\n+  while (worklist.size() > 0) {\n+    Node* referent = worklist.pop();\n+    Node* sfpt     = worklist.pop();\n+    sfpt->add_req(referent);\n+    igvn()._worklist.push(sfpt);\n+  }\n+\n+  \/\/ Eliminate redundant RFs.\n+  bool progress = (redundant_rfs.size() > 0);\n+  while (redundant_rfs.size() > 0) {\n+    remove_rf(redundant_rfs.pop()->as_ReachabilityFence());\n+  }\n+\n+  assert(C->reachability_fences_count() == no_of_constant_rfs, \"\");\n+  return progress;\n+}\n+\n+\/\/======================================================================\n+\/\/---------------------------- Phase 3 ---------------------------------\n+\n+\/\/ Find a point in CFG right after safepoint node to insert reachability fence.\n+static Node* sfpt_ctrl_out(SafePointNode* sfpt) {\n+  if (sfpt->is_Call()) {\n+    CallProjections callprojs;\n+    sfpt->as_Call()->extract_projections(&callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+    if (callprojs.fallthrough_catchproj != nullptr) {\n+      return callprojs.fallthrough_catchproj;\n+    } else if (callprojs.catchall_catchproj != nullptr) {\n+      return callprojs.catchall_catchproj; \/\/ rethrow stub \/\/ TODO: safe to ignore?\n+    } else if (callprojs.fallthrough_proj != nullptr) {\n+      return callprojs.fallthrough_proj; \/\/ no exceptions thrown\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  } else {\n+    return sfpt;\n+  }\n+}\n+\n+\/\/ Phase 3: expand reachability fences from safepoint info.\n+\/\/ Turn extra safepoint edges into reachability fences immediately following the safepoint.\n+void Compile::expand_reachability_fences(Unique_Node_List& safepoints) {\n+  for (uint i = 0; i < safepoints.size(); i++) {\n+    SafePointNode* sfpt = safepoints.at(i)->as_SafePoint();\n+\n+    uint rf_offset = rf_base_offset(sfpt);\n+    if (sfpt->jvms() != nullptr && sfpt->req() > rf_offset) {\n+      assert(is_significant_sfpt(sfpt), \"\");\n+      Node* ctrl_out = sfpt_ctrl_out(sfpt);\n+      Node* ctrl_end = ctrl_out->unique_ctrl_out();\n+\n+      Node* extra_edge = nullptr;\n+      if (sfpt->is_Call()) {\n+        address entry = sfpt->as_Call()->entry_point();\n+        if (entry == OptoRuntime::new_array_Java() ||\n+            entry == OptoRuntime::new_array_nozero_Java()) {\n+          \/\/ valid_length_test_input is appended during macro expansion at the very end\n+          int last_idx = sfpt->req() - 1;\n+          extra_edge = sfpt->in(last_idx);\n+          sfpt->del_req(last_idx);\n+        }\n+      }\n+\n+      while (sfpt->req() > rf_offset) {\n+        int idx = sfpt->req() - 1;\n+        Node* referent = sfpt->in(idx);\n+        sfpt->del_req(idx);\n+\n+        Node* new_rf = new ReachabilityFenceNode(C, ctrl_out, referent);\n+        ctrl_end->replace_edge(ctrl_out, new_rf);\n+        ctrl_end = new_rf;\n+      }\n+\n+      if (extra_edge != nullptr) {\n+        sfpt->add_req(extra_edge); \/\/ Add valid_length_test_input edge back\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/reachability.cpp","additions":554,"deletions":0,"binary":false,"changes":554,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_OPTO_REACHABILITY_HPP\n+#define SHARE_OPTO_REACHABILITY_HPP\n+\n+#include \"opto\/multnode.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/opcodes.hpp\"\n+#include \"opto\/type.hpp\"\n+\n+\/\/------------------------ReachabilityFenceNode--------------------------\n+\/\/ Represents a Reachability Fence (RF) in the code.\n+\/\/\n+\/\/ RF ensures that the given object (referent) remains strongly reachable regardless of\n+\/\/ any optimizing transformations the virtual machine may perform that might otherwise\n+\/\/ allow the object to become unreachable.\n+\n+\/\/ java.lang.ref.Reference::reachabilityFence calls are intrinsified into ReachabilityFence nodes.\n+\/\/\n+\/\/ More details in reachability.cpp.\n+class ReachabilityFenceNode : public Node {\n+public:\n+  ReachabilityFenceNode(Compile* C, Node* ctrl, Node* referent)\n+      : Node(1) {\n+    assert(referent->bottom_type()->isa_oopptr() ||\n+           referent->bottom_type()->isa_narrowoop() != nullptr ||\n+           referent->bottom_type() == TypePtr::NULL_PTR,\n+           \"%s\", Type::str(referent->bottom_type()));\n+    init_class_id(Class_ReachabilityFence);\n+    init_req(TypeFunc::Control, ctrl);\n+    add_req(referent);\n+    C->add_reachability_fence(this);\n+  }\n+  virtual int  Opcode() const;\n+  virtual bool is_CFG() const { return true; }\n+  virtual uint hash() const { return NO_HASH; }  \/\/ CFG nodes do not hash\n+  virtual bool depends_only_on_test() const { return false; };\n+  virtual uint ideal_reg() const { return 0; } \/\/ not matched in the AD file\n+  virtual const Type* bottom_type() const { return Type::CONTROL; }\n+  virtual const RegMask& in_RegMask(uint idx) const {\n+    \/\/ Fake input register mask for the referent: accepts all registers and all stack slots.\n+    \/\/ This avoids redundant register moves around reachability fences.\n+    return RegMask::All;\n+  }\n+  virtual const RegMask& out_RegMask() const {\n+    return RegMask::Empty;\n+  }\n+\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual Node* Identity(PhaseGVN* phase);\n+\n+  bool clear_referent(PhaseIterGVN& phase);\n+\n+#ifndef PRODUCT\n+  virtual void format(PhaseRegAlloc* ra, outputStream* st) const;\n+  virtual void emit(C2_MacroAssembler* masm, PhaseRegAlloc* ra) const;\n+#endif\n+};\n+\n+#endif \/\/ SHARE_OPTO_REACHABILITY_HPP\n","filename":"src\/hotspot\/share\/opto\/reachability.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -653,1 +653,1 @@\n-    @ForceInline\n+    @IntrinsicCandidate\n@@ -655,5 +655,3 @@\n-        \/\/ Does nothing. This method is annotated with @ForceInline to eliminate\n-        \/\/ most of the overhead that using @DontInline would cause with the\n-        \/\/ HotSpot JVM, when this fence is used in a wide variety of situations.\n-        \/\/ HotSpot JVM retains the ref and does not GC it before a call to\n-        \/\/ this method, because the JIT-compilers do not have GC-only safepoints.\n+        \/\/ Does nothing. HotSpot JVM retains the ref and does not GC it before a call to this method.\n+        \/\/ NB! Some of the optimizations JIT-compilers perform may break that invariant,\n+        \/\/ so the method is intrinsified when the invariant doesn't hold.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\/*\n+ * @test\n+ * @bug 8290892\n+ * @summary Tests to ensure that reachabilityFence() correctly keeps objects from being collected prematurely.\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -Xbatch compiler.c2.TestReachabilityFence\n+ *\/\n+public class TestReachabilityFence {\n+    private static final int SIZE = 100;\n+\n+    static final boolean[] STATUS = new boolean[2];\n+\n+    interface MyBuffer {\n+        byte get(int offset);\n+    }\n+    static class MyBufferOnHeap implements MyBuffer {\n+\n+        private static int current = 0;\n+        private final static byte[][] payload = new byte[10][];\n+\n+        private final int id;\n+\n+        public MyBufferOnHeap() {\n+            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            id = current++;\n+            payload[id] = new byte[SIZE];\n+\n+            \/\/ Initialize buffer\n+            for (int i = 0; i < SIZE; ++i) {\n+                put(i, (byte) 42);\n+            }\n+\n+            \/\/ Register a cleaner to free the memory when the buffer is garbage collected\n+            int lid = id; \/\/ Capture current value\n+            Cleaner.create().register(this, () -> { free(lid); });\n+\n+            System.out.println(\"Created new buffer of size = \" + SIZE + \" with id = \" + id);\n+        }\n+\n+        private static void free(int id) {\n+            System.out.println(\"Freeing buffer with id = \" + id);\n+            for (int i = 0; i < SIZE; ++i) {\n+                payload[id][i] = (byte)0;\n+            }\n+            payload[id] = null;\n+\n+            synchronized (STATUS) {\n+                STATUS[0] = true;\n+                STATUS.notifyAll();\n+            }\n+        }\n+\n+        public void put(int offset, byte b) {\n+            payload[id][offset] = b;\n+        }\n+\n+        public byte get(int offset) {\n+            try {\n+                return payload[id][offset];\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        }\n+    }\n+\n+    static class MyBufferOffHeap implements MyBuffer {\n+        private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+        private static int current = 0;\n+        private static long payload[] = new long[10];\n+\n+        private final int id;\n+\n+        public MyBufferOffHeap() {\n+            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            id = current++;\n+            payload[id] = UNSAFE.allocateMemory(SIZE);\n+\n+            \/\/ Initialize buffer\n+            for (int i = 0; i < SIZE; ++i) {\n+                put(i, (byte) 42);\n+            }\n+\n+            \/\/ Register a cleaner to free the memory when the buffer is garbage collected\n+            int lid = id; \/\/ Capture current value\n+            Cleaner.create().register(this, () -> { free(lid); });\n+\n+            System.out.println(\"Created new buffer of size = \" + SIZE + \" with id = \" + id);\n+        }\n+\n+        private static void free(int id) {\n+            System.out.println(\"Freeing buffer with id = \" + id);\n+            for (int i = 0; i < SIZE; ++i) {\n+                UNSAFE.putByte(payload[id] + i, (byte)0);\n+            }\n+            \/\/ UNSAFE.freeMemory(payload[id]); \/\/ don't deallocate backing memory to avoid crashes\n+            payload[id] = 0;\n+\n+            synchronized (STATUS) {\n+                STATUS[1] = true;\n+                STATUS.notifyAll();\n+            }\n+        }\n+\n+        public void put(int offset, byte b) {\n+            UNSAFE.putByte(payload[id] + offset, b);\n+        }\n+\n+        public byte get(int offset) {\n+            try {\n+                return UNSAFE.getByte(payload[id] + offset);\n+            } finally {\n+                Reference.reachabilityFence(this);\n+            }\n+        }\n+    }\n+\n+    static MyBuffer bufferOff = new MyBufferOffHeap();\n+    static MyBuffer bufferOn = new MyBufferOnHeap();\n+\n+    static long counter1 = 0;\n+    static long counter2 = 0;\n+\n+    \/\/ Off-heap version.\n+    static long testOffHeap(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBuffer myBuffer = bufferOff; \/\/ local\n+            if (myBuffer == null) {\n+                return j;\n+            }\n+            for (int i = 0; i < SIZE; i++) {\n+                \/\/ The access is split into base address load (payload[id]), offset computation, and data load.\n+                \/\/ While offset is loop-variant, payload[id] is not and can be hoisted.\n+                \/\/ If bufferOff and payload[id] loads are hoisted outside outermost loop, it eliminates all usages of\n+                \/\/ myBuffer oop inside the loop and bufferOff can be GCed at the safepoint on outermost loop back branch.\n+                byte b = myBuffer.get(i); \/\/ inlined\n+                if (b != 42) {\n+                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            counter1 = j;\n+            \/\/ Keep the buffer live while we read from it\n+            Reference.reachabilityFence(myBuffer);\n+        } \/\/ safepoint on loop backedge does NOT contain myBuffer local as part of its JVM state\n+        return limit;\n+    }\n+\n+    \/\/ On-heap version.\n+    static long testOnHeap(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBuffer myBuffer = bufferOn;\n+            if (myBuffer == null) {\n+                return j;\n+            }\n+            for (int i = 0; i < SIZE; i++) {\n+                byte b = myBuffer.get(i);\n+                if (b != 42) {\n+                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n+                    throw new AssertionError(msg);\n+                }\n+            }\n+            counter2 = j;\n+            \/\/ Keep the buffer live while we read from it\n+            Reference.reachabilityFence(myBuffer);\n+        }\n+        return limit;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ Warmup to trigger compilation\n+        for (int i = 0; i < 10_000; i++) {\n+            testOffHeap(10);\n+            testOnHeap(10);\n+        }\n+\n+        CountDownLatch latch = new CountDownLatch(3);\n+        final Throwable[] result = new Throwable[2];\n+\n+        Thread compThread1 = new Thread(() -> {\n+            latch.countDown(); \/\/ synchronize with main thread\n+            try {\n+                System.out.printf(\"Computation thread #1 has started\\n\");\n+                long cnt = testOffHeap(100_000_000);\n+                System.out.printf(\"#1 Finished after %d iterations\\n\", cnt);\n+            } catch (Throwable e) {\n+                System.out.printf(\"#1 Finished with an exception %s\\n\", e);\n+                result[0] = e;\n+            }\n+        });\n+\n+        Thread compThread2 = new Thread(() -> {\n+            latch.countDown(); \/\/ synchronize with main thread\n+            try {\n+                System.out.printf(\"Computation thread #2 has started\\n\");\n+                long cnt = testOnHeap(100_000_000);\n+                System.out.printf(\"#2 Finished after %d iterations\\n\", cnt);\n+            } catch (Throwable e) {\n+                System.out.printf(\"#2 Finished with an exception %s\\n\", e);\n+                result[1] = e;\n+            }\n+        });\n+\n+        compThread1.start();\n+        compThread2.start();\n+\n+        latch.countDown(); \/\/ synchronize with comp thread\n+\n+        Thread.sleep(100); \/\/ let compThread proceed\n+\n+        \/\/ Clear reference to 'buffer' and make sure it's garbage collected\n+        System.out.printf(\"Buffer set to null. Waiting for garbage collection. (counter1 = %d; counter2 = %d)\\n\",\n+                          counter1, counter2);\n+        bufferOn = null;\n+        bufferOff = null;\n+\n+        System.gc();\n+\n+        synchronized (STATUS) {\n+            do {\n+                if (STATUS[0] && STATUS[1] ) {\n+                    break;\n+                } else {\n+                    System.out.printf(\"Waiting for cleanup... (counter1 = %d; counter2 = %d)\\n\", counter1, counter2);\n+                    System.gc();\n+                    STATUS.wait(100);\n+                }\n+            } while (true);\n+        }\n+\n+        compThread1.join();\n+        compThread2.join();\n+        if (result[0] != null) {\n+            System.out.println(\"TEST FAILED\");\n+            throw result[0];\n+        }\n+        if (result[1] != null) {\n+            System.out.println(\"TEST FAILED\");\n+            throw result[0];\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFence.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8290892\n+ * @summary Test diagnostic modes for Reference.reachabilityFence support\n+ *\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressReachabilityFences -XX:-OptimizeReachabilityFences -XX:-PreserveReachabilityFencesOnConstants\n+ *                     compiler.c2.TestReachabilityFenceFlags\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressReachabilityFences -XX:-OptimizeReachabilityFences -XX:+PreserveReachabilityFencesOnConstants\n+ *                     compiler.c2.TestReachabilityFenceFlags\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressReachabilityFences -XX:+OptimizeReachabilityFences -XX:-PreserveReachabilityFencesOnConstants\n+ *                     compiler.c2.TestReachabilityFenceFlags\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+StressReachabilityFences -XX:+OptimizeReachabilityFences -XX:+PreserveReachabilityFencesOnConstants\n+ *                     compiler.c2.TestReachabilityFenceFlags\n+ *\/\n+public class TestReachabilityFenceFlags {\n+    public static void main(String[] args) throws Throwable {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFenceFlags.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+\/*\n+ * @test\n+ * @bug 8290892\n+ * @summary Tests to ensure that reachabilityFence() correctly keeps objects from being collected prematurely.\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/bootclasspath\/othervm -Xbatch -XX:-TieredCompilation -XX:CompileCommand=quiet\n+ *                                 -XX:CompileCommand=compileonly,*::test\n+ *                                 -XX:+UnlockDiagnosticVMOptions -XX:+PreserveReachabilityFencesOnConstants\n+ *                                 compiler.c2.TestReachabilityFenceOnConstant\n+ *\/\n+public class TestReachabilityFenceOnConstant {\n+    static final Unsafe U = Unsafe.getUnsafe();\n+\n+    static final long BUFFER_SIZE = 1024;\n+    static @Stable MyBuffer BUFFER = new MyBuffer();\n+\n+    static volatile boolean isCleaned = false;\n+\n+    static class MyBuffer {\n+        final @Stable long address;\n+        final @Stable long limit;\n+\n+        MyBuffer() {\n+            final long adr = U.allocateMemory(BUFFER_SIZE);\n+            U.setMemory(adr, BUFFER_SIZE, (byte)0);\n+            address = adr;\n+            limit = BUFFER_SIZE;\n+            System.out.printf(\"Allocated memory (%d bytes): 0x%016x\\n\", BUFFER_SIZE, adr);\n+            Cleaner.create().register(this, () -> {\n+                System.out.printf(\"Freed memory (%d bytes): 0x%016x\\n\", BUFFER_SIZE, adr);\n+                U.setMemory(adr, BUFFER_SIZE, (byte)-1); \/\/ clear\n+                U.freeMemory(adr);\n+                isCleaned = true;\n+            });\n+        }\n+\n+        byte getByte(long offset) {\n+            return U.getByte(null, address + offset);\n+        }\n+    }\n+\n+    static int test() {\n+        int acc = 0;\n+        MyBuffer buf = BUFFER;\n+        try {\n+            for (long i = 0; i < buf.limit; i++) {\n+                acc += buf.getByte(i);\n+            }\n+        } finally {\n+            Reference.reachabilityFence(buf);\n+        }\n+        return acc;\n+    }\n+\n+    static void runTest() {\n+        for (int i = 0; i < 20_000; i++) {\n+            if (test() != 0) {\n+                throw new AssertionError(\"observed stale buffer: TestConstantOop::isCleaned=\" + isCleaned);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {\n+        runTest(); \/\/ run test() and constant fold accesses to BUFFER (and it's state) during JIT-compilation\n+\n+        BUFFER = null; \/\/ remove last strong root\n+\n+        \/\/ Ensure the instance is GCed.\n+        while (!isCleaned) {\n+            try {\n+                System.gc();\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        try {\n+            runTest(); \/\/ repeat to ensure stale BUFFER contents is not accessed\n+        } catch (NullPointerException e) {\n+            \/\/ expected; ignore\n+        }\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFenceOnConstant.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -100,0 +100,1 @@\n+    ELIMINATE_REACHABILITY_FENCES(  \"Eliminate Reachability Fences\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+        List<Node> reachabilityFences = new ArrayList<>();\n+        List<Node> projections = new ArrayList<>();\n@@ -84,0 +86,4 @@\n+                } else if (header.endsWith(\"ReachabilityFence\")) {\n+                    reachabilityFences.add(new Node(\"ReachabilityFence\", line));\n+                } else if (header.endsWith(\"Proj\")) {\n+                    projections.add(new Node(\"Proj\", line));\n@@ -89,6 +95,13 @@\n-        for (Node loopEnd : loopEnds) {\n-            found |= loopEnd.to.stream()\n-                                 .filter(id -> nodeListHasElementWithId(safePoints, id))\n-                                 .findAny()\n-                                 .isPresent();\n-        }\n+\n+        \/\/ CountedLoopEnd -> SafePoint\n+        found |= loopEnds.stream()\n+                .flatMap(n -> n.to.stream()).flatMap(id -> safePoints.stream().filter(node -> node.id == id))\n+                .findAny().isPresent();\n+\n+        \/\/ CountedLoopEnd -> Proj -> ReachabilityFence -> SafePoint\n+        found |= loopEnds.stream()\n+                .flatMap(n -> n.to.stream()).flatMap(id -> projections.stream().filter(node -> node.id == id))\n+                .flatMap(n -> n.to.stream()).flatMap(id -> reachabilityFences.stream().filter(node -> node.id == id))\n+                .flatMap(n -> n.to.stream()).flatMap(id -> safePoints.stream().filter(node -> node.id == id))\n+                .findAny().isPresent();\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/UseCountedLoopSafepointsTest.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"}]}