{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Arrays;\n+import java.util.concurrent.Callable;\n@@ -29,1 +31,0 @@\n-\n@@ -32,0 +33,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -37,0 +40,1 @@\n+ * @library \/test\/lib \/\n@@ -55,1 +59,1 @@\n-            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            \/\/ Get a unique id, allocate memory, and save the address in the payload array.\n@@ -64,1 +68,1 @@\n-            \/\/ Register a cleaner to free the memory when the buffer is garbage collected\n+            \/\/ Register a cleaner to free the memory when the buffer is garbage collected.\n@@ -106,1 +110,1 @@\n-            \/\/ Get a unique id, allocate memory and save the address in the payload array\n+            \/\/ Get a unique id, allocate memory, and save the address in the payload array.\n@@ -149,2 +153,22 @@\n-    static MyBuffer bufferOff = new MyBufferOffHeap();\n-    static MyBuffer bufferOn = new MyBufferOnHeap();\n+    static MyBufferOffHeap bufferOff = new MyBufferOffHeap();\n+    static MyBufferOnHeap bufferOn = new MyBufferOnHeap();\n+\n+    static long[] counters = new long[4];\n+\n+    static boolean test(MyBuffer buf) {\n+        if (buf == null) {\n+            return false;\n+        }\n+        for (int i = 0; i < SIZE; i++) {\n+            \/\/ The access is split into base address load (payload[id]), offset computation, and data load.\n+            \/\/ While offset is loop-variant, payload[id] is not and can be hoisted.\n+            \/\/ If bufferOff and payload[id] loads are hoisted outside outermost loop, it eliminates all usages of\n+            \/\/ myBuffer oop inside the loop and bufferOff can be GCed at the safepoint on outermost loop back branch.\n+            byte b = buf.get(i); \/\/ inlined\n+            if (b != 42) {\n+                String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n+                throw new AssertionError(msg);\n+            }\n+        }\n+        return true;\n+    }\n@@ -152,2 +176,1 @@\n-    static long counter1 = 0;\n-    static long counter2 = 0;\n+    \/* ===================================== Off-heap versions ===================================== *\/\n@@ -155,2 +178,7 @@\n-    \/\/ Off-heap version.\n-    static long testOffHeap(int limit) {\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.AFTER_LOOP_OPTS)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"0\"}, phase = CompilePhase.EXPAND_REACHABILITY_FENCES)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    static long testOffHeap1(int limit) {\n@@ -158,2 +186,2 @@\n-            MyBuffer myBuffer = bufferOff; \/\/ local\n-            if (myBuffer == null) {\n+            MyBufferOffHeap myBuffer = bufferOff; \/\/ local\n+            if (!test(myBuffer)) {\n@@ -162,9 +190,17 @@\n-            for (int i = 0; i < SIZE; i++) {\n-                \/\/ The access is split into base address load (payload[id]), offset computation, and data load.\n-                \/\/ While offset is loop-variant, payload[id] is not and can be hoisted.\n-                \/\/ If bufferOff and payload[id] loads are hoisted outside outermost loop, it eliminates all usages of\n-                \/\/ myBuffer oop inside the loop and bufferOff can be GCed at the safepoint on outermost loop back branch.\n-                byte b = myBuffer.get(i); \/\/ inlined\n-                if (b != 42) {\n-                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n-                    throw new AssertionError(msg);\n+            counters[0] = j;\n+        } \/\/ safepoint on loop backedge does NOT contain myBuffer local as part of its JVM state\n+        return limit;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"2\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"2\"}, phase = CompilePhase.AFTER_LOOP_OPTS)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"0\"}, phase = CompilePhase.EXPAND_REACHABILITY_FENCES)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    static long testOffHeap2(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBufferOffHeap myBuffer = bufferOff; \/\/ local\n+            try {\n+                if (!test(myBuffer)) {\n+                    return j;\n@@ -172,0 +208,3 @@\n+                counters[1] = j;\n+            } finally {\n+                Reference.reachabilityFence(myBuffer);\n@@ -173,3 +212,0 @@\n-            counter1 = j;\n-            \/\/ Keep the buffer live while we read from it\n-            Reference.reachabilityFence(myBuffer);\n@@ -180,2 +216,9 @@\n-    \/\/ On-heap version.\n-    static long testOnHeap(int limit) {\n+    \/* ===================================== On-heap versions ===================================== *\/\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.AFTER_LOOP_OPTS)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"0\"}, phase = CompilePhase.EXPAND_REACHABILITY_FENCES)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    static long testOnHeap1(int limit) {\n@@ -183,2 +226,2 @@\n-            MyBuffer myBuffer = bufferOn;\n-            if (myBuffer == null) {\n+            MyBufferOnHeap myBuffer = bufferOn; \/\/ local\n+            if (!test(myBuffer)) {\n@@ -187,5 +230,17 @@\n-            for (int i = 0; i < SIZE; i++) {\n-                byte b = myBuffer.get(i);\n-                if (b != 42) {\n-                    String msg = \"Unexpected value = \" + b + \". Buffer was garbage collected before reachabilityFence was reached!\";\n-                    throw new AssertionError(msg);\n+            counters[2] = j;\n+        } \/\/ safepoint on loop backedge does NOT contain myBuffer local as part of its JVM state\n+        return limit;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.NUMBER_42})\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"2\"}, phase = CompilePhase.AFTER_PARSING)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"2\"}, phase = CompilePhase.AFTER_LOOP_OPTS)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"0\"}, phase = CompilePhase.EXPAND_REACHABILITY_FENCES)\n+    @IR(counts = {IRNode.REACHABILITY_FENCE, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    static long testOnHeap2(int limit) {\n+        for (long j = 0; j < limit; j++) {\n+            MyBufferOnHeap myBuffer = bufferOn; \/\/ local\n+            try {\n+                if (!test(myBuffer)) {\n+                    return j;\n@@ -193,0 +248,3 @@\n+                counters[3] = j;\n+            } finally {\n+                Reference.reachabilityFence(myBuffer);\n@@ -194,4 +252,1 @@\n-            counter2 = j;\n-            \/\/ Keep the buffer live while we read from it\n-            Reference.reachabilityFence(myBuffer);\n-        }\n+        } \/\/ safepoint on loop backedge does NOT contain myBuffer local as part of its JVM state\n@@ -201,2 +256,2 @@\n-    public static void main(String[] args) throws Throwable {\n-        \/\/ Warmup to trigger compilation\n+    static void runJavaTestCases() throws Throwable {\n+        \/\/ Warmup to trigger compilations.\n@@ -204,2 +259,4 @@\n-            testOffHeap(10);\n-            testOnHeap(10);\n+            testOffHeap1(10);\n+            testOffHeap2(10);\n+            testOnHeap1(10);\n+            testOnHeap2(10);\n@@ -208,26 +265,26 @@\n-        CountDownLatch latch = new CountDownLatch(3);\n-        final Throwable[] result = new Throwable[2];\n-\n-        Thread compThread1 = new Thread(() -> {\n-            latch.countDown(); \/\/ synchronize with main thread\n-            try {\n-                System.out.printf(\"Computation thread #1 has started\\n\");\n-                long cnt = testOffHeap(100_000_000);\n-                System.out.printf(\"#1 Finished after %d iterations\\n\", cnt);\n-            } catch (Throwable e) {\n-                System.out.printf(\"#1 Finished with an exception %s\\n\", e);\n-                result[0] = e;\n-            }\n-        });\n-\n-        Thread compThread2 = new Thread(() -> {\n-            latch.countDown(); \/\/ synchronize with main thread\n-            try {\n-                System.out.printf(\"Computation thread #2 has started\\n\");\n-                long cnt = testOnHeap(100_000_000);\n-                System.out.printf(\"#2 Finished after %d iterations\\n\", cnt);\n-            } catch (Throwable e) {\n-                System.out.printf(\"#2 Finished with an exception %s\\n\", e);\n-                result[1] = e;\n-            }\n-        });\n+        @SuppressWarnings(\"unchecked\")\n+        Callable<Long>[] tasks = new Callable[] {\n+                () -> testOffHeap1(100_000_000),\n+                () -> testOffHeap2(100_000_000),\n+                () -> testOnHeap1(100_000_000),\n+                () -> testOnHeap2(100_000_000),\n+        };\n+        int taskCount = tasks.length;\n+        CountDownLatch latch = new CountDownLatch(taskCount + 1);\n+        final Thread[] workers = new Thread[taskCount];\n+        final Throwable[] result = new Throwable[taskCount];\n+\n+        for (int i = 0; i < taskCount; i++) {\n+            final int id = i;\n+            workers[id] = new Thread(() -> {\n+                latch.countDown(); \/\/ synchronize with main thread\n+                try {\n+                    System.out.printf(\"Computation thread #%d has started\\n\", id);\n+                    long cnt = tasks[id].call();\n+                    System.out.printf(\"#%d Finished after %d iterations\\n\", id, cnt);\n+                } catch (Throwable e) {\n+                    System.out.printf(\"#%d Finished with an exception %s\\n\", id, e);\n+                    result[id] = e;\n+                }\n+            });\n+        }\n@@ -235,2 +292,3 @@\n-        compThread1.start();\n-        compThread2.start();\n+        for (Thread worker : workers) {\n+            worker.start();\n+        }\n@@ -238,1 +296,1 @@\n-        latch.countDown(); \/\/ synchronize with comp thread\n+        latch.countDown(); \/\/ synchronize with worker threads\n@@ -240,1 +298,1 @@\n-        Thread.sleep(100); \/\/ let compThread proceed\n+        Thread.sleep(100); \/\/ let workers proceed\n@@ -242,3 +300,2 @@\n-        \/\/ Clear reference to 'buffer' and make sure it's garbage collected\n-        System.out.printf(\"Buffer set to null. Waiting for garbage collection. (counter1 = %d; counter2 = %d)\\n\",\n-                          counter1, counter2);\n+        \/\/ Clear references to buffers and make sure it's garbage collected.\n+        System.out.printf(\"Buffers set to null. Waiting for garbage collection. (counters = %s)\\n\", Arrays.toString(counters));\n@@ -252,1 +309,1 @@\n-                if (STATUS[0] && STATUS[1] ) {\n+                if (STATUS[0] && STATUS[1]) {\n@@ -255,1 +312,1 @@\n-                    System.out.printf(\"Waiting for cleanup... (counter1 = %d; counter2 = %d)\\n\", counter1, counter2);\n+                    System.out.printf(\"Waiting for cleanup... (counters = %s)\\n\", Arrays.toString(counters));\n@@ -262,5 +319,2 @@\n-        compThread1.join();\n-        compThread2.join();\n-        if (result[0] != null) {\n-            System.out.println(\"TEST FAILED\");\n-            throw result[0];\n+        for (Thread worker : workers) {\n+            worker.join();\n@@ -268,3 +322,7 @@\n-        if (result[1] != null) {\n-            System.out.println(\"TEST FAILED\");\n-            throw result[0];\n+\n+        System.out.printf(\"Results: %s\\n\", Arrays.deepToString(result));\n+\n+        for (Throwable e : result) {\n+            if (e != null) {\n+                throw e;\n+            }\n@@ -272,0 +330,1 @@\n+    }\n@@ -273,1 +332,15 @@\n-        System.out.println(\"TEST PASSED\");\n+    static void runIRTestCases() {\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        framework.start();\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        try {\n+            runIRTestCases();\n+            runJavaTestCases();\n+            System.out.println(\"TEST PASSED\");\n+        } catch (Throwable e) {\n+            System.out.println(\"TEST FAILED\");\n+            throw e;\n+        }\n@@ -275,1 +348,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReachabilityFence.java","additions":159,"deletions":86,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    ELIMINATE_REACHABILITY_FENCES(  \"Eliminate Reachability Fences\"),\n+    EXPAND_REACHABILITY_FENCES(     \"Expand Reachability Fences\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3044,0 +3044,5 @@\n+    public static final String REACHABILITY_FENCE = PREFIX + \"REACHABILITY_FENCE\" + POSTFIX;\n+    static {\n+        fromBeforeRemoveUselessToFinalCode(REACHABILITY_FENCE, \"ReachabilityFence\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}