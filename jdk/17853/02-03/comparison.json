{"files":[{"patch":"@@ -1538,5 +1538,23 @@\n-  if ((cop == Op_CmpI && cmp1_op == Op_AddI && cmp2_op == Op_ConI) ||\n-      (cop == Op_CmpL && cmp1_op == Op_AddL && cmp2_op == Op_ConL)) {\n-    Node* x = cmp1->in(1);\n-    Node* c1 = cmp1->in(2);\n-    if ((c1->Opcode() == Op_ConI || c1->Opcode() == Op_ConL) &&\n+  \/\/ and  cmp(sub(c2, x), c1) into cmp(sub(c2, c1), x)\n+  if ((cop == Op_CmpI && (cmp1_op == Op_AddI || cmp1_op == Op_SubI) &&\n+       cmp2_op == Op_ConI) ||\n+      (cop == Op_CmpL && (cmp1_op == Op_AddL || cmp1_op == Op_SubL) &&\n+       cmp2_op == Op_ConL)) {\n+    Node* x;\n+    Node* c1;\n+    Node* c2;\n+    if (cmp1->is_Add()) {\n+      x = cmp1->in(1);\n+      c1 = cmp1->in(2);\n+      c2 = cmp2;\n+    } else {\n+      assert(cmp1->is_Sub(), \"cmp1 must be sub\");\n+      x = cmp1->in(2);\n+      c1 = cmp2;\n+      c2 = cmp1->in(1);\n+    }\n+    BasicType bt = cop == Op_CmpI ? T_INT : T_LONG;\n+    const TypeInteger* x_type = phase->type(x)->isa_integer(bt);\n+    const TypeInteger* c1_type = phase->type(c1)->isa_integer(bt);\n+    const TypeInteger* c2_type = phase->type(c2)->isa_integer(bt);\n+    if (x_type != nullptr && c1_type != nullptr && c2_type != nullptr &&\n@@ -1544,0 +1562,1 @@\n+      \/\/ Do not fold if any node is TOP.\n@@ -1546,38 +1565,12 @@\n-      BasicType bt = cmp1_op == Op_AddI ? T_INT : T_LONG;\n-      const TypeInteger* x_type = phase->type(x)->isa_integer(bt);\n-      if (x_type != nullptr) { \/\/ x_type can be TOP\n-        const TypeInteger* c1_type = phase->type(c1)->is_integer(bt);\n-        const TypeInteger* c2_type = phase->type(cmp2)->is_integer(bt);\n-        bool add_no_overflow = !x_type->can_overflow(cmp1_op, c1_type);\n-        bool cons_no_overflow = !c2_type->can_overflow(bt == T_INT ? Op_SubI : Op_SubL, c1_type);\n-        if ((add_no_overflow && cons_no_overflow && _test.is_less()) ||\n-            _test._test == BoolTest::eq || _test._test == BoolTest::ne) {\n-          cmp = CmpNode::make(x, phase->transform(SubNode::make(cmp2, c1, bt)), bt);\n-          cmp = phase->transform(cmp);\n-          BoolNode* bn = new BoolNode(cmp, _test._test);\n-          return bn;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Fold cmp(sub(c1, x), c2) into cmp(sub(c1, c2), x)\n-  if ((cop == Op_CmpI && cmp1_op == Op_SubI && cmp2_op == Op_ConI) ||\n-      (cop == Op_CmpL && cmp1_op == Op_SubL && cmp2_op == Op_ConL)) {\n-    Node* x = cmp1->in(2);\n-    Node* c1 = cmp1->in(1);\n-    if (c1->Opcode() == Op_ConI || c1->Opcode() == Op_ConL) {\n-      BasicType bt = cmp1_op == Op_SubI ? T_INT : T_LONG;\n-      const TypeInteger* x_type = phase->type(x)->isa_integer(bt);\n-      if (x_type != nullptr) { \/\/ x_type can be TOP\n-        const TypeInteger* c1_type = phase->type(c1)->is_integer(bt);\n-        const TypeInteger* c2_type = phase->type(cmp2)->is_integer(bt);\n-        bool sub_no_overflow = !c1_type->can_overflow(cmp1_op, x_type);\n-        bool cons_no_overflow = !c1_type->can_overflow(cmp1_op, c2_type);\n-        if ((sub_no_overflow && cons_no_overflow && _test.is_less()) ||\n-            _test._test == BoolTest::eq || _test._test == BoolTest::ne) {\n-          cmp = CmpNode::make(phase->transform(SubNode::make(c1, cmp2, bt)), x, bt);\n-          cmp = phase->transform(cmp);\n-          BoolNode* bn = new BoolNode(cmp, _test._test);\n-          return bn;\n-        }\n+      bool binop_no_overflow = cmp1->is_Add()\n+                                   ? !x_type->can_overflow(cmp1_op, c1_type)\n+                                   : !c2_type->can_overflow(cmp1_op, x_type);\n+      bool cons_no_overflow =\n+          !c2_type->can_overflow(bt == T_INT ? Op_SubI : Op_SubL, c1_type);\n+      if ((binop_no_overflow && cons_no_overflow && _test.is_less()) ||\n+          _test._test == BoolTest::eq || _test._test == BoolTest::ne) {\n+        Node *sub = phase->transform(SubNode::make(c2, c1, bt));\n+        cmp = cmp1->is_Add() ? CmpNode::make(x, sub, bt)\n+                              : CmpNode::make(sub, x, bt);\n+        BoolNode *bn = new BoolNode(phase->transform(cmp), _test._test);\n+        return bn;\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":36,"deletions":43,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1759,0 +1759,2 @@\n+  default:\n+    assert(false, \"invalid TypeInt opcode\");\n@@ -1901,0 +1903,2 @@\n+  default:\n+    assert(false, \"invalid TypeLong opcode\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}