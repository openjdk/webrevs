{"files":[{"patch":"@@ -1498,1 +1498,5 @@\n-        \/\/ Reverse edges until the test is canonical\n+        \/\/ Reverse edges until the test is canonical. It is possible given\n+        \/\/ constants c1 and c2, IfNode transformations will follow:\n+        \/\/ `c2 > c1 - x` -> `c1 - x < c2` -> `c1 - c2 < x` -> `x > c1 - c2`\n+        \/\/ Which is still not canonical. We can make it canonical by applying\n+        \/\/ the gvn transformation again.\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1537,1 +1537,1 @@\n-  \/\/ Fold cmp(add(X, C1), C2) into cmp(X, sub(C2, C1))\n+  \/\/ Fold cmp(add(x, c1), c2) into cmp(x, sub(c2, c1))\n@@ -1544,0 +1544,2 @@\n+      \/\/ Do not modify loop exit conditions because it may prevent CountedLoop's\n+      \/\/ recognition of induction variables and strides.\n@@ -1550,2 +1552,1 @@\n-        bool cons_no_overflow =\n-            !c2_type->can_overflow(bt == T_INT ? Op_SubI : Op_SubL, c1_type);\n+        bool cons_no_overflow = !c2_type->can_overflow(bt == T_INT ? Op_SubI : Op_SubL, c1_type);\n@@ -1554,2 +1555,1 @@\n-          cmp =\n-              CmpNode::make(x, phase->transform(SubNode::make(cmp2, c1, bt)), bt);\n+          cmp = CmpNode::make(x, phase->transform(SubNode::make(cmp2, c1, bt)), bt);\n@@ -1564,1 +1564,1 @@\n-  \/\/ Fold cmp(sub(C1, X), C2) into cmp(sub(C1, C2), X)\n+  \/\/ Fold cmp(sub(c1, x), c2) into cmp(sub(c1, c2), x)\n@@ -1579,2 +1579,1 @@\n-          cmp = CmpNode::make(phase->transform(SubNode::make(c1, cmp2, bt)), x,\n-                              bt);\n+          cmp = CmpNode::make(phase->transform(SubNode::make(c1, cmp2, bt)), x, bt);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}