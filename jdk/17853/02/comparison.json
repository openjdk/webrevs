{"files":[{"patch":"@@ -424,20 +424,0 @@\n-template<class T> static bool subtract_overflows(T x, T y) {\n-  T s = java_subtract(x, y);\n-  return (x >= 0) && (y < 0) && (s < 0);\n-}\n-\n-template<class T> static bool subtract_underflows(T x, T y) {\n-  T s = java_subtract(x, y);\n-  return (x < 0) && (y > 0) && (s > 0);\n-}\n-\n-template<class T> static bool add_overflows(T x, T y) {\n-  T s = java_add(x, y);\n-  return (x > 0) && (y > 0) && (s < 0);\n-}\n-\n-template<class T> static bool add_underflows(T x, T y) {\n-  T s = java_add(x, y);\n-  return (x < 0) && (y < 0) && (s >= 0);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1497,2 +1497,6 @@\n-      if (!BoolTest(btest).is_canonical()) {\n-        \/\/ Reverse edges one more time...\n+      while (!BoolTest(btest).is_canonical()) {\n+        \/\/ Reverse edges until the test is canonical. It is possible given\n+        \/\/ constants c1 and c2, IfNode transformations will follow:\n+        \/\/ `c2 > c1 - x` -> `c1 - x < c2` -> `c1 - c2 < x` -> `x > c1 - c2`\n+        \/\/ Which is still not canonical. We can make it canonical by applying\n+        \/\/ the gvn transformation again.\n@@ -1501,1 +1505,0 @@\n-        assert(BoolTest(btest).is_canonical(), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1537,0 +1537,51 @@\n+  \/\/ Fold cmp(add(x, c1), c2) into cmp(x, sub(c2, c1))\n+  if ((cop == Op_CmpI && cmp1_op == Op_AddI && cmp2_op == Op_ConI) ||\n+      (cop == Op_CmpL && cmp1_op == Op_AddL && cmp2_op == Op_ConL)) {\n+    Node* x = cmp1->in(1);\n+    Node* c1 = cmp1->in(2);\n+    if ((c1->Opcode() == Op_ConI || c1->Opcode() == Op_ConL) &&\n+        !is_cloop_condition(this)) {\n+      \/\/ Do not modify loop exit conditions because it may prevent CountedLoop's\n+      \/\/ recognition of induction variables and strides.\n+      BasicType bt = cmp1_op == Op_AddI ? T_INT : T_LONG;\n+      const TypeInteger* x_type = phase->type(x)->isa_integer(bt);\n+      if (x_type != nullptr) { \/\/ x_type can be TOP\n+        const TypeInteger* c1_type = phase->type(c1)->is_integer(bt);\n+        const TypeInteger* c2_type = phase->type(cmp2)->is_integer(bt);\n+        bool add_no_overflow = !x_type->can_overflow(cmp1_op, c1_type);\n+        bool cons_no_overflow = !c2_type->can_overflow(bt == T_INT ? Op_SubI : Op_SubL, c1_type);\n+        if ((add_no_overflow && cons_no_overflow && _test.is_less()) ||\n+            _test._test == BoolTest::eq || _test._test == BoolTest::ne) {\n+          cmp = CmpNode::make(x, phase->transform(SubNode::make(cmp2, c1, bt)), bt);\n+          cmp = phase->transform(cmp);\n+          BoolNode* bn = new BoolNode(cmp, _test._test);\n+          return bn;\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Fold cmp(sub(c1, x), c2) into cmp(sub(c1, c2), x)\n+  if ((cop == Op_CmpI && cmp1_op == Op_SubI && cmp2_op == Op_ConI) ||\n+      (cop == Op_CmpL && cmp1_op == Op_SubL && cmp2_op == Op_ConL)) {\n+    Node* x = cmp1->in(2);\n+    Node* c1 = cmp1->in(1);\n+    if (c1->Opcode() == Op_ConI || c1->Opcode() == Op_ConL) {\n+      BasicType bt = cmp1_op == Op_SubI ? T_INT : T_LONG;\n+      const TypeInteger* x_type = phase->type(x)->isa_integer(bt);\n+      if (x_type != nullptr) { \/\/ x_type can be TOP\n+        const TypeInteger* c1_type = phase->type(c1)->is_integer(bt);\n+        const TypeInteger* c2_type = phase->type(cmp2)->is_integer(bt);\n+        bool sub_no_overflow = !c1_type->can_overflow(cmp1_op, x_type);\n+        bool cons_no_overflow = !c1_type->can_overflow(cmp1_op, c2_type);\n+        if ((sub_no_overflow && cons_no_overflow && _test.is_less()) ||\n+            _test._test == BoolTest::eq || _test._test == BoolTest::ne) {\n+          cmp = CmpNode::make(phase->transform(SubNode::make(c1, cmp2, bt)), x, bt);\n+          cmp = phase->transform(cmp);\n+          BoolNode* bn = new BoolNode(cmp, _test._test);\n+          return bn;\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1747,0 +1747,16 @@\n+bool TypeInt::can_overflow(int opcode, const TypeInteger* other) const {\n+  const TypeInt* other_int = other->isa_int();\n+  if (other_int == nullptr || empty() || other->empty()) {\n+    return true;\n+  }\n+  switch (opcode) {\n+  case Op_AddI:\n+    return add_underflows(_lo, other_int->_lo) ||\n+           add_overflows(_hi, other_int->_hi);\n+  case Op_SubI:\n+    return subtract_underflows(_lo, other_int->_hi) ||\n+           subtract_overflows(_hi, other_int->_lo);\n+  }\n+  return true;\n+}\n+\n@@ -1873,0 +1889,15 @@\n+bool TypeLong::can_overflow(int opcode, const TypeInteger* other) const {\n+  const TypeLong* other_long = other->isa_long();\n+  if (other_long == nullptr || empty() || other->empty()) {\n+    return true;\n+  }\n+  switch (opcode) {\n+  case Op_AddL:\n+    return add_underflows(_lo, other_long->_lo) ||\n+           add_overflows(_hi, other_long->_hi);\n+  case Op_SubL:\n+    return subtract_underflows(_lo, other_long->_hi) ||\n+           subtract_overflows(_hi, other_long->_lo);\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -559,0 +559,1 @@\n+  virtual bool empty(void) const = 0;\n@@ -561,0 +562,1 @@\n+  virtual bool can_overflow(int opcode, const TypeInteger* other) const = 0;\n@@ -609,0 +611,1 @@\n+  virtual bool can_overflow(int opcode, const TypeInteger* other) const;\n@@ -674,0 +677,1 @@\n+  virtual bool can_overflow(int opcode, const TypeInteger* other) const;\n@@ -2183,0 +2187,20 @@\n+template<class T> static bool subtract_overflows(T x, T y) {\n+  T s = java_subtract(x, y);\n+  return (x >= 0) && (y < 0) && (s < 0);\n+}\n+\n+template<class T> static bool subtract_underflows(T x, T y) {\n+  T s = java_subtract(x, y);\n+  return (x < 0) && (y > 0) && (s > 0);\n+}\n+\n+template<class T> static bool add_overflows(T x, T y) {\n+  T s = java_add(x, y);\n+  return (x > 0) && (y > 0) && (s < 0);\n+}\n+\n+template<class T> static bool add_underflows(T x, T y) {\n+  T s = java_add(x, y);\n+  return (x < 0) && (y < 0) && (s >= 0);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325674\n+ * @summary Test constant folding compares\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestConstantFoldCompares\n+ *\/\n+public class TestConstantFoldCompares {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final int NARROW = 1000;\n+    int input;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Setup\n+    public Object[] setup() {\n+        input = RANDOM.nextInt();\n+        return new Object[] { input };\n+    }\n+\n+    @Setup\n+    public Object[] setupEquality() {\n+        int r = RANDOM.nextInt();\n+        \/\/ Make sure equality results are true sometimes to prevent generation of\n+        \/\/ uncommon traps.\n+        input = r % 2 == 0 ? 58 : r;\n+        return new Object[] { input };\n+    }\n+\n+    public void checkAddLtCommon(boolean returnValue) {\n+        if ((input < 58 && !returnValue) || (input >= 58 && returnValue)) {\n+            throw new RuntimeException(\"Illegal constant folding of add lt comparisonInt\");\n+        }\n+    }\n+\n+    public void checkSubLtCommon(boolean returnValue) {\n+        if ((input > 58 && !returnValue) || (input <= 58 && returnValue)) {\n+            throw new RuntimeException(\"Illegal constant folding of sub lt comparisonInt\");\n+        }\n+    }\n+\n+    public void checkEqCommon(boolean returnValue) {\n+        if ((input == 58 && !returnValue) || input != 58 && returnValue) {\n+            throw new RuntimeException(\"Illegal constant folding of eq comparisonInt\");\n+        }\n+    }\n+\n+    public void checkNeCommon(boolean returnValue) {\n+        if ((input == 58 && returnValue) || input != 58 && !returnValue) {\n+            throw new RuntimeException(\"Illegal constant folding of ne comparisonInt\");\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n+    public boolean dontFoldAddInt(int x) {\n+        return 42 + x < 100;\n+    }\n+\n+    @Check(test = \"dontFoldAddInt\")\n+    public void checkDontFoldAddInt(boolean returnValue) {\n+        checkAddLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n+    public boolean dontFoldAdd2Int(int x) {\n+        return (Integer.MAX_VALUE - 1) + Integer.max(x, -100) < -100;\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public boolean dontFoldSubInt(int x) {\n+        return 100 - x < 42;\n+    }\n+\n+    @Check(test = \"dontFoldSubInt\")\n+    public void checkDontFoldSubInt(boolean returnValue) {\n+        checkSubLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public boolean dontFoldSub2Int(int x) {\n+        return 42 - Integer.min(x, -100) < (Integer.MIN_VALUE + 1);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    public boolean foldAddLtInt(int x) {\n+        return 42 + Integer.min(x, NARROW) < 100;\n+    }\n+\n+    @Check(test = \"foldAddLtInt\")\n+    public void checkFoldAddLtInt(boolean returnValue) {\n+        checkAddLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldSubLtInt(int x) {\n+        return 100 - Integer.max(x, -NARROW) < 42;\n+    }\n+\n+    @Check(test = \"foldSubLtInt\")\n+    public void checkFoldSubLtInt(boolean returnValue) {\n+        checkSubLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldAddEqInt(int x) {\n+        return 42 + x == 100;\n+    }\n+\n+    @Check(test = \"foldAddEqInt\")\n+    public void checkFoldAddEqInt(boolean returnValue) {\n+        checkEqCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldSubEqInt(int x) {\n+        return 42 - x == -16;\n+    }\n+\n+    @Check(test = \"foldAddNeInt\")\n+    public void checkFoldAddNeInt(boolean returnValue) {\n+        checkNeCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldAddNeInt(int x) {\n+        return 42 + x != 100;\n+    }\n+\n+    @Check(test = \"foldSubEqInt\")\n+    public void checkFoldSubEqInt(boolean returnValue) {\n+        checkEqCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldSubNeInt(int x) {\n+        return 42 - x != -16;\n+    }\n+\n+    @Check(test = \"foldSubNeInt\")\n+    public void checkFoldSubNeInt(boolean returnValue) {\n+        checkNeCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    public boolean dontFoldAddLong(long x) {\n+        return 42 + x < 100;\n+    }\n+\n+    @Check(test = \"dontFoldAddLong\")\n+    public void checkDontFoldAddLong(boolean returnValue) {\n+        checkAddLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.ADD_L, \"1\"})\n+    public boolean dontFoldAdd2Long(long x) {\n+        return (Long.MAX_VALUE - 1) + Long.max(x, -100) < -100;\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public boolean dontFoldSubLong(long x) {\n+        return 100 - x < 42;\n+    }\n+\n+    @Check(test = \"dontFoldSubLong\")\n+    public void checkDontFoldSubLong(boolean returnValue) {\n+        checkSubLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public boolean dontFoldSub2Long(long x) {\n+        return 42 - Long.min(x, -100) < (Long.MIN_VALUE + 1);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.ADD})\n+    public boolean foldAddLtLong(int x) {\n+        return 42 + (long)x < 100;\n+    }\n+\n+    @Check(test = \"foldAddLtLong\")\n+    public void checkFoldAddLt(boolean returnValue) {\n+        checkAddLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = {IRNode.SUB})\n+    public boolean foldSubLtLong(int x) {\n+        return 100 - (long)x < 42;\n+    }\n+\n+    @Check(test = \"foldSubLtLong\")\n+    public void checkFoldSubLt(boolean returnValue) {\n+        checkSubLtCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(failOn = {IRNode.SUB})\n+    public boolean foldAddEqLong(long x) {\n+        return 42 + x == 100;\n+    }\n+\n+    @Check(test = \"foldAddEqLong\")\n+    public void checkFoldAddEq(boolean returnValue) {\n+        checkEqCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD})\n+    @IR(failOn = {IRNode.SUB})\n+    public boolean foldSubEqLong(long x) {\n+        return 42 - x == -16;\n+    }\n+\n+    @Check(test = \"foldAddNeLong\")\n+    public void checkFoldAddNe(boolean returnValue) {\n+        checkNeCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldAddNeLong(long x) {\n+        return 42 + x != 100;\n+    }\n+\n+    @Check(test = \"foldSubEqLong\")\n+    public void checkFoldSubEq(boolean returnValue) {\n+        checkEqCommon(returnValue);\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setupEquality\")\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(failOn = {IRNode.SUB_I})\n+    public boolean foldSubNeLong(long x) {\n+        return 42 - x != -16;\n+    }\n+\n+    @Check(test = \"foldSubNeLong\")\n+    public void checkFoldSubNe(boolean returnValue) {\n+        checkNeCommon(returnValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestConstantFoldCompares.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -150,14 +150,0 @@\n-    @Test\n-    @IR(failOn = {CMP_I, ADD_I})\n-    @IR(counts = {CMP_U, \"1\"})\n-    public boolean testIntConEQ(int x) {\n-        return x + INT_MIN == INT_CONST;\n-    }\n-\n-    @Test\n-    @IR(failOn = {CMP_I, ADD_I})\n-    @IR(counts = {CMP_U, \"1\"})\n-    public boolean testIntConNE(int x) {\n-        return x + INT_MIN != INT_CONST;\n-    }\n-\n@@ -192,2 +178,1 @@\n-    @Run(test = {\"testIntConEQ\", \"testIntConNE\",\n-                 \"testIntConLT\", \"testIntConLE\",\n+    @Run(test = {\"testIntConLT\", \"testIntConLE\",\n@@ -199,4 +184,0 @@\n-            Asserts.assertEquals(testIntConEQ(INT_DATA[i]),\n-                                 i == CONST_INDEX);\n-            Asserts.assertEquals(testIntConNE(INT_DATA[i]),\n-                                 i != CONST_INDEX);\n@@ -280,14 +261,0 @@\n-    @Test\n-    @IR(failOn = {CMP_L, ADD_L})\n-    @IR(counts = {CMP_UL, \"1\"})\n-    public boolean testLongConEQ(long x) {\n-        return x + LONG_MIN == LONG_CONST;\n-    }\n-\n-    @Test\n-    @IR(failOn = {CMP_L, ADD_L})\n-    @IR(counts = {CMP_UL, \"1\"})\n-    public boolean testLongConNE(long x) {\n-        return x + LONG_MIN != LONG_CONST;\n-    }\n-\n@@ -322,2 +289,1 @@\n-    @Run(test = {\"testLongConEQ\", \"testLongConNE\",\n-                 \"testLongConLT\", \"testLongConLE\",\n+    @Run(test = {\"testLongConLT\", \"testLongConLE\",\n@@ -329,4 +295,0 @@\n-            Asserts.assertEquals(testLongConEQ(LONG_DATA[i]),\n-                                 i == CONST_INDEX);\n-            Asserts.assertEquals(testLongConNE(LONG_DATA[i]),\n-                                 i != CONST_INDEX);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestUnsignedComparison.java","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"}]}