{"files":[{"patch":"@@ -64,0 +64,1 @@\n+    _alloc_failure_waiters_count++;\n@@ -67,0 +68,1 @@\n+    _alloc_failure_waiters_count--;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  size_t  _alloc_failure_waiters_count;\n@@ -61,0 +62,1 @@\n+    _alloc_failure_waiters_count(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,3 +280,8 @@\n-  \/\/ If this was an allocation failure GC cycle, notify waiters about it\n-  if (ShenandoahCollectorPolicy::is_allocation_failure(request.cause)) {\n-    notify_alloc_failure_waiters();\n+  {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    if (_alloc_failure_waiters_count > 0 && !_heap->cancelled_gc()) {\n+      log_debug(gc, thread)(\"Notify %zu threads waiting because of allocation failures\", _alloc_failure_waiters_count);\n+      \/\/ If there are threads waiting because of allocation failures, and we\n+      \/\/ completed a cycle that cleared the cancellation, notify the waiters.\n+      ml.notify_all();\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}