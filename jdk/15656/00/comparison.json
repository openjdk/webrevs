{"files":[{"patch":"@@ -561,3 +561,0 @@\n-  \/\/ Adjust global class iterator.\n-  ClassLoaderDataGraph::adjust_saved_class(scratch_class);\n-\n@@ -623,3 +620,0 @@\n-\n-  \/\/ Clean up global class iterator for compiler\n-  ClassLoaderDataGraph::adjust_saved_class(this);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,79 +83,0 @@\n-\/\/ Class iterator used by the compiler.  It gets some number of classes at\n-\/\/ a safepoint to decay invocation counters on the methods.\n-class ClassLoaderDataGraphKlassIteratorStatic {\n-  ClassLoaderData* _current_loader_data;\n-  Klass*           _current_class_entry;\n- public:\n-\n-  ClassLoaderDataGraphKlassIteratorStatic() : _current_loader_data(nullptr), _current_class_entry(nullptr) {}\n-\n-  InstanceKlass* try_get_next_class() {\n-    assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n-    size_t max_classes = ClassLoaderDataGraph::num_instance_classes();\n-    assert(max_classes > 0, \"should not be called with no instance classes\");\n-    for (size_t i = 0; i < max_classes; ) {\n-\n-      if (_current_class_entry != nullptr) {\n-        Klass* k = _current_class_entry;\n-        _current_class_entry = _current_class_entry->next_link();\n-\n-        if (k->is_instance_klass()) {\n-          InstanceKlass* ik = InstanceKlass::cast(k);\n-          i++;  \/\/ count all instance classes found\n-          \/\/ Not yet loaded classes are counted in max_classes\n-          \/\/ but only return loaded classes.\n-          if (ik->is_loaded()) {\n-            return ik;\n-          }\n-        }\n-      } else {\n-        \/\/ Go to next CLD\n-        if (_current_loader_data != nullptr) {\n-          _current_loader_data = _current_loader_data->next();\n-        }\n-        \/\/ Start at the beginning\n-        if (_current_loader_data == nullptr) {\n-          _current_loader_data = ClassLoaderDataGraph::_head;\n-        }\n-\n-        _current_class_entry = _current_loader_data->klasses();\n-      }\n-    }\n-    \/\/ Should never be reached unless all instance classes have failed or are not fully loaded.\n-    \/\/ Caller handles null.\n-    return nullptr;\n-  }\n-\n-  \/\/ If the current class for the static iterator is a class being unloaded or\n-  \/\/ deallocated, adjust the current class.\n-  void adjust_saved_class(ClassLoaderData* cld) {\n-    if (_current_loader_data == cld) {\n-      _current_loader_data = cld->next();\n-      if (_current_loader_data != nullptr) {\n-        _current_class_entry = _current_loader_data->klasses();\n-      }  \/\/ else try_get_next_class will start at the head\n-    }\n-  }\n-\n-  void adjust_saved_class(Klass* klass) {\n-    if (_current_class_entry == klass) {\n-      _current_class_entry = klass->next_link();\n-    }\n-  }\n-};\n-\n-static ClassLoaderDataGraphKlassIteratorStatic static_klass_iterator;\n-\n-InstanceKlass* ClassLoaderDataGraph::try_get_next_class() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n-  return static_klass_iterator.try_get_next_class();\n-}\n-\n-void ClassLoaderDataGraph::adjust_saved_class(ClassLoaderData* cld) {\n-  return static_klass_iterator.adjust_saved_class(cld);\n-}\n-\n-void ClassLoaderDataGraph::adjust_saved_class(Klass* klass) {\n-  return static_klass_iterator.adjust_saved_class(klass);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":0,"deletions":79,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-  \/\/ VM_CounterDecay iteration support\n-  static InstanceKlass* try_get_next_class();\n-  static void adjust_saved_class(ClassLoaderData* cld);\n-  static void adjust_saved_class(Klass* klass);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}