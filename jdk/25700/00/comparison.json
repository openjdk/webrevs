{"files":[{"patch":"@@ -97,0 +97,9 @@\n+    private static final StableValue<Boolean> SHUTDOWN_WRITE_BEFORE_CLOSE = StableValue.of();\n+\n+    \/**\n+     * Tells whether a TCP connection should be shutdown for writing before closing.\n+     *\/\n+    static boolean shouldShutdownWriteBeforeClose() {\n+        return SHUTDOWN_WRITE_BEFORE_CLOSE.orElseSet(Net::shouldShutdownWriteBeforeClose0);\n+    }\n+\n@@ -465,0 +474,2 @@\n+    private static native boolean shouldShutdownWriteBeforeClose0();\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -849,1 +849,1 @@\n-     * @param isa the remote address\n+     * @param sa the remote socket address\n@@ -1073,2 +1073,2 @@\n-     * Closes the socket if there are no I\/O operations in progress and the\n-     * channel is not registered with a Selector.\n+     * Closes the socket if there are no I\/O operations in progress (or no I\/O\n+     * operations tracked), and the channel is not registered with a Selector.\n@@ -1099,1 +1099,3 @@\n-     * Closes this channel when configured in blocking mode.\n+     * Closes this channel when configured in blocking mode. If there are no I\/O\n+     * operations in progress (or tracked), then the channel's socket is closed. If\n+     * there are I\/O operations in progress then the behavior is platform specific.\n@@ -1101,3 +1103,11 @@\n-     * If there is an I\/O operation in progress then the socket is pre-closed\n-     * and the I\/O threads signalled, in which case the final close is deferred\n-     * until all I\/O operations complete.\n+     * On Unix systems, the channel's socket is pre-closed. This unparks any virtual\n+     * threads that are blocked in I\/O operations on this channel. If there are\n+     * platform threads blocked on the channel's socket then the socket is dup'ed\n+     * and the platform threads signalled. The final close is deferred until all I\/O\n+     * operations complete.\n+     *\n+     * On Windows, the channel's socket is pre-closed. This unparks any virtual\n+     * threads that are blocked in I\/O operations on this channel. If there are no\n+     * virtual threads blocked in I\/O operations on this channel then the channel's\n+     * socket is closed. If there are virtual threads in I\/O then the final close is\n+     * deferred until all I\/O operations on virtual threads complete.\n@@ -1115,1 +1125,1 @@\n-            if (!tryClose()) {\n+            if (connected && Net.shouldShutdownWriteBeforeClose()) {\n@@ -1117,8 +1127,7 @@\n-                if (connected) {\n-                    try {\n-                        var SO_LINGER = StandardSocketOptions.SO_LINGER;\n-                        if ((int) Net.getSocketOption(fd, SO_LINGER) != 0) {\n-                            Net.shutdown(fd, Net.SHUT_WR);\n-                        }\n-                    } catch (IOException ignore) { }\n-                }\n+                try {\n+                    var SO_LINGER = StandardSocketOptions.SO_LINGER;\n+                    if ((int) Net.getSocketOption(fd, SO_LINGER) != 0) {\n+                        Net.shutdown(fd, Net.SHUT_WR);\n+                    }\n+                } catch (IOException ignore) { }\n+            }\n@@ -1126,0 +1135,1 @@\n+            if (!tryClose()) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -208,0 +208,5 @@\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_Net_shouldShutdownWriteBeforeClose0(JNIEnv *env, jclass clazz) {\n+    return JNI_FALSE;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,5 @@\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_Net_shouldShutdownWriteBeforeClose0(JNIEnv *env, jclass clazz) {\n+    return JNI_TRUE;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8358764\n+ * @summary Test closing a socket while a thread is blocked in read. The connection\n+ *     should be closed gracefuly so that the peer reads EOF.\n+ * @run junit PeerReadsAfterAsyncClose\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.SocketChannel;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class PeerReadsAfterAsyncClose {\n+\n+    static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n+    }\n+\n+    \/**\n+     * Close SocketChannel while a thread is blocked reading from the channel's socket.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseDuringSocketChannelRead(ThreadFactory factory) throws Exception {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (var listener = new ServerSocket()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+\n+            try (SocketChannel sc = SocketChannel.open(listener.getLocalSocketAddress());\n+                 Socket peer = listener.accept()) {\n+\n+                \/\/ start thread to read from channel\n+                var cceThrown = new AtomicBoolean();\n+                Thread thread = factory.newThread(() -> {\n+                    try {\n+                        sc.read(ByteBuffer.allocate(1));\n+                        fail();\n+                    } catch (ClosedChannelException e) {\n+                        cceThrown.set(true);\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+                thread.start();\n+                try {\n+                    \/\/ close SocketChannel when thread sampled in implRead\n+                    onReach(thread, \"sun.nio.ch.SocketChannelImpl.implRead\", () -> {\n+                        try {\n+                            sc.close();\n+                        } catch (IOException ignore) { }\n+                    });\n+\n+                    \/\/ peer should read EOF\n+                    int n = peer.getInputStream().read();\n+                    assertEquals(-1, n);\n+                } finally {\n+                    thread.join();\n+                }\n+                assertEquals(true, cceThrown.get(), \"ClosedChannelException not thrown\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Close Socket while a thread is blocked reading from the socket.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseDuringSocketUntimedRead(ThreadFactory factory) throws Exception {\n+        testCloseDuringSocketRead(factory, 0);\n+    }\n+\n+    \/**\n+     * Close Socket while a thread is blocked reading from the socket with a timeout.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseDuringSockeTimedRead(ThreadFactory factory) throws Exception {\n+        testCloseDuringSocketRead(factory, 60_000);\n+    }\n+\n+    private void testCloseDuringSocketRead(ThreadFactory factory, int timeout) throws Exception {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (var listener = new ServerSocket()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+\n+            try (Socket s = new Socket(loopback, listener.getLocalPort());\n+                 Socket peer = listener.accept()) {\n+\n+                \/\/ start thread to read from socket\n+                var seThrown = new AtomicBoolean();\n+                Thread thread = factory.newThread(() -> {\n+                    try {\n+                        s.setSoTimeout(timeout);\n+                        s.getInputStream().read();\n+                        fail();\n+                    } catch (SocketException e) {\n+                        seThrown.set(true);\n+                    } catch (Throwable e) {\n+                        e.printStackTrace();\n+                    }\n+                });\n+                thread.start();\n+                try {\n+                    \/\/ close Socket when thread sampled in implRead\n+                    onReach(thread, \"sun.nio.ch.NioSocketImpl.implRead\", () -> {\n+                        try {\n+                            s.close();\n+                        } catch (IOException ignore) { }\n+                    });\n+\n+                    \/\/ peer should read EOF\n+                    int n = peer.getInputStream().read();\n+                    assertEquals(-1, n);\n+                } finally {\n+                    thread.join();\n+                }\n+                assertEquals(true, seThrown.get(), \"SocketException not thrown\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the given action when the given target thread is sampled at the given\n+     * location. The location takes the form \"{@code c.m}\" where\n+     * {@code c} is the fully qualified class name and {@code m} is the method name.\n+     *\/\n+    private void onReach(Thread target, String location, Runnable action) {\n+        int index = location.lastIndexOf('.');\n+        String className = location.substring(0, index);\n+        String methodName = location.substring(index + 1);\n+        Thread.ofPlatform().daemon(true).start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    found = contains(target.getStackTrace(), className, methodName);\n+                    if (!found) {\n+                        Thread.sleep(20);\n+                    }\n+                }\n+                action.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given class\n+     * and method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String className, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> className.equals(e.getClassName())\n+                        && methodName.equals(e.getMethodName()));\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/PeerReadsAfterAsyncClose.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"}]}