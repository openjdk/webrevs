{"files":[{"patch":"@@ -75,2 +75,2 @@\n-\/\/ Add a symbol entry to the temporary hash table\n-void CompactHashtableWriter::add(unsigned int hash, u4 value) {\n+\/\/ Add an entry to the temporary hash table\n+void CompactHashtableWriter::add(unsigned int hash, u4 encoded_value) {\n@@ -78,1 +78,1 @@\n-  _buckets[index]->append_if_missing(Entry(hash, value));\n+  _buckets[index]->append_if_missing(Entry(hash, encoded_value));\n@@ -110,1 +110,1 @@\n-\/\/ Write the compact table's buckets\n+\/\/ Write the compact table's buckets and entries\n@@ -117,1 +117,0 @@\n-      \/\/ bucket with one entry is compacted and only has the symbol offset\n@@ -121,1 +120,2 @@\n-      _compact_entries->at_put(offset++, ent.value());\n+      \/\/ bucket with one entry is value_only and only has the encoded_value\n+      _compact_entries->at_put(offset++, ent.encoded_value());\n@@ -124,1 +124,2 @@\n-      \/\/ regular bucket, each entry is a symbol (hash, offset) pair\n+      \/\/ regular bucket, it could contain zero or more than one entry,\n+      \/\/ each entry is a <hash, encoded_value> pair\n@@ -129,2 +130,2 @@\n-        _compact_entries->at_put(offset++, u4(ent.hash())); \/\/ write entry hash\n-        _compact_entries->at_put(offset++, ent.value());\n+        _compact_entries->at_put(offset++, u4(ent.hash()));      \/\/ write entry hash\n+        _compact_entries->at_put(offset++, ent.encoded_value()); \/\/ write entry encoded_value\n@@ -192,6 +193,0 @@\n-size_t SimpleCompactHashtable::calculate_header_size() {\n-  \/\/ We have 5 fields. Each takes up sizeof(intptr_t). See WriteClosure::do_u4\n-  size_t bytes = sizeof(intptr_t) * 5;\n-  return bytes;\n-}\n-\n@@ -199,2 +194,0 @@\n-  \/\/ NOTE: if you change this function, you MUST change the number 5 in\n-  \/\/ calculate_header_size() accordingly.\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  V (*DECODE)(address base_address, u4 offset),\n+  V (*DECODE)(address base_address, u4 encoded_value),\n@@ -65,2 +65,3 @@\n-\/\/ At dump time, the CompactHashtableWriter obtains all entries from the\n-\/\/ symbol\/string table and adds them to a new temporary hash table. The hash\n+\/\/ At dump time, the CompactHashtableWriter obtains all entries from\n+\/\/ a table (the table could be in any form of a collection of <hash, encoded_value> pair)\n+\/\/ and adds them to a new temporary hash table (_buckets). The hash\n@@ -79,4 +80,4 @@\n-\/\/ (regular or compact) are encoded in bit[31, 30]. For buckets with more\n-\/\/ than one entry, both hash and entry offset are written to the\n-\/\/ table. For buckets with only one entry, only the entry offset is written\n-\/\/ to the table and the buckets are tagged as compact in their type bits.\n+\/\/ (regular or value_only) are encoded in bit[31, 30]. For buckets with more\n+\/\/ than one entry, both hash and encoded_value are written to the\n+\/\/ table. For buckets with only one entry, only the encoded_value is written\n+\/\/ to the table and the buckets are tagged as value_only in their type bits.\n@@ -90,1 +91,1 @@\n-    u4 _value;\n+    u4 _encoded_value;\n@@ -94,1 +95,1 @@\n-    Entry(unsigned int hash, u4 val) : _hash(hash), _value(val) {}\n+    Entry(unsigned int hash, u4 encoded_value) : _hash(hash), _encoded_value(encoded_value) {}\n@@ -96,2 +97,2 @@\n-    u4 value() {\n-      return _value;\n+    u4 encoded_value() {\n+      return _encoded_value;\n@@ -104,1 +105,1 @@\n-      return (_value == other._value && _hash == other._hash);\n+      return (_encoded_value == other._encoded_value && _hash == other._hash);\n@@ -124,1 +125,2 @@\n-  void add(unsigned int hash, u4 value);\n+  void add(unsigned int hash, u4 encoded_value);\n+  void dump(SimpleCompactHashtable *cht, const char* table_name);\n@@ -134,3 +136,0 @@\n-\n-public:\n-  void dump(SimpleCompactHashtable *cht, const char* table_name);\n@@ -151,1 +150,2 @@\n-\/\/ CompactHashtable is used to store the CDS archive's symbol\/string tables.\n+\/\/ CompactHashtable is used to store the CDS archive's tables.\n+\/\/ A table could be in any form of a collection of <hash, encoded_value> pair.\n@@ -165,2 +165,0 @@\n-\/\/ The last entry is a special type. It contains the end of the last\n-\/\/ bucket.\n@@ -168,3 +166,5 @@\n-\/\/ There are two types of buckets, regular buckets and value_only buckets. The\n-\/\/ value_only buckets have '01' in their highest 2-bit, and regular buckets have\n-\/\/ '00' in their highest 2-bit.\n+\/\/ There are three types of buckets: regular, value_only, and table_end.\n+\/\/  . The regular buckets have '00' in their highest 2-bit.\n+\/\/  . The value_only buckets have '01' in their highest 2-bit.\n+\/\/  . There is only a single table_end bucket that marks the end of buckets[].\n+\/\/    It has '11' in its highest 2-bit.\n@@ -172,6 +172,6 @@\n-\/\/ For normal buckets, each entry is 8 bytes in the entries[]:\n-\/\/   u4 hash;    \/* symbol\/string hash *\/\n-\/\/   union {\n-\/\/     u4 offset;  \/* Symbol* sym = (Symbol*)(base_address + offset) *\/\n-\/\/     narrowOop str; \/* String narrowOop encoding *\/\n-\/\/   }\n+\/\/ For regular buckets, each entry is 8 bytes in the entries[]:\n+\/\/   u4 hash;          \/\/ entry hash\n+\/\/   u4 encoded_value; \/\/ A 32-bit encoding of the template type V. The template parameter DECODE\n+\/\/                     \/\/ converts this to type V. Many CompactHashtables encode a pointer as a 32-bit offset, where\n+\/\/                     \/\/   V entry = (V)(base_address + offset)\n+\/\/                     \/\/ see StringTable, SymbolTable and AdapterHandlerLibrary for examples\n@@ -179,0 +179,1 @@\n+\/\/ For value_only buckets, each entry has only the 4-byte 'encoded_value' in the entries[].\n@@ -180,1 +181,1 @@\n-\/\/ For value_only buckets, each entry has only the 4-byte 'offset' in the entries[].\n+\/\/ The single table_end bucket has no corresponding entry.\n@@ -182,9 +183,23 @@\n-\/\/ Example -- note that the second bucket is a VALUE_ONLY_BUCKET_TYPE so the hash code\n-\/\/            is skipped.\n-\/\/ buckets[0, 4, 5, ....]\n-\/\/         |  |  |\n-\/\/         |  |  +---+\n-\/\/         |  |      |\n-\/\/         |  +----+ |\n-\/\/         v       v v\n-\/\/ entries[H,O,H,O,O,H,O,H,O.....]\n+\/\/ The number of entries in bucket <i> can be calculated like this:\n+\/\/      my_offset   = _buckets[i]   & 0x3fffffff; \/\/ mask off top 2-bit\n+\/\/      next_offset = _buckets[i+1] & 0x3fffffff\n+\/\/  For REGULAR_BUCKET_TYPE\n+\/\/      num_entries = (next_offset - my_offset) \/ 8;\n+\/\/  For VALUE_ONLY_BUCKET_TYPE\n+\/\/      num_entries = (next_offset - my_offset) \/ 4;\n+\/\/\n+\/\/ If bucket <i> is empty, we have my_offset == next_offset. Empty buckets are\n+\/\/ always encoded as regular buckets.\n+\/\/\n+\/\/ In the following example:\n+\/\/   - Bucket #0 is a REGULAR_BUCKET_TYPE with two entries\n+\/\/   - Bucket #1 is a VALUE_ONLY_BUCKET_TYPE with one entry.\n+\/\/   - Bucket #2 is a REGULAR_BUCKET_TYPE with zero entries.\n+\/\/\n+\/\/ buckets[0, 4, 5(empty), 5, ...., N(table_end)]\n+\/\/         |  |  |         |        |\n+\/\/         |  |  +---+-----+        |\n+\/\/         |  |      |              |\n+\/\/         |  +----+ +              |\n+\/\/         v       v v              v\n+\/\/ entries[H,O,H,O,O,H,O,H,O........]\n@@ -233,2 +248,0 @@\n-\n-  static size_t calculate_header_size();\n@@ -240,1 +253,1 @@\n-  V (*DECODE)(address base_address, u4 offset),\n+  V (*DECODE)(address base_address, u4 encoded_value),\n@@ -246,2 +259,2 @@\n-  V decode(u4 offset) const {\n-    return DECODE(_base_address, offset);\n+  V decode(u4 encoded_value) const {\n+    return DECODE(_base_address, encoded_value);\n@@ -267,1 +280,1 @@\n-        \/\/ entries. Each entry is a pair of entry (hash, offset).\n+        \/\/ entries. Each entry is a (hash, value) pair.\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":57,"deletions":44,"binary":false,"changes":101,"status":"modified"}]}