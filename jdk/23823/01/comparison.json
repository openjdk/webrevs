{"files":[{"patch":"@@ -1702,3 +1702,2 @@\n-void PhaseIdealLoop::update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head) {\n-  Node* init = main_loop_head->init_trip();\n-\n+void PhaseIdealLoop::update_main_loop_assertion_predicates(CountedLoopNode* new_main_loop_head,\n+                                                           const int stride_con_before_unroll) {\n@@ -1707,1 +1706,1 @@\n-  int unrolled_stride_con = main_loop_head->stride_con() * 2;\n+  int unrolled_stride_con = stride_con_before_unroll * 2;\n@@ -1710,1 +1709,1 @@\n-  Node* loop_entry = main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  Node* loop_entry = new_main_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -1712,1 +1711,1 @@\n-  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, this);\n+  UpdateStrideForAssertionPredicates update_stride_for_assertion_predicates(unrolled_stride, new_main_loop_head, this);\n@@ -1751,3 +1750,3 @@\n-                                                          CountedLoopNode* target_loop_head,\n-                                                          const NodeInLoopBody& _node_in_loop_body,\n-                                                          const bool clone_template) {\n+                                                         CountedLoopNode* target_loop_head,\n+                                                         const NodeInLoopBody& _node_in_loop_body,\n+                                                         const bool clone_template) {\n@@ -1857,1 +1856,1 @@\n-  int stride_con = stride->get_int();\n+  const int stride_con = stride->get_int();\n@@ -1864,2 +1863,0 @@\n-  update_main_loop_assertion_predicates(loop_head);\n-\n@@ -1999,1 +1996,1 @@\n-  Node *clone_head = old_new[loop_head->_idx];\n+  CountedLoopNode* clone_head = old_new[loop_head->_idx]->as_CountedLoop();\n@@ -2028,0 +2025,2 @@\n+  update_main_loop_assertion_predicates(clone_head, stride_con);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -282,1 +282,2 @@\n-  LoopNode* const _loop_head; \/\/ OuterStripMinedLoopNode if loop strip mined, else just the loop head.\n+  LoopNode* const _loop_head;\n+  LoopNode* const _outer_loop_head; \/\/ OuterStripMinedLoopNode if loop strip mined, else just the loop head.\n@@ -289,1 +290,2 @@\n-      : _loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n+      : _loop_head(loop->_head->as_Loop()),\n+        _outer_loop_head(loop->_head->as_Loop()->skip_strip_mined()),\n@@ -317,1 +319,1 @@\n-    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_loop_head),\n+    _phase->clone_loop(_loop, _old_new, _phase->dom_depth(_outer_loop_head),\n@@ -322,3 +324,3 @@\n-  void fix_loop_entries(const LoopSelector& loop_selector) {\n-    _phase->replace_loop_entry(_loop_head, loop_selector.true_path_loop_proj());\n-    LoopNode* false_path_loop_strip_mined_head = old_to_new(_loop_head)->as_Loop();\n+  void fix_loop_entries(const LoopSelector& loop_selector) const {\n+    _phase->replace_loop_entry(_outer_loop_head, loop_selector.true_path_loop_proj());\n+    LoopNode* false_path_loop_strip_mined_head = old_to_new(_outer_loop_head)->as_Loop();\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -982,1 +982,1 @@\n-  void update_main_loop_assertion_predicates(CountedLoopNode* main_loop_head);\n+  void update_main_loop_assertion_predicates(CountedLoopNode* new_main_loop_head, int stride_con_before_unroll);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,2 +115,4 @@\n-OpaqueTemplateAssertionPredicateNode::OpaqueTemplateAssertionPredicateNode(BoolNode* bol): Node(nullptr, bol),\n-  _predicate_state(PredicateState::Useful) {\n+OpaqueTemplateAssertionPredicateNode::OpaqueTemplateAssertionPredicateNode(BoolNode* bol,  CountedLoopNode* loop_node)\n+    : Node(nullptr, bol),\n+      _loop_node(loop_node),\n+      _predicate_state(PredicateState::Useful) {\n@@ -151,0 +153,1 @@\n+  st->print(\"loop_idx=%d \", _loop_node->_idx);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+  \/\/ The counted loop this Template Assertion Predicate is associated with.\n+  CountedLoopNode* _loop_node;\n+\n@@ -167,1 +170,1 @@\n-  OpaqueTemplateAssertionPredicateNode(BoolNode* bol);\n+  OpaqueTemplateAssertionPredicateNode(BoolNode* bol, CountedLoopNode* loop_node);\n@@ -175,0 +178,9 @@\n+  CountedLoopNode* loop_node() const {\n+    return _loop_node;\n+  }\n+\n+  \/\/ Should only be called during Loop Unrolling when we only update the OpaqueLoopStride input but don't require a full\n+  \/\/ clone of the Template Assertion Expression.\n+  void update_loop_node(CountedLoopNode* loop_node) {\n+    _loop_node = loop_node;\n+  }\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -182,1 +182,2 @@\n-TemplateAssertionPredicate TemplateAssertionPredicate::clone(Node* new_control, PhaseIdealLoop* phase) const {\n+TemplateAssertionPredicate TemplateAssertionPredicate::clone(Node* new_control, CountedLoopNode* new_loop_node,\n+                                                             PhaseIdealLoop* phase) const {\n@@ -184,2 +185,2 @@\n-  TemplateAssertionExpression template_assertion_expression(opaque_node());\n-  OpaqueTemplateAssertionPredicateNode* new_opaque_node = template_assertion_expression.clone(new_control, phase);\n+  TemplateAssertionExpression template_assertion_expression(opaque_node(), phase);\n+  OpaqueTemplateAssertionPredicateNode* new_opaque_node = template_assertion_expression.clone(new_control, new_loop_node);\n@@ -198,0 +199,1 @@\n+                                                                                      CountedLoopNode* new_loop_node,\n@@ -202,1 +204,1 @@\n-  TemplateAssertionExpression template_assertion_expression(opaque_node());\n+  TemplateAssertionExpression template_assertion_expression(opaque_node(), phase);\n@@ -204,1 +206,1 @@\n-      template_assertion_expression.clone_and_replace_init(new_control, new_opaque_init, phase);\n+      template_assertion_expression.clone_and_replace_init(new_control, new_opaque_init, new_loop_node);\n@@ -214,0 +216,30 @@\n+\/\/ This class is used to replace the input to OpaqueLoopStrideNode with a new node while leaving the other nodes\n+\/\/ unchanged.\n+class ReplaceOpaqueStrideInput : public BFSActions {\n+  Node* _new_opaque_stride_input;\n+  PhaseIterGVN& _igvn;\n+\n+  public:\n+  ReplaceOpaqueStrideInput(Node* new_opaque_stride_input, PhaseIterGVN& igvn)\n+      : _new_opaque_stride_input(new_opaque_stride_input),\n+        _igvn(igvn) {}\n+  NONCOPYABLE(ReplaceOpaqueStrideInput);\n+\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopStride();\n+  }\n+\n+  void target_node_action(Node* target_node) override {\n+    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n+  }\n+};\n+\n@@ -217,2 +249,2 @@\n-  TemplateAssertionExpression expression(opaque_node());\n-  expression.replace_opaque_stride_input(new_stride, igvn);\n+  ReplaceOpaqueStrideInput replace_opaque_stride_input(new_stride, igvn);\n+  replace_opaque_stride_input.replace_for(opaque_node());\n@@ -430,3 +462,3 @@\n-OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_control, PhaseIdealLoop* phase) const {\n-  CloneStrategy clone_init_and_stride_strategy(phase, new_control);\n-  return clone(clone_init_and_stride_strategy, new_control, phase);\n+OpaqueTemplateAssertionPredicateNode* TemplateAssertionExpression::clone(Node* new_control, CountedLoopNode* new_loop_node) const {\n+  CloneStrategy clone_init_and_stride_strategy(_phase, new_control);\n+  return clone(clone_init_and_stride_strategy, new_control, new_loop_node);\n@@ -437,3 +469,4 @@\n-TemplateAssertionExpression::clone_and_replace_init(Node* new_control, Node* new_init, PhaseIdealLoop* phase) const {\n-  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_control, new_init, phase);\n-  return clone(replace_init_and_clone_stride_strategy, new_control, phase);\n+TemplateAssertionExpression::clone_and_replace_init(Node* new_control, Node* new_init,\n+                                                    CountedLoopNode* new_loop_node) const {\n+  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_control, new_init, _phase);\n+  return clone(replace_init_and_clone_stride_strategy, new_control, new_loop_node);\n@@ -445,2 +478,1 @@\n-TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride,\n-                                                               PhaseIdealLoop* phase) const {\n+TemplateAssertionExpression::clone_and_replace_init_and_stride(Node* new_control, Node* new_init, Node* new_stride) const {\n@@ -448,1 +480,1 @@\n-  return clone(replace_init_and_stride_strategy, new_control, phase);\n+  return clone(replace_init_and_stride_strategy, new_control, _opaque_node->loop_node());\n@@ -531,1 +563,1 @@\n-                                   PhaseIdealLoop* phase) const {\n+                                   CountedLoopNode* new_loop_node) const {\n@@ -538,2 +570,3 @@\n-  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque_node);\n-  DataNodeGraph data_node_graph(collected_nodes, phase);\n+  Node* bool_into_opaque_node = _opaque_node->in(1);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(bool_into_opaque_node);\n+  DataNodeGraph data_node_graph(collected_nodes, _phase);\n@@ -542,39 +575,7 @@\n-  assert(orig_to_new.contains(_opaque_node), \"must exist\");\n-  Node* opaque_node_clone = *orig_to_new.get(_opaque_node);\n-  return opaque_node_clone->as_OpaqueTemplateAssertionPredicate();\n-}\n-\n-\/\/ This class is used to replace the input to OpaqueLoopStrideNode with a new node while leaving the other nodes\n-\/\/ unchanged.\n-class ReplaceOpaqueStrideInput : public BFSActions {\n-  Node* _new_opaque_stride_input;\n-  PhaseIterGVN& _igvn;\n-\n- public:\n-  ReplaceOpaqueStrideInput(Node* new_opaque_stride_input, PhaseIterGVN& igvn)\n-      : _new_opaque_stride_input(new_opaque_stride_input),\n-        _igvn(igvn) {}\n-  NONCOPYABLE(ReplaceOpaqueStrideInput);\n-\n-  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n-    DataNodeBFS bfs(*this);\n-    bfs.run(opaque_node);\n-  }\n-\n-  bool should_visit(Node* node) const override {\n-    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n-  }\n-\n-  bool is_target_node(Node* node) const override {\n-    return node->is_OpaqueLoopStride();\n-  }\n-\n-  void target_node_action(Node* target_node) override {\n-    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n-  }\n-};\n-\n-\/\/ Replace the input to OpaqueLoopStrideNode with 'new_stride' and leave the other nodes unchanged.\n-void TemplateAssertionExpression::replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const {\n-  ReplaceOpaqueStrideInput replace_opaque_stride_input(new_stride, igvn);\n-  replace_opaque_stride_input.replace_for(_opaque_node);\n+  assert(orig_to_new.contains(bool_into_opaque_node), \"must exist\");\n+  BoolNode* bool_into_opaque_node_clone = (*orig_to_new.get(bool_into_opaque_node))->as_Bool();\n+  OpaqueTemplateAssertionPredicateNode* opaque_clone =\n+      new OpaqueTemplateAssertionPredicateNode(bool_into_opaque_node_clone, new_loop_node);\n+  _phase->C->add_template_assertion_predicate_opaque(opaque_clone);\n+  _phase->register_new_node(opaque_clone, new_control);\n+  return opaque_clone;\n@@ -596,1 +597,1 @@\n-TemplateAssertionExpression::clone_and_fold_opaque_loop_nodes(Node* new_control, PhaseIdealLoop* phase) const {\n+TemplateAssertionExpression::clone_and_fold_opaque_loop_nodes(Node* new_control) const {\n@@ -599,1 +600,1 @@\n-                                                                       phase);\n+                                                                       _opaque_node->loop_node());\n@@ -601,2 +602,2 @@\n-      new OpaqueInitializedAssertionPredicateNode(cloned_template_opaque->in(1)->as_Bool(), phase->C);\n-  phase->register_new_node(opaque_initialized_opaque, new_control);\n+      new OpaqueInitializedAssertionPredicateNode(cloned_template_opaque->in(1)->as_Bool(), _phase->C);\n+  _phase->register_new_node(opaque_initialized_opaque, new_control);\n@@ -648,1 +649,2 @@\n-  OpaqueTemplateAssertionPredicateNode* create_for_template(Node* new_control, Node* operand, bool& does_overflow) const {\n+  OpaqueTemplateAssertionPredicateNode* create_for_template(Node* new_control, Node* operand, CountedLoopNode* loop_node,\n+                                                            bool& does_overflow) const {\n@@ -651,1 +653,1 @@\n-    return create_opaque_node(new_control, bool_for_expression);\n+    return create_opaque_for_template(new_control, bool_for_expression, loop_node);\n@@ -655,2 +657,4 @@\n-  OpaqueTemplateAssertionPredicateNode* create_opaque_node(Node* new_control, BoolNode* bool_for_expression) const {\n-    OpaqueTemplateAssertionPredicateNode* new_expression = new OpaqueTemplateAssertionPredicateNode(bool_for_expression);\n+  OpaqueTemplateAssertionPredicateNode* create_opaque_for_template(Node* new_control, BoolNode* bool_for_expression,\n+                                                           CountedLoopNode* loop_node) const {\n+    OpaqueTemplateAssertionPredicateNode* new_expression = new OpaqueTemplateAssertionPredicateNode(bool_for_expression,\n+                                                                                                    loop_node);\n@@ -668,1 +672,1 @@\n-    return create_opaque_initialized_assertion_predicate_node(new_control, bool_for_expression);\n+    return create_opaque_for_initialized(new_control, bool_for_expression);\n@@ -672,2 +676,2 @@\n-  OpaqueInitializedAssertionPredicateNode* create_opaque_initialized_assertion_predicate_node(\n-      Node* new_control, BoolNode* bool_for_expression) const {\n+  OpaqueInitializedAssertionPredicateNode* create_opaque_for_initialized(Node* new_control,\n+                                                                         BoolNode* bool_for_expression) const {\n@@ -765,1 +769,1 @@\n-  return expression_creator.create_for_template(new_control, opaque_init, does_overflow);\n+  return expression_creator.create_for_template(new_control, opaque_init, _loop_head, does_overflow);\n@@ -773,1 +777,1 @@\n-  return expression_creator.create_for_template(new_control, last_value, does_overflow);\n+  return expression_creator.create_for_template(new_control, last_value, _loop_head, does_overflow);\n@@ -858,1 +862,1 @@\n-  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate.opaque_node());\n+  TemplateAssertionExpression template_assertion_expression(template_assertion_predicate.opaque_node(), _phase);\n@@ -861,1 +865,1 @@\n-      template_assertion_expression.clone_and_fold_opaque_loop_nodes(template_assertion_predicate_success_proj, _phase);\n+      template_assertion_expression.clone_and_fold_opaque_loop_nodes(template_assertion_predicate_success_proj);\n@@ -902,1 +906,1 @@\n-  TemplateAssertionExpression template_assertion_expression(template_opaque);\n+  TemplateAssertionExpression template_assertion_expression(template_opaque, _phase);\n@@ -904,1 +908,1 @@\n-      template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init, new_stride, _phase);\n+      template_assertion_expression.clone_and_replace_init_and_stride(new_control, new_init, new_stride);\n@@ -962,0 +966,1 @@\n+      _target_loop_head(target_loop_head),\n@@ -1016,1 +1021,2 @@\n-      template_assertion_predicate.clone_and_replace_opaque_input(_old_target_loop_entry, _init, _phase);\n+      template_assertion_predicate.clone_and_replace_opaque_input(_old_target_loop_entry, _init, _target_loop_head,\n+                                                                  _phase);\n@@ -1084,2 +1090,4 @@\n-    : _old_target_loop_entry(target_loop_head->in(LoopNode::EntryControl)),\n-      _target_loop_predicate_chain(target_loop_head, phase),\n+    : _target_loop_head(target_loop_head),\n+      _target_outer_loop_head(target_loop_head->skip_strip_mined()),\n+      _old_target_loop_entry(_target_outer_loop_head->in(LoopNode::EntryControl)),\n+      _target_loop_predicate_chain(_target_outer_loop_head, phase),\n@@ -1089,0 +1097,9 @@\n+\/\/ Clones the provided Template Assertion Predicate to the head of the current predicate chain at the target loop.\n+void ClonePredicateToTargetLoop::clone_template_assertion_predicate(\n+    const TemplateAssertionPredicate& template_assertion_predicate) {\n+  TemplateAssertionPredicate cloned_template_assertion_predicate =\n+      template_assertion_predicate.clone(_old_target_loop_entry, _target_loop_head->as_CountedLoop(), _phase);\n+  template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_assertion_predicate.tail(),\n+                                                             _node_in_loop_body, _phase);\n+  _target_loop_predicate_chain.insert_predicate(cloned_template_assertion_predicate);\n+}\n@@ -1134,0 +1151,1 @@\n+  template_assertion_predicate.update_associated_loop_node(_loop_node);\n@@ -1215,0 +1233,2 @@\n+  LoopNode* const _loop_node; \/\/ The loop node from which we currently iterate through the Predicates.\n+\n@@ -1216,0 +1236,3 @@\n+  explicit PredicateUsefulMarkerVisitor(LoopNode* loop_node) : _loop_node(loop_node) {}\n+  NONCOPYABLE(PredicateUsefulMarkerVisitor);\n+\n@@ -1224,1 +1247,20 @@\n-    template_assertion_predicate.opaque_node()->mark_useful();\n+    if (!_loop_node->is_CountedLoop()) {\n+      \/\/ Template Assertion Predicate above LoopNode? Must be unrelated because they can only be created above\n+      \/\/ CountedLoopNodes during Loop Predication or Range Check Elimination.\n+      return;\n+    }\n+\n+    mark_template_useful_if_matching_loop(template_assertion_predicate);\n+  }\n+\n+  \/\/ If the stored loop node does not match the current loop node from which we iterate from, we found a Template\n+  \/\/ Assertion Predicate belonging to an already earlier folded loop in the graph. We need to drop this Template\n+  \/\/ Assertion Predicate because we are no longer splitting a loop which it belongs to. Moreover, if we do not remove\n+  \/\/ this Template Assertion Predicate, we could wrongly be creating Initialized Assertion Predicates from it at the\n+  \/\/ new loop which has completely unrelated loop values. These Initialized Assertion Predicates can then fail at\n+  \/\/ runtime, and we crash by executing a halt instruction.\n+  void mark_template_useful_if_matching_loop(const TemplateAssertionPredicate& template_assertion_predicate) const {\n+    OpaqueTemplateAssertionPredicateNode* opaque_node = template_assertion_predicate.opaque_node();\n+    if (opaque_node->loop_node() == _loop_node) {\n+      template_assertion_predicate.opaque_node()->mark_useful();\n+    }\n@@ -1229,1 +1271,2 @@\n-  Node* loop_entry = loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl);\n+  LoopNode* loop_node = loop->_head->as_Loop();\n+  Node* loop_entry = loop_node->skip_strip_mined()->in(LoopNode::EntryControl);\n@@ -1231,1 +1274,1 @@\n-  PredicateUsefulMarkerVisitor predicate_useful_marker_visitor;\n+  PredicateUsefulMarkerVisitor predicate_useful_marker_visitor(loop_node);\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":124,"deletions":81,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-  TemplateAssertionPredicate clone(Node* new_control, PhaseIdealLoop* phase) const;\n+  TemplateAssertionPredicate clone(Node* new_control, CountedLoopNode* new_loop_node, PhaseIdealLoop* phase) const;\n@@ -401,1 +401,1 @@\n-                                                            PhaseIdealLoop* phase) const;\n+                                                            CountedLoopNode* new_loop_node, PhaseIdealLoop* phase) const;\n@@ -407,0 +407,7 @@\n+\n+  \/\/ Should only be called during Loop Unrolling when we only update the OpaqueLoopStride input but don't require a full\n+  \/\/ clone of the Template Assertion Expression.\n+  void update_associated_loop_node(CountedLoopNode* loop_node) const {\n+    opaque_node()->update_loop_node(loop_node);\n+  }\n+\n@@ -481,2 +488,2 @@\n-  OpaqueTemplateAssertionPredicateNode* _opaque_node;\n-\n+  OpaqueTemplateAssertionPredicateNode* const _opaque_node;\n+  PhaseIdealLoop* const _phase;\n@@ -484,1 +491,4 @@\n-  explicit TemplateAssertionExpression(OpaqueTemplateAssertionPredicateNode* opaque_node) : _opaque_node(opaque_node) {}\n+  TemplateAssertionExpression(OpaqueTemplateAssertionPredicateNode* opaque_node, PhaseIdealLoop* phase)\n+      : _opaque_node(opaque_node),\n+        _phase(phase) {}\n+  NONCOPYABLE(TemplateAssertionExpression);\n@@ -488,1 +498,1 @@\n-                                              Node* new_control, PhaseIdealLoop* phase) const;\n+                                              Node* new_control, CountedLoopNode* new_loop_node) const;\n@@ -491,1 +501,1 @@\n-  OpaqueTemplateAssertionPredicateNode* clone(Node* new_control, PhaseIdealLoop* phase) const;\n+  OpaqueTemplateAssertionPredicateNode* clone(Node* new_control, CountedLoopNode* new_loop_node) const;\n@@ -493,1 +503,1 @@\n-                                                               PhaseIdealLoop* phase) const;\n+                                                               CountedLoopNode* new_loop_node) const;\n@@ -495,3 +505,2 @@\n-                                                                          Node* new_stride, PhaseIdealLoop* phase) const;\n-  void replace_opaque_stride_input(Node* new_stride, PhaseIterGVN& igvn) const;\n-  OpaqueInitializedAssertionPredicateNode* clone_and_fold_opaque_loop_nodes(Node* new_control, PhaseIdealLoop* phase) const;\n+                                                                          Node* new_stride) const;\n+  OpaqueInitializedAssertionPredicateNode* clone_and_fold_opaque_loop_nodes(Node* new_control) const;\n@@ -1081,0 +1090,1 @@\n+  CountedLoopNode* const _target_loop_head;\n@@ -1142,0 +1152,2 @@\n+  LoopNode* const _target_loop_head;\n+  LoopNode* const _target_outer_loop_head;\n@@ -1157,8 +1169,1 @@\n-  \/\/ Clones the provided Template Assertion Predicate to the head of the current predicate chain at the target loop.\n-  void clone_template_assertion_predicate(const TemplateAssertionPredicate& template_assertion_predicate) {\n-    TemplateAssertionPredicate cloned_template_assertion_predicate =\n-        template_assertion_predicate.clone(_old_target_loop_entry, _phase);\n-    template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_assertion_predicate.tail(),\n-                                                               _node_in_loop_body, _phase);\n-    _target_loop_predicate_chain.insert_predicate(cloned_template_assertion_predicate);\n-  }\n+  void clone_template_assertion_predicate(const TemplateAssertionPredicate& template_assertion_predicate);\n@@ -1212,0 +1217,1 @@\n+  CountedLoopNode* const _loop_node;\n@@ -1221,1 +1227,1 @@\n-  UpdateStrideForAssertionPredicates(Node* const new_stride, PhaseIdealLoop* phase)\n+  UpdateStrideForAssertionPredicates(Node* const new_stride, CountedLoopNode* loop_node, PhaseIdealLoop* phase)\n@@ -1223,0 +1229,1 @@\n+        _loop_node(loop_node),\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -407,3 +407,4 @@\n-    TemplateAssertionExpression template_assertion_expression(opaque_node);\n-    Node* new_ctrl = template_assertion_predicate->in(0);\n-    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_ctrl, this);\n+    TemplateAssertionExpression template_assertion_expression(opaque_node, this);\n+    Node* new_control = template_assertion_predicate->in(0);\n+    OpaqueTemplateAssertionPredicateNode* cloned_opaque_node = template_assertion_expression.clone(new_control,\n+                                                                                                   opaque_node->loop_node());\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8288981 8350579\n+ * @summary Test all possible cases in which Assertion Predicates are required such that the graph is not left in a\n+ *          broken state to trigger assertions. Additional tests ensure the correctness of the implementation.\n+ *          All tests additionally -XX:+AbortVMOnCompilationFailure which would catch bad graphs as a result of missing\n+            or wrong Assertion Predicates where we simply bail out of C2 compilation.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Xbatch\n+ *\/\n+\n+\/*\n+ * @test id=NoTieredCompilation\n+ * @bug 8288981 8350579\n+\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates NoTieredCompilation\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @bug 8288981 8350579\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=inline,compiler.predicates.TestAssertionPredicates::inline\n+ *                   compiler.predicates.TestAssertionPredicates Xcomp\n+ *\/\n+\n+\/*\n+ * @test id=LoopMaxUnroll0\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates LoopMaxUnroll0\n+ *\/\n+\n+\/*\n+ * @test id=StressXcomp\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Stress\n+ *\/\n+\n+\/*\n+ * @test id=StressXbatch\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Stress\n+ *\/\n+\n+\/*\n+ * @test id=NoLoopPredication\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:-UseLoopPredicate\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates NoLoopPredication\n+ *\/\n+\n+\/*\n+ * @test id=NoFlags\n+ * @bug 8288981 8350579\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                    compiler.predicates.TestAssertionPredicates NoFlags\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestAssertionPredicates {\n+    static int[] iArrShort = new int[10];\n+    static int[] iArr = new int[200];\n+    static int[] iArr2 = new int[200];\n+    static int[] iArr3 = new int[300];\n+    static short[] sArr = new short[10];\n+\n+    static boolean flag;\n+    static int iFld = 34;\n+    static int iFld2, iFld3;\n+    static float fFld;\n+    static short five = 5;\n+\n+\n+    public static void main(String[] args) {\n+        switch (args[0]) {\n+            case \"Xbatch\" -> {\n+                for (int i = 0; i < 10000; i++) {\n+                    flag = !flag;\n+                    testTemplateAssertionPredicateNotRemovedHalt();\n+                    testTemplateAssertionPredicateNotRemovedMalformedGraph();\n+                    test8305428();\n+                    test8305428No2();\n+                }\n+            }\n+            case \"NoTieredCompilation\" -> {\n+                for (int i = 0; i < 1000; i++) {\n+                    test8320920();\n+                    test8332501();\n+                }\n+            }\n+            case \"LoopMaxUnroll0\" -> {\n+                testDyingRuntimePredicate();\n+                testDyingNegatedRuntimePredicate();\n+            }\n+            case \"Xcomp\" -> {\n+                testDyingInitializedAssertionPredicate();\n+            }\n+            case \"NoLoopPredication\", \"NoFlags\", \"Stress\" -> {\n+                for (int i = 0; i < 10000; i++) {\n+                    runAllTests();\n+                }\n+            }\n+            default -> throw new RuntimeException(\"invalid arg\");\n+        }\n+    }\n+\n+    static void runAllTests() {\n+        testTemplateAssertionPredicateNotRemovedHalt();\n+        testTemplateAssertionPredicateNotRemovedMalformedGraph();\n+        testDyingRuntimePredicate();\n+        testDyingNegatedRuntimePredicate();\n+        testDyingInitializedAssertionPredicate();\n+        test8305428();\n+        test8305428No2();\n+        test8320920();\n+        test8332501();\n+    }\n+\n+    \/\/ Corresponds to JDK-8305428.\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    public static void testTemplateAssertionPredicateNotRemovedHalt() {\n+        int one = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            one = 1;\n+        }\n+\n+        int i = 80;\n+        \/\/ 1) Found to be a counted loop with a limit between 1 and 34 (C2 only knows after CCP that 'one'\n+        \/\/    is the constant 1).\n+        \/\/ 2b) Two Hoisted Range Check Predicates.\n+        \/\/     Two Template Assertion Predicates but triggering this bug, we only need to focus on one:\n+        \/\/         Init Value: OpaqueLoopInit(0) <u iArrShort.length\n+        \/\/ 4) After CCP, we know that this loop only runs for one iteration. The backedge is never taken\n+        \/\/    and the CountedLoopNode can be folded away during IGVN.\n+        \/\/    The Parse Predicates together with the Template Assertion Predicate from 2b) now end up\n+        \/\/    above the partially peeled inner loop.\n+        for (int j = 0; j < one; j++) {\n+            \/\/ 3) Apply Partial Peeling which gives us the following loop:\n+            \/\/      for (i = 80; i >= 5; i--) { fFld += 34; }\n+            \/\/    Note that this loop does not have any Parse Predicates above its loop entry.\n+            \/\/ 5) This loop is converted to a counted loop.\n+            \/\/ 6) We pre-main-post this loop and update the Template Assertion Predicate for the main-loop\n+            \/\/    The problem now is, that we use the init value of this loop which is completely\n+            \/\/    unrelated to the init value of the outer loop for which this Tempalte Asseriton Predicate\n+            \/\/    was originally created! We get the following wrong Template Assertion Predicate for the\n+            \/\/    init value:\n+            \/\/        OpaqueLoopInit(79) <u iArrShort.length\n+            \/\/    From that we create a wrong Initialized Assertion Predicate:\n+            \/\/        79 <u iArrShort.length\n+            \/\/    During runtime, we know the length:\n+            \/\/        79 <u iArrShort.length = 10\n+            \/\/    And the Initialized Assertion Predidate fails. We execute the corresponding Halt node\n+            \/\/    and the VM crashes.\n+            while (true) {\n+\n+                \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+                \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+                \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+                if (flag) {\n+                }\n+\n+                \/\/ Loop exit test.\n+                if (i < 5) {\n+                    break;\n+                }\n+                \/\/ <-- Partial Peeling CUT -->\n+                \/\/ Safepoint\n+                fFld += 34; \/\/ Make sure loop not empty.\n+                i--;\n+            }\n+            \/\/ 2a) Loop Predication hoists this check out of the loop with two Hoisted Range Check\n+            \/\/     Predicates and two Template Assertion Predicates at 2b).\n+            iArrShort[j] = 3;\n+        }\n+    }\n+\n+    \/\/ Corresponds to JDK-8305428 but with different manifestation (malformed graph).\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    public static void testTemplateAssertionPredicateNotRemovedMalformedGraph() {\n+        int zero = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 1;\n+        }\n+\n+        int i = 80;\n+        for (int j = 0; j < zero; j++) {\n+            while (true) {\n+\n+                \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+                \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+                \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+                if (flag) {\n+                }\n+\n+                \/\/ Loop exit test.\n+                if (i < -5) {\n+                    break;\n+                }\n+                \/\/ <-- Partial Peeling CUT -->\n+                \/\/ Safepoint\n+                fFld = iArr2[i+5];\n+                i--;\n+            }\n+            iArr[j] = 3;\n+        }\n+    }\n+\n+    \/*\n+     * Some tests catching some issues while adding the new implementation.\n+     *\/\n+\n+    \/\/ Initialized Assertion Predicate with ConI as bool node is not recognized, and we miss to remove a Template\n+    \/\/ Assertion Predicate from which we later create a wrong Initialized Assertion Predicate (for wrong loop).\n+    static void testDyingInitializedAssertionPredicate() {\n+        boolean b = false;\n+        int i4, i6, i7 = 14, i8, iArr[][] = new int[10][10];\n+        for (int i = 0; i < iArr.length; i++) {\n+            inline(iArr[i]);\n+        }\n+        for (i4 = 7; i4 < 10; i4++) {\n+            iArr2[1] += 5;\n+        }\n+        for (i6 = 100; i6 > 4; --i6) {\n+            i8 = 1;\n+            while (++i8 < 6) {\n+                sArr[i8] = 3;\n+                i7 += i8 + i8;\n+                iArr2[i8] -= 34;\n+            }\n+        }\n+    }\n+\n+    public static void inline(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = 4;\n+        }\n+    }\n+\n+    static void testDyingRuntimePredicate() {\n+        int zero = 34;\n+        int[] iArrLoc = new int[100];\n+\n+        int limit = 2;\n+        int loopInit = -10;\n+        int four = -10;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+            loopInit = 99;\n+            four = 4;\n+        }\n+\n+        \/\/ Template + Hoisted Range Check Predicate for iArr[i]. Hoisted Invariant Check Predicate IC for iArr3[index].\n+        \/\/ After CCP: ConI for IC and uncommon proj already killed -> IGVN will fold this away. But Predicate logic\n+        \/\/ need to still recognize this predicate to find the Template above to kill it. If we don't do it, then it\n+        \/\/ will end up at loop below and peeling will clone the template and create a completely wrong Initialized\n+        \/\/ Assertion Predicate, killing some parts of the graph and leaving us with a broken graph.\n+        for (int i = loopInit; i < 100; i++) {\n+            iArr[i] = 34;\n+            iArrLoc[four] = 34;\n+        }\n+\n+        int i = -10;\n+        while (true) {\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (zero * i == 34) {\n+                iFld2 = 23;\n+            } else {\n+                iFld = 2;\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (i >= -2) {\n+                break;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            if (zero * i + five == 0) {\n+                return;\n+            }\n+            iFld2 = 34;\n+            i++;\n+        }\n+    }\n+\n+    static void testDyingNegatedRuntimePredicate() {\n+        int zero = 34;\n+        int[] iArrLoc = new int[100];\n+\n+        int limit = 2;\n+        int loopInit = -10;\n+        int four = -10;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+            loopInit = 99;\n+            four = 4;\n+        }\n+\n+        \/\/ Template + Hoisted Range Check Predicate for iArr[i]. Hoisted Invariant Check Predicate IC for iArr3[index].\n+        \/\/ After CCP: ConI for IC and uncommon proj already killed -> IGVN will fold this away. But Predicate logic\n+        \/\/ need to still recognize this predicate to find the Template above to kill it. If we don't do it, then it\n+        \/\/ will end up at loop below and peeling will clone the template and create a completely wrong Initialized\n+        \/\/ Assertion Predicate, killing some parts of the graph and leaving us with a broken graph.\n+        for (int i = loopInit; i < 100; i++) {\n+            iArr[i] = 34;\n+            if (-3 > loopInit) {\n+                \/\/ Negated Hoisted Invariant Check Predicate.\n+                iArrLoc[101] = 34; \/\/ Always out of bounds and will be a range_check trap in the graph.\n+            }\n+        }\n+\n+        int i = -10;\n+        while (true) {\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (zero * i == 34) {\n+                iFld2 = 23;\n+            } else {\n+                iFld = 2;\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (i >= -2) {\n+                break;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            if (zero * i + five == 0) {\n+                return;\n+            }\n+            iFld2 = 34;\n+            i++;\n+        }\n+    }\n+\n+    \/**\n+     * Tests collected in JBS and duplicated issues\n+     *\/\n+\n+\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    static void test8305428() {\n+        int j = 1;\n+        do {\n+            for (int k = 270; k > 1; --k) {\n+                iFld++;\n+            }\n+\n+            switch (j) {\n+                case 1:\n+                    switch (92) {\n+                        case 92:\n+                            flag = flag;\n+                    }\n+                case 2:\n+                    iArr[j] = 3;\n+            }\n+        } while (++j < 100);\n+    }\n+\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    static void test8305428No2() {\n+        int i = 1;\n+        do {\n+            for (int j = 103; j > 1; --j) {\n+                iArr[i] = iArr[j \/ 34];\n+            }\n+            for (int j = 103; j > 4; j -= 3) {\n+                switch (i % 9) {\n+                    case 0:\n+                    case 2:\n+                    case 3:\n+                        iArr[i - 1] = 34;\n+                    case 8:\n+                }\n+            }\n+        } while (++i < 99);\n+    }\n+\n+    static void test8320920() {\n+        int i = 1;\n+        do {\n+            for (int j = 83; j > i; j--) {\n+                iFld = 3;\n+            }\n+            for (int j = 5; j < 83; j++) {\n+                for (int k = i; k < 2; k++)\n+                    ;\n+            }\n+            iArr3[i - 1] = 34;\n+        } while (++i < 300);\n+    }\n+\n+    static void test8332501() {\n+        int i = 1;\n+        do {\n+            for (int j = 108; j > 1; j -= 2) {\n+                fFld += j;\n+            }\n+            for (int j = 3; 108 > j; j++) {\n+                for (int k = 2; k > i; --k) {\n+                }\n+            }\n+            iArr[i] = 34;\n+        } while (++i < 150);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"}]}