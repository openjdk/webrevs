{"files":[{"patch":"@@ -2506,1 +2506,13 @@\n-Node *CountedLoopNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* CountedLoopNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape && phase->type(in(LoopBackControl)) == Type::TOP) {\n+    \/\/ Since this loop is collapsing, we also need to remove the associated Template Assertion Predicates above this loop\n+    \/\/ (no more loop opts for this loop). Otherwise, the Template Assertion Predicates could wrongly end up at the loop\n+    \/\/ entry of another counted loop which did not have any predicates before (could happen for example, when partially\n+    \/\/ peeling a loop which loses its Parse Predicates due to nodes in between which are later optimized away + converting\n+    \/\/ this loop into a counted loop). When further splitting this counted loop during loop opts into sub loops, we\n+    \/\/ erroneously create Initialized Assertion Predicates for the sub loops with the init and stride values of the\n+    \/\/ previously collapsed loop. These can then fail at runtime because they check the wrong values.\n+    KillTemplateAssertionPredicates kill_template_assertion_predicates(phase->is_IterGVN());\n+    PredicateIterator predicate_iterator(skip_strip_mined()->in(EntryControl));\n+    predicate_iterator.for_each(kill_template_assertion_predicates);\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,2 +44,7 @@\n-\/\/ An Assertion Predicate has always a true projection on the success path.\n-bool may_be_assertion_predicate_if(const Node* node) {\n+\/\/ An Assertion Predicate has always a true projection on the success path and a Halt node on the failure path. Usually,\n+\/\/ Assertion Predicates have their dedicated opaque nodes as bool input, except when an Assertion Predicate was killed\n+\/\/ as part of loop splitting or during IGVN. In this case, it has a ConI input which we also treat as a valid Assertion\n+\/\/ Predicate. Note that during IGVN, we could also have a dying Assertion Predicate with only one If projection left.\n+\/\/ We will treat such a predicate as Runtime Predicate to skip over it during predicate iteration and not process it\n+\/\/ further as Assertion Predicate.\n+bool AssertionPredicate::may_be_assertion_predicate_if(const Node* node) {\n@@ -47,1 +52,4 @@\n-  return node->is_IfTrue() && RegularPredicate::may_be_predicate_if(node->as_IfProj());\n+  return node->is_IfTrue() &&\n+         RegularPredicate::may_be_predicate_if(node->as_IfProj()) &&\n+         node->in(0)->outcnt() == 2 &&\n+         has_halt(node);\n@@ -54,1 +62,1 @@\n-  return has_assertion_predicate_opaque(maybe_success_proj) && has_halt(maybe_success_proj);\n+  return has_assertion_predicate_opaque_or_con_input(maybe_success_proj);\n@@ -57,3 +65,4 @@\n-\/\/ Check if the If node of `predicate_proj` has an OpaqueTemplateAssertionPredicate (Template Assertion Predicate) or\n-\/\/ an OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node as input.\n-bool AssertionPredicate::has_assertion_predicate_opaque(const Node* predicate_proj) {\n+\/\/ Check if the If node of `predicate_proj` has an OpaqueTemplateAssertionPredicate (Template Assertion Predicate),\n+\/\/ an OpaqueInitializedAssertionPredicate (Initialized Assertion Predicate) node or a ConI node as bool input. The latter\n+\/\/ case could happen when an Assertion Predicate is about to be folded during IGVN.\n+bool AssertionPredicate::has_assertion_predicate_opaque_or_con_input(const Node* predicate_proj) {\n@@ -62,1 +71,1 @@\n-  return bol->is_OpaqueTemplateAssertionPredicate() || bol->is_OpaqueInitializedAssertionPredicate();\n+  return bol->is_OpaqueTemplateAssertionPredicate() || bol->is_OpaqueInitializedAssertionPredicate() || bol->is_ConI();\n@@ -68,1 +77,1 @@\n-  return other_proj->outcnt() == 1 && other_proj->unique_out()->Opcode() == Op_Halt;\n+  return other_proj->outcnt() == 1 && other_proj->unique_out()->is_Halt();\n@@ -113,3 +122,2 @@\n-    return has_valid_uncommon_trap(maybe_success_proj);\n-  } else {\n-    return false;\n+    return is_being_folded_without_uncommon_proj(maybe_success_proj->as_IfProj()) ||\n+           has_valid_uncommon_trap(maybe_success_proj);\n@@ -117,0 +125,1 @@\n+  return false;\n@@ -122,4 +131,4 @@\n-  return (deopt_reason == Deoptimization::Reason_loop_limit_check ||\n-          deopt_reason == Deoptimization::Reason_auto_vectorization_check ||\n-          deopt_reason == Deoptimization::Reason_predicate ||\n-          deopt_reason == Deoptimization::Reason_profile_predicate);\n+  return deopt_reason == Deoptimization::Reason_loop_limit_check ||\n+         deopt_reason == Deoptimization::Reason_auto_vectorization_check ||\n+         deopt_reason == Deoptimization::Reason_predicate ||\n+         deopt_reason == Deoptimization::Reason_profile_predicate;\n@@ -130,3 +139,2 @@\n-    return deopt_reason == uncommon_trap_reason(node->as_IfProj());\n-  } else {\n-    return false;\n+    IfProjNode* success_proj = node->as_IfProj();\n+    return is_being_folded_without_uncommon_proj(success_proj) || deopt_reason == uncommon_trap_reason(success_proj);\n@@ -134,0 +142,11 @@\n+  return false;\n+}\n+\n+\/\/ Does the If node only have the success projection left due to already folding the uncommon projection because of a\n+\/\/ constant bool input? This can happen during IGVN. Treat this case as being a Runtime Predicate to not miss other\n+\/\/ Predicates above this node when iterating through them. Since the failing path is already removed, we could also\n+\/\/ match an Assertion Predicate. This is fine since this predicate is being removed anyways and we just want to skip\n+\/\/ it.\n+bool RuntimePredicate::is_being_folded_without_uncommon_proj(const IfProjNode* success_proj) {\n+  IfNode* if_node = success_proj->in(0)->as_If();\n+  return if_node->in(1)->is_ConI() && if_node->outcnt() == 1;\n@@ -166,1 +185,1 @@\n-  if (!may_be_assertion_predicate_if(node)) {\n+  if (!AssertionPredicate::may_be_assertion_predicate_if(node)) {\n@@ -229,0 +248,7 @@\n+\/\/ Kills the Template Assertion Predicate by setting the condition to true. This method should only be called during\n+\/\/ IGVN. During PhaseIdealLoop, call kill() instead to make sure control of data nodes are maintained correctly.\n+void TemplateAssertionPredicate::kill_during_igvn(PhaseIterGVN* igvn) const {\n+  ConINode* true_con = igvn->intcon(1);\n+  igvn->replace_input_of(_if_node, 1, true_con);\n+}\n+\n@@ -299,1 +325,1 @@\n-  if (!may_be_assertion_predicate_if(node)) {\n+  if (!AssertionPredicate::may_be_assertion_predicate_if(node)) {\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-  static bool has_assertion_predicate_opaque(const Node* predicate_proj);\n+  static bool has_assertion_predicate_opaque_or_con_input(const Node* predicate_proj);\n@@ -279,0 +279,1 @@\n+  static bool may_be_assertion_predicate_if(const Node* node);\n@@ -340,1 +341,4 @@\n-\/\/ Class to represent a Runtime Predicate which always has an associated UCT on the failing path.\n+\/\/ Class to represent a Runtime Predicate which always has an associated UCT on the failing path. Note that when a\n+\/\/ Regular Predicate is dying, it could already lose one of its out projections. We therefore treat any such dying\n+\/\/ Regular Predicate (i.e. Assertion or Runtime Predicate) as Runtime Predicate in order to skip through it when\n+\/\/ iterating through all predicates during IGVN.\n@@ -357,0 +361,1 @@\n+  static bool is_being_folded_without_uncommon_proj(const IfProjNode* success_proj);\n@@ -375,0 +380,7 @@\n+\/\/ A Template Assertion Predicate has the following properties:\n+\/\/ - The head of the predicate is an If or RangeCheck node.\n+\/\/   - The bool input into the head is either:\n+\/\/     - (Usually) OpaqueTemplateAssertionPredicateNode\n+\/\/     - ConI if the predicate is dead or about to be dying during IGVN.\n+\/\/ - The tail of the predicate is the success path represented with a true projection.\n+\/\/ - The failing path contains a Halt node.\n@@ -414,0 +426,1 @@\n+  void kill_during_igvn(PhaseIterGVN* igvn) const;\n@@ -426,2 +439,9 @@\n-\/\/ Class to represent an Initialized Assertion Predicate which always has a halt node on the failing path.\n-\/\/ This predicate should never fail at runtime by design.\n+\/\/ Class to represent an Initialized Assertion Predicate which should never fail at runtime by design.\n+\/\/ An Initialized Assertion Predicate has the following properties:\n+\/\/ - The head of the predicate is an If or RangeCheck node.\n+\/\/   - The bool input into the head is either:\n+\/\/     - (Usually) OpaqueInitializedAssertionPredicate, before macro expansion\n+\/\/     - A Bool after removing OpaqueInitializedAssertionPredicate during macro expansion\n+\/\/     - ConI if the predicate is dead or about to be dying during IGVN.\n+\/\/ - The tail of the predicate is the success path represented with a true projection.\n+\/\/ - The failing path contains a Halt node.\n@@ -1207,0 +1227,14 @@\n+\n+\/\/ The visitor visits all Template Assertion Predicates and kills them by marking them useless. They will be removed\n+\/\/ during next round of IGVN.\n+class KillTemplateAssertionPredicates : public PredicateVisitor {\n+  PhaseIterGVN* _igvn;\n+  public:\n+  using PredicateVisitor::visit;\n+\n+  KillTemplateAssertionPredicates(PhaseIterGVN* igvn) : _igvn(igvn) {}\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    template_assertion_predicate.kill_during_igvn(_igvn);\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8288981 8350579\n+ * @summary Test all possible cases in which Assertion Predicates are required such that the graph is not left in a\n+ *          broken state to trigger assertions. Additional tests ensure the correctness of the implementation.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Xbatch\n+ *\/\n+\n+\/*\n+ * @test id=NoTieredCompilation\n+ * @bug 8288981 8350579\n+ * @summary Test all possible cases in which Assertion Predicates are required such that the graph is not left in a\n+ *          broken state to trigger assertions. Additional tests ensure the correctness of the implementation.\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates NoTieredCompilation\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @bug 8288981 8350579\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=inline,compiler.predicates.TestAssertionPredicates::inline\n+ *                   compiler.predicates.TestAssertionPredicates Xcomp\n+ *\/\n+\n+\/*\n+ * @test id=LoopMaxUnroll0\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:LoopMaxUnroll=0\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates LoopMaxUnroll0\n+ *\/\n+\n+\/*\n+ * @test id=StressXcomp\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Stress\n+ *\/\n+\n+\/*\n+ * @test id=StressXbatch\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates Stress\n+ *\/\n+\n+\/*\n+ * @test id=NoLoopPredication\n+ * @bug 8288981 8350579\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:-UseLoopPredicate\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.TestAssertionPredicates::*\n+ *                   compiler.predicates.TestAssertionPredicates NoLoopPredication\n+ *\/\n+\n+\/*\n+ * @test id=NoFlags\n+ * @bug 8288981 8350579\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure\n+ *                    compiler.predicates.TestAssertionPredicates NoFlags\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestAssertionPredicates {\n+    static int[] iArrShort = new int[10];\n+    static int[] iArr = new int[200];\n+    static int[] iArr2 = new int[200];\n+    static int[] iArr3 = new int[300];\n+    static short[] sArr = new short[10];\n+\n+    static boolean flag;\n+    static int iFld = 34;\n+    static int iFld2, iFld3;\n+    static float fFld;\n+    static short five = 5;\n+\n+\n+    public static void main(String[] args) {\n+        switch (args[0]) {\n+            case \"Xbatch\" -> {\n+                for (int i = 0; i < 10000; i++) {\n+                    flag = !flag;\n+                    testTemplateAssertionPredicateNotRemovedHalt();\n+                    testTemplateAssertionPredicateNotRemovedMalformedGraph();\n+                    test8305428();\n+                    test8305428No2();\n+                }\n+            }\n+            case \"NoTieredCompilation\" -> {\n+                for (int i = 0; i < 1000; i++) {\n+                    test8320920();\n+                    test8332501();\n+                }\n+            }\n+            case \"LoopMaxUnroll0\" -> {\n+                testDyingRuntimePredicate();\n+                testDyingNegatedRuntimePredicate();\n+            }\n+            case \"Xcomp\" -> {\n+                testDyingInitializedAssertionPredicate();\n+            }\n+            case \"NoLoopPredication\", \"NoFlags\", \"Stress\" -> {\n+                for (int i = 0; i < 10000; i++) {\n+                    runAllTests();\n+                }\n+            }\n+            default -> throw new RuntimeException(\"invalid arg\");\n+        }\n+    }\n+\n+    \/\/ Runs most of the tests except the really time-consuming ones.\n+    static void runAllTests() {\n+        testTemplateAssertionPredicateNotRemovedHalt();\n+        testTemplateAssertionPredicateNotRemovedMalformedGraph();\n+        testDyingRuntimePredicate();\n+        testDyingNegatedRuntimePredicate();\n+        testDyingInitializedAssertionPredicate();\n+        test8305428();\n+        test8305428No2();\n+        test8320920();\n+        test8332501();\n+    }\n+\n+    \/\/ Corresponds to JDK-8305428.\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    public static void testTemplateAssertionPredicateNotRemovedHalt() {\n+        int one = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            one = 1;\n+        }\n+\n+        int i = 80;\n+        \/\/ 1) Found to be a counted loop with a limit between 1 and 34 (C2 only knows after CCP that 'one'\n+        \/\/    is the constant 1).\n+        \/\/ 2b) Two Hoisted Range Check Predicates.\n+        \/\/     Two Template Assertion Predicates but triggering this bug, we only need to focus on one:\n+        \/\/         Init Value: OpaqueLoopInit(0) <u iArrShort.length\n+        \/\/ 4) After CCP, we know that this loop only runs for one iteration. The backedge is never taken\n+        \/\/    and the CountedLoopNode can be folded away during IGVN.\n+        \/\/    The Parse Predicates together with the Template Assertion Predicate from 2b) now end up\n+        \/\/    above the partially peeled inner loop.\n+        for (int j = 0; j < one; j++) {\n+            \/\/ 3) Apply Partial Peeling which gives us the following loop:\n+            \/\/      for (i = 80; i >= 5; i--) { fFld += 34; }\n+            \/\/    Note that this loop does not have any Parse Predicates above its loop entry.\n+            \/\/ 5) This loop is converted to a counted loop.\n+            \/\/ 6) We pre-main-post this loop and update the Template Assertion Predicate for the main-loop\n+            \/\/    The problem now is, that we use the init value of this loop which is completely\n+            \/\/    unrelated to the init value of the outer loop for which this Tempalte Asseriton Predicate\n+            \/\/    was originally created! We get the following wrong Template Assertion Predicate for the\n+            \/\/    init value:\n+            \/\/        OpaqueLoopInit(79) <u iArrShort.length\n+            \/\/    From that we create a wrong Initialized Assertion Predicate:\n+            \/\/        79 <u iArrShort.length\n+            \/\/    During runtime, we know the length:\n+            \/\/        79 <u iArrShort.length = 10\n+            \/\/    And the Initialized Assertion Predidate fails. We execute the corresponding Halt node\n+            \/\/    and the VM crashes.\n+            while (true) {\n+\n+                \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+                \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+                \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+                if (flag) {\n+                }\n+\n+                \/\/ Loop exit test.\n+                if (i < 5) {\n+                    break;\n+                }\n+                \/\/ <-- Partial Peeling CUT -->\n+                \/\/ Safepoint\n+                fFld += 34; \/\/ Make sure loop not empty.\n+                i--;\n+            }\n+            \/\/ 2a) Loop Predication hoists this check out of the loop with two Hoisted Range Check\n+            \/\/     Predicates and two Template Assertion Predicates at 2b).\n+            iArrShort[j] = 3;\n+        }\n+    }\n+\n+    \/\/ Corresponds to JDK-8305428 but with different manifestation (malformed graph).\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    public static void testTemplateAssertionPredicateNotRemovedMalformedGraph() {\n+        int zero = 34;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 1;\n+        }\n+\n+        int i = 80;\n+        for (int j = 0; j < zero; j++) {\n+            while (true) {\n+\n+                \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+                \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+                \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+                if (flag) {\n+                }\n+\n+                \/\/ Loop exit test.\n+                if (i < -5) {\n+                    break;\n+                }\n+                \/\/ <-- Partial Peeling CUT -->\n+                \/\/ Safepoint\n+                fFld = iArr2[i+5];\n+                i--;\n+            }\n+            iArr[j] = 3;\n+        }\n+    }\n+\n+    \/*\n+     * Some tests catching some issues while adding the new implementation.\n+     *\/\n+\n+    \/\/ Initialized Assertion Predicate with ConI as bool node is not recognized, and we miss to remove a Template\n+    \/\/ Assertion Predicate from which we later create a wrong Initialized Assertion Predicate (for wrong loop).\n+    static void testDyingInitializedAssertionPredicate() {\n+        boolean b = false;\n+        int i4, i6, i7 = 14, i8, iArr[][] = new int[10][10];\n+        for (int i = 0; i < iArr.length; i++) {\n+            inline(iArr[i]);\n+        }\n+        for (i4 = 7; i4 < 10; i4++) {\n+            iArr2[1] += 5;\n+        }\n+        for (i6 = 100; i6 > 4; --i6) {\n+            i8 = 1;\n+            while (++i8 < 6) {\n+                sArr[i8] = 3;\n+                i7 += i8 + i8;\n+                iArr2[i8] -= 34;\n+            }\n+        }\n+    }\n+\n+    public static void inline(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = 4;\n+        }\n+    }\n+\n+    static void testDyingRuntimePredicate() {\n+        int zero = 34;\n+        int[] iArrLoc = new int[100];\n+\n+        int limit = 2;\n+        int loopInit = -10;\n+        int four = -10;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+            loopInit = 99;\n+            four = 4;\n+        }\n+\n+        \/\/ Template + Hoisted Range Check Predicate for iArr[i]. Hoisted Invariant Check Predicate IC for iArr3[index].\n+        \/\/ After CCP: ConI for IC and uncommon proj already killed -> IGVN will fold this away. But Predicate logic\n+        \/\/ need to still recognize this predicate to find the Template above to kill it. If we don't do it, then it\n+        \/\/ will end up at loop below and peeling will clone the template and create a completely wrong Initialized\n+        \/\/ Assertion Predicate, killing some parts of the graph and leaving us with a broken graph.\n+        for (int i = loopInit; i < 100; i++) {\n+            iArr[i] = 34;\n+            iArrLoc[four] = 34;\n+        }\n+\n+        int i = -10;\n+        while (true) {\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (zero * i == 34) {\n+                iFld2 = 23;\n+            } else {\n+                iFld = 2;\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (i >= -2) {\n+                break;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            if (zero * i + five == 0) {\n+                return;\n+            }\n+            iFld2 = 34;\n+            i++;\n+        }\n+    }\n+\n+    static void testDyingNegatedRuntimePredicate() {\n+        int zero = 34;\n+        int[] iArrLoc = new int[100];\n+\n+        int limit = 2;\n+        int loopInit = -10;\n+        int four = -10;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+            loopInit = 99;\n+            four = 4;\n+        }\n+\n+        \/\/ Template + Hoisted Range Check Predicate for iArr[i]. Hoisted Invariant Check Predicate IC for iArr3[index].\n+        \/\/ After CCP: ConI for IC and uncommon proj already killed -> IGVN will fold this away. But Predicate logic\n+        \/\/ need to still recognize this predicate to find the Template above to kill it. If we don't do it, then it\n+        \/\/ will end up at loop below and peeling will clone the template and create a completely wrong Initialized\n+        \/\/ Assertion Predicate, killing some parts of the graph and leaving us with a broken graph.\n+        for (int i = loopInit; i < 100; i++) {\n+            iArr[i] = 34;\n+            if (-3 > loopInit) {\n+                \/\/ Negated Hoisted Invariant Check Predicate.\n+                iArrLoc[101] = 34; \/\/ Always out of bounds and will be a range_check trap in the graph.\n+            }\n+        }\n+\n+        int i = -10;\n+        while (true) {\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (zero * i == 34) {\n+                iFld2 = 23;\n+            } else {\n+                iFld = 2;\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (i >= -2) {\n+                break;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            if (zero * i + five == 0) {\n+                return;\n+            }\n+            iFld2 = 34;\n+            i++;\n+        }\n+    }\n+\n+    \/**\n+     * Tests collected in JBS and duplicated issues\n+     *\/\n+\n+\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    static void test8305428() {\n+        int j = 1;\n+        do {\n+            for (int k = 270; k > 1; --k) {\n+                iFld++;\n+            }\n+\n+            switch (j) {\n+                case 1:\n+                    switch (92) {\n+                        case 92:\n+                            flag = flag;\n+                    }\n+                case 2:\n+                    iArr[j] = 3;\n+            }\n+        } while (++j < 100);\n+    }\n+\n+    \/\/ -Xbatch -XX:CompileCommand=compileonly,Test*::*\n+    static void test8305428No2() {\n+        int i = 1;\n+        do {\n+            for (int j = 103; j > 1; --j) {\n+                iArr[i] = iArr[j \/ 34];\n+            }\n+            for (int j = 103; j > 4; j -= 3) {\n+                switch (i % 9) {\n+                    case 0:\n+                    case 2:\n+                    case 3:\n+                        iArr[i - 1] = 34;\n+                    case 8:\n+                }\n+            }\n+        } while (++i < 99);\n+    }\n+\n+    static void test8320920() {\n+        int i = 1;\n+        do {\n+            for (int j = 83; j > i; j--) {\n+                iFld = 3;\n+            }\n+            for (int j = 5; j < 83; j++) {\n+                for (int k = i; k < 2; k++)\n+                    ;\n+            }\n+            iArr3[i - 1] = 34;\n+        } while (++i < 300);\n+    }\n+\n+    static void test8332501() {\n+        int i = 1;\n+        do {\n+            for (int j = 108; j > 1; j -= 2) {\n+                fFld += j;\n+            }\n+            for (int j = 3; 108 > j; j++) {\n+                for (int k = 2; k > i; --k) {\n+                }\n+            }\n+            iArr[i] = 34;\n+        } while (++i < 150);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"}]}