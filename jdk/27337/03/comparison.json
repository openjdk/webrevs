{"files":[{"patch":"@@ -687,1 +687,1 @@\n-  DebugAranges debug_aranges(this);\n+  \/\/ Use cached aranges for binary search if available\n@@ -689,1 +689,10 @@\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  ensure_aranges_cache();\n+  bool found = false;\n+  if (_aranges_cache._initialized) {\n+    found = _aranges_cache.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset);\n+  } else {\n+    DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", filepath());\n+    DebugAranges debug_aranges(this);\n+    found = debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset);\n+  }\n+  if (!found) {\n@@ -711,0 +720,96 @@\n+int DwarfFile::ArangesCache::compare_aranges_entries(const void* a, const void* b) {\n+  const ArangesEntry* entry_a = static_cast<const ArangesEntry*>(a);\n+  const ArangesEntry* entry_b = static_cast<const ArangesEntry*>(b);\n+\n+  if (entry_a->beginning_address < entry_b->beginning_address) {\n+    return -1;\n+  } else if (entry_a->beginning_address > entry_b->beginning_address) {\n+    return 1;\n+  }\n+\n+  uintptr_t len_a = entry_a->end_address - entry_a->beginning_address;\n+  uintptr_t len_b = entry_b->end_address - entry_b->beginning_address;\n+  if (len_a < len_b) {\n+    return -1;\n+  } else if (len_a > len_b) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void DwarfFile::DebugAranges::build_cache(ArangesCache& cache) {\n+  assert(cache._capacity == 0, \"need fresh cache\");\n+  assert(cache._count == 0, \"need fresh cache\");\n+  assert(!cache._initialized, \"need fresh cache\");\n+  assert(!cache._failed, \"need fresh cache\");\n+  if (!read_section_header()) {\n+    cache._failed = true;\n+    return;\n+  }\n+  \/\/ Start with reasonable initial capacity\n+  size_t initial_capacity = 128;\n+  cache._entries = NEW_C_HEAP_ARRAY(ArangesEntry, initial_capacity, mtInternal);\n+  if (cache._entries == nullptr) {\n+    cache._failed = true;\n+    return;\n+  }\n+  cache._capacity = initial_capacity;\n+  cache._count = 0;\n+\n+  \/\/ Read all sets and their descriptors\n+  while (_reader.has_bytes_left()) {\n+    DebugArangesSetHeader set_header;\n+    if (!read_set_header(set_header)) {\n+      break;\n+    }\n+\n+    \/\/ Read all address descriptors for this set\n+    AddressDescriptor descriptor;\n+    do {\n+      if (!read_address_descriptor(descriptor)) {\n+        goto cleanup_and_fail;\n+      }\n+      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0) {\n+        if (cache._count >= cache._capacity) {\n+          size_t new_capacity = cache._capacity * 1.5;\n+          ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, cache._entries, new_capacity, mtInternal);\n+          if (new_entries == nullptr) {\n+            goto cleanup_and_fail;\n+          }\n+          cache._entries = new_entries;\n+          cache._capacity = new_capacity;\n+        }\n+        cache._entries[cache._count] = ArangesEntry(\n+          descriptor.beginning_address,\n+          descriptor.beginning_address + descriptor.range_length,\n+          set_header._debug_info_offset\n+        );\n+        cache._count++;\n+      }\n+    } while (!is_terminating_entry(set_header, descriptor) && _reader.has_bytes_left());\n+  }\n+  if (cache._count == 0) {\n+    goto cleanup_and_fail;\n+  }\n+  cache.sort();\n+  if (cache._count < cache._capacity) {\n+    ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, cache._entries, cache._count, mtInternal);\n+    if (new_entries != nullptr) {\n+      cache._entries = new_entries;\n+      cache._capacity = cache._count;\n+    }\n+  }\n+  cache._initialized = true;\n+  DWARF_LOG_INFO(\"Built aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), cache._count);\n+  return;\n+\n+cleanup_and_fail:\n+  if (cache._entries != nullptr) {\n+    FREE_C_HEAP_ARRAY(ArangesEntry, cache._entries);\n+    cache._entries = nullptr;\n+  }\n+  cache._count = 0;\n+  cache._capacity = 0;\n+  cache._failed = true;\n+}\n+\n@@ -832,0 +937,22 @@\n+bool DwarfFile::ArangesCache::find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const {\n+  if (!_initialized || _entries == nullptr || _count == 0) {\n+    return false;\n+  }\n+\n+  size_t left = 0;\n+  size_t right = _count;\n+  while (left < right) {\n+    size_t mid = left + (right - left) \/ 2;\n+    const ArangesEntry& entry = _entries[mid];\n+    if (offset_in_library < entry.beginning_address) {\n+      right = mid;\n+    } else if (offset_in_library >= entry.end_address) {\n+      left = mid + 1;\n+    } else {\n+      *compilation_unit_offset = entry.debug_info_offset;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":129,"deletions":2,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+#ifdef ASSERT\n+  const char* filepath() const { return _filepath; }\n+#endif\n@@ -438,0 +441,2 @@\n+  struct ArangesCache;\n+\n@@ -504,0 +509,7 @@\n+    void build_cache(ArangesCache& cache);\n+  };\n+\n+  struct ArangesEntry {\n+    uintptr_t beginning_address;\n+    uintptr_t end_address;\n+    uint32_t debug_info_offset;\n@@ -505,0 +517,35 @@\n+    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n+    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n+      : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n+  };\n+\n+  \/\/ Cache for .debug_aranges to enable binary search for address lookup\n+  struct ArangesCache {\n+    friend DebugAranges;\n+\n+    ArangesEntry* _entries;\n+    size_t _count;\n+    size_t _capacity;\n+    bool _initialized;\n+    bool _failed;\n+\n+    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n+    ArangesCache(ArangesCache&& other) : _entries(other._entries), _count(other._count), _capacity(other._capacity),\n+                                          _initialized(other._initialized), _failed(other._failed) {\n+      other._entries = nullptr;\n+      other._count = 0;\n+      other._capacity = 0;\n+    }\n+    ~ArangesCache() {\n+      if (_entries != nullptr) {\n+        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n+      }\n+    }\n+\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n+\n+   private:\n+    static int compare_aranges_entries(const void* a, const void* b);\n+    void sort() {\n+      qsort(_entries, _count, sizeof(ArangesEntry), DwarfFile::ArangesCache::compare_aranges_entries);\n+    }\n@@ -900,0 +947,12 @@\n+\n+ private:\n+  ArangesCache _aranges_cache;\n+\n+  \/\/ Build cache of all address ranges for binary search in a single pass\n+  void ensure_aranges_cache() {\n+    if (_aranges_cache._initialized || _aranges_cache._failed) {\n+      return;\n+    }\n+    DebugAranges debug_aranges(const_cast<DwarfFile*>(this));\n+    debug_aranges.build_cache(_aranges_cache);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}