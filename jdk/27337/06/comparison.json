{"files":[{"patch":"@@ -687,1 +687,0 @@\n-  DebugAranges debug_aranges(this);\n@@ -689,1 +688,1 @@\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n@@ -711,0 +710,63 @@\n+\/\/ Build sorted cache of all address ranges for binary search.\n+DwarfFile::DebugAranges::CacheHint DwarfFile::DebugAranges::ensure_cached() {\n+  if (_cache._failed) {\n+    return CacheHint::FAILED;\n+  }\n+  if (_cache._initialized) {\n+    return CacheHint::VALID;\n+  }\n+\n+  assert(_cache._capacity == 0, \"need fresh cache\");\n+  assert(_cache._count == 0, \"need fresh cache\");\n+  const long pos = _reader.get_position();\n+  if (!read_section_header()) {\n+    _cache.destroy(true);\n+    return CacheHint::FAILED;\n+  }\n+\n+  \/\/ Start with reasonable initial capacity to minimize number of grow\/realloc calls.\n+  \/\/ Assume ~3% of the .debug_aranges is DebugArangesSetHeader and the rest is made up of AddressDescriptors.\n+  const uintptr_t estimatedSetHeaderSize = _size_bytes \/ 32;\n+  const size_t initial_capacity = (_size_bytes - estimatedSetHeaderSize) \/ sizeof(AddressDescriptor);\n+  _cache._entries = NEW_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, initial_capacity, mtInternal);\n+  if (_cache._entries == nullptr) {\n+    _cache.destroy(true);\n+    _reader.set_position(pos);\n+    return CacheHint::TRY_LINEAR_SCAN;\n+  }\n+  _cache._capacity = initial_capacity;\n+  _cache._count = 0;\n+\n+  \/\/ Read all sets and their descriptors\n+  while (_reader.has_bytes_left()) {\n+    DebugArangesSetHeader set_header;\n+    if (!read_set_header(set_header)) {\n+      break;\n+    }\n+\n+    \/\/ Read all address descriptors for this set into the cache.\n+    AddressDescriptor descriptor;\n+    do {\n+      if (!read_address_descriptor(descriptor)) {\n+        _cache.destroy(true);\n+        return CacheHint::FAILED;\n+      }\n+      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0 &&\n+          !_cache.add_entry(descriptor, set_header._debug_info_offset)) {\n+        _reader.set_position(pos);\n+        return CacheHint::TRY_LINEAR_SCAN;\n+      }\n+    } while (!is_terminating_entry(set_header, descriptor) && _reader.has_bytes_left());\n+  }\n+\n+  if (_cache._count == 0) {\n+    _cache.destroy(false);\n+    \/\/ No entries found, unusual but still valid.\n+    return CacheHint::VALID;\n+  }\n+  _cache.sort();\n+  _cache._initialized = true;\n+  DWARF_LOG_INFO(\"Built .debug_aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n+  return CacheHint::VALID;\n+}\n+\n@@ -716,0 +778,12 @@\n+  switch (ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  \/\/ Fall back to linear scan if building of the cache failed, which can happen\n+  \/\/ if there are C heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n@@ -753,0 +827,1 @@\n+  _size_bytes = shdr.sh_size;\n@@ -832,0 +907,69 @@\n+\/\/ Sort entries by beginning_address, when same then sort longest range first.\n+int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n+  if (a.beginning_address < b.beginning_address) {\n+    return -1;\n+  } else if (a.beginning_address > b.beginning_address) {\n+    return 1;\n+  }\n+\n+  uintptr_t len_a = a.end_address - a.beginning_address;\n+  uintptr_t len_b = b.end_address - b.beginning_address;\n+  if (len_a < len_b) {\n+    return 1;\n+  } else if (len_a > len_b) {\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+void DwarfFile::ArangesCache::sort() {\n+  QuickSort::sort(_entries, _count, compare_aranges_entries);\n+}\n+\n+bool DwarfFile::ArangesCache::add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset) {\n+  if (_count >= _capacity && !grow()) {\n+    destroy(true);\n+    return false;\n+  }\n+  _entries[_count] = ArangesEntry(\n+    descriptor.beginning_address,\n+    descriptor.beginning_address + descriptor.range_length,\n+    debug_info_offset\n+  );\n+  _count++;\n+  return true;\n+}\n+\n+bool DwarfFile::ArangesCache::grow() {\n+  size_t new_capacity = _capacity == 0 ? 128 : _capacity * 1.5;\n+  ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, _entries, new_capacity, mtInternal);\n+  if (new_entries == nullptr) {\n+    return false;\n+  }\n+  _entries = new_entries;\n+  _capacity = new_capacity;\n+  return true;\n+}\n+\n+bool DwarfFile::ArangesCache::find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const {\n+  if (!_initialized || _entries == nullptr || _count == 0) {\n+    return false;\n+  }\n+\n+  size_t left = 0;\n+  size_t right = _count;\n+  while (left < right) {\n+    size_t mid = left + (right - left) \/ 2;\n+    const ArangesEntry& entry = _entries[mid];\n+    if (offset_in_library < entry.beginning_address) {\n+      right = mid;\n+    } else if (offset_in_library >= entry.end_address) {\n+      left = mid + 1;\n+    } else {\n+      *compilation_unit_offset = entry.debug_info_offset;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":146,"deletions":2,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -97,0 +98,2 @@\n+class DwarfFile;\n+class ElfFuncDescTable;\n@@ -99,2 +102,0 @@\n-class ElfFuncDescTable;\n-class DwarfFile;\n@@ -204,0 +205,1 @@\n+  DEBUG_ONLY(const char* filepath() const { return _filepath; })\n@@ -400,1 +402,0 @@\n-\n@@ -438,0 +439,57 @@\n+  \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n+  \/\/ the set header in the DWARF 4 spec.\n+  struct AddressDescriptor {\n+    uintptr_t beginning_address = 0;\n+    uintptr_t range_length = 0;\n+  };\n+\n+  \/\/ Entry in ArangesCache, corresponding to an entry in .debug_aranges section.\n+  struct ArangesEntry {\n+    uintptr_t beginning_address;\n+    uintptr_t end_address;\n+    uint32_t debug_info_offset;\n+\n+    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n+    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n+    : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n+  };\n+\n+  \/\/ Cache for .debug_aranges to enable binary search for address lookup.\n+  \/\/ DebugAranges uses this cache to resolve the compilation_unit_offset, rather than doing a linear scan on the files\n+  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset.\n+  struct ArangesCache {\n+    ArangesEntry* _entries;\n+    size_t _count;\n+    size_t _capacity;\n+    bool _initialized;\n+    bool _failed;\n+\n+    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n+    ArangesCache(const ArangesCache&) = delete;\n+    ArangesCache& operator=(const ArangesCache&) = delete;\n+    ~ArangesCache() {\n+      this->free();\n+    }\n+\n+    void destroy(bool failed) {\n+      this->free();\n+      _count = 0;\n+      _capacity = 0;\n+      _failed = failed;\n+    }\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n+    bool valid() const { return _initialized && !_failed; }\n+    bool add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset);\n+    void sort();\n+\n+   private:\n+    static int compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b);\n+    bool grow();\n+    void free() {\n+      if (_entries != nullptr) {\n+        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n+        _entries = nullptr;\n+      }\n+    }\n+  };\n+\n@@ -478,5 +536,9 @@\n-    \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n-    \/\/ the set header in the DWARF 4 spec.\n-    struct AddressDescriptor {\n-      uintptr_t beginning_address = 0;\n-      uintptr_t range_length = 0;\n+    enum class CacheHint {\n+      \/\/ Do not retry as linear scan won't be able to read this either.\n+      FAILED,\n+\n+      \/\/ Cache is usable, no need to fallback to linear scan.\n+      VALID,\n+\n+      \/\/ Cache is unusable, possible reasons are C heap allocation failures. Fall back to linear scan.\n+      TRY_LINEAR_SCAN,\n@@ -486,0 +548,1 @@\n+    ArangesCache _cache;\n@@ -488,0 +551,1 @@\n+    uintptr_t _size_bytes;\n@@ -502,1 +566,1 @@\n-                                          _section_start_address(0), _entry_end(0) {}\n+                                          _section_start_address(0), _size_bytes(0), _entry_end(0) {}\n@@ -504,1 +568,1 @@\n-\n+    CacheHint ensure_cached();\n@@ -887,1 +951,2 @@\n-  DwarfFile(const char* filepath) : ElfFile(filepath) {}\n+  DwarfFile(const char* filepath) : ElfFile(filepath), _debug_aranges(this) {\n+  }\n@@ -900,0 +965,3 @@\n+\n+ private:\n+  DebugAranges _debug_aranges;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":79,"deletions":11,"binary":false,"changes":90,"status":"modified"}]}