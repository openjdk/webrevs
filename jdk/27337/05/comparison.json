{"files":[{"patch":"@@ -687,1 +687,0 @@\n-  DebugAranges debug_aranges(this);\n@@ -689,1 +688,1 @@\n-  if (!debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n+  if (!_debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset)) {\n@@ -711,0 +710,97 @@\n+\/\/ Sort entries by beginning_address, when same then sort longest range first.\n+int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n+  if (a.beginning_address < b.beginning_address) {\n+    return -1;\n+  } else if (a.beginning_address > b.beginning_address) {\n+    return 1;\n+  }\n+\n+  uintptr_t len_a = a.end_address - a.beginning_address;\n+  uintptr_t len_b = b.end_address - b.beginning_address;\n+  if (len_a < len_b) {\n+    return 1;\n+  } else if (len_a > len_b) {\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+DwarfFile::DebugAranges::CacheHint DwarfFile::DebugAranges::ensure_cached() {\n+  if (_cache._failed) {\n+    return CacheHint::FAILED;\n+  }\n+  if (_cache._initialized) {\n+    return CacheHint::VALID;\n+  }\n+\n+  assert(_cache._capacity == 0, \"need fresh cache\");\n+  assert(_cache._count == 0, \"need fresh cache\");\n+  const long pos = _reader.get_position();\n+  if (!read_section_header()) {\n+    _cache.destroy(true);\n+    return CacheHint::FAILED;\n+  }\n+  \/\/ Start with reasonable initial capacity\n+  size_t initial_capacity = 128;\n+  _cache._entries = NEW_C_HEAP_ARRAY(ArangesEntry, initial_capacity, mtInternal);\n+  if (_cache._entries == nullptr) {\n+    _cache.destroy(true);\n+    _reader.set_position(pos);\n+    return CacheHint::TRY_LINEAR_SCAN;\n+  }\n+  _cache._capacity = initial_capacity;\n+  _cache._count = 0;\n+\n+  \/\/ Read all sets and their descriptors\n+  while (_reader.has_bytes_left()) {\n+    DebugArangesSetHeader set_header;\n+    if (!read_set_header(set_header)) {\n+      break;\n+    }\n+\n+    \/\/ Read all address descriptors for this set\n+    AddressDescriptor descriptor;\n+    do {\n+      if (!read_address_descriptor(descriptor)) {\n+        _cache.destroy(true);\n+        return CacheHint::FAILED;\n+      }\n+      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0) {\n+        if (_cache._count >= _cache._capacity) {\n+          size_t new_capacity = _cache._capacity * 1.5;\n+          ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, new_capacity, mtInternal);\n+          if (new_entries == nullptr) {\n+            _cache.destroy(true);\n+            _reader.set_position(pos);\n+            return CacheHint::TRY_LINEAR_SCAN;\n+          }\n+          _cache._entries = new_entries;\n+          _cache._capacity = new_capacity;\n+        }\n+        _cache._entries[_cache._count] = ArangesEntry(\n+          descriptor.beginning_address,\n+          descriptor.beginning_address + descriptor.range_length,\n+          set_header._debug_info_offset\n+        );\n+        _cache._count++;\n+      }\n+    } while (!is_terminating_entry(set_header, descriptor) && _reader.has_bytes_left());\n+  }\n+  if (_cache._count == 0) {\n+    _cache.destroy(false);\n+    \/\/ No entries found, unusual but still valid.\n+    return CacheHint::VALID;\n+  }\n+  QuickSort::sort(_cache._entries, _cache._count, DwarfFile::ArangesCache::compare_aranges_entries);\n+  if (_cache._count < _cache._capacity) {\n+    ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, _cache._count, mtInternal);\n+    if (new_entries != nullptr) {\n+      _cache._entries = new_entries;\n+      _cache._capacity = _cache._count;\n+    }\n+  }\n+  _cache._initialized = true;\n+  DWARF_LOG_INFO(\"Built aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n+  return CacheHint::VALID;\n+}\n+\n@@ -716,0 +812,12 @@\n+  switch(ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  \/\/ Fall back to linear scan if building of the cache failed, which can happen\n+  \/\/ if there are heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n@@ -832,0 +940,22 @@\n+bool DwarfFile::ArangesCache::find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const {\n+  if (!_initialized || _entries == nullptr || _count == 0) {\n+    return false;\n+  }\n+\n+  size_t left = 0;\n+  size_t right = _count;\n+  while (left < right) {\n+    size_t mid = left + (right - left) \/ 2;\n+    const ArangesEntry& entry = _entries[mid];\n+    if (offset_in_library < entry.beginning_address) {\n+      right = mid;\n+    } else if (offset_in_library >= entry.end_address) {\n+      left = mid + 1;\n+    } else {\n+      *compilation_unit_offset = entry.debug_info_offset;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":132,"deletions":2,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -204,0 +205,3 @@\n+#ifdef ASSERT\n+  const char* filepath() const { return _filepath; }\n+#endif\n@@ -438,0 +442,51 @@\n+  struct ArangesEntry {\n+    uintptr_t beginning_address;\n+    uintptr_t end_address;\n+    uint32_t debug_info_offset;\n+\n+    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n+    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n+    : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n+  };\n+\n+  class DebugAranges;\n+\n+  \/\/ Cache for .debug_aranges to enable binary search for address lookup.\n+  \/\/ DebugAranges uses this cache to resolve the compilation_unit_offset, rather than doing a linear scan on the files\n+  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset\n+  struct ArangesCache {\n+    friend DebugAranges;\n+\n+    ArangesEntry* _entries;\n+    size_t _count;\n+    size_t _capacity;\n+    bool _initialized;\n+    bool _failed;\n+\n+   public:\n+    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n+    ArangesCache(const ArangesCache&) = delete;\n+    ArangesCache& operator=(const ArangesCache&) = delete;\n+    ~ArangesCache() {\n+      this->free();\n+    }\n+\n+    void destroy(bool failed) {\n+      this->free();\n+      _count = 0;\n+      _capacity = 0;\n+      _failed = failed;\n+    }\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n+    bool valid() const { return _initialized && !_failed; }\n+\n+   private:\n+    static int compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b);\n+    void free() {\n+      if (_entries != nullptr) {\n+        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n+        _entries = nullptr;\n+      }\n+    }\n+  };\n+\n@@ -485,0 +540,11 @@\n+    enum class CacheHint {\n+      \/\/ Do not retry as linear scan won't be able to read this either.\n+      FAILED,\n+\n+      \/\/ Cache is usable, no need to fallback to linear scan.\n+      VALID,\n+\n+      \/\/ Cache is unusable, fallback to linear scan.\n+      TRY_LINEAR_SCAN,\n+    };\n+\n@@ -486,0 +552,1 @@\n+    ArangesCache _cache;\n@@ -501,1 +568,1 @@\n-    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()),\n+    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _cache(), _reader(dwarf_file->fd()),\n@@ -505,0 +572,2 @@\n+    \/\/ Build cache of all address ranges for binary search in a single pass\n+    CacheHint ensure_cached();\n@@ -887,1 +956,2 @@\n-  DwarfFile(const char* filepath) : ElfFile(filepath) {}\n+  DwarfFile(const char* filepath) : ElfFile(filepath), _debug_aranges(this) {\n+  }\n@@ -900,0 +970,3 @@\n+\n+ private:\n+  DebugAranges _debug_aranges;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":75,"deletions":2,"binary":false,"changes":77,"status":"modified"}]}