{"files":[{"patch":"@@ -710,18 +710,1 @@\n-\/\/ Sort entries by beginning_address, when same then sort longest range first.\n-int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n-  if (a.beginning_address < b.beginning_address) {\n-    return -1;\n-  } else if (a.beginning_address > b.beginning_address) {\n-    return 1;\n-  }\n-\n-  uintptr_t len_a = a.end_address - a.beginning_address;\n-  uintptr_t len_b = b.end_address - b.beginning_address;\n-  if (len_a < len_b) {\n-    return 1;\n-  } else if (len_a > len_b) {\n-    return -1;\n-  }\n-  return 0;\n-}\n-\n+\/\/ Build sorted cache of all address ranges for binary search.\n@@ -743,3 +726,6 @@\n-  \/\/ Start with reasonable initial capacity\n-  size_t initial_capacity = 128;\n-  _cache._entries = NEW_C_HEAP_ARRAY(ArangesEntry, initial_capacity, mtInternal);\n+\n+  \/\/ Start with reasonable initial capacity to minimize number of grow\/realloc calls.\n+  \/\/ Assume ~3% of the .debug_aranges is DebugArangesSetHeader and the rest is made up of AddressDescriptors.\n+  const uintptr_t estimatedSetHeaderSize = _size_bytes \/ 32;\n+  const size_t initial_capacity = (_size_bytes - estimatedSetHeaderSize) \/ sizeof(AddressDescriptor);\n+  _cache._entries = NEW_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, initial_capacity, mtInternal);\n@@ -761,1 +747,1 @@\n-    \/\/ Read all address descriptors for this set\n+    \/\/ Read all address descriptors for this set into the cache.\n@@ -768,18 +754,4 @@\n-      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0) {\n-        if (_cache._count >= _cache._capacity) {\n-          size_t new_capacity = _cache._capacity * 1.5;\n-          ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, new_capacity, mtInternal);\n-          if (new_entries == nullptr) {\n-            _cache.destroy(true);\n-            _reader.set_position(pos);\n-            return CacheHint::TRY_LINEAR_SCAN;\n-          }\n-          _cache._entries = new_entries;\n-          _cache._capacity = new_capacity;\n-        }\n-        _cache._entries[_cache._count] = ArangesEntry(\n-          descriptor.beginning_address,\n-          descriptor.beginning_address + descriptor.range_length,\n-          set_header._debug_info_offset\n-        );\n-        _cache._count++;\n+      if (!is_terminating_entry(set_header, descriptor) && descriptor.range_length > 0 &&\n+          !_cache.add_entry(descriptor, set_header._debug_info_offset)) {\n+        _reader.set_position(pos);\n+        return CacheHint::TRY_LINEAR_SCAN;\n@@ -789,0 +761,1 @@\n+\n@@ -794,8 +767,1 @@\n-  QuickSort::sort(_cache._entries, _cache._count, DwarfFile::ArangesCache::compare_aranges_entries);\n-  if (_cache._count < _cache._capacity) {\n-    ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, _cache._count, mtInternal);\n-    if (new_entries != nullptr) {\n-      _cache._entries = new_entries;\n-      _cache._capacity = _cache._count;\n-    }\n-  }\n+  _cache.sort();\n@@ -803,1 +769,1 @@\n-  DWARF_LOG_INFO(\"Built aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n+  DWARF_LOG_INFO(\"Built .debug_aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n@@ -812,1 +778,1 @@\n-  switch(ensure_cached()) {\n+  switch (ensure_cached()) {\n@@ -822,1 +788,1 @@\n-  \/\/ if there are heap allocation errors.\n+  \/\/ if there are C heap allocation errors.\n@@ -861,0 +827,1 @@\n+  _size_bytes = shdr.sh_size;\n@@ -940,0 +907,47 @@\n+\/\/ Sort entries by beginning_address, when same then sort longest range first.\n+int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n+  if (a.beginning_address < b.beginning_address) {\n+    return -1;\n+  } else if (a.beginning_address > b.beginning_address) {\n+    return 1;\n+  }\n+\n+  uintptr_t len_a = a.end_address - a.beginning_address;\n+  uintptr_t len_b = b.end_address - b.beginning_address;\n+  if (len_a < len_b) {\n+    return 1;\n+  } else if (len_a > len_b) {\n+    return -1;\n+  }\n+  return 0;\n+}\n+\n+void DwarfFile::ArangesCache::sort() {\n+  QuickSort::sort(_entries, _count, compare_aranges_entries);\n+}\n+\n+bool DwarfFile::ArangesCache::add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset) {\n+  if (_count >= _capacity && !grow()) {\n+    destroy(true);\n+    return false;\n+  }\n+  _entries[_count] = ArangesEntry(\n+    descriptor.beginning_address,\n+    descriptor.beginning_address + descriptor.range_length,\n+    debug_info_offset\n+  );\n+  _count++;\n+  return true;\n+}\n+\n+bool DwarfFile::ArangesCache::grow() {\n+  size_t new_capacity = _capacity == 0 ? 128 : _capacity * 1.5;\n+  ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY_RETURN_NULL(ArangesEntry, _entries, new_capacity, mtInternal);\n+  if (new_entries == nullptr) {\n+    return false;\n+  }\n+  _entries = new_entries;\n+  _capacity = new_capacity;\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":65,"deletions":51,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+class DwarfFile;\n+class ElfFuncDescTable;\n@@ -100,2 +102,0 @@\n-class ElfFuncDescTable;\n-class DwarfFile;\n@@ -205,3 +205,1 @@\n-#ifdef ASSERT\n-  const char* filepath() const { return _filepath; }\n-#endif\n+  DEBUG_ONLY(const char* filepath() const { return _filepath; })\n@@ -404,1 +402,0 @@\n-\n@@ -442,0 +439,8 @@\n+  \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n+  \/\/ the set header in the DWARF 4 spec.\n+  struct AddressDescriptor {\n+    uintptr_t beginning_address = 0;\n+    uintptr_t range_length = 0;\n+  };\n+\n+  \/\/ Entry in ArangesCache, corresponding to an entry in .debug_aranges section.\n@@ -452,2 +457,0 @@\n-  class DebugAranges;\n-\n@@ -456,1 +459,1 @@\n-  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset\n+  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset.\n@@ -458,2 +461,0 @@\n-    friend DebugAranges;\n-\n@@ -466,1 +467,0 @@\n-   public:\n@@ -482,0 +482,2 @@\n+    bool add_entry(const AddressDescriptor& descriptor, uint32_t debug_info_offset);\n+    void sort();\n@@ -485,0 +487,1 @@\n+    bool grow();\n@@ -533,7 +536,0 @@\n-    \/\/ Address descriptor defining a range that is covered by a compilation unit. It is defined in section 6.1.2 after\n-    \/\/ the set header in the DWARF 4 spec.\n-    struct AddressDescriptor {\n-      uintptr_t beginning_address = 0;\n-      uintptr_t range_length = 0;\n-    };\n-\n@@ -547,1 +543,1 @@\n-      \/\/ Cache is unusable, fallback to linear scan.\n+      \/\/ Cache is unusable, possible reasons are C heap allocation failures. Fall back to linear scan.\n@@ -555,0 +551,1 @@\n+    uintptr_t _size_bytes;\n@@ -568,2 +565,2 @@\n-    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _cache(), _reader(dwarf_file->fd()),\n-                                          _section_start_address(0), _entry_end(0) {}\n+    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()),\n+                                          _section_start_address(0), _size_bytes(0), _entry_end(0) {}\n@@ -571,2 +568,0 @@\n-\n-    \/\/ Build cache of all address ranges for binary search in a single pass\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":19,"deletions":24,"binary":false,"changes":43,"status":"modified"}]}