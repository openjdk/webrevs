{"files":[{"patch":"@@ -687,1 +687,0 @@\n-  \/\/ Use cached aranges for binary search if available\n@@ -689,1 +688,0 @@\n-  ensure_aranges_cache();\n@@ -691,7 +689,1 @@\n-  if (_aranges_cache._initialized) {\n-    found = _aranges_cache.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset);\n-  } else {\n-    DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", filepath());\n-    DebugAranges debug_aranges(this);\n-    found = debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset);\n-  }\n+  found = _debug_aranges.find_compilation_unit_offset(offset_in_library, &compilation_unit_offset);\n@@ -720,5 +712,3 @@\n-int DwarfFile::ArangesCache::compare_aranges_entries(const void* a, const void* b) {\n-  const ArangesEntry* entry_a = static_cast<const ArangesEntry*>(a);\n-  const ArangesEntry* entry_b = static_cast<const ArangesEntry*>(b);\n-\n-  if (entry_a->beginning_address < entry_b->beginning_address) {\n+\/\/ Sort entries by beginning_address, when same then sort longest range first.\n+int DwarfFile::ArangesCache::compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b) {\n+  if (a.beginning_address < b.beginning_address) {\n@@ -726,1 +716,1 @@\n-  } else if (entry_a->beginning_address > entry_b->beginning_address) {\n+  } else if (a.beginning_address > b.beginning_address) {\n@@ -730,2 +720,2 @@\n-  uintptr_t len_a = entry_a->end_address - entry_a->beginning_address;\n-  uintptr_t len_b = entry_b->end_address - entry_b->beginning_address;\n+  uintptr_t len_a = a.end_address - a.beginning_address;\n+  uintptr_t len_b = b.end_address - b.beginning_address;\n@@ -733,2 +723,0 @@\n-    return -1;\n-  } else if (len_a > len_b) {\n@@ -736,0 +724,2 @@\n+  } else if (len_a > len_b) {\n+    return -1;\n@@ -740,5 +730,11 @@\n-void DwarfFile::DebugAranges::build_cache(ArangesCache& cache) {\n-  assert(cache._capacity == 0, \"need fresh cache\");\n-  assert(cache._count == 0, \"need fresh cache\");\n-  assert(!cache._initialized, \"need fresh cache\");\n-  assert(!cache._failed, \"need fresh cache\");\n+DwarfFile::DebugAranges::CacheHint DwarfFile::DebugAranges::ensure_cached() {\n+  if (_cache._failed) {\n+    return CacheHint::FAILED;\n+  }\n+  if (_cache._initialized) {\n+    return CacheHint::VALID;\n+  }\n+\n+  assert(_cache._capacity == 0, \"need fresh cache\");\n+  assert(_cache._count == 0, \"need fresh cache\");\n+  const long pos = _reader.get_position();\n@@ -746,2 +742,2 @@\n-    cache._failed = true;\n-    return;\n+    _cache.destroy(true);\n+    return CacheHint::FAILED;\n@@ -751,4 +747,6 @@\n-  cache._entries = NEW_C_HEAP_ARRAY(ArangesEntry, initial_capacity, mtInternal);\n-  if (cache._entries == nullptr) {\n-    cache._failed = true;\n-    return;\n+  _cache._entries = NEW_C_HEAP_ARRAY(ArangesEntry, initial_capacity, mtInternal);\n+  if (_cache._entries == nullptr) {\n+    _cache.destroy(true);\n+    \/\/ TODO Reset pointer of read_section_header.\n+    _reader.set_position(pos);\n+    return CacheHint::TRY_LINEAR_SCAN;\n@@ -756,2 +754,2 @@\n-  cache._capacity = initial_capacity;\n-  cache._count = 0;\n+  _cache._capacity = initial_capacity;\n+  _cache._count = 0;\n@@ -770,1 +768,2 @@\n-        goto cleanup_and_fail;\n+        _cache.destroy(true);\n+        return CacheHint::FAILED;\n@@ -773,3 +772,3 @@\n-        if (cache._count >= cache._capacity) {\n-          size_t new_capacity = cache._capacity * 1.5;\n-          ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, cache._entries, new_capacity, mtInternal);\n+        if (_cache._count >= _cache._capacity) {\n+          size_t new_capacity = _cache._capacity * 1.5;\n+          ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, new_capacity, mtInternal);\n@@ -777,1 +776,3 @@\n-            goto cleanup_and_fail;\n+            _cache.destroy(true);\n+            _reader.set_position(pos);\n+            return CacheHint::TRY_LINEAR_SCAN;\n@@ -779,2 +780,2 @@\n-          cache._entries = new_entries;\n-          cache._capacity = new_capacity;\n+          _cache._entries = new_entries;\n+          _cache._capacity = new_capacity;\n@@ -782,1 +783,1 @@\n-        cache._entries[cache._count] = ArangesEntry(\n+        _cache._entries[_cache._count] = ArangesEntry(\n@@ -787,1 +788,1 @@\n-        cache._count++;\n+        _cache._count++;\n@@ -791,2 +792,4 @@\n-  if (cache._count == 0) {\n-    goto cleanup_and_fail;\n+  if (_cache._count == 0) {\n+    _cache.destroy(false);\n+    \/\/ No entries found, unusual but still valid.\n+    return CacheHint::VALID;\n@@ -794,3 +797,3 @@\n-  cache.sort();\n-  if (cache._count < cache._capacity) {\n-    ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, cache._entries, cache._count, mtInternal);\n+  QuickSort::sort(_cache._entries, _cache._count, DwarfFile::ArangesCache::compare_aranges_entries);\n+  if (_cache._count < _cache._capacity) {\n+    ArangesEntry* new_entries = REALLOC_C_HEAP_ARRAY(ArangesEntry, _cache._entries, _cache._count, mtInternal);\n@@ -798,2 +801,2 @@\n-      cache._entries = new_entries;\n-      cache._capacity = cache._count;\n+      _cache._entries = new_entries;\n+      _cache._capacity = _cache._count;\n@@ -802,12 +805,3 @@\n-  cache._initialized = true;\n-  DWARF_LOG_INFO(\"Built aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), cache._count);\n-  return;\n-\n-cleanup_and_fail:\n-  if (cache._entries != nullptr) {\n-    FREE_C_HEAP_ARRAY(ArangesEntry, cache._entries);\n-    cache._entries = nullptr;\n-  }\n-  cache._count = 0;\n-  cache._capacity = 0;\n-  cache._failed = true;\n+  _cache._initialized = true;\n+  DWARF_LOG_INFO(\"Built aranges cache for '%s' with %zu entries\", this->_dwarf_file->filepath(), _cache._count);\n+  return CacheHint::VALID;\n@@ -821,0 +815,12 @@\n+  switch(ensure_cached()) {\n+    case CacheHint::VALID:\n+      return _cache.find_compilation_unit_offset(offset_in_library, compilation_unit_offset);\n+    case CacheHint::TRY_LINEAR_SCAN:\n+      break;\n+    case CacheHint::FAILED:\n+      return false;\n+  }\n+\n+  \/\/ Fall back to linear scan if building of the cache failed, which can happen\n+  \/\/ if there are heap allocation errors.\n+  DWARF_LOG_INFO(\"Falling back to linear scan of .debug_aranges for '%s'\", _dwarf_file->filepath());\n","filename":"src\/hotspot\/share\/utilities\/elfFile.cpp","additions":66,"deletions":60,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"utilities\/quickSort.hpp\"\n@@ -441,1 +442,48 @@\n-  struct ArangesCache;\n+  struct ArangesEntry {\n+    uintptr_t beginning_address;\n+    uintptr_t end_address;\n+    uint32_t debug_info_offset;\n+\n+    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n+    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n+    : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n+  };\n+\n+  class DebugAranges;\n+\n+  \/\/ Cache for .debug_aranges to enable binary search for address lookup.\n+  \/\/ DebugAranges uses this cache to resolve the compilation_unit_offset, rather than doing a linear scan on the files\n+  \/\/ in each invocation of DebugAranges::find_compilation_unit_offset\n+  struct ArangesCache {\n+    friend DebugAranges;\n+\n+    ArangesEntry* _entries;\n+    size_t _count;\n+    size_t _capacity;\n+    bool _initialized;\n+    bool _failed;\n+\n+   public:\n+    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n+    ~ArangesCache() {\n+      this->free();\n+    }\n+\n+    void destroy(bool failed) {\n+      this->free();\n+      _count = 0;\n+      _capacity = 0;\n+      _failed = failed;\n+    }\n+    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n+    bool valid() { return _initialized && !_failed; }\n+\n+   private:\n+    static int compare_aranges_entries(const ArangesEntry& a, const ArangesEntry& b);\n+    void free() {\n+      if (_entries != nullptr) {\n+        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n+        _entries = nullptr;\n+      }\n+    }\n+  };\n@@ -490,0 +538,11 @@\n+    enum class CacheHint {\n+      \/\/ Do not retry as linear scan won't be able to read this either.\n+      FAILED,\n+\n+      \/\/ Cache is usable, no need to fallback to linear scan.\n+      VALID,\n+\n+      \/\/ Cache is unusable, fallback to linear scan.\n+      TRY_LINEAR_SCAN,\n+    };\n+\n@@ -491,0 +550,1 @@\n+    ArangesCache _cache;\n@@ -506,1 +566,1 @@\n-    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _reader(dwarf_file->fd()),\n+    DebugAranges(DwarfFile* dwarf_file) : _dwarf_file(dwarf_file), _cache(), _reader(dwarf_file->fd()),\n@@ -509,37 +569,0 @@\n-    void build_cache(ArangesCache& cache);\n-  };\n-\n-  struct ArangesEntry {\n-    uintptr_t beginning_address;\n-    uintptr_t end_address;\n-    uint32_t debug_info_offset;\n-\n-    ArangesEntry() : beginning_address(0), end_address(0), debug_info_offset(0) {}\n-    ArangesEntry(uintptr_t begin, uintptr_t end, uint32_t offset)\n-      : beginning_address(begin), end_address(end), debug_info_offset(offset) {}\n-  };\n-\n-  \/\/ Cache for .debug_aranges to enable binary search for address lookup\n-  struct ArangesCache {\n-    friend DebugAranges;\n-\n-    ArangesEntry* _entries;\n-    size_t _count;\n-    size_t _capacity;\n-    bool _initialized;\n-    bool _failed;\n-\n-    ArangesCache() : _entries(nullptr), _count(0), _capacity(0), _initialized(false), _failed(false) {}\n-    ArangesCache(ArangesCache&& other) : _entries(other._entries), _count(other._count), _capacity(other._capacity),\n-                                          _initialized(other._initialized), _failed(other._failed) {\n-      other._entries = nullptr;\n-      other._count = 0;\n-      other._capacity = 0;\n-    }\n-    ~ArangesCache() {\n-      if (_entries != nullptr) {\n-        FREE_C_HEAP_ARRAY(ArangesEntry, _entries);\n-      }\n-    }\n-\n-    bool find_compilation_unit_offset(uint32_t offset_in_library, uint32_t* compilation_unit_offset) const;\n@@ -547,5 +570,2 @@\n-   private:\n-    static int compare_aranges_entries(const void* a, const void* b);\n-    void sort() {\n-      qsort(_entries, _count, sizeof(ArangesEntry), DwarfFile::ArangesCache::compare_aranges_entries);\n-    }\n+    \/\/ Build cache of all address ranges for binary search in a single pass\n+    CacheHint ensure_cached();\n@@ -934,1 +954,2 @@\n-  DwarfFile(const char* filepath) : ElfFile(filepath) {}\n+  DwarfFile(const char* filepath) : ElfFile(filepath), _debug_aranges(this) {\n+  }\n@@ -949,10 +970,1 @@\n-  ArangesCache _aranges_cache;\n-\n-  \/\/ Build cache of all address ranges for binary search in a single pass\n-  void ensure_aranges_cache() {\n-    if (_aranges_cache._initialized || _aranges_cache._failed) {\n-      return;\n-    }\n-    DebugAranges debug_aranges(const_cast<DwarfFile*>(this));\n-    debug_aranges.build_cache(_aranges_cache);\n-  }\n+  DebugAranges _debug_aranges;\n","filename":"src\/hotspot\/share\/utilities\/elfFile.hpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"}]}