{"files":[{"patch":"@@ -38,0 +38,2 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -40,2 +42,0 @@\n-#include \"memory\/resourceArea.hpp\"\n-#include \"runtime\/atomic.hpp\"\n@@ -44,3 +44,1 @@\n-  ConcurrentGCThread(),\n-  _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n+  ShenandoahController(),\n@@ -48,2 +46,1 @@\n-  _degen_point(ShenandoahGC::_degenerated_outside_cycle),\n-  _allocs_seen(0) {\n+  _degen_point(ShenandoahGC::_degenerated_outside_cycle) {\n@@ -51,1 +48,0 @@\n-  reset_gc_id();\n@@ -56,1 +52,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -80,1 +76,1 @@\n-    const size_t allocs_seen = Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+    const size_t allocs_seen = reset_allocs_seen();\n@@ -109,1 +105,0 @@\n-\n@@ -242,1 +237,1 @@\n-      \/\/ Allow allocators to know we have seen this much regions\n+      \/\/ Report to pacer that we have seen this many words allocated\n@@ -410,51 +405,0 @@\n-void ShenandoahControlThread::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  assert(current()->is_Java_thread(), \"expect Java thread here\");\n-\n-  if (try_set_alloc_failure_gc()) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n-                 req.type_string(),\n-                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n-\n-    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n-    heap->cancel_gc(GCCause::_allocation_failure);\n-  }\n-\n-\n-  if (block) {\n-    MonitorLocker ml(&_alloc_failure_waiters_lock);\n-    while (is_alloc_failure_gc()) {\n-      ml.wait();\n-    }\n-  }\n-}\n-\n-void ShenandoahControlThread::handle_alloc_failure_evac(size_t words) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  if (try_set_alloc_failure_gc()) {\n-    \/\/ Only report the first allocation failure\n-    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n-                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n-  }\n-\n-  \/\/ Forcefully report allocation failure\n-  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n-}\n-\n-void ShenandoahControlThread::notify_alloc_failure_waiters() {\n-  _alloc_failure_gc.unset();\n-  MonitorLocker ml(&_alloc_failure_waiters_lock);\n-  ml.notify_all();\n-}\n-\n-bool ShenandoahControlThread::try_set_alloc_failure_gc() {\n-  return _alloc_failure_gc.try_set();\n-}\n-\n-bool ShenandoahControlThread::is_alloc_failure_gc() {\n-  return _alloc_failure_gc.is_set();\n-}\n-\n@@ -466,29 +410,0 @@\n-\n-void ShenandoahControlThread::pacing_notify_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n-  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n-}\n-\n-void ShenandoahControlThread::reset_gc_id() {\n-  Atomic::store(&_gc_id, (size_t)0);\n-}\n-\n-void ShenandoahControlThread::update_gc_id() {\n-  Atomic::inc(&_gc_id);\n-}\n-\n-size_t ShenandoahControlThread::get_gc_id() {\n-  return Atomic::load(&_gc_id);\n-}\n-\n-void ShenandoahControlThread::start() {\n-  create_and_start();\n-}\n-\n-void ShenandoahControlThread::prepare_for_graceful_shutdown() {\n-  _graceful_shutdown.set();\n-}\n-\n-bool ShenandoahControlThread::in_graceful_shutdown() {\n-  return _graceful_shutdown.is_set();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":92,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n@@ -34,1 +35,1 @@\n-class ShenandoahControlThread: public ConcurrentGCThread {\n+class ShenandoahControlThread: public ShenandoahController {\n@@ -45,11 +46,0 @@\n-  \/\/ While we could have a single lock for these, it may risk unblocking\n-  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n-  \/\/ to make complete explicit cycle for for demanding customers.\n-  Monitor _alloc_failure_waiters_lock;\n-  Monitor _gc_waiters_lock;\n-\n-public:\n-  void run_service();\n-  void stop_service();\n-\n-private:\n@@ -57,2 +47,0 @@\n-  ShenandoahSharedFlag _alloc_failure_gc;\n-  ShenandoahSharedFlag _graceful_shutdown;\n@@ -62,5 +50,9 @@\n-  shenandoah_padding(0);\n-  volatile size_t _allocs_seen;\n-  shenandoah_padding(1);\n-  volatile size_t _gc_id;\n-  shenandoah_padding(2);\n+public:\n+  ShenandoahControlThread();\n+\n+  void run_service() override;\n+  void stop_service() override;\n+\n+  void request_gc(GCCause::Cause cause) override;\n+\n+private:\n@@ -73,8 +65,0 @@\n-  bool try_set_alloc_failure_gc();\n-  void notify_alloc_failure_waiters();\n-  bool is_alloc_failure_gc();\n-\n-  void reset_gc_id();\n-  void update_gc_id();\n-  size_t get_gc_id();\n-\n@@ -86,21 +70,0 @@\n-\n-public:\n-  \/\/ Constructor\n-  ShenandoahControlThread();\n-\n-  \/\/ Handle allocation failure from a mutator allocation.\n-  \/\/ Optionally blocks while collector is handling the failure. If the GC\n-  \/\/ threshold has been exceeded, the mutator allocation will not block so\n-  \/\/ that the out of memory error can be raised promptly.\n-  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block = true);\n-\n-  \/\/ Handle allocation failure from evacuation path.\n-  void handle_alloc_failure_evac(size_t words);\n-\n-  void request_gc(GCCause::Cause cause);\n-\n-  void pacing_notify_alloc(size_t words);\n-\n-  void start();\n-  void prepare_for_graceful_shutdown();\n-  bool in_graceful_shutdown();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":11,"deletions":48,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shenandoah\/shenandoahController.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.inline.hpp\"\n+\n+void ShenandoahController::pacing_notify_alloc(size_t words) {\n+  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n+  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n+}\n+\n+size_t ShenandoahController::reset_allocs_seen() {\n+  return Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n+}\n+\n+void ShenandoahController::prepare_for_graceful_shutdown() {\n+  _graceful_shutdown.set();\n+}\n+\n+bool ShenandoahController::in_graceful_shutdown() {\n+  return _graceful_shutdown.is_set();\n+}\n+\n+void ShenandoahController::update_gc_id() {\n+  Atomic::inc(&_gc_id);\n+}\n+\n+size_t ShenandoahController::get_gc_id() {\n+  return Atomic::load(&_gc_id);\n+}\n+\n+void ShenandoahController::handle_alloc_failure(ShenandoahAllocRequest& req, bool block) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  assert(current()->is_Java_thread(), \"expect Java thread here\");\n+  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate %s, \" SIZE_FORMAT \"%s\",\n+                 req.type_string(),\n+                 byte_size_in_proper_unit(req.size() * HeapWordSize), proper_unit_for_byte_size(req.size() * HeapWordSize));\n+\n+    \/\/ Now that alloc failure GC is scheduled, we can abort everything else\n+    heap->cancel_gc(GCCause::_allocation_failure);\n+  }\n+\n+\n+  if (block) {\n+    MonitorLocker ml(&_alloc_failure_waiters_lock);\n+    while (is_alloc_failure_gc()) {\n+      ml.wait();\n+    }\n+  }\n+}\n+\n+void ShenandoahController::handle_alloc_failure_evac(size_t words) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+\n+  if (try_set_alloc_failure_gc(is_humongous)) {\n+    \/\/ Only report the first allocation failure\n+    log_info(gc)(\"Failed to allocate \" SIZE_FORMAT \"%s for evacuation\",\n+                 byte_size_in_proper_unit(words * HeapWordSize), proper_unit_for_byte_size(words * HeapWordSize));\n+  }\n+\n+  \/\/ Forcefully report allocation failure\n+  heap->cancel_gc(GCCause::_shenandoah_allocation_failure_evac);\n+}\n+\n+void ShenandoahController::notify_alloc_failure_waiters() {\n+  _alloc_failure_gc.unset();\n+  _humongous_alloc_failure_gc.unset();\n+  MonitorLocker ml(&_alloc_failure_waiters_lock);\n+  ml.notify_all();\n+}\n+\n+bool ShenandoahController::try_set_alloc_failure_gc(bool is_humongous) {\n+  if (is_humongous) {\n+    _humongous_alloc_failure_gc.try_set();\n+  }\n+  return _alloc_failure_gc.try_set();\n+}\n+\n+bool ShenandoahController::is_alloc_failure_gc() {\n+  return _alloc_failure_gc.is_set();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+#define LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n+\n+#include \"gc\/shared\/gcCause.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahAllocRequest.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+\/**\n+ * This interface exposes methods necessary for the heap to interact\n+ * with the threads responsible for driving the collection cycle.\n+ *\/\n+class ShenandoahController: public ConcurrentGCThread {\n+private:\n+  ShenandoahSharedFlag _graceful_shutdown;\n+\n+  shenandoah_padding(0);\n+  volatile size_t _allocs_seen;\n+  shenandoah_padding(1);\n+  volatile size_t _gc_id;\n+  shenandoah_padding(2);\n+\n+protected:\n+  ShenandoahSharedFlag _alloc_failure_gc;\n+  ShenandoahSharedFlag _humongous_alloc_failure_gc;\n+\n+  \/\/ While we could have a single lock for these, it may risk unblocking\n+  \/\/ GC waiters when alloc failure GC cycle finishes. We want instead\n+  \/\/ to make complete explicit cycle for demanding customers.\n+  Monitor _alloc_failure_waiters_lock;\n+  Monitor _gc_waiters_lock;\n+\n+public:\n+  ShenandoahController():\n+    ConcurrentGCThread(),\n+    _allocs_seen(0),\n+    _gc_id(0),\n+    _alloc_failure_waiters_lock(Mutex::safepoint-2, \"ShenandoahAllocFailureGC_lock\", true),\n+    _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true)\n+  { }\n+\n+  \/\/ Request a collection cycle. This handles \"explicit\" gc requests\n+  \/\/ like System.gc and \"implicit\" gc requests, like metaspace oom.\n+  virtual void request_gc(GCCause::Cause cause) = 0;\n+\n+  \/\/ This cancels the collection cycle and has an option to block\n+  \/\/ until another cycle runs and clears the alloc failure gc flag.\n+  void handle_alloc_failure(ShenandoahAllocRequest& req, bool block);\n+\n+  \/\/ Invoked for allocation failures during evacuation. This cancels\n+  \/\/ the collection cycle without blocking.\n+  void handle_alloc_failure_evac(size_t words);\n+\n+  \/\/ Return true if setting the flag which indicates allocation failure succeeds.\n+  bool try_set_alloc_failure_gc(bool is_humongous);\n+\n+  \/\/ Notify threads waiting for GC to complete.\n+  void notify_alloc_failure_waiters();\n+\n+  \/\/ True if allocation failure flag has been set.\n+  bool is_alloc_failure_gc();\n+\n+  \/\/ This is called for every allocation. The control thread accumulates\n+  \/\/ this value when idle. During the gc cycle, the control resets it\n+  \/\/ and reports it to the pacer.\n+  void pacing_notify_alloc(size_t words);\n+  size_t reset_allocs_seen();\n+\n+  \/\/ These essentially allows to cancel a collection cycle for the\n+  \/\/ purpose of shutting down the JVM, without trying to start a degenerated\n+  \/\/ cycle.\n+  void prepare_for_graceful_shutdown();\n+  bool in_graceful_shutdown();\n+\n+\n+  \/\/ Returns the internal gc count used by the control thread. Probably\n+  \/\/ doesn't need to be exposed.\n+  size_t get_gc_id();\n+  void update_gc_id();\n+};\n+#endif \/\/LINUX_X86_64_SERVER_SLOWDEBUG_SHENANDOAHCONTROLLER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -958,1 +958,1 @@\n-      control_thread()->handle_alloc_failure(req);\n+      control_thread()->handle_alloc_failure(req, true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}