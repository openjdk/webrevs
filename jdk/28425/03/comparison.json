{"files":[{"patch":"@@ -185,1 +185,43 @@\n-        return convert0('X', vspecies().withLanes(laneType));\n+        return convert0('X', vspecies().withLanes(laneType)).swapIfNeeded(vspecies());\n+    }\n+\n+    @ForceInline\n+    protected static <T> VectorShuffle<T> normalizeSubLanesForSpecies(AbstractSpecies<T> targetSpecies, int subLanesPerSrc) {\n+        final int lanes = targetSpecies.laneCount();\n+\n+        \/\/ This happens when source and target element sizes are equal\n+        \/\/ (int -> int, long -> long). Therefore, no reordering is required.\n+        if (subLanesPerSrc <= 1) {\n+            int[] id = new int[lanes];\n+            for (int i = 0; i < lanes; ++i) id[i] = i;\n+            return VectorShuffle.fromArray(targetSpecies, id, 0);\n+        }\n+        if ((lanes % subLanesPerSrc) != 0) {\n+            throw new IllegalArgumentException(\"laneCount \" + lanes + \" not divisible by subLanesPerSrc \" + subLanesPerSrc);\n+        }\n+\n+        \/\/ Each group corresponds to one source lane.\n+        \/\/ For each group, reverse the lanes inside that group.\n+        final int groups = lanes \/ subLanesPerSrc;\n+        int[] map = new int[lanes];\n+        for (int g = 0; g < groups; ++g) {\n+            int base = g * subLanesPerSrc;\n+            for (int j = 0; j < subLanesPerSrc; ++j) {\n+                 map[base + j] = base + (subLanesPerSrc - 1 - j);\n+            }\n+        }\n+        return VectorShuffle.fromArray(targetSpecies, map, 0);\n+    }\n+\n+    @ForceInline\n+    protected final int subLanesToSwap(ByteOrder bo, AbstractSpecies<?> srcSpecies) {\n+        if (bo != ByteOrder.BIG_ENDIAN) {\n+            return -1;\n+        }\n+        int sBytes = srcSpecies.elementSize();\n+        int tBytes = vspecies().elementSize();\n+        if (sBytes == tBytes || (sBytes % tBytes) != 0) {\n+            return -1;\n+        }\n+        int subLanesPerSrc = sBytes \/ tBytes;\n+        return subLanesPerSrc;\n@@ -245,0 +287,3 @@\n+    \/*package-private*\/\n+    abstract AbstractVector<?> swapIfNeeded(AbstractSpecies<?> srcSpecies);\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4104,0 +4104,8 @@\n+    \/*package-private*\/\n+    @Override\n+    @ForceInline\n+    final\n+    ByteVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        return this;\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3615,0 +3615,13 @@\n+    @Override\n+    @ForceInline\n+    final\n+    DoubleVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int subLanesPerSrc = subLanesToSwap(bo, srcSpecies);\n+        if (subLanesPerSrc < 0) {\n+            return this;\n+        }\n+        VectorShuffle<Double> shuffle = normalizeSubLanesForSpecies(this.vspecies(), subLanesPerSrc);\n+        return (DoubleVector) this.rearrange(shuffle);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3565,0 +3565,13 @@\n+    @Override\n+    @ForceInline\n+    final\n+    FloatVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int subLanesPerSrc = subLanesToSwap(bo, srcSpecies);\n+        if (subLanesPerSrc < 0) {\n+            return this;\n+        }\n+        VectorShuffle<Float> shuffle = normalizeSubLanesForSpecies(this.vspecies(), subLanesPerSrc);\n+        return (FloatVector) this.rearrange(shuffle);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3723,0 +3723,13 @@\n+    @Override\n+    @ForceInline\n+    final\n+    IntVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int subLanesPerSrc = subLanesToSwap(bo, srcSpecies);\n+        if (subLanesPerSrc < 0) {\n+            return this;\n+        }\n+        VectorShuffle<Integer> shuffle = normalizeSubLanesForSpecies(this.vspecies(), subLanesPerSrc);\n+        return (IntVector) this.rearrange(shuffle);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3658,0 +3658,13 @@\n+    @Override\n+    @ForceInline\n+    final\n+    LongVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int subLanesPerSrc = subLanesToSwap(bo, srcSpecies);\n+        if (subLanesPerSrc < 0) {\n+            return this;\n+        }\n+        VectorShuffle<Long> shuffle = normalizeSubLanesForSpecies(this.vspecies(), subLanesPerSrc);\n+        return (LongVector) this.rearrange(shuffle);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4077,0 +4077,13 @@\n+    @Override\n+    @ForceInline\n+    final\n+    ShortVector swapIfNeeded(AbstractSpecies<?> srcSpecies) {\n+        ByteOrder bo = ByteOrder.nativeOrder();\n+        int subLanesPerSrc = subLanesToSwap(bo, srcSpecies);\n+        if (subLanesPerSrc < 0) {\n+            return this;\n+        }\n+        VectorShuffle<Short> shuffle = normalizeSubLanesForSpecies(this.vspecies(), subLanesPerSrc);\n+        return (ShortVector) this.rearrange(shuffle);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}