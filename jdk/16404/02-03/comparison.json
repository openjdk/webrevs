{"files":[{"patch":"@@ -63,7 +63,11 @@\n-\/\/ with updates always done with CASes. For the cell state, positive values mean\n-\/\/ the cell is armed and maybe has waiters. Negative values mean the cell is disarmed\n-\/\/ and maybe has completing waiters. The cell starts with \"-1\". Arming a cell swings\n-\/\/ from \"-1\" to \"+1\". Every new waiter swings from (n) to (n+1), as long as \"n\" is\n-\/\/ positive. Disarm swings from (n) to (-n). Every completing waiter swings from (n)\n-\/\/ to (n+1), where \"n\" is guaranteed to stay negative. When all waiters complete,\n-\/\/ a cell ends up at \"-1\" again. This allows accurate tracking of how many signals\n+\/\/ with updates always done with CASes:\n+\/\/\n+\/\/   [.......... barrier tag ..........][.......... waiters ..........]\n+\/\/  63                                  31                            0\n+\/\/\n+\/\/ Cell starts with zero tag and zero waiters. Arming the cell swings barrier tag from\n+\/\/ zero to some tag, while checking that no waiters have appeared. Disarming swings\n+\/\/ the barrier tag back from tag to zero. Every waiter registers itself by incrementing\n+\/\/ the \"waiters\", while checking that barrier tag is still the same. Every completing waiter\n+\/\/ decrements the \"waiters\". When all waiters complete, a cell ends up in initial state,\n+\/\/ ready to be armed again. This allows accurate tracking of how many signals\n@@ -85,1 +89,1 @@\n-  cell.arm();\n+  cell.arm(barrier_tag);\n@@ -92,2 +96,2 @@\n-  int tag = Atomic::load_acquire(&_barrier_tag);\n-  assert(tag != 0, \"Pre disarm: Should be armed. Tag: %d\", tag);\n+  int barrier_tag = Atomic::load_acquire(&_barrier_tag);\n+  assert(barrier_tag != 0, \"Pre disarm: Should be armed. Tag: %d\", barrier_tag);\n@@ -96,2 +100,2 @@\n-  Cell &cell = tag_to_cell(tag);\n-  cell.disarm();\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.disarm(barrier_tag);\n@@ -107,1 +111,1 @@\n-  cell.wait();\n+  cell.wait(barrier_tag);\n@@ -113,3 +117,1 @@\n-void GenericWaitBarrier::Cell::arm() {\n-  assert(Atomic::load_acquire(&_state) < 0, \"Pre arm: should be disarmed\");\n-\n+void GenericWaitBarrier::Cell::arm(int32_t requested_tag) {\n@@ -117,1 +119,4 @@\n-  \/\/ have left the previous cell. This means the cell state has rolled to -1.\n+  \/\/ have left the previous cell.\n+\n+  int64_t state;\n+\n@@ -119,1 +124,9 @@\n-  while (Atomic::load_acquire(&_state) < -1) {\n+  while (true) {\n+    state = Atomic::load_acquire(&_state);\n+    assert(decode_tag(state) == 0,\n+           \"Pre arm: Should not be armed. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           decode_tag(state), decode_waiters(state));\n+    if (decode_waiters(state) == 0) {\n+      break;\n+    }\n@@ -124,3 +137,6 @@\n-  int ps = Atomic::cmpxchg(&_state, -1, 1);\n-  if (ps != -1) {\n-    fatal(\"Mid arm: Cannot arm the wait barrier. State: %d\", ps);\n+  int64_t new_state = encode(requested_tag, 0);\n+  int64_t prev_state = Atomic::cmpxchg(&_state, state, new_state);\n+  if (prev_state != state) {\n+    fatal(\"Cannot arm the wait barrier. \"\n+          \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+          decode_tag(prev_state), decode_waiters(prev_state));\n@@ -128,2 +144,0 @@\n-\n-  assert(Atomic::load(&_state) > 0, \"Post arm: should be armed\");\n@@ -132,2 +146,2 @@\n-int GenericWaitBarrier::Cell::wake_if_needed(int max) {\n-  int wakeups = 0;\n+int GenericWaitBarrier::Cell::signal_if_needed(int max) {\n+  int signals = 0;\n@@ -151,2 +165,2 @@\n-    if (wakeups++ > max) {\n-      \/\/ Over the wakeup limit, break out.\n+    if (++signals >= max) {\n+      \/\/ Signalled requested number of times, break out.\n@@ -158,1 +172,3 @@\n-void GenericWaitBarrier::Cell::disarm() {\n+void GenericWaitBarrier::Cell::disarm(int32_t expected_tag) {\n+  int32_t waiters;\n+\n@@ -161,12 +177,12 @@\n-    int s = Atomic::load_acquire(&_state);\n-    assert(s > 0, \"Mid disarm: Should be armed. State: %d\", s);\n-    if (Atomic::cmpxchg(&_state, s, -s) == s) {\n-      \/\/ Successfully disarmed. Wake up waiters, if we have at least one.\n-      \/\/ Allow other threads to assist with wakeups, if possible.\n-      int waiters = s - 1;\n-      if (waiters > 0) {\n-        Atomic::release_store(&_outstanding_wakeups, waiters);\n-        while (wake_if_needed(INT_MAX) > 0) {\n-          sp.wait();\n-        }\n-      }\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0),\n+           \"Mid disarm: Should be armed with expected tag and have sane waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(0, waiters);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Successfully disarmed.\n@@ -178,0 +194,8 @@\n+  \/\/ Wake up waiters, if we have at least one.\n+  \/\/ Allow other threads to assist with wakeups, if possible.\n+  if (waiters > 0) {\n+    Atomic::release_store(&_outstanding_wakeups, waiters);\n+    while (signal_if_needed(INT_MAX) > 0) {\n+      sp.wait();\n+    }\n+  }\n@@ -179,1 +203,0 @@\n-  assert(Atomic::load(&_state) < 0, \"Post disarm: Should be disarmed\");\n@@ -182,12 +205,23 @@\n-void GenericWaitBarrier::Cell::wait() {\n-  \/\/ Try to register ourselves as pending waiter. If we got disarmed while\n-  \/\/ trying to register, return immediately.\n-  {\n-    int s;\n-    do {\n-      s = Atomic::load_acquire(&_state);\n-      if (s < 0) {\n-        return;\n-      }\n-      assert(s > 0, \"Before wait: Should be armed. State: %d\", s);\n-    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n+void GenericWaitBarrier::Cell::wait(int32_t expected_tag) {\n+  \/\/ Try to register ourselves as pending waiter.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    if (tag != expected_tag) {\n+      \/\/ Cell tag had changed while waiting here. This means either the cell had\n+      \/\/ been disarmed, or we are late and the cell was armed with a new tag.\n+      \/\/ Exit without touching anything else.\n+      return;\n+    }\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0 && waiters < INT32_MAX),\n+           \"Before wait: Should be armed with expected tag and waiters are in range. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters + 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success! Proceed to wait.\n+      break;\n+    }\n@@ -205,1 +239,1 @@\n-  wake_if_needed(2);\n+  signal_if_needed(2);\n@@ -208,6 +242,15 @@\n-  {\n-    int s;\n-    do {\n-      s = Atomic::load_acquire(&_state);\n-      assert(s < -1, \"After wait: Should be disarmed and have returning waiters. State: %d\", s);\n-    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == 0) && (waiters > 0),\n+           \"After wait: Should be not armed and have non-complete waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters - 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success!\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":103,"deletions":60,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -41,5 +41,2 @@\n-    \/\/ Cell state, tracks the arming + waiter status\n-    \/\/   <= -1: disarmed, have abs(n)-1 unreported waiters\n-    \/\/       0: forbidden value\n-    \/\/   >=  1: armed, have abs(n)-1 waiters\n-    volatile int _state;\n+    \/\/ Cell state, tracks the arming + waiters status\n+    volatile int64_t _state;\n@@ -52,1 +49,17 @@\n-    int wake_if_needed(int max);\n+    int signal_if_needed(int max);\n+\n+    static int64_t encode(int32_t barrier_tag, int32_t waiters) {\n+      int64_t val = (((int64_t) barrier_tag) << 32) |\n+                    (((int64_t) waiters) & 0xFFFFFFFF);\n+      assert(decode_tag(val) == barrier_tag, \"Encoding is reversible\");\n+      assert(decode_waiters(val) == waiters, \"Encoding is reversible\");\n+      return val;\n+    }\n+\n+    static int32_t decode_tag(int64_t value) {\n+      return (int32_t)(value >> 32);\n+    }\n+\n+    static int32_t decode_waiters(int64_t value) {\n+      return (int32_t)(value & 0xFFFFFFFF);\n+    }\n@@ -55,1 +68,1 @@\n-    Cell() : _sem(0), _state(-1), _outstanding_wakeups(0) {}\n+    Cell() : _sem(0), _state(encode(0, 0)), _outstanding_wakeups(0) {}\n@@ -58,3 +71,3 @@\n-    void arm();\n-    void disarm();\n-    void wait();\n+    void arm(int32_t requested_tag);\n+    void disarm(int32_t expected_tag);\n+    void wait(int32_t expected_tag);\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"}]}