{"files":[{"patch":"@@ -34,4 +34,1 @@\n-#if defined(LINUX)\n-#include \"waitBarrier_linux.hpp\"\n-typedef LinuxWaitBarrier WaitBarrierDefault;\n-#else\n+\/\/ FIXME: Replaced for testing on all platforms, revert before integration\n@@ -39,1 +36,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,44 @@\n+\/\/ Implements the striped semaphore wait barrier.\n+\/\/\n+\/\/ To guarantee progress and safety, we need to make sure that new barrier tag\n+\/\/ starts with the completely empty set of waiters and free semaphore. This\n+\/\/ requires either waiting for all threads to leave wait() for current barrier\n+\/\/ tag on disarm(), or waiting for all threads to leave the previous tag before\n+\/\/ reusing the semaphore in arm().\n+\/\/\n+\/\/ When there are multiple threads, it is normal for some threads to take\n+\/\/ significant time to leave the barrier. Waiting for these threads introduces\n+\/\/ stalls on barrier reuse.\n+\/\/\n+\/\/ If we wait on disarm(), this stall is nearly guaranteed to happen if some threads\n+\/\/ are de-scheduled by prior wait(). It would be especially bad if there are more\n+\/\/ waiting threads than CPUs: every thread would need to wake up and register itself\n+\/\/ as leaving, before we can unblock from disarm().\n+\/\/\n+\/\/ If we wait on arm(), we can get lucky that most threads would be able to catch up,\n+\/\/ exit wait(), and so we arrive to arm() with semaphore ready for reuse. However,\n+\/\/ that is still insufficient in practice.\n+\/\/\n+\/\/ Therefore, this implementation goes a step further and implements the _striped_\n+\/\/ semaphores. We maintain several semaphores in cells. The barrier tags are assigned\n+\/\/ to cells in some simple manner. Most of the current uses have sequential barrier\n+\/\/ tags, so simple modulo works well. We then operate on a cell like we would operate\n+\/\/ on a single semaphore: we wait at arm() for all threads to catch up before reusing\n+\/\/ the cell. For the cost of maintaining just a few cells, we have enough window for\n+\/\/ threads to catch up.\n+\/\/\n+\/\/ The correctness is guaranteed by using a single atomic state variable per cell,\n+\/\/ with updates always done with CASes. For the cell state, positive values mean\n+\/\/ the cell is armed and maybe has waiters. Negative values mean the cell is disarmed\n+\/\/ and maybe has completing waiters. The cell starts with \"-1\". Arming a cell swings\n+\/\/ from \"-1\" to \"+1\". Every new waiter swings from (n) to (n+1), as long as \"n\" is\n+\/\/ positive. Disarm swings from (n) to (-n). Every completing waiter swings from (n)\n+\/\/ to (n+1), where \"n\" is guaranteed to stay negative. When all waiters complete,\n+\/\/ a cell ends up at \"-1\" again. This allows accurate tracking of how many signals\n+\/\/ to issue and does not race with disarm.\n+\/\/\n+\/\/ The implementation uses the strongest (default) barriers for extra safety, even\n+\/\/ when not strictly required to do so for correctness. Extra barrier overhead is\n+\/\/ dominated by the actual wait\/notify latency anyway.\n+\/\/\n+\n@@ -33,4 +78,22 @@\n-  assert(_barrier_tag == 0, \"Already armed\");\n-  assert(_waiters == 0, \"We left a thread hanging\");\n-  _barrier_tag = barrier_tag;\n-  _waiters = 0;\n+  assert(barrier_tag != 0, \"Pre arm: Should be arming with armed value\");\n+  assert(Atomic::load(&_barrier_tag) == 0,\n+         \"Pre arm: Should not be already armed. Tag: %d\",\n+         Atomic::load(&_barrier_tag));\n+  Atomic::release_store(&_barrier_tag, barrier_tag);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.arm();\n+\n+  \/\/ API specifies arm() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n+\n+void GenericWaitBarrier::disarm() {\n+  int tag = Atomic::load_acquire(&_barrier_tag);\n+  assert(tag != 0, \"Pre disarm: Should be armed. Tag: %d\", tag);\n+  Atomic::release_store(&_barrier_tag, 0);\n+\n+  Cell &cell = tag_to_cell(tag);\n+  cell.disarm();\n+\n+  \/\/ API specifies disarm() must provide a trailing fence.\n@@ -40,7 +103,18 @@\n-int GenericWaitBarrier::wake_if_needed() {\n-  assert(_barrier_tag == 0, \"Not disarmed\");\n-  int w = _waiters;\n-  if (w == 0) {\n-    \/\/ Load of _barrier_threads in caller must not pass the load of _waiters.\n-    OrderAccess::loadload();\n-    return 0;\n+void GenericWaitBarrier::wait(int barrier_tag) {\n+  assert(barrier_tag != 0, \"Pre wait: Should be waiting on armed value\");\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.wait();\n+\n+  \/\/ API specifies wait() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n+\n+void GenericWaitBarrier::Cell::arm() {\n+  assert(Atomic::load_acquire(&_state) < 0, \"Pre arm: should be disarmed\");\n+\n+  \/\/ Before we continue to arm, we need to make sure that all threads\n+  \/\/ have left the previous cell. This means the cell state has rolled to -1.\n+  SpinYield sp;\n+  while (Atomic::load_acquire(&_state) < -1) {\n+    sp.wait();\n@@ -48,6 +122,5 @@\n-  assert(w > 0, \"Bad counting\");\n-  \/\/ We need an exact count which never goes below zero,\n-  \/\/ otherwise the semaphore may be signalled too many times.\n-  if (Atomic::cmpxchg(&_waiters, w, w - 1) == w) {\n-    _sem_barrier.signal();\n-    return w - 1;\n+\n+  \/\/ Try to swing cell to armed. This should always succeed after the check above.\n+  int ps = Atomic::cmpxchg(&_state, -1, 1);\n+  if (ps != -1) {\n+    fatal(\"Mid arm: Cannot arm the wait barrier. State: %d\", ps);\n@@ -55,1 +128,2 @@\n-  return w;\n+\n+  assert(Atomic::load(&_state) > 0, \"Post arm: should be armed\");\n@@ -58,7 +132,27 @@\n-void GenericWaitBarrier::disarm() {\n-  assert(_barrier_tag != 0, \"Not armed\");\n-  _barrier_tag = 0;\n-  \/\/ Loads of _barrier_threads\/_waiters must not float above disarm store and\n-  \/\/ disarm store must not sink below.\n-  OrderAccess::fence();\n-  int left;\n+int GenericWaitBarrier::Cell::wake_if_needed(int max) {\n+  int wakeups = 0;\n+  while (true) {\n+    int cur = Atomic::load_acquire(&_outstanding_wakeups);\n+    if (cur == 0) {\n+      \/\/ All done, no more waiters.\n+      return 0;\n+    }\n+    assert(cur > 0, \"Sanity\");\n+\n+    int prev = Atomic::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n+    if (prev != cur) {\n+      \/\/ Contention, return to caller for early return or backoff.\n+      return prev;\n+    }\n+\n+    \/\/ Signal!\n+    _sem.signal();\n+\n+    if (wakeups++ > max) {\n+      \/\/ Over the wakeup limit, break out.\n+      return prev;\n+    }\n+  }\n+}\n+\n+void GenericWaitBarrier::Cell::disarm() {\n@@ -66,5 +160,14 @@\n-  do {\n-    left = GenericWaitBarrier::wake_if_needed();\n-    if (left == 0 && _barrier_threads > 0) {\n-      \/\/ There is no thread to wake but we still have barrier threads.\n-      sp.wait();\n+  while (true) {\n+    int s = Atomic::load_acquire(&_state);\n+    assert(s > 0, \"Mid disarm: Should be armed. State: %d\", s);\n+    if (Atomic::cmpxchg(&_state, s, -s) == s) {\n+      \/\/ Successfully disarmed. Wake up waiters, if we have at least one.\n+      \/\/ Allow other threads to assist with wakeups, if possible.\n+      int waiters = s - 1;\n+      if (waiters > 0) {\n+        Atomic::release_store(&_outstanding_wakeups, waiters);\n+        while (wake_if_needed(INT_MAX) > 0) {\n+          sp.wait();\n+        }\n+      }\n+      break;\n@@ -72,4 +175,5 @@\n-    \/\/ We must loop here until there are no waiters or potential waiters.\n-  } while (left > 0 || _barrier_threads > 0);\n-  \/\/ API specifies disarm() must provide a trailing fence.\n-  OrderAccess::fence();\n+    sp.wait();\n+  }\n+\n+  assert(Atomic::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n+  assert(Atomic::load(&_state) < 0, \"Post disarm: Should be disarmed\");\n@@ -78,6 +182,12 @@\n-void GenericWaitBarrier::wait(int barrier_tag) {\n-  assert(barrier_tag != 0, \"Trying to wait on disarmed value\");\n-  if (barrier_tag != _barrier_tag) {\n-    \/\/ API specifies wait() must provide a trailing fence.\n-    OrderAccess::fence();\n-    return;\n+void GenericWaitBarrier::Cell::wait() {\n+  \/\/ Try to register ourselves as pending waiter. If we got disarmed while\n+  \/\/ trying to register, return immediately.\n+  {\n+    int s;\n+    do {\n+      s = Atomic::load_acquire(&_state);\n+      if (s < 0) {\n+        return;\n+      }\n+      assert(s > 0, \"Before wait: Should be armed. State: %d\", s);\n+    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n@@ -85,7 +195,19 @@\n-  Atomic::add(&_barrier_threads, 1);\n-  if (barrier_tag != 0 && barrier_tag == _barrier_tag) {\n-    Atomic::add(&_waiters, 1);\n-    _sem_barrier.wait();\n-    \/\/ We help out with posting, but we need to do so before we decrement the\n-    \/\/ _barrier_threads otherwise we might wake threads up in next wait.\n-    GenericWaitBarrier::wake_if_needed();\n+\n+  \/\/ Wait for notification.\n+  _sem.wait();\n+\n+  \/\/ Unblocked! We help out with waking up two siblings. This allows to avalanche\n+  \/\/ the wakeups for many threads, even if some threads are lagging behind.\n+  \/\/ Note that we can only do this *before* reporting back as completed waiter,\n+  \/\/ otherwise we might prematurely wake up threads for another barrier tag.\n+  \/\/ Current arm() sequence protects us from this trouble by waiting until all waiters\n+  \/\/ leave.\n+  wake_if_needed(2);\n+\n+  \/\/ Register ourselves as completed waiter before leaving.\n+  {\n+    int s;\n+    do {\n+      s = Atomic::load_acquire(&_state);\n+      assert(s < -1, \"After wait: Should be disarmed and have returning waiters. State: %d\", s);\n+    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n@@ -93,1 +215,0 @@\n-  Atomic::add(&_barrier_threads, -1);\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":170,"deletions":49,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/padded.hpp\"\n@@ -32,2 +33,0 @@\n-\/\/ In addition to the barrier tag, it uses two counters to keep the semaphore\n-\/\/ count correct and not leave any late thread waiting.\n@@ -35,0 +34,35 @@\n+private:\n+  class Cell : public CHeapObj<mtInternal> {\n+  private:\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n+    Semaphore _sem;\n+\n+    \/\/ Cell state, tracks the arming + waiter status\n+    \/\/   <= -1: disarmed, have abs(n)-1 unreported waiters\n+    \/\/       0: forbidden value\n+    \/\/   >=  1: armed, have abs(n)-1 waiters\n+    volatile int _state;\n+\n+    \/\/ Wakeups to deliver for current waiters\n+    volatile int _outstanding_wakeups;\n+\n+    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n+    int wake_if_needed(int max);\n+\n+  public:\n+    Cell() : _sem(0), _state(-1), _outstanding_wakeups(0) {}\n+    NONCOPYABLE(Cell);\n+\n+    void arm();\n+    void disarm();\n+    void wait();\n+  };\n+\n+  \/\/ Should be enough for most uses without exploding the footprint.\n+  static constexpr int CELLS_COUNT = 16;\n+\n+  Cell _cells[CELLS_COUNT];\n+  Cell& tag_to_cell(int tag) { return _cells[tag & (CELLS_COUNT - 1)]; }\n+\n@@ -36,6 +70,0 @@\n-  \/\/ The number of threads waiting on or about to wait on the semaphore.\n-  volatile int _waiters;\n-  \/\/ The number of threads in the wait path, before or after the tag check.\n-  \/\/ These threads can become waiters.\n-  volatile int _barrier_threads;\n-  Semaphore _sem_barrier;\n@@ -45,4 +73,2 @@\n-  int wake_if_needed();\n-\n- public:\n-  GenericWaitBarrier() : _barrier_tag(0), _waiters(0), _barrier_threads(0), _sem_barrier(0) {}\n+public:\n+  GenericWaitBarrier() : _cells(), _barrier_tag(0) {}\n@@ -51,1 +77,1 @@\n-  const char* description() { return \"semaphore\"; }\n+  const char* description() { return \"striped semaphore\"; }\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"}]}