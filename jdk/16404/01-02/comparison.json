{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -34,4 +35,1 @@\n-\/\/ In addition to the barrier tag, it uses two counters to keep the semaphore\n-\/\/ count correct and not leave any late thread waiting.\n-\/\/\n-\/\/ To guarantee progress and safety, we should make sure that new barrier tag\n+\/\/ To guarantee progress and safety, we need to make sure that new barrier tag\n@@ -45,4 +43,6 @@\n-\/\/ stalls on barrier reuse. If wait on disarm(), this stall is nearly guaranteed\n-\/\/ to happen if some threads are stalled. If we wait on arm(), we can get lucky\n-\/\/ that most threads would be able to catch up, exit wait(), and so we arrive\n-\/\/ to arm() with semaphore ready for reuse.\n+\/\/ stalls on barrier reuse.\n+\/\/\n+\/\/ If we wait on disarm(), this stall is nearly guaranteed to happen if some threads\n+\/\/ are de-scheduled by prior wait(). It would be especially bad if there are more\n+\/\/ waiting threads than CPUs: every thread would need to wake up and register itself\n+\/\/ as leaving, before we can unblock from disarm().\n@@ -50,3 +50,6 @@\n-\/\/ However, that is insufficient in practice. Therefore, this implementation goes\n-\/\/ a step further and implements the _striped_ semaphores. We maintain several\n-\/\/ semaphores (along with aux counters) in cells. The barrier tags are assigned\n+\/\/ If we wait on arm(), we can get lucky that most threads would be able to catch up,\n+\/\/ exit wait(), and so we arrive to arm() with semaphore ready for reuse. However,\n+\/\/ that is still insufficient in practice.\n+\/\/\n+\/\/ Therefore, this implementation goes a step further and implements the _striped_\n+\/\/ semaphores. We maintain several semaphores in cells. The barrier tags are assigned\n@@ -54,1 +57,4 @@\n-\/\/ tags, so simple modulo works well.\n+\/\/ tags, so simple modulo works well. We then operate on a cell like we would operate\n+\/\/ on a single semaphore: we wait at arm() for all threads to catch up before reusing\n+\/\/ the cell. For the cost of maintaining just a few cells, we have enough window for\n+\/\/ threads to catch up.\n@@ -56,4 +62,9 @@\n-\/\/ We then operate on a cell like we would operate on a single semaphore: we wait\n-\/\/ at arm() for all threads to catch up before reusing the cell, and only then use it.\n-\/\/ For the cost of maintaining just a few cells, we have enough window for threads\n-\/\/ to catch up.\n+\/\/ The correctness is guaranteed by using a single atomic state variable per cell,\n+\/\/ with updates always done with CASes. For the cell state, positive values mean\n+\/\/ the cell is armed and maybe has waiters. Negative values mean the cell is disarmed\n+\/\/ and maybe has completing waiters. The cell starts with \"-1\". Arming a cell swings\n+\/\/ from \"-1\" to \"+1\". Every new waiter swings from (n) to (n+1), as long as \"n\" is\n+\/\/ positive. Disarm swings from (n) to (-n). Every completing waiter swings from (n)\n+\/\/ to (n+1), where \"n\" is guaranteed to stay negative. When all waiters complete,\n+\/\/ a cell ends up at \"-1\" again. This allows accurate tracking of how many signals\n+\/\/ to issue and does not race with disarm.\n@@ -61,3 +72,3 @@\n-\/\/ For extra generality, the implementation uses the strongest barriers for extra safety,\n-\/\/ even when not strictly required to do so for correctness. Extra barrier overhead\n-\/\/ is dominated by the actual wait\/notify latency.\n+\/\/ The implementation uses the strongest (default) barriers for extra safety, even\n+\/\/ when not strictly required to do so for correctness. Extra barrier overhead is\n+\/\/ dominated by the actual wait\/notify latency anyway.\n@@ -67,2 +78,20 @@\n-  assert(barrier_tag != 0, \"Pre-condition: should be arming with armed value\");\n-  assert(Atomic::load(&_barrier_tag) == 0, \"Pre-condition: should not be already armed\");\n+  assert(barrier_tag != 0, \"Pre arm: Should be arming with armed value\");\n+  assert(Atomic::load(&_barrier_tag) == 0,\n+         \"Pre arm: Should not be already armed. Tag: %d\",\n+         Atomic::load(&_barrier_tag));\n+  Atomic::release_store(&_barrier_tag, barrier_tag);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.arm();\n+\n+  \/\/ API specifies arm() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n+\n+void GenericWaitBarrier::disarm() {\n+  int tag = Atomic::load_acquire(&_barrier_tag);\n+  assert(tag != 0, \"Pre disarm: Should be armed. Tag: %d\", tag);\n+  Atomic::release_store(&_barrier_tag, 0);\n+\n+  Cell &cell = tag_to_cell(tag);\n+  cell.disarm();\n@@ -70,1 +99,3 @@\n-  Cell& cell = tag_to_cell(barrier_tag);\n+  \/\/ API specifies disarm() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n@@ -72,2 +103,9 @@\n-  \/\/ Prepare target cell for arming.\n-  \/\/ New waiters would still return immediately until barrier is fully armed.\n+void GenericWaitBarrier::wait(int barrier_tag) {\n+  assert(barrier_tag != 0, \"Pre wait: Should be waiting on armed value\");\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.wait();\n+\n+  \/\/ API specifies wait() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n@@ -75,1 +113,2 @@\n-  assert(Atomic::load(&cell._unsignaled_waits) == 0, \"Pre-condition: no unsignaled waits\");\n+void GenericWaitBarrier::Cell::arm() {\n+  assert(Atomic::load_acquire(&_state) < 0, \"Pre arm: should be disarmed\");\n@@ -78,1 +117,1 @@\n-  \/\/ have left the previous cell. This allows reusing the cell.\n+  \/\/ have left the previous cell. This means the cell state has rolled to -1.\n@@ -80,2 +119,1 @@\n-  while (Atomic::load_acquire(&cell._wait_threads) > 0) {\n-    assert(Atomic::load(&cell._unsignaled_waits) == 0, \"Lifecycle sanity: no new waiters\");\n+  while (Atomic::load_acquire(&_state) < -1) {\n@@ -85,6 +123,7 @@\n-  \/\/ Announce the barrier is ready to accept waiters.\n-  \/\/ Make sure accesses to barrier tag are fully ordered.\n-  \/\/ API specifies arm() must provide a trailing fence.\n-  OrderAccess::fence();\n-  Atomic::release_store(&_barrier_tag, barrier_tag);\n-  OrderAccess::fence();\n+  \/\/ Try to swing cell to armed. This should always succeed after the check above.\n+  int ps = Atomic::cmpxchg(&_state, -1, 1);\n+  if (ps != -1) {\n+    fatal(\"Mid arm: Cannot arm the wait barrier. State: %d\", ps);\n+  }\n+\n+  assert(Atomic::load(&_state) > 0, \"Post arm: should be armed\");\n@@ -94,4 +133,0 @@\n-  \/\/ Match the signal counts with the number of unsignaled waits.\n-  \/\/ This would allow semaphore to be reused after we are done with it in\n-  \/\/ this arm-wait-disarm cycle.\n-\n@@ -100,1 +135,1 @@\n-    int cur = Atomic::load_acquire(&_unsignaled_waits);\n+    int cur = Atomic::load_acquire(&_outstanding_wakeups);\n@@ -107,1 +142,1 @@\n-    int prev = Atomic::cmpxchg(&_unsignaled_waits, cur, cur - 1);\n+    int prev = Atomic::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n@@ -109,1 +144,1 @@\n-      \/\/ Contention! Return to caller for early return or backoff.\n+      \/\/ Contention, return to caller for early return or backoff.\n@@ -114,1 +149,1 @@\n-    _sem_barrier.signal();\n+    _sem.signal();\n@@ -123,13 +158,1 @@\n-void GenericWaitBarrier::disarm() {\n-  int tag = Atomic::load_acquire(&_barrier_tag);\n-  assert(tag != 0, \"Pre-condition: should be armed\");\n-\n-  \/\/ Announce the barrier is disarmed. New waiters would start to return immediately.\n-  \/\/ Make sure accesses to barrier tag are fully ordered.\n-  OrderAccess::fence();\n-  Atomic::release_store(&_barrier_tag, 0);\n-  OrderAccess::fence();\n-\n-  Cell& cell = tag_to_cell(tag);\n-\n-  \/\/ Wake up all current waiters.\n+void GenericWaitBarrier::Cell::disarm() {\n@@ -137,1 +160,15 @@\n-  while (cell.wake_if_needed(INT_MAX) > 0) {\n+  while (true) {\n+    int s = Atomic::load_acquire(&_state);\n+    assert(s > 0, \"Mid disarm: Should be armed. State: %d\", s);\n+    if (Atomic::cmpxchg(&_state, s, -s) == s) {\n+      \/\/ Successfully disarmed. Wake up waiters, if we have at least one.\n+      \/\/ Allow other threads to assist with wakeups, if possible.\n+      int waiters = s - 1;\n+      if (waiters > 0) {\n+        Atomic::release_store(&_outstanding_wakeups, waiters);\n+        while (wake_if_needed(INT_MAX) > 0) {\n+          sp.wait();\n+        }\n+      }\n+      break;\n+    }\n@@ -141,4 +178,2 @@\n-  \/\/ API specifies disarm() must provide a trailing fence.\n-  OrderAccess::fence();\n-\n-  assert(Atomic::load(&cell._unsignaled_waits) == 0, \"Post-condition: no unsignaled waits\");\n+  assert(Atomic::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n+  assert(Atomic::load(&_state) < 0, \"Post disarm: Should be disarmed\");\n@@ -147,9 +182,12 @@\n-void GenericWaitBarrier::wait(int barrier_tag) {\n-  assert(barrier_tag != 0, \"Pre-condition: should be waiting on armed value\");\n-\n-  if (Atomic::load_acquire(&_barrier_tag) != barrier_tag) {\n-    \/\/ Not our current barrier at all, return right away without touching\n-    \/\/ anything. Chances are we catching up with disarm() disarming right now.\n-    \/\/ API specifies wait() must provide a trailing fence.\n-    OrderAccess::fence();\n-    return;\n+void GenericWaitBarrier::Cell::wait() {\n+  \/\/ Try to register ourselves as pending waiter. If we got disarmed while\n+  \/\/ trying to register, return immediately.\n+  {\n+    int s;\n+    do {\n+      s = Atomic::load_acquire(&_state);\n+      if (s < 0) {\n+        return;\n+      }\n+      assert(s > 0, \"Before wait: Should be armed. State: %d\", s);\n+    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n@@ -158,30 +196,18 @@\n-  Cell& cell = tag_to_cell(barrier_tag);\n-\n-  Atomic::add(&cell._wait_threads, 1);\n-\n-  \/\/ There is a subtle race against disarming code.\n-  \/\/\n-  \/\/ Disarming first lowers the actual barrier tag, and then proceeds to signal\n-  \/\/ threads. If we resume here after disarm() signaled all current waiters, we\n-  \/\/ might go into the wait without a matching signal, and be stuck indefinitely.\n-  \/\/ To avoid this, we check the expected barrier tag right here.\n-  \/\/\n-  \/\/ Note that we have to do this check *after* incrementing _wait_threads. Otherwise,\n-  \/\/ the disarming code might not notice that we are about to wait, and not deliver\n-  \/\/ additional signal to wake us up. (This is a Dekker-like step in disguise.)\n-\n-  \/\/ Make sure accesses to barrier tag are fully ordered.\n-  OrderAccess::fence();\n-\n-  if (Atomic::load_acquire(&_barrier_tag) == barrier_tag) {\n-    Atomic::add(&cell._unsignaled_waits, 1);\n-\n-    \/\/ Wait for notification.\n-    cell._sem_barrier.wait();\n-\n-    \/\/ Unblocked! We help out with waking up two siblings. This allows to avalanche\n-    \/\/ the wakeups for many threads, even if some threads are lagging behind.\n-    \/\/ Note that we can only do this *before* decrementing _wait_threads, otherwise\n-    \/\/ we might prematurely wake up threads for another barrier tag. Current arm()\n-    \/\/ sequence protects us from this trouble by waiting until all waiters leave.\n-    cell.wake_if_needed(2);\n+  \/\/ Wait for notification.\n+  _sem.wait();\n+\n+  \/\/ Unblocked! We help out with waking up two siblings. This allows to avalanche\n+  \/\/ the wakeups for many threads, even if some threads are lagging behind.\n+  \/\/ Note that we can only do this *before* reporting back as completed waiter,\n+  \/\/ otherwise we might prematurely wake up threads for another barrier tag.\n+  \/\/ Current arm() sequence protects us from this trouble by waiting until all waiters\n+  \/\/ leave.\n+  wake_if_needed(2);\n+\n+  \/\/ Register ourselves as completed waiter before leaving.\n+  {\n+    int s;\n+    do {\n+      s = Atomic::load_acquire(&_state);\n+      assert(s < -1, \"After wait: Should be disarmed and have returning waiters. State: %d\", s);\n+    } while (Atomic::cmpxchg(&_state, s, s + 1) != s);\n@@ -189,5 +215,0 @@\n-\n-  Atomic::sub(&cell._wait_threads, 1);\n-\n-  \/\/ API specifies wait() must provide a trailing fence.\n-  OrderAccess::fence();\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":126,"deletions":105,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-    friend GenericWaitBarrier;\n@@ -40,1 +39,1 @@\n-    Semaphore _sem_barrier;\n+    Semaphore _sem;\n@@ -42,2 +41,5 @@\n-    \/\/ The number of threads in the wait path.\n-    volatile int _wait_threads;\n+    \/\/ Cell state, tracks the arming + waiter status\n+    \/\/   <= -1: disarmed, have abs(n)-1 unreported waiters\n+    \/\/       0: forbidden value\n+    \/\/   >=  1: armed, have abs(n)-1 waiters\n+    volatile int _state;\n@@ -45,2 +47,2 @@\n-    \/\/ The number of waits that need to be signalled.\n-    volatile int _unsignaled_waits;\n+    \/\/ Wakeups to deliver for current waiters\n+    volatile int _outstanding_wakeups;\n@@ -50,0 +52,2 @@\n+    int wake_if_needed(int max);\n+\n@@ -51,1 +55,1 @@\n-    Cell() : _sem_barrier(0), _wait_threads(0), _unsignaled_waits(0) {}\n+    Cell() : _sem(0), _state(-1), _outstanding_wakeups(0) {}\n@@ -54,1 +58,3 @@\n-    int wake_if_needed(int max);\n+    void arm();\n+    void disarm();\n+    void wait();\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"}]}