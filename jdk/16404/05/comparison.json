{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,48 @@\n+\/\/ Implements the striped semaphore wait barrier.\n+\/\/\n+\/\/ To guarantee progress and safety, we need to make sure that new barrier tag\n+\/\/ starts with the completely empty set of waiters and free semaphore. This\n+\/\/ requires either waiting for all threads to leave wait() for current barrier\n+\/\/ tag on disarm(), or waiting for all threads to leave the previous tag before\n+\/\/ reusing the semaphore in arm().\n+\/\/\n+\/\/ When there are multiple threads, it is normal for some threads to take\n+\/\/ significant time to leave the barrier. Waiting for these threads introduces\n+\/\/ stalls on barrier reuse.\n+\/\/\n+\/\/ If we wait on disarm(), this stall is nearly guaranteed to happen if some threads\n+\/\/ are de-scheduled by prior wait(). It would be especially bad if there are more\n+\/\/ waiting threads than CPUs: every thread would need to wake up and register itself\n+\/\/ as leaving, before we can unblock from disarm().\n+\/\/\n+\/\/ If we wait on arm(), we can get lucky that most threads would be able to catch up,\n+\/\/ exit wait(), and so we arrive to arm() with semaphore ready for reuse. However,\n+\/\/ that is still insufficient in practice.\n+\/\/\n+\/\/ Therefore, this implementation goes a step further and implements the _striped_\n+\/\/ semaphores. We maintain several semaphores in cells. The barrier tags are assigned\n+\/\/ to cells in some simple manner. Most of the current uses have sequential barrier\n+\/\/ tags, so simple modulo works well. We then operate on a cell like we would operate\n+\/\/ on a single semaphore: we wait at arm() for all threads to catch up before reusing\n+\/\/ the cell. For the cost of maintaining just a few cells, we have enough window for\n+\/\/ threads to catch up.\n+\/\/\n+\/\/ The correctness is guaranteed by using a single atomic state variable per cell,\n+\/\/ with updates always done with CASes:\n+\/\/\n+\/\/   [.......... barrier tag ..........][.......... waiters ..........]\n+\/\/  63                                  31                            0\n+\/\/\n+\/\/ Cell starts with zero tag and zero waiters. Arming the cell swings barrier tag from\n+\/\/ zero to some tag, while checking that no waiters have appeared. Disarming swings\n+\/\/ the barrier tag back from tag to zero. Every waiter registers itself by incrementing\n+\/\/ the \"waiters\", while checking that barrier tag is still the same. Every completing waiter\n+\/\/ decrements the \"waiters\". When all waiters complete, a cell ends up in initial state,\n+\/\/ ready to be armed again. This allows accurate tracking of how many signals\n+\/\/ to issue and does not race with disarm.\n+\/\/\n+\/\/ The implementation uses the strongest (default) barriers for extra safety, even\n+\/\/ when not strictly required to do so for correctness. Extra barrier overhead is\n+\/\/ dominated by the actual wait\/notify latency anyway.\n+\/\/\n+\n@@ -33,4 +82,32 @@\n-  assert(_barrier_tag == 0, \"Already armed\");\n-  assert(_waiters == 0, \"We left a thread hanging\");\n-  _barrier_tag = barrier_tag;\n-  _waiters = 0;\n+  assert(barrier_tag != 0, \"Pre arm: Should be arming with armed value\");\n+  assert(Atomic::load(&_barrier_tag) == 0,\n+         \"Pre arm: Should not be already armed. Tag: %d\",\n+         Atomic::load(&_barrier_tag));\n+  Atomic::release_store(&_barrier_tag, barrier_tag);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.arm(barrier_tag);\n+\n+  \/\/ API specifies arm() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n+\n+void GenericWaitBarrier::disarm() {\n+  int barrier_tag = Atomic::load_acquire(&_barrier_tag);\n+  assert(barrier_tag != 0, \"Pre disarm: Should be armed. Tag: %d\", barrier_tag);\n+  Atomic::release_store(&_barrier_tag, 0);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.disarm(barrier_tag);\n+\n+  \/\/ API specifies disarm() must provide a trailing fence.\n+  OrderAccess::fence();\n+}\n+\n+void GenericWaitBarrier::wait(int barrier_tag) {\n+  assert(barrier_tag != 0, \"Pre wait: Should be waiting on armed value\");\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.wait(barrier_tag);\n+\n+  \/\/ API specifies wait() must provide a trailing fence.\n@@ -40,7 +117,17 @@\n-int GenericWaitBarrier::wake_if_needed() {\n-  assert(_barrier_tag == 0, \"Not disarmed\");\n-  int w = _waiters;\n-  if (w == 0) {\n-    \/\/ Load of _barrier_threads in caller must not pass the load of _waiters.\n-    OrderAccess::loadload();\n-    return 0;\n+void GenericWaitBarrier::Cell::arm(int32_t requested_tag) {\n+  \/\/ Before we continue to arm, we need to make sure that all threads\n+  \/\/ have left the previous cell.\n+\n+  int64_t state;\n+\n+  SpinYield sp;\n+  while (true) {\n+    state = Atomic::load_acquire(&_state);\n+    assert(decode_tag(state) == 0,\n+           \"Pre arm: Should not be armed. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           decode_tag(state), decode_waiters(state));\n+    if (decode_waiters(state) == 0) {\n+      break;\n+    }\n+    sp.wait();\n@@ -48,6 +135,8 @@\n-  assert(w > 0, \"Bad counting\");\n-  \/\/ We need an exact count which never goes below zero,\n-  \/\/ otherwise the semaphore may be signalled too many times.\n-  if (Atomic::cmpxchg(&_waiters, w, w - 1) == w) {\n-    _sem_barrier.signal();\n-    return w - 1;\n+\n+  \/\/ Try to swing cell to armed. This should always succeed after the check above.\n+  int64_t new_state = encode(requested_tag, 0);\n+  int64_t prev_state = Atomic::cmpxchg(&_state, state, new_state);\n+  if (prev_state != state) {\n+    fatal(\"Cannot arm the wait barrier. \"\n+          \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+          decode_tag(prev_state), decode_waiters(prev_state));\n@@ -55,1 +144,0 @@\n-  return w;\n@@ -58,7 +146,29 @@\n-void GenericWaitBarrier::disarm() {\n-  assert(_barrier_tag != 0, \"Not armed\");\n-  _barrier_tag = 0;\n-  \/\/ Loads of _barrier_threads\/_waiters must not float above disarm store and\n-  \/\/ disarm store must not sink below.\n-  OrderAccess::fence();\n-  int left;\n+int GenericWaitBarrier::Cell::signal_if_needed(int max) {\n+  int signals = 0;\n+  while (true) {\n+    int cur = Atomic::load_acquire(&_outstanding_wakeups);\n+    if (cur == 0) {\n+      \/\/ All done, no more waiters.\n+      return 0;\n+    }\n+    assert(cur > 0, \"Sanity\");\n+\n+    int prev = Atomic::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n+    if (prev != cur) {\n+      \/\/ Contention, return to caller for early return or backoff.\n+      return prev;\n+    }\n+\n+    \/\/ Signal!\n+    _sem.signal();\n+\n+    if (++signals >= max) {\n+      \/\/ Signalled requested number of times, break out.\n+      return prev;\n+    }\n+  }\n+}\n+\n+void GenericWaitBarrier::Cell::disarm(int32_t expected_tag) {\n+  int32_t waiters;\n+\n@@ -66,4 +176,23 @@\n-  do {\n-    left = GenericWaitBarrier::wake_if_needed();\n-    if (left == 0 && _barrier_threads > 0) {\n-      \/\/ There is no thread to wake but we still have barrier threads.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0),\n+           \"Mid disarm: Should be armed with expected tag and have sane waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(0, waiters);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Successfully disarmed.\n+      break;\n+    }\n+    sp.wait();\n+  }\n+\n+  \/\/ Wake up waiters, if we have at least one.\n+  \/\/ Allow other threads to assist with wakeups, if possible.\n+  if (waiters > 0) {\n+    Atomic::release_store(&_outstanding_wakeups, waiters);\n+    while (signal_if_needed(INT_MAX) > 0) {\n@@ -72,4 +201,2 @@\n-    \/\/ We must loop here until there are no waiters or potential waiters.\n-  } while (left > 0 || _barrier_threads > 0);\n-  \/\/ API specifies disarm() must provide a trailing fence.\n-  OrderAccess::fence();\n+  }\n+  assert(Atomic::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n@@ -78,6 +205,23 @@\n-void GenericWaitBarrier::wait(int barrier_tag) {\n-  assert(barrier_tag != 0, \"Trying to wait on disarmed value\");\n-  if (barrier_tag != _barrier_tag) {\n-    \/\/ API specifies wait() must provide a trailing fence.\n-    OrderAccess::fence();\n-    return;\n+void GenericWaitBarrier::Cell::wait(int32_t expected_tag) {\n+  \/\/ Try to register ourselves as pending waiter.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    if (tag != expected_tag) {\n+      \/\/ Cell tag had changed while waiting here. This means either the cell had\n+      \/\/ been disarmed, or we are late and the cell was armed with a new tag.\n+      \/\/ Exit without touching anything else.\n+      return;\n+    }\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0 && waiters < INT32_MAX),\n+           \"Before wait: Should be armed with expected tag and waiters are in range. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters + 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success! Proceed to wait.\n+      break;\n+    }\n@@ -85,7 +229,28 @@\n-  Atomic::add(&_barrier_threads, 1);\n-  if (barrier_tag != 0 && barrier_tag == _barrier_tag) {\n-    Atomic::add(&_waiters, 1);\n-    _sem_barrier.wait();\n-    \/\/ We help out with posting, but we need to do so before we decrement the\n-    \/\/ _barrier_threads otherwise we might wake threads up in next wait.\n-    GenericWaitBarrier::wake_if_needed();\n+\n+  \/\/ Wait for notification.\n+  _sem.wait();\n+\n+  \/\/ Unblocked! We help out with waking up two siblings. This allows to avalanche\n+  \/\/ the wakeups for many threads, even if some threads are lagging behind.\n+  \/\/ Note that we can only do this *before* reporting back as completed waiter,\n+  \/\/ otherwise we might prematurely wake up threads for another barrier tag.\n+  \/\/ Current arm() sequence protects us from this trouble by waiting until all waiters\n+  \/\/ leave.\n+  signal_if_needed(2);\n+\n+  \/\/ Register ourselves as completed waiter before leaving.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == 0) && (waiters > 0),\n+           \"After wait: Should be not armed and have non-complete waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters - 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success!\n+      break;\n+    }\n@@ -93,1 +258,0 @@\n-  Atomic::add(&_barrier_threads, -1);\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":212,"deletions":48,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/padded.hpp\"\n@@ -32,2 +33,0 @@\n-\/\/ In addition to the barrier tag, it uses two counters to keep the semaphore\n-\/\/ count correct and not leave any late thread waiting.\n@@ -35,0 +34,52 @@\n+private:\n+  class Cell : public CHeapObj<mtInternal> {\n+  private:\n+    \/\/ Pad out the cells to avoid interference between the cells.\n+    \/\/ This would insulate from stalls when adjacent cells have returning\n+    \/\/ workers and contend over the cache line for current latency-critical\n+    \/\/ cell.\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n+    Semaphore _sem;\n+\n+    \/\/ Cell state, tracks the arming + waiters status\n+    volatile int64_t _state;\n+\n+    \/\/ Wakeups to deliver for current waiters\n+    volatile int _outstanding_wakeups;\n+\n+    int signal_if_needed(int max);\n+\n+    static int64_t encode(int32_t barrier_tag, int32_t waiters) {\n+      int64_t val = (((int64_t) barrier_tag) << 32) |\n+                    (((int64_t) waiters) & 0xFFFFFFFF);\n+      assert(decode_tag(val) == barrier_tag, \"Encoding is reversible\");\n+      assert(decode_waiters(val) == waiters, \"Encoding is reversible\");\n+      return val;\n+    }\n+\n+    static int32_t decode_tag(int64_t value) {\n+      return (int32_t)(value >> 32);\n+    }\n+\n+    static int32_t decode_waiters(int64_t value) {\n+      return (int32_t)(value & 0xFFFFFFFF);\n+    }\n+\n+  public:\n+    Cell() : _sem(0), _state(encode(0, 0)), _outstanding_wakeups(0) {}\n+    NONCOPYABLE(Cell);\n+\n+    void arm(int32_t requested_tag);\n+    void disarm(int32_t expected_tag);\n+    void wait(int32_t expected_tag);\n+  };\n+\n+  \/\/ Should be enough for most uses without exploding the footprint.\n+  static constexpr int CELLS_COUNT = 16;\n+\n+  Cell _cells[CELLS_COUNT];\n+\n+  \/\/ Trailing padding to protect the last cell.\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n@@ -36,6 +87,5 @@\n-  \/\/ The number of threads waiting on or about to wait on the semaphore.\n-  volatile int _waiters;\n-  \/\/ The number of threads in the wait path, before or after the tag check.\n-  \/\/ These threads can become waiters.\n-  volatile int _barrier_threads;\n-  Semaphore _sem_barrier;\n+\n+  \/\/ Trailing padding to insulate the rest of the barrier from adjacent\n+  \/\/ data structures. The leading padding is not needed, as cell padding\n+  \/\/ handles this for us.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n@@ -45,1 +95,1 @@\n-  int wake_if_needed();\n+  Cell& tag_to_cell(int tag) { return _cells[tag & (CELLS_COUNT - 1)]; }\n@@ -47,2 +97,2 @@\n- public:\n-  GenericWaitBarrier() : _barrier_tag(0), _waiters(0), _barrier_threads(0), _sem_barrier(0) {}\n+public:\n+  GenericWaitBarrier() : _cells(), _barrier_tag(0) {}\n@@ -51,1 +101,1 @@\n-  const char* description() { return \"semaphore\"; }\n+  const char* description() { return \"striped semaphore\"; }\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"}]}