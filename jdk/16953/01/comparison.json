{"files":[{"patch":"@@ -1989,1 +1989,1 @@\n-    case NEW :\n+    case NEW:\n@@ -1992,4 +1992,3 @@\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNING :\n-    case PARKING :\n+    case STARTED:\n+    case RUNNING:\n+    case PARKING:\n@@ -1997,1 +1996,3 @@\n-    case YIELDING :\n+    case UNPARKED:\n+    case YIELDING:\n+    case YIELDED:\n@@ -2000,2 +2001,2 @@\n-    case PARKED :\n-    case PINNED :\n+    case PARKED:\n+    case PINNED:\n@@ -2008,1 +2009,1 @@\n-    case TERMINATED :\n+    case TERMINATED:\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -526,8 +526,8 @@\n-    RUNNABLE      = 2,\n-    RUNNING       = 3,\n-    PARKING       = 4,\n-    PARKED        = 5,\n-    PINNED        = 6,\n-    TIMED_PARKING = 7,\n-    TIMED_PARKED  = 8,\n-    TIMED_PINNED  = 9,\n+    RUNNING       = 2,\n+    PARKING       = 3,\n+    PARKED        = 4,\n+    PINNED        = 5,\n+    TIMED_PARKING = 6,\n+    TIMED_PARKED  = 7,\n+    TIMED_PINNED  = 8,\n+    UNPARKED      = 9,\n@@ -535,0 +535,1 @@\n+    YIELDED       = 11,\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-     *   PARKED -> RUNNABLE        \/\/ unparked, schedule to continue\n+     *   PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n@@ -101,0 +101,1 @@\n+     * UNPARKED -> RUNNING         \/\/ continue execution after park\n@@ -105,1 +106,1 @@\n-     *  TIMED_PARKED -> RUNNABLE        \/\/ unparked, schedule to continue\n+     *  TIMED_PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n@@ -108,2 +109,0 @@\n-     * RUNNABLE -> RUNNING         \/\/ continue execution\n-     *\n@@ -111,2 +110,3 @@\n-     * YIELDING -> RUNNABLE        \/\/ yield successful\n-     * YIELDING -> RUNNING         \/\/ yield failed\n+     * YIELDING -> YIELDED         \/\/ cont.yield successful, may be scheduled to continue\n+     * YIELDING -> RUNNING         \/\/ cont.yield failed\n+     *  YIELDED -> RUNNING         \/\/ continue execution after Thread.yield\n@@ -116,7 +116,1 @@\n-    private static final int RUNNABLE = 2;     \/\/ runnable-unmounted\n-    private static final int RUNNING  = 3;     \/\/ runnable-mounted\n-\n-    \/\/ untimed parking\n-    private static final int PARKING  = 4;\n-    private static final int PARKED   = 5;     \/\/ unmounted\n-    private static final int PINNED   = 6;     \/\/ mounted\n+    private static final int RUNNING  = 2;     \/\/ runnable-mounted\n@@ -124,4 +118,8 @@\n-    \/\/ timed parking\n-    private static final int TIMED_PARKING = 7;\n-    private static final int TIMED_PARKED  = 8;\n-    private static final int TIMED_PINNED  = 9;\n+    \/\/ untimed and timed parking\n+    private static final int PARKING       = 3;\n+    private static final int PARKED        = 4;     \/\/ unmounted\n+    private static final int PINNED        = 5;     \/\/ mounted\n+    private static final int TIMED_PARKING = 6;\n+    private static final int TIMED_PARKED  = 7;     \/\/ unmounted\n+    private static final int TIMED_PINNED  = 8;     \/\/ mounted\n+    private static final int UNPARKED      = 9;     \/\/ unmounted but runnable\n@@ -129,1 +127,3 @@\n-    private static final int YIELDING   = 10;  \/\/ Thread.yield\n+    \/\/ Thread.yield\n+    private static final int YIELDING = 10;\n+    private static final int YIELDED  = 11;         \/\/ unmounted but runnable\n@@ -221,5 +221,9 @@\n-        if (initialState == STARTED && compareAndSetState(STARTED, RUNNING)) {\n-            \/\/ first run\n-        } else if (initialState == RUNNABLE && compareAndSetState(RUNNABLE, RUNNING)) {\n-            \/\/ consume parking permit\n-            setParkPermit(false);\n+        if (initialState == STARTED || initialState == UNPARKED || initialState == YIELDED) {\n+            \/\/ newly started or continue after parking\/blocking\/Thread.yield\n+            if (!compareAndSetState(initialState, RUNNING)) {\n+                return;\n+            }\n+            \/\/ consume parking permit when continuing after parking\n+            if (initialState == UNPARKED) {\n+                setParkPermit(false);\n+            }\n@@ -247,2 +251,1 @@\n-     * otherwise it will be pushed to a submission queue.\n-     *\n+     * otherwise it will be pushed to an external submission queue.\n@@ -261,1 +264,1 @@\n-     * Submits the runContinuation task to the scheduler with a lazy submit.\n+     * Submits the runContinuation task to given scheduler with a lazy submit.\n@@ -275,1 +278,1 @@\n-     * Submits the runContinuation task to the scheduler as an external submit.\n+     * Submits the runContinuation task to the given scheduler as an external submit.\n@@ -460,1 +463,1 @@\n-            if (parkPermit && compareAndSetState(newState, RUNNABLE)) {\n+            if (parkPermit && compareAndSetState(newState, UNPARKED)) {\n@@ -474,1 +477,1 @@\n-            setState(RUNNABLE);\n+            setState(YIELDED);\n@@ -621,1 +624,1 @@\n-            Future<?> unparker = scheduleUnpark(this::unpark, nanos);\n+            Future<?> unparker = scheduleUnpark(nanos);  \/\/ may throw OOME\n@@ -686,1 +689,1 @@\n-     * Schedule an unpark task to run after a given delay.\n+     * Schedule this virtual thread to be unparked after a given delay.\n@@ -689,1 +692,2 @@\n-    private Future<?> scheduleUnpark(Runnable unparker, long nanos) {\n+    private Future<?> scheduleUnpark(long nanos) {\n+        assert Thread.currentThread() == this;\n@@ -693,1 +697,1 @@\n-            return UNPARKER.schedule(unparker, nanos, NANOSECONDS);\n+            return UNPARKER.schedule(this::unpark, nanos, NANOSECONDS);\n@@ -729,1 +733,1 @@\n-            if (parked && compareAndSetState(s, RUNNABLE)) {\n+            if (parked && compareAndSetState(s, UNPARKED)) {\n@@ -741,1 +745,1 @@\n-                \/\/ unpark carrier thread when pinned.\n+                \/\/ unpark carrier thread when pinned\n@@ -892,1 +896,2 @@\n-            case RUNNABLE:\n+            case UNPARKED:\n+            case YIELDED:\n@@ -908,1 +913,1 @@\n-                \/\/ runnable, mounted, not yet waiting\n+                \/\/ runnable, in transition\n@@ -950,1 +955,1 @@\n-     * Returns null if the thread is in another state.\n+     * Returns null if the thread is mounted or in transition.\n@@ -954,21 +959,12 @@\n-        return switch (initialState) {\n-            case RUNNABLE, PARKED, TIMED_PARKED -> {\n-                int suspendedState = initialState | SUSPENDED;\n-                if (compareAndSetState(initialState, suspendedState)) {\n-                    try {\n-                        yield cont.getStackTrace();\n-                    } finally {\n-                        assert state == suspendedState;\n-                        setState(initialState);\n-\n-                        \/\/ re-submit if runnable\n-                        \/\/ re-submit if unparked while suspended\n-                        if (initialState == RUNNABLE\n-                            || (parkPermit && compareAndSetState(initialState, RUNNABLE))) {\n-                            try {\n-                                submitRunContinuation();\n-                            } catch (RejectedExecutionException ignore) { }\n-                        }\n-                    }\n-                }\n-                yield null;\n+        switch (initialState) {\n+            case NEW, STARTED, TERMINATED -> {\n+                return new StackTraceElement[0];  \/\/ unmounted, empty stack\n+            }\n+            case RUNNING, PINNED -> {\n+                return null;   \/\/ mounted\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ unmounted, not runnable\n+            }\n+            case UNPARKED, YIELDED -> {\n+                \/\/ unmounted, runnable\n@@ -976,2 +972,30 @@\n-            case NEW, STARTED, TERMINATED ->  new StackTraceElement[0];  \/\/ empty stack\n-            default -> null;\n+            case PARKING, TIMED_PARKING, YIELDING -> {\n+                return null;  \/\/ in transition\n+            }\n+            default -> throw new InternalError();\n+        }\n+\n+        \/\/ thread is unmounted, prevent it from continuing\n+        int suspendedState = initialState | SUSPENDED;\n+        if (!compareAndSetState(initialState, suspendedState)) {\n+            return null;\n+        }\n+\n+        \/\/ get stack trace and restore state\n+        StackTraceElement[] stack;\n+        try {\n+            stack = cont.getStackTrace();\n+        } finally {\n+            assert state == suspendedState;\n+            setState(initialState);\n+        }\n+        boolean resubmit = switch (initialState) {\n+            case UNPARKED, YIELDED -> {\n+                \/\/ resubmit as task may have run while suspended\n+                yield true;\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ resubmit if unparked while suspended\n+                yield parkPermit && compareAndSetState(initialState, UNPARKED);\n+            }\n+            default -> throw new InternalError();\n@@ -979,0 +1003,4 @@\n+        if (resubmit) {\n+            submitRunContinuation();\n+        }\n+        return stack;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":89,"deletions":61,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8286788\n+ * @bug 8284161 8286788 8321270\n@@ -1194,0 +1194,30 @@\n+    \/**\n+     * Test that Thread.yield does not consume the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield3() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            LockSupport.unpark(Thread.currentThread());\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should not park\n+        });\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test that Thread.yield does not make available the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield4() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should park\n+        });\n+        try {\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"}]}