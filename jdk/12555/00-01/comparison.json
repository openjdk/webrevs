{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-    public SSLContext createClientSSLContext() throws Exception {\n+    protected SSLContext createClientSSLContext() throws Exception {\n@@ -290,1 +290,1 @@\n-    public SSLContext createServerSSLContext() throws Exception {\n+    protected SSLContext createServerSSLContext() throws Exception {\n@@ -736,1 +736,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/TLSWithEdDSA.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -395,0 +395,8 @@\n+                \/\/ md5WithRSAEncryption, 1024 bits\n+                \/\/ Validity\n+                \/\/      Not Before: Aug 19 01:52:19 2011 GMT\n+                \/\/      Not After : Jul 29 01:52:19 2032 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      keyid:B9:7C:D5:D9:DF:A7:4C:03:AE:FD:0E:27:5B:31:95:6C:C7:F3:75:E1\n+                \/\/      DirName:\/C=US\/O=Java\/OU=SunJSSE Test Serivce\n+                \/\/      serial:00\n@@ -717,0 +725,6 @@\n+                \/\/ md5WithRSAEncryption, 512 bits\n+                \/\/ Validity\n+                \/\/      Not Before: Nov  7 13:55:52 2011 GMT\n+                \/\/      Not After : Jul 25 13:55:52 2031 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      B9:7C:D5:D9:DF:A7:4C:03:AE:FD:0E:27:5B:31:95:6C:C7:F3:75:E1\n@@ -872,0 +886,9 @@\n+                \/\/ Signature Algorithm: rsassaPss\n+                \/\/ Hash Algorithm: sha256\n+                \/\/ Mask Algorithm: mgf1 with sha256\n+                \/\/\n+                \/\/ Validity\n+                \/\/      Not Before: Jun  6 07:11:00 2018 GMT\n+                \/\/      Not After : Jun  1 07:11:00 2038 GMT\n+                \/\/ X509v3 Authority Key Identifier:\n+                \/\/      1F:16:2B:79:8A:55:89:99:98:02:5F:84:18:D0:7B:1A:23:D8:88:0C\n@@ -892,1 +915,1 @@\n-                \"-----END CERTIFICATE-----\\n\",\n+                \"-----END CERTIFICATE-----\",\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,507 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\/\/\n-\n-\/*\n- * @test\n- * @bug 7105780\n- * @summary Add SSLSocket client\/SSLEngine server to templates directory.\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.1\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.2\n- * @run main\/othervm SSLSocketSSLEngineTemplate TLSv1.3\n- *\/\n-\n-\/**\n- * A SSLSocket\/SSLEngine interop test case.  This is not the way to\n- * code SSLEngine-based servers, but works for what we need to do here,\n- * which is to make sure that SSLEngine\/SSLSockets can talk to each other.\n- * SSLEngines can use direct or indirect buffers, and different code\n- * is used to get at the buffer contents internally, so we test that here.\n- *\n- * The test creates one SSLSocket (client) and one SSLEngine (server).\n- * The SSLSocket talks to a raw ServerSocket, and the server code\n- * does the translation between byte [] and ByteBuffers that the SSLEngine\n- * can use.  The \"transport\" layer consists of a Socket Input\/OutputStream\n- * and two byte buffers for the SSLEngines:  think of them\n- * as directly connected pipes.\n- *\n- * Again, this is a *very* simple example: real code will be much more\n- * involved.  For example, different threading and I\/O models could be\n- * used, transport mechanisms could close unexpectedly, and so on.\n- *\n- * When this application runs, notice that several messages\n- * (wrap\/unwrap) pass before any application data is consumed or\n- * produced.  (For more information, please see the SSL\/TLS\n- * specifications.)  There may several steps for a successful handshake,\n- * so it's typical to see the following series of operations:\n- *\n- *      client          server          message\n- *      ======          ======          =======\n- *      write()         ...             ClientHello\n- *      ...             unwrap()        ClientHello\n- *      ...             wrap()          ServerHello\/Certificate\n- *      read()          ...             ServerHello\/Certificate\n- *      write()         ...             ClientKeyExchange\n- *      write()         ...             ChangeCipherSpec\n- *      write()         ...             Finished\n- *      ...             unwrap()        ClientKeyExchange\n- *      ...             unwrap()        ChangeCipherSpec\n- *      ...             unwrap()        Finished\n- *      ...             wrap()          ChangeCipherSpec\n- *      ...             wrap()          Finished\n- *      read()          ...             ChangeCipherSpec\n- *      read()          ...             Finished\n- *\/\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.net.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class SSLSocketSSLEngineTemplate extends SSLContextTemplate {\n-\n-    \/*\n-     * Enables logging of the SSL\/TLS operations.\n-     *\/\n-    private static final boolean logging = true;\n-\n-    \/*\n-     * Enables the JSSE system debugging system property:\n-     *\n-     *     -Djavax.net.debug=all\n-     *\n-     * This gives a lot of low-level information about operations underway,\n-     * including specific handshake messages, and might be best examined\n-     * after gaining some familiarity with this application.\n-     *\/\n-    private static final boolean debug = false;\n-    private final String protocol;\n-\n-    private SSLEngine serverEngine;     \/\/ server-side SSLEngine\n-    private SSLSocket clientSocket;\n-\n-    private final byte[] serverMsg =\n-        \"Hi there Client, I'm a Server.\".getBytes();\n-    private final byte[] clientMsg =\n-        \"Hello Server, I'm a Client! Pleased to meet you!\".getBytes();\n-\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n-\n-    private volatile Exception clientException;\n-    private volatile Exception serverException;\n-\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n-\n-    \/*\n-     * Main entry point for this test.\n-     *\/\n-    public static void main(String args[]) throws Exception {\n-        String protocol = args[0];\n-\n-        \/\/ reset security properties to make sure that the algorithms\n-        \/\/ and keys used in this test are not disabled.\n-        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n-        Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n-\n-        if (debug) {\n-            System.setProperty(\"javax.net.debug\", \"all\");\n-        }\n-\n-        \/*\n-         * Run the tests with direct and indirect buffers.\n-         *\/\n-        SSLSocketSSLEngineTemplate test =\n-            new SSLSocketSSLEngineTemplate(protocol);\n-        log(\"-------------------------------------\");\n-        log(\"Testing \" + protocol + \" for direct buffers ...\");\n-        test.runTest(true);\n-\n-        log(\"---------------------------------------\");\n-        log(\"Testing \" + protocol + \" for indirect buffers ...\");\n-        test.runTest(false);\n-\n-        log(\"Test Passed.\");\n-    }\n-\n-    \/*\n-     * Create an initialized SSLContext to use for these tests.\n-     *\/\n-    public SSLSocketSSLEngineTemplate(String protocol) {\n-        this.protocol = protocol;\n-    }\n-\n-    public ContextParameters getClientContextParameters() {\n-        return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n-    }\n-\n-    public ContextParameters getServerContextParameters() {\n-        return new ContextParameters(protocol, \"PKIX\", \"NewSunX509\");\n-    }\n-\n-    \/*\n-     * Run the test.\n-     *\n-     * Sit in a tight loop, with the server engine calling wrap\/unwrap\n-     * regardless of whether data is available or not.  We do this until\n-     * we get the application data.  Then we shutdown and go to the next one.\n-     *\n-     * The main loop handles all of the I\/O phases of the SSLEngine's\n-     * lifetime:\n-     *\n-     *     initial handshaking\n-     *     application data transfer\n-     *     engine closing\n-     *\n-     * One could easily separate these phases into separate\n-     * sections of code.\n-     *\/\n-    private void runTest(boolean direct) throws Exception {\n-        clientSocket = null;\n-        boolean serverClose = direct;\n-\n-        \/\/ generates the server-side Socket\n-        try (ServerSocket serverSocket = new ServerSocket()) {\n-            serverSocket.setReuseAddress(false);\n-            serverSocket.bind(null);\n-            int port = serverSocket.getLocalPort();\n-            log(\"Port: \" + port);\n-            Thread thread = createClientThread(port, serverClose);\n-\n-            createSSLEngine();\n-            createBuffers(direct);\n-\n-            \/\/ server-side socket that will read\n-            try (Socket socket = serverSocket.accept()) {\n-                socket.setSoTimeout(500);\n-\n-                boolean closed = false;\n-                \/\/ will try to read one more time in case client message\n-                \/\/ is fragmented to multiple pieces\n-                boolean retry = true;\n-\n-                InputStream is = socket.getInputStream();\n-                OutputStream os = socket.getOutputStream();\n-\n-                SSLEngineResult serverResult;   \/\/ results from last operation\n-\n-                \/*\n-                 * Examining the SSLEngineResults could be much more involved,\n-                 * and may alter the overall flow of the application.\n-                 *\n-                 * For example, if we received a BUFFER_OVERFLOW when trying\n-                 * to write to the output pipe, we could reallocate a larger\n-                 * pipe, but instead we wait for the peer to drain it.\n-                 *\/\n-                byte[] inbound = new byte[8192];\n-                byte[] outbound = new byte[8192];\n-\n-                while (!isEngineClosed(serverEngine)) {\n-                    int len;\n-\n-                    \/\/ Inbound data\n-                    log(\"================\");\n-\n-                    \/\/ Read from the Client side.\n-                    try {\n-                        len = is.read(inbound);\n-                        if (len == -1) {\n-                            logSocketStatus(clientSocket);\n-                            if (clientSocket.isClosed()\n-                                    || clientSocket.isOutputShutdown()) {\n-                                log(\"Client socket was closed or shutdown output\");\n-                                break;\n-                            } else {\n-                                throw new Exception(\"Unexpected EOF\");\n-                            }\n-                        }\n-                        cTOs.put(inbound, 0, len);\n-                    } catch (SocketTimeoutException ste) {\n-                        \/\/ swallow. Nothing yet, probably waiting on us.\n-                    }\n-\n-                    cTOs.flip();\n-\n-                    serverResult = serverEngine.unwrap(cTOs, serverIn);\n-                    log(\"server unwrap: \", serverResult);\n-                    runDelegatedTasks(serverResult, serverEngine);\n-                    cTOs.compact();\n-\n-                    \/\/ Outbound data\n-                    log(\"----\");\n-\n-                    serverResult = serverEngine.wrap(serverOut, sTOc);\n-                    log(\"server wrap: \", serverResult);\n-                    runDelegatedTasks(serverResult, serverEngine);\n-\n-                    sTOc.flip();\n-\n-                    if ((len = sTOc.remaining()) != 0) {\n-                        sTOc.get(outbound, 0, len);\n-                        os.write(outbound, 0, len);\n-                        \/\/ Give the other side a chance to process\n-                    }\n-\n-                    sTOc.compact();\n-\n-                    if (!closed && (serverOut.remaining() == 0)) {\n-                        closed = true;\n-\n-                        \/*\n-                         * We'll alternate initiatating the shutdown.\n-                         * When the server initiates, it will take one more\n-                         * loop, but tests the orderly shutdown.\n-                         *\/\n-                        if (serverClose) {\n-                            serverEngine.closeOutbound();\n-                        }\n-                        serverIn.flip();\n-\n-                        \/*\n-                         * A sanity check to ensure we got what was sent.\n-                         *\/\n-                        if (serverIn.remaining() !=  clientMsg.length) {\n-                            if (retry &&\n-                                    serverIn.remaining() < clientMsg.length) {\n-                                log(\"Need to read more from client\");\n-                                serverIn.compact();\n-                                retry = false;\n-                                continue;\n-                            } else {\n-                                throw new Exception(\n-                                        \"Client: Data length error\");\n-                            }\n-                        }\n-\n-                        for (int i = 0; i < clientMsg.length; i++) {\n-                            if (clientMsg[i] != serverIn.get()) {\n-                                throw new Exception(\n-                                        \"Client: Data content error\");\n-                            }\n-                        }\n-                        serverIn.compact();\n-                    }\n-                }\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                \/\/ Wait for the client to join up with us.\n-                if (thread != null) {\n-                    thread.join();\n-                }\n-            }\n-        } finally {\n-            if (serverException != null) {\n-                if (clientException != null) {\n-                    serverException.addSuppressed(clientException);\n-                }\n-                throw serverException;\n-            }\n-            if (clientException != null) {\n-                if (serverException != null) {\n-                    clientException.addSuppressed(serverException);\n-                }\n-                throw clientException;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Create a client thread which does simple SSLSocket operations.\n-     * We'll write and read one data packet.\n-     *\/\n-    private Thread createClientThread(final int port,\n-            final boolean serverClose) throws Exception {\n-\n-        Thread t = new Thread(\"ClientThread\") {\n-\n-            @Override\n-            public void run() {\n-                \/\/ client-side socket\n-                try (SSLSocket sslSocket =\n-                             (SSLSocket)createClientSSLContext().getSocketFactory().\n-                            createSocket(\"localhost\", port)) {\n-                    clientSocket = sslSocket;\n-\n-                    OutputStream os = sslSocket.getOutputStream();\n-                    InputStream is = sslSocket.getInputStream();\n-\n-                    \/\/ write(byte[]) goes in one shot.\n-                    os.write(clientMsg);\n-\n-                    byte[] inbound = new byte[2048];\n-                    int pos = 0;\n-\n-                    int len;\n-                    while ((len = is.read(inbound, pos, 2048 - pos)) != -1) {\n-                        pos += len;\n-                        \/\/ Let the client do the closing.\n-                        if ((pos == serverMsg.length) && !serverClose) {\n-                            sslSocket.close();\n-                            break;\n-                        }\n-                    }\n-\n-                    if (pos != serverMsg.length) {\n-                        throw new Exception(\"Client:  Data length error\");\n-                    }\n-\n-                    for (int i = 0; i < serverMsg.length; i++) {\n-                        if (inbound[i] != serverMsg[i]) {\n-                            throw new Exception(\"Client:  Data content error\");\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    clientException = e;\n-                }\n-            }\n-        };\n-        t.start();\n-        return t;\n-    }\n-\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngine() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.\n-         *\/\n-        serverEngine = createServerSSLContext().createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.getNeedClientAuth();\n-    }\n-\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers(boolean direct) {\n-\n-        SSLSession session = serverEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        if (direct) {\n-            serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n-            cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-            sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-        } else {\n-            serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-            cTOs = ByteBuffer.allocate(netBufferMax);\n-            sTOc = ByteBuffer.allocate(netBufferMax);\n-        }\n-\n-        serverOut = ByteBuffer.wrap(serverMsg);\n-    }\n-\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n-    private static void runDelegatedTasks(SSLEngineResult result,\n-            SSLEngine engine) throws Exception {\n-\n-        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n-            Runnable runnable;\n-            while ((runnable = engine.getDelegatedTask()) != null) {\n-                log(\"\\trunning delegated task...\");\n-                runnable.run();\n-            }\n-            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n-            if (hsStatus == HandshakeStatus.NEED_TASK) {\n-                throw new Exception(\n-                        \"handshake shouldn't need additional tasks\");\n-            }\n-            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n-        }\n-    }\n-\n-    private static boolean isEngineClosed(SSLEngine engine) {\n-        return (engine.isOutboundDone() && engine.isInboundDone());\n-    }\n-\n-    private static void logSocketStatus(Socket socket) {\n-        log(\"##### \" + socket + \" #####\");\n-        log(\"isBound: \" + socket.isBound());\n-        log(\"isConnected: \" + socket.isConnected());\n-        log(\"isClosed: \" + socket.isClosed());\n-        log(\"isInputShutdown: \" + socket.isInputShutdown());\n-        log(\"isOutputShutdown: \" + socket.isOutputShutdown());\n-    }\n-\n-    \/*\n-     * Logging code\n-     *\/\n-    private static boolean resultOnce = true;\n-\n-    private static void log(String str, SSLEngineResult result) {\n-        if (!logging) {\n-            return;\n-        }\n-        if (resultOnce) {\n-            resultOnce = false;\n-            log(\"The format of the SSLEngineResult is: \\n\"\n-                    + \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\"\n-                    + \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n-        }\n-        HandshakeStatus hsStatus = result.getHandshakeStatus();\n-        log(str\n-                + result.getStatus() + \"\/\" + hsStatus + \", \"\n-                + result.bytesConsumed() + \"\/\" + result.bytesProduced()\n-                + \" bytes\");\n-        if (hsStatus == HandshakeStatus.FINISHED) {\n-            log(\"\\t...ready for application data\");\n-        }\n-    }\n-\n-    private static void log(String str) {\n-        if (logging) {\n-            if (debug) {\n-                System.err.println(str);\n-            } else {\n-                System.out.println(str);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketSSLEngineTemplate.java","additions":0,"deletions":507,"binary":false,"changes":507,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    public SSLContext createServerSSLContext() throws Exception {\n+    protected SSLContext createServerSSLContext() throws Exception {\n@@ -116,1 +116,1 @@\n-    public SSLContext createClientSSLContext() throws Exception {\n+    protected SSLContext createClientSSLContext() throws Exception {\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsClient\/ServerIdentityTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates\n@@ -85,1 +85,0 @@\n-import java.security.*;\n@@ -92,1 +91,1 @@\n-public class SSLEngineBadBufferArrayAccess {\n+public class SSLEngineBadBufferArrayAccess extends SSLContextTemplate {\n@@ -97,1 +96,2 @@\n-    private static boolean logging = true;\n+    private final static boolean logging = Boolean.parseBoolean(\n+            System.getProperty(\"test.logging\", \"true\"));\n@@ -108,2 +108,3 @@\n-    private static boolean debug = false;\n-    private SSLContext sslc;\n+    private final static boolean debug = Boolean.getBoolean(\"test.debug\");\n+    private final String PROTOCOL;\n+\n@@ -127,14 +128,0 @@\n-    \/*\n-     * The following is to set up the keystores\/trust material.\n-     *\/\n-    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final String passwd = \"passphrase\";\n-    private static String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + keyStoreFile;\n-    private static String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n-            + \"\/\" + trustStoreFile;\n-\n@@ -159,1 +146,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -168,1 +155,1 @@\n-            \"SSLv3\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\" };\n+            \"SSLv3\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\", \"TLSv1.3\"};\n@@ -187,22 +174,3 @@\n-    public SSLEngineBadBufferArrayAccess(String protocol) throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        try (FileInputStream fis = new FileInputStream(keyFilename)) {\n-            ks.load(fis, passphrase);\n-        }\n-\n-        try (FileInputStream fis = new FileInputStream(trustFilename)) {\n-            ts.load(fis, passphrase);\n-        }\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(protocol);\n+    public SSLEngineBadBufferArrayAccess(String protocol) {\n+        PROTOCOL = protocol;\n+    }\n@@ -210,1 +178,4 @@\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return new ContextParameters(PROTOCOL, \"PKIX\", \"NewSunX509\");\n+    }\n@@ -212,1 +183,3 @@\n-        sslc = sslCtx;\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return new ContextParameters(PROTOCOL, \"PKIX\", \"NewSunX509\");\n@@ -235,0 +208,1 @@\n+        System.out.println(\"Running test serverClose = \" + serverClose);\n@@ -247,1 +221,1 @@\n-            socket = (Socket) serverSocket.accept();\n+            socket = serverSocket.accept();\n@@ -330,1 +304,1 @@\n-            int len = 0;\n+            int len;\n@@ -339,1 +313,8 @@\n-                    throw new Exception(\"Unexpected EOF\");\n+                    logSocketStatus(socket);\n+                    if (socket.isClosed()\n+                            || socket.isOutputShutdown()) {\n+                        log(\"Client socket was closed or shutdown output\");\n+                        break;\n+                    } else {\n+                        throw new Exception(\"Unexpected EOF\");\n+                    }\n@@ -375,1 +356,1 @@\n-                 * We'll alternate initiatating the shutdown.\n+                 * We'll alternate initiating the shutdown.\n@@ -382,3 +363,0 @@\n-            }\n-\n-            if (closed && isEngineClosed(serverEngine)) {\n@@ -406,0 +384,1 @@\n+                break;\n@@ -453,1 +432,1 @@\n-        SSLSocketFactory sslsf = sslc.getSocketFactory();\n+        SSLSocketFactory sslsf = createClientSSLContext().getSocketFactory();\n@@ -495,0 +474,1 @@\n+        System.out.println(\"writing message to server.\");\n@@ -502,0 +482,1 @@\n+            System.out.printf(\"Client read %d bytes. Waiting for %d from server.%n\", len, serverMsg.length);\n@@ -505,0 +486,1 @@\n+                System.out.println(\"Closing the socket\");\n@@ -509,1 +491,1 @@\n-\n+        System.out.println(\"Read everything we're going to, I guess.\");\n@@ -530,1 +512,1 @@\n-        serverEngine = sslc.createSSLEngine();\n+        serverEngine = createServerSSLContext().createSSLEngine();\n@@ -592,0 +574,9 @@\n+    private static void logSocketStatus(Socket socket) {\n+        log(\"##### \" + socket + \" #####\");\n+        log(\"isBound: \" + socket.isBound());\n+        log(\"isConnected: \" + socket.isConnected());\n+        log(\"isClosed: \" + socket.isClosed());\n+        log(\"isInputShutdown: \" + socket.isInputShutdown());\n+        log(\"isOutputShutdown: \" + socket.isOutputShutdown());\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/SSLEngineBadBufferArrayAccess.java","additions":47,"deletions":56,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-\n@@ -109,0 +108,4 @@\n+        } catch (SSLProtocolException | SSLHandshakeException sslhe) {\n+            System.err.println(\"Client had unexpected SSL exception: \" + sslhe);\n+            throw sslhe;\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SocketExceptionForSocketIssues.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021, 2023 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -52,1 +52,1 @@\n-    public SSLContext createServerSSLContext() throws Exception {\n+    protected SSLContext createServerSSLContext() throws Exception {\n@@ -60,1 +60,1 @@\n-    public SSLContext createClientSSLContext() throws Exception {\n+    protected SSLContext createClientSSLContext() throws Exception {\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}