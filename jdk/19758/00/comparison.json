{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,137 +44,0 @@\n-#ifdef ASSERT\n-void NativeLoadGot::report_and_fail() const {\n-  tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: %x %x %x\", p2i(instruction_address()),\n-                  (has_rex ? ubyte_at(0) : 0), ubyte_at(rex_size), ubyte_at(rex_size + 1));\n-  fatal(\"not a indirect rip mov to rbx\");\n-}\n-\n-void NativeLoadGot::verify() const {\n-  if (has_rex) {\n-    int rex = ubyte_at(0);\n-    if (rex != rex_prefix && rex != rex_b_prefix) {\n-      report_and_fail();\n-    }\n-  }\n-\n-  int inst = ubyte_at(rex_size);\n-  if (inst != instruction_code) {\n-    report_and_fail();\n-  }\n-  int modrm = ubyte_at(rex_size + 1);\n-  if (modrm != modrm_rbx_code && modrm != modrm_rax_code) {\n-    report_and_fail();\n-  }\n-}\n-#endif\n-\n-intptr_t NativeLoadGot::data() const {\n-  return *(intptr_t *) got_address();\n-}\n-\n-address NativePltCall::destination() const {\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  return jump->destination();\n-}\n-\n-address NativePltCall::plt_entry() const {\n-  return return_address() + displacement();\n-}\n-\n-address NativePltCall::plt_jump() const {\n-  address entry = plt_entry();\n-  \/\/ Virtual PLT code has move instruction first\n-  if (((NativeGotJump*)entry)->is_GotJump()) {\n-    return entry;\n-  } else {\n-    return nativeLoadGot_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-address NativePltCall::plt_load_got() const {\n-  address entry = plt_entry();\n-  if (!((NativeGotJump*)entry)->is_GotJump()) {\n-    \/\/ Virtual PLT code has move instruction first\n-    return entry;\n-  } else {\n-    \/\/ Static PLT code has move instruction second (from c2i stub)\n-    return nativeGotJump_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-address NativePltCall::plt_c2i_stub() const {\n-  address entry = plt_load_got();\n-  \/\/ This method should be called only for static calls which has C2I stub.\n-  NativeLoadGot* load = nativeLoadGot_at(entry);\n-  return entry;\n-}\n-\n-address NativePltCall::plt_resolve_call() const {\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  address entry = jump->next_instruction_address();\n-  if (((NativeGotJump*)entry)->is_GotJump()) {\n-    return entry;\n-  } else {\n-    \/\/ c2i stub 2 instructions\n-    entry = nativeLoadGot_at(entry)->next_instruction_address();\n-    return nativeGotJump_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-void NativePltCall::reset_to_plt_resolve_call() {\n-  set_destination_mt_safe(plt_resolve_call());\n-}\n-\n-void NativePltCall::set_destination_mt_safe(address dest) {\n-  \/\/ rewriting the value in the GOT, it should always be aligned\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  address* got = (address *) jump->got_address();\n-  *got = dest;\n-}\n-\n-void NativePltCall::set_stub_to_clean() {\n-  NativeLoadGot* method_loader = nativeLoadGot_at(plt_c2i_stub());\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  method_loader->set_data(0);\n-  jump->set_jump_destination((address)-1);\n-}\n-\n-void NativePltCall::verify() const {\n-  \/\/ Make sure code pattern is actually a call rip+off32 instruction.\n-  int inst = ubyte_at(0);\n-  if (inst != instruction_code) {\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", p2i(instruction_address()),\n-                                                        inst);\n-    fatal(\"not a call rip+off32\");\n-  }\n-}\n-\n-address NativeGotJump::destination() const {\n-  address *got_entry = (address *) got_address();\n-  return *got_entry;\n-}\n-\n-#ifdef ASSERT\n-void NativeGotJump::report_and_fail() const {\n-  tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: %x %x %x\", p2i(instruction_address()),\n-                 (has_rex() ? ubyte_at(0) : 0), ubyte_at(rex_size()), ubyte_at(rex_size() + 1));\n-  fatal(\"not a indirect rip jump\");\n-}\n-\n-void NativeGotJump::verify() const {\n-  if (has_rex()) {\n-    int rex = ubyte_at(0);\n-    if (rex != rex_prefix) {\n-      report_and_fail();\n-    }\n-  }\n-  int inst = ubyte_at(rex_size());\n-  if (inst != instruction_code) {\n-    report_and_fail();\n-  }\n-  int modrm = ubyte_at(rex_size() + 1);\n-  if (modrm != modrm_code) {\n-    report_and_fail();\n-  }\n-}\n-#endif\n-\n@@ -568,22 +431,0 @@\n-address NativeFarJump::jump_destination() const          {\n-  NativeMovConstReg* mov = nativeMovConstReg_at(addr_at(0));\n-  return (address)mov->data();\n-}\n-\n-void NativeFarJump::verify() {\n-  if (is_far_jump()) {\n-    NativeMovConstReg* mov = nativeMovConstReg_at(addr_at(0));\n-    NativeInstruction* jmp = nativeInstruction_at(mov->next_instruction_address());\n-    if (jmp->is_jump_reg()) return;\n-  }\n-  fatal(\"not a jump instruction\");\n-}\n-\n-void NativePopReg::insert(address code_pos, Register reg) {\n-  assert(reg->encoding() < 8, \"no space for REX\");\n-  assert(NativePopReg::instruction_size == sizeof(char), \"right address unit for update\");\n-  *code_pos = (u_char)(instruction_code | reg->encoding());\n-  ICache::invalidate_range(code_pos, instruction_size);\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":1,"deletions":160,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-\/\/ - - NativeFarJump\n@@ -67,1 +66,0 @@\n-  inline bool is_far_jump();\n@@ -107,41 +105,0 @@\n-class NativePltCall: public NativeInstruction {\n-public:\n-  enum Intel_specific_constants {\n-    instruction_code           = 0xE8,\n-    instruction_size           =    5,\n-    instruction_offset         =    0,\n-    displacement_offset        =    1,\n-    return_address_offset      =    5\n-  };\n-  address instruction_address() const { return addr_at(instruction_offset); }\n-  address next_instruction_address() const { return addr_at(return_address_offset); }\n-  address displacement_address() const { return addr_at(displacement_offset); }\n-  int displacement() const { return (jint) int_at(displacement_offset); }\n-  address return_address() const { return addr_at(return_address_offset); }\n-  address destination() const;\n-  address plt_entry() const;\n-  address plt_jump() const;\n-  address plt_load_got() const;\n-  address plt_resolve_call() const;\n-  address plt_c2i_stub() const;\n-  void set_stub_to_clean();\n-\n-  void  reset_to_plt_resolve_call();\n-  void  set_destination_mt_safe(address dest);\n-\n-  void verify() const;\n-};\n-\n-inline NativePltCall* nativePltCall_at(address address) {\n-  NativePltCall* call = (NativePltCall*) address;\n-#ifdef ASSERT\n-  call->verify();\n-#endif\n-  return call;\n-}\n-\n-inline NativePltCall* nativePltCall_before(address addr) {\n-  address at = addr - NativePltCall::instruction_size;\n-  return nativePltCall_at(at);\n-}\n-\n@@ -429,51 +386,0 @@\n-\/\/ destination is rbx or rax\n-\/\/ mov rbx, [rip + offset]\n-class NativeLoadGot: public NativeInstruction {\n-#ifdef AMD64\n-  static const bool has_rex = true;\n-  static const int rex_size = 1;\n-#else\n-  static const bool has_rex = false;\n-  static const int rex_size = 0;\n-#endif\n-\n-  enum Intel_specific_constants {\n-    rex_prefix = 0x48,\n-    rex_b_prefix = 0x49,\n-    instruction_code = 0x8b,\n-    modrm_rbx_code = 0x1d,\n-    modrm_rax_code = 0x05,\n-    instruction_length = 6 + rex_size,\n-    offset_offset = 2 + rex_size\n-  };\n-\n-  int rip_offset() const { return int_at(offset_offset); }\n-  address return_address() const { return addr_at(instruction_length); }\n-  address got_address() const { return return_address() + rip_offset(); }\n-\n-#ifdef ASSERT\n-  void report_and_fail() const;\n-  address instruction_address() const { return addr_at(0); }\n-#endif\n-\n-public:\n-  address next_instruction_address() const { return return_address(); }\n-  intptr_t data() const;\n-  void set_data(intptr_t data) {\n-    intptr_t *addr = (intptr_t *) got_address();\n-    *addr = data;\n-  }\n-\n-  DEBUG_ONLY( void verify() const );\n-};\n-\n-inline NativeLoadGot* nativeLoadGot_at(address addr) {\n-  NativeLoadGot* load = (NativeLoadGot*) addr;\n-#ifdef ASSERT\n-  load->verify();\n-#endif\n-  return load;\n-}\n-\n-\/\/ jump rel32off\n-\n@@ -535,20 +441,0 @@\n-\/\/ far jump reg\n-class NativeFarJump: public NativeInstruction {\n- public:\n-  address jump_destination() const;\n-\n-  \/\/ Creation\n-  inline friend NativeFarJump* nativeFarJump_at(address address);\n-\n-  void verify();\n-\n-};\n-\n-inline NativeFarJump* nativeFarJump_at(address address) {\n-  NativeFarJump* jump = (NativeFarJump*)(address);\n-#ifdef ASSERT\n-  jump->verify();\n-#endif\n-  return jump;\n-}\n-\n@@ -588,55 +474,0 @@\n-class NativeGotJump: public NativeInstruction {\n-  enum Intel_specific_constants {\n-    rex_prefix = 0x41,\n-    instruction_code = 0xff,\n-    modrm_code = 0x25,\n-    instruction_size = 6,\n-    rip_offset = 2\n-  };\n-\n-  bool has_rex() const { return ubyte_at(0) == rex_prefix; }\n-  int rex_size() const { return has_rex() ? 1 : 0; }\n-\n-  address return_address() const { return addr_at(instruction_size + rex_size()); }\n-  int got_offset() const { return (jint) int_at(rip_offset + rex_size()); }\n-\n-#ifdef ASSERT\n-  void report_and_fail() const;\n-  address instruction_address() const { return addr_at(0); }\n-#endif\n-\n-public:\n-  address got_address() const { return return_address() + got_offset(); }\n-  address next_instruction_address() const { return return_address(); }\n-  bool is_GotJump() const { return ubyte_at(rex_size()) == instruction_code; }\n-\n-  address destination() const;\n-  void set_jump_destination(address dest)  {\n-    address *got_entry = (address *) got_address();\n-    *got_entry = dest;\n-  }\n-\n-  DEBUG_ONLY( void verify() const; )\n-};\n-\n-inline NativeGotJump* nativeGotJump_at(address addr) {\n-  NativeGotJump* jump = (NativeGotJump*)(addr);\n-  debug_only(jump->verify());\n-  return jump;\n-}\n-\n-class NativePopReg : public NativeInstruction {\n- public:\n-  enum Intel_specific_constants {\n-    instruction_code            = 0x58,\n-    instruction_size            =    1,\n-    instruction_offset          =    0,\n-    data_offset                 =    1,\n-    next_instruction_offset     =    1\n-  };\n-\n-  \/\/ Insert a pop instruction\n-  static void insert(address code_pos, Register reg);\n-};\n-\n-\n@@ -705,1 +536,0 @@\n-inline bool NativeInstruction::is_far_jump()     { return is_mov_literal64(); }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":1,"deletions":171,"binary":false,"changes":172,"status":"modified"}]}