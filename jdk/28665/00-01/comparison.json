{"files":[{"patch":"@@ -78,3 +78,3 @@\n-    {\n-      \/\/ If the cycle was cancelled, continue the next iteration to deal with it. Otherwise,\n-      \/\/ if there was no other cycle requested, cleanup and wait for the next request.\n+    \/\/ If the cycle was cancelled, continue the next iteration to deal with it. Otherwise,\n+    \/\/ if there was no other cycle requested, cleanup and wait for the next request.\n+    if (!_heap->cancelled_gc()) {\n@@ -82,5 +82,3 @@\n-      if (!_heap->cancelled_gc()) {\n-        if (_requested_gc_cause == GCCause::_no_gc) {\n-          set_gc_mode(ml, none);\n-          ml.wait();\n-        }\n+      if (_requested_gc_cause == GCCause::_no_gc) {\n+        set_gc_mode(ml, none);\n+        ml.wait();\n@@ -101,2 +99,1 @@\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n-  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  notify_control_thread(ml, GCCause::_shenandoah_stop_vm);\n@@ -145,1 +142,2 @@\n-\n+  \/\/ Important: not all paths update the request.generation. This is intentional.\n+  \/\/ A degenerated cycle must use the same generation carried over from the previous request.\n@@ -638,3 +636,1 @@\n-    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n-    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n-    notify_cancellation(cause);\n+    notify_control_thread(cause);\n@@ -666,1 +662,1 @@\n-      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc);\n@@ -706,1 +702,1 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause) {\n@@ -708,1 +704,1 @@\n-  notify_cancellation(ml, cause);\n+  notify_control_thread(ml, cause);\n@@ -711,3 +707,4 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n-  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n-  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n+  log_debug(gc, thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+  _requested_gc_cause = cause;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -142,5 +142,2 @@\n-\n-  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n-  void notify_cancellation(GCCause::Cause cause);\n-  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n+  void notify_control_thread(GCCause::Cause cause);\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}