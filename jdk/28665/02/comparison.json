{"files":[{"patch":"@@ -99,2 +99,1 @@\n-  _requested_gc_cause = GCCause::_shenandoah_stop_vm;\n-  notify_cancellation(ml, GCCause::_shenandoah_stop_vm);\n+  notify_control_thread(ml, GCCause::_shenandoah_stop_vm);\n@@ -143,1 +142,2 @@\n-\n+  \/\/ Important: not all paths update the request.generation. This is intentional.\n+  \/\/ A degenerated cycle must use the same generation carried over from the previous request.\n@@ -636,3 +636,1 @@\n-    \/\/ GC should already be cancelled. Here we are just notifying the control thread to\n-    \/\/ wake up and handle the cancellation request, so we don't need to set _requested_gc_cause.\n-    notify_cancellation(cause);\n+    notify_control_thread(cause);\n@@ -664,1 +662,1 @@\n-      notify_cancellation(ml, GCCause::_shenandoah_concurrent_gc);\n+      notify_control_thread(ml, GCCause::_shenandoah_concurrent_gc);\n@@ -704,1 +702,1 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(GCCause::Cause cause) {\n+void ShenandoahGenerationalControlThread::notify_control_thread(GCCause::Cause cause) {\n@@ -706,1 +704,1 @@\n-  notify_cancellation(ml, cause);\n+  notify_control_thread(ml, cause);\n@@ -709,3 +707,4 @@\n-void ShenandoahGenerationalControlThread::notify_cancellation(MonitorLocker& ml, GCCause::Cause cause) {\n-  assert(_heap->cancelled_gc(), \"GC should already be cancelled\");\n-  log_debug(gc,thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+void ShenandoahGenerationalControlThread::notify_control_thread(MonitorLocker& ml, GCCause::Cause cause) {\n+  assert(_control_lock.is_locked(), \"Request lock must be held here\");\n+  log_debug(gc, thread)(\"Notify control (%s): %s\", gc_mode_name(gc_mode()), GCCause::to_string(cause));\n+  _requested_gc_cause = cause;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -138,2 +138,4 @@\n-  \/\/ Takes the request lock and updates the requested cause and generation, then notifies the control thread.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n+  \/\/ These notify the control thread after updating _requested_gc_cause and (optionally) _requested_generation.\n+  \/\/ Updating the requested generation is not necessary for allocation failures nor when stopping the thread.\n+  void notify_control_thread(GCCause::Cause cause);\n+  void notify_control_thread(MonitorLocker& ml, GCCause::Cause cause);\n@@ -143,5 +145,0 @@\n-  \/\/ Notifies the control thread, but does not update the requested cause or generation.\n-  \/\/ The overloaded variant should be used when the _control_lock is already held.\n-  void notify_cancellation(GCCause::Cause cause);\n-  void notify_cancellation(MonitorLocker& ml, GCCause::Cause cause);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}