{"files":[{"patch":"@@ -48,0 +48,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -407,0 +408,1 @@\n+        _finished_workers(0),\n@@ -468,0 +470,1 @@\n+  Atomic::store(&_finished_workers, 0);\n@@ -478,2 +481,6 @@\n-  \/\/ Done executing task locally, wait for any remaining workers to complete,\n-  \/\/ and then do the final housekeeping.\n+  \/\/ Done executing task locally, wait for any remaining workers to complete.\n+  \/\/ Once all workers report, we can proceed to termination. To do this safely,\n+  \/\/ we need to make sure every worker has left. A spin-wait alone would suffice,\n+  \/\/ but we do not want to burn cycles on it. A semaphore alone would not be safe,\n+  \/\/ since workers can still be inside it as we proceed from wait here. So we block\n+  \/\/ on semaphore first, and then spin-wait for all workers to terminate.\n@@ -481,0 +488,5 @@\n+  SpinYield spin;\n+  while (Atomic::load(&_finished_workers) != _num_workers) {\n+    spin.wait();\n+  }\n+\n@@ -484,0 +496,1 @@\n+  assert(Atomic::load(&_finished_workers) == _num_workers, \"All workers have finished\");\n@@ -495,1 +508,2 @@\n-  \/\/ Signal the pool the tasks are complete, if this was the last running worker.\n+  \/\/ Signal the pool the work is complete, and we are exiting.\n+  \/\/ Worker cannot do anything else with the pool after this.\n@@ -499,0 +513,1 @@\n+  Atomic::add(&_finished_workers, 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -372,0 +372,1 @@\n+  int _finished_workers;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}