{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,0 +199,5 @@\n+# Set main class of jdk.httpserver module\n+ifeq ($(MODULE), jdk.httpserver)\n+    JMOD_FLAGS += --main-class sun.net.httpserver.simpleserver.Main\n+endif\n+\n","filename":"make\/CreateJmods.gmk","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+import com.sun.tools.classfile.ModuleMainClass_attribute;\n@@ -931,0 +932,6 @@\n+        if (header.moduleMainClass != null) {\n+            int attrIdx = addString(cp, Attribute.ModuleMainClass);\n+            int targetIdx = addString(cp, header.moduleMainClass);\n+            attributes.put(Attribute.ModuleMainClass,\n+                           new ModuleMainClass_attribute(attrIdx, targetIdx));\n+        }\n@@ -2297,0 +2304,7 @@\n+            case Attribute.ModuleMainClass: {\n+                ModuleMainClass_attribute moduleMainClass = (ModuleMainClass_attribute) attr;\n+                assert feature instanceof ModuleHeaderDescription;\n+                ModuleHeaderDescription mhd = (ModuleHeaderDescription) feature;\n+                mhd.moduleMainClass = moduleMainClass.getMainClassName(cf.constant_pool);\n+                break;\n+            }\n@@ -2734,0 +2748,1 @@\n+        String moduleMainClass;\n@@ -2746,0 +2761,1 @@\n+            hash = 83 * hash + Objects.hashCode(this.moduleMainClass);\n@@ -2784,0 +2800,4 @@\n+            if (!Objects.equals(this.moduleMainClass,\n+                                other.moduleMainClass)) {\n+                return false;\n+            }\n@@ -2821,0 +2841,2 @@\n+            if (moduleMainClass != null)\n+                output.append(\" moduleMainClass \" + quote(moduleMainClass, true));\n@@ -2865,0 +2887,2 @@\n+            moduleMainClass = reader.attributes.get(\"moduleMainClass\");\n+\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include GensrcCommonJdk.gmk\n+include GensrcProperties.gmk\n+include Modules.gmk\n+\n+################################################################################\n+\n+# Use wildcard so as to avoid getting non-existing directories back\n+SIMPLESERVER_RESOURCES_DIRS := $(wildcard $(addsuffix \/sun\/net\/httpserver\/simpleserver\/resources, \\\n+    $(call FindModuleSrcDirs, jdk.httpserver)))\n+\n+$(eval $(call SetupCompileProperties, SIMPLESERVER_PROPERTIES, \\\n+    SRC_DIRS := $(SIMPLESERVER_RESOURCES_DIRS), \\\n+    CLASS := ListResourceBundle, \\\n+))\n+\n+TARGETS += $(SIMPLESERVER_PROPERTIES)\n","filename":"make\/modules\/jdk.httpserver\/Gensrc.gmk","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.net.URI;\n@@ -35,0 +36,2 @@\n+import java.util.function.UnaryOperator;\n+import sun.net.httpserver.DelegatingHttpExchange;\n@@ -137,1 +140,0 @@\n-\n@@ -255,0 +257,60 @@\n+\n+    \/**\n+     * Returns a\n+     * {@linkplain Filter#beforeHandler(String, Consumer) pre-processing Filter}\n+     * that inspects and possibly adapts the request state.\n+     *\n+     * The {@code Request} returned by the {@link UnaryOperator requestOperator}\n+     * will be the effective request state of the exchange. It is executed for\n+     * each {@code HttpExchange} before invoking either the next filter in the\n+     * chain or the exchange handler (if this is the final filter in the chain).\n+     * Exceptions thrown by the {@code requestOperator} are not handled by the\n+     * filter.\n+     *\n+     * @apiNote\n+     * When the returned filter is invoked, it first invokes the\n+     * {@code requestOperator} with the given exchange, {@code ex}, in order to\n+     * retrieve the <i>adapted request state<\/i>. It then invokes the next\n+     * filter in the chain or the exchange handler, passing an exchange\n+     * equivalent to {@code ex} with the <i>adapted request state<\/i> set as the\n+     * effective request state.\n+     *\n+     * <p> Example of adding the {@code \"Foo\"} request header to all requests:\n+     * <pre>{@code\n+     *     var filter = Filter.adaptRequest(\"Add Foo header\", r -> r.with(\"Foo\", List.of(\"Bar\")));\n+     *     httpContext.getFilters().add(filter);\n+     * }<\/pre>\n+     *\n+     * @param description the string to be returned from {@link #description()}\n+     * @param requestOperator the request operator\n+     * @return a filter that adapts the request state before the exchange is handled\n+     * @throws NullPointerException if any argument is null\n+     * @since 18\n+     *\/\n+    public static Filter adaptRequest(String description,\n+                                      UnaryOperator<Request> requestOperator) {\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(requestOperator);\n+\n+        return new Filter() {\n+            @Override\n+            public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+                var request = requestOperator.apply(exchange);\n+                var newExchange =  new DelegatingHttpExchange(exchange) {\n+                    @Override\n+                    public URI getRequestURI() { return request.getRequestURI(); }\n+\n+                    @Override\n+                    public String getRequestMethod() { return request.getRequestMethod(); }\n+\n+                    @Override\n+                    public Headers getRequestHeaders() { return request.getRequestHeaders(); }\n+                };\n+                chain.doFilter(newExchange);\n+            }\n+            @Override\n+            public String description() {\n+                return description;\n+            }\n+        };\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Filter.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Arrays;\n@@ -36,0 +37,2 @@\n+import java.util.stream.Collectors;\n+import sun.net.httpserver.UnmodifiableHeaders;\n@@ -68,0 +71,8 @@\n+ * <p> An instance of {@code Headers} is either <i>mutable<\/i> or <i>immutable<\/i>.\n+ * A <i>mutable headers<\/i> allows to add, remove, or modify header names and\n+ * values, e.g. the instance returned by {@link HttpExchange#getResponseHeaders()}.\n+ * An <i>immutable headers<\/i> disallows any modification to header names or\n+ * values, e.g. the instance returned by {@link HttpExchange#getRequestHeaders()}.\n+ * The mutator methods for an immutable headers instance unconditionally throw\n+ * {@code UnsupportedOperationException}.\n+ *\n@@ -81,0 +92,19 @@\n+    \/**\n+     * Creates a mutable {@code Headers} from the given {@code headers} with\n+     * the same header names and values.\n+     *\n+     * @param headers a map of header names and values\n+     * @throws NullPointerException if {@code headers} or any of its names or\n+     *                              values are null, or if any value contains\n+     *                              null.\n+     * @since 18\n+     *\/\n+    public Headers(Map<String,List<String>> headers) {\n+        Objects.requireNonNull(headers);\n+        var h = headers.entrySet().stream()\n+                .collect(Collectors.toUnmodifiableMap(\n+                        Entry::getKey, e -> new LinkedList<>(e.getValue())));\n+        map = new HashMap<>(32);\n+        this.putAll(h);\n+    }\n+\n@@ -257,0 +287,51 @@\n+\n+    \/**\n+     * Returns an immutable {@code Headers} with the given name value pairs as\n+     * its set of headers.\n+     *\n+     * <p> The supplied {@code String} instances must alternate as header names\n+     * and header values. To add several values to the same name, the same name\n+     * must be supplied with each new value. If the supplied {@code headers} is\n+     * empty, then an empty {@code Headers} is returned.\n+     *\n+     * @param headers the list of name value pairs\n+     * @return an immutable headers with the given name value pairs\n+     * @throws NullPointerException     if {@code headers} or any of its\n+     *                                  elements are null.\n+     * @throws IllegalArgumentException if the number of supplied strings is odd.\n+     * @since 18\n+     *\/\n+    public static Headers of(String... headers) {\n+        Objects.requireNonNull(headers);\n+        if (headers.length == 0) {\n+            return new UnmodifiableHeaders(new Headers());\n+        }\n+        if (headers.length % 2 != 0) {\n+            throw new IllegalArgumentException(\"wrong number, %d, of elements\"\n+                    .formatted(headers.length));\n+        }\n+        Arrays.stream(headers).forEach(Objects::requireNonNull);\n+\n+        var h = new Headers();\n+        for (int i = 0; i < headers.length; i += 2) {\n+            String name  = headers[i];\n+            String value = headers[i + 1];\n+            h.add(name, value);\n+        }\n+        return new UnmodifiableHeaders(h);\n+    }\n+\n+    \/**\n+     * Returns an immutable {@code Headers} from the given {@code headers} with\n+     * the same header names and values.\n+     *\n+     * @param headers a map of header names and values\n+     * @return an immutable headers\n+     * @throws NullPointerException if {@code headers} or any of its names or\n+     *                              values are null, or if any value contains\n+     *                              null.\n+     * @since 18\n+     *\/\n+    public static Headers of(Map<String,List<String>> headers) {\n+        return new UnmodifiableHeaders(new Headers(headers));\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-public abstract class HttpExchange implements AutoCloseable {\n+public abstract class HttpExchange implements AutoCloseable, Request {\n@@ -81,13 +81,2 @@\n-     * Returns an immutable {@link Headers} containing the HTTP headers that\n-     * were included with this request.\n-     *\n-     * <p> The keys in this {@code Headers} are the header names, while the\n-     * values are a {@link java.util.List} of\n-     * {@linkplain java.lang.String Strings} containing each value that was\n-     * included in the request, in the order they were included. Header fields\n-     * appearing multiple times are represented as multiple string values.\n-     *\n-     * <p> The keys in {@code Headers} are case-insensitive.\n-     *\n-     * @return a read-only {@code Headers} which can be used to access request\n-     *         headers.\n+     * {@inheritDoc}\n+     * @return {@inheritDoc}\n@@ -114,3 +103,2 @@\n-     * Returns the request {@link URI}.\n-     *\n-     * @return the request {@code URI}\n+     * {@inheritDoc}\n+     * @return {@inheritDoc}\n@@ -121,3 +109,2 @@\n-     * Returns the request method.\n-     *\n-     * @return the request method\n+     * {@inheritDoc}\n+     * @return {@inheritDoc}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpExchange.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.net.httpserver;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * Implementations of {@link com.sun.net.httpserver.HttpHandler HttpHandler}\n+ * that implement various useful handlers, such as a static response handler,\n+ * or a conditional handler that complements one handler with another.\n+ *\n+ * <p> The factory method {@link #of(int, Headers, String)} provides a\n+ * means to create handlers with pre-set static response state. For example, a\n+ * {@code jsonHandler} that always returns <i>200<\/i> with the same json:\n+ * <pre>{@code\n+ *    HttpHandlers.of(200,\n+ *                    Headers.of(\"Content-Type\", \"application\/json\"),\n+ *                    Files.readString(Path.of(\"some.json\")));\n+ * }<\/pre>\n+ * or a {@code notAllowedHandler} that always replies with <i>405<\/i> -\n+ * Method Not Allowed, and indicates the set of methods that are allowed:\n+ * <pre>{@code\n+ *    HttpHandlers.of(405, Headers.of(\"Allow\", \"GET\"), \"\");\n+ * }<\/pre>\n+ *\n+ * <p> The functionality of a handler can be extended or enhanced through the\n+ * use of {@link #handleOrElse(Predicate, HttpHandler, HttpHandler) handleOrElse},\n+ * which allows to complement a given handler. For example, complementing a\n+ * {@code jsonHandler} with <i>notAllowedHandler<\/i>:\n+ *\n+ * <pre>{@code\n+ *    Predicate<Request> IS_GET = r -> r.getRequestMethod().equals(\"GET\");\n+ *    var handler = HttpHandlers.handleOrElse(IS_GET, jsonHandler, notAllowedHandler);\n+ * }<\/pre>\n+ *\n+ * The above <i>handleOrElse<\/i> {@code handler} offers an if-else like construct;\n+ * if the request method is \"GET\" then handling of the exchange is delegated to\n+ * the {@code jsonHandler}, otherwise handling of the exchange is delegated to\n+ * the {@code notAllowedHandler}.\n+ *\n+ * @since 18\n+ *\/\n+public final class HttpHandlers {\n+\n+    private HttpHandlers() { }\n+\n+    \/**\n+     * Complements a conditional {@code HttpHandler} with another handler.\n+     *\n+     * <p> This method creates a <i>handleOrElse<\/i> handler; an if-else like\n+     * construct. Exchanges who's request matches the {@code handlerTest}\n+     * predicate are handled by the {@code handler}. All remaining exchanges\n+     * are handled by the {@code fallbackHandler}.\n+     *\n+     * <p> Example of a nested handleOrElse handler:\n+     * <pre>{@code\n+     *    Predicate<Request> IS_GET = r -> r.getRequestMethod().equals(\"GET\");\n+     *    Predicate<Request> WANTS_DIGEST =  r -> r.getRequestHeaders().containsKey(\"Want-Digest\");\n+     *\n+     *    var h1 = new SomeHandler();\n+     *    var h2 = HttpHandlers.handleOrElse(IS_GET, new SomeGetHandler(), h1);\n+     *    var h3 = HttpHandlers.handleOrElse(WANTS_DIGEST.and(IS_GET), new SomeDigestHandler(), h2);\n+     * }<\/pre>\n+     * The {@code h3} handleOrElse handler delegates handling of the exchange to\n+     * {@code SomeDigestHandler} if the \"Want-Digest\" request header is present\n+     * and the request method is {@code GET}, otherwise it delegates handling of\n+     * the exchange to the {@code h2} handler. The {@code h2} handleOrElse\n+     * handler, in turn, delegates handling of the exchange to {@code\n+     * SomeGetHandler} if the request method is {@code GET}, otherwise it\n+     * delegates handling of the exchange to the {@code h1} handler. The {@code\n+     * h1} handler handles all exchanges that are not previously delegated to\n+     * either {@code SomeGetHandler} or {@code SomeDigestHandler}.\n+     *\n+     * @param handlerTest a request predicate\n+     * @param handler a conditional handler\n+     * @param fallbackHandler a fallback handler\n+     * @return a handler\n+     * @throws NullPointerException if any argument is null\n+     *\/\n+    public static HttpHandler handleOrElse(Predicate<Request> handlerTest,\n+                                           HttpHandler handler,\n+                                           HttpHandler fallbackHandler) {\n+        Objects.requireNonNull(handlerTest);\n+        Objects.requireNonNull(handler);\n+        Objects.requireNonNull(fallbackHandler);\n+        return exchange -> {\n+            if (handlerTest.test(exchange))\n+                handler.handle(exchange);\n+            else\n+                fallbackHandler.handle(exchange);\n+        };\n+    }\n+\n+    \/**\n+     * Returns an {@code HttpHandler} that sends a response comprising the given\n+     * {@code statusCode}, {@code headers}, and {@code body}.\n+     *\n+     * <p> This method creates a handler that reads and discards the request\n+     * body before it sets the response state and sends the response.\n+     *\n+     * <p> {@code headers} are the effective headers of the response. The\n+     * response <i>body bytes<\/i> are a {@code UTF-8} encoded byte sequence of\n+     * {@code body}. The response headers\n+     * {@linkplain HttpExchange#sendResponseHeaders(int, long) are sent} with\n+     * the given {@code statusCode} and the body bytes' length (or {@code -1}\n+     * if the body is empty). The body bytes are then sent as response body,\n+     * unless the body is empty, in which case no response body is sent.\n+     *\n+     * @param statusCode a response status code\n+     * @param headers a headers\n+     * @param body a response body string\n+     * @return a handler\n+     * @throws IllegalArgumentException if statusCode is not a positive 3-digit\n+     *                                  integer, as per rfc2616, section 6.1.1\n+     * @throws NullPointerException     if headers or body are null\n+     *\/\n+    public static HttpHandler of(int statusCode, Headers headers, String body) {\n+        if (statusCode < 100 || statusCode > 999)\n+            throw new IllegalArgumentException(\"statusCode must be 3-digit: \"\n+                    + statusCode);\n+        Objects.requireNonNull(headers);\n+        Objects.requireNonNull(body);\n+\n+        final var headersCopy = Headers.of(headers);\n+        final var bytes = body.getBytes(StandardCharsets.UTF_8);\n+\n+        return exchange -> {\n+            try (exchange) {\n+                exchange.getRequestBody().readAllBytes();\n+                exchange.getResponseHeaders().putAll(headersCopy);\n+                if (exchange.getRequestMethod().equals(\"HEAD\")) {\n+                    exchange.getResponseHeaders().set(\"Content-Length\", Integer.toString(bytes.length));\n+                    exchange.sendResponseHeaders(statusCode, -1);\n+                }\n+                else if (bytes.length == 0) {\n+                    exchange.sendResponseHeaders(statusCode, -1);\n+                } else {\n+                    exchange.sendResponseHeaders(statusCode, bytes.length);\n+                    exchange.getResponseBody().write(bytes);\n+                }\n+            }\n+        };\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpHandlers.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Arrays;\n+import java.util.Objects;\n@@ -153,0 +155,52 @@\n+    \/**\n+     * Creates an {@code HttpServer} instance with an initial context.\n+     *\n+     * <p> The server is created with an <i>initial context<\/i> that maps the\n+     * URI {@code path} to the exchange {@code handler}. The initial context is\n+     * created as if by an invocation of\n+     * {@link HttpServer#createContext(String) createContext(path)}. The\n+     * {@code filters}, if any, are added to the initial context, in the order\n+     * they are given. The returned server is not started so can be configured\n+     * further if required.\n+     *\n+     * <p> The server instance will bind to the given\n+     * {@link java.net.InetSocketAddress}.\n+     *\n+     * <p> A maximum backlog can also be specified. This is the maximum number\n+     * of queued incoming connections to allow on the listening socket.\n+     * Queued TCP connections exceeding this limit may be rejected by\n+     * the TCP implementation. The HttpServer is acquired from the currently\n+     * installed {@link HttpServerProvider}.\n+     *\n+     * @param addr    the address to listen on, if {@code null} then\n+     *                {@link #bind bind} must be called to set the address\n+     * @param backlog the socket backlog. If this value is less than or\n+     *                equal to zero, then a system default value is used\n+     * @param path    the root URI path of the context, must be absolute\n+     * @param handler the HttpHandler for the context\n+     * @param filters the Filters for the context, optional\n+     * @return the HttpServer\n+     * @throws BindException            if the server cannot bind to the address\n+     * @throws IOException              if an I\/O error occurs\n+     * @throws IllegalArgumentException if path is invalid\n+     * @throws NullPointerException     if any of: {@code path}, {@code handler},\n+     *        {@code filters}, or any element of {@code filters}, are {@code null}\n+     * @since 18\n+     *\/\n+    public static HttpServer create(InetSocketAddress addr,\n+                                    int backlog,\n+                                    String path,\n+                                    HttpHandler handler,\n+                                    Filter... filters) throws IOException {\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(handler);\n+        Objects.requireNonNull(filters);\n+        Arrays.stream(filters).forEach(Objects::requireNonNull);\n+\n+        HttpServer server = HttpServer.create(addr, backlog);\n+        HttpContext context = server.createContext(path);\n+        context.setHandler(handler);\n+        Arrays.stream(filters).forEach(f -> context.getFilters().add(f));\n+        return server;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpServer.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n@@ -95,0 +98,55 @@\n+    \/**\n+     * Creates an {@code HttpsServer} instance with an initial context.\n+     *\n+     * <p> The server is created with an <i>initial context<\/i> that maps the\n+     * URI {@code path} to the exchange {@code handler}. The initial context is\n+     * created as if by an invocation of\n+     * {@link HttpsServer#createContext(String) createContext(path)}. The\n+     * {@code filters}, if any, are added to the initial context, in the order\n+     * they are given. The returned server is not started so can be configured\n+     * further if required.\n+     *\n+     * <p> The server instance will bind to the given\n+     * {@link java.net.InetSocketAddress}.\n+     *\n+     * <p> A maximum backlog can also be specified. This is the maximum number\n+     * of queued incoming connections to allow on the listening socket.\n+     * Queued TCP connections exceeding this limit may be rejected by\n+     * the TCP implementation. The HttpsServer is acquired from the currently\n+     * installed {@link HttpServerProvider}.\n+     *\n+     * <p> The server must have an HttpsConfigurator established with\n+     * {@link #setHttpsConfigurator(HttpsConfigurator)}.\n+     *\n+     * @param addr    the address to listen on, if {@code null} then\n+     *                {@link #bind bind} must be called to set the address\n+     * @param backlog the socket backlog. If this value is less than or\n+     *                equal to zero, then a system default value is used\n+     * @param path    the root URI path of the context, must be absolute\n+     * @param handler the HttpHandler for the context\n+     * @param filters the Filters for the context, optional\n+     * @return the HttpsServer\n+     * @throws BindException            if the server cannot bind to the address\n+     * @throws IOException              if an I\/O error occurs\n+     * @throws IllegalArgumentException if path is invalid\n+     * @throws NullPointerException     if any of: {@code path}, {@code handler},\n+     *        {@code filters}, or any element of {@code filters}, are {@code null}\n+     * @since 18\n+     *\/\n+    public static HttpsServer create(InetSocketAddress addr,\n+                                    int backlog,\n+                                    String path,\n+                                    HttpHandler handler,\n+                                    Filter... filters) throws IOException {\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(handler);\n+        Objects.requireNonNull(filters);\n+        Arrays.stream(filters).forEach(Objects::requireNonNull);\n+\n+        HttpsServer server = HttpsServer.create(addr, backlog);\n+        HttpContext context = server.createContext(path);\n+        context.setHandler(handler);\n+        Arrays.stream(filters).forEach(f -> context.getFilters().add(f));\n+        return server;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/HttpsServer.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.net.httpserver;\n+\n+import java.net.URI;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * A view of the immutable request state of an HTTP exchange.\n+ *\n+ * @since 18\n+ *\/\n+public interface Request {\n+\n+    \/**\n+     * Returns the request {@link URI}.\n+     *\n+     * @return the request {@code URI}\n+     *\/\n+    URI getRequestURI();\n+\n+    \/**\n+     * Returns the request method.\n+     *\n+     * @return the request method string\n+     *\/\n+    String getRequestMethod();\n+\n+    \/**\n+     * Returns an immutable {@link Headers} containing the HTTP headers that\n+     * were included with this request.\n+     *\n+     * <p> The keys in this {@code Headers} are the header names, while the\n+     * values are a {@link java.util.List} of\n+     * {@linkplain java.lang.String Strings} containing each value that was\n+     * included in the request, in the order they were included. Header fields\n+     * appearing multiple times are represented as multiple string values.\n+     *\n+     * <p> The keys in {@code Headers} are case-insensitive.\n+     *\n+     * @return a read-only {@code Headers} which can be used to access request\n+     *         headers.\n+     *\/\n+    Headers getRequestHeaders();\n+\n+    \/**\n+     * Returns an identical {@code Request} with an additional header.\n+     *\n+     * <p> The returned {@code Request} has the same set of\n+     * {@link #getRequestHeaders() headers} as {@code this} request, but with\n+     * the addition of the given header. All other request state remains\n+     * unchanged.\n+     *\n+     * <p> If {@code this} request already contains a header with the same name\n+     * as the given {@code headerName}, then its value is not replaced.\n+     *\n+     * @implSpec\n+     * The default implementation first creates a new {@code Headers}, {@code h},\n+     * then adds all the request headers from {@code this} request to {@code h},\n+     * then adds the given name-values mapping if {@code headerName} is\n+     * not present in {@code h}. Then an unmodifiable view, {@code h'}, of\n+     * {@code h} and a new {@code Request}, {@code r}, are created.\n+     * The {@code getRequestMethod} and {@code getRequestURI} methods of\n+     * {@code r} simply invoke the equivalently named method of {@code this}\n+     * request. The {@code getRequestHeaders} method returns {@code h'}. Lastly,\n+     * {@code r} is returned.\n+     *\n+     * @param headerName   the header name\n+     * @param headerValues the list of header values\n+     * @return a request\n+     * @throws NullPointerException if any argument is null, or if any element\n+     *                              of headerValues is null.\n+     *\/\n+    default Request with(String headerName, List<String> headerValues) {\n+        Objects.requireNonNull(headerName);\n+        Objects.requireNonNull(headerValues);\n+        final Request r = this;\n+\n+        var h = new Headers();\n+        h.putAll(r.getRequestHeaders());\n+        if (!h.containsKey(headerName)) {\n+            h.put(headerName, headerValues);\n+        }\n+        var unmodifiableHeaders = Headers.of(h);\n+        return new Request() {\n+            @Override\n+            public URI getRequestURI() { return r.getRequestURI(); }\n+\n+            @Override\n+            public String getRequestMethod() { return r.getRequestMethod(); }\n+\n+            @Override\n+            public Headers getRequestHeaders() { return unmodifiableHeaders; }\n+        };\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Request.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.net.httpserver;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetSocketAddress;\n+import java.net.URLConnection;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import sun.net.httpserver.simpleserver.FileServerHandler;\n+import sun.net.httpserver.simpleserver.OutputFilter;\n+\n+\/**\n+ * A simple HTTP file server and its components (intended for testing,\n+ * development and debugging purposes only).\n+ *\n+ * <p> A <a href=\"#server-impl\">simple file server<\/a> is composed of three\n+ * components:\n+ * <ul>\n+ *   <li> an {@link HttpServer HttpServer} that is bound to a given address, <\/li>\n+ *   <li> an {@link HttpHandler HttpHandler} that serves files from a given\n+ *        directory path, and <\/li>\n+ *   <li> an optional {@link Filter Filter} that prints log messages relating to\n+ *        the exchanges handled by the server. <\/li>\n+ * <\/ul>\n+ * The individual server components can be retrieved for reuse and extension via\n+ * the static methods provided.\n+ *\n+ * <h2>Simple file server<\/h2>\n+ *\n+ * <p> The {@link #createFileServer(InetSocketAddress,Path,OutputLevel) createFileServer}\n+ * static factory method returns an {@link HttpServer HttpServer} that is a\n+ * simple out-of-the-box file server. The server comes with an initial handler\n+ * that serves files from a given directory path (and its subdirectories).\n+ * The output level determines what log messages are printed to\n+ * {@code System.out}, if any.\n+ *\n+ * <p> Example of a simple file server:\n+ * <pre>{@code\n+ *    var addr = new InetSocketAddress(8080);\n+ *    var server = SimpleFileServer.createFileServer(addr, Path.of(\"\/some\/path\"), OutputLevel.INFO);\n+ *    server.start();\n+ * }<\/pre>\n+ *\n+ * <h2>File handler<\/h2>\n+ *\n+ * <p> The {@link #createFileHandler(Path) createFileHandler} static factory\n+ * method returns an {@code HttpHandler} that serves files and directory\n+ * listings. The handler supports only the <i>HEAD<\/i> and <i>GET<\/i> request\n+ * methods; to handle other request methods, one can either add additional\n+ * handlers to the server, or complement the file handler by composing a single\n+ * handler via\n+ * {@link HttpHandlers#handleOrElse(Predicate, HttpHandler, HttpHandler)}.\n+ *\n+ * <p>Example of composing a single handler:\n+ * <pre>{@code\n+ *    var handler = HttpHandlers.handleOrElse(\n+ *        (req) -> req.getRequestMethod().equals(\"PUT\"),\n+ *        (exchange) -> {\n+ *            \/\/ validate and handle PUT request\n+ *        },\n+ *        SimpleFileServer.createFileHandler(Path.of(\"\/some\/path\")))\n+ *    );\n+ * }<\/pre>\n+ *\n+ * <h2>Output filter<\/h2>\n+ *\n+ * <p> The {@link #createOutputFilter(OutputStream, OutputLevel) createOutputFilter}\n+ * static factory method returns a\n+ * {@link Filter#afterHandler(String, Consumer) post-processing filter} that\n+ * prints log messages relating to the exchanges handled by the server. The\n+ * output format is specified by the {@link OutputLevel outputLevel}.\n+ *\n+ * <p> Example of an output filter:\n+ * <pre>{@code\n+ *    var filter = SimpleFileServer.createOutputFilter(System.out, OutputLevel.VERBOSE);\n+ *    var server = HttpServer.create(new InetSocketAddress(8080), 10, \"\/some\/path\/\", new SomeHandler(), filter);\n+ *    server.start();\n+ * }<\/pre>\n+ *\n+ * <h2>Main entry point<\/h2>\n+ *\n+ * <p>A <a id=\"server-impl\">simple HTTP file server implementation<\/a> is\n+ * provided via the\n+ * <a href=\"{@docRoot}\/jdk.httpserver\/module-summary.html#entry-point\">main entry point<\/a>\n+ * of the {@code jdk.httpserver} module.\n+ *\n+ * @since 18\n+ *\/\n+public final class SimpleFileServer {\n+\n+    private static final UnaryOperator<String> MIME_TABLE =\n+            URLConnection.getFileNameMap()::getContentTypeFor;\n+\n+    private SimpleFileServer() { }\n+\n+    \/**\n+     * Describes the log message output level produced by the server when\n+     * processing exchanges.\n+     *\n+     * @since 18\n+     *\/\n+    public enum OutputLevel {\n+        \/**\n+         * Used to specify no log message output level.\n+         *\/\n+        NONE,\n+\n+        \/**\n+         * Used to specify the informative log message output level.\n+         *\n+         * <p> The log message format is based on the\n+         * <a href='https:\/\/www.w3.org\/Daemon\/User\/Config\/Logging.html#common-logfile-format'>Common Logfile Format<\/a>,\n+         * that includes the following information about an {@code HttpExchange}:\n+         *\n+         * <p> {@code remotehost rfc931 authuser [date] \"request\" status bytes}\n+         *\n+         * <p> Example:\n+         * <pre>{@code\n+         *    127.0.0.1 - - [22\/Jun\/2000:13:55:36 -0700] \"GET \/example.txt HTTP\/1.1\" 200 -\n+         * }<\/pre>\n+         *\n+         * @implNote The fields {@code rfc931}, {@code authuser} and {@code bytes}\n+         * are not captured in the implementation, so are always represented as\n+         * {@code '-'}.\n+         *\/\n+        INFO,\n+\n+        \/**\n+         * Used to specify the verbose log message output level.\n+         *\n+         * <p> Additional to the information provided by the\n+         * {@linkplain OutputLevel#INFO info} level, the verbose level\n+         * includes the request and response headers of the {@code HttpExchange}\n+         * and the absolute path of the resource served up.\n+         *\/\n+        VERBOSE\n+    }\n+\n+    \/**\n+     * Creates a <i>file server<\/i> the serves files from a given path.\n+     *\n+     * <p> The server is configured with an initial context that maps the\n+     * URI {@code path} to a <i>file handler<\/i>. The <i>file handler<\/i> is\n+     * created as if by an invocation of\n+     * {@link #createFileHandler(Path) createFileHandler(rootDirectory)}, and is\n+     * associated to a context created as if by an invocation of\n+     * {@link HttpServer#createContext(String) createContext(\"\/\")}.\n+     *\n+     * <p> An output level can be given to print log messages relating to the\n+     * exchanges handled by the server. The log messages, if any, are printed to\n+     * {@code System.out}. If {@link OutputLevel#NONE OutputLevel.NONE} is\n+     * given, no log messages are printed.\n+     *\n+     * @param addr          the address to listen on\n+     * @param rootDirectory the root directory to be served, must be an absolute path\n+     * @param outputLevel   the log message output level\n+     * @return an HttpServer\n+     * @throws IllegalArgumentException if root does not exist, is not absolute,\n+     *         is not a directory, or is not readable\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     * @throws NullPointerException if any argument is null\n+     * @throws SecurityException if a security manager is installed and a\n+     *         recursive {@link java.io.FilePermission} \"{@code read}\" of the\n+     *         rootDirectory is denied\n+     *\/\n+    public static HttpServer createFileServer(InetSocketAddress addr,\n+                                              Path rootDirectory,\n+                                              OutputLevel outputLevel) {\n+        Objects.requireNonNull(addr);\n+        Objects.requireNonNull(rootDirectory);\n+        Objects.requireNonNull(outputLevel);\n+        try {\n+            var handler = FileServerHandler.create(rootDirectory, MIME_TABLE);\n+            if (outputLevel.equals(OutputLevel.NONE))\n+                return HttpServer.create(addr, 0, \"\/\", handler);\n+            else\n+                return HttpServer.create(addr, 0, \"\/\", handler, OutputFilter.create(System.out, outputLevel));\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a <i>file handler<\/i> that serves files from a given directory\n+     * path (and its subdirectories).\n+     *\n+     * <p> The file handler resolves the request URI against the given\n+     * {@code rootDirectory} path to determine the path {@code p} on the\n+     * associated file system to serve the response. If the path {@code p} is\n+     * a directory, then the response contains a directory listing, formatted in\n+     * HTML, as the response body. If the path {@code p} is a file, then the\n+     * response contains a \"Content-Type\" header based on the best-guess\n+     * content type, as determined by an invocation of\n+     * {@linkplain java.net.FileNameMap#getContentTypeFor(String) getContentTypeFor},\n+     * on the system-wide {@link URLConnection#getFileNameMap() mimeTable}, as\n+     * well as the contents of the file as the response body.\n+     *\n+     * <p> The handler supports only requests with the <i>HEAD<\/i> or <i>GET<\/i>\n+     * method, and will reply with a {@code 405} response code for requests with\n+     * any other method.\n+     *\n+     * @param rootDirectory the root directory to be served, must be an absolute path\n+     * @return a file handler\n+     * @throws IllegalArgumentException if rootDirectory does not exist,\n+     *         is not absolute, is not a directory, or is not readable\n+     * @throws NullPointerException if the argument is null\n+     * @throws SecurityException if a security manager is installed and a\n+     *         recursive {@link java.io.FilePermission} \"{@code read}\" of the\n+     *         rootDirectory is denied\n+     *\/\n+    public static HttpHandler createFileHandler(Path rootDirectory) {\n+        Objects.requireNonNull(rootDirectory);\n+        return FileServerHandler.create(rootDirectory, MIME_TABLE);\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain Filter#afterHandler(String, Consumer)\n+     * post-processing Filter} that prints log messages about\n+     * {@linkplain HttpExchange exchanges}. The log messages are printed to\n+     * the given {@code OutputStream} in {@code UTF-8} encoding.\n+     *\n+     * @apiNote\n+     * To not output any log messages it is recommended to not use a filter.\n+     *\n+     * @param out         the stream to print to\n+     * @param outputLevel the output level\n+     * @return a post-processing filter\n+     * @throws IllegalArgumentException if {@link OutputLevel#NONE OutputLevel.NONE}\n+     *                                  is given\n+     * @throws NullPointerException     if any argument is null\n+     *\/\n+    public static Filter createOutputFilter(OutputStream out,\n+                                            OutputLevel outputLevel) {\n+        Objects.requireNonNull(out);\n+        Objects.requireNonNull(outputLevel);\n+        return OutputFilter.create(out, outputLevel);\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/SimpleFileServer.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,6 @@\n+   <p>\n+   The {@link com.sun.net.httpserver.SimpleFileServer} class offers a simple\n+   HTTP file server (intended for testing, development and debugging purposes\n+   only). A default implementation is provided via the\n+   <a href=\"{@docRoot}\/jdk.httpserver\/module-summary.html#entry-point\">main entry point<\/a>\n+   of the {@code jdk.httpserver} module.\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/package-info.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,34 @@\n+ * <p>\n+ * A basic high-level API for building embedded servers. Both HTTP and\n+ * HTTPS are supported.\n+ * <p>\n+ * The main components are:\n+ * <ul>\n+ * <li>the {@link com.sun.net.httpserver.HttpExchange} class that describes a\n+ * request and response pair,<\/li>\n+ * <li>the {@link com.sun.net.httpserver.HttpHandler} interface to handle\n+ * incoming requests, plus the {@link com.sun.net.httpserver.HttpHandlers} class\n+ * that provides useful handler implementations,<\/li>\n+ * <li>the {@link com.sun.net.httpserver.HttpContext} class that maps a URI path\n+ * to a {@code HttpHandler},<\/li>\n+ * <li>the {@link com.sun.net.httpserver.HttpServer} class to listen for\n+ * connections and dispatch requests to handlers,<\/li>\n+ * <li>the {@link com.sun.net.httpserver.Filter} class that allows pre- and post-\n+ * processing of requests.<\/li><\/ul>\n+ * <p>\n+ * The {@link com.sun.net.httpserver.SimpleFileServer} class offers a simple\n+ * HTTP file server (intended for testing, development and debugging purposes\n+ * only). A default implementation is provided via the <a id=\"entry-point\"><\/a>\n+ * main entry point of the {@code jdk.httpserver} module, which can be used on\n+ * the command line as such:\n+ * <pre>{@code\n+ *    Usage: java -m jdk.httpserver [-b bind address] [-p port] [-d directory]\n+ *                                  [-o none|info|verbose] [-h to show options]\n+ *    Options:\n+ *    -b, --bind-address    - Address to bind to. Default: 127.0.0.1 or ::1 (loopback).\n+ *                            For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\n+ *    -d, --directory       - Directory to serve. Default: current directory.\n+ *    -o, --output          - Output format. none|info|verbose. Default: info.\n+ *    -p, --port            - Port to listen on. Default: 8000.\n+ *    -h, -?, --help        - Print this help message.\n+ * }<\/pre>\n","filename":"src\/jdk.httpserver\/share\/classes\/module-info.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver;\n+\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpPrincipal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+\n+public abstract class DelegatingHttpExchange extends HttpExchange {\n+\n+    private final HttpExchange exchange;\n+\n+    public DelegatingHttpExchange(HttpExchange ex) {\n+        this.exchange = ex;\n+    }\n+\n+    public abstract Headers getRequestHeaders();\n+\n+    public abstract String getRequestMethod();\n+\n+    public abstract URI getRequestURI();\n+\n+    public Headers getResponseHeaders() {\n+        return exchange.getResponseHeaders();\n+    }\n+\n+    public HttpContext getHttpContext() {\n+        return exchange.getHttpContext();\n+    }\n+\n+    public void close() {\n+        exchange.close();\n+    }\n+\n+    public InputStream getRequestBody() {\n+        return exchange.getRequestBody();\n+    }\n+\n+    public int getResponseCode() {\n+        return exchange.getResponseCode();\n+    }\n+\n+    public OutputStream getResponseBody() {\n+        return exchange.getResponseBody();\n+    }\n+\n+    public void sendResponseHeaders(int rCode, long contentLen) throws IOException {\n+        exchange.sendResponseHeaders(rCode, contentLen);\n+    }\n+\n+    public InetSocketAddress getRemoteAddress() {\n+        return exchange.getRemoteAddress();\n+    }\n+\n+    public InetSocketAddress getLocalAddress() {\n+        return exchange.getLocalAddress();\n+    }\n+\n+    public String getProtocol() {\n+        return exchange.getProtocol();\n+    }\n+\n+    public Object getAttribute(String name) {\n+        return exchange.getAttribute(name);\n+    }\n+\n+    public void setAttribute(String name, Object value) {\n+        exchange.setAttribute(name, value);\n+    }\n+\n+    public void setStreams(InputStream i, OutputStream o) {\n+        exchange.setStreams(i, o);\n+    }\n+\n+    public HttpPrincipal getPrincipal() {\n+        return exchange.getPrincipal();\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/DelegatingHttpExchange.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -88,1 +88,1 @@\n-        this.reqHdrs = new UnmodifiableHeaders(req.headers());\n+        this.reqHdrs = Headers.of(req.headers());\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver.simpleserver;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.System.Logger;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.UnaryOperator;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpHandlers;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+\/**\n+ * A basic HTTP file server handler for static content.\n+ *\n+ * <p> Must be given an absolute pathname to the directory to be served.\n+ * Supports only HEAD and GET requests. Directory listings and files can be\n+ * served, content types are supported on a best-guess basis.\n+ *\/\n+public final class FileServerHandler implements HttpHandler {\n+\n+    private static final List<String> SUPPORTED_METHODS = List.of(\"HEAD\", \"GET\");\n+    private static final List<String> UNSUPPORTED_METHODS =\n+            List.of(\"CONNECT\", \"DELETE\", \"OPTIONS\", \"PATCH\", \"POST\", \"PUT\", \"TRACE\");\n+\n+    private final Path root;\n+    private final UnaryOperator<String> mimeTable;\n+    private final Logger logger;\n+\n+    private FileServerHandler(Path root, UnaryOperator<String> mimeTable) {\n+        root = root.normalize();\n+\n+        @SuppressWarnings(\"removal\")\n+        var securityManager = System.getSecurityManager();\n+        if (securityManager != null)\n+            securityManager.checkRead(pathForSecurityCheck(root.toString()));\n+\n+        if (!Files.exists(root))\n+            throw new IllegalArgumentException(\"Path does not exist: \" + root);\n+        if (!root.isAbsolute())\n+            throw new IllegalArgumentException(\"Path is not absolute: \" + root);\n+        if (!Files.isDirectory(root))\n+            throw new IllegalArgumentException(\"Path is not a directory: \" + root);\n+        if (!Files.isReadable(root))\n+            throw new IllegalArgumentException(\"Path is not readable: \" + root);\n+        this.root = root;\n+        this.mimeTable = mimeTable;\n+        this.logger = System.getLogger(\"com.sun.net.httpserver\");\n+    }\n+\n+    private static String pathForSecurityCheck(String path) {\n+        var separator = String.valueOf(File.separatorChar);\n+        return path.endsWith(separator) ? (path + \"-\") : (path + separator + \"-\");\n+    }\n+\n+    private static final HttpHandler NOT_IMPLEMENTED_HANDLER =\n+            HttpHandlers.of(501, Headers.of(), \"\");\n+\n+    private static final HttpHandler METHOD_NOT_ALLOWED_HANDLER =\n+            HttpHandlers.of(405, Headers.of(\"Allow\", \"HEAD, GET\"), \"\");\n+\n+    public static HttpHandler create(Path root, UnaryOperator<String> mimeTable) {\n+        var fallbackHandler = HttpHandlers.handleOrElse(\n+                r -> UNSUPPORTED_METHODS.contains(r.getRequestMethod()),\n+                METHOD_NOT_ALLOWED_HANDLER,\n+                NOT_IMPLEMENTED_HANDLER);\n+        return HttpHandlers.handleOrElse(\n+                r -> SUPPORTED_METHODS.contains(r.getRequestMethod()),\n+                new FileServerHandler(root, mimeTable), fallbackHandler);\n+    }\n+\n+    private void handleHEAD(HttpExchange exchange, Path path) throws IOException {\n+        handleSupportedMethod(exchange, path, false);\n+    }\n+\n+    private void handleGET(HttpExchange exchange, Path path) throws IOException {\n+        handleSupportedMethod(exchange, path, true);\n+    }\n+\n+    private void handleSupportedMethod(HttpExchange exchange, Path path, boolean writeBody)\n+        throws IOException {\n+        if (Files.isDirectory(path)) {\n+            if (missingSlash(exchange)) {\n+                handleMovedPermanently(exchange);\n+                return;\n+            }\n+            if (indexFile(path) != null) {\n+                serveFile(exchange, indexFile(path), writeBody);\n+            } else {\n+                listFiles(exchange, path, writeBody);\n+            }\n+        } else {\n+            serveFile(exchange, path, writeBody);\n+        }\n+    }\n+\n+    private void handleMovedPermanently(HttpExchange exchange) throws IOException {\n+        exchange.getResponseHeaders().set(\"Location\", getRedirectURI(exchange.getRequestURI()));\n+        exchange.sendResponseHeaders(301, -1);\n+    }\n+\n+    private void handleForbidden(HttpExchange exchange) throws IOException {\n+        exchange.sendResponseHeaders(403, -1);\n+    }\n+\n+    private void handleNotFound(HttpExchange exchange) throws IOException {\n+        String fileNotFound = ResourceBundleHelper.getMessage(\"html.not.found\");\n+        var bytes = (openHTML\n+                + \"<h1>\" + fileNotFound + \"<\/h1>\\n\"\n+                + \"<p>\" + sanitize.apply(exchange.getRequestURI().getPath()) + \"<\/p>\\n\"\n+                + closeHTML).getBytes(UTF_8);\n+        exchange.getResponseHeaders().set(\"Content-Type\", \"text\/html; charset=UTF-8\");\n+\n+        if (exchange.getRequestMethod().equals(\"HEAD\")) {\n+            exchange.getResponseHeaders().set(\"Content-Length\", Integer.toString(bytes.length));\n+            exchange.sendResponseHeaders(404, -1);\n+        } else {\n+            exchange.sendResponseHeaders(404, bytes.length);\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                os.write(bytes);\n+            }\n+        }\n+    }\n+\n+    private static void discardRequestBody(HttpExchange exchange) throws IOException {\n+        try (InputStream is = exchange.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+\n+    private String getRedirectURI(URI uri) {\n+        String query = uri.getRawQuery();\n+        String redirectPath = uri.getRawPath() + \"\/\";\n+        return query == null ? redirectPath : redirectPath + \"?\" + query;\n+    }\n+\n+    private static boolean missingSlash(HttpExchange exchange) {\n+        return !exchange.getRequestURI().getPath().endsWith(\"\/\");\n+    }\n+\n+    private static String contextPath(HttpExchange exchange) {\n+        String context = exchange.getHttpContext().getPath();\n+        if (!context.startsWith(\"\/\")) {\n+            throw new IllegalArgumentException(\"Context path invalid: \" + context);\n+        }\n+        return context;\n+    }\n+\n+    private static String requestPath(HttpExchange exchange) {\n+        String request = exchange.getRequestURI().getPath();\n+        if (!request.startsWith(\"\/\")) {\n+            throw new IllegalArgumentException(\"Request path invalid: \" + request);\n+        }\n+        return request;\n+    }\n+\n+    \/\/ Checks that the request does not escape context.\n+    private static void checkRequestWithinContext(String requestPath,\n+                                                  String contextPath) {\n+        if (requestPath.equals(contextPath)) {\n+            return;  \/\/ context path requested, e.g. context \/foo, request \/foo\n+        }\n+        String contextPathWithTrailingSlash = contextPath.endsWith(\"\/\")\n+                ? contextPath : contextPath + \"\/\";\n+        if (!requestPath.startsWith(contextPathWithTrailingSlash)) {\n+            throw new IllegalArgumentException(\"Request not in context: \" + contextPath);\n+        }\n+    }\n+\n+    \/\/ Checks that path is, or is within, the root.\n+    private static Path checkPathWithinRoot(Path path, Path root) {\n+        if (!path.startsWith(root)) {\n+            throw new IllegalArgumentException(\"Request not in root\");\n+        }\n+        return path;\n+    }\n+\n+    \/\/ Returns the request URI path relative to the context.\n+    private static String relativeRequestPath(HttpExchange exchange) {\n+        String context = contextPath(exchange);\n+        String request = requestPath(exchange);\n+        checkRequestWithinContext(request, context);\n+        return request.substring(context.length());\n+    }\n+\n+    private Path mapToPath(HttpExchange exchange, Path root) {\n+        try {\n+            assert root.isAbsolute() && Files.isDirectory(root);  \/\/ checked during creation\n+            String uriPath = relativeRequestPath(exchange);\n+            String[] pathSegment = uriPath.split(\"\/\");\n+\n+            \/\/ resolve each path segment against the root\n+            Path path = root;\n+            for (var segment : pathSegment) {\n+                path = path.resolve(segment);\n+                if (!Files.isReadable(path) || isHiddenOrSymLink(path)) {\n+                    return null;  \/\/ stop resolution, null results in 404 response\n+                }\n+            }\n+            path = path.normalize();\n+            return checkPathWithinRoot(path, root);\n+        } catch (Exception e) {\n+            logger.log(System.Logger.Level.TRACE,\n+                    \"FileServerHandler: request URI path resolution failed\", e);\n+            return null;  \/\/ could not resolve request URI path\n+        }\n+    }\n+\n+    private static Path indexFile(Path path) {\n+        Path html = path.resolve(\"index.html\");\n+        Path htm = path.resolve(\"index.htm\");\n+        return Files.exists(html) ? html : Files.exists(htm) ? htm : null;\n+    }\n+\n+    private void serveFile(HttpExchange exchange, Path path, boolean writeBody)\n+        throws IOException\n+    {\n+        var respHdrs = exchange.getResponseHeaders();\n+        respHdrs.set(\"Content-Type\", mediaType(path.toString()));\n+        respHdrs.set(\"Last-Modified\", getLastModified(path));\n+        if (writeBody) {\n+            exchange.sendResponseHeaders(200, Files.size(path));\n+            try (InputStream fis = Files.newInputStream(path);\n+                 OutputStream os = exchange.getResponseBody()) {\n+                fis.transferTo(os);\n+            }\n+        } else {\n+            respHdrs.set(\"Content-Length\", Long.toString(Files.size(path)));\n+            exchange.sendResponseHeaders(200, -1);\n+        }\n+    }\n+\n+    private void listFiles(HttpExchange exchange, Path path, boolean writeBody)\n+        throws IOException\n+    {\n+        var respHdrs = exchange.getResponseHeaders();\n+        respHdrs.set(\"Content-Type\", \"text\/html; charset=UTF-8\");\n+        respHdrs.set(\"Last-Modified\", getLastModified(path));\n+        var bodyBytes = dirListing(exchange, path).getBytes(UTF_8);\n+        if (writeBody) {\n+            exchange.sendResponseHeaders(200, bodyBytes.length);\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                os.write(bodyBytes);\n+            }\n+        } else {\n+            respHdrs.set(\"Content-Length\", Integer.toString(bodyBytes.length));\n+            exchange.sendResponseHeaders(200, -1);\n+        }\n+    }\n+\n+    private static final String openHTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html>\n+            <head>\n+            <meta charset=\"utf-8\"\/>\n+            <\/head>\n+            <body>\n+            \"\"\";\n+\n+    private static final String closeHTML = \"\"\"\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+\n+    private static final String hrefListItemTemplate = \"\"\"\n+            <li><a href=\"%s\">%s<\/a><\/li>\n+            \"\"\";\n+\n+    private static String hrefListItemFor(URI uri) {\n+        return hrefListItemTemplate.formatted(uri.toASCIIString(), sanitize.apply(uri.getPath()));\n+    }\n+\n+    private static String dirListing(HttpExchange exchange, Path path) throws IOException {\n+        String dirListing = ResourceBundleHelper.getMessage(\"html.dir.list\");\n+        var sb = new StringBuilder(openHTML\n+                + \"<h1>\" + dirListing + \" \"\n+                + sanitize.apply(exchange.getRequestURI().getPath())\n+                + \"<\/h1>\\n\"\n+                + \"<ul>\\n\");\n+        try (var paths = Files.list(path)) {\n+            paths.filter(p -> Files.isReadable(p) && !isHiddenOrSymLink(p))\n+                 .map(p -> path.toUri().relativize(p.toUri()))\n+                 .forEach(uri -> sb.append(hrefListItemFor(uri)));\n+        }\n+        sb.append(\"<\/ul>\\n\");\n+        sb.append(closeHTML);\n+\n+        return sb.toString();\n+    }\n+\n+    private static String getLastModified(Path path) throws IOException {\n+        var fileTime = Files.getLastModifiedTime(path);\n+        return fileTime.toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+\n+    private static boolean isHiddenOrSymLink(Path path) {\n+        try {\n+            return Files.isHidden(path) || Files.isSymbolicLink(path);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/\/ Default for unknown content types, as per RFC 2046\n+    private static final String DEFAULT_CONTENT_TYPE = \"application\/octet-stream\";\n+\n+    private String mediaType(String file) {\n+        String type = mimeTable.apply(file);\n+        return type != null ? type : DEFAULT_CONTENT_TYPE;\n+    }\n+\n+    \/\/ A non-exhaustive map of reserved-HTML and special characters to their\n+    \/\/ equivalent entity.\n+    private static final Map<Integer,String> RESERVED_CHARS = Map.of(\n+            (int) '&'  , \"&amp;\"   ,\n+            (int) '<'  , \"&lt;\"    ,\n+            (int) '>'  , \"&gt;\"    ,\n+            (int) '\"'  , \"&quot;\"  ,\n+            (int) '\\'' , \"&#x27;\"  ,\n+            (int) '\/'  , \"&#x2F;\"  );\n+\n+    \/\/ A function that takes a string and returns a sanitized version of that\n+    \/\/ string with the reserved-HTML and special characters replaced with their\n+    \/\/ equivalent entity.\n+    private static final UnaryOperator<String> sanitize =\n+            file -> file.chars().collect(StringBuilder::new,\n+                    (sb, c) -> sb.append(RESERVED_CHARS.getOrDefault(c, Character.toString(c))),\n+                    StringBuilder::append).toString();\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        assert List.of(\"GET\", \"HEAD\").contains(exchange.getRequestMethod());\n+        try (exchange) {\n+            discardRequestBody(exchange);\n+            Path path = mapToPath(exchange, root);\n+            if (path != null) {\n+                exchange.setAttribute(\"request-path\", path.toString());  \/\/ store for OutputFilter\n+                if (!Files.exists(path) || !Files.isReadable(path) || isHiddenOrSymLink(path)) {\n+                    handleNotFound(exchange);\n+                } else if (exchange.getRequestMethod().equals(\"HEAD\")) {\n+                    handleHEAD(exchange, path);\n+                } else {\n+                    handleGET(exchange, path);\n+                }\n+            } else {\n+                exchange.setAttribute(\"request-path\", \"could not resolve request URI path\");\n+                handleNotFound(exchange);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/FileServerHandler.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver.simpleserver;\n+\n+import java.io.PrintWriter;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+\/**\n+ * Programmatic entry point to start the simpleserver tool.\n+ *\n+ * <p><b> This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interface are subject to change or deletion\n+ * without notice.<\/b>\n+ *\/\n+public class Main {\n+\n+    \/**\n+     * This constructor should never be called.\n+     *\/\n+    private Main() { throw new AssertionError(); }\n+\n+    \/**\n+     * The main entry point.\n+     *\n+     * <p> The command line arguments are parsed and the server is started. If\n+     * started successfully, the server will run on a new non-daemon thread,\n+     * and this method will return. Otherwise, if the server is not started\n+     * successfully, e.g. an error is encountered while parsing the arguments\n+     * or an I\/O error occurs, the server is not started and this method invokes\n+     * System::exit with an appropriate exit code.\n+     *\n+     * @param args the command-line options\n+     * @throws NullPointerException if {@code args} is {@code null}, or if there\n+     *         are any {@code null} values in the {@code args} array\n+     *\/\n+    public static void main(String... args) {\n+        int ec = SimpleFileServerImpl.start(new PrintWriter(System.out, true, UTF_8), args);\n+        if (ec != 0)\n+            System.exit(ec);\n+        \/\/ otherwise the server has been started successfully and runs in\n+        \/\/ another non-daemon thread.\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/Main.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver.simpleserver;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.function.Consumer;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+\/**\n+ * A Filter that outputs log messages about an HttpExchange. The implementation\n+ * uses a {@link Filter#afterHandler(String, Consumer) post-processing filter}.\n+ *\n+ * <p> If the outputLevel is INFO, the format is based on the\n+ * <a href='https:\/\/www.w3.org\/Daemon\/User\/Config\/Logging.html#common-logfile-format'>Common Logfile Format<\/a>.\n+ * In this case the output includes the following information about an exchange:\n+ *\n+ * <p> remotehost rfc931 authuser [date] \"request line\" status bytes\n+ *\n+ * <p> Example:\n+ * 127.0.0.1 - - [22\/Jun\/2000:13:55:36 -0700] \"GET \/example.txt HTTP\/1.1\" 200 -\n+ *\n+ * <p> The fields rfc931, authuser and bytes are not captured in the implementation\n+ * and are always represented as '-'.\n+ *\n+ * <p> If the outputLevel is VERBOSE, the output additionally includes the\n+ * absolute path of the resource requested, if it has been\n+ * {@linkplain HttpExchange#setAttribute(String, Object) provided} via the\n+ * attribute {@code \"request-path\"}, as well as the request and response headers\n+ * of the exchange.\n+ *\/\n+public final class OutputFilter extends Filter {\n+    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(\"dd\/MMM\/yyyy:HH:mm:ss Z\");\n+    private final PrintStream printStream;\n+    private final OutputLevel outputLevel;\n+    private final Filter filter;\n+\n+    private OutputFilter(OutputStream os, OutputLevel outputLevel) {\n+        printStream = new PrintStream(os, true, UTF_8);\n+        this.outputLevel = outputLevel;\n+        var description = \"HttpExchange OutputFilter (outputLevel: \" + outputLevel + \")\";\n+        this.filter = Filter.afterHandler(description, operation());\n+    }\n+\n+    public static OutputFilter create(OutputStream os, OutputLevel outputLevel) {\n+        if (outputLevel.equals(OutputLevel.NONE)) {\n+            throw new IllegalArgumentException(\"Not a valid outputLevel: \" + outputLevel);\n+        }\n+        return new OutputFilter(os, outputLevel);\n+    }\n+\n+    private Consumer<HttpExchange> operation() {\n+        return e -> {\n+            String s = e.getRemoteAddress().getHostString() + \" \"\n+                    + \"- - \"    \/\/ rfc931 and authuser\n+                    + \"[\" + OffsetDateTime.now().format(FORMATTER) + \"] \"\n+                    + \"\\\"\" + e.getRequestMethod() + \" \" + e.getRequestURI() + \" \" + e.getProtocol() + \"\\\" \"\n+                    + e.getResponseCode() + \" -\";    \/\/ bytes\n+            printStream.println(s);\n+\n+            if (outputLevel.equals(OutputLevel.VERBOSE)) {\n+                if (e.getAttribute(\"request-path\") instanceof String requestPath) {\n+                    printStream.println(\"Resource requested: \" + requestPath);\n+                }\n+                logHeaders(\">\", e.getRequestHeaders());\n+                logHeaders(\"<\", e.getResponseHeaders());\n+            }\n+        };\n+    }\n+\n+    private void logHeaders(String sign, Headers headers) {\n+        headers.forEach((name, values) -> {\n+            var sb = new StringBuilder();\n+            var it = values.iterator();\n+            while (it.hasNext()) {\n+                sb.append(it.next());\n+                if (it.hasNext()) {\n+                    sb.append(\", \");\n+                }\n+            }\n+            printStream.println(sign + \" \" + name + \": \" + sb);\n+        });\n+        printStream.println(sign);\n+    }\n+\n+    @Override\n+    public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+        try  {\n+            filter.doFilter(exchange, chain);\n+        } catch (Throwable t) {\n+            if (!outputLevel.equals(OutputLevel.NONE)) {\n+                reportError(ResourceBundleHelper.getMessage(\"err.server.handle.failed\",\n+                        t.getMessage()));\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public String description() { return filter.description(); }\n+\n+    private void reportError(String message) {\n+        printStream.println(ResourceBundleHelper.getMessage(\"error.prefix\") + \" \" + message);\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/OutputFilter.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver.simpleserver;\n+\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+class ResourceBundleHelper {\n+    static final ResourceBundle bundle;\n+\n+    static {\n+        try {\n+            bundle = ResourceBundle.getBundle(\"sun.net.httpserver.simpleserver.resources.simpleserver\");\n+        } catch (MissingResourceException e) {\n+            throw new InternalError(\"Cannot find simpleserver resource bundle for locale \" + Locale.getDefault());\n+        }\n+    }\n+\n+    static String getMessage(String key, Object... args) {\n+        try {\n+            return MessageFormat.format(bundle.getString(key), args);\n+        } catch (MissingResourceException e) {\n+            throw new InternalError(\"Missing message: \" + key);\n+        }\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/ResourceBundleHelper.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.net.httpserver.simpleserver;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+\n+\/**\n+ * A class that provides a simple HTTP file server to serve the content of\n+ * a given directory.\n+ *\n+ * <p> The server is an HttpServer bound to a given address. It comes with an\n+ * HttpHandler that serves files from a given directory path\n+ * (and its subdirectories) on the default file system, and an optional Filter\n+ * that prints log messages related to the exchanges handled by the server to\n+ * a given output stream.\n+ *\n+ * <p> Unless specified as arguments, the default values are:<ul>\n+ * <li>bind address: 127.0.0.1 or ::1 (loopback)<\/li>\n+ * <li>directory: current working directory<\/li>\n+ * <li>outputLevel: info<\/li><\/ul>\n+ * <li>port: 8000<\/li>\n+ * <p>\n+ * The implementation is provided via the main entry point of the jdk.httpserver\n+ * module.\n+ *\/\n+final class SimpleFileServerImpl {\n+    private static final InetAddress LOOPBACK_ADDR = InetAddress.getLoopbackAddress();\n+    private static final int DEFAULT_PORT = 8000;\n+    private static final Path DEFAULT_ROOT = Path.of(\"\").toAbsolutePath();\n+    private static final OutputLevel DEFAULT_OUTPUT_LEVEL = OutputLevel.INFO;\n+    private static boolean addrSpecified = false;\n+\n+    private SimpleFileServerImpl() { throw new AssertionError(); }\n+\n+    \/**\n+     * Starts a simple HTTP file server created on a directory.\n+     *\n+     * @param  writer the writer to which output should be written\n+     * @param  args the command line options\n+     * @throws NullPointerException if any of the arguments are {@code null},\n+     *         or if there are any {@code null} values in the {@code args} array\n+     * @return startup status code\n+     *\/\n+    static int start(PrintWriter writer, String[] args) {\n+        Objects.requireNonNull(args);\n+        for (var arg : args) {\n+            Objects.requireNonNull(arg);\n+        }\n+        Out out = new Out(writer);\n+\n+        InetAddress addr = LOOPBACK_ADDR;\n+        int port = DEFAULT_PORT;\n+        Path root = DEFAULT_ROOT;\n+        OutputLevel outputLevel = DEFAULT_OUTPUT_LEVEL;\n+\n+        \/\/ parse options\n+        Iterator<String> options = Arrays.asList(args).iterator();\n+        String option = null;\n+        String optionArg = null;\n+        try {\n+            while (options.hasNext()) {\n+                option = options.next();\n+                switch (option) {\n+                    case \"-h\", \"-?\", \"--help\" -> {\n+                        out.showHelp();\n+                        return Startup.OK.statusCode;\n+                    }\n+                    case \"-b\", \"--bind-address\" -> {\n+                        addr = InetAddress.getByName(optionArg = options.next());\n+                        addrSpecified = true;\n+                    }\n+                    case \"-d\", \"--directory\" ->\n+                        root = Path.of(optionArg = options.next());\n+                    case \"-o\", \"--output\" ->\n+                        outputLevel = Enum.valueOf(OutputLevel.class,\n+                                (optionArg = options.next()).toUpperCase(Locale.ROOT));\n+                    case \"-p\", \"--port\" ->\n+                        port = Integer.parseInt(optionArg = options.next());\n+                    default -> throw new AssertionError();\n+                }\n+            }\n+        } catch (AssertionError ae) {\n+            out.reportError(ResourceBundleHelper.getMessage(\"err.unknown.option\", option));\n+            out.showUsage();\n+            return Startup.CMDERR.statusCode;\n+        } catch (NoSuchElementException nsee) {\n+            out.reportError(ResourceBundleHelper.getMessage(\"err.missing.arg\", option));\n+            out.showOption(option);\n+            return Startup.CMDERR.statusCode;\n+        } catch (Exception e) {\n+            out.reportError(ResourceBundleHelper.getMessage(\"err.invalid.arg\", option, optionArg));\n+            e.printStackTrace(out.writer);\n+            return Startup.CMDERR.statusCode;\n+        } finally {\n+            out.flush();\n+        }\n+\n+        \/\/ configure and start server\n+        try {\n+            var socketAddr = new InetSocketAddress(addr, port);\n+            var server = SimpleFileServer.createFileServer(socketAddr, root, outputLevel);\n+            server.start();\n+            out.printStartMessage(root, server);\n+        } catch (Throwable t) {\n+            out.reportError(ResourceBundleHelper.getMessage(\"err.server.config.failed\", t.getMessage()));\n+            return Startup.SYSERR.statusCode;\n+        } finally {\n+            out.flush();\n+        }\n+        return Startup.OK.statusCode;\n+    }\n+\n+    private final static class Out {\n+        private final PrintWriter writer;\n+        private Out() { throw new AssertionError(); }\n+\n+        Out(PrintWriter writer) {\n+            this.writer = Objects.requireNonNull(writer);\n+        }\n+\n+        void printStartMessage(Path root, HttpServer server)\n+                throws UnknownHostException\n+        {\n+            String port = Integer.toString(server.getAddress().getPort());\n+            var inetAddr = server.getAddress().getAddress();\n+            var isAnyLocal = inetAddr.isAnyLocalAddress();\n+            var addr = isAnyLocal ? InetAddress.getLocalHost().getHostAddress() : inetAddr.getHostAddress();\n+            if (!addrSpecified) {\n+                writer.println(ResourceBundleHelper.getMessage(\"loopback.info\"));\n+            }\n+            if (isAnyLocal) {\n+                writer.println(ResourceBundleHelper.getMessage(\"msg.start.anylocal\", root, addr, port));\n+            } else {\n+                writer.println(ResourceBundleHelper.getMessage(\"msg.start.other\", root, addr, port));\n+            }\n+        }\n+\n+        void showUsage() {\n+            writer.println(ResourceBundleHelper.getMessage(\"usage\"));\n+        }\n+\n+        void showHelp() {\n+            writer.println(ResourceBundleHelper.getMessage(\"usage\"));\n+            writer.println(ResourceBundleHelper.getMessage(\"options\", LOOPBACK_ADDR.getHostAddress()));\n+        }\n+\n+        void showOption(String option) {\n+            switch (option) {\n+                case \"-b\", \"--bind-address\" ->\n+                        writer.println(ResourceBundleHelper.getMessage(\"opt.bindaddress\", LOOPBACK_ADDR.getHostAddress()));\n+                case \"-d\", \"--directory\" ->\n+                        writer.println(ResourceBundleHelper.getMessage(\"opt.directory\"));\n+                case \"-o\", \"--output\" ->\n+                        writer.println(ResourceBundleHelper.getMessage(\"opt.output\"));\n+                case \"-p\", \"--port\" ->\n+                        writer.println(ResourceBundleHelper.getMessage(\"opt.port\"));\n+            }\n+        }\n+\n+        void reportError(String message) {\n+            writer.println(ResourceBundleHelper.getMessage(\"error.prefix\") + \" \" + message);\n+        }\n+\n+        void flush() {\n+            writer.flush();\n+        }\n+    }\n+\n+    private enum Startup {\n+        \/** Started with no errors *\/\n+        OK(0),\n+        \/** Not started, bad command-line arguments *\/\n+        CMDERR(1),\n+        \/** Not started, system error or resource exhaustion *\/\n+        SYSERR(2);\n+\n+        Startup(int statusCode) {\n+            this.statusCode = statusCode;\n+        }\n+        public final int statusCode;\n+    }\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+usage=\\\n+Usage: java -m jdk.httpserver [-b bind address] [-p port] [-d directory]\\n\\\n+\\                              [-o none|info|verbose] [-h to show options]\n+\n+options=\\\n+Options:\\n\\\n+-b, --bind-address    - Address to bind to. Default: {0} (loopback).\\n\\\n+\\                        For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\\n\\\n+-d, --directory       - Directory to serve. Default: current directory.\\n\\\n+-o, --output          - Output format. none|info|verbose. Default: info.\\n\\\n+-p, --port            - Port to listen on. Default: 8000.\\n\\\n+-h, -?, --help        - Print this help message.\\n\\\n+To stop the server, press Ctrl + C.\n+\n+opt.bindaddress=\\\n+-b, --bind-address    - Address to bind to. Default: {0} (loopback).\\n\\\n+\\                        For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\n+opt.directory=\\\n+-d, --directory       - Directory to serve. Default: current directory.\n+opt.output=\\\n+-o, --output          - Output format. none|info|verbose. Default: info.\n+opt.port=\\\n+-p, --port            - Port to listen on. Default: 8000.\n+\n+loopback.info=\\\n+Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\n+\n+msg.start.anylocal=\\\n+Serving {0} and subdirectories on 0.0.0.0 (all interfaces) port {2}\\n\\\n+URL http:\/\/{1}:{2}\/ ...\n+\n+msg.start.other=\\\n+Serving {0} and subdirectories on\\n\\\n+URL http:\/\/{1}:{2}\/ ...\n+\n+error.prefix=Error:\n+\n+err.unknown.option=unknown option: {0}\n+err.missing.arg=no value given for {0}\n+err.invalid.arg=invalid value given for {0}: {1}\n+err.server.config.failed=server config failed: {0}\n+err.server.handle.failed=server exchange handling failed: {0}\n+\n+html.dir.list=Directory listing for\n+html.not.found=File not found\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/resources\/simpleserver.properties","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -30,2 +30,3 @@\n-com\/sun\/tools\/attach sun\/security\/mscapi java\/util\/Arrays\/largeMemory \\\n-java\/util\/BitSet\/stream javax\/rmi java\/net\/httpclient\/websocket\n+com\/sun\/tools\/attach sun\/security\/mscapi java\/util\/stream java\/util\/Arrays\/largeMemory \\\n+java\/util\/BitSet\/stream javax\/rmi java\/net\/httpclient\/websocket \\\n+com\/sun\/net\/httpserver\/simpleserver\n","filename":"test\/jdk\/TEST.ROOT","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -50,1 +52,0 @@\n-import static java.net.http.HttpClient.Builder.NO_PROXY;\n@@ -54,0 +55,1 @@\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n@@ -82,0 +84,3 @@\n+\n+        expectThrows(NPE, () -> Filter.adaptRequest(\"Some description\", null));\n+        expectThrows(NPE, () -> Filter.adaptRequest(null, r -> r.with(\"Foo\", List.of(\"Bar\"))));\n@@ -93,0 +98,3 @@\n+\n+        var adaptFilter = Filter.adaptRequest(desc, r -> r.with(\"Foo\", List.of(\"Bar\")));\n+        assertEquals(desc, adaptFilter.description());\n@@ -308,0 +316,58 @@\n+    @Test\n+    public void testInspectRequest() throws Exception {\n+        var handler = new EchoHandler();\n+        var inspectedURI = new AtomicReference<URI>();\n+        var filter = Filter.adaptRequest(\"Inspect request URI\",\n+                r -> {inspectedURI.set(r.getRequestURI()); return r;});\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR,0), 10);\n+        server.createContext(\"\/\", handler).getFilters().add(filter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"foo\/bar\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(inspectedURI.get(), URI.create(\"\/foo\/bar\"));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private static HttpExchange originalExchange;\n+\n+    \/**\n+     * Confirms that adaptRequest changes only the expected request state and\n+     * all other exchange state remains unchanged.\n+     *\/\n+    @Test\n+    public void testAdaptRequest() throws Exception {\n+        var handler = new CompareStateAndEchoHandler();\n+        var captureFilter = Filter.beforeHandler(\"capture exchange\", e -> {\n+            e.setAttribute(\"foo\", \"bar\");\n+            originalExchange = e;\n+        });\n+        var adaptFilter = Filter.adaptRequest(\"Add x-foo request header\", r -> {\n+            \/\/ Confirm request state is unchanged\n+            assertEquals(r.getRequestHeaders(), originalExchange.getRequestHeaders());\n+            assertEquals(r.getRequestURI(), originalExchange.getRequestURI());\n+            assertEquals(r.getRequestMethod(), originalExchange.getRequestMethod());\n+            return r.with(\"x-foo\", List.of(\"bar\"));\n+        });\n+        var server = HttpServer.create(new InetSocketAddress(LOOPBACK_ADDR,0), 10);\n+        var context = server.createContext(\"\/\", handler);\n+        context.getFilters().add(captureFilter);\n+        context.getFilters().add(adaptFilter);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"bar\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n@@ -328,0 +394,36 @@\n+    \/**\n+     * A handler that compares the adapted exchange with the original exchange,\n+     * before discarding the request and returning the test request header value.\n+     *\/\n+    static class CompareStateAndEchoHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            assertEquals(exchange.getLocalAddress(), originalExchange.getLocalAddress());\n+            assertEquals(exchange.getRemoteAddress(), originalExchange.getRemoteAddress());\n+            assertEquals(exchange.getProtocol(), originalExchange.getProtocol());\n+            assertEquals(exchange.getPrincipal(), originalExchange.getPrincipal());\n+            assertEquals(exchange.getHttpContext(), originalExchange.getHttpContext());\n+            assertEquals(exchange.getRequestMethod(), originalExchange.getRequestMethod());\n+            assertEquals(exchange.getRequestURI(), originalExchange.getRequestURI());\n+            assertEquals(exchange.getRequestBody(), originalExchange.getRequestBody());\n+            assertEquals(exchange.getResponseHeaders(), originalExchange.getResponseHeaders());\n+            assertEquals(exchange.getResponseCode(), originalExchange.getResponseCode());\n+            assertEquals(exchange.getResponseBody(), originalExchange.getResponseBody());\n+            assertEquals(exchange.getAttribute(\"foo\"), originalExchange.getAttribute(\"foo\"));\n+            assertFalse(exchange.getRequestHeaders().equals(originalExchange.getRequestHeaders()));\n+\n+            exchange.setAttribute(\"foo\", \"barbar\");\n+            assertEquals(exchange.getAttribute(\"foo\"), originalExchange.getAttribute(\"foo\"));\n+\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = exchange.getRequestHeaders().get(\"x-foo\")\n+                        .get(0)\n+                        .getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/FilterTest.java","additions":103,"deletions":1,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *          jdk.httpserver\/sun.net.httpserver:+open\n@@ -58,0 +59,1 @@\n+import sun.net.httpserver.UnmodifiableHeaders;\n@@ -62,0 +64,1 @@\n+import static org.testng.Assert.assertNotEquals;\n@@ -317,0 +320,127 @@\n+\n+    @Test\n+    public static void test1ArgConstructorNull() {\n+        assertThrows(NPE, () -> new Headers(null));\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            m.put(null, List.of(\"Bar\"));\n+            assertThrows(NPE, () -> new Headers(m));\n+        }\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            m.put(\"Foo\", null);\n+            assertThrows(NPE, () -> new Headers(m));\n+        }\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            final var list = new LinkedList<String>();\n+            list.add(null);\n+            m.put(\"Foo\", list);\n+            assertThrows(NPE, () -> new Headers(m));\n+        }\n+    }\n+\n+    @Test\n+    public static void test1ArgConstructor() {\n+        {\n+            var h = new Headers(new Headers());\n+            assertTrue(h.isEmpty());\n+        }\n+        {\n+            var h = new Headers(Map.of(\"Foo\", List.of(\"Bar\")));\n+            assertEquals(h.get(\"Foo\"), List.of(\"Bar\"));\n+            assertEquals(h.size(), 1);\n+        }\n+        {\n+            var h1 = new Headers(new UnmodifiableHeaders(new Headers()));\n+            assertTrue(h1.isEmpty());\n+            h1.put(\"Foo\", List.of(\"Bar\"));  \/\/ modifiable\n+            assertEquals(h1.get(\"Foo\"), List.of(\"Bar\"));\n+            assertEquals(h1.size(), 1);\n+\n+            var h2 = new Headers(h1);\n+            assertEquals(h2.get(\"Foo\"), List.of(\"Bar\"));\n+            assertEquals(h2.size(), 1);\n+\n+            assertEquals(h1, h2);\n+            h1.set(\"Foo\", \"Barbar\");\n+            assertNotEquals(h1, h2);\n+        }\n+    }\n+\n+    @Test\n+    public static void testMutableHeaders() {\n+        {\n+            var h = new Headers();\n+            h.add(\"Foo\", \"Bar\");\n+            h.add(\"Foo\", \"Bazz\");\n+            h.get(\"Foo\").remove(0);\n+            h.remove(\"Foo\");\n+            h.clear();\n+        }\n+        {\n+            var h = new Headers(Map.of(\"Foo\", List.of(\"Bar\")));\n+            h.get(\"Foo\").add(\"Bazz\");\n+            h.get(\"Foo\").remove(0);\n+            h.remove(\"Foo\");\n+            h.clear();\n+        }\n+    }\n+\n+    @Test\n+    public static void testOfNull() {\n+        assertThrows(NPE, () -> Headers.of((String[])null));\n+        assertThrows(NPE, () -> Headers.of(null, \"Bar\"));\n+        assertThrows(NPE, () -> Headers.of(\"Foo\", null));\n+\n+        assertThrows(NPE, () -> Headers.of((Map<String, List<String>>) null));\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            m.put(null, List.of(\"Bar\"));\n+            assertThrows(NPE, () -> Headers.of(m));\n+        }\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            m.put(\"Foo\", null);\n+            assertThrows(NPE, () -> Headers.of(m));\n+        }\n+        {\n+            final var m = new HashMap<String, List<String>>();\n+            final var list = new LinkedList<String>();\n+            list.add(null);\n+            m.put(\"Foo\", list);\n+            assertThrows(NPE, () -> Headers.of(m));\n+        }\n+    }\n+\n+    @Test\n+    public static void testOf() {\n+        final var h = Headers.of(\"a\", \"1\", \"b\", \"2\");\n+        assertEquals(h.size(), 2);\n+        List.of(\"a\", \"b\").forEach(n -> assertTrue(h.containsKey(n)));\n+        List.of(\"1\", \"2\").forEach(v -> assertTrue(h.containsValue(List.of(v))));\n+    }\n+\n+    @Test\n+    public static void testOfEmpty() {\n+        for (var h : List.of(Headers.of(), Headers.of(new String[] { }))) {\n+            assertEquals(h.size(), 0);\n+            assertTrue(h.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public static void testOfNumberOfElements() {\n+        assertThrows(IAE, () -> Headers.of(\"a\"));\n+        assertThrows(IAE, () -> Headers.of(\"a\", \"1\", \"b\"));\n+    }\n+\n+    @Test\n+    public static void testOfMultipleValues() {\n+        final var h = Headers.of(\"a\", \"1\", \"b\", \"1\", \"b\", \"2\", \"b\", \"3\");\n+        assertEquals(h.size(), 2);\n+        List.of(\"a\", \"b\").forEach(n -> assertTrue(h.containsKey(n)));\n+        List.of(List.of(\"1\"), List.of(\"1\", \"2\", \"3\")).forEach(v -> assertTrue(h.containsValue(v)));\n+    }\n+\n+    \/\/ Immutability tests in UnmodifiableHeadersTest.java\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -65,2 +66,2 @@\n-    @Test\n-    public static void testUnmodifiableHeaders() {\n+    @DataProvider\n+    public Object[][] headers() {\n@@ -69,1 +70,8 @@\n-        HttpExchange exchange = new TestHttpExchange(headers);\n+        var exchange = new TestHttpExchange(headers);\n+\n+        return new Object[][] {\n+            { exchange.getRequestHeaders() },\n+            { Headers.of(\"Foo\", \"Bar\") },\n+            { Headers.of(Map.of(\"Foo\", List.of(\"Bar\"))) },\n+        };\n+    }\n@@ -71,2 +79,5 @@\n-        assertUnsupportedOperation(exchange.getRequestHeaders());\n-        assertUnmodifiableCollection(exchange.getRequestHeaders());\n+    @Test(dataProvider = \"headers\")\n+    public static void testUnmodifiableHeaders(Headers headers) {\n+        assertUnsupportedOperation(headers);\n+        assertUnmodifiableCollection(headers);\n+        assertUnmodifiableList(headers);\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/UnmodifiableHeadersTest.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Negative tests for simpleserver command-line tool\n+ * @library \/test\/lib\n+ * @modules jdk.httpserver\n+ * @run testng\/othervm CommandLineNegativeTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static org.testng.Assert.assertFalse;\n+\n+public class CommandLineNegativeTest {\n+\n+    static final Path JAVA_HOME = Path.of(System.getProperty(\"java.home\"));\n+    static final String JAVA = getJava(JAVA_HOME);\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final Path TEST_DIR = CWD.resolve(\"CommandLineNegativeTest\");\n+    static final Path TEST_FILE = TEST_DIR.resolve(\"file.txt\");\n+    static final String LOOPBACK_ADDR = InetAddress.getLoopbackAddress().getHostAddress();\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+        Files.createFile(TEST_FILE);\n+    }\n+\n+    @DataProvider\n+    public Object[][] unknownOption() {\n+        return new Object[][] {\n+                {\"--unknownOption\"},\n+                {\"null\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"unknownOption\")\n+    public void testBadOption(String opt) throws Throwable {\n+        out.println(\"\\n--- testUnknownOption, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt)\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: unknown option: \" + opt);\n+    }\n+\n+    @DataProvider\n+    public Object[][] tooManyOptionArgs() {\n+        return new Object[][] {\n+                {\"-b\", \"localhost\"},\n+                {\"-d\", \"\/some\/path\"},\n+                {\"-o\", \"none\"},\n+                {\"-p\", \"0\"},\n+                {\"--bind-address\", \"localhost\"},\n+                {\"--directory\", \"\/some\/path\"},\n+                {\"--output\", \"none\"},\n+                {\"--port\", \"0\"}\n+                \/\/ doesn't fail for -h option\n+        };\n+    }\n+\n+    @Test(dataProvider = \"tooManyOptionArgs\")\n+    public void testTooManyOptionArgs(String opt, String arg) throws Throwable {\n+        out.println(\"\\n--- testTooManyOptionArgs, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, arg, arg)\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: unknown option: \" + arg);\n+    }\n+\n+    @DataProvider\n+    public Object[][] noArg() {\n+        return new Object[][] {\n+                {\"-b\", \"\"\"\n+                    -b, --bind-address    - Address to bind to. Default: %s (loopback).\n+                                            For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\"\"\".formatted(LOOPBACK_ADDR)},\n+                {\"-d\", \"-d, --directory       - Directory to serve. Default: current directory.\"},\n+                {\"-o\", \"-o, --output          - Output format. none|info|verbose. Default: info.\"},\n+                {\"-p\", \"-p, --port            - Port to listen on. Default: 8000.\"},\n+                {\"--bind-address\", \"\"\"\n+                        -b, --bind-address    - Address to bind to. Default: %s (loopback).\n+                                                For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\"\"\".formatted(LOOPBACK_ADDR)},\n+                {\"--directory\", \"-d, --directory       - Directory to serve. Default: current directory.\"},\n+                {\"--output\",    \"-o, --output          - Output format. none|info|verbose. Default: info.\"},\n+                {\"--port\",      \"-p, --port            - Port to listen on. Default: 8000.\"}\n+                \/\/ doesn't fail for -h option\n+        };\n+    }\n+\n+    @Test(dataProvider = \"noArg\")\n+    public void testNoArg(String opt, String msg) throws Throwable {\n+        out.println(\"\\n--- testNoArg, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt)\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: no value given for \" + opt)\n+                .shouldContain(msg);\n+    }\n+\n+    @DataProvider\n+    public Object[][] invalidValue() {\n+        return new Object[][] {\n+                {\"-b\", \"[127.0.0.1]\"},\n+                {\"-b\", \"badhost\"},\n+                {\"--bind-address\", \"192.168.1.220...\"},\n+\n+                {\"-o\", \"bad-output-level\"},\n+                {\"--output\", \"bad-output-level\"},\n+\n+                {\"-p\", \"+-\"},\n+                {\"--port\", \"+-\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalidValue\")\n+    public void testInvalidValue(String opt, String val) throws Throwable {\n+        out.println(\"\\n--- testInvalidValue, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, val)\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: invalid value given for \" + opt + \": \" + val);\n+    }\n+\n+    @DataProvider\n+    public Object[][] portOptions() { return new Object[][] {{\"-p\"}, {\"--port\"}}; }\n+\n+    @Test(dataProvider = \"portOptions\")\n+    public void testPortOutOfRange(String opt) throws Throwable {\n+        out.println(\"\\n--- testPortOutOfRange, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"65536\")  \/\/ range 0 to 65535\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: server config failed: \" + \"port out of range:65536\");\n+    }\n+\n+    @DataProvider\n+    public Object[][] directoryOptions() { return new Object[][] {{\"-d\"}, {\"--directory\"}}; }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRootNotAbsolute(String opt) throws Throwable {\n+        out.println(\"\\n--- testRootNotAbsolute, opt=\\\"%s\\\" \".formatted(opt));\n+        var root = Path.of(\".\");\n+        assertFalse(root.isAbsolute());\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, root.toString())\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: server config failed: \" + \"Path is not absolute:\");\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRootNotADirectory(String opt) throws Throwable {\n+        out.println(\"\\n--- testRootNotADirectory, opt=\\\"%s\\\" \".formatted(opt));\n+        var file = TEST_FILE.toString();\n+        assertFalse(Files.isDirectory(TEST_FILE));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, file)\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: server config failed: \" + \"Path is not a directory: \" + file);\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRootDoesNotExist(String opt) throws Throwable {\n+        out.println(\"\\n--- testRootDoesNotExist, opt=\\\"%s\\\" \".formatted(opt));\n+        Path root = TEST_DIR.resolve(\"not\/existent\/dir\");\n+        assertFalse(Files.exists(root));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, root.toString())\n+                .shouldNotHaveExitValue(0)\n+                .shouldContain(\"Error: server config failed: \" + \"Path does not exist: \" + root.toString());\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRootNotReadable(String opt) throws Throwable {\n+        out.println(\"\\n--- testRootNotReadable, opt=\\\"%s\\\" \".formatted(opt));\n+        if (Platform.isWindows()) {\n+            \/\/ Not applicable to Windows. Reason: cannot revoke an owner's read\n+            \/\/ access to a directory that was created by that owner\n+            throw new SkipException(\"cannot run on Windows\");\n+        }\n+        Path root = Files.createDirectories(TEST_DIR.resolve(\"not\/readable\/dir\"));\n+        try {\n+            root.toFile().setReadable(false, false);\n+            assertFalse(Files.isReadable(root));\n+            simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, root.toString())\n+                    .shouldNotHaveExitValue(0)\n+                    .shouldContain(\"Error: server config failed: \" + \"Path is not readable: \" + root.toString());\n+        } finally {\n+            root.toFile().setReadable(true, false);\n+        }\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static String getJava(Path image) {\n+        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+        Path java = image.resolve(\"bin\").resolve(isWindows ? \"java.exe\" : \"java\");\n+        if (Files.notExists(java))\n+            throw new RuntimeException(java + \" not found\");\n+        return java.toAbsolutePath().toString();\n+    }\n+\n+    static OutputAnalyzer simpleserver(String... args) throws Throwable {\n+        var pb = new ProcessBuilder(args)\n+                .directory(TEST_DIR.toFile());\n+        var outputAnalyser = ProcessTools.executeCommand(pb)\n+                .outputTo(System.out)\n+                .errorTo(System.out);\n+        return outputAnalyser;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLineNegativeTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Positive tests for simpleserver command-line tool\n+ * @library \/test\/lib\n+ * @modules jdk.httpserver\n+ * @run testng\/othervm CommandLinePositiveTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+\n+public class CommandLinePositiveTest {\n+\n+    static final Path JAVA_HOME = Path.of(System.getProperty(\"java.home\"));\n+    static final String JAVA = getJava(JAVA_HOME);\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final Path TEST_DIR = CWD.resolve(\"CommandLinePositiveTest\");\n+    static final Path TEST_FILE = TEST_DIR.resolve(\"file.txt\");\n+    static final String TEST_DIR_STR = TEST_DIR.toString();\n+    static final String LOOPBACK_ADDR = InetAddress.getLoopbackAddress().getHostAddress();\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+        Files.createFile(TEST_FILE);\n+    }\n+\n+    static final int SIGTERM = 15;\n+    static final int NORMAL_EXIT_CODE = normalExitCode();\n+\n+    static int normalExitCode() {\n+        if (Platform.isWindows()) {\n+            return 1; \/\/ expected process destroy exit code\n+        } else {\n+            \/\/ signal terminated exit code on Unix is 128 + signal value\n+            return 128 + SIGTERM;\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] directoryOptions() { return new Object[][] {{\"-d\"}, {\"--directory\"}}; }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testDirectory(String opt) throws Throwable {\n+        out.println(\"\\n--- testDirectory, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, TEST_DIR_STR)\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @DataProvider\n+    public Object[][] portOptions() { return new Object[][] {{\"-p\"}, {\"--port\"}}; }\n+\n+    @Test(dataProvider = \"portOptions\")\n+    public void testPort(String opt) throws Throwable {\n+        out.println(\"\\n--- testPort, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"0\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @DataProvider\n+    public Object[][] helpOptions() { return new Object[][] {{\"-h\"}, {\"-?\"}, {\"--help\"}}; }\n+\n+    static final String USAGE_TEXT = \"\"\"\n+            Usage: java -m jdk.httpserver [-b bind address] [-p port] [-d directory]\n+                                          [-o none|info|verbose] [-h to show options]\"\"\";\n+\n+    static final String OPTIONS_TEXT = \"\"\"\n+            Options:\n+            -b, --bind-address    - Address to bind to. Default: %s (loopback).\n+                                    For 0.0.0.0 (all interfaces) use -b 0.0.0.0 or -b ::0.\n+            -d, --directory       - Directory to serve. Default: current directory.\n+            -o, --output          - Output format. none|info|verbose. Default: info.\n+            -p, --port            - Port to listen on. Default: 8000.\n+            -h, -?, --help        - Print this help message.\n+            To stop the server, press Ctrl + C.\"\"\".formatted(LOOPBACK_ADDR);\n+\n+    @Test(dataProvider = \"helpOptions\")\n+    public void testHelp(String opt) throws Throwable {\n+        out.println(\"\\n--- testHelp, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(WaitForLine.HELP_STARTUP_LINE,\n+                     false,  \/\/ do not explicitly destroy the process\n+                     JAVA, \"-m\", \"jdk.httpserver\", opt)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(USAGE_TEXT)\n+                .shouldContain(OPTIONS_TEXT);\n+    }\n+\n+    @DataProvider\n+    public Object[][] bindOptions() { return new Object[][] {{\"-b\"}, {\"--bind-address\"}}; }\n+\n+    @Test(dataProvider = \"bindOptions\")\n+    public void testBindAllInterfaces(String opt) throws Throwable {\n+        out.println(\"\\n--- testPort, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"0.0.0.0\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                .shouldContain(\"URL http:\/\/\" + InetAddress.getLocalHost().getHostAddress());\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"::0\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                .shouldContain(\"URL http:\/\/\" + InetAddress.getLocalHost().getHostAddress());\n+    }\n+\n+    @Test(dataProvider = \"bindOptions\")\n+    public void testLastOneWinsBindAddress(String opt) throws Throwable {\n+        out.println(\"\\n--- testLastOneWinsBindAddress, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, \"123.4.5.6\", opt, LOOPBACK_ADDR)\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testLastOneWinsDirectory(String opt) throws Throwable {\n+        out.println(\"\\n--- testLastOneWinsDirectory, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, TEST_DIR_STR, opt, TEST_DIR_STR)\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @DataProvider\n+    public Object[][] outputOptions() { return new Object[][] {{\"-o\"}, {\"--output\"}}; }\n+\n+    @Test(dataProvider = \"outputOptions\")\n+    public void testLastOneWinsOutput(String opt) throws Throwable {\n+        out.println(\"\\n--- testLastOneWinsOutput, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, \"none\", opt, \"verbose\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @Test(dataProvider = \"portOptions\")\n+    public void testLastOneWinsPort(String opt) throws Throwable {\n+        out.println(\"\\n--- testLastOneWinsPort, opt=\\\"%s\\\" \".formatted(opt));\n+        simpleserver(JAVA, \"-m\", \"jdk.httpserver\", opt, \"-999\", opt, \"0\")\n+                .shouldHaveExitValue(NORMAL_EXIT_CODE)\n+                .shouldContain(\"Default bind address loopback. For all interfaces use -b 0.0.0.0 or -b ::0.\")\n+                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on\\n\" +\n+                        \"URL http:\/\/\" + LOOPBACK_ADDR);\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static String getJava(Path image) {\n+        boolean isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+        Path java = image.resolve(\"bin\").resolve(isWindows ? \"java.exe\" : \"java\");\n+        if (Files.notExists(java))\n+            throw new RuntimeException(java + \" not found\");\n+        return java.toAbsolutePath().toString();\n+    }\n+\n+    static final String REGULAR_STARTUP_LINE1_STRING = \"Serving\";\n+    static final String REGULAR_STARTUP_LINE2_STRING = \"URL http:\/\/\";\n+\n+    \/\/ The stdout\/stderr output line to wait for when starting the simpleserver\n+    enum WaitForLine {\n+        REGULAR_STARTUP_LINE (REGULAR_STARTUP_LINE2_STRING) ,\n+        HELP_STARTUP_LINE (OPTIONS_TEXT.lines().reduce((first, second) -> second).orElseThrow());\n+\n+        final String value;\n+        WaitForLine(String value) { this.value = value; }\n+    }\n+\n+    static OutputAnalyzer simpleserver(String... args) throws Throwable {\n+        return simpleserver(WaitForLine.REGULAR_STARTUP_LINE, true, args);\n+    }\n+\n+    static OutputAnalyzer simpleserver(WaitForLine waitForLine, boolean destroy, String... args) throws Throwable {\n+        StringBuffer sb = new StringBuffer();  \/\/ stdout & stderr\n+        \/\/ start the process and await the waitForLine before returning\n+        var p = ProcessTools.startProcess(\"simpleserver\",\n+                new ProcessBuilder(args).directory(TEST_DIR.toFile()),\n+                line -> sb.append(line + \"\\n\"),\n+                line -> line.startsWith(waitForLine.value),\n+                30,  \/\/ suitably high default timeout, not expected to timeout\n+                TimeUnit.SECONDS);\n+        if (destroy) {\n+            p.destroy();  \/\/ SIGTERM on Unix\n+        }\n+        int ec = p.waitFor();\n+        var outputAnalyser = new OutputAnalyzer(sb.toString(), \"\", ec);\n+        return outputAnalyser;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLinePositiveTest.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,970 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for SimpleFileServer with a root that is not of the default\n+ *          file system\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm CustomFileSystemTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.AccessMode;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n+import java.nio.file.spi.FileSystemProvider;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class CustomFileSystemTest {\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void testFileGET() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testFileGET\");\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"some text\");\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <li><a href=\"aFile.txt\">aFile.txt<\/a><\/li>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testDirectoryGET\");\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testFileHEAD() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testFileHEAD\");\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .method(\"HEAD\", HttpRequest.BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryHEAD() throws Exception {\n+        var expectedLength = Integer.toString(\n+                (openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <li><a href=\"aFile.txt\">aFile.txt<\/a><\/li>\n+                <\/ul>\n+                \"\"\" + closeHTML).getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testDirectoryHEAD\");\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\"))\n+                    .method(\"HEAD\", HttpRequest.BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] indexFiles() {\n+        var fileContent = openHTML + \"\"\"\n+                <h1>This is an index file<\/h1>\n+                \"\"\" + closeHTML;\n+        var dirListing = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        return new Object[][] {\n+                {\"1\", \"index.html\", \"text\/html\",                \"116\", fileContent, true},\n+                {\"2\", \"index.htm\",  \"text\/html\",                \"116\", fileContent, true},\n+                {\"3\", \"index.txt\",  \"text\/html; charset=UTF-8\", \"134\", dirListing,  false}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"indexFiles\")\n+    public void testDirectoryWithIndexGET(String id,\n+                                          String filename,\n+                                          String contentType,\n+                                          String contentLength,\n+                                          String expectedBody,\n+                                          boolean serveIndexFile) throws Exception {\n+        var root = createDirectoryInCustomFs(\"testDirectoryWithIndexGET\"+id);\n+        var lastModified = getLastModified(root);\n+        if (serveIndexFile) {\n+            var file = Files.writeString(root.resolve(filename), expectedBody, CREATE);\n+            lastModified = getLastModified(file);\n+        }\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), contentType);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), contentLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            if (serveIndexFile) {\n+                Files.delete(root.resolve(filename));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNotReadableFileGET() throws Exception {\n+        if (!Platform.isWindows()) {  \/\/ not applicable on Windows\n+            var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+            var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+            var root = createDirectoryInCustomFs(\"testNotReadableFileGET\");\n+            var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+\n+            file.toFile().setReadable(false, false);\n+            assert !Files.isReadable(file);\n+\n+            var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+            server.start();\n+            try {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+                var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 404);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+                assertEquals(response.body(), expectedBody);\n+            } finally {\n+                server.stop(0);\n+                file.toFile().setReadable(true, false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNotReadableSegmentGET() throws Exception {\n+        if (!Platform.isWindows()) {  \/\/ not applicable on Windows\n+            var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;dir&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+            var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+            var root = createDirectoryInCustomFs(\"testNotReadableSegmentGET\");\n+            var dir = Files.createDirectory(root.resolve(\"dir\"));\n+            var file = Files.writeString(dir.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+\n+            dir.toFile().setReadable(false, false);\n+            assert !Files.isReadable(dir);\n+            assert Files.isReadable(file);\n+\n+            var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+            server.start();\n+            try {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+                var request = HttpRequest.newBuilder(uri(server, \"dir\/aFile.txt\")).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 404);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+                assertEquals(response.body(), expectedBody);\n+            } finally {\n+                server.stop(0);\n+                dir.toFile().setReadable(true, false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidRequestURIGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;aFile?#.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testInvalidRequestURIGET\");\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile?#.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testNotFoundGET\");\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundHEAD() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testNotFoundHEAD\");\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\"))\n+                    .method(\"HEAD\", HttpRequest.BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSymlinkGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;symlink<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testSymlinkGET\");\n+        var symlink = root.resolve(\"symlink\");\n+        var target = Files.writeString(root.resolve(\"target.txt\"), \"some text\", CREATE);\n+        Files.createSymbolicLink(symlink, target);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"symlink\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSymlinkSegmentGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;symlink&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createDirectoryInCustomFs(\"testSymlinkSegmentGET\");\n+        var symlink = root.resolve(\"symlink\");\n+        var target = Files.createDirectory(root.resolve(\"target\"));\n+        Files.writeString(target.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        Files.createSymbolicLink(symlink, target);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"symlink\/aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHiddenFileGET() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testHiddenFileGET\");\n+        var file = createHiddenFile(root);\n+        var fileName = file.getFileName().toString();\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;\"\"\" + fileName +\n+                \"\"\"\n+                <\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, fileName)).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHiddenSegmentGET() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testHiddenSegmentGET\");\n+        var file = createFileInHiddenDirectory(root);\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;.hiddenDirectory&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \".hiddenDirectory\/aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private Path createHiddenFile(Path root) throws IOException {\n+        Path file;\n+        if (Platform.isWindows()) {\n+            file = Files.createFile(root.resolve(\"aFile.txt\"));\n+            Files.setAttribute(file, \"dos:hidden\", true, LinkOption.NOFOLLOW_LINKS);\n+        } else {\n+            file = Files.writeString(root.resolve(\".aFile.txt\"), \"some text\", CREATE);\n+        }\n+        assertTrue(Files.isHidden(file));\n+        return file;\n+    }\n+\n+    private Path createFileInHiddenDirectory(Path root) throws IOException {\n+        Path dir;\n+        Path file;\n+        if (Platform.isWindows()) {\n+            dir = Files.createDirectory(root.resolve(\"hiddenDirectory\"));\n+            Files.setAttribute(dir, \"dos:hidden\", true, LinkOption.NOFOLLOW_LINKS);\n+        } else {\n+            dir = Files.createDirectory(root.resolve(\".hiddenDirectory\"));\n+        }\n+        file = Files.writeString(dir.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        assertTrue(Files.isHidden(dir));\n+        assertFalse(Files.isHidden(file));\n+        return file;\n+    }\n+\n+    @Test\n+    public void testMovedPermanently() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testMovedPermanently\");\n+        Files.createDirectory(root.resolve(\"aDirectory\"));\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;aDirectory&#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY)\n+                        .followRedirects(HttpClient.Redirect.NEVER).build();\n+                var uri = uri(server, \"aDirectory\");\n+                var request = HttpRequest.newBuilder(uri).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 301);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(response.headers().firstValue(\"location\").get(), \"\/aDirectory\/\");\n+\n+                \/\/ tests that query component is preserved during redirect\n+                var uri2 = uri(server, \"aDirectory\", \"query\");\n+                var req2 = HttpRequest.newBuilder(uri2).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 301);\n+                assertEquals(res2.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res2.headers().firstValue(\"location\").get(), \"\/aDirectory\/?query\");\n+            }\n+\n+            {   \/\/ tests that redirect to returned relative URI works\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY)\n+                        .followRedirects(HttpClient.Redirect.ALWAYS).build();\n+                var uri = uri(server, \"aDirectory\");\n+                var request = HttpRequest.newBuilder(uri).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 200);\n+                assertEquals(response.body(), expectedBody);\n+                assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testXss() throws Exception {\n+        var root = createDirectoryInCustomFs(\"testXss\");\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"beginDelim%3C%3EEndDelim\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertTrue(response.body().contains(\"beginDelim%3C%3EEndDelim\"));\n+            assertTrue(response.body().contains(\"File not found\"));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static Path createDirectoryInCustomFs(String name) throws Exception {\n+        var defaultFs = FileSystems.getDefault();\n+        var fs = new CustomProvider(defaultFs.provider()).newFileSystem(defaultFs);\n+        var dir = fs.getPath(name);\n+        if (Files.notExists(dir)) {\n+            Files.createDirectory(dir);\n+        }\n+        return dir.toAbsolutePath();\n+    }\n+\n+    static final String openHTML = \"\"\"\n+                <!DOCTYPE html>\n+                <html>\n+                <head>\n+                <meta charset=\"utf-8\"\/>\n+                <\/head>\n+                <body>\n+                \"\"\";\n+\n+    static final String closeHTML = \"\"\"\n+                <\/body>\n+                <\/html>\n+                \"\"\";\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    static URI uri(HttpServer server, String path, String query) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .query(query)\n+                .buildUnchecked();\n+    }\n+\n+    static String getLastModified(Path path) throws IOException {\n+        return Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+\n+    \/\/ --- Custom File System ---\n+\n+    static class CustomProvider extends FileSystemProvider {\n+        private final ConcurrentHashMap<FileSystem, CustomFileSystem> map =\n+                new ConcurrentHashMap<>();\n+        private final FileSystemProvider defaultProvider;\n+\n+        public CustomProvider(FileSystemProvider provider) {\n+            defaultProvider = provider;\n+        }\n+\n+        @Override\n+        public String getScheme() {\n+            return defaultProvider.getScheme();\n+        }\n+\n+        public FileSystem newFileSystem(FileSystem fs) {\n+            return map.computeIfAbsent(fs, (sfs) ->\n+                    new CustomFileSystem(this, fs));\n+        }\n+\n+        @Override\n+        public FileSystem newFileSystem(URI uri, Map<String, ?> env) throws IOException {\n+            FileSystem fs = defaultProvider.newFileSystem(uri, env);\n+            return map.computeIfAbsent(fs, (sfs) ->\n+                    new CustomFileSystem(this, fs)\n+            );\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem(URI uri) {\n+            return map.get(defaultProvider.getFileSystem(uri));\n+        }\n+\n+        @Override\n+        public Path getPath(URI uri) {\n+            Path p = defaultProvider.getPath(uri);\n+            return map.get(defaultProvider.getFileSystem(uri)).wrap(p);\n+        }\n+\n+        @Override\n+        public SeekableByteChannel newByteChannel(Path path, Set<? extends OpenOption> options, FileAttribute<?>... attrs) throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.newByteChannel(p, options, attrs);\n+        }\n+\n+        @Override\n+        public DirectoryStream<Path> newDirectoryStream(Path dir, DirectoryStream.Filter<? super Path> filter) throws IOException {\n+            throw new RuntimeException(\"not implemented\");\n+        }\n+\n+        @Override\n+        public void createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException {\n+            Path p = toCustomPath(dir).unwrap();\n+            defaultProvider.createDirectory(p, attrs);\n+        }\n+\n+        @Override\n+        public void delete(Path path) throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            defaultProvider.delete(p);\n+        }\n+\n+        @Override\n+        public void copy(Path source, Path target, CopyOption... options) throws IOException {\n+            Path sp = toCustomPath(source).unwrap();\n+            Path tp = toCustomPath(target).unwrap();\n+            defaultProvider.copy(sp, tp, options);\n+        }\n+\n+        @Override\n+        public void move(Path source, Path target, CopyOption... options)\n+                throws IOException {\n+            Path sp = toCustomPath(source).unwrap();\n+            Path tp = toCustomPath(target).unwrap();\n+            defaultProvider.move(sp, tp, options);\n+        }\n+\n+        @Override\n+        public boolean isSameFile(Path path, Path path2)\n+                throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            Path p2 = toCustomPath(path2).unwrap();\n+            return defaultProvider.isSameFile(p, p2);\n+        }\n+\n+        @Override\n+        public boolean isHidden(Path path) throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.isHidden(p);\n+        }\n+\n+        @Override\n+        public FileStore getFileStore(Path path) throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.getFileStore(p);\n+        }\n+\n+        @Override\n+        public void checkAccess(Path path, AccessMode... modes) throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            defaultProvider.checkAccess(p, modes);\n+        }\n+\n+        @Override\n+        public <V extends FileAttributeView> V getFileAttributeView(Path path,\n+                                                                    Class<V> type,\n+                                                                    LinkOption... options) {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.getFileAttributeView(p, type, options);\n+        }\n+\n+        @Override\n+        public <A extends BasicFileAttributes> A readAttributes(Path path,\n+                                                                Class<A> type,\n+                                                                LinkOption... options)\n+                throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.readAttributes(p, type, options);\n+        }\n+\n+        @Override\n+        public Map<String, Object> readAttributes(Path path,\n+                                                  String attributes,\n+                                                  LinkOption... options)\n+                throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            return defaultProvider.readAttributes(p, attributes, options);\n+        }\n+\n+        @Override\n+        public void setAttribute(Path path, String attribute,\n+                                 Object value, LinkOption... options)\n+                throws IOException {\n+            Path p = toCustomPath(path).unwrap();\n+            defaultProvider.setAttribute(p, attribute, options);\n+        }\n+\n+        \/\/ Checks that the given file is a CustomPath\n+        static CustomPath toCustomPath(Path obj) {\n+            if (obj == null)\n+                throw new NullPointerException();\n+            if (!(obj instanceof CustomPath cp))\n+                throw new ProviderMismatchException();\n+            return cp;\n+        }\n+    }\n+\n+    static class CustomFileSystem extends FileSystem {\n+\n+        private final CustomProvider provider;\n+        private final FileSystem delegate;\n+\n+        public CustomFileSystem(CustomProvider provider, FileSystem delegate) {\n+            this.provider = provider;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public FileSystemProvider provider() {\n+            return provider;\n+        }\n+\n+        @Override\n+        public void close() throws IOException { delegate.close(); }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean isReadOnly() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String getSeparator() { return delegate.getSeparator(); }\n+\n+        @Override\n+        public Iterable<Path> getRootDirectories() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Iterable<FileStore> getFileStores() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<String> supportedFileAttributeViews() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path getPath(String first, String... more) {\n+            return delegate.getPath(first, more);\n+        }\n+\n+        @Override\n+        public PathMatcher getPathMatcher(String syntaxAndPattern) {\n+            return null;\n+        }\n+\n+        @Override\n+        public UserPrincipalLookupService getUserPrincipalLookupService() {\n+            return null;\n+        }\n+\n+        @Override\n+        public WatchService newWatchService() throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return delegate.toString();\n+        }\n+\n+        Path wrap(Path path) {\n+            return (path != null) ? new CustomPath(this, path) : null;\n+        }\n+\n+        Path unwrap(Path wrapper) {\n+            if (wrapper == null)\n+                throw new NullPointerException();\n+            if (!(wrapper instanceof CustomPath cp))\n+                throw new ProviderMismatchException();\n+            return cp.unwrap();\n+        }\n+    }\n+\n+    static class CustomPath implements Path {\n+\n+        private final CustomFileSystem fs;\n+        private final Path delegate;\n+\n+        CustomPath(CustomFileSystem fs, Path delegate) {\n+            this.fs = fs;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public FileSystem getFileSystem() {\n+            return fs;\n+        }\n+\n+        @Override\n+        public boolean isAbsolute() {\n+            return delegate.isAbsolute();\n+        }\n+\n+        @Override\n+        public Path getRoot() {\n+            return fs.wrap(delegate.getRoot());\n+        }\n+\n+        @Override\n+        public Path getFileName() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path getParent() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getNameCount() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public Path getName(int index) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Path subpath(int beginIndex, int endIndex) {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean startsWith(Path other) {\n+            return delegate.startsWith(other);\n+        }\n+\n+        @Override\n+        public boolean endsWith(Path other) {\n+            return false;\n+        }\n+\n+        @Override\n+        public Path normalize() {\n+            return fs.wrap(delegate.normalize());\n+        }\n+\n+        @Override\n+        public Path resolve(Path other) {\n+            return fs.wrap(delegate.resolve(fs.unwrap(other)));\n+        }\n+\n+        @Override\n+        public Path relativize(Path other) {\n+            return null;\n+        }\n+\n+        @Override\n+        public URI toUri() {\n+            return delegate.toUri();\n+        }\n+\n+        @Override\n+        public Path toAbsolutePath() {\n+            return fs.wrap(delegate.toAbsolutePath());\n+        }\n+\n+        @Override\n+        public Path toRealPath(LinkOption... options) throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public WatchKey register(WatchService watcher, WatchEvent.Kind<?>[] events, WatchEvent.Modifier... modifiers) throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public int compareTo(Path other) {\n+            return 0;\n+        }\n+\n+        Path unwrap() {\n+            return delegate;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CustomFileSystemTest.java","additions":970,"deletions":0,"binary":false,"changes":970,"status":"added"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for FileServerHandler\n+ * @run testng FileServerHandlerTest\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpPrincipal;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class FileServerHandlerTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final Class<RuntimeException> RE = RuntimeException.class;\n+\n+    @DataProvider\n+    public Object[][] notAllowedMethods() {\n+        var l = List.of(\"POST\", \"PUT\", \"DELETE\", \"TRACE\", \"OPTIONS\");\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"notAllowedMethods\")\n+    public void testNotAllowedRequestMethod(String requestMethod) throws Exception {\n+        var handler = SimpleFileServer.createFileHandler(CWD);\n+        var exchange = new MethodHttpExchange(requestMethod);\n+        handler.handle(exchange);\n+        assertEquals(exchange.rCode, 405);\n+        assertEquals(exchange.getResponseHeaders().getFirst(\"allow\"), \"HEAD, GET\");\n+    }\n+\n+    @DataProvider\n+    public Object[][] notImplementedMethods() {\n+        var l = List.of(\"GARBAGE\", \"RUBBISH\", \"TRASH\", \"FOO\", \"BAR\");\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"notImplementedMethods\")\n+    public void testNotImplementedRequestMethod(String requestMethod) throws Exception {\n+        var handler = SimpleFileServer.createFileHandler(CWD);\n+        var exchange = new MethodHttpExchange(requestMethod);\n+        handler.handle(exchange);\n+        assertEquals(exchange.rCode, 501);\n+    }\n+\n+    \/\/ 301 and 404 response codes tested in SimpleFileServerTest\n+\n+    @Test\n+    public void testThrowingExchange() {\n+        var h = SimpleFileServer.createFileHandler(CWD);\n+        {\n+            var exchange = new ThrowingHttpExchange(\"GET\") {\n+                public InputStream getRequestBody() {\n+                    throw new RuntimeException(\"getRequestBody\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"getRequestBody\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange(\"GET\") {\n+                public Headers getResponseHeaders() {\n+                    throw new RuntimeException(\"getResponseHeaders\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"getResponseHeaders\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange(\"GET\") {\n+                public void sendResponseHeaders(int rCode, long responseLength) {\n+                    throw new RuntimeException(\"sendResponseHeaders\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"sendResponseHeaders\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange(\"GET\") {\n+                public OutputStream getResponseBody() {\n+                    throw new RuntimeException(\"getResponseBody\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"getResponseBody\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange(\"GET\") {\n+                public void close() {\n+                    throw new RuntimeException(\"close\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"close\");\n+        }\n+    }\n+\n+    static class ThrowingHttpExchange extends StubHttpExchange {\n+        private final String method;\n+        volatile int rCode;\n+        volatile long responseLength;\n+        volatile Headers responseHeaders;\n+        volatile Headers requestHeaders;\n+        volatile InputStream requestBody;\n+\n+        ThrowingHttpExchange(String method) {\n+            this.method = method;\n+            responseHeaders = new Headers();\n+            requestHeaders = new Headers();\n+            requestBody = new ByteArrayInputStream(new byte[]{});\n+        }\n+\n+        @Override public String getRequestMethod() { return method; }\n+        @Override public Headers getResponseHeaders() { return responseHeaders; }\n+        @Override public Headers getRequestHeaders() { return requestHeaders; }\n+        @Override public InputStream getRequestBody() { return requestBody; }\n+        @Override public URI getRequestURI() { return URI.create(\"\/\"); }\n+        @Override public OutputStream getResponseBody() {\n+            return OutputStream.nullOutputStream();\n+        }\n+        @Override public void sendResponseHeaders(int rCode, long responseLength) {\n+            this.rCode = rCode;\n+            this.responseLength = responseLength;\n+        }\n+        @Override public HttpContext getHttpContext() {\n+            return new HttpContext() {\n+                @Override public HttpHandler getHandler() { return null; }\n+                @Override public void setHandler(HttpHandler handler) { }\n+                @Override public String getPath() {\n+                    return \"\/\";\n+                }\n+                @Override public HttpServer getServer() {\n+                    return null;\n+                }\n+                @Override public Map<String, Object> getAttributes() {\n+                    return null;\n+                }\n+                @Override public List<Filter> getFilters() {\n+                    return null;\n+                }\n+                @Override public Authenticator setAuthenticator(Authenticator auth) {\n+                    return null;\n+                }\n+                @Override public Authenticator getAuthenticator() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    static class MethodHttpExchange extends StubHttpExchange {\n+        private final String method;\n+        volatile int rCode;\n+        volatile long responseLength;\n+        volatile Headers responseHeaders;\n+        volatile InputStream requestBody;\n+\n+        MethodHttpExchange(String method) {\n+            this.method = method;\n+            responseHeaders = new Headers();\n+            requestBody = InputStream.nullInputStream();\n+        }\n+\n+        @Override public String getRequestMethod() { return method; }\n+        @Override public Headers getResponseHeaders() { return responseHeaders; }\n+        @Override public InputStream getRequestBody() { return requestBody; }\n+        @Override public void sendResponseHeaders(int rCode, long responseLength) {\n+            this.rCode = rCode;\n+            this.responseLength = responseLength;\n+        }\n+    }\n+\n+    static class StubHttpExchange extends HttpExchange {\n+        @Override public Headers getRequestHeaders() { return null; }\n+        @Override public Headers getResponseHeaders() { return null; }\n+        @Override public URI getRequestURI() { return null; }\n+        @Override public String getRequestMethod() { return null; }\n+        @Override public void close() { }\n+        @Override public InputStream getRequestBody() { return null; }\n+        @Override public OutputStream getResponseBody() { return null; }\n+        @Override public HttpContext getHttpContext() { return null; }\n+        @Override public void sendResponseHeaders(int rCode, long responseLength) { }\n+        @Override public InetSocketAddress getRemoteAddress() { return null; }\n+        @Override public int getResponseCode() { return 0; }\n+        @Override public InetSocketAddress getLocalAddress() { return null; }\n+        @Override public String getProtocol() { return null; }\n+        @Override public Object getAttribute(String name) { return null; }\n+        @Override public void setAttribute(String name, Object value) { }\n+        @Override public void setStreams(InputStream i, OutputStream o) { }\n+        @Override public HttpPrincipal getPrincipal() { return null; }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/FileServerHandlerTest.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"@@ -0,0 +1,362 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for HttpHandlers\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm HttpHandlersTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import jdk.test.lib.net.URIBuilder;\n+import com.sun.net.httpserver.*;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.*;\n+\n+public class HttpHandlersTest {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<RuntimeException> RE = RuntimeException.class;\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        final var handler = new TestHandler();\n+        assertThrows(NPE, () -> HttpHandlers.handleOrElse(null, handler, new TestHandler()));\n+        assertThrows(NPE, () -> HttpHandlers.handleOrElse(p -> true, null, handler));\n+        assertThrows(NPE, () -> HttpHandlers.handleOrElse(p -> true, handler, null));\n+\n+        final var headers = new Headers();\n+        final var body = \"\";\n+        assertThrows(NPE, () -> HttpHandlers.of(200, null, body));\n+        assertThrows(NPE, () -> HttpHandlers.of(200, headers, null));\n+    }\n+\n+    @Test\n+    public void testOfStatusCode() {\n+        final var headers = new Headers();\n+        final var body = \"\";\n+        assertThrows(IAE, () -> HttpHandlers.of(99, headers, body));\n+        assertThrows(IAE, () -> HttpHandlers.of(1000, headers, body));\n+    }\n+\n+    @Test\n+    public void testOfNoBody() throws Exception {\n+        var handler = HttpHandlers.of(200, Headers.of(\"foo\", \"bar\"), \"\");\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertTrue(response.headers().map().containsKey(\"date\"));\n+            assertEquals(response.headers().firstValue(\"foo\").get(), \"bar\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), \"0\");\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testOfWithBody() throws Exception {\n+        var handler = HttpHandlers.of(200, Headers.of(\"foo\", \"bar\"), \"hello world\");\n+        var expectedLength = Integer.toString(\"hello world\".getBytes(UTF_8).length);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertTrue(response.headers().map().containsKey(\"date\"));\n+            assertEquals(response.headers().firstValue(\"foo\").get(), \"bar\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"hello world\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testOfHeadRequest() throws Exception {\n+        var handler = HttpHandlers.of(200, Headers.of(\"content-length\", \"999\"), \"hello world\");\n+        var expectedLength = Integer.toString(\"hello world\".getBytes(UTF_8).length);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertTrue(response.headers().map().containsKey(\"date\"));\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().map().size(), 2);\n+            assertEquals(response.statusCode(), 200);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testOfOverwriteHeaders() throws Exception {\n+        var headers = Headers.of(\"content-length\", \"1000\", \"date\", \"12345\");\n+        var handler = HttpHandlers.of(200, headers, \"hello world\");\n+        var expectedLength = Integer.toString(\"hello world\".getBytes(UTF_8).length);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertNotEquals(response.headers().firstValue(\"date\").get(), \"12345\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().map().size(), 2);\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"hello world\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] responseBodies() {\n+        return new Object[][] { {\"hello world\"}, {\"\"} };\n+    }\n+\n+    @Test(dataProvider = \"responseBodies\")\n+    public void testOfThrowingExchange(String body) {\n+        var h = HttpHandlers.of(200, Headers.of(), body);\n+        {\n+            var exchange = new ThrowingHttpExchange() {\n+                public InputStream getRequestBody() {\n+                    throw new RuntimeException(\"getRequestBody\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"getRequestBody\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange() {\n+                public Headers getResponseHeaders() {\n+                    throw new RuntimeException(\"getResponseHeaders\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"getResponseHeaders\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange() {\n+                public void sendResponseHeaders(int rCode, long responseLength) {\n+                    throw new RuntimeException(\"sendResponseHeaders\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"sendResponseHeaders\");\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange() {\n+                public OutputStream getResponseBody() {\n+                    throw new RuntimeException(\"getResponseBody\");\n+                }\n+            };\n+            if (!body.isEmpty()) {  \/\/ getResponseBody not called if no responseBody\n+                var t = expectThrows(RE, () -> h.handle(exchange));\n+                assertEquals(t.getMessage(), \"getResponseBody\");\n+            }\n+        }\n+        {\n+            var exchange = new ThrowingHttpExchange() {\n+                public void close() {\n+                    throw new RuntimeException(\"close\");\n+                }\n+            };\n+            var t = expectThrows(RE, () -> h.handle(exchange));\n+            assertEquals(t.getMessage(), \"close\");\n+        }\n+    }\n+\n+    @Test\n+    public void testHandleOrElseTrue() throws Exception {\n+        var h1 = new TestHandler(\"TestHandler-1\");\n+        var h2 = new TestHandler(\"TestHandler-2\");\n+        var handler = HttpHandlers.handleOrElse(p -> true, h1, h2);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"TestHandler-1\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHandleOrElseFalse() throws Exception {\n+        var h1 = new TestHandler(\"TestHandler-1\");\n+        var h2 = new TestHandler(\"TestHandler-2\");\n+        var handler = HttpHandlers.handleOrElse(p -> false, h1, h2);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"TestHandler-2\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHandleOrElseNested() throws Exception {\n+        var h1 = new TestHandler(\"TestHandler-1\");\n+        var h2 = new TestHandler(\"TestHandler-2\");\n+        var h3 = new TestHandler(\"TestHandler-3\");\n+        var h4 = HttpHandlers.handleOrElse(p -> false, h1, h2);\n+        var handler = HttpHandlers.handleOrElse(p -> false, h3, h4);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"TestHandler-2\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    \/**\n+     * A test handler that discards the request and returns its name\n+     *\/\n+    static class TestHandler implements HttpHandler {\n+        final String name;\n+        TestHandler(String name) { this.name = name; }\n+        TestHandler() { this(\"no name\"); }\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = name.getBytes(UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    static class ThrowingHttpExchange extends HttpExchange {\n+        static final String requestMethod = \"GET\";\n+        volatile int responseCode;\n+        volatile long responseLength;\n+        volatile Headers responseHeaders;\n+        volatile InputStream requestBody;\n+\n+        ThrowingHttpExchange() {\n+            responseHeaders = new Headers();\n+            this.requestBody = InputStream.nullInputStream();\n+        }\n+\n+        @Override public Headers getResponseHeaders() { return responseHeaders; }\n+        @Override public InputStream getRequestBody() { return requestBody; }\n+        @Override public void sendResponseHeaders(int rCode, long responseLength) {\n+            this.responseCode = rCode;\n+            this.responseLength = responseLength;\n+        }\n+        @Override public OutputStream getResponseBody() {\n+            return OutputStream.nullOutputStream();\n+        }\n+        @Override public String getRequestMethod() { return requestMethod; }\n+\n+        @Override public Headers getRequestHeaders() { return null; }\n+        @Override public URI getRequestURI() { return null; }\n+        @Override public HttpContext getHttpContext() { return null; }\n+        @Override public void close() { }\n+        @Override public InetSocketAddress getRemoteAddress() { return null; }\n+        @Override public int getResponseCode() { return 0; }\n+        @Override public InetSocketAddress getLocalAddress() { return null; }\n+        @Override public String getProtocol() { return null; }\n+        @Override public Object getAttribute(String name) { return null; }\n+        @Override public void setAttribute(String name, Object value) { }\n+        @Override public void setStreams(InputStream i, OutputStream o) { }\n+        @Override public HttpPrincipal getPrincipal() { return null; }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/HttpHandlersTest.java","additions":362,"deletions":0,"binary":false,"changes":362,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test for HttpsServer::create\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm HttpsServerTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import javax.net.ssl.SSLContext;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertThrows;\n+\n+public class HttpsServerTest {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    SSLContext sslContext;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        sslContext = new SimpleSSLContext().get();\n+        SSLContext.setDefault(sslContext);\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        assertThrows(NPE, () -> HttpsServer.create(null, 0, null, new Handler()));\n+        assertThrows(NPE, () -> HttpsServer.create(null, 0, \"\/\", null));\n+        assertThrows(NPE, () -> HttpsServer.create(null, 0, \"\/\", new Handler(), (Filter)null));\n+        assertThrows(NPE, () -> HttpsServer.create(null, 0, \"\/\", new Handler(), new Filter[]{null}));\n+    }\n+\n+    @Test\n+    public void testCreate() throws IOException {\n+        assertNull(HttpsServer.create().getAddress());\n+\n+        final var s1 = HttpsServer.create(null, 0);\n+        assertNull(s1.getAddress());\n+        s1.bind((LOOPBACK_ADDR), 0);\n+        assertEquals(s1.getAddress().getAddress(), LOOPBACK_ADDR.getAddress());\n+\n+        final var s2 = HttpsServer.create(null, 0, \"\/foo\/\", new Handler());\n+        assertNull(s2.getAddress());\n+        s2.bind(LOOPBACK_ADDR, 0);\n+        assertEquals(s2.getAddress().getAddress(), LOOPBACK_ADDR.getAddress());\n+        s2.removeContext(\"\/foo\/\");  \/\/ throws if context doesn't exist\n+    }\n+\n+    @Test\n+    public void testExchange() throws Exception {\n+        var filter = new Filter();\n+        var server = HttpsServer.create(LOOPBACK_ADDR, 0, \"\/test\", new Handler(), filter);\n+        server.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder()\n+                    .proxy(NO_PROXY)\n+                    .sslContext(sslContext)\n+                    .build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\/test\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"hello world\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(),\n+                    Integer.toString(\"hello world\".length()));\n+            assertEquals(response.statusCode(), filter.responseCode.get().intValue());\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .scheme(\"https\")\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .path(path)\n+                .buildUnchecked();\n+    }\n+\n+    \/**\n+     * A test handler that discards the request and sends a response\n+     *\/\n+    static class Handler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A test post-processing filter that captures the response code\n+     *\/\n+    static class Filter extends com.sun.net.httpserver.Filter {\n+        final CompletableFuture<Integer> responseCode = new CompletableFuture<>();\n+\n+        @Override\n+        public void doFilter(HttpExchange exchange, Chain chain) throws IOException {\n+            chain.doFilter(exchange);\n+            responseCode.complete(exchange.getResponseCode());\n+        }\n+\n+        @Override\n+        public String description() {\n+            return \"HttpsServerTest Filter\";\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/HttpsServerTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import jdk.test.lib.net.URIBuilder;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Test idempotency and commutativity of responses with an exhaustive\n+ *          set of binary request sequences\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm IdempotencyAndCommutativityTest\n+ *\/\n+public class IdempotencyAndCommutativityTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final String FILE_NAME = \"file.txt\";\n+    static final String DIR_NAME = \"\";\n+    static final String MISSING_FILE_NAME = \"doesNotExist\";\n+\n+    static HttpServer server;\n+    static HttpClient client;\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        Path root = Files.createDirectories(CWD.resolve(\"testDirectory\"));\n+        Files.writeString(root.resolve(FILE_NAME), \"some text\", CREATE);\n+\n+        client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+        server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, SimpleFileServer.OutputLevel.VERBOSE);\n+        server.start();\n+    }\n+\n+    \/\/ Container of expected response state for a given request\n+    record ExchangeValues(String method, String resource, int respCode, String contentType) {}\n+\n+    \/\/ Creates an exhaustive set of binary exchange sequences\n+    @DataProvider\n+    public Object[][] allBinarySequences() {\n+        final List<ExchangeValues> sequences =  List.of(\n+                new ExchangeValues(\"GET\",     FILE_NAME,         200, \"text\/plain\"),\n+                new ExchangeValues(\"GET\",     DIR_NAME,          200, \"text\/html; charset=UTF-8\"),\n+                new ExchangeValues(\"GET\",     MISSING_FILE_NAME, 404, \"text\/html; charset=UTF-8\"),\n+                new ExchangeValues(\"HEAD\",    FILE_NAME,         200, \"text\/plain\"),\n+                new ExchangeValues(\"HEAD\",    DIR_NAME,          200, \"text\/html; charset=UTF-8\"),\n+                new ExchangeValues(\"HEAD\",    MISSING_FILE_NAME, 404, \"text\/html; charset=UTF-8\"),\n+                new ExchangeValues(\"UNKNOWN\", FILE_NAME,         501, null),\n+                new ExchangeValues(\"UNKNOWN\", DIR_NAME,          501, null),\n+                new ExchangeValues(\"UNKNOWN\", MISSING_FILE_NAME, 501, null)\n+        );\n+\n+        return sequences.stream()  \/\/ cartesian product\n+                        .flatMap(s1 -> sequences.stream().map(s2 -> new ExchangeValues[] { s1, s2 }))\n+                        .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"allBinarySequences\")\n+    public void testBinarySequences(ExchangeValues e1, ExchangeValues e2) throws Exception {\n+        System.out.println(\"---\");\n+        System.out.println(e1);\n+        executeExchange(e1);\n+        System.out.println(e2);\n+        executeExchange(e2);\n+    }\n+\n+    private static void executeExchange(ExchangeValues e) throws Exception {\n+        var request = HttpRequest.newBuilder(uri(server, e.resource()))\n+                                            .method(e.method(), HttpRequest.BodyPublishers.noBody())\n+                                            .build();\n+        var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+        assertEquals(response.statusCode(), e.respCode());\n+        if (e.contentType != null) {\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), e.contentType());\n+        } else {\n+            assertTrue(response.headers().firstValue(\"content-type\").isEmpty());\n+        }\n+    }\n+\n+    @AfterTest\n+    public static void teardown() {\n+        server.stop(0);\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/IdempotencyAndCommutativityTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests the FileServerHandler's mapping of request URI path to file\n+ *          system path\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm MapToPathTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Stream;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpHandlers;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static org.testng.Assert.assertEquals;\n+\n+public class MapToPathTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final Path TEST_DIR = CWD.resolve(\"MapToPathTest\").normalize();\n+\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+    static final Filter OUTPUT_FILTER = SimpleFileServer.createOutputFilter(out, OutputLevel.VERBOSE);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        createDirectories(TEST_DIR);\n+    }\n+\n+    private void createDirectories(Path testDir) throws IOException {\n+        \/\/      Create directory tree:\n+        \/\/\n+        \/\/      |-- TEST_DIR\n+        \/\/          |-- foo\n+        \/\/              |-- bar\n+        \/\/                  |-- baz\n+        \/\/                      |-- file.txt\n+        \/\/              |-- file.txt\n+        \/\/          |-- foobar\n+        \/\/              |-- file.txt\n+        \/\/          |-- file.txt\n+\n+        Files.createDirectories(TEST_DIR);\n+        Stream.of(\"foo\", \"foobar\", \"foo\/bar\/baz\").forEach(s -> {\n+            try {\n+                Path p = testDir.resolve(s);\n+                Files.createDirectories(p);\n+                Files.writeString(p.resolve(\"file.txt\"), s, CREATE);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        });\n+        Files.writeString(testDir.resolve(\"file.txt\"), \"testdir\", CREATE);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+        {\n+            var handler = SimpleFileServer.createFileHandler(TEST_DIR);\n+            var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler, OUTPUT_FILTER);\n+            server.start();\n+            try {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+                assertEquals(res1.headers().firstValue(\"content-length\").get(), Long.toString(257L));\n+                assertEquals(res1.headers().firstValue(\"last-modified\").get(), getLastModified(TEST_DIR));\n+\n+                var req2 = HttpRequest.newBuilder(uri(server, \"\/..\/\")).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 404);  \/\/ cannot escape root\n+\n+                var req3 = HttpRequest.newBuilder(uri(server, \"\/foo\/bar\/baz\/c:\/\/\")).build();\n+                var res3 = client.send(req3, BodyHandlers.ofString());\n+                assertEquals(res3.statusCode(), 404);  \/\/ not found\n+\n+                var req4 = HttpRequest.newBuilder(uri(server, \"\/foo\/file:\" + TEST_DIR.getParent())).build();\n+                var res4 = client.send(req4, BodyHandlers.ofString());\n+                assertEquals(res4.statusCode(), 404);  \/\/ not found\n+\n+                var req5 = HttpRequest.newBuilder(uri(server, \"\/foo\/bar\/\\\\..\\\\..\/\")).build();\n+                var res5 = client.send(req5, BodyHandlers.ofString());\n+                assertEquals(res5.statusCode(), 404);  \/\/ not found\n+\n+                var req6 = HttpRequest.newBuilder(uri(server, \"\/foo\")).build();\n+                var res6 = client.send(req6, BodyHandlers.ofString());\n+                assertEquals(res6.statusCode(), 301);  \/\/ redirect\n+                assertEquals(res6.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res6.headers().firstValue(\"location\").get(), \"\/foo\/\");\n+            } finally {\n+                server.stop(0);\n+            }\n+        }\n+        {\n+            var handler = SimpleFileServer.createFileHandler(TEST_DIR);\n+            var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/browse\/\", handler, OUTPUT_FILTER);\n+            server.start();\n+            try {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/browse\/file.txt\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"testdir\");\n+                assertEquals(res1.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+                assertEquals(res1.headers().firstValue(\"content-length\").get(), Long.toString(7L));\n+                assertEquals(res1.headers().firstValue(\"last-modified\").get(), getLastModified(TEST_DIR.resolve(\"file.txt\")));\n+\n+                var req2 = HttpRequest.newBuilder(uri(server, \"\/store\/file.txt\")).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 404);  \/\/ no context found\n+            } finally {\n+                server.stop(0);\n+            }\n+        }\n+        {\n+            \/\/ Test \"\/foo\/\" context (with trailing slash)\n+            var handler = SimpleFileServer.createFileHandler(TEST_DIR.resolve(\"foo\"));\n+            var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/foo\/\", handler, OUTPUT_FILTER);\n+            server.start();\n+            try {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/foo\/file.txt\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"foo\");\n+                assertEquals(res1.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+                assertEquals(res1.headers().firstValue(\"content-length\").get(), Long.toString(3L));\n+                assertEquals(res1.headers().firstValue(\"last-modified\").get(), getLastModified(TEST_DIR.resolve(\"foo\").resolve(\"file.txt\")));\n+\n+                var req2 = HttpRequest.newBuilder(uri(server, \"\/foobar\/file.txt\")).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 404);  \/\/ no context found\n+\n+                var req3 = HttpRequest.newBuilder(uri(server, \"\/foo\/..\/foobar\/file.txt\")).build();\n+                var res3 = client.send(req3, BodyHandlers.ofString());\n+                assertEquals(res3.statusCode(), 404);  \/\/ cannot escape context\n+\n+                var req4 = HttpRequest.newBuilder(uri(server, \"\/foo\/..\/..\")).build();\n+                var res4 = client.send(req4, BodyHandlers.ofString());\n+                assertEquals(res4.statusCode(), 404);  \/\/ cannot escape root\n+\n+                var req5 = HttpRequest.newBuilder(uri(server, \"\/foo\/bar\")).build();\n+                var res5 = client.send(req5, BodyHandlers.ofString());\n+                assertEquals(res5.statusCode(), 301);  \/\/ redirect\n+                assertEquals(res5.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res5.headers().firstValue(\"location\").get(), \"\/foo\/bar\/\");\n+            } finally {\n+                server.stop(0);\n+            }\n+        }\n+        {\n+            \/\/ Test \"\/foo\" context (without trailing slash)\n+            var handler = SimpleFileServer.createFileHandler(TEST_DIR.resolve(\"foo\"));\n+            var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/foo\", handler, OUTPUT_FILTER);\n+            server.start();\n+            try {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/foo\/file.txt\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"foo\");\n+                assertEquals(res1.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+                assertEquals(res1.headers().firstValue(\"content-length\").get(), Long.toString(3L));\n+                assertEquals(res1.headers().firstValue(\"last-modified\").get(), getLastModified(TEST_DIR.resolve(\"foo\").resolve(\"file.txt\")));\n+\n+                var req2 = HttpRequest.newBuilder(uri(server, \"\/foobar\/\")).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 404);  \/\/ handler prevents mapping to \/foo\/bar\n+\n+                var req3 = HttpRequest.newBuilder(uri(server, \"\/foobar\/file.txt\")).build();\n+                var res3 = client.send(req3, BodyHandlers.ofString());\n+                assertEquals(res3.statusCode(), 404);  \/\/ handler prevents mapping to \/foo\/bar\/file.txt\n+\n+                var req4 = HttpRequest.newBuilder(uri(server, \"\/file.txt\")).build();\n+                var res4 = client.send(req4, BodyHandlers.ofString());\n+                assertEquals(res4.statusCode(), 404);\n+\n+                var req5 = HttpRequest.newBuilder(uri(server, \"\/foo\/bar\")).build();\n+                var res5 = client.send(req5, BodyHandlers.ofString());\n+                assertEquals(res5.statusCode(), 301);  \/\/ redirect\n+                assertEquals(res5.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res5.headers().firstValue(\"location\").get(), \"\/foo\/bar\/\");\n+\n+                var req6 = HttpRequest.newBuilder(uri(server, \"\/foo\")).build();\n+                var res6 = client.send(req6, BodyHandlers.ofString());\n+                assertEquals(res6.statusCode(), 301);  \/\/ redirect\n+                assertEquals(res6.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res6.headers().firstValue(\"location\").get(), \"\/foo\/\");\n+            } finally {\n+                server.stop(0);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests with a mixture of in-memory and file handlers.\n+    @Test\n+    public void multipleContexts() throws Exception {\n+        var rootHandler = HttpHandlers.of(200, Headers.of(), \"root response body\");\n+        var fooHandler = SimpleFileServer.createFileHandler(TEST_DIR.resolve(\"foo\"));\n+        var foobarHandler = SimpleFileServer.createFileHandler(TEST_DIR.resolve(\"foobar\"));\n+        var barHandler = HttpHandlers.of(200, Headers.of(), \"bar response body\");\n+\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0);\n+        server.createContext(\"\/\", rootHandler);\n+        server.createContext(\"\/foo\/\", fooHandler);\n+        server.createContext(\"\/bar\/\", barHandler);\n+        server.createContext(\"\/foobar\/\", foobarHandler);\n+        server.start();\n+        var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+        try {\n+            for (String uriPath : List.of(\"\/\", \"\/blah\", \"\/xyz\/t\/z\", \"\/txt\") ) {\n+                out.println(\"uri.Path=\" + uriPath);\n+                var req1 = HttpRequest.newBuilder(uri(server, uriPath)).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"root response body\");\n+            }\n+            {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/foo\/file.txt\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"foo\");\n+\n+                var req2 = HttpRequest.newBuilder(uri(server, \"\/foo\/bar\/baz\/file.txt\")).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 200);\n+                assertEquals(res2.body(), \"foo\/bar\/baz\");\n+            }\n+            {\n+                var req1 = HttpRequest.newBuilder(uri(server, \"\/foobar\/file.txt\")).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"foobar\");\n+            }\n+            for (String uriPath : List.of(\"\/bar\/\", \"\/bar\/t\", \"\/bar\/t\/z\", \"\/bar\/index.html\") ) {\n+                out.println(\"uri.Path=\" + uriPath);\n+                var req1 = HttpRequest.newBuilder(uri(server, uriPath)).build();\n+                var res1 = client.send(req1, BodyHandlers.ofString());\n+                assertEquals(res1.statusCode(), 200);\n+                assertEquals(res1.body(), \"bar response body\");\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    \/\/ Tests requests with queries, which are simply ignored by the handler\n+    @Test\n+    public void requestWithQuery() throws Exception {\n+        var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+        var handler = SimpleFileServer.createFileHandler(TEST_DIR);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler, OUTPUT_FILTER);\n+        server.start();\n+        try {\n+            for (String query : List.of(\"x=y\", \"x=\", \"xxx\", \"#:?\") ) {\n+                out.println(\"uri.Query=\" + query);\n+                var req = HttpRequest.newBuilder(uri(server, \"\", query)).build();\n+                var res = client.send(req, BodyHandlers.ofString());\n+                assertEquals(res.statusCode(), 200);\n+                assertEquals(res.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+                assertEquals(res.headers().firstValue(\"content-length\").get(), Long.toString(257L));\n+                assertEquals(res.headers().firstValue(\"last-modified\").get(), getLastModified(TEST_DIR));\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(path)\n+                .buildUnchecked();\n+    }\n+\n+    static URI uri(HttpServer server, String path, String query) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(path)\n+                .query(query)\n+                .buildUnchecked();\n+    }\n+\n+    static String getLastModified(Path path) throws IOException {\n+        return Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/MapToPathTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for OutputFilter\n+ * @modules java.base\/sun.net.www:+open\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm -Djdk.httpclient.redirects.retrylimit=1 OutputFilterTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Pattern;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.*;\n+import static com.sun.net.httpserver.SimpleFileServer.OutputLevel.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+import static org.testng.Assert.assertTrue;\n+\n+public class OutputFilterTest {\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<IOException> IOE = IOException.class;\n+\n+    static final OutputStream OUT = new ByteArrayOutputStream();\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger logger = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            logger.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            logger.addHandler(ch);\n+        }\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(null, null));\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(null, VERBOSE));\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(OUT, null));\n+    }\n+\n+    @Test\n+    public void testDescription() {\n+        var filter = SimpleFileServer.createOutputFilter(OUT, VERBOSE);\n+        assertEquals(filter.description(), \"HttpExchange OutputFilter (outputLevel: VERBOSE)\");\n+\n+        filter = SimpleFileServer.createOutputFilter(OUT, INFO);\n+        assertEquals(filter.description(), \"HttpExchange OutputFilter (outputLevel: INFO)\");\n+    }\n+\n+    @Test\n+    public void testNONE() {\n+        assertThrows(IAE, () -> SimpleFileServer.createOutputFilter(OUT, NONE));\n+    }\n+\n+    \/**\n+     * Confirms that the output filter produces the expected output for a\n+     * successful exchange (with the request-path attribute set.)\n+     *\/\n+    @Test\n+    public void testExchange() throws Exception {\n+        var baos = new ByteArrayOutputStream();\n+        var handler = new RequestPathHandler();\n+        var filter = SimpleFileServer.createOutputFilter(baos, VERBOSE);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler, filter);\n+        server.start();\n+        try (baos) {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 3);\n+            assertEquals(response.body(), \"hello world\");\n+        } finally {\n+            server.stop(0);\n+            baos.flush();\n+            var filterOutput = baos.toString(UTF_8);\n+            var pattern = Pattern.compile(\"\"\"\n+                    127\\\\.0\\\\.0\\\\.1 - - \\\\[[\\\\s\\\\S]+] \"GET \/ HTTP\/1\\\\.1\" 200 -\n+                    Resource requested: \/foo\/bar\n+                    (>[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    >\n+                    (<[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    <\n+                    \"\"\".replaceAll(\"\\n\", System.lineSeparator()));\n+            assertTrue(pattern.matcher(filterOutput).matches());\n+\n+            \/*\n+             * Expected output format:\n+             *     \"\"\"\n+             *     127.0.0.1 - - [06\/Jul\/2021:12:56:47 +0100] \"GET \/ HTTP\/1.1\" 200 -\n+             *     Resource requested: \/foo\/bar\n+             *     > Connection: Upgrade, HTTP2-Settings\n+             *     > Http2-settings: AAEAAEAAAAIAAAABAAMAAABkAAQBAAAAAAUAAEAA\n+             *     > Host: localhost:59146\n+             *     > Upgrade: h2c\n+             *     > User-agent: Java-http-client\/18-internal\n+             *     > Content-length: 0\n+             *     >\n+             *     < Date: Tue, 06 Jul 2021 11:56:47 GMT\n+             *     < Content-length: 11\n+             *     <\n+             *     \"\"\";\n+             *\/\n+        }\n+    }\n+\n+    \/**\n+     * Confirms that the output filter produces the expected output for\n+     * a successful exchange (without the request-path attribute set.)\n+     *\/\n+    @Test\n+    public void testExchangeWithoutRequestPath() throws Exception {\n+        var baos = new ByteArrayOutputStream();\n+        var handler = new NoRequestPathHandler();\n+        var filter = SimpleFileServer.createOutputFilter(baos, VERBOSE);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler, filter);\n+        server.start();\n+        try (baos) {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().map().size(), 2);\n+            assertEquals(response.body(), \"hello world\");\n+        } finally {\n+            server.stop(0);\n+            baos.flush();\n+            var filterOutput = baos.toString(UTF_8);\n+            var pattern = Pattern.compile(\"\"\"\n+                    127\\\\.0\\\\.0\\\\.1 - - \\\\[[\\\\s\\\\S]+] \"GET \/ HTTP\/1\\\\.1\" 200 -\n+                    (>[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    >\n+                    (<[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    <\n+                    \"\"\".replaceAll(\"\\n\", System.lineSeparator()));\n+            assertTrue(pattern.matcher(filterOutput).matches());\n+\n+            \/*\n+             * Expected output:\n+             *     \"\"\"\n+             *     127.0.0.1 - - [12\/Jul\/2021:10:05:10 +0000] \"GET \/ HTTP\/1.1\" 200 -\n+             *     > Connection: Upgrade, HTTP2-Settings\n+             *     > Http2-settings: AAEAAEAAAAIAAAABAAMAAABkAAQBAAAAAAUAAEAA\n+             *     > Host: localhost:57931\n+             *     > Upgrade: h2c\n+             *     > User-agent: Java-http-client\/18-internal\n+             *     > Content-length: 0\n+             *     >\n+             *     < Date: Mon, 12 Jul 2021 10:05:10 GMT\n+             *     < Content-length: 11\n+             *     <\n+             *     \"\"\";\n+             *\/\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] throwingHandler() {\n+        return new Object[][] {\n+                {VERBOSE, \"Error: server exchange handling failed: IOE ThrowingHandler\" + System.lineSeparator()},\n+                {INFO, \"Error: server exchange handling failed: IOE ThrowingHandler\" + System.lineSeparator()},\n+                {NONE, \"\"}\n+        };\n+    }\n+\n+    \/**\n+     * Confirms that the output filter captures a throwable that is thrown\n+     * during the exchange handling and prints the expected error message.\n+     * The \"httpclient.redirects.retrylimit\" system property is set to 1 to\n+     * prevent retries on the client side, which would result in more than one\n+     * error message.\n+     *\/\n+    @Test(dataProvider = \"throwingHandler\")\n+    public void testExchangeThrowingHandler(OutputLevel level,\n+                                            String expectedOutput) throws Exception {\n+        var baos = new ByteArrayOutputStream();\n+        var handler = new ThrowingHandler();\n+        HttpServer server;\n+        if (level.equals(NONE)) {\n+            server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler);\n+        } else {\n+            var filter = SimpleFileServer.createOutputFilter(baos, level);\n+            server = HttpServer.create(LOOPBACK_ADDR, 10, \"\/\", handler, filter);\n+        }\n+        server.start();\n+        try (baos) {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            assertThrows(IOE, () -> client.send(request, HttpResponse.BodyHandlers.ofString()));\n+        } finally {\n+            server.stop(0);\n+            baos.flush();\n+            assertEquals(baos.toString(UTF_8), expectedOutput);\n+        }\n+    }\n+\n+    \/**\n+     * Confirms that the output filter prints the expected message if the request\n+     * URI cannot be resolved. This only applies if the filter is used in\n+     * combination with the SimpleFileServer file-handler, which sets the\n+     * necessary request-path attribute.\n+     *\/\n+    @Test\n+    public void testCannotResolveRequestURI() throws Exception {\n+        var baos = new ByteArrayOutputStream();\n+        var handler = SimpleFileServer.createFileHandler(Path.of(\".\").toAbsolutePath());\n+        var filter = SimpleFileServer.createOutputFilter(baos, VERBOSE);\n+        var server = HttpServer.create(LOOPBACK_ADDR, 0, \"\/\", handler, filter);\n+        server.start();\n+        try (baos) {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile\\u0000.txt\")).build();\n+            var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().map().size(), 3);\n+        } finally {\n+            server.stop(0);\n+            baos.flush();\n+            var filterOutput = baos.toString(UTF_8);\n+            var pattern = Pattern.compile(\"\"\"\n+                    127\\\\.0\\\\.0\\\\.1 - - \\\\[[\\\\s\\\\S]+] \"GET \/aFile%00\\\\.txt HTTP\/1\\\\.1\" 404 -\n+                    Resource requested: could not resolve request URI path\n+                    (>[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    >\n+                    (<[\\\\s\\\\S]+:[\\\\s\\\\S]+)+\n+                    <\n+                    \"\"\".replaceAll(\"\\n\", System.lineSeparator()));\n+            assertTrue(pattern.matcher(filterOutput).matches());\n+        }\n+    }\n+\n+    \/\/ --- infra ---\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    \/**\n+     * A handler that sets the request-path attribute and a custom header\n+     * and sends a response.\n+     *\/\n+    static class RequestPathHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                exchange.setAttribute(\"request-path\", \"\/foo\/bar\");\n+                exchange.getResponseHeaders().put(\"Foo\", List.of(\"bar\", \"bar\"));\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A handler that sets no request-path attribute and sends a response.\n+     *\/\n+    static class NoRequestPathHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A handler that throws an IOException.\n+     *\/\n+    static class ThrowingHandler implements HttpHandler {\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (exchange) {\n+                throw new IOException(\"IOE ThrowingHandler\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/OutputFilterTest.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for Request\n+ * @run testng RequestTest\n+ *\/\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import com.sun.net.httpserver.*;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertThrows;\n+\n+public class RequestTest {\n+\n+    @Test\n+    public void testAddToEmpty() {\n+        var headers = new Headers();\n+        Request request = new TestHttpExchange(headers);\n+        request = request.with(\"Foo\", List.of(\"Bar\"));\n+        assertEquals(request.getRequestHeaders().size(), 1);\n+        assertEquals(request.getRequestHeaders().get(\"Foo\"), List.of(\"Bar\"));\n+        assertReadOnly(request.getRequestHeaders());\n+    }\n+\n+    @Test\n+    public void testAddition() {\n+        var headers = new Headers();\n+        headers.add(\"Foo\", \"Bar\");\n+        Request request = new TestHttpExchange(headers);\n+        request = request.with(\"X-Foo\", List.of(\"Bar\"));\n+        assertEquals(request.getRequestHeaders().size(), 2);\n+        assertEquals(request.getRequestHeaders().get(\"Foo\"), List.of(\"Bar\"));\n+        assertEquals(request.getRequestHeaders().get(\"X-Foo\"), List.of(\"Bar\"));\n+        assertReadOnly(request.getRequestHeaders());\n+    }\n+\n+    @Test\n+    public void testAddWithExisting() {\n+        final String headerName = \"Foo\";\n+        var headers = new Headers();\n+        headers.add(headerName, \"Bar\");\n+        Request request = new TestHttpExchange(headers);\n+        request = request.with(headerName, List.of(\"blahblahblah\"));\n+        assertEquals(request.getRequestHeaders().size(), 1);\n+        assertEquals(request.getRequestHeaders().get(headerName), List.of(\"Bar\"));\n+        assertReadOnly(request.getRequestHeaders());\n+    }\n+\n+    @Test\n+    public void testAddSeveral() {\n+        var headers = new Headers();\n+        headers.add(\"Foo\", \"Bar\");\n+        Request request = new TestHttpExchange(headers);\n+        request = request.with(\"Larry\", List.of(\"a\"))\n+                         .with(\"Curly\", List.of(\"b\"))\n+                         .with(\"Moe\",   List.of(\"c\"));\n+        assertEquals(request.getRequestHeaders().size(), 4);\n+        assertEquals(request.getRequestHeaders().getFirst(\"Foo\"), \"Bar\");\n+        assertEquals(request.getRequestHeaders().getFirst(\"Larry\"), \"a\");\n+        assertEquals(request.getRequestHeaders().getFirst(\"Curly\"), \"b\");\n+        assertEquals(request.getRequestHeaders().getFirst(\"Moe\"  ), \"c\");\n+        assertReadOnly(request.getRequestHeaders());\n+    }\n+\n+    static final Class<UnsupportedOperationException> UOP = UnsupportedOperationException.class;\n+\n+    static void assertReadOnly(Headers headers) {\n+        assertUnsupportedOperation(headers);\n+        assertUnmodifiableCollection(headers);\n+        assertUnmodifiableList(headers);\n+    }\n+\n+    static void assertUnsupportedOperation(Headers headers) {\n+        assertThrows(UOP, () -> headers.add(\"a\", \"b\"));\n+        assertThrows(UOP, () -> headers.compute(\"c\", (k, v) -> List.of(\"c\")));\n+        assertThrows(UOP, () -> headers.computeIfAbsent(\"d\", k -> List.of(\"d\")));\n+        assertThrows(UOP, () -> headers.computeIfPresent(\"Foo\", (k, v) -> null));\n+        assertThrows(UOP, () -> headers.merge(\"e\", List.of(\"e\"), (k, v) -> List.of(\"e\")));\n+        assertThrows(UOP, () -> headers.put(\"f\", List.of(\"f\")));\n+        assertThrows(UOP, () -> headers.putAll(Map.of()));\n+        assertThrows(UOP, () -> headers.putIfAbsent(\"g\", List.of(\"g\")));\n+        assertThrows(UOP, () -> headers.remove(\"h\"));\n+        assertThrows(UOP, () -> headers.replace(\"i\", List.of(\"i\")));\n+        assertThrows(UOP, () -> headers.replace(\"j\", List.of(\"j\"), List.of(\"j\")));\n+        assertThrows(UOP, () -> headers.replaceAll((k, v) -> List.of(\"k\")));\n+        assertThrows(UOP, () -> headers.set(\"l\", \"m\"));\n+        assertThrows(UOP, () -> headers.clear());\n+    }\n+\n+    static void assertUnmodifiableCollection(Headers headers) {\n+        var entry = new AbstractMap.SimpleEntry<>(\"n\", List.of(\"n\"));\n+\n+        assertThrows(UOP, () -> headers.values().remove(List.of(\"Bar\")));\n+        assertThrows(UOP, () -> headers.values().removeAll(List.of(\"Bar\")));\n+        assertThrows(UOP, () -> headers.keySet().remove(\"Foo\"));\n+        assertThrows(UOP, () -> headers.keySet().removeAll(List.of(\"Foo\")));\n+        assertThrows(UOP, () -> headers.entrySet().remove(entry));\n+        assertThrows(UOP, () -> headers.entrySet().removeAll(List.of(entry)));\n+    }\n+\n+    static void assertUnmodifiableList(Headers headers) {\n+        assertThrows(UOP, () -> headers.get(\"Foo\").remove(0));\n+        assertThrows(UOP, () -> headers.get(\"foo\").remove(0));\n+        assertThrows(UOP, () -> headers.values().stream().findFirst().orElseThrow().remove(0));\n+        assertThrows(UOP, () -> headers.entrySet().stream().findFirst().orElseThrow().getValue().remove(0));\n+    }\n+\n+    static class TestHttpExchange extends StubHttpExchange {\n+        final Headers headers;\n+        TestHttpExchange(Headers headers) {\n+            this.headers = headers;\n+        }\n+        @Override\n+        public Headers getRequestHeaders() {\n+            return headers;\n+        }\n+    }\n+\n+    static class StubHttpExchange extends HttpExchange {\n+        @Override public Headers getRequestHeaders() { return null; }\n+        @Override public Headers getResponseHeaders() { return null; }\n+        @Override public URI getRequestURI() { return null; }\n+        @Override public String getRequestMethod() { return null; }\n+        @Override public HttpContext getHttpContext() { return null; }\n+        @Override public void close() { }\n+        @Override public InputStream getRequestBody() { return null; }\n+        @Override public OutputStream getResponseBody() { return null; }\n+        @Override public void sendResponseHeaders(int rCode, long responseLength) { }\n+        @Override public InetSocketAddress getRemoteAddress() { return null; }\n+        @Override public int getResponseCode() { return 0; }\n+        @Override public InetSocketAddress getLocalAddress() { return null; }\n+        @Override public String getProtocol() { return null; }\n+        @Override public Object getAttribute(String name) { return null; }\n+        @Override public void setAttribute(String name, Object value) { }\n+        @Override public void setStreams(InputStream i, OutputStream o) { }\n+        @Override public HttpPrincipal getPrincipal() { return null; }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/RequestTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for FileServerHandler with SecurityManager\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run main\/othervm\/java.security.policy=SecurityManagerTestRead.policy -ea SecurityManagerTest true\n+ * @run main\/othervm\/java.security.policy=SecurityManagerTestNoRead.policy -ea SecurityManagerTest false\n+ * @run main\/othervm -ea SecurityManagerTest true\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.AccessControlException;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.util.FileUtils;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+\n+\/**\n+ * Tests the permission checks during the creation of a FileServerHandler.\n+ *\n+ * A FileServerHandler can only be created if a \"read\" FilePermission is\n+ * granted for the root directory passed. The test consists of 3 runs:\n+ *     1) security manager enabled and \"read\" FilePermission granted\n+ *     2) security manager enabled and \"read\" FilePermission NOT granted\n+ *     3) security manager NOT enabled\n+ * 2) misses the required permissions to call many of the java.nio.file methods,\n+ * the test works around this by reusing the test directory created in the\n+ * previous run.\n+* *\/\n+public class SecurityManagerTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n+    static final Path TEST_DIR = CWD.resolve(\"SecurityManagerTest\");\n+    static final InetSocketAddress LOOPBACK_ADDR =\n+            new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    static boolean readPermitted;\n+    static String lastModifiedDir;\n+    static String lastModifiedFile;\n+\n+    public static void main(String[] args) throws Exception {\n+        setupLogging();\n+        readPermitted = Boolean.parseBoolean(args[0]);\n+        if (readPermitted) {\n+            createTestDir();\n+            testDirectoryGET();\n+            testFileGET();\n+        } else {  \/\/ no FilePermission \"read\" for TEST_DIR granted,\n+                  \/\/ assert handler cannot be created\n+            testCreateHandler();\n+        }\n+    }\n+\n+    private static void setupLogging() {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+    }\n+\n+    private static void createTestDir() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+        var file = Files.writeString(TEST_DIR.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        lastModifiedDir = getLastModified(TEST_DIR);\n+        lastModifiedFile = getLastModified(file);\n+    }\n+\n+    private static void testDirectoryGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <li><a href=\"aFile.txt\">aFile.txt<\/a><\/li>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, TEST_DIR, OutputLevel.VERBOSE);\n+\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assert response.statusCode() == 200;\n+            assert response.body().equals(expectedBody);\n+            assert response.headers().firstValue(\"content-type\").get().equals(\"text\/html; charset=UTF-8\");\n+            assert response.headers().firstValue(\"content-length\").get().equals(expectedLength);\n+            assert response.headers().firstValue(\"last-modified\").get().equals(lastModifiedDir);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private static void testFileGET() throws Exception {\n+        var expectedBody = \"some text\";\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, TEST_DIR, OutputLevel.VERBOSE);\n+\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assert response.statusCode() == 200;\n+            assert response.body().equals(\"some text\");\n+            assert response.headers().firstValue(\"content-type\").get().equals(\"text\/plain\");\n+            assert response.headers().firstValue(\"content-length\").get().equals(expectedLength);\n+            assert response.headers().firstValue(\"last-modified\").get().equals(lastModifiedFile);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void testCreateHandler(){\n+        try {\n+            SimpleFileServer.createFileServer(LOOPBACK_ADDR, TEST_DIR, OutputLevel.NONE);\n+            throw new RuntimeException(\"Handler creation expected to fail\");\n+        } catch (AccessControlException expected) { }\n+\n+        try {\n+            SimpleFileServer.createFileHandler(TEST_DIR);\n+            throw new RuntimeException(\"Handler creation expected to fail\");\n+        } catch (AccessControlException expected) { }\n+    }\n+\n+    static final String openHTML = \"\"\"\n+                <!DOCTYPE html>\n+                <html>\n+                <head>\n+                <meta charset=\"utf-8\"\/>\n+                <\/head>\n+                <body>\n+                \"\"\";\n+\n+    static final String closeHTML = \"\"\"\n+                <\/body>\n+                <\/html>\n+                \"\"\";\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    static String getLastModified(Path path) throws IOException {\n+        return Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SecurityManagerTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+\/\/ for JTwork\/classes\/test\/lib\/jdk\/test\/lib\/util\/FileUtils.class\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/..\/..\/test\/lib\/-\" {\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+};\n+\n+grant codeBase \"file:${test.classes}\/*\" {\n+    permission java.net.URLPermission \"http:\/\/localhost:*\/*\", \"GET\";\n+\n+    \/\/ for HTTP server\n+    permission java.net.SocketPermission \"localhost:*\", \"accept,resolve\";\n+\n+    \/\/ for HTTP\/1.1 server logging\n+    permission java.util.logging.LoggingPermission \"control\";\n+\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+};\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SecurityManagerTestNoRead.policy","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+\/\/ for JTwork\/classes\/test\/lib\/jdk\/test\/lib\/util\/FileUtils.class\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/..\/..\/test\/lib\/-\" {\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+};\n+\n+grant codeBase \"file:${test.classes}\/*\" {\n+    permission java.net.URLPermission \"http:\/\/localhost:*\/*\", \"GET\";\n+\n+    \/\/ for test directory tree\n+    permission java.io.FilePermission \"${user.dir}${\/}SecurityManagerTest\", \"read,write,delete\";\n+    permission java.io.FilePermission \"${user.dir}${\/}SecurityManagerTest\/-\", \"read,write,delete\";\n+\n+    \/\/ for HTTP server\n+    permission java.net.SocketPermission \"localhost:*\", \"accept,resolve\";\n+\n+    \/\/ for HTTP\/1.1 server logging\n+    permission java.util.logging.LoggingPermission \"control\";\n+\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+};\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SecurityManagerTestRead.policy","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import jdk.test.lib.net.URIBuilder;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import sun.net.www.MimeTable;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary Tests for MIME types in response headers\n+ * @modules java.base\/sun.net.www:+open\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm ServerMimeTypesResolutionTest\n+ *\/\n+public class ServerMimeTypesResolutionTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+    static final String FILE_NAME = \"empty-file-of-type\";\n+    static final String UNKNOWN_FILE_EXTENSION = \".unknown-file-extension\";\n+    static final Properties SUPPORTED_MIME_TYPES = new Properties();\n+    static final Set<String> UNSUPPORTED_FILE_EXTENSIONS = new HashSet<>();\n+    static List<String> supportedFileExtensions;\n+    static Path root;\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        getSupportedMimeTypes(SUPPORTED_MIME_TYPES);\n+        supportedFileExtensions = getFileExtensions(SUPPORTED_MIME_TYPES);\n+        root = createFileTreeFromMimeTypes(SUPPORTED_MIME_TYPES);\n+    }\n+\n+    public static Properties getSupportedMimeTypes(Properties properties) throws IOException {\n+        properties.load(MimeTable.class.getResourceAsStream(\"content-types.properties\"));\n+        return properties;\n+    }\n+\n+    private static List<String> getFileExtensions(Properties input) {\n+        return new ArrayList<>(getMimeTypesPerFileExtension(input).keySet());\n+    }\n+\n+    private static Map<String,String> getMimeTypesPerFileExtension(Properties input) {\n+        return input\n+                .entrySet()\n+                .stream()\n+                .filter(entry -> ((String)entry.getValue()).contains(\"file_extensions\"))\n+                .flatMap(entry ->\n+                        Arrays.stream(\n+                                ((String)deserialize((String) entry.getValue(), \";\")\n+                                        .get(\"file_extensions\")).split(\",\"))\n+                        .map(extension ->\n+                                Map.entry(extension, entry.getKey().toString())))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Path createFileTreeFromMimeTypes(Properties properties)\n+            throws IOException {\n+        final Path root = Files.createDirectory(CWD.resolve(ServerMimeTypesResolutionTest.class.getSimpleName()));\n+        for (String extension : supportedFileExtensions) {\n+            Files.createFile(root.resolve(toFileName(extension)));\n+        }\n+        Files.createFile(root.resolve(toFileName(UNKNOWN_FILE_EXTENSION)));\n+        return root;\n+    }\n+\n+    private static String toFileName(String extension) {\n+        return \"%s%s\".formatted(FILE_NAME, extension);\n+    }\n+\n+    protected static Properties deserialize(String serialized, String delimiter) {\n+        try {\n+            Properties properties = new Properties();\n+            properties.load(\n+                new StringReader(\n+                    Optional.ofNullable(delimiter)\n+                            .map(d -> serialized.replaceAll(delimiter, System.lineSeparator()))\n+                            .orElse(serialized)\n+                )\n+            );\n+            return properties;\n+        } catch (IOException exception) {\n+            exception.printStackTrace();\n+            throw new RuntimeException((\"error while deserializing string %s \" +\n+                    \"to properties\").formatted(serialized), exception);\n+        }\n+    }\n+\n+    @Test\n+    public static void testMimeTypeHeaders() throws Exception {\n+        final var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, SimpleFileServer.OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            final var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            final Map<String, String> mimeTypesPerFileExtension = getMimeTypesPerFileExtension(SUPPORTED_MIME_TYPES);\n+            for (String extension : supportedFileExtensions) {\n+                final String expectedMimeType = mimeTypesPerFileExtension.get(extension);\n+                execute(server, client, extension, expectedMimeType);\n+            }\n+            execute(server, client, UNKNOWN_FILE_EXTENSION,\"application\/octet-stream\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private static void execute(HttpServer server,\n+                                HttpClient client,\n+                                String extension,\n+                                String expectedMimeType)\n+            throws IOException, InterruptedException {\n+        final var uri = uri(server, toFileName(extension));\n+        final var request = HttpRequest.newBuilder(uri).build();\n+        final var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n+        assertEquals(response.statusCode(), 200);\n+        assertEquals(response.headers().firstValue(\"content-type\").get(),expectedMimeType);\n+    }\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    @DataProvider\n+    public static Object[][] commonExtensions() {\n+        Set<String> extensions = Set.of(\".aac\", \".abw\", \".arc\", \".avi\", \".azw\", \".bin\", \".bmp\", \".bz\",\n+                \".bz2\", \".csh\", \".css\", \".csv\", \".doc\", \".docx\",\".eot\", \".epub\", \".gz\", \".gif\", \".htm\", \".html\", \".ico\",\n+                \".ics\", \".jar\", \".jpeg\", \".jpg\", \".js\", \".json\", \".jsonld\", \".mid\", \".midi\", \".mjs\", \".mp3\", \".cda\",\n+                \".mp4\", \".mpeg\", \".mpkg\", \".odp\", \".ods\", \".odt\", \".oga\", \".ogv\", \".ogx\", \".opus\", \".otf\", \".png\",\n+                \".pdf\", \".php\", \".ppt\", \".pptx\", \".rar\", \".rtf\", \".sh\", \".svg\", \".swf\", \".tar\", \".tif\", \".tiff\", \".ts\",\n+                \".ttf\", \".txt\", \".vsd\", \".wav\", \".weba\", \".webm\", \".webp\", \".woff\", \".woff2\", \".xhtml\", \".xls\", \".xlsx\",\n+                \".xml\", \".xul\", \".zip\", \".3gp\", \".3g2\", \".7z\");\n+        return extensions.stream().map(e -> new Object[]{e}).toArray(Object[][]::new);\n+    }\n+\n+    \/**\n+     * This is a one-off test to check which common file extensions are\n+     * currently supported by the system-wide mime table returned by\n+     * {@linkplain java.net.FileNameMap#getContentTypeFor(String) getContentTypeFor}.\n+     *\n+     * Source common mime types:\n+     * https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTTP\/Basics_of_HTTP\/MIME_types\/Common_types\n+     *\/\n+\/\/    @Test(dataProvider = \"commonExtensions\")\n+    public static void testCommonExtensions(String extension) {\n+        var contains = supportedFileExtensions.contains(extension);\n+        if (!contains) UNSUPPORTED_FILE_EXTENSIONS.add(extension);\n+        assertTrue(contains, \"expecting %s to be present\".formatted(extension));\n+    }\n+\n+\/\/    @AfterTest\n+    public static void printUnsupportedFileExtensions() {\n+        System.out.println(\"Unsupported file extensions: \" + UNSUPPORTED_FILE_EXTENSIONS.size());\n+        UNSUPPORTED_FILE_EXTENSIONS.forEach(System.out::println);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/ServerMimeTypesResolutionTest.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,703 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for SimpleFileServer\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm SimpleFileServerTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static org.testng.Assert.*;\n+\n+public class SimpleFileServerTest {\n+\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<UncheckedIOException> UIOE = UncheckedIOException.class;\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final Path TEST_DIR = CWD.resolve(\"SimpleFileServerTest\");\n+\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+    }\n+\n+    @Test\n+    public void testFileGET() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testFileGET\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"some text\");\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <li><a href=\"aFile.txt\">aFile.txt<\/a><\/li>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testDirectoryGET\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testFileHEAD() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testFileHEAD\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryHEAD() throws Exception {\n+        var expectedLength = Integer.toString(\n+                (openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <li><a href=\"aFile.txt\">aFile.txt<\/a><\/li>\n+                <\/ul>\n+                \"\"\" + closeHTML).getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testDirectoryHEAD\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] indexFiles() {\n+        var fileContent = openHTML + \"\"\"\n+                <h1>This is an index file<\/h1>\n+                \"\"\" + closeHTML;\n+        var dirListing = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        return new Object[][] {\n+                {\"1\", \"index.html\", \"text\/html\",                \"116\", fileContent, true},\n+                {\"2\", \"index.htm\",  \"text\/html\",                \"116\", fileContent, true},\n+                {\"3\", \"index.txt\",  \"text\/html; charset=UTF-8\", \"134\", dirListing,  false}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"indexFiles\")\n+    public void testDirectoryWithIndexGET(String id,\n+                                          String filename,\n+                                          String contentType,\n+                                          String contentLength,\n+                                          String expectedBody,\n+                                          boolean serveIndexFile) throws Exception {\n+        var root = Files.createDirectories(TEST_DIR.resolve(\"testDirectoryWithIndexGET\"+id));\n+        var lastModified = getLastModified(root);\n+        if (serveIndexFile) {\n+            var file = Files.writeString(root.resolve(filename), expectedBody, CREATE);\n+            lastModified = getLastModified(file);\n+        }\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), contentType);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), contentLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            if (serveIndexFile) {\n+                Files.delete(root.resolve(filename));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNotReadableFileGET() throws Exception {\n+        if (!Platform.isWindows()) {  \/\/ not applicable on Windows\n+            var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+            var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+            var root = Files.createDirectory(TEST_DIR.resolve(\"testNotReadableFileGET\"));\n+            var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+\n+            file.toFile().setReadable(false, false);\n+            assert !Files.isReadable(file);\n+\n+            var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+            server.start();\n+            try {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+                var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 404);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+                assertEquals(response.body(), expectedBody);\n+            } finally {\n+                server.stop(0);\n+                file.toFile().setReadable(true, false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNotReadableSegmentGET() throws Exception {\n+        if (!Platform.isWindows()) {  \/\/ not applicable on Windows\n+            var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;dir&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+            var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+            var root = Files.createDirectory(TEST_DIR.resolve(\"testNotReadableSegmentGET\"));\n+            var dir = Files.createDirectory(root.resolve(\"dir\"));\n+            var file = Files.writeString(dir.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+\n+            dir.toFile().setReadable(false, false);\n+            assert !Files.isReadable(dir);\n+            assert Files.isReadable(file);\n+\n+            var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+            server.start();\n+            try {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+                var request = HttpRequest.newBuilder(uri(server, \"dir\/aFile.txt\")).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 404);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+                assertEquals(response.body(), expectedBody);\n+            } finally {\n+                server.stop(0);\n+                dir.toFile().setReadable(true, false);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testInvalidRequestURIGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;aFile?#.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testInvalidRequestURIGET\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile?#.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testNotFoundGET\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundHEAD() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testNotFoundHEAD\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSymlinkGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;symlink<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testSymlinkGET\"));\n+        var symlink = root.resolve(\"symlink\");\n+        var target = Files.writeString(root.resolve(\"target.txt\"), \"some text\", CREATE);\n+        Files.createSymbolicLink(symlink, target);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"symlink\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testSymlinkSegmentGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;symlink&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testSymlinkSegmentGET\"));\n+        var symlink = root.resolve(\"symlink\");\n+        var target = Files.createDirectory(root.resolve(\"target\"));\n+        Files.writeString(target.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        Files.createSymbolicLink(symlink, target);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"symlink\/aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHiddenFileGET() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testHiddenFileGET\"));\n+        var file = createHiddenFile(root);\n+        var fileName = file.getFileName().toString();\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;\"\"\" + fileName +\n+                \"\"\"\n+                <\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, fileName)).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testHiddenSegmentGET() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testHiddenSegmentGET\"));\n+        var file = createFileInHiddenDirectory(root);\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;.hiddenDirectory&#x2F;aFile.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \".hiddenDirectory\/aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private Path createHiddenFile(Path root) throws IOException {\n+        Path file;\n+        if (Platform.isWindows()) {\n+            file = Files.createFile(root.resolve(\"aFile.txt\"));\n+            Files.setAttribute(file, \"dos:hidden\", true, LinkOption.NOFOLLOW_LINKS);\n+        } else {\n+            file = Files.writeString(root.resolve(\".aFile.txt\"), \"some text\", CREATE);\n+        }\n+        assertTrue(Files.isHidden(file));\n+        return file;\n+    }\n+\n+    private Path createFileInHiddenDirectory(Path root) throws IOException {\n+        Path dir;\n+        Path file;\n+        if (Platform.isWindows()) {\n+            dir = Files.createDirectory(root.resolve(\"hiddenDirectory\"));\n+            Files.setAttribute(dir, \"dos:hidden\", true, LinkOption.NOFOLLOW_LINKS);\n+        } else {\n+            dir = Files.createDirectory(root.resolve(\".hiddenDirectory\"));\n+        }\n+        file = Files.writeString(dir.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        assertTrue(Files.isHidden(dir));\n+        assertFalse(Files.isHidden(file));\n+        return file;\n+    }\n+\n+    @Test\n+    public void testMovedPermanently() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testMovedPermanently\"));\n+        Files.createDirectory(root.resolve(\"aDirectory\"));\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;aDirectory&#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            {\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY)\n+                        .followRedirects(HttpClient.Redirect.NEVER).build();\n+                var uri = uri(server, \"aDirectory\");\n+                var request = HttpRequest.newBuilder(uri).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 301);\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(response.headers().firstValue(\"location\").get(), \"\/aDirectory\/\");\n+\n+                \/\/ tests that query component is preserved during redirect\n+                var uri2 = uri(server, \"aDirectory\", \"query\");\n+                var req2 = HttpRequest.newBuilder(uri2).build();\n+                var res2 = client.send(req2, BodyHandlers.ofString());\n+                assertEquals(res2.statusCode(), 301);\n+                assertEquals(res2.headers().firstValue(\"content-length\").get(), \"0\");\n+                assertEquals(res2.headers().firstValue(\"location\").get(), \"\/aDirectory\/?query\");\n+            }\n+\n+            {   \/\/ tests that redirect to returned relative URI works\n+                var client = HttpClient.newBuilder().proxy(NO_PROXY)\n+                        .followRedirects(HttpClient.Redirect.ALWAYS).build();\n+                var uri = uri(server, \"aDirectory\");\n+                var request = HttpRequest.newBuilder(uri).build();\n+                var response = client.send(request, BodyHandlers.ofString());\n+                assertEquals(response.statusCode(), 200);\n+                assertEquals(response.body(), expectedBody);\n+                assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+                assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            }\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @Test\n+    public void testNull() {\n+        final var addr = InetSocketAddress.createUnresolved(\"foo\", 8080);\n+        final var path = Path.of(\"\/tmp\");\n+        final var levl = OutputLevel.INFO;\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(null, null, null));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(null, null, levl));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(null, path, null));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(null, path, levl));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(addr, null, null));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(addr, null, levl));\n+        assertThrows(NPE, () -> SimpleFileServer.createFileServer(addr, path, null));\n+\n+        assertThrows(NPE, () -> SimpleFileServer.createFileHandler(null));\n+\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(null, null));\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(null, levl));\n+        assertThrows(NPE, () -> SimpleFileServer.createOutputFilter(System.out, null));\n+    }\n+\n+    @Test\n+    public void testInitialSlashContext() {\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, TEST_DIR, OutputLevel.INFO);\n+        server.removeContext(\"\/\"); \/\/ throws if no context\n+        server.stop(0);\n+    }\n+\n+    @Test\n+    public void testBound() {\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, TEST_DIR, OutputLevel.INFO);\n+        var boundAddr = server.getAddress();\n+        server.stop(0);\n+        assertTrue(boundAddr.getAddress() != null);\n+        assertTrue(boundAddr.getPort() > 0);\n+    }\n+\n+    @Test\n+    public void testIllegalPath() throws Exception {\n+        var addr = LOOPBACK_ADDR;\n+        {   \/\/ not absolute\n+            Path p = Path.of(\".\");\n+            assert Files.isDirectory(p);\n+            assert Files.exists(p);\n+            assert !p.isAbsolute();\n+            var iae = expectThrows(IAE, () -> SimpleFileServer.createFileServer(addr, p, OutputLevel.INFO));\n+            assertTrue(iae.getMessage().contains(\"is not absolute\"));\n+        }\n+        {   \/\/ not a directory\n+            Path p = Files.createFile(TEST_DIR.resolve(\"aFile\"));\n+            assert !Files.isDirectory(p);\n+            var iae = expectThrows(IAE, () -> SimpleFileServer.createFileServer(addr, p, OutputLevel.INFO));\n+            assertTrue(iae.getMessage().contains(\"not a directory\"));\n+        }\n+        {   \/\/ does not exist\n+            Path p = TEST_DIR.resolve(\"doesNotExist\");\n+            assert !Files.exists(p);\n+            var iae = expectThrows(IAE, () -> SimpleFileServer.createFileServer(addr, p, OutputLevel.INFO));\n+            assertTrue(iae.getMessage().contains(\"does not exist\"));\n+        }\n+        {   \/\/ not readable\n+            if (!Platform.isWindows()) {  \/\/ not applicable on Windows\n+                Path p = Files.createDirectory(TEST_DIR.resolve(\"aDir\"));\n+                p.toFile().setReadable(false, false);\n+                assert !Files.isReadable(p);\n+                try {\n+                    var iae = expectThrows(IAE, () -> SimpleFileServer.createFileServer(addr, p, OutputLevel.INFO));\n+                    assertTrue(iae.getMessage().contains(\"not readable\"));\n+                } finally {\n+                    p.toFile().setReadable(true, false);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testUncheckedIOException() {\n+        var addr = InetSocketAddress.createUnresolved(\"foo\", 8080);\n+        assertThrows(UIOE, () -> SimpleFileServer.createFileServer(addr, TEST_DIR, OutputLevel.INFO));\n+        assertThrows(UIOE, () -> SimpleFileServer.createFileServer(addr, TEST_DIR, OutputLevel.VERBOSE));\n+    }\n+\n+    @Test\n+    public void testXss() throws Exception {\n+        var root = Files.createDirectory(TEST_DIR.resolve(\"testXss\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"beginDelim%3C%3EEndDelim\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertTrue(response.body().contains(\"beginDelim%3C%3EEndDelim\"));\n+            assertTrue(response.body().contains(\"File not found\"));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    static final String openHTML = \"\"\"\n+                <!DOCTYPE html>\n+                <html>\n+                <head>\n+                <meta charset=\"utf-8\"\/>\n+                <\/head>\n+                <body>\n+                \"\"\";\n+\n+    static final String closeHTML = \"\"\"\n+                <\/body>\n+                <\/html>\n+                \"\"\";\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    static URI uri(HttpServer server, String path, String query) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .query(query)\n+                .buildUnchecked();\n+    }\n+\n+    static String getLastModified(Path path) throws IOException {\n+        return Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerTest.java","additions":703,"deletions":0,"binary":false,"changes":703,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test to stress directory listings\n+ * @library \/test\/lib\n+ * @run testng\/othervm StressDirListings\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.file.Path;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.assertEquals;\n+\n+public class StressDirListings {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = false;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    HttpServer simpleFileServer;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        simpleFileServer = SimpleFileServer.createFileServer(LOOPBACK_ADDR, CWD, OutputLevel.VERBOSE);\n+        simpleFileServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        simpleFileServer.stop(0);\n+    }\n+\n+    \/\/ Enough to trigger FileSystemException: Too many open files (machine dependent)\n+    static final int TIMES = 11_000;\n+\n+    \/**\n+     * Issues a large number of identical GET requests sequentially, each of\n+     * which returns the root directory listing. An IOException will be thrown\n+     * if the server does not issue a valid reply, e.g. the server logic that\n+     * enumerates the directory files fails to close the stream from Files::list.\n+     *\/\n+    @Test\n+    public void testDirListings() throws Exception {\n+        var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+        var request = HttpRequest.newBuilder(uri(simpleFileServer)).build();\n+        for (int i=0; i<TIMES; i++) {\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            if (i % 100 == 0) {\n+                out.print(\" \" + i + \" \");\n+            }\n+        }\n+    }\n+\n+    static URI uri(HttpServer server) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\")\n+                .buildUnchecked();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/StressDirListings.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests for SimpleFileServer with a root that is of a zip file system\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm ZipFileSystemTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Map;\n+import java.util.logging.ConsoleHandler;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+import com.sun.net.httpserver.SimpleFileServer.OutputLevel;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.StandardOpenOption.CREATE;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class ZipFileSystemTest {\n+\n+    static final Path CWD = Path.of(\".\").toAbsolutePath();\n+    static final Path TEST_DIR = CWD.resolve(\"ZipFileSystemTest\");\n+\n+    static final InetSocketAddress LOOPBACK_ADDR = new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+\n+    static final boolean ENABLE_LOGGING = true;\n+    static final Logger LOGGER = Logger.getLogger(\"com.sun.net.httpserver\");\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        if (ENABLE_LOGGING) {\n+            ConsoleHandler ch = new ConsoleHandler();\n+            LOGGER.setLevel(Level.ALL);\n+            ch.setLevel(Level.ALL);\n+            LOGGER.addHandler(ch);\n+        }\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+        Files.createDirectories(TEST_DIR);\n+    }\n+\n+    @Test\n+    public void testFileGET() throws Exception {\n+        var root = createZipFs(TEST_DIR.resolve(\"testFileGET.zip\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"some text\");\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testFileGET.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createZipFs(TEST_DIR.resolve(\"testDirectoryGET.zip\"));\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testDirectoryGET.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testFileHEAD() throws Exception {\n+        var root = createZipFs(TEST_DIR.resolve(\"testFileHEAD.zip\"));\n+        var file = Files.writeString(root.resolve(\"aFile.txt\"), \"some text\", CREATE);\n+        var lastModified = getLastModified(file);\n+        var expectedLength = Long.toString(Files.size(file));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile.txt\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/plain\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testFileHEAD.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testDirectoryHEAD() throws Exception {\n+        var expectedLength = Integer.toString(\n+                (openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML).getBytes(UTF_8).length);\n+        var root = createZipFs(TEST_DIR.resolve(\"testDirectoryHEAD.zip\"));\n+        var lastModified = getLastModified(root);\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), \"text\/html; charset=UTF-8\");\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testDirectoryHEAD.zip\"));\n+        }\n+    }\n+\n+    @DataProvider\n+    public Object[][] indexFiles() {\n+        var fileContent = openHTML + \"\"\"\n+                <h1>This is an index file<\/h1>\n+                \"\"\" + closeHTML;\n+        var dirListing = openHTML + \"\"\"\n+                <h1>Directory listing for &#x2F;<\/h1>\n+                <ul>\n+                <\/ul>\n+                \"\"\" + closeHTML;\n+        return new Object[][] {\n+                {\"1\", \"index.html\", \"text\/html\",                \"116\", fileContent, true},\n+                {\"2\", \"index.htm\",  \"text\/html\",                \"116\", fileContent, true},\n+                {\"3\", \"index.txt\",  \"text\/html; charset=UTF-8\", \"134\", dirListing,  false}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"indexFiles\")\n+    public void testDirectoryWithIndexGET(String id,\n+                                          String filename,\n+                                          String contentType,\n+                                          String contentLength,\n+                                          String expectedBody,\n+                                          boolean serveIndexFile) throws Exception {\n+        var root = createZipFs(TEST_DIR.resolve(\"testDirectoryWithIndexGET\"+id+\".zip\"));\n+        var lastModified = getLastModified(root);\n+        if (serveIndexFile) {\n+            var file = Files.writeString(root.resolve(filename), expectedBody, CREATE);\n+            lastModified = getLastModified(file);\n+        }\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.headers().firstValue(\"content-type\").get(), contentType);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), contentLength);\n+            assertEquals(response.headers().firstValue(\"last-modified\").get(), lastModified);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            if (serveIndexFile) {\n+                Files.delete(root.resolve(filename));\n+            }\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testDirectoryWithIndexGET\"+id+\".zip\"));\n+        }\n+    }\n+\n+    \/\/ no testNotReadableGET() - Zip file system does not enforce access permissions\n+    \/\/ no testSymlinkGET() - Zip file system does not support symlink creation\n+    \/\/ no testHiddenFileGET() - Zip file system does not support hidden files\n+\n+    @Test\n+    public void testInvalidRequestURIGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;aFile?#.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createZipFs(TEST_DIR.resolve(\"testInvalidRequestURIGET.zip\"));\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"aFile?#.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testInvalidRequestURIGET.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundGET() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\" + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createZipFs(TEST_DIR.resolve(\"testNotFoundGET.zip\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), expectedBody);\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testNotFoundGET.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testNotFoundHEAD() throws Exception {\n+        var expectedBody = openHTML + \"\"\"\n+                <h1>File not found<\/h1>\n+                <p>&#x2F;doesNotExist.txt<\/p>\n+                \"\"\"\n+                + closeHTML;\n+        var expectedLength = Integer.toString(expectedBody.getBytes(UTF_8).length);\n+        var root = createZipFs(TEST_DIR.resolve(\"testNotFoundHEAD.zip\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"doesNotExist.txt\"))\n+                    .method(\"HEAD\", BodyPublishers.noBody()).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), expectedLength);\n+            assertEquals(response.body(), \"\");\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testNotFoundHEAD.zip\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testMovedPermanently() throws Exception {\n+        var root = createZipFs(TEST_DIR.resolve(\"testMovedPermanently.zip\"));\n+        Files.createDirectory(root.resolve(\"aDirectory\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var uri = uri(server, \"aDirectory\");\n+            var request = HttpRequest.newBuilder(uri).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 301);\n+            assertEquals(response.headers().firstValue(\"content-length\").get(), \"0\");\n+            assertEquals(response.headers().firstValue(\"location\").get(), \"\/aDirectory\/\");\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testMovedPermanently.zip\"));\n+        }\n+    }\n+\n+    static Path createZipFs(Path zipFile) throws Exception {\n+        var p = zipFile.toAbsolutePath().normalize();\n+        var fs = FileSystems.newFileSystem(p, Map.of(\"create\", \"true\"));\n+        assert fs != FileSystems.getDefault();\n+        return fs.getPath(\"\/\");  \/\/ root entry\n+    }\n+\n+    @Test\n+    public void testXss() throws Exception {\n+        var root = createZipFs(TEST_DIR.resolve(\"testXss.zip\"));\n+\n+        var server = SimpleFileServer.createFileServer(LOOPBACK_ADDR, root, OutputLevel.VERBOSE);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"beginDelim%3C%3EEndDelim\")).build();\n+            var response = client.send(request, BodyHandlers.ofString());\n+            assertEquals(response.statusCode(), 404);\n+            assertTrue(response.body().contains(\"beginDelim%3C%3EEndDelim\"));\n+            assertTrue(response.body().contains(\"File not found\"));\n+        } finally {\n+            server.stop(0);\n+            root.getFileSystem().close();\n+            Files.deleteIfExists(TEST_DIR.resolve(\"testXss.zip\"));\n+        }\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws IOException {\n+        if (Files.exists(TEST_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        }\n+    }\n+\n+    static final String openHTML = \"\"\"\n+                <!DOCTYPE html>\n+                <html>\n+                <head>\n+                <meta charset=\"utf-8\"\/>\n+                <\/head>\n+                <body>\n+                \"\"\";\n+\n+    static final String closeHTML = \"\"\"\n+                <\/body>\n+                <\/html>\n+                \"\"\";\n+\n+    static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    static String getLastModified(Path path) throws IOException {\n+        return Files.getLastModifiedTime(path).toInstant().atZone(ZoneId.of(\"GMT\"))\n+                .format(DateTimeFormatter.RFC_1123_DATE_TIME);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/ZipFileSystemTest.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"}]}