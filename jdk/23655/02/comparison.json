{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,13 @@\n+ * <h2 id=\"deflater-usage\">Deflater Usage<\/h2>\n+ * <p>This class uses a {@link Deflater} for compressing the data. Two forms of constructors\n+ * are available for constructing a {@code DeflaterInputStream} - one which accepts\n+ * a {@code Deflater} and one which doesn't. The constructors that don't accept a {@code Deflater}\n+ * will create and use a {@code Deflater} instance of their own. The {@code Deflater} instance\n+ * created in those cases will be {@linkplain Deflater#close() closed} when the\n+ * {@code DeflaterInputStream} instance itself is {@linkplain #close() closed}.\n+ * On the other hand, if a {@code DeflaterInputStream} was\n+ * constructed by passing it a {@code Deflater}, then closing the {@code DeflaterInputStream}\n+ * will not close the passed {@code Deflater}. In those cases, it is the responsibility of\n+ * the caller to close the {@code Deflater} as and when appropriate, after the\n+ * {@code DeflaterInputStream} has been closed.\n+ *\n@@ -86,0 +99,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterInputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code defl}.\n+     *\n@@ -98,0 +114,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterInputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code defl}.\n+     *\n@@ -124,0 +143,4 @@\n+     * @apiNote If this {@code DeflaterInputStream} was constructed by passing\n+     * a {@code Deflater}, then this method {@linkplain ##deflater-usage does not close}\n+     * that {@code Deflater}.\n+     *\n@@ -126,0 +149,1 @@\n+    @Override\n@@ -150,0 +174,1 @@\n+    @Override\n@@ -172,0 +197,1 @@\n+    @Override\n@@ -227,0 +253,1 @@\n+    @Override\n@@ -262,0 +289,1 @@\n+    @Override\n@@ -276,0 +304,1 @@\n+    @Override\n@@ -285,0 +314,1 @@\n+    @Override\n@@ -294,0 +324,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterInputStream.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,13 @@\n+ * <h2 id=\"deflater-usage\">Deflater Usage<\/h2>\n+ * <p>This class uses a {@link Deflater} for compressing the data. Two forms of constructors\n+ * are available for constructing a {@code DeflaterOutputStream} - one which accepts\n+ * a {@code Deflater} and one which doesn't. The constructors that don't accept a {@code Deflater}\n+ * will create and use a {@code Deflater} instance of their own. The {@code Deflater} instance\n+ * created in those cases will be {@linkplain Deflater#close() closed} when the\n+ * {@code DeflaterOutputStream} instance itself is {@linkplain #close() closed}.\n+ * On the other hand, if a {@code DeflaterOutputStream} was\n+ * constructed by passing it a {@code Deflater}, then closing the {@code DeflaterOutputStream}\n+ * will not close the passed {@code Deflater}. In those cases, it is the responsibility of\n+ * the caller to close the {@code Deflater} as and when appropriate, after the\n+ * {@code DeflaterOutputStream} has been closed.\n+ *\n@@ -67,0 +80,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterOutputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code def}.\n+     *\n@@ -101,1 +117,4 @@\n-     * the 4-argument constructor DeflaterOutputStream(out, def, size, false).\n+     * the 4-argument constructor {@code DeflaterOutputStream(out, def, size, false)}.\n+     *\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterOutputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code def}.\n@@ -116,0 +135,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterOutputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code def}.\n+     *\n@@ -138,1 +160,4 @@\n-     * the 3-argument constructor DeflaterOutputStream(out, def, false).\n+     * the 3-argument constructor {@code DeflaterOutputStream(out, def, false)}.\n+     *\n+     * @apiNote {@linkplain #close() Closing} the {@code DeflaterOutputStream}\n+     * {@linkplain ##deflater-usage will not close} the given {@code def}.\n@@ -172,1 +197,1 @@\n-     * the 2-argument constructor DeflaterOutputStream(out, false).\n+     * the 2-argument constructor {@code DeflaterOutputStream(out, false)}.\n@@ -187,0 +212,1 @@\n+    @Override\n@@ -201,0 +227,1 @@\n+    @Override\n@@ -242,0 +269,5 @@\n+     *\n+     * @apiNote If this {@code DeflaterOutputStream} was constructed by passing\n+     * a {@code Deflater}, then this method {@linkplain ##deflater-usage does not close}\n+     * that {@code Deflater}.\n+     *\n@@ -244,0 +276,1 @@\n+    @Override\n@@ -299,0 +332,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,15 @@\n+ *\n+ * <h2 id=\"inflater-usage\">Inflater Usage<\/h2>\n+ * <p>This class uses an {@link Inflater} for uncompressing the data. Two forms of constructors\n+ * are available for constructing an {@code InflaterInputStream} - one which accepts\n+ * an {@code Inflater} and one which doesn't. The constructors that don't accept an\n+ * {@code Inflater} will create and use an {@code Inflater} instance of their own.\n+ * The {@code Inflater} instance created in those cases will be\n+ * {@linkplain Inflater#close() closed} when the {@code InflaterInputStream} instance itself\n+ * is {@linkplain #close() closed}.\n+ * On the other hand, if an {@code InflaterInputStream} was\n+ * constructed by passing it an {@code Inflater}, then closing the {@code InflaterInputStream}\n+ * will not close the passed {@code Inflater}. In those cases, it is the responsibility of\n+ * the caller to close the {@code Inflater} as and when appropriate, after the\n+ * {@code InflaterInputStream} has been closed.\n+ *\n@@ -78,0 +93,4 @@\n+     *\n+     * @apiNote {@linkplain #close() Closing} the {@code InflaterInputStream}\n+     * {@linkplain ##inflater-usage will not close} the given {@code inf}.\n+     *\n@@ -97,0 +116,4 @@\n+     *\n+     * @apiNote {@linkplain #close() Closing} the {@code InflaterInputStream}\n+     * {@linkplain ##inflater-usage will not close} the given {@code inf}.\n+     *\n@@ -123,0 +146,1 @@\n+    @Override\n@@ -154,0 +178,1 @@\n+    @Override\n@@ -196,0 +221,1 @@\n+    @Override\n@@ -223,0 +249,1 @@\n+    @Override\n@@ -249,0 +276,5 @@\n+     *\n+     * @apiNote If this {@code InflaterInputStream} was constructed by passing\n+     * an {@code Inflater}, then this method {@linkplain ##inflater-usage does not close}\n+     * that {@code Inflater}.\n+     *\n@@ -251,0 +283,1 @@\n+    @Override\n@@ -290,0 +323,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/InflaterInputStream.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,14 @@\n+ * <h2 id=\"inflater-usage\">Inflater Usage<\/h2>\n+ * <p>This class uses an {@link Inflater} for uncompressing the data. Two forms of constructors\n+ * are available for constructing an {@code InflaterOutputStream} - one which accepts\n+ * an {@code Inflater} and one which doesn't. The constructors that don't accept an\n+ * {@code Inflater} will create and use an {@code Inflater} instance of their own.\n+ * The {@code Inflater} instance created in those cases will be\n+ * {@linkplain Inflater#close() closed} when the {@code InflaterOutputStream} instance itself\n+ * is {@linkplain #close() closed}.\n+ * On the other hand, if an {@code InflaterOutputStream} was\n+ * constructed by passing it an {@code Inflater}, then closing the {@code InflaterOutputStream}\n+ * will not close the passed {@code Inflater}. In those cases, it is the responsibility of\n+ * the caller to close the {@code Inflater} as and when appropriate, after the\n+ * {@code InflaterOutputStream} has been closed.\n+ *\n@@ -86,0 +100,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code InflaterOutputStream}\n+     * {@linkplain ##inflater-usage will not close} the given {@code infl}.\n+     *\n@@ -98,0 +115,3 @@\n+     * @apiNote {@linkplain #close() Closing} the {@code InflaterOutputStream}\n+     * {@linkplain ##inflater-usage will not close} the given {@code infl}.\n+     *\n@@ -124,0 +144,4 @@\n+     * @apiNote If this {@code InflaterOutputStream} was constructed by passing\n+     * an {@code Inflater}, then this method {@linkplain ##inflater-usage does not close}\n+     * that {@code Inflater}.\n+     *\n@@ -126,0 +150,1 @@\n+    @Override\n@@ -145,0 +170,1 @@\n+    @Override\n@@ -202,0 +228,1 @@\n+    @Override\n@@ -222,0 +249,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/InflaterOutputStream.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -273,0 +274,77 @@\n+    \/**\n+     * Verifies that when a DeflaterInputStream is constructed\n+     * by passing a Deflater instance, then closing the DeflaterInputStream\n+     * will not close the passed Deflater instance.\n+     *\/\n+    private static void deflaterInputStreamDeflaterNotClosed() throws Throwable {\n+        \/\/ some arbitrary content\n+        final byte[] original = \"foo\".repeat(1024).getBytes(StandardCharsets.US_ASCII);\n+        \/\/ run the DeflaterInputStream tests\n+        try (final Deflater def = new Deflater()) {\n+            try (ByteArrayInputStream bis = new ByteArrayInputStream(original);\n+                 DeflaterInputStream iis = new DeflaterInputStream(bis, def)) {\n+                iis.readAllBytes();\n+            }\n+            \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the deflater is closed\n+            def.reset();\n+\n+            \/\/ repeat the test with the other constructor\n+            try (ByteArrayInputStream bis = new ByteArrayInputStream(original);\n+                 DeflaterInputStream iis = new DeflaterInputStream(bis, def, 1024)) {\n+                iis.readAllBytes();\n+            }\n+            \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the deflater is closed\n+            def.reset();\n+        }\n+    }\n+\n+    private static byte[] deflate(final byte[] original) {\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        try (Deflater compressor = new Deflater()) {\n+            compressor.setInput(original);\n+            compressor.finish();\n+            while (!compressor.finished()) {\n+                byte[] tmpBuffer = new byte[1024];\n+                int numCompressed = compressor.deflate(tmpBuffer);\n+                compressedBaos.write(tmpBuffer, 0, numCompressed);\n+            }\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    \/**\n+     * Verifies that when a InflaterOutputStream is constructed\n+     * by passing a Inflater instance, then closing the InflaterOutputStream\n+     * will not close the passed Inflater instance.\n+     *\/\n+    private static void inflaterOutputStreamInflaterNotClosed() throws Throwable {\n+        \/\/ some arbitrary content\n+        final byte[] original = \"bar\".repeat(1024).getBytes(StandardCharsets.US_ASCII);\n+        \/\/ deflate it\n+        final byte[] deflated = deflate(original);\n+        try (final Inflater infl = new Inflater()) {\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                 InflaterOutputStream dos = new InflaterOutputStream(bos, infl)) {\n+                dos.write(deflated);\n+                dos.flush();\n+                check(Arrays.equals(original, bos.toByteArray()));\n+            }\n+            \/\/ verify the inflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the inflater is closed\n+            infl.reset();\n+\n+            \/\/ repeat the test with the other constructor\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                 InflaterOutputStream dos = new InflaterOutputStream(bos, infl, 1024)) {\n+                dos.write(deflated);\n+                dos.flush();\n+                check(Arrays.equals(original, bos.toByteArray()));\n+            }\n+            \/\/ verify the inflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the inflater is closed\n+            infl.reset();\n+        }\n+    }\n+\n@@ -287,0 +365,4 @@\n+\n+        deflaterInputStreamDeflaterNotClosed();\n+\n+        inflaterOutputStreamInflaterNotClosed();\n","filename":"test\/jdk\/java\/util\/zip\/DeflateIn_InflateOut.java","additions":83,"deletions":1,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +34,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -296,0 +298,100 @@\n+    private static byte[] deflate(final byte[] original) {\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        try (Deflater compressor = new Deflater()) {\n+            compressor.setInput(original);\n+            compressor.finish();\n+            while (!compressor.finished()) {\n+                byte[] tmpBuffer = new byte[1024];\n+                int numCompressed = compressor.deflate(tmpBuffer);\n+                compressedBaos.write(tmpBuffer, 0, numCompressed);\n+            }\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    \/**\n+     * Verifies that when a InflaterInputStream is constructed\n+     * by passing a Inflater instance, then closing the InflaterInputStream\n+     * will not close the passed Inflater instance.\n+     *\/\n+    private static void inflaterInputStreamInflaterNotClosed() throws Throwable {\n+        \/\/ some arbitrary content\n+        final byte[] original = \"foo\".repeat(1024).getBytes(StandardCharsets.US_ASCII);\n+        \/\/ deflate it\n+        final byte[] deflated = deflate(original);\n+        \/\/ run the InflaterInputStream tests\n+        try (final Inflater infl = new Inflater()) {\n+            try (ByteArrayInputStream bis = new ByteArrayInputStream(deflated);\n+                 InflaterInputStream iis = new InflaterInputStream(bis, infl)) {\n+                final byte[] inflated = iis.readAllBytes();\n+                check(Arrays.equals(original, inflated));\n+            }\n+            \/\/ verify the inflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the inflater is closed\n+            infl.reset();\n+\n+            \/\/ repeat the test with the other constructor\n+            try (ByteArrayInputStream bis = new ByteArrayInputStream(deflated);\n+                 InflaterInputStream iis = new InflaterInputStream(bis, infl, 1024)) {\n+                final byte[] inflated = iis.readAllBytes();\n+                check(Arrays.equals(original, inflated));\n+            }\n+            \/\/ verify the inflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the inflater is closed\n+            infl.reset();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a DeflaterOutputStream is constructed\n+     * by passing a Deflater instance, then closing the DeflaterOutputStream\n+     * will not close the passed Deflater instance.\n+     *\/\n+    private static void deflaterOutputStreamDeflaterNotClosed() throws Throwable {\n+        \/\/ some arbitrary content\n+        final byte[] data = \"bar\".repeat(1024).getBytes(StandardCharsets.US_ASCII);\n+        \/\/ run the InflaterInputStream tests\n+        try (final Deflater def = new Deflater()) {\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                 DeflaterOutputStream dos = new DeflaterOutputStream(bos, def)) {\n+                dos.write(data);\n+            }\n+            \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the deflater is closed\n+            def.reset();\n+\n+            \/\/ repeat the test with the other constructor\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                 DeflaterOutputStream dos = new DeflaterOutputStream(bos, def, 1024)) {\n+                dos.write(data);\n+            }\n+            \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+            \/\/ the deflater is closed\n+            def.reset();\n+\n+            \/\/ repeat the test with the other constructor\n+            for (boolean syncFlush : new boolean[] {false, true}) {\n+                System.out.println(\"testing with syncFlush = \" + syncFlush);\n+                try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                     DeflaterOutputStream dos = new DeflaterOutputStream(bos, def, syncFlush)) {\n+                    dos.write(data);\n+                }\n+                \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+                \/\/ the deflater is closed\n+                def.reset();\n+            }\n+\n+            \/\/ repeat the test with the other constructor\n+            for (boolean syncFlush : new boolean[] {false, true}) {\n+                System.out.println(\"testing with syncFlush = \" + syncFlush);\n+                try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                     DeflaterOutputStream dos = new DeflaterOutputStream(bos, def, 1024, syncFlush)) {\n+                    dos.write(data);\n+                }\n+                \/\/ verify the deflater wasn't closed - reset() will throw IllegalStateException if\n+                \/\/ the deflater is closed\n+                def.reset();\n+            }\n+        }\n+    }\n+\n@@ -303,0 +405,2 @@\n+        inflaterInputStreamInflaterNotClosed();\n+        deflaterOutputStreamDeflaterNotClosed();\n","filename":"test\/jdk\/java\/util\/zip\/InflateIn_DeflateOut.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"}]}