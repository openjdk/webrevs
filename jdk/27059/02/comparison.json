{"files":[{"patch":"@@ -2571,4 +2571,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,7 +386,0 @@\n-\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on aarch64\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -231,2 +231,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -489,2 +488,1 @@\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n+      if (sender_nm->is_deopt_entry(_pc)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1157,4 +1157,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REGP_mask();\n-}\n-\n@@ -1251,17 +1247,0 @@\n-  enc_class preserve_SP %{\n-    \/\/ preserve mark\n-    address mark = __ inst_mark();\n-    DEBUG_ONLY(int off0 = __ offset());\n-    \/\/ FP is preserved across all calls, even compiled calls.\n-    \/\/ Use it to preserve SP in places where the callee might change the SP.\n-    __ mov(Rmh_SP_save, SP);\n-    DEBUG_ONLY(int off1 = __ offset());\n-    assert(off1 - off0 == 4, \"correct size prediction\");\n-    \/\/ restore mark\n-    __ set_inst_mark(mark);\n-  %}\n-\n-  enc_class restore_SP %{\n-    __ mov(SP, Rmh_SP_save);\n-  %}\n-\n@@ -8813,1 +8792,0 @@\n-  predicate(! ((CallStaticJavaNode*)n)->is_method_handle_invoke());\n@@ -8822,14 +8800,0 @@\n-\/\/ Call Java Static Instruction (method handle version)\n-instruct CallStaticJavaHandle( method meth ) %{\n-  match(CallStaticJava);\n-  predicate(((CallStaticJavaNode*)n)->is_method_handle_invoke());\n-  effect(USE meth);\n-  \/\/ FP is saved by all callees (for interpreter stack correction).\n-  \/\/ We use it here for a similar purpose, in {preserve,restore}_FP.\n-\n-  ins_cost(CALL_COST);\n-  format %{ \"CALL,static\/MethodHandle ==> \" %}\n-  ins_encode( SetInstMark, preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog, ClearInstMark );\n-  ins_pipe(simple_call);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -435,2 +435,1 @@\n-  return ((far ? 3 : 1) + (_method_handle_invoke ? 1 : 0)) *\n-    NativeInstruction::instruction_size;\n+  return (far ? 3 : 1) * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,5 +177,0 @@\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  assert(Rmh_SP_save == FP, \"Fix register used for saving SP for MethodHandle calls\");\n-  return FP_opr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_FrameMap_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,8 +278,0 @@\n-static void restore_sp_for_method_handle(StubAssembler* sasm) {\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr_s32(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-}\n-\n-\n@@ -342,1 +334,0 @@\n-    restore_sp_for_method_handle(sasm);\n@@ -375,3 +366,0 @@\n-  \/\/ JSR292 extension\n-  restore_sp_for_method_handle(sasm);\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -336,2 +336,1 @@\n-\/\/ given unextended SP.  The unextended SP might also be the saved SP\n-\/\/ for MethodHandle call sites.\n+\/\/ given unextended SP.\n@@ -339,1 +338,1 @@\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {\n+void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n@@ -350,1 +349,0 @@\n-  assert(nm->is_method_handle_return(original_pc) == is_method_handle_return, \"must be\");\n@@ -357,6 +355,3 @@\n-  \/\/ same as on x86\n-\n-  \/\/ If we are returning to a compiled MethodHandle call site, the\n-  \/\/ saved_fp will in fact be a saved value of the unextended SP.  The\n-  \/\/ simplest way to tell whether we are returning to such a call site\n-  \/\/ is as follows:\n+  \/\/ On arm, sites calling method handle intrinsics and lambda forms are treated\n+  \/\/ as any other call site. Therefore, no special action is needed when we are\n+  \/\/ returning to any of these call sites.\n@@ -366,8 +361,2 @@\n-    \/\/ If the sender PC is a deoptimization point, get the original\n-    \/\/ PC.  For MethodHandle call site the unextended_sp is stored in\n-    \/\/ saved_fp.\n-    if (sender_nm->is_deopt_mh_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_mh_original_pc(sender_nm, _fp));\n-      _unextended_sp = _fp;\n-    }\n-    else if (sender_nm->is_deopt_entry(_pc)) {\n+    \/\/ If the sender PC is a deoptimization point, get the original PC.\n+    if (sender_nm->is_deopt_entry(_pc)) {\n@@ -376,3 +365,0 @@\n-    else if (sender_nm->is_method_handle_return(_pc)) {\n-      _unextended_sp = _fp;\n-    }\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -96,4 +96,1 @@\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return = false);\n-  static void verify_deopt_mh_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-    verify_deopt_original_pc(nm, unextended_sp, true);\n-  }\n+  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-#define Rmh_SP_save      FP \/\/ for C1\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -267,5 +267,0 @@\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,9 +377,0 @@\n-\n-\/\/ JSR 292\n-\/\/ On PPC64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_FrameMap_ppc.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2476,4 +2476,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n@@ -3437,1 +3433,0 @@\n-    call->_method_handle_invoke = _method_handle_invoke;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -380,5 +380,0 @@\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on riscv\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_FrameMap_riscv.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,2 +220,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -463,2 +462,1 @@\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n+      if (sender_nm->is_deopt_entry(_pc)) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2135,4 +2135,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,7 +285,0 @@\n-\/\/ JSR 292\n-\/\/ On ZARCH_64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1982,5 +1982,0 @@\n-\/\/ Copied from sparc.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -329,7 +329,0 @@\n-\/\/ JSR 292\n-\/\/ On x86, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -222,2 +222,1 @@\n-        if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-            nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -478,2 +477,1 @@\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n+      if (sender_nm->is_deopt_entry(_pc)) {\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1700,5 +1700,0 @@\n-\/\/ Register for saving SP into on method handle invokes. Not used on x86_64.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-    return NO_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -624,3 +624,1 @@\n-        address deopt = nm->is_method_handle_return(pc) ?\n-          nm->deopt_mh_handler_begin() :\n-          nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2814,3 +2814,1 @@\n-          address deopt = nm->is_method_handle_return(pc) ?\n-            nm->deopt_mh_handler_begin() :\n-            nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-                 DeoptMH,        \/\/ Offset where MethodHandle deopt handler lives\n@@ -80,1 +79,0 @@\n-    _values[DeoptMH       ] = -1;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,8 +313,0 @@\n-  \/\/ Emit the MethodHandle deopt handler code (if required).\n-  if (has_method_handle_invokes()) {\n-    \/\/ We can use the same code as for the normal deopt handler, we\n-    \/\/ just need a different entry point address.\n-    code_offsets->set_value(CodeOffsets::DeoptMH, assembler->emit_deopt_handler());\n-    CHECK_BAILOUT();\n-  }\n-\n@@ -577,1 +569,0 @@\n-, _has_method_handle_invokes(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool               _has_method_handle_invokes;  \/\/ True if this method has MethodHandle invokes.\n@@ -183,4 +182,0 @@\n-  \/\/ JSR 292\n-  bool     has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,3 +158,0 @@\n-  \/\/ JSR 292\n-  static LIR_Opr method_handle_invoke_SP_save_opr();\n-\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-  , _is_method_handle_invoke(false)\n@@ -206,1 +205,0 @@\n-  , _is_method_handle_invoke(info->_is_method_handle_invoke)\n@@ -221,1 +219,1 @@\n-  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke);\n+  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false) {\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute) {\n@@ -251,1 +251,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop,\n+                             reexecute, rethrow_exception, return_oop,\n@@ -265,1 +265,0 @@\n-  bool              _is_method_handle_invoke;    \/\/ true if the associated call site is a MethodHandle call site.\n@@ -291,3 +290,0 @@\n-  bool     is_method_handle_invoke() const { return _is_method_handle_invoke;     }\n-  void set_is_method_handle_invoke(bool x) {        _is_method_handle_invoke = x; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -712,5 +712,0 @@\n-      if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &&\n-          opJavaCall->is_method_handle_invoke()) {\n-        opJavaCall->_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();\n-        do_temp(opJavaCall->_method_handle_invoke_SP_save_opr);\n-      }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1184,1 +1184,0 @@\n-  LIR_Opr   _method_handle_invoke_SP_save_opr;  \/\/ Used in LIR_OpVisitState::visit to store the reference to FrameMap::method_handle_invoke_SP_save_opr.\n@@ -1194,1 +1193,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n@@ -1203,1 +1201,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -482,6 +482,0 @@\n-\n-  \/\/ JSR 292\n-  \/\/ Record if this method has MethodHandle invokes.\n-  if (op->is_method_handle_invoke()) {\n-    compilation()->set_has_method_handle_invokes(true);\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2715,2 +2715,0 @@\n-  \/\/ JSR 292\n-  \/\/ Preserve the SP over MethodHandle call sites, if needed.\n@@ -2718,10 +2716,0 @@\n-  bool is_method_handle_invoke = (\/\/ %%% FIXME: Are both of these relevant?\n-                                  target->is_method_handle_intrinsic() ||\n-                                  target->is_compiled_lambda_form());\n-  if (is_method_handle_invoke) {\n-    info->set_is_method_handle_invoke(true);\n-    if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-        __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());\n-    }\n-  }\n-\n@@ -2760,7 +2748,0 @@\n-  \/\/ JSR 292\n-  \/\/ Restore the SP after MethodHandle call sites, if needed.\n-  if (is_method_handle_invoke\n-      && FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-    __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -544,3 +544,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -625,2 +622,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -663,2 +658,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-                                              bool        is_method_handle_invoke,\n@@ -304,1 +303,0 @@\n-  last_pd->set_is_method_handle_invoke(is_method_handle_invoke);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-                      bool        is_method_handle_invoke = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -468,8 +468,0 @@\n-bool nmethod::is_method_handle_return(address return_pc) {\n-  if (!has_method_handle_invokes())  return false;\n-  PcDesc* pd = pc_desc_at(return_pc);\n-  if (pd == nullptr)\n-    return false;\n-  return pd->is_method_handle_invoke();\n-}\n-\n@@ -1240,1 +1232,0 @@\n-  _has_method_handle_invokes  = 0;\n@@ -1319,1 +1310,0 @@\n-    _deopt_mh_handler_offset = 0;\n@@ -1467,5 +1457,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1481,5 +1466,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -2702,9 +2682,0 @@\n-  \/\/ Search for MethodHandle invokes and tag the nmethod.\n-  for (int i = 0; i < count; i++) {\n-    if (pcs[i].is_method_handle_invoke()) {\n-      set_has_method_handle_invokes(true);\n-      break;\n-    }\n-  }\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n-\n@@ -3720,1 +3691,0 @@\n-  if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = \"[Deopt MH Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -230,3 +230,0 @@\n-  \/\/ All deoptee's at a MethodHandle call site will resume execution\n-  \/\/ at this location described by this offset.\n-  int _deopt_mh_handler_offset;\n@@ -271,1 +268,0 @@\n-          _has_method_handle_invokes:1,\/\/ Has this method MethodHandle invokes?\n@@ -610,1 +606,0 @@\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n@@ -749,3 +744,0 @@\n-  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n-  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n-\n@@ -822,2 +814,0 @@\n-  \/\/ MethodHandle\n-  bool is_method_handle_return(address return_pc);\n@@ -827,1 +817,0 @@\n-  inline bool is_deopt_mh_entry(address pc);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }\n+inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc); }\n@@ -40,4 +40,0 @@\n-inline bool nmethod::is_deopt_mh_entry(address pc) {\n-  return pc == deopt_mh_handler_begin();\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,5 +43,4 @@\n-    PCDESC_is_method_handle_invoke   = 1 << 1,\n-    PCDESC_return_oop                = 1 << 2,\n-    PCDESC_rethrow_exception         = 1 << 3,\n-    PCDESC_has_ea_local_in_scope     = 1 << 4,\n-    PCDESC_arg_escape                = 1 << 5\n+    PCDESC_return_oop                = 1 << 1,\n+    PCDESC_rethrow_exception         = 1 << 2,\n+    PCDESC_has_ea_local_in_scope     = 1 << 3,\n+    PCDESC_arg_escape                = 1 << 4\n@@ -88,3 +87,0 @@\n-  bool     is_method_handle_invoke()       const { return (_flags & PCDESC_is_method_handle_invoke) != 0;     }\n-  void set_is_method_handle_invoke(bool z)       { set_flag(PCDESC_is_method_handle_invoke, z); }\n-\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS) {\n@@ -1187,1 +1187,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, return_oop,\n@@ -1245,6 +1245,0 @@\n-      vmIntrinsics::ID iid = method->intrinsic_id();\n-      bool is_mh_invoke = false;\n-      if (direct_call) {\n-        is_mh_invoke = !method->is_static() && (iid == vmIntrinsics::_compiledLambdaForm ||\n-                (MethodHandles::is_signature_polymorphic(iid) && MethodHandles::is_signature_polymorphic_intrinsic(iid)));\n-      }\n@@ -1252,1 +1246,1 @@\n-      record_scope(next_pc_offset, stream, flags, true, is_mh_invoke, return_oop, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, return_oop, JVMCI_CHECK);\n@@ -1342,3 +1336,0 @@\n-    case DEOPT_MH_HANDLER_ENTRY:\n-      _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n-      break;\n@@ -1372,0 +1363,1 @@\n+    case DEOPT_MH_HANDLER_ENTRY:\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -414,1 +414,1 @@\n-  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n+  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS);\n@@ -417,1 +417,1 @@\n-    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* is_mh_invoke *\/, false \/* return_oop *\/, JVMCIENV);\n+    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* return_oop *\/, JVMCIENV);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -308,2 +305,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -346,3 +341,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,4 +172,0 @@\n-    if (method()->is_method_handle_intrinsic() ||\n-        method()->is_compiled_lambda_form()) {\n-      call->set_method_handle_invoke(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -767,1 +767,0 @@\n-  bool    _method_handle_invoke;\n@@ -775,1 +774,0 @@\n-      _method_handle_invoke(false),\n@@ -787,2 +785,0 @@\n-  void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }\n-  bool  is_method_handle_invoke() const    { return _method_handle_invoke; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -653,1 +653,0 @@\n-      _has_method_handle_invokes(false),\n@@ -926,1 +925,0 @@\n-      _has_method_handle_invokes(false),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,2 +357,0 @@\n-  \/\/ JSR 292\n-  bool                  _has_method_handle_invokes; \/\/ True if this method has MethodHandle invokes.\n@@ -663,4 +661,0 @@\n-  \/\/ JSR 292\n-  bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -948,11 +948,0 @@\n-\n-  \/\/ If the call is a MethodHandle invoke, we need to exclude the\n-  \/\/ register which is used to save the SP value over MH invokes from\n-  \/\/ the mask.  Otherwise this register could be used for\n-  \/\/ deoptimization information.\n-  if (op == Op_CallStaticJava) {\n-    MachCallStaticJavaNode* mcallstaticjava = (MachCallStaticJavaNode*) mcall;\n-    if (mcallstaticjava->_method_handle_invoke)\n-      proj->_rout.OR(Matcher::method_handle_invoke_SP_save_mask());\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -775,2 +775,0 @@\n-  if (_method_handle_invoke)\n-    st->print(\"MethodHandle \");\n@@ -797,4 +795,1 @@\n-  \/\/ If this call is a MethodHandle invoke we have to use a different\n-  \/\/ debugmask which does not include the register we use to save the\n-  \/\/ SP over MH invokes.\n-  RegMask** debugmask = _method_handle_invoke ? m->idealreg2mhdebugmask : m->idealreg2debugmask;\n+  RegMask** debugmask = m->idealreg2debugmask;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -960,1 +960,0 @@\n-  bool      _method_handle_invoke;   \/\/ Tells if the call has to preserve SP\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-RegMask Matcher::mh_caller_save_regmask;\n-RegMask Matcher::mh_caller_save_regmask_exclude_soe;\n@@ -116,15 +114,0 @@\n-  idealreg2mhdebugmask[Op_RegI] = nullptr;\n-  idealreg2mhdebugmask[Op_RegN] = nullptr;\n-  idealreg2mhdebugmask[Op_RegL] = nullptr;\n-  idealreg2mhdebugmask[Op_RegF] = nullptr;\n-  idealreg2mhdebugmask[Op_RegD] = nullptr;\n-  idealreg2mhdebugmask[Op_RegP] = nullptr;\n-  idealreg2mhdebugmask[Op_VecA] = nullptr;\n-  idealreg2mhdebugmask[Op_VecS] = nullptr;\n-  idealreg2mhdebugmask[Op_VecD] = nullptr;\n-  idealreg2mhdebugmask[Op_VecX] = nullptr;\n-  idealreg2mhdebugmask[Op_VecY] = nullptr;\n-  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n-  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n-  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n-\n@@ -481,1 +464,1 @@\n-#define NOF_STACK_MASKS (3*13)\n+#define NOF_STACK_MASKS (2*13)\n@@ -496,45 +479,6 @@\n-  idealreg2spillmask  [Op_RegN] = &rms[0];\n-  idealreg2spillmask  [Op_RegI] = &rms[1];\n-  idealreg2spillmask  [Op_RegL] = &rms[2];\n-  idealreg2spillmask  [Op_RegF] = &rms[3];\n-  idealreg2spillmask  [Op_RegD] = &rms[4];\n-  idealreg2spillmask  [Op_RegP] = &rms[5];\n-\n-  idealreg2debugmask  [Op_RegN] = &rms[6];\n-  idealreg2debugmask  [Op_RegI] = &rms[7];\n-  idealreg2debugmask  [Op_RegL] = &rms[8];\n-  idealreg2debugmask  [Op_RegF] = &rms[9];\n-  idealreg2debugmask  [Op_RegD] = &rms[10];\n-  idealreg2debugmask  [Op_RegP] = &rms[11];\n-\n-  idealreg2mhdebugmask[Op_RegN] = &rms[12];\n-  idealreg2mhdebugmask[Op_RegI] = &rms[13];\n-  idealreg2mhdebugmask[Op_RegL] = &rms[14];\n-  idealreg2mhdebugmask[Op_RegF] = &rms[15];\n-  idealreg2mhdebugmask[Op_RegD] = &rms[16];\n-  idealreg2mhdebugmask[Op_RegP] = &rms[17];\n-\n-  idealreg2spillmask  [Op_VecA] = &rms[18];\n-  idealreg2spillmask  [Op_VecS] = &rms[19];\n-  idealreg2spillmask  [Op_VecD] = &rms[20];\n-  idealreg2spillmask  [Op_VecX] = &rms[21];\n-  idealreg2spillmask  [Op_VecY] = &rms[22];\n-  idealreg2spillmask  [Op_VecZ] = &rms[23];\n-\n-  idealreg2debugmask  [Op_VecA] = &rms[24];\n-  idealreg2debugmask  [Op_VecS] = &rms[25];\n-  idealreg2debugmask  [Op_VecD] = &rms[26];\n-  idealreg2debugmask  [Op_VecX] = &rms[27];\n-  idealreg2debugmask  [Op_VecY] = &rms[28];\n-  idealreg2debugmask  [Op_VecZ] = &rms[29];\n-\n-  idealreg2mhdebugmask[Op_VecA] = &rms[30];\n-  idealreg2mhdebugmask[Op_VecS] = &rms[31];\n-  idealreg2mhdebugmask[Op_VecD] = &rms[32];\n-  idealreg2mhdebugmask[Op_VecX] = &rms[33];\n-  idealreg2mhdebugmask[Op_VecY] = &rms[34];\n-  idealreg2mhdebugmask[Op_VecZ] = &rms[35];\n-\n-  idealreg2spillmask  [Op_RegVectMask] = &rms[36];\n-  idealreg2debugmask  [Op_RegVectMask] = &rms[37];\n-  idealreg2mhdebugmask[Op_RegVectMask] = &rms[38];\n+  int index = 0;\n+  for (int i = Op_RegN; i <= Op_RegVectMask; ++i) {\n+    idealreg2spillmask[i] = &rms[index++];\n+    idealreg2debugmask[i] = &rms[index++];\n+  }\n+  assert(index == NOF_STACK_MASKS, \"wrong size\");\n@@ -735,15 +679,0 @@\n-  *idealreg2mhdebugmask[Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2mhdebugmask[Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2mhdebugmask[Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2mhdebugmask[Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2mhdebugmask[Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2mhdebugmask[Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2mhdebugmask[Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2mhdebugmask[Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2mhdebugmask[Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2mhdebugmask[Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2mhdebugmask[Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2mhdebugmask[Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2mhdebugmask[Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n-\n@@ -754,1 +683,0 @@\n-  RegMask* mh_caller_save_mask = exclude_soe ? &mh_caller_save_regmask_exclude_soe : &mh_caller_save_regmask;\n@@ -770,15 +698,0 @@\n-\n-  idealreg2mhdebugmask[Op_RegN]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegI]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegL]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegF]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegP]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegVectMask]->SUBTRACT(*mh_caller_save_mask);\n-\n-  idealreg2mhdebugmask[Op_VecA]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecS]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecX]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecY]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecZ]->SUBTRACT(*mh_caller_save_mask);\n@@ -1013,1 +926,0 @@\n-      mh_caller_save_regmask.Insert(i);\n@@ -1020,1 +932,0 @@\n-      mh_caller_save_regmask_exclude_soe.Insert(i);\n@@ -1024,6 +935,0 @@\n-  \/\/ Also exclude the register we use to save the SP for MethodHandle\n-  \/\/ invokes to from the corresponding MH debug masks\n-  const RegMask sp_save_mask = method_handle_invoke_SP_save_mask();\n-  mh_caller_save_regmask.OR(sp_save_mask);\n-  mh_caller_save_regmask_exclude_soe.OR(sp_save_mask);\n-\n@@ -1305,1 +1210,0 @@\n-  bool             is_method_handle_invoke = false;  \/\/ for special kill effects\n@@ -1331,2 +1235,0 @@\n-      is_method_handle_invoke = call_java->is_method_handle_invoke();\n-      mcall_java->_method_handle_invoke = is_method_handle_invoke;\n@@ -1335,3 +1237,0 @@\n-      if (is_method_handle_invoke) {\n-        C->set_has_method_handle_invokes(true);\n-      }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":108,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -182,1 +182,0 @@\n-  RegMask *idealreg2mhdebugmask[_last_machine_leaf];\n@@ -190,2 +189,0 @@\n-  static RegMask mh_caller_save_regmask;\n-  static RegMask mh_caller_save_regmask_exclude_soe;\n@@ -429,2 +426,0 @@\n-  static const RegMask method_handle_invoke_SP_save_mask();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1007,1 +1007,0 @@\n-  bool is_method_handle_invoke = false;\n@@ -1019,1 +1018,0 @@\n-    \/\/ Is the call a MethodHandle call?\n@@ -1021,4 +1019,0 @@\n-      if (mcall->as_MachCallJava()->_method_handle_invoke) {\n-        assert(C->has_method_handle_invokes(), \"must have been set during call generation\");\n-        is_method_handle_invoke = true;\n-      }\n@@ -1207,1 +1201,0 @@\n-      is_method_handle_invoke,\n@@ -1385,3 +1378,0 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n@@ -1879,7 +1869,0 @@\n-\n-    \/\/ Emit the MethodHandle deopt handler code (if required).\n-    if (C->has_method_handle_invokes() && !C->failing()) {\n-      \/\/ We can use the same code as for the normal deopt handler, we\n-      \/\/ just need a different entry point address.\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n-    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1916,3 +1916,0 @@\n-\n-    \/\/ Check if the exception PC is a MethodHandle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -592,6 +592,1 @@\n-\n-  \/\/ If the deopt call site is a MethodHandle invoke call site we have\n-  \/\/ to adjust the unpack_sp.\n-  nmethod* deoptee_nm = deoptee.cb()->as_nmethod_or_null();\n-  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n-    unpack_sp = deoptee.unextended_sp();\n+  assert(unpack_sp == deoptee.unextended_sp(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -209,4 +209,1 @@\n-    if (nm->is_method_handle_return(pc()))\n-      return nm->deopt_mh_handler_begin() - pc_return_offset;\n-    else\n-      return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_begin() - pc_return_offset;\n@@ -361,3 +358,1 @@\n-  address deopt = nm->is_method_handle_return(pc()) ?\n-                        nm->deopt_mh_handler_begin() :\n-                        nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -479,1 +479,0 @@\n-  _is_method_handle_return(0),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -453,1 +453,0 @@\n-  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n@@ -823,1 +822,0 @@\n-  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n@@ -872,1 +870,0 @@\n-  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -528,3 +528,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -545,2 +542,0 @@\n-    \/\/ Set flag if return address is a method handle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n@@ -616,1 +615,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -1715,1 +1713,0 @@\n-  declare_constant(PcDesc::PCDESC_is_method_handle_invoke)                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  private static CIntegerField deoptMhHandlerOffsetField;\n@@ -89,1 +88,0 @@\n-    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n@@ -128,1 +126,0 @@\n-  public Address deoptMhHandlerBegin()  { return headerBegin().addOffsetTo(getDeoptMhHandlerOffset()); }\n@@ -253,11 +250,0 @@\n-  \/\/ MethodHandle\n-  public boolean isMethodHandleReturn(Address returnPc) {\n-    \/\/ Hard to read a bit fields from Java and it's only there for performance\n-    \/\/ so just go directly to the PCDesc\n-    \/\/ if (!hasMethodHandleInvokes())  return false;\n-    PCDesc pd = getPCDescAt(returnPc);\n-    if (pd == null)\n-      return false;\n-    return pd.isMethodHandleInvoke();\n-  }\n-\n@@ -266,1 +252,1 @@\n-  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }\n+  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc); }\n@@ -268,1 +254,0 @@\n-  public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }\n@@ -497,1 +482,0 @@\n-  private int getDeoptMhHandlerOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  private static int isMethodHandleInvokeMask;\n@@ -64,1 +63,0 @@\n-    isMethodHandleInvokeMask = db.lookupIntConstant(\"PcDesc::PCDESC_is_method_handle_invoke\");\n@@ -96,5 +94,0 @@\n-  public boolean isMethodHandleInvoke() {\n-    int flags = (int)pcFlagsField.getValue(addr);\n-    return (flags & isMethodHandleInvokeMask) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/PCDesc.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -369,2 +369,1 @@\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n+      if (senderNm.isDeoptEntry(getPC())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -361,2 +361,1 @@\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n+      if (senderNm.isDeoptEntry(getPC())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -366,2 +366,1 @@\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n+      if (senderNm.isDeoptEntry(getPC())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}