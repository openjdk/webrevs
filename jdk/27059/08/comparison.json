{"files":[{"patch":"@@ -2571,4 +2571,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,7 +386,0 @@\n-\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on aarch64\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -231,2 +231,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -457,42 +456,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On aarch64, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,2 +144,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -155,5 +153,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-  adjust_unextended_sp();\n-\n@@ -226,1 +224,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1157,4 +1157,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REGP_mask();\n-}\n-\n@@ -1251,17 +1247,0 @@\n-  enc_class preserve_SP %{\n-    \/\/ preserve mark\n-    address mark = __ inst_mark();\n-    DEBUG_ONLY(int off0 = __ offset());\n-    \/\/ FP is preserved across all calls, even compiled calls.\n-    \/\/ Use it to preserve SP in places where the callee might change the SP.\n-    __ mov(Rmh_SP_save, SP);\n-    DEBUG_ONLY(int off1 = __ offset());\n-    assert(off1 - off0 == 4, \"correct size prediction\");\n-    \/\/ restore mark\n-    __ set_inst_mark(mark);\n-  %}\n-\n-  enc_class restore_SP %{\n-    __ mov(SP, Rmh_SP_save);\n-  %}\n-\n@@ -8802,1 +8781,0 @@\n-  predicate(! ((CallStaticJavaNode*)n)->is_method_handle_invoke());\n@@ -8811,14 +8789,0 @@\n-\/\/ Call Java Static Instruction (method handle version)\n-instruct CallStaticJavaHandle( method meth ) %{\n-  match(CallStaticJava);\n-  predicate(((CallStaticJavaNode*)n)->is_method_handle_invoke());\n-  effect(USE meth);\n-  \/\/ FP is saved by all callees (for interpreter stack correction).\n-  \/\/ We use it here for a similar purpose, in {preserve,restore}_FP.\n-\n-  ins_cost(CALL_COST);\n-  format %{ \"CALL,static\/MethodHandle ==> \" %}\n-  ins_encode( SetInstMark, preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog, ClearInstMark );\n-  ins_pipe(simple_call);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -435,2 +435,1 @@\n-  return ((far ? 3 : 1) + (_method_handle_invoke ? 1 : 0)) *\n-    NativeInstruction::instruction_size;\n+  return (far ? 3 : 1) * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -177,5 +177,0 @@\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  assert(Rmh_SP_save == FP, \"Fix register used for saving SP for MethodHandle calls\");\n-  return FP_opr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_FrameMap_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -278,8 +278,0 @@\n-static void restore_sp_for_method_handle(StubAssembler* sasm) {\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr_s32(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-}\n-\n-\n@@ -342,1 +334,0 @@\n-    restore_sp_for_method_handle(sasm);\n@@ -375,3 +366,0 @@\n-  \/\/ JSR292 extension\n-  restore_sp_for_method_handle(sasm);\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -332,50 +332,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.  The unextended SP might also be the saved SP\n-\/\/ for MethodHandle call sites.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-  assert(nm->is_method_handle_return(original_pc) == is_method_handle_return, \"must be\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-void frame::adjust_unextended_sp() {\n-  \/\/ same as on x86\n-\n-  \/\/ If we are returning to a compiled MethodHandle call site, the\n-  \/\/ saved_fp will in fact be a saved value of the unextended SP.  The\n-  \/\/ simplest way to tell whether we are returning to such a call site\n-  \/\/ is as follows:\n-\n-  nmethod* sender_nm = (_cb == nullptr) ? nullptr : _cb->as_nmethod_or_null();\n-  if (sender_nm != nullptr) {\n-    \/\/ If the sender PC is a deoptimization point, get the original\n-    \/\/ PC.  For MethodHandle call site the unextended_sp is stored in\n-    \/\/ saved_fp.\n-    if (sender_nm->is_deopt_mh_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_mh_original_pc(sender_nm, _fp));\n-      _unextended_sp = _fp;\n-    }\n-    else if (sender_nm->is_deopt_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_original_pc(sender_nm, _unextended_sp));\n-    }\n-    else if (sender_nm->is_method_handle_return(_pc)) {\n-      _unextended_sp = _fp;\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,0 @@\n-  void adjust_unextended_sp();\n@@ -94,8 +93,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp, bool is_method_handle_return = false);\n-  static void verify_deopt_mh_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-    verify_deopt_original_pc(nm, unextended_sp, true);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,0 @@\n-  adjust_unextended_sp();\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,1 +367,0 @@\n-#define Rmh_SP_save      FP \/\/ for C1\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,5 +267,0 @@\n-  \/\/ Restore SP from its saved reg (FP) if the exception PC is a MethodHandle call site.\n-  __ ldr(Rtemp, Address(Rthread, JavaThread::is_method_handle_return_offset()));\n-  __ cmp(Rtemp, 0);\n-  __ mov(SP, Rmh_SP_save, ne);\n-\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -377,9 +377,0 @@\n-\n-\/\/ JSR 292\n-\/\/ On PPC64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_FrameMap_ppc.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2476,4 +2476,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n@@ -3437,1 +3433,0 @@\n-    call->_method_handle_invoke = _method_handle_invoke;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -380,5 +380,0 @@\n-\/\/ JSR 292\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;  \/\/ Not needed on riscv\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_FrameMap_riscv.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,2 +220,1 @@\n-      if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-          nm->method()->is_method_handle_intrinsic()) {\n+      if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -430,43 +429,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  assert_cond(nm != nullptr);\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On riscv, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,2 +182,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -188,5 +186,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,2 +117,0 @@\n-  adjust_unextended_sp();\n-\n@@ -218,1 +216,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2135,4 +2135,0 @@\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return FP_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,7 +285,0 @@\n-\/\/ JSR 292\n-\/\/ On ZARCH_64, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_FrameMap_s390.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1982,5 +1982,0 @@\n-\/\/ Copied from sparc.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-  return RegMask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -329,7 +329,0 @@\n-\/\/ JSR 292\n-\/\/ On x86, there is no need to save the SP, because neither\n-\/\/ method handle intrinsics, nor compiled lambda forms modify it.\n-LIR_Opr FrameMap::method_handle_invoke_SP_save_opr() {\n-  return LIR_OprFact::illegalOpr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_FrameMap_x86.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -222,2 +222,1 @@\n-        if (nm->is_deopt_mh_entry(sender_pc) || nm->is_deopt_entry(sender_pc) ||\n-            nm->method()->is_method_handle_intrinsic()) {\n+        if (nm->is_deopt_entry(sender_pc) || nm->method()->is_method_handle_intrinsic()) {\n@@ -446,41 +445,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it) original_pc: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" name: %s\", p2i(original_pc), p2i(unextended_sp), nm->name());\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc) ||\n-          sender_nm->is_deopt_mh_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,2 +141,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -147,5 +145,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,2 +114,0 @@\n-  adjust_unextended_sp();\n-\n@@ -212,1 +210,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1700,5 +1700,0 @@\n-\/\/ Register for saving SP into on method handle invokes. Not used on x86_64.\n-const RegMask Matcher::method_handle_invoke_SP_save_mask() {\n-    return NO_REG_mask();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -624,3 +624,1 @@\n-        address deopt = nm->is_method_handle_return(pc) ?\n-          nm->deopt_mh_handler_begin() :\n-          nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2814,3 +2814,1 @@\n-          address deopt = nm->is_method_handle_return(pc) ?\n-            nm->deopt_mh_handler_begin() :\n-            nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-                 DeoptMH,        \/\/ Offset where MethodHandle deopt handler lives\n@@ -80,1 +79,0 @@\n-    _values[DeoptMH       ] = -1;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,8 +313,0 @@\n-  \/\/ Emit the MethodHandle deopt handler code (if required).\n-  if (has_method_handle_invokes()) {\n-    \/\/ We can use the same code as for the normal deopt handler, we\n-    \/\/ just need a different entry point address.\n-    code_offsets->set_value(CodeOffsets::DeoptMH, assembler->emit_deopt_handler());\n-    CHECK_BAILOUT();\n-  }\n-\n@@ -577,1 +569,0 @@\n-, _has_method_handle_invokes(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  bool               _has_method_handle_invokes;  \/\/ True if this method has MethodHandle invokes.\n@@ -183,4 +182,0 @@\n-  \/\/ JSR 292\n-  bool     has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -158,3 +158,0 @@\n-  \/\/ JSR 292\n-  static LIR_Opr method_handle_invoke_SP_save_opr();\n-\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-  , _is_method_handle_invoke(false)\n@@ -206,1 +205,0 @@\n-  , _is_method_handle_invoke(info->_is_method_handle_invoke)\n@@ -221,1 +219,1 @@\n-  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute, _is_method_handle_invoke);\n+  _scope_debug_info->record_debug_info(recorder, pc_offset, reexecute);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute, bool is_method_handle_invoke = false) {\n+  void record_debug_info(DebugInformationRecorder* recorder, int pc_offset, bool reexecute) {\n@@ -251,1 +251,1 @@\n-                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop,\n+                             reexecute, rethrow_exception, return_oop,\n@@ -265,1 +265,0 @@\n-  bool              _is_method_handle_invoke;    \/\/ true if the associated call site is a MethodHandle call site.\n@@ -291,3 +290,0 @@\n-  bool     is_method_handle_invoke() const { return _is_method_handle_invoke;     }\n-  void set_is_method_handle_invoke(bool x) {        _is_method_handle_invoke = x; }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -712,5 +712,0 @@\n-      if (FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr &&\n-          opJavaCall->is_method_handle_invoke()) {\n-        opJavaCall->_method_handle_invoke_SP_save_opr = FrameMap::method_handle_invoke_SP_save_opr();\n-        do_temp(opJavaCall->_method_handle_invoke_SP_save_opr);\n-      }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1179,1 +1179,0 @@\n-  LIR_Opr   _method_handle_invoke_SP_save_opr;  \/\/ Used in LIR_OpVisitState::visit to store the reference to FrameMap::method_handle_invoke_SP_save_opr.\n@@ -1189,1 +1188,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n@@ -1198,1 +1196,0 @@\n-  , _method_handle_invoke_SP_save_opr(LIR_OprFact::illegalOpr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -481,6 +481,0 @@\n-\n-  \/\/ JSR 292\n-  \/\/ Record if this method has MethodHandle invokes.\n-  if (op->is_method_handle_invoke()) {\n-    compilation()->set_has_method_handle_invokes(true);\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2715,2 +2715,0 @@\n-  \/\/ JSR 292\n-  \/\/ Preserve the SP over MethodHandle call sites, if needed.\n@@ -2718,10 +2716,0 @@\n-  bool is_method_handle_invoke = (\/\/ %%% FIXME: Are both of these relevant?\n-                                  target->is_method_handle_intrinsic() ||\n-                                  target->is_compiled_lambda_form());\n-  if (is_method_handle_invoke) {\n-    info->set_is_method_handle_invoke(true);\n-    if(FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-        __ move(FrameMap::stack_pointer(), FrameMap::method_handle_invoke_SP_save_opr());\n-    }\n-  }\n-\n@@ -2760,7 +2748,0 @@\n-  \/\/ JSR 292\n-  \/\/ Restore the SP after MethodHandle call sites, if needed.\n-  if (is_method_handle_invoke\n-      && FrameMap::method_handle_invoke_SP_save_opr() != LIR_OprFact::illegalOpr) {\n-    __ move(FrameMap::method_handle_invoke_SP_save_opr(), FrameMap::stack_pointer());\n-  }\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -544,3 +544,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -625,2 +622,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -663,2 +658,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-                                              bool        is_method_handle_invoke,\n@@ -304,1 +303,0 @@\n-  last_pd->set_is_method_handle_invoke(is_method_handle_invoke);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,0 @@\n-                      bool        is_method_handle_invoke = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -468,8 +468,0 @@\n-bool nmethod::is_method_handle_return(address return_pc) {\n-  if (!has_method_handle_invokes())  return false;\n-  PcDesc* pd = pc_desc_at(return_pc);\n-  if (pd == nullptr)\n-    return false;\n-  return pd->is_method_handle_invoke();\n-}\n-\n@@ -1240,1 +1232,0 @@\n-  _has_method_handle_invokes  = 0;\n@@ -1319,1 +1310,0 @@\n-    _deopt_mh_handler_offset = 0;\n@@ -1467,5 +1457,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = code_offset() + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -1481,5 +1466,0 @@\n-      if (offsets->value(CodeOffsets::DeoptMH) != -1) {\n-        _deopt_mh_handler_offset = _stub_offset + offsets->value(CodeOffsets::DeoptMH);\n-      } else {\n-        _deopt_mh_handler_offset = -1;\n-      }\n@@ -2702,9 +2682,0 @@\n-  \/\/ Search for MethodHandle invokes and tag the nmethod.\n-  for (int i = 0; i < count; i++) {\n-    if (pcs[i].is_method_handle_invoke()) {\n-      set_has_method_handle_invokes(true);\n-      break;\n-    }\n-  }\n-  assert(has_method_handle_invokes() == (_deopt_mh_handler_offset != -1), \"must have deopt mh handler\");\n-\n@@ -3720,1 +3691,0 @@\n-  if (has_method_handle_invokes() && (pos == deopt_mh_handler_begin())) label = \"[Deopt MH Handler Code]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -230,3 +230,0 @@\n-  \/\/ All deoptee's at a MethodHandle call site will resume execution\n-  \/\/ at this location described by this offset.\n-  int _deopt_mh_handler_offset;\n@@ -271,1 +268,0 @@\n-          _has_method_handle_invokes:1,\/\/ Has this method MethodHandle invokes?\n@@ -610,1 +606,0 @@\n-  address deopt_mh_handler_begin() const { return           header_begin() + _deopt_mh_handler_offset ; }\n@@ -749,3 +744,0 @@\n-  bool  has_method_handle_invokes() const         { return _has_method_handle_invokes; }\n-  void  set_has_method_handle_invokes(bool z)     { _has_method_handle_invokes = z; }\n-\n@@ -822,2 +814,0 @@\n-  \/\/ MethodHandle\n-  bool is_method_handle_return(address return_pc);\n@@ -827,1 +817,0 @@\n-  inline bool is_deopt_mh_entry(address pc);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc) || is_deopt_mh_entry(pc); }\n+inline bool nmethod::is_deopt_pc(address pc) { return is_deopt_entry(pc); }\n@@ -40,4 +40,0 @@\n-inline bool nmethod::is_deopt_mh_entry(address pc) {\n-  return pc == deopt_mh_handler_begin();\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,5 +43,4 @@\n-    PCDESC_is_method_handle_invoke   = 1 << 1,\n-    PCDESC_return_oop                = 1 << 2,\n-    PCDESC_rethrow_exception         = 1 << 3,\n-    PCDESC_has_ea_local_in_scope     = 1 << 4,\n-    PCDESC_arg_escape                = 1 << 5\n+    PCDESC_return_oop                = 1 << 1,\n+    PCDESC_rethrow_exception         = 1 << 2,\n+    PCDESC_has_ea_local_in_scope     = 1 << 3,\n+    PCDESC_arg_escape                = 1 << 4\n@@ -88,3 +87,0 @@\n-  bool     is_method_handle_invoke()       const { return (_flags & PCDESC_is_method_handle_invoke) != 0;     }\n-  void set_is_method_handle_invoke(bool z)       { set_flag(PCDESC_is_method_handle_invoke, z); }\n-\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1144,1 +1144,1 @@\n-void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS) {\n+void CodeInstaller::record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS) {\n@@ -1187,1 +1187,1 @@\n-      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, is_mh_invoke, return_oop,\n+      _debug_recorder->describe_scope(pc_offset, method, nullptr, bci, reexecute, rethrow_exception, return_oop,\n@@ -1245,6 +1245,0 @@\n-      vmIntrinsics::ID iid = method->intrinsic_id();\n-      bool is_mh_invoke = false;\n-      if (direct_call) {\n-        is_mh_invoke = !method->is_static() && (iid == vmIntrinsics::_compiledLambdaForm ||\n-                (MethodHandles::is_signature_polymorphic(iid) && MethodHandles::is_signature_polymorphic_intrinsic(iid)));\n-      }\n@@ -1252,1 +1246,1 @@\n-      record_scope(next_pc_offset, stream, flags, true, is_mh_invoke, return_oop, JVMCI_CHECK);\n+      record_scope(next_pc_offset, stream, flags, true, return_oop, JVMCI_CHECK);\n@@ -1342,3 +1336,0 @@\n-    case DEOPT_MH_HANDLER_ENTRY:\n-      _offsets.set_value(CodeOffsets::DeoptMH, pc_offset);\n-      break;\n@@ -1372,0 +1363,1 @@\n+    case DEOPT_MH_HANDLER_ENTRY:\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,1 @@\n-  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool is_mh_invoke, bool return_oop, JVMCI_TRAPS);\n+  void record_scope(jint pc_offset, HotSpotCompiledCodeStream* stream, u1 debug_info_flags, bool full_info, bool return_oop, JVMCI_TRAPS);\n@@ -417,1 +417,1 @@\n-    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* is_mh_invoke *\/, false \/* return_oop *\/, JVMCIENV);\n+    record_scope(pc_offset, stream, debug_info_flags, full_info, false \/* return_oop *\/, JVMCIENV);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -308,2 +305,0 @@\n-      \/\/ Set flag if return address is a method handle call site.\n-      current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n@@ -346,3 +341,0 @@\n-  \/\/ Set flag if return address is a method handle call site.\n-  current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,4 +172,0 @@\n-    if (method()->is_method_handle_intrinsic() ||\n-        method()->is_compiled_lambda_form()) {\n-      call->set_method_handle_invoke(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,1 +781,0 @@\n-  bool    _method_handle_invoke;\n@@ -789,1 +788,0 @@\n-      _method_handle_invoke(false),\n@@ -801,2 +799,0 @@\n-  void  set_method_handle_invoke(bool f)   { _method_handle_invoke = f; }\n-  bool  is_method_handle_invoke() const    { return _method_handle_invoke; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -653,1 +653,0 @@\n-      _has_method_handle_invokes(false),\n@@ -928,1 +927,0 @@\n-      _has_method_handle_invokes(false),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,2 +357,0 @@\n-  \/\/ JSR 292\n-  bool                  _has_method_handle_invokes; \/\/ True if this method has MethodHandle invokes.\n@@ -669,4 +667,0 @@\n-  \/\/ JSR 292\n-  bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }\n-  void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }\n-\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -949,11 +949,0 @@\n-\n-  \/\/ If the call is a MethodHandle invoke, we need to exclude the\n-  \/\/ register which is used to save the SP value over MH invokes from\n-  \/\/ the mask.  Otherwise this register could be used for\n-  \/\/ deoptimization information.\n-  if (op == Op_CallStaticJava) {\n-    MachCallStaticJavaNode* mcallstaticjava = (MachCallStaticJavaNode*) mcall;\n-    if (mcallstaticjava->_method_handle_invoke)\n-      proj->_rout.OR(Matcher::method_handle_invoke_SP_save_mask());\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -775,2 +775,0 @@\n-  if (_method_handle_invoke)\n-    st->print(\"MethodHandle \");\n@@ -797,4 +795,1 @@\n-  \/\/ If this call is a MethodHandle invoke we have to use a different\n-  \/\/ debugmask which does not include the register we use to save the\n-  \/\/ SP over MH invokes.\n-  RegMask** debugmask = _method_handle_invoke ? m->idealreg2mhdebugmask : m->idealreg2debugmask;\n+  RegMask** debugmask = m->idealreg2debugmask;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -963,1 +963,0 @@\n-  bool      _method_handle_invoke;   \/\/ Tells if the call has to preserve SP\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-RegMask Matcher::mh_caller_save_regmask;\n-RegMask Matcher::mh_caller_save_regmask_exclude_soe;\n@@ -117,15 +115,0 @@\n-  idealreg2mhdebugmask[Op_RegI] = nullptr;\n-  idealreg2mhdebugmask[Op_RegN] = nullptr;\n-  idealreg2mhdebugmask[Op_RegL] = nullptr;\n-  idealreg2mhdebugmask[Op_RegF] = nullptr;\n-  idealreg2mhdebugmask[Op_RegD] = nullptr;\n-  idealreg2mhdebugmask[Op_RegP] = nullptr;\n-  idealreg2mhdebugmask[Op_VecA] = nullptr;\n-  idealreg2mhdebugmask[Op_VecS] = nullptr;\n-  idealreg2mhdebugmask[Op_VecD] = nullptr;\n-  idealreg2mhdebugmask[Op_VecX] = nullptr;\n-  idealreg2mhdebugmask[Op_VecY] = nullptr;\n-  idealreg2mhdebugmask[Op_VecZ] = nullptr;\n-  idealreg2mhdebugmask[Op_RegFlags] = nullptr;\n-  idealreg2mhdebugmask[Op_RegVectMask] = nullptr;\n-\n@@ -468,1 +451,1 @@\n-#define NOF_STACK_MASKS (3*13)\n+#define NOF_STACK_MASKS (2*13)\n@@ -483,45 +466,6 @@\n-  idealreg2spillmask  [Op_RegN] = &rms[0];\n-  idealreg2spillmask  [Op_RegI] = &rms[1];\n-  idealreg2spillmask  [Op_RegL] = &rms[2];\n-  idealreg2spillmask  [Op_RegF] = &rms[3];\n-  idealreg2spillmask  [Op_RegD] = &rms[4];\n-  idealreg2spillmask  [Op_RegP] = &rms[5];\n-\n-  idealreg2debugmask  [Op_RegN] = &rms[6];\n-  idealreg2debugmask  [Op_RegI] = &rms[7];\n-  idealreg2debugmask  [Op_RegL] = &rms[8];\n-  idealreg2debugmask  [Op_RegF] = &rms[9];\n-  idealreg2debugmask  [Op_RegD] = &rms[10];\n-  idealreg2debugmask  [Op_RegP] = &rms[11];\n-\n-  idealreg2mhdebugmask[Op_RegN] = &rms[12];\n-  idealreg2mhdebugmask[Op_RegI] = &rms[13];\n-  idealreg2mhdebugmask[Op_RegL] = &rms[14];\n-  idealreg2mhdebugmask[Op_RegF] = &rms[15];\n-  idealreg2mhdebugmask[Op_RegD] = &rms[16];\n-  idealreg2mhdebugmask[Op_RegP] = &rms[17];\n-\n-  idealreg2spillmask  [Op_VecA] = &rms[18];\n-  idealreg2spillmask  [Op_VecS] = &rms[19];\n-  idealreg2spillmask  [Op_VecD] = &rms[20];\n-  idealreg2spillmask  [Op_VecX] = &rms[21];\n-  idealreg2spillmask  [Op_VecY] = &rms[22];\n-  idealreg2spillmask  [Op_VecZ] = &rms[23];\n-\n-  idealreg2debugmask  [Op_VecA] = &rms[24];\n-  idealreg2debugmask  [Op_VecS] = &rms[25];\n-  idealreg2debugmask  [Op_VecD] = &rms[26];\n-  idealreg2debugmask  [Op_VecX] = &rms[27];\n-  idealreg2debugmask  [Op_VecY] = &rms[28];\n-  idealreg2debugmask  [Op_VecZ] = &rms[29];\n-\n-  idealreg2mhdebugmask[Op_VecA] = &rms[30];\n-  idealreg2mhdebugmask[Op_VecS] = &rms[31];\n-  idealreg2mhdebugmask[Op_VecD] = &rms[32];\n-  idealreg2mhdebugmask[Op_VecX] = &rms[33];\n-  idealreg2mhdebugmask[Op_VecY] = &rms[34];\n-  idealreg2mhdebugmask[Op_VecZ] = &rms[35];\n-\n-  idealreg2spillmask  [Op_RegVectMask] = &rms[36];\n-  idealreg2debugmask  [Op_RegVectMask] = &rms[37];\n-  idealreg2mhdebugmask[Op_RegVectMask] = &rms[38];\n+  int index = 0;\n+  for (int i = Op_RegN; i <= Op_RegVectMask; ++i) {\n+    idealreg2spillmask[i] = &rms[index++];\n+    idealreg2debugmask[i] = &rms[index++];\n+  }\n+  assert(index == NOF_STACK_MASKS, \"wrong size\");\n@@ -713,15 +657,0 @@\n-  *idealreg2mhdebugmask[Op_RegN] = *idealreg2spillmask[Op_RegN];\n-  *idealreg2mhdebugmask[Op_RegI] = *idealreg2spillmask[Op_RegI];\n-  *idealreg2mhdebugmask[Op_RegL] = *idealreg2spillmask[Op_RegL];\n-  *idealreg2mhdebugmask[Op_RegF] = *idealreg2spillmask[Op_RegF];\n-  *idealreg2mhdebugmask[Op_RegD] = *idealreg2spillmask[Op_RegD];\n-  *idealreg2mhdebugmask[Op_RegP] = *idealreg2spillmask[Op_RegP];\n-  *idealreg2mhdebugmask[Op_RegVectMask] = *idealreg2spillmask[Op_RegVectMask];\n-\n-  *idealreg2mhdebugmask[Op_VecA] = *idealreg2spillmask[Op_VecA];\n-  *idealreg2mhdebugmask[Op_VecS] = *idealreg2spillmask[Op_VecS];\n-  *idealreg2mhdebugmask[Op_VecD] = *idealreg2spillmask[Op_VecD];\n-  *idealreg2mhdebugmask[Op_VecX] = *idealreg2spillmask[Op_VecX];\n-  *idealreg2mhdebugmask[Op_VecY] = *idealreg2spillmask[Op_VecY];\n-  *idealreg2mhdebugmask[Op_VecZ] = *idealreg2spillmask[Op_VecZ];\n-\n@@ -732,1 +661,0 @@\n-  RegMask* mh_caller_save_mask = exclude_soe ? &mh_caller_save_regmask_exclude_soe : &mh_caller_save_regmask;\n@@ -748,15 +676,0 @@\n-\n-  idealreg2mhdebugmask[Op_RegN]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegI]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegL]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegF]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegP]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_RegVectMask]->SUBTRACT(*mh_caller_save_mask);\n-\n-  idealreg2mhdebugmask[Op_VecA]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecS]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecD]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecX]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecY]->SUBTRACT(*mh_caller_save_mask);\n-  idealreg2mhdebugmask[Op_VecZ]->SUBTRACT(*mh_caller_save_mask);\n@@ -987,1 +900,0 @@\n-      mh_caller_save_regmask.Insert(i);\n@@ -994,1 +906,0 @@\n-      mh_caller_save_regmask_exclude_soe.Insert(i);\n@@ -998,6 +909,0 @@\n-  \/\/ Also exclude the register we use to save the SP for MethodHandle\n-  \/\/ invokes to from the corresponding MH debug masks\n-  const RegMask sp_save_mask = method_handle_invoke_SP_save_mask();\n-  mh_caller_save_regmask.OR(sp_save_mask);\n-  mh_caller_save_regmask_exclude_soe.OR(sp_save_mask);\n-\n@@ -1275,1 +1180,0 @@\n-  bool             is_method_handle_invoke = false;  \/\/ for special kill effects\n@@ -1301,2 +1205,0 @@\n-      is_method_handle_invoke = call_java->is_method_handle_invoke();\n-      mcall_java->_method_handle_invoke = is_method_handle_invoke;\n@@ -1305,3 +1207,0 @@\n-      if (is_method_handle_invoke) {\n-        C->set_has_method_handle_invokes(true);\n-      }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":7,"deletions":108,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,1 +182,0 @@\n-  RegMask *idealreg2mhdebugmask[_last_machine_leaf];\n@@ -190,2 +189,0 @@\n-  static RegMask mh_caller_save_regmask;\n-  static RegMask mh_caller_save_regmask_exclude_soe;\n@@ -429,2 +426,0 @@\n-  static const RegMask method_handle_invoke_SP_save_mask();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -995,1 +995,0 @@\n-  bool is_method_handle_invoke = false;\n@@ -1007,1 +1006,0 @@\n-    \/\/ Is the call a MethodHandle call?\n@@ -1009,4 +1007,0 @@\n-      if (mcall->as_MachCallJava()->_method_handle_invoke) {\n-        assert(C->has_method_handle_invokes(), \"must have been set during call generation\");\n-        is_method_handle_invoke = true;\n-      }\n@@ -1195,1 +1189,0 @@\n-      is_method_handle_invoke,\n@@ -1373,3 +1366,0 @@\n-  if (C->has_method_handle_invokes())\n-    total_req += deopt_handler_req;  \/\/ deopt MH handler\n-\n@@ -1809,7 +1799,0 @@\n-\n-    \/\/ Emit the MethodHandle deopt handler code (if required).\n-    if (C->has_method_handle_invokes() && !C->failing()) {\n-      \/\/ We can use the same code as for the normal deopt handler, we\n-      \/\/ just need a different entry point address.\n-      _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(masm));\n-    }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1916,3 +1916,0 @@\n-\n-    \/\/ Check if the exception PC is a MethodHandle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -592,6 +592,1 @@\n-\n-  \/\/ If the deopt call site is a MethodHandle invoke call site we have\n-  \/\/ to adjust the unpack_sp.\n-  nmethod* deoptee_nm = deoptee.cb()->as_nmethod_or_null();\n-  if (deoptee_nm != nullptr && deoptee_nm->is_method_handle_return(deoptee.pc()))\n-    unpack_sp = deoptee.unextended_sp();\n+  assert(unpack_sp == deoptee.unextended_sp(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -209,4 +209,1 @@\n-    if (nm->is_method_handle_return(pc()))\n-      return nm->deopt_mh_handler_begin() - pc_return_offset;\n-    else\n-      return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_begin() - pc_return_offset;\n@@ -361,3 +358,1 @@\n-  address deopt = nm->is_method_handle_return(pc()) ?\n-                        nm->deopt_mh_handler_begin() :\n-                        nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_begin();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,4 @@\n-    return nm->get_original_pc(this);\n+    address original_pc = nm->get_original_pc(this);\n+    assert(nm->insts_contains_inclusive(original_pc),\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n+    return original_pc;\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -479,1 +479,0 @@\n-  _is_method_handle_return(0),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -453,1 +453,0 @@\n-  volatile int     _is_method_handle_return;     \/\/ true (== 1) if the current exception PC is a MethodHandle call site.\n@@ -820,1 +819,0 @@\n-  void set_is_method_handle_return(bool value)   { _is_method_handle_return = value ? 1 : 0; }\n@@ -869,1 +867,0 @@\n-  static ByteSize is_method_handle_return_offset() { return byte_offset_of(JavaThread, _is_method_handle_return); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -528,3 +528,0 @@\n-  \/\/ Reset method handle flag.\n-  current->set_is_method_handle_return(false);\n-\n@@ -545,2 +542,0 @@\n-    \/\/ Set flag if return address is a method handle call site.\n-    current->set_is_method_handle_return(nm->is_method_handle_return(return_address));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-  nonstatic_field(nmethod,                     _deopt_mh_handler_offset,                      int)                                   \\\n@@ -616,1 +615,0 @@\n-  volatile_nonstatic_field(JavaThread,         _is_method_handle_return,                      int)                                   \\\n@@ -1720,1 +1718,0 @@\n-  declare_constant(PcDesc::PCDESC_is_method_handle_invoke)                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  private static CIntegerField deoptMhHandlerOffsetField;\n@@ -89,1 +88,0 @@\n-    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n@@ -128,1 +126,0 @@\n-  public Address deoptMhHandlerBegin()  { return headerBegin().addOffsetTo(getDeoptMhHandlerOffset()); }\n@@ -253,11 +250,0 @@\n-  \/\/ MethodHandle\n-  public boolean isMethodHandleReturn(Address returnPc) {\n-    \/\/ Hard to read a bit fields from Java and it's only there for performance\n-    \/\/ so just go directly to the PCDesc\n-    \/\/ if (!hasMethodHandleInvokes())  return false;\n-    PCDesc pd = getPCDescAt(returnPc);\n-    if (pd == null)\n-      return false;\n-    return pd.isMethodHandleInvoke();\n-  }\n-\n@@ -266,1 +252,1 @@\n-  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc) || isDeoptMhEntry(pc); }\n+  public boolean isDeoptPc      (Address pc) { return isDeoptEntry(pc); }\n@@ -268,1 +254,0 @@\n-  public boolean isDeoptMhEntry (Address pc) { return pc == deoptMhHandlerBegin(); }\n@@ -497,1 +482,0 @@\n-  private int getDeoptMhHandlerOffset() { return (int) deoptMhHandlerOffsetField.getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-  private static int isMethodHandleInvokeMask;\n@@ -64,1 +63,0 @@\n-    isMethodHandleInvokeMask = db.lookupIntConstant(\"PcDesc::PCDESC_is_method_handle_invoke\");\n@@ -96,5 +94,0 @@\n-  public boolean isMethodHandleInvoke() {\n-    int flags = (int)pcFlagsField.getValue(addr);\n-    return (flags & isMethodHandleInvokeMask) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/PCDesc.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,18 @@\n+  protected void adjustForDeopt() {\n+    if (pc != null) {\n+      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n+      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n+      if (cb != null && cb.isJavaMethod()) {\n+        NMethod nm = (NMethod) cb;\n+        if (pc.equals(nm.deoptHandlerBegin())) {\n+          if (Assert.ASSERTS_ENABLED) {\n+            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n+          }\n+          \/\/ adjust pc if frame is deoptimized.\n+          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n+          deoptimized = true;\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,18 +109,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -132,1 +114,0 @@\n-    adjustUnextendedSP();\n@@ -156,2 +137,0 @@\n-    adjustUnextendedSP();\n-\n@@ -172,1 +151,0 @@\n-    adjustUnextendedSP();\n@@ -358,18 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,18 +88,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -119,1 +101,0 @@\n-    adjustUnextendedSP();\n@@ -139,1 +120,0 @@\n-    adjustUnextendedSP();\n@@ -163,1 +143,0 @@\n-    adjustUnextendedSP();\n@@ -345,6 +324,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Nothing to do. senderForInterpreterFrame finds the correct unextendedSP.\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,18 +104,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -127,1 +109,0 @@\n-    adjustUnextendedSP();\n@@ -151,2 +132,0 @@\n-    adjustUnextendedSP();\n-\n@@ -167,1 +146,0 @@\n-    adjustUnextendedSP();\n@@ -350,18 +328,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,18 +105,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -137,1 +119,0 @@\n-    adjustUnextendedSP();\n@@ -141,1 +122,1 @@\n-}\n+  }\n@@ -355,18 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-    \/\/ as any other call site. Therefore, no special action is needed when we are\n-    \/\/ returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC()) ||\n-          senderNm.isDeoptMhEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"}]}