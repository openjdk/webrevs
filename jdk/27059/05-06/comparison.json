{"files":[{"patch":"@@ -456,41 +456,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On aarch64, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -144,2 +144,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -155,5 +153,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-  adjust_unextended_sp();\n-\n@@ -226,1 +224,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -332,36 +332,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-void frame::adjust_unextended_sp() {\n-  \/\/ On arm, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  nmethod* sender_nm = (_cb == nullptr) ? nullptr : _cb->as_nmethod_or_null();\n-  if (sender_nm != nullptr) {\n-    \/\/ If the sender PC is a deoptimization point, get the original PC.\n-    if (sender_nm->is_deopt_entry(_pc)) {\n-      DEBUG_ONLY(verify_deopt_original_pc(sender_nm, _unextended_sp));\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-  void adjust_unextended_sp();\n@@ -94,5 +93,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,2 +115,0 @@\n-  adjust_unextended_sp();\n-\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,42 +429,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  assert_cond(nm != nullptr);\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On riscv, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -182,2 +182,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -188,5 +186,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-  adjust_unextended_sp();\n-\n@@ -218,1 +216,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -445,40 +445,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::verify_deopt_original_pc\n-\/\/\n-\/\/ Verifies the calculated original PC of a deoptimization PC for the\n-\/\/ given unextended SP.\n-#ifdef ASSERT\n-void frame::verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp) {\n-  frame fr;\n-\n-  \/\/ This is ugly but it's better than to change {get,set}_original_pc\n-  \/\/ to take an SP value as argument.  And it's only a debugging\n-  \/\/ method anyway.\n-  fr._unextended_sp = unextended_sp;\n-\n-  address original_pc = nm->get_original_pc(&fr);\n-  assert(nm->insts_contains_inclusive(original_pc),\n-         \"original PC must be in the main code section of the compiled method (or must be immediately following it) original_pc: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" name: %s\", p2i(original_pc), p2i(unextended_sp), nm->name());\n-}\n-#endif\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::adjust_unextended_sp\n-#ifdef ASSERT\n-void frame::adjust_unextended_sp() {\n-  \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-  \/\/ as any other call site. Therefore, no special action is needed when we are\n-  \/\/ returning to any of these call sites.\n-\n-  if (_cb != nullptr) {\n-    nmethod* sender_nm = _cb->as_nmethod_or_null();\n-    if (sender_nm != nullptr) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (sender_nm->is_deopt_entry(_pc)) {\n-        verify_deopt_original_pc(sender_nm, _unextended_sp);\n-      }\n-    }\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -141,2 +141,0 @@\n-  void adjust_unextended_sp() NOT_DEBUG_RETURN;\n-\n@@ -147,5 +145,0 @@\n-#ifdef ASSERT\n-  \/\/ Used in frame::sender_for_{interpreter,compiled}_frame\n-  static void verify_deopt_original_pc(nmethod* nm, intptr_t* unextended_sp);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -114,2 +114,0 @@\n-  adjust_unextended_sp();\n-\n@@ -212,1 +210,0 @@\n-  adjust_unextended_sp();\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,1 +79,4 @@\n-    return nm->get_original_pc(this);\n+    address original_pc = nm->get_original_pc(this);\n+    assert(nm->insts_contains_inclusive(original_pc),\n+           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n+    return original_pc;\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,0 +84,18 @@\n+  protected void adjustForDeopt() {\n+    if ( pc != null) {\n+      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n+      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n+      if (cb != null && cb.isJavaMethod()) {\n+        NMethod nm = (NMethod) cb;\n+        if (pc.equals(nm.deoptHandlerBegin())) {\n+          if (Assert.ASSERTS_ENABLED) {\n+            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n+          }\n+          \/\/ adjust pc if frame is deoptimized.\n+          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n+          deoptimized = true;\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -109,18 +109,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -132,1 +114,0 @@\n-    adjustUnextendedSP();\n@@ -156,2 +137,0 @@\n-    adjustUnextendedSP();\n-\n@@ -172,1 +151,0 @@\n-    adjustUnextendedSP();\n@@ -358,17 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -88,18 +88,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -119,1 +101,0 @@\n-    adjustUnextendedSP();\n@@ -139,1 +120,0 @@\n-    adjustUnextendedSP();\n@@ -163,1 +143,0 @@\n-    adjustUnextendedSP();\n@@ -345,6 +324,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Nothing to do. senderForInterpreterFrame finds the correct unextendedSP.\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -104,18 +104,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -127,1 +109,0 @@\n-    adjustUnextendedSP();\n@@ -151,2 +132,0 @@\n-    adjustUnextendedSP();\n-\n@@ -167,1 +146,0 @@\n-    adjustUnextendedSP();\n@@ -350,17 +328,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ Sites calling method handle intrinsics and lambda forms are\n-    \/\/ treated as any other call site. Therefore, no special action is\n-    \/\/ needed when we are returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -105,18 +105,0 @@\n-  private void adjustForDeopt() {\n-    if ( pc != null) {\n-      \/\/ Look for a deopt pc and if it is deopted convert to original pc\n-      CodeBlob cb = VM.getVM().getCodeCache().findBlob(pc);\n-      if (cb != null && cb.isJavaMethod()) {\n-        NMethod nm = (NMethod) cb;\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n-          if (Assert.ASSERTS_ENABLED) {\n-            Assert.that(this.getUnextendedSP() != null, \"null SP in Java frame\");\n-          }\n-          \/\/ adjust pc if frame is deoptimized.\n-          pc = this.getUnextendedSP().getAddressAt(nm.origPCOffset());\n-          deoptimized = true;\n-        }\n-      }\n-    }\n-  }\n-\n@@ -137,1 +119,0 @@\n-    adjustUnextendedSP();\n@@ -141,1 +122,1 @@\n-}\n+  }\n@@ -355,17 +336,0 @@\n-  \/\/------------------------------------------------------------------------------\n-  \/\/ frame::adjust_unextended_sp\n-  private void adjustUnextendedSP() {\n-    \/\/ On x86, sites calling method handle intrinsics and lambda forms are treated\n-    \/\/ as any other call site. Therefore, no special action is needed when we are\n-    \/\/ returning to any of these call sites.\n-\n-    CodeBlob cb = cb();\n-    NMethod senderNm = (cb == null) ? null : cb.asNMethodOrNull();\n-    if (senderNm != null) {\n-      \/\/ If the sender PC is a deoptimization point, get the original PC.\n-      if (senderNm.isDeoptEntry(getPC())) {\n-        \/\/ DEBUG_ONLY(verifyDeoptriginalPc(senderNm, raw_unextendedSp));\n-      }\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"}]}