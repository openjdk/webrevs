{"files":[{"patch":"@@ -10620,1 +10620,1 @@\n-  predicate(!UseAPX);\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10634,1 +10634,1 @@\n-  predicate(UseAPX);\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -10649,1 +10649,1 @@\n-  predicate(UseAPX);\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_int()->get_con() != -1);\n@@ -11324,1 +11324,1 @@\n-  predicate(!UseAPX);\n+  predicate(!UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11338,1 +11338,1 @@\n-  predicate(UseAPX);\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n@@ -11353,1 +11353,1 @@\n-  predicate(UseAPX);\n+  predicate(UseAPX && n->in(2)->bottom_type()->is_long()->get_con() != -1L);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,13 @@\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F2 \/r\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF};\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF2};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/AndnTestI.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,17 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F3 \/3(opcode extension)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0x3};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsiTestI.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -61,0 +61,17 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W1 F3 \/2(opcode extension part of ModRM.REG)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0x2};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsmskTestI.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -62,0 +62,18 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W1 F3 \/1(opcode extension part of ModRM.REG)\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF,\n+                (byte) 0x38};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF3,\n+                (byte) 0x1};\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BlsrTestI.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,2 @@\n-        if (!((BmiTestCase) testCase).verifyPositive(nativeCode)) {\n+        boolean use_apx = CPUInfo.hasFeature(\"apx_f\");\n+        if (!((BmiTestCase) testCase).verifyPositive(nativeCode, use_apx)) {\n@@ -127,0 +128,2 @@\n+        protected byte[] instrMaskAPX;\n+        protected byte[] instrPatternAPX;\n@@ -163,0 +166,7 @@\n+        protected int countCpuInstructionsAPX(byte[] nativeCode) {\n+            if (instrMaskAPX == null || instrPatternAPX == null) {\n+                return 0;\n+            }\n+            return countCpuInstructions(nativeCode, instrMaskAPX, instrPatternAPX);\n+        }\n+\n@@ -184,2 +194,6 @@\n-        public boolean verifyPositive(byte[] nativeCode) {\n-            final int cnt = countCpuInstructions(nativeCode);\n+        public boolean verifyPositive(byte[] nativeCode, boolean use_apx) {\n+            int cnt = countCpuInstructions(nativeCode);\n+            if (use_apx) {\n+                System.out.println(\"CHECKING APX INST PATTERNS\");\n+                cnt += countCpuInstructionsAPX(nativeCode);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BmiIntrinsicBase.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,15 @@\n+\n+        \/\/ from intel apx specifications EVEX.128.NP.0F38.W0 F5 \/r\n+        instrMaskAPX = new byte[]{\n+                (byte) 0xFF,\n+                (byte) 0x07,\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xFF};\n+\n+        instrPatternAPX = new byte[]{\n+                (byte) 0x62, \/\/ fixed prefix byte 0x62 for extended EVEX instruction\n+                (byte) 0x02, \/\/ 00010 implied 0F 38 leading opcode bytes\n+                (byte) 0x00,\n+                (byte) 0x00,\n+                (byte) 0xF5};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/BzhiTestI2L.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+\n+        \/\/ REX2 variant\n+        instrMaskAPX = new byte[]{(byte) 0xFF, (byte)0x80, (byte) 0xFF};\n+        instrPatternAPX = new byte[]{(byte) 0xD5, (byte) 0x80, (byte) 0xBD};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/LZcntTestI.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,4 @@\n+\n+        \/\/ REX2 variant\n+        instrMaskAPX = new byte[]{(byte) 0xFF, (byte)0x80, (byte) 0xFF};\n+        instrPatternAPX = new byte[]{(byte) 0xD5, (byte) 0x80, (byte) 0xBC};\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/verifycode\/TZcntTestI.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}