{"files":[{"patch":"@@ -1097,0 +1097,12 @@\n+  \/* Note on 'non-obvious' assembly sequence:\n+   *\n+   * While there are vminps\/vmaxps instructions, there are two important differences between hardware\n+   * and Java on how they handle floats:\n+   *  a. -0.0 and +0.0 are considered equal (vminps\/vmaxps will return second parameter when inputs are equal)\n+   *  b. NaN is not necesarily propagated (vminps\/vmaxps will return second parameter when either input is NaN)\n+   *\n+   * It is still more efficient to use vminps\/vmaxps, but with some pre\/post-processing:\n+   *  a. -0.0\/+0.0: Bias negative (positive) numbers to second parameter before vminps (vmaxps)\n+   *                (only useful when signs differ, noop otherwise)\n+   *  b. NaN: Check if it was the first parameter that had the NaN (with vcmp[UNORD_Q])\n+   *\/\n@@ -1098,2 +1110,7 @@\n-    vblendvps(atmp, a, b, a, vlen_enc);\n-    vblendvps(btmp, b, a, a, vlen_enc);\n+    XMMRegister mask = a;\n+    if (EnableX86ECoreOpts) {\n+      vpsrad(tmp, mask, 32, vlen_enc);\n+      mask = tmp;\n+    }\n+    vblendvps(atmp, a, b, mask, vlen_enc, true, btmp);\n+    vblendvps(btmp, b, a, mask, vlen_enc, true, tmp);\n@@ -1102,1 +1119,1 @@\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    vblendvps(dst, tmp, atmp, btmp, vlen_enc, true, btmp);\n@@ -1104,2 +1121,7 @@\n-    vblendvps(btmp, b, a, b, vlen_enc);\n-    vblendvps(atmp, a, b, b, vlen_enc);\n+    XMMRegister mask = b;\n+    if (EnableX86ECoreOpts) {\n+      vpsrad(tmp, mask, 32, vlen_enc);\n+      mask = tmp;\n+    }\n+    vblendvps(btmp, b, a, mask, vlen_enc, true, atmp);\n+    vblendvps(atmp, a, b, mask, vlen_enc, true, tmp);\n@@ -1108,1 +1130,1 @@\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    vblendvps(dst, tmp, atmp, btmp, vlen_enc, true, btmp);\n@@ -1110,2 +1132,8 @@\n-    vblendvpd(atmp, a, b, a, vlen_enc);\n-    vblendvpd(btmp, b, a, a, vlen_enc);\n+    XMMRegister mask = a;\n+    if (EnableX86ECoreOpts) {\n+      vpxor(tmp, tmp, tmp, vlen_enc);\n+      vpcmpgtq(tmp, tmp, mask, vlen_enc);\n+      mask = tmp;\n+    }\n+    vblendvpd(atmp, a, b, mask, vlen_enc, true, btmp);\n+    vblendvpd(btmp, b, a, mask, vlen_enc, true, tmp);\n@@ -1114,1 +1142,1 @@\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    vblendvpd(dst, tmp, atmp, btmp, vlen_enc, true, btmp);\n@@ -1117,2 +1145,8 @@\n-    vblendvpd(btmp, b, a, b, vlen_enc);\n-    vblendvpd(atmp, a, b, b, vlen_enc);\n+    XMMRegister mask = b;\n+    if (EnableX86ECoreOpts) {\n+      vpxor(tmp, tmp, tmp, vlen_enc);\n+      vpcmpgtq(tmp, tmp, mask, vlen_enc);\n+      mask = tmp;\n+    }\n+    vblendvpd(btmp, b, a, mask, vlen_enc, true, atmp);\n+    vblendvpd(atmp, a, b, mask, vlen_enc, true, tmp);\n@@ -1121,1 +1155,1 @@\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    vblendvpd(dst, tmp, atmp, btmp, vlen_enc, true, btmp);\n@@ -5321,1 +5355,1 @@\n-    vblendvpd(dst, one, dst, src, vec_enc);\n+    vblendvpd(dst, one, dst, src, vec_enc, false, xtmp1);\n@@ -5324,1 +5358,1 @@\n-    vblendvpd(dst, dst, src, xtmp1, vec_enc);\n+    vblendvpd(dst, dst, src, xtmp1, vec_enc, true, xtmp1);\n@@ -5329,1 +5363,1 @@\n-    vblendvps(dst, one, dst, src, vec_enc);\n+    vblendvps(dst, one, dst, src, vec_enc, false, xtmp1);\n@@ -5332,1 +5366,1 @@\n-    vblendvps(dst, dst, src, xtmp1, vec_enc);\n+    vblendvps(dst, dst, src, xtmp1, vec_enc, true, xtmp1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -3483,0 +3483,52 @@\n+\/\/ Vector float blend\n+\/\/ vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool fully_masked = false, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvps(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool fully_masked, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst;\n+  bool dst_available = dst != src1 || dst != src2;\n+  if (EnableX86ECoreOpts && scratch_available && dst_available) {\n+    XMMRegister full_mask = mask;\n+    if (!fully_masked) {\n+      vpsrad(scratch, mask, 32, vector_len);\n+      full_mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     full_mask, src1, vector_len); \/\/ if mask == 0, src1\n+      vpand (scratch, full_mask, src2, vector_len); \/\/ if mask == 1, src2\n+    } else {\n+      vpand (dst,     full_mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, full_mask, src1, vector_len); \/\/ if mask == 0, src1\n+    }\n+    vpor(dst, dst, scratch, vector_len);\n+    \/\/ CASE dst==src1==src2\n+  } else {\n+    Assembler::vblendvps(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n+\/\/ vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool fully_masked = false, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvpd(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool fully_masked, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst && (fully_masked || scratch != mask);\n+  bool dst_available = dst != src1 || dst != src2;\n+  if (EnableX86ECoreOpts && scratch_available && dst_available) {\n+    XMMRegister full_mask = mask;\n+    if (!fully_masked) {\n+      vpxor(scratch, scratch, scratch, vector_len);\n+      vpcmpgtq(scratch, scratch, mask, vector_len);\n+      full_mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     full_mask, src1, vector_len); \/\/ if mask == 0, src\n+      vpand (scratch, full_mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpor(dst, dst, scratch, vector_len);\n+    } else {\n+      vpand (dst,     full_mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, full_mask, src1, vector_len); \/\/ if mask == 0, src\n+      vpor(dst, dst, scratch, vector_len);\n+    }\n+  } else {\n+    Assembler::vblendvpd(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1115,0 +1115,4 @@\n+  \/\/ Vector float blend\n+  void vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool fully_masked = false, XMMRegister scratch = xnoreg);\n+  void vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool fully_masked = false, XMMRegister scratch = xnoreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7807,1 +7807,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7821,1 +7821,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7832,0 +7832,16 @@\n+%}\n+\n+instruct ablendvp(legVec dst, legVec src1, legVec src2, legVec mask, legVec vtmp) %{\n+  predicate(UseAVX > 0 && EnableX86ECoreOpts &&\n+            n->in(2)->bottom_type()->isa_vectmask() == NULL &&\n+            Matcher::vector_length_in_bytes(n) <= 32);\n+  match(Set dst (VectorBlend (Binary src1 src2) mask));\n+  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using $vtmp as TEMP\" %}\n+  effect(TEMP vtmp, TEMP dst);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpandn($vtmp$$XMMRegister, $mask$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+    __ vpand($dst$$XMMRegister, $src2$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n+    __ vpor($dst$$XMMRegister, $dst$$XMMRegister, $vtmp$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4503,2 +4503,7 @@\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n+    XMMRegister mask = $b$$XMMRegister;\n+    if (EnableX86ECoreOpts) {\n+      __ vpsrad($tmp$$XMMRegister, mask, 32, vector_len);\n+      mask = $tmp$$XMMRegister;\n+    }\n+    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, mask, vector_len, true, $atmp$$XMMRegister);\n+    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, mask, vector_len, true, $tmp$$XMMRegister);\n@@ -4507,1 +4512,1 @@\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len, true, $btmp$$XMMRegister);\n@@ -4539,2 +4544,8 @@\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n+    XMMRegister mask = $b$$XMMRegister;\n+    if (EnableX86ECoreOpts) {\n+      __ vpxor($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);\n+      __ vpcmpgtq($tmp$$XMMRegister, $tmp$$XMMRegister, mask, vector_len);\n+      mask = $tmp$$XMMRegister;\n+    }\n+    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, mask, vector_len, true, $atmp$$XMMRegister);\n+    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, mask, vector_len, true, $tmp$$XMMRegister);\n@@ -4543,1 +4554,1 @@\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len, true, $btmp$$XMMRegister);\n@@ -4575,2 +4586,7 @@\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n+    XMMRegister mask = $a$$XMMRegister;\n+    if (EnableX86ECoreOpts) {\n+      __ vpsrad($tmp$$XMMRegister, mask, 32, vector_len);\n+      mask = $tmp$$XMMRegister;\n+    }\n+    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, mask, vector_len, true, $btmp$$XMMRegister);\n+    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, mask, vector_len, true, $tmp$$XMMRegister);\n@@ -4579,1 +4595,1 @@\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len, true, $btmp$$XMMRegister);\n@@ -4611,2 +4627,8 @@\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n+    XMMRegister mask = $a$$XMMRegister;\n+    if (EnableX86ECoreOpts) {\n+      __ vpxor($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);\n+      __ vpcmpgtq($tmp$$XMMRegister, $tmp$$XMMRegister, mask, vector_len);\n+      mask = $tmp$$XMMRegister;\n+    }\n+    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, mask, vector_len, true, $btmp$$XMMRegister);\n+    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, mask, vector_len, true, $tmp$$XMMRegister);\n@@ -4615,1 +4637,1 @@\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len, true, $btmp$$XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Random;\n+\n@@ -65,0 +67,1 @@\n+      Random rnd = new Random(20);\n@@ -66,1 +69,1 @@\n-          dinp[i] = (double)i*1.4;\n+          dinp[i] = (double)(i-ARRLEN\/2)*rnd.nextDouble();\n@@ -71,0 +74,9 @@\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+        if (i-ARRLEN\/2<0) {\n+            if (dout[i] != -1.0)  throw new RuntimeException(\"Expected negative numbers in first half of array: \" + java.util.Arrays.toString(dout));\n+        } else if (i-ARRLEN\/2==0) {\n+            if (dout[i] != 0)     throw new RuntimeException(\"Expected zero in the middle of array: \" + java.util.Arrays.toString(dout));\n+        } else {\n+            if (dout[i] != 1.0)   throw new RuntimeException(\"Expected positive numbers in second half of array: \" + java.util.Arrays.toString(dout));\n+        }\n+    }\n@@ -85,0 +97,1 @@\n+      Random rnd = new Random(20);\n@@ -86,1 +99,1 @@\n-          finp[i] = (float)i*1.4f;\n+          finp[i] = (i-ARRLEN\/2)*(float)rnd.nextDouble();\n@@ -91,0 +104,9 @@\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+        if (i-ARRLEN\/2<0) {\n+            if (fout[i] != -1.0)  throw new RuntimeException(\"Expected negative numbers in first half of array: \" + java.util.Arrays.toString(fout));\n+        } else if (i-ARRLEN\/2==0) {\n+            if (fout[i] != 0)     throw new RuntimeException(\"Expected zero in the middle of array: \" + java.util.Arrays.toString(fout));\n+        } else {\n+            if (fout[i] != 1.0)   throw new RuntimeException(\"Expected positive numbers in second half of array: \" + java.util.Arrays.toString(fout));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSignumVector.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Random;\n@@ -53,0 +54,2 @@\n+    private double[] d;\n+    private double[] e;\n@@ -55,0 +58,33 @@\n+        \/\/ Positive test values                       sign |   exponent | mantisa\n+        double smallPositive   = Double.longBitsToDouble(0<<63 | 0x03f << 52 | 0x30000f);\n+        double positive        = Double.longBitsToDouble(0<<63 | 0x07f << 52 | 0x30000f);\n+        double bigPositive     = Double.longBitsToDouble(0<<63 | 0x07f << 52 | 0x30100f);\n+        double biggerPositive  = Double.longBitsToDouble(0<<63 | 0x7fe << 52 | 0x30000f);\n+        double maxPositive     = Double.MAX_VALUE;\n+\n+        \/\/ Special positive\n+        double nan1  = Double.longBitsToDouble(0<<63 | 0x7ff << 52 | 0x7fffff);\n+        double nan2  = Double.longBitsToDouble(0<<63 | 0x7ff << 52 | 0x30000f);\n+        double inf   = Double.longBitsToDouble(0<<63 | 0x7ff << 52);\n+        double zero  = 0.0;\n+\n+        \/\/ Negative test values                       sign |   exponent | mantisa\n+        double smallNegative   = Double.longBitsToDouble(1<<63 | 0x003 << 52 | 0x30000f);\n+        double negative        = Double.longBitsToDouble(1<<63 | 0x783 << 52 | 0x30100f);\n+        double bigNegative     = Double.longBitsToDouble(1<<63 | 0x783 << 52 | 0x30000f);\n+        double biggerNegative  = Double.longBitsToDouble(1<<63 | 0x786 << 52 | 0x30000f);\n+        double maxNegative     = Double.longBitsToDouble(1<<63 | 0x7fe << 52 | 0x7fffff);\n+\n+        \/\/ Special negative\n+        double nNan1  = Double.longBitsToDouble(1<<63 | 0x7ff << 52 | 0x7fffff);\n+        double nNan2  = Double.longBitsToDouble(1<<63 | 0x7ff << 52 | 0x30000f);\n+        double nInf   = Double.longBitsToDouble(1<<63 | 0x7ff << 52);\n+        double nZero  = -0.0;\n+\n+        double[] numberList = new double[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf,\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        Random rnd = new Random(10);\n@@ -58,0 +94,17 @@\n+        d = new double[SIZE];\n+        e = new double[SIZE];\n+\n+        for (int i = 0; i < SIZE;) {\n+            for (int j = 0; j < numberList.length && i < SIZE; j++, i++) {\n+                for (int k = j; k < numberList.length && i < SIZE; k++, i++) {\n+                    if (rnd.nextBoolean()) {\n+                        d[i] = numberList[j];\n+                        e[i] = numberList[k];\n+                    } else {\n+                        d[i] = numberList[k];\n+                        e[i] = numberList[j];\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -182,1 +235,1 @@\n-            res[i] = Math.max(a[i], b[i]);\n+            res[i] = Math.max(d[i], e[i]);\n@@ -193,1 +246,1 @@\n-            res[i] = Math.min(a[i], b[i]);\n+            res[i] = Math.min(d[i], e[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Random;\n@@ -53,0 +54,2 @@\n+    private float[] d;\n+    private float[] e;\n@@ -55,0 +58,42 @@\n+        \/\/ Positive test values                       sign |   exponent | mantisa\n+        float smallPositive   = Float.intBitsToFloat(0<<31 | 0x3f << 23 | 0x30000f);\n+        float positive        = Float.intBitsToFloat(0<<31 | 0x7f << 23 | 0x30000f);\n+        float bigPositive     = Float.intBitsToFloat(0<<31 | 0x7f << 23 | 0x30100f);\n+        float biggerPositive  = Float.intBitsToFloat(0<<31 | 0xfe << 23 | 0x30000f);\n+        float maxPositive     = Float.MAX_VALUE;\n+\n+        \/\/ Special positive\n+        float nan1  = Float.intBitsToFloat(0<<31 | 0xff << 23 | 0x7fffff);\n+        float nan2  = Float.intBitsToFloat(0<<31 | 0xff << 23 | 0x30000f);\n+        float inf   = Float.intBitsToFloat(0<<31 | 0xff << 23);\n+        float zero  = 0.0f;\n+\n+        \/\/ Negative test values                       sign |   exponent | mantisa\n+        float smallNegative   = Float.intBitsToFloat(1<<31 | 0x03 << 23 | 0x30000f);\n+        float negative        = Float.intBitsToFloat(1<<31 | 0x83 << 23 | 0x30100f);\n+        float bigNegative     = Float.intBitsToFloat(1<<31 | 0x83 << 23 | 0x30000f);\n+        float biggerNegative  = Float.intBitsToFloat(1<<31 | 0x86 << 23 | 0x30000f);\n+        float maxNegative     = Float.intBitsToFloat(1<<31 | 0xfe << 23 | 0x7fffff);\n+\n+        \/\/ Special negative\n+        float nNan1  = Float.intBitsToFloat(1<<31 | 0xff << 23 | 0x7fffff);\n+        float nNan2  = Float.intBitsToFloat(1<<31 | 0xff << 23 | 0x30000f);\n+        float nInf   = Float.intBitsToFloat(1<<31 | 0xff << 23);\n+        float nZero  = -0.0f;\n+\n+        float[] orderedList = new float[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf\n+        };\n+\n+        float[] NaNs = new float[] {\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        float[] numberList = new float[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf,\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        Random rnd = new Random(11);\n@@ -58,0 +103,17 @@\n+        d = new float[SIZE];\n+        e = new float[SIZE];\n+\n+        for (int i = 0; i < SIZE;) {\n+            for (int j = 0; j < numberList.length && i < SIZE; j++, i++) {\n+                for (int k = j; k < numberList.length && i < SIZE; k++, i++) {\n+                    if (rnd.nextBoolean()) {\n+                        d[i] = numberList[j];\n+                        e[i] = numberList[k];\n+                    } else {\n+                        d[i] = numberList[k];\n+                        e[i] = numberList[j];\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -149,1 +211,1 @@\n-            res[i] = Math.max(a[i], b[i]);\n+            res[i] = Math.max(d[i], e[i]);\n@@ -160,1 +222,1 @@\n-            res[i] = Math.min(a[i], b[i]);\n+            res[i] = Math.min(d[i], e[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"}]}