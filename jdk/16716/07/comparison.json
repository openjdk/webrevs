{"files":[{"patch":"@@ -1097,0 +1097,24 @@\n+  \/* Note on 'non-obvious' assembly sequence:\n+   *\n+   * While there are vminps\/vmaxps instructions, there are two important differences between hardware\n+   * and Java on how they handle floats:\n+   *  a. -0.0 and +0.0 are considered equal (vminps\/vmaxps will return second parameter when inputs are equal)\n+   *  b. NaN is not necesarily propagated (vminps\/vmaxps will return second parameter when either input is NaN)\n+   *\n+   * It is still more efficient to use vminps\/vmaxps, but with some pre\/post-processing:\n+   *  a. -0.0\/+0.0: Bias negative (positive) numbers to second parameter before vminps (vmaxps)\n+   *                (only useful when signs differ, noop otherwise)\n+   *  b. NaN: Check if it was the first parameter that had the NaN (with vcmp[UNORD_Q])\n+\n+   *  Following pseudo code describes the algorithm for max[FD] (Min algorithm is on similar lines):\n+   *   btmp = (b < +0.0) ? a : b\n+   *   atmp = (b < +0.0) ? b : a\n+   *   Tmp  = Max_Float(atmp , btmp)\n+   *   Res  = (atmp == NaN) ? atmp : Tmp\n+   *\/\n+\n+  void (MacroAssembler::*vblend)(XMMRegister, XMMRegister, XMMRegister, XMMRegister, int, bool, XMMRegister);\n+  void (MacroAssembler::*vmaxmin)(XMMRegister, XMMRegister, XMMRegister, int);\n+  void (MacroAssembler::*vcmp)(XMMRegister, XMMRegister, XMMRegister, int, int);\n+  XMMRegister mask;\n+\n@@ -1098,5 +1122,4 @@\n-    vblendvps(atmp, a, b, a, vlen_enc);\n-    vblendvps(btmp, b, a, a, vlen_enc);\n-    vminps(tmp, atmp, btmp, vlen_enc);\n-    vcmpps(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = a;\n+    vblend = &MacroAssembler::vblendvps;\n+    vmaxmin = &MacroAssembler::vminps;\n+    vcmp = &MacroAssembler::vcmpps;\n@@ -1104,5 +1127,4 @@\n-    vblendvps(btmp, b, a, b, vlen_enc);\n-    vblendvps(atmp, a, b, b, vlen_enc);\n-    vmaxps(tmp, atmp, btmp, vlen_enc);\n-    vcmpps(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvps(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = b;\n+    vblend = &MacroAssembler::vblendvps;\n+    vmaxmin = &MacroAssembler::vmaxps;\n+    vcmp = &MacroAssembler::vcmpps;\n@@ -1110,5 +1132,4 @@\n-    vblendvpd(atmp, a, b, a, vlen_enc);\n-    vblendvpd(btmp, b, a, a, vlen_enc);\n-    vminpd(tmp, atmp, btmp, vlen_enc);\n-    vcmppd(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = a;\n+    vblend = &MacroAssembler::vblendvpd;\n+    vmaxmin = &MacroAssembler::vminpd;\n+    vcmp = &MacroAssembler::vcmppd;\n@@ -1117,5 +1138,4 @@\n-    vblendvpd(btmp, b, a, b, vlen_enc);\n-    vblendvpd(atmp, a, b, b, vlen_enc);\n-    vmaxpd(tmp, atmp, btmp, vlen_enc);\n-    vcmppd(btmp, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n-    vblendvpd(dst, tmp, atmp, btmp, vlen_enc);\n+    mask = b;\n+    vblend = &MacroAssembler::vblendvpd;\n+    vmaxmin = &MacroAssembler::vmaxpd;\n+    vcmp = &MacroAssembler::vcmppd;\n@@ -1123,0 +1143,26 @@\n+\n+  \/\/ Make sure EnableX86ECoreOpts isn't disabled on register overlaps\n+  XMMRegister maxmin, scratch;\n+  if (dst == btmp) {\n+    maxmin = btmp;\n+    scratch = tmp;\n+  } else {\n+    maxmin = tmp;\n+    scratch = btmp;\n+  }\n+\n+  bool precompute_mask = EnableX86ECoreOpts && UseAVX>1;\n+  if (precompute_mask && !is_double_word) {\n+    vpsrad(tmp, mask, 32, vlen_enc);\n+    mask = tmp;\n+  } else if (precompute_mask && is_double_word) {\n+    vpxor(tmp, tmp, tmp, vlen_enc);\n+    vpcmpgtq(tmp, tmp, mask, vlen_enc);\n+    mask = tmp;\n+  }\n+\n+  (this->*vblend)(atmp, a, b, mask, vlen_enc, !precompute_mask, btmp);\n+  (this->*vblend)(btmp, b, a, mask, vlen_enc, !precompute_mask, tmp);\n+  (this->*vmaxmin)(maxmin, atmp, btmp, vlen_enc);\n+  (this->*vcmp)(scratch, atmp, atmp, Assembler::UNORD_Q, vlen_enc);\n+  (this->*vblend)(dst, maxmin, atmp, scratch, vlen_enc, false, scratch);\n@@ -5321,1 +5367,1 @@\n-    vblendvpd(dst, one, dst, src, vec_enc);\n+    vblendvpd(dst, one, dst, src, vec_enc, true, xtmp1);\n@@ -5324,1 +5370,1 @@\n-    vblendvpd(dst, dst, src, xtmp1, vec_enc);\n+    vblendvpd(dst, dst, src, xtmp1, vec_enc, false, xtmp1);\n@@ -5329,1 +5375,1 @@\n-    vblendvps(dst, one, dst, src, vec_enc);\n+    vblendvps(dst, one, dst, src, vec_enc, true, xtmp1);\n@@ -5332,1 +5378,1 @@\n-    vblendvps(dst, dst, src, xtmp1, vec_enc);\n+    vblendvps(dst, dst, src, xtmp1, vec_enc, false, xtmp1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":70,"deletions":24,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -3569,0 +3569,50 @@\n+\/\/ Vector float blend\n+\/\/ vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvps(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool compute_mask, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst;\n+  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n+  if (blend_emulation && scratch_available && dst_available) {\n+    if (compute_mask) {\n+      vpsrad(scratch, mask, 32, vector_len);\n+      mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     mask, src1, vector_len); \/\/ if mask == 0, src1\n+      vpand (scratch, mask, src2, vector_len); \/\/ if mask == 1, src2\n+    } else {\n+      vpand (dst,     mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, mask, src1, vector_len); \/\/ if mask == 0, src1\n+    }\n+    vpor(dst, dst, scratch, vector_len);\n+  } else {\n+    Assembler::vblendvps(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n+\/\/ vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg)\n+void MacroAssembler::vblendvpd(XMMRegister dst, XMMRegister src1, XMMRegister src2, XMMRegister mask, int vector_len, bool compute_mask, XMMRegister scratch) {\n+  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n+  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst && (!compute_mask || scratch != mask);\n+  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n+  if (blend_emulation && scratch_available && dst_available) {\n+    if (compute_mask) {\n+      vpxor(scratch, scratch, scratch, vector_len);\n+      vpcmpgtq(scratch, scratch, mask, vector_len);\n+      mask = scratch;\n+    }\n+    if (dst == src1) {\n+      vpandn(dst,     mask, src1, vector_len); \/\/ if mask == 0, src\n+      vpand (scratch, mask, src2, vector_len); \/\/ if mask == 1, src2\n+    } else {\n+      vpand (dst,     mask, src2, vector_len); \/\/ if mask == 1, src2\n+      vpandn(scratch, mask, src1, vector_len); \/\/ if mask == 0, src\n+    }\n+    vpor(dst, dst, scratch, vector_len);\n+  } else {\n+    Assembler::vblendvpd(dst, src1, src2, mask, vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1132,0 +1132,4 @@\n+  \/\/ Vector float blend\n+  void vblendvps(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg);\n+  void vblendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src, XMMRegister mask, int vector_len, bool compute_mask = true, XMMRegister scratch = xnoreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7807,1 +7807,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7821,1 +7821,1 @@\n-  predicate(UseAVX > 0 &&\n+  predicate(UseAVX > 0 && !EnableX86ECoreOpts &&\n@@ -7832,0 +7832,16 @@\n+%}\n+\n+instruct vblendvp(legVec dst, legVec src1, legVec src2, legVec mask, legVec vtmp) %{\n+  predicate(UseAVX > 0 && EnableX86ECoreOpts &&\n+            n->in(2)->bottom_type()->isa_vectmask() == NULL &&\n+            Matcher::vector_length_in_bytes(n) <= 32);\n+  match(Set dst (VectorBlend (Binary src1 src2) mask));\n+  format %{ \"vector_blend  $dst,$src1,$src2,$mask\\t! using $vtmp as TEMP\" %}\n+  effect(TEMP vtmp, TEMP dst);\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpandn($vtmp$$XMMRegister, $mask$$XMMRegister, $src1$$XMMRegister, vlen_enc);\n+    __ vpand ($dst$$XMMRegister,  $mask$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+    __ vpor  ($dst$$XMMRegister,  $dst$$XMMRegister,  $vtmp$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4481,8 +4481,0 @@\n-\n-\/\/ Following pseudo code describes the algorithm for max[FD]:\n-\/\/ Min algorithm is on similar lines\n-\/\/  btmp = (b < +0.0) ? a : b\n-\/\/  atmp = (b < +0.0) ? b : a\n-\/\/  Tmp  = Max_Float(atmp , btmp)\n-\/\/  Res  = (atmp == NaN) ? atmp : Tmp\n-\n@@ -4494,7 +4486,1 @@\n-  format %{\n-     \"vblendvps        $btmp,$b,$a,$b           \\n\\t\"\n-     \"vblendvps        $atmp,$a,$b,$b           \\n\\t\"\n-     \"vmaxss           $tmp,$atmp,$btmp         \\n\\t\"\n-     \"vcmpps.unordered $btmp,$atmp,$atmp        \\n\\t\"\n-     \"vblendvps        $dst,$tmp,$atmp,$btmp    \\n\\t\"\n-  %}\n+  format %{ \"maxF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4502,7 +4488,2 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n- %}\n+    __ vminmax_fp(Op_MaxV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n+  %}\n@@ -4530,7 +4511,1 @@\n-  format %{\n-     \"vblendvpd        $btmp,$b,$a,$b            \\n\\t\"\n-     \"vblendvpd        $atmp,$a,$b,$b            \\n\\t\"\n-     \"vmaxsd           $tmp,$atmp,$btmp          \\n\\t\"\n-     \"vcmppd.unordered $btmp,$atmp,$atmp         \\n\\t\"\n-     \"vblendvpd        $dst,$tmp,$atmp,$btmp     \\n\\t\"\n-  %}\n+  format %{ \"maxD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4538,6 +4513,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);\n-    __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MaxV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -4566,7 +4536,1 @@\n-  format %{\n-     \"vblendvps        $atmp,$a,$b,$a             \\n\\t\"\n-     \"vblendvps        $btmp,$b,$a,$a             \\n\\t\"\n-     \"vminss           $tmp,$atmp,$btmp           \\n\\t\"\n-     \"vcmpps.unordered $btmp,$atmp,$atmp          \\n\\t\"\n-     \"vblendvps        $dst,$tmp,$atmp,$btmp      \\n\\t\"\n-  %}\n+  format %{ \"minF $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4574,6 +4538,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MinV, T_FLOAT, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n@@ -4602,7 +4561,1 @@\n-  format %{\n-     \"vblendvpd        $atmp,$a,$b,$a           \\n\\t\"\n-     \"vblendvpd        $btmp,$b,$a,$a           \\n\\t\"\n-     \"vminsd           $tmp,$atmp,$btmp         \\n\\t\"\n-     \"vcmppd.unordered $btmp,$atmp,$atmp        \\n\\t\"\n-     \"vblendvpd        $dst,$tmp,$atmp,$btmp    \\n\\t\"\n-  %}\n+    format %{ \"minD $dst, $a, $b \\t! using tmp, atmp and btmp as TEMP\" %}\n@@ -4610,6 +4563,1 @@\n-    int vector_len = Assembler::AVX_128bit;\n-    __ vblendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vblendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);\n-    __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);\n-    __ vcmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);\n-    __ vblendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);\n+    __ vminmax_fp(Op_MinV, T_DOUBLE, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, Assembler::AVX_128bit);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":9,"deletions":61,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Random;\n+\n@@ -65,0 +67,1 @@\n+      Random rnd = new Random(20);\n@@ -66,1 +69,1 @@\n-          dinp[i] = (double)i*1.4;\n+          dinp[i] = (i-ARRLEN\/2)*rnd.nextDouble();\n@@ -71,0 +74,9 @@\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+        if (i-ARRLEN\/2<0) {\n+            if (dout[i] != -1.0)  throw new RuntimeException(\"Expected negative numbers in first half of array: \" + java.util.Arrays.toString(dout));\n+        } else if (i-ARRLEN\/2==0) {\n+            if (dout[i] != 0)     throw new RuntimeException(\"Expected zero in the middle of array: \" + java.util.Arrays.toString(dout));\n+        } else {\n+            if (dout[i] != 1.0)   throw new RuntimeException(\"Expected positive numbers in second half of array: \" + java.util.Arrays.toString(dout));\n+        }\n+    }\n@@ -85,0 +97,1 @@\n+      Random rnd = new Random(20);\n@@ -86,1 +99,1 @@\n-          finp[i] = (float)i*1.4f;\n+          finp[i] = (i-ARRLEN\/2)*rnd.nextFloat();\n@@ -91,0 +104,9 @@\n+      for(int i = 0 ; i < ARRLEN; i++) {\n+        if (i-ARRLEN\/2<0) {\n+            if (fout[i] != -1.0)  throw new RuntimeException(\"Expected negative numbers in first half of array: \" + java.util.Arrays.toString(fout));\n+        } else if (i-ARRLEN\/2==0) {\n+            if (fout[i] != 0)     throw new RuntimeException(\"Expected zero in the middle of array: \" + java.util.Arrays.toString(fout));\n+        } else {\n+            if (fout[i] != 1.0)   throw new RuntimeException(\"Expected positive numbers in second half of array: \" + java.util.Arrays.toString(fout));\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSignumVector.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Random;\n@@ -53,0 +54,2 @@\n+    private double[] d;\n+    private double[] e;\n@@ -55,0 +58,33 @@\n+        \/\/ Positive test values                       sign |   exponent | mantisa\n+        double smallPositive   = Double.longBitsToDouble(0<<63 | 0x03f << 52 | 0x30000f);\n+        double positive        = Double.longBitsToDouble(0<<63 | 0x07f << 52 | 0x30000f);\n+        double bigPositive     = Double.longBitsToDouble(0<<63 | 0x07f << 52 | 0x30100f);\n+        double biggerPositive  = Double.longBitsToDouble(0<<63 | 0x7fe << 52 | 0x30000f);\n+        double maxPositive     = Double.MAX_VALUE;\n+\n+        \/\/ Special positive\n+        double nan1  = Double.longBitsToDouble(0<<63 | 0x7ff << 52 | 0x7fffff);\n+        double nan2  = Double.longBitsToDouble(0<<63 | 0x7ff << 52 | 0x30000f);\n+        double inf   = Double.longBitsToDouble(0<<63 | 0x7ff << 52);\n+        double zero  = 0.0;\n+\n+        \/\/ Negative test values                       sign |   exponent | mantisa\n+        double smallNegative   = Double.longBitsToDouble(1<<63 | 0x003 << 52 | 0x30000f);\n+        double negative        = Double.longBitsToDouble(1<<63 | 0x783 << 52 | 0x30100f);\n+        double bigNegative     = Double.longBitsToDouble(1<<63 | 0x783 << 52 | 0x30000f);\n+        double biggerNegative  = Double.longBitsToDouble(1<<63 | 0x786 << 52 | 0x30000f);\n+        double maxNegative     = Double.longBitsToDouble(1<<63 | 0x7fe << 52 | 0x7fffff);\n+\n+        \/\/ Special negative\n+        double nNan1  = Double.longBitsToDouble(1<<63 | 0x7ff << 52 | 0x7fffff);\n+        double nNan2  = Double.longBitsToDouble(1<<63 | 0x7ff << 52 | 0x30000f);\n+        double nInf   = Double.longBitsToDouble(1<<63 | 0x7ff << 52);\n+        double nZero  = -0.0;\n+\n+        double[] numberList = new double[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf,\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        Random rnd = new Random(10);\n@@ -58,0 +94,17 @@\n+        d = new double[SIZE];\n+        e = new double[SIZE];\n+\n+        for (int i = 0; i < SIZE;) {\n+            for (int j = 0; j < numberList.length && i < SIZE; j++, i++) {\n+                for (int k = j; k < numberList.length && i < SIZE; k++, i++) {\n+                    if (rnd.nextBoolean()) {\n+                        d[i] = numberList[j];\n+                        e[i] = numberList[k];\n+                    } else {\n+                        d[i] = numberList[k];\n+                        e[i] = numberList[j];\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -182,1 +235,1 @@\n-            res[i] = Math.max(a[i], b[i]);\n+            res[i] = Math.max(d[i], e[i]);\n@@ -193,1 +246,1 @@\n-            res[i] = Math.min(a[i], b[i]);\n+            res[i] = Math.min(d[i], e[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicDoubleOpTest.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.Random;\n@@ -53,0 +54,2 @@\n+    private float[] d;\n+    private float[] e;\n@@ -55,0 +58,42 @@\n+        \/\/ Positive test values                       sign |   exponent | mantisa\n+        float smallPositive   = Float.intBitsToFloat(0<<31 | 0x3f << 23 | 0x30000f);\n+        float positive        = Float.intBitsToFloat(0<<31 | 0x7f << 23 | 0x30000f);\n+        float bigPositive     = Float.intBitsToFloat(0<<31 | 0x7f << 23 | 0x30100f);\n+        float biggerPositive  = Float.intBitsToFloat(0<<31 | 0xfe << 23 | 0x30000f);\n+        float maxPositive     = Float.MAX_VALUE;\n+\n+        \/\/ Special positive\n+        float nan1  = Float.intBitsToFloat(0<<31 | 0xff << 23 | 0x7fffff);\n+        float nan2  = Float.intBitsToFloat(0<<31 | 0xff << 23 | 0x30000f);\n+        float inf   = Float.intBitsToFloat(0<<31 | 0xff << 23);\n+        float zero  = 0.0f;\n+\n+        \/\/ Negative test values                       sign |   exponent | mantisa\n+        float smallNegative   = Float.intBitsToFloat(1<<31 | 0x03 << 23 | 0x30000f);\n+        float negative        = Float.intBitsToFloat(1<<31 | 0x83 << 23 | 0x30100f);\n+        float bigNegative     = Float.intBitsToFloat(1<<31 | 0x83 << 23 | 0x30000f);\n+        float biggerNegative  = Float.intBitsToFloat(1<<31 | 0x86 << 23 | 0x30000f);\n+        float maxNegative     = Float.intBitsToFloat(1<<31 | 0xfe << 23 | 0x7fffff);\n+\n+        \/\/ Special negative\n+        float nNan1  = Float.intBitsToFloat(1<<31 | 0xff << 23 | 0x7fffff);\n+        float nNan2  = Float.intBitsToFloat(1<<31 | 0xff << 23 | 0x30000f);\n+        float nInf   = Float.intBitsToFloat(1<<31 | 0xff << 23);\n+        float nZero  = -0.0f;\n+\n+        float[] orderedList = new float[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf\n+        };\n+\n+        float[] NaNs = new float[] {\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        float[] numberList = new float[] {\n+            nInf, maxNegative, biggerNegative, bigNegative, negative, smallNegative, nZero,\n+            zero, smallPositive, positive, bigPositive, biggerPositive, maxPositive, inf,\n+            nan1, nan2, nNan1, nNan2\n+        };\n+\n+        Random rnd = new Random(11);\n@@ -58,0 +103,17 @@\n+        d = new float[SIZE];\n+        e = new float[SIZE];\n+\n+        for (int i = 0; i < SIZE;) {\n+            for (int j = 0; j < numberList.length && i < SIZE; j++, i++) {\n+                for (int k = j; k < numberList.length && i < SIZE; k++, i++) {\n+                    if (rnd.nextBoolean()) {\n+                        d[i] = numberList[j];\n+                        e[i] = numberList[k];\n+                    } else {\n+                        d[i] = numberList[k];\n+                        e[i] = numberList[j];\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -149,1 +211,1 @@\n-            res[i] = Math.max(a[i], b[i]);\n+            res[i] = Math.max(d[i], e[i]);\n@@ -160,1 +222,1 @@\n-            res[i] = Math.min(a[i], b[i]);\n+            res[i] = Math.min(d[i], e[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicFloatOpTest.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"}]}