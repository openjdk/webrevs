{"files":[{"patch":"@@ -338,5 +338,5 @@\n-        kdfOutput = new byte[rounds * hmacLen];\n-\n-        for (int i = 0, offset = 0; i < rounds; i++, offset += hmacLen) {\n-            \/\/ Calculate this round\n-            try {\n+        kdfOutput = new byte[outLen];\n+        int i = 0;\n+        int offset = 0;\n+        try {\n+            while (i < rounds) {\n@@ -344,2 +344,13 @@\n-                    hmacObj.update(kdfOutput, Math.max(0, offset - hmacLen),\n-                                   hmacLen); \/\/ add T(i-1)\n+                    hmacObj.update(kdfOutput, Math.max(0,offset - hmacLen), hmacLen); \/\/ add T(i-1)\n+                }\n+                hmacObj.update(info);                   \/\/ Add info\n+                hmacObj.update((byte) ++i);             \/\/ Add round number\n+                if (i == rounds && (outLen - offset < hmacLen)) {\n+                    \/\/ special handling for last chunk\n+                    byte[] tmp = hmacObj.doFinal();\n+                    System.arraycopy(tmp, 0, kdfOutput, offset,\n+                                     outLen - offset);\n+                    offset = outLen;\n+                } else {\n+                    hmacObj.doFinal(kdfOutput, offset);\n+                    offset += hmacLen;\n@@ -347,8 +358,0 @@\n-                hmacObj.update(info); \/\/ Add info\n-                hmacObj.update((byte) (i + 1)); \/\/ Add round number\n-                hmacObj.doFinal(kdfOutput, offset);\n-            } catch (ShortBufferException sbe) {\n-                \/\/ This really shouldn't happen given that we've\n-                \/\/ sized the buffers to their largest possible size up-front,\n-                \/\/ but just in case...\n-                throw new RuntimeException(sbe);\n@@ -356,0 +359,5 @@\n+        } catch (ShortBufferException sbe) {\n+            \/\/ This really shouldn't happen given that we've\n+            \/\/ sized the buffers to their largest possible size up-front,\n+            \/\/ but just in case...\n+            throw new ProviderException(sbe);\n@@ -357,2 +365,1 @@\n-\n-        return Arrays.copyOf(kdfOutput, outLen);\n+        return kdfOutput;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -89,7 +89,7 @@\n- * {@code deriveData} method. However, if {@code getProviderName} or\n- * {@code getParameters} is called before calling the {@code deriveKey} or\n- * {@code deriveData} methods, the first provider supporting the KDF algorithm\n- * and {@code KDFParameters} is chosen, which may not be the provider that is\n- * eventually selected once the {@code AlgorithmParameterSpec} is supplied in\n- * the derive methods. Therefore, it is recommended not to call\n- * {@code getProviderName} or {@code getKDFParameters} until after a key\n+ * {@code deriveData} method. If the {@code getProviderName} or {@code\n+ * getParameters} method is called before the {@code deriveKey} or {@code\n+ * deriveData} methods, the first provider supporting the KDF algorithm and\n+ * optional {@code KDFParameters} is chosen. This provider may not support\n+ * the key material that is subsequently passed to the deriveKey or\n+ * deriveData methods. Therefore, it is recommended not to call the {@code\n+ * getProviderName} or {@code getParameters} methods until after a key\n@@ -98,1 +98,0 @@\n- *\n@@ -350,5 +349,9 @@\n-                            \"newInstance failed to provide a KDFSpi for the \"\n-                            + \"provided kdfParameters\"));\n-                    continue;\n-                }\n-                if (t.hasNext()) {\n+                            \"No provider can be found that supports the \"\n+                            + \"specified parameters\"));\n+                    if (!skipDebug && pdebug != null) {\n+                        pdebug.println(\n+                            \"obj was not an instance of KDFSpi (should not \"\n+                            + \"happen)\");\n+                    }\n+                    \/\/ continue to next iteration\n+                } else if (t.hasNext()) {\n@@ -365,3 +368,6 @@\n-                            \"newInstance failed for the provided \"\n-                            + \"kdfParameters\"));\n-                continue;\n+                            \"No provider can be found that supports the \"\n+                            + \"specified parameters\"));\n+                if (!skipDebug && pdebug != null) {\n+                    pdebug.println(e.toString());\n+                }\n+                \/\/ continue to next iteration\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -31,0 +32,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -54,9 +57,10 @@\n-        if (!Arrays.equals(prk.getEncoded(), expectedPrk)) {\n-            throw new Exception(\"the PRK does not match the expected value\");\n-        }\n-        if (!Arrays.equals(okm1.getEncoded(), expectedOkm)) {\n-            throw new Exception(\"the OKM does not match the expected value (expand)\");\n-        }\n-        if (!Arrays.equals(okm2.getEncoded(), expectedOkm)) {\n-            throw new Exception(\"the OKM does not match the expected value (extract expand)\");\n-        }\n+        Asserts.assertEqualsByteArray(prk.getEncoded(), expectedPrk,\n+                                      \"the PRK must match the expected value\");\n+\n+        Asserts.assertEqualsByteArray(okm1.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(expand)\");\n+\n+        Asserts.assertEqualsByteArray(okm2.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(extract expand)\");\n@@ -68,0 +72,2 @@\n+        \/\/ test expand with null info\n+        test(HKDFParameterSpec.ofExtract().thenExpand(null, 32));\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/BasicHKDFFunctions.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}