{"files":[{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/**\n+ * KDF implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC\n+ * 5869.  This implementation provides the complete Extract-then-Expand HKDF\n+ * function as well as Extract-only and Expand-only variants.\n+ *\/\n+abstract class HkdfKeyDerivation extends KDFSpi {\n+\n+    protected final int hmacLen;\n+    protected final String hmacAlgName;\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param kdfParameters\n+     *     the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    HkdfKeyDerivation(String hmacAlgName, int hmacLen,\n+                      KDFParameters kdfParameters)\n+        throws InvalidAlgorithmParameterException {\n+        super(kdfParameters);\n+        if (kdfParameters != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                \"RFC 5869 has no parameters for its KDF algorithms\");\n+        }\n+        this.hmacAlgName = hmacAlgName;\n+        this.hmacLen = hmacLen;\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey}.\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived, or specifies\n+     *     a type of output that is not a key (e.g. raw data)\n+     * @throws IllegalArgumentException\n+     *     if {@code alg} is {@code null} or empty\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg,\n+                                        AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+\n+        if (alg == null || alg.isEmpty()) {\n+            throw new IllegalArgumentException(\n+                \"the algorithm for the resultant SecretKey may not be null or\"\n+                + \" empty\");\n+        }\n+\n+        return new SecretKeySpec(engineDeriveData(kdfParameterSpec), alg);\n+\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+        List<SecretKey> ikms;\n+        List<SecretKey> salts;\n+        SecretKey inputKeyMaterial;\n+        SecretKey salt;\n+        SecretKey pseudoRandomKey;\n+        byte[] info;\n+        int length;\n+        \/\/ A switch would be nicer, but we may need to backport this before\n+        \/\/ JDK 17\n+        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable\n+        \/\/ in instanceof either\n+        if (kdfParameterSpec instanceof HKDFParameterSpec.Extract) {\n+            HKDFParameterSpec.Extract anExtract =\n+                (HKDFParameterSpec.Extract) kdfParameterSpec;\n+            ikms = anExtract.ikms();\n+            salts = anExtract.salts();\n+            \/\/ we should be able to combine these Lists of keys into single\n+            \/\/ SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"Issue encountered when combining ikm or salt values into\"\n+                    + \" single keys\").initCause(ike);\n+            }\n+            \/\/ perform extract\n+            try {\n+                return hkdfExtract(inputKeyMaterial,\n+                                   (salt == null) ? null : salt.getEncoded());\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"an HKDF Extract could not be initialized with the given \"\n+                    + \"key or salt material\").initCause(ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.Expand) {\n+            HKDFParameterSpec.Expand anExpand =\n+                (HKDFParameterSpec.Expand) kdfParameterSpec;\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk()) == null) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Requested length exceeds maximum allowed key stream \"\n+                    + \"length\");\n+            }\n+            \/\/ perform expand\n+            try {\n+                return Arrays.copyOf(hkdfExpand(pseudoRandomKey, info, length),\n+                                     length);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"an HKDF Expand could not be initialized with the given \"\n+                    + \"key material\").initCause(ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        } else if (kdfParameterSpec instanceof HKDFParameterSpec.ExtractThenExpand) {\n+            HKDFParameterSpec.ExtractThenExpand anExtractThenExpand =\n+                (HKDFParameterSpec.ExtractThenExpand) kdfParameterSpec;\n+            ikms = anExtractThenExpand.ikms();\n+            salts = anExtractThenExpand.salts();\n+            \/\/ we should be able to combine these Lists of keys into single\n+            \/\/ SecretKey Objects,\n+            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"Issue encountered when combining ikm or salt values into\"\n+                    + \" single keys\").initCause(ike);\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExtractThenExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExtractThenExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Requested length exceeds maximum allowed key stream \"\n+                    + \"length\");\n+            }\n+            \/\/ perform extract and then expand\n+            try {\n+                byte[] extractResult = hkdfExtract(inputKeyMaterial, (salt\n+                                                                      == null) ? null : salt.getEncoded());\n+                pseudoRandomKey = new SecretKeySpec(extractResult, \"RAW\");\n+                return Arrays.copyOf(hkdfExpand(pseudoRandomKey, info, length),\n+                                     length);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"an HKDF ExtractThenExpand could not be initialized with \"\n+                    + \"the given key or salt material\").initCause(ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"an HKDF could not be initialized with the given KDFParameterSpec\");\n+    }\n+\n+    private static boolean isNullOrEmpty(Collection<?> c) {\n+        return c == null || c.isEmpty();\n+    }\n+\n+    private SecretKey consolidateKeyMaterial(List<SecretKey> keys)\n+        throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                SecretKey checkIt = localKeys.get(0);\n+                byte[] workItemBytes = CipherCore.getKeyBytes(checkIt);\n+                return new SecretKeySpec(workItemBytes, \"Generic\");\n+            } else {\n+                byte[] bb = new byte[0];\n+                for (SecretKey workItem : localKeys) {\n+                    byte[] workItemBytes = CipherCore.getKeyBytes(workItem);\n+\n+                    bb = Arrays.copyOf(bb, bb.length + workItemBytes.length);\n+                    System.arraycopy(workItemBytes, 0, bb,\n+                                     bb.length - workItemBytes.length,\n+                                     workItemBytes.length);\n+                }\n+                return new SecretKeySpec(bb, \"Generic\");\n+            }\n+        } else if (keys.isEmpty()) {\n+            return null;\n+        } else {\n+            throw new InvalidKeyException(\n+                \"List of keys could not be consolidated\");\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Extract operation.\n+     *\n+     * @param inputKey\n+     *     the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *     the salt value used for HKDF-Extract.  If no salt is to be used a\n+     *     {@code null} value should be provided.\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid salt was provided through the\n+     *     {@code HkdfParameterSpec}\n+     *\/\n+    protected byte[] hkdfExtract(SecretKey inputKey, byte[] salt)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+\n+        if (salt == null) {\n+            salt = new byte[hmacLen];\n+        }\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+        hmacObj.init(new SecretKeySpec(salt, \"HKDF-Salt\"));\n+\n+        if (inputKey == null) {\n+            return hmacObj.doFinal();\n+        } else {\n+            return hmacObj.doFinal(inputKey.getEncoded());\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HMAC-Expand operation.  At the end of the operation, the\n+     * keyStream instance variable will contain the complete KDF output based on\n+     * the input values and desired length.\n+     *\n+     * @param prk\n+     *     the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *     optional context and application specific information or {@code null}\n+     *     if no info data is provided.\n+     * @param outLen\n+     *     the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete KDF output.  This will be at\n+     *     least as long as the requested length in the {@code outLen}\n+     *     parameter, but will be rounded up to the nearest multiple of the HMAC\n+     *     output length.\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid key was provided through the {@code HkdfParameterSpec}\n+     *     or derived during the generation of the PRK.\n+     *\/\n+    protected byte[] hkdfExpand(SecretKey prk, byte[] info, int outLen)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+        byte[] kdfOutput;\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        hmacObj.init(prk);\n+        if (info == null) {\n+            info = new byte[0];\n+        }\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[rounds * hmacLen];\n+        int offset = 0;\n+        int tLength = 0;\n+\n+        for (int i = 0; i < rounds; i++) {\n+\n+            \/\/ Calculate this round\n+            try {\n+                \/\/ Add T(i).  This will be an empty string on the first\n+                \/\/ iteration since tLength starts at zero.  After the first\n+                \/\/ iteration, tLength is changed to the HMAC length for the\n+                \/\/ rest of the loop.\n+                hmacObj.update(kdfOutput, Math.max(0, offset - hmacLen),\n+                               tLength);\n+                hmacObj.update(info);                       \/\/ Add info\n+                hmacObj.update((byte) (i + 1));              \/\/ Add round number\n+                hmacObj.doFinal(kdfOutput, offset);\n+\n+                tLength = hmacLen;\n+                offset += hmacLen;                       \/\/ For next iteration\n+            } catch (ShortBufferException sbe) {\n+                \/\/ This really shouldn't happen given that we've\n+                \/\/ sized the buffers to their largest possible size up-front,\n+                \/\/ but just in case...\n+                throw new RuntimeException(sbe);\n+            }\n+        }\n+\n+        return kdfOutput;\n+    }\n+\n+    public static final class HkdfSHA256 extends HkdfKeyDerivation {\n+        public HkdfSHA256(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA256\", 32, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HkdfSHA384 extends HkdfKeyDerivation {\n+        public HkdfSHA384(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA384\", 48, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HkdfSHA512 extends HkdfKeyDerivation {\n+        public HkdfSHA512(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA512\", 64, kdfParameters);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -460,0 +460,10 @@\n+        \/*\n+         * Key Derivation engines\n+         *\/\n+        ps(\"KDF\", \"HKDFWithHmacSHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA256\");\n+        ps(\"KDF\", \"HKDFWithHmacSHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA384\");\n+        ps(\"KDF\", \"HKDFWithHmacSHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA512\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A specification of {@code KDF} parameters.\n+ * <p>\n+ * The purpose of this interface is to group (and provide type safety for) all\n+ * {@code KDF} parameter specifications. All {@code KDF} parameter\n+ * specifications must implement this interface.\n+ * <p>\n+ * Typically, a {@code KDFParameters} object is passed as a parameter to one of\n+ * the\n+ * {@link javax.crypto.KDF#getInstance(String, KDFParameters) KDF.getInstance}\n+ * methods. The {@code getInstance} method returns a {@code KDF}. The\n+ * {@code KDF} that is returned is initialized with the specified parameters.\n+ *\n+ * @see javax.crypto.KDF#getInstance(String, KDFParameters)\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface KDFParameters {}\n","filename":"src\/java.base\/share\/classes\/java\/security\/KDFParameters.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1607,0 +1607,2 @@\n+        addEngine(\"KDF\",                                false,\n+                            java.security.KDFParameters.class);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,611 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.GetInstance.Instance;\n+import sun.security.util.Debug;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Provider.Service;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Derivation Function (KDF),\n+ * which is a cryptographic algorithm for deriving additional keys from a secret\n+ * key and other data.\n+ * <p>\n+ * {@code KDF} objects are instantiated with the {@code getInstance} family of\n+ * methods. KDF algorithm names follow a naming convention of\n+ * <em>Algorithm<\/em>With<em>PRF<\/em>. For instance, a KDF implementation of\n+ * HKDF using HMAC-SHA256 has an algorithm name of \"HKDFWithHmacSHA256\". In some\n+ * cases the PRF portion of the algorithm field may be omitted if the KDF\n+ * algorithm has a fixed or default PRF.\n+ * <p>\n+ * If a provider is not specified in the {@code getInstance} method when\n+ * instantiating a {@code KDF} object, the provider is selected the first time\n+ * the {@code deriveKey} or {@code deriveData} method is called and a provider\n+ * is chosen that supports the parameters passed to the {@code deriveKey} or\n+ * {@code deriveData} method, for example the initial key material. However, if\n+ * {@code getProviderName} is called before calling the {@code deriveKey} or\n+ * {@code deriveData} methods, the first provider supporting the KDF algorithm\n+ * is chosen which may not be the desired one; therefore it is recommended not\n+ * to call {@code getProviderName} until after a key derivation operation. Once\n+ * a provider is selected, it cannot be changed.\n+ * <p>\n+ * API Usage Example:\n+ * {@snippet lang = java:\n+ *    KDF kdfHkdf = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+ *\n+ *    AlgorithmParameterSpec kdfParameterSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 42);\n+ *\n+ *    kdfHkdf.deriveKey(\"AES\", kdfParameterSpec);\n+ *}\n+ *\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public final class KDF {\n+    private static final Debug debug = Debug.getInstance(\"jca\", \"KDF\");\n+\n+    private static final Debug pdebug = Debug.getInstance(\"provider\",\n+                                                          \"Provider\");\n+    private static final boolean skipDebug = Debug.isOn(\"engine=\")\n+                                             && !Debug.isOn(\"kdf\");\n+\n+    \/\/ The provider\n+    private Provider provider;\n+\n+    \/\/ The provider implementation (delegate)\n+    private KDFSpi spi;\n+\n+    \/\/ The name of the KDF algorithm.\n+    private final String algorithm;\n+\n+    \/\/ Additional KDF configuration parameters\n+    private final KDFParameters kdfParameters;\n+\n+    \/\/ next service to try in provider selection\n+    \/\/ null once provider is selected\n+    private Service firstService;\n+\n+    \/\/ remaining services to try in provider selection\n+    \/\/ null once provider is selected\n+    private Iterator<Service> serviceIterator;\n+\n+    private final Object lock;\n+\n+    \/**\n+     * Instantiates a KDF object.\n+     *\n+     * @param keyDerivSpi\n+     *     the delegate\n+     * @param provider\n+     *     the provider\n+     * @param algorithm\n+     *     the algorithm\n+     * @param kdfParameters\n+     *     the algorithm parameters\n+     *\/\n+    private KDF(KDFSpi keyDerivSpi, Provider provider, String algorithm,\n+                KDFParameters kdfParameters) {\n+        this.spi = keyDerivSpi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+        this.kdfParameters = kdfParameters;\n+        lock = new Object();\n+    }\n+\n+    private KDF(Service s, Iterator<Service> t, String algorithm,\n+                KDFParameters kdfParameters) {\n+        firstService = s;\n+        serviceIterator = t;\n+        this.algorithm = algorithm;\n+        this.kdfParameters = kdfParameters;\n+        lock = new Object();\n+    }\n+\n+    \/**\n+     * Returns the algorithm name of this {@code KDF} object.\n+     *\n+     * @return the algorithm name of this {@code KDF} object\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+\n+    \/**\n+     * Returns the name of the provider.\n+     *\n+     * @return the name of the provider\n+     *\/\n+    public String getProviderName() {\n+        chooseFirstProvider();\n+        return provider.getName();\n+    }\n+\n+    \/**\n+     * Returns the {@code KDFParameters} used to initialize the object.\n+     *\n+     * @return the parameters used to initialize the object\n+     *\/\n+    public KDFParameters getKDFParameters() {\n+        return this.kdfParameters;\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDF} implementation for the\n+     *     specified algorithm\n+     * @throws NullPointerException\n+     *     if {@code algorithm} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm)\n+        throws NoSuchAlgorithmException {\n+        try {\n+            return getInstance(algorithm, (KDFParameters) null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidAlgorithmParameterException. Does this \"\n+                + \"algorithm require an AlgorithmParameterSpec?\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider to use for this key derivation (may not be\n+     *     {@code null})\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if a provider is specified and it does not support the specified KDF\n+     *     algorithm, or if provider is {@code null} and there is no provider\n+     *     that supports a KDF implementation of the specified algorithm\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        Objects.requireNonNull(provider, \"provider may not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidAlgorithmParameterException. Does this \"\n+                + \"algorithm require an AlgorithmParameterSpec?\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param provider\n+     *     the provider to use for this key derivation (may not be\n+     *     {@code null})\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if a provider is specified and it does not support the specified KDF\n+     *     algorithm, or if provider is {@code null} and there is no provider\n+     *     that supports a KDF implementation of the specified algorithm\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, Provider provider)\n+        throws NoSuchAlgorithmException {\n+        Objects.requireNonNull(provider, \"provider may not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"Received an InvalidAlgorithmParameterException. Does this \"\n+                + \"algorithm require an AlgorithmParameterSpec?\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm and\n+     * is initialized with the specified parameters.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure this KDF's algorithm or\n+     *     {@code null} if no additional parameters are provided\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        \/\/ make sure there is at least one service from a signed provider\n+        Iterator<Service> t = GetInstance.getServices(\"KDF\", algorithm);\n+        while (t.hasNext()) {\n+            Service s = t.next();\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                continue;\n+            }\n+            return new KDF(s, t, algorithm, kdfParameters);\n+        }\n+        throw new NoSuchAlgorithmException(\n+            \"Algorithm \" + algorithm + \" not available\");\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure this KDF's algorithm or\n+     *     {@code null} if no additional parameters are provided\n+     * @param provider\n+     *     the provider to use for this key derivation (may not be\n+     *     {@code null})\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if a provider is specified and it does not support the specified KDF\n+     *     algorithm, or if provider is {@code null} and there is no provider\n+     *     that supports a KDF implementation of the specified algorithm\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException,\n+               InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        Objects.requireNonNull(provider, \"provider may not be null\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        kdfParameters,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new NoSuchProviderException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm,\n+                           kdfParameters);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure this KDF's algorithm or\n+     *     {@code null} if no additional parameters are provided\n+     * @param provider\n+     *     the provider to use for this key derivation (may not be\n+     *     {@code null})\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if a provider is specified and it does not support the specified KDF\n+     *     algorithm, or if provider is {@code null} and there is no provider\n+     *     that supports a KDF implementation of the specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the {@code AlgorithmParameterSpec} is an invalid value\n+     * @throws NullPointerException\n+     *     if the algorithm is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  Provider provider)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"null algorithm name\");\n+        Objects.requireNonNull(provider, \"provider may not be null\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        kdfParameters,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new SecurityException(msg);\n+            }\n+            return new KDF((KDFSpi) instance.impl, instance.provider, algorithm,\n+                           kdfParameters);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    private static KDF handleException(NoSuchAlgorithmException e)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Throwable cause = e.getCause();\n+        if (cause instanceof InvalidAlgorithmParameterException) {\n+            throw (InvalidAlgorithmParameterException) cause;\n+        }\n+        throw e;\n+    }\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code deriveKey} method may be called multiple times at the same\n+     * time on a particular {@code KDF} instance.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called. Once a\n+     * provider is selected, it cannot be changed.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code SecretKey} object (may not be\n+     *     {@code null})\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the\n+     *     KDF output and according to the derivation parameters\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws NullPointerException\n+     *     if {@code alg} or {@code kdfParameterSpec} is null\n+     *\/\n+    public SecretKey deriveKey(String alg,\n+                               AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+\n+        synchronized (lock) {\n+            if (alg == null || alg.isEmpty()) {\n+                throw new NullPointerException(\n+                    \"the algorithm for the SecretKey return value may not be \"\n+                    + \"null or empty\");\n+            }\n+            Objects.requireNonNull(kdfParameterSpec);\n+            if (spi != null) {\n+                return spi.engineDeriveKey(alg, kdfParameterSpec);\n+            }\n+\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    KDFSpi spi = (KDFSpi) s.newInstance(kdfParameters);\n+                    SecretKey result = spi.engineDeriveKey(alg,\n+                                                           kdfParameterSpec);\n+                    provider = s.getProvider();\n+                    this.spi = spi;\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return result;\n+                } catch (Exception e) {\n+                    if (lastException == null) {\n+                        lastException = e;\n+                    }\n+                }\n+            }\n+            \/\/ no working provider found, fail\n+            if (lastException instanceof InvalidAlgorithmParameterException) {\n+                throw (InvalidAlgorithmParameterException) lastException;\n+            }\n+            if (lastException instanceof RuntimeException) {\n+                throw (RuntimeException) lastException;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"No installed provider supports the deriveKey method with \"\n+            + \"these parameters\");\n+    }\n+\n+    \/**\n+     * Obtains raw data from a key derivation function.\n+     * <p>\n+     * The {@code deriveData} method may be called multiple times at the same\n+     * time on a particular {@code KDF} instance.\n+     * <p>\n+     * Delayed provider selection is also supported such that the provider\n+     * performing the derive is not selected until the method is called. Once a\n+     * provider is selected, it cannot be changed.\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array containing a key built from the KDF output and\n+     *     according to the derivation parameters\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     * @throws NullPointerException\n+     *     if {@code kdfParameterSpec} is null\n+     *\/\n+    public byte[] deriveData(AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException {\n+\n+        synchronized (lock) {\n+            Objects.requireNonNull(kdfParameterSpec);\n+            if (spi != null) {\n+                return spi.engineDeriveData(kdfParameterSpec);\n+            }\n+\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    KDFSpi spi = (KDFSpi) s.newInstance(kdfParameters);\n+                    byte[] result = spi.engineDeriveData(kdfParameterSpec);\n+                    provider = s.getProvider();\n+                    this.spi = spi;\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return result;\n+                } catch (Exception e) {\n+                    if (lastException == null) {\n+                        lastException = e;\n+                    }\n+                }\n+            }\n+            \/\/ no working provider found, fail\n+            if (lastException instanceof InvalidAlgorithmParameterException) {\n+                throw (InvalidAlgorithmParameterException) lastException;\n+            }\n+            if (lastException instanceof RuntimeException) {\n+                throw (RuntimeException) lastException;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"No installed provider supports the deriveData method with\"\n+            + \" these parameters\");\n+    }\n+\n+    \/\/ max number of debug warnings to print from chooseFirstProvider()\n+    private static int warnCount = 10;\n+\n+    \/**\n+     * Choose the Spi from the first provider available. Used if delayed\n+     * provider selection is not possible because init() is not the first method\n+     * called.\n+     *\/\n+    void chooseFirstProvider() {\n+        if ((spi != null) || (serviceIterator == null)) {\n+            return;\n+        }\n+        synchronized (lock) {\n+            if (spi != null) {\n+                return;\n+            }\n+            Exception lastException = null;\n+            while ((firstService != null) || serviceIterator.hasNext()) {\n+                Service s;\n+                if (firstService != null) {\n+                    s = firstService;\n+                    firstService = null;\n+                } else {\n+                    s = serviceIterator.next();\n+                }\n+                if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                    continue;\n+                }\n+                try {\n+                    Object obj = s.newInstance(kdfParameters);\n+                    if (!(obj instanceof KDFSpi)) {\n+                        continue;\n+                    }\n+                    spi = (KDFSpi) obj;\n+                    provider = s.getProvider();\n+                    \/\/ not needed any more\n+                    firstService = null;\n+                    serviceIterator = null;\n+                    return;\n+                } catch (NoSuchAlgorithmException e) {\n+                    lastException = e;\n+                }\n+            }\n+            ProviderException e = new ProviderException(\n+                \"Could not construct KDFSpi instance\");\n+            if (lastException != null) {\n+                e.initCause(lastException);\n+            }\n+            throw e;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":611,"deletions":0,"binary":false,"changes":611,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+\n+\/**\n+ * This class defines the <i>Service Provider Interface<\/i> (<b>SPI<\/b>) for the\n+ * {@code KDF} class.\n+ * <p>\n+ * All the abstract methods in this class must be implemented by each\n+ * cryptographic service provider who wishes to supply the implementation of a\n+ * particular key derivation algorithm.\n+ *\n+ * @see KDF\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public abstract class KDFSpi {\n+\n+    \/**\n+     * The sole constructor.\n+     * <p>\n+     * A {@code KDFParameters} object may be specified for KDF algorithms\n+     * that require this.\n+     *\n+     * @param kdfParameters\n+     *     the initialization parameters for the {@code KDF} algorithm (may be\n+     *     {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    protected KDFSpi(KDFParameters kdfParameters)\n+        throws InvalidAlgorithmParameterException {}\n+\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code deriveKey} method may be called multiple times on a particular\n+     * {@code KDF} instance.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code SecretKey} object (may not be\n+     *     {@code null})\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a {@code SecretKey} object corresponding to a key built from the\n+     *     KDF output and according to the derivation parameters\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws NullPointerException\n+     *     if {@code alg} or {@code kdfParameterSpec} is null\n+     *\/\n+    protected abstract SecretKey engineDeriveKey(String alg,\n+                                                 AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException;\n+\n+    \/**\n+     * Obtains raw data from a key derivation function.\n+     * <p>\n+     * The {@code deriveData} method may be called multiple times on a\n+     * particular {@code KDF} instance.\n+     *\n+     * @param kdfParameterSpec\n+     *     derivation parameters\n+     *\n+     * @return a byte array whose length matches the specified length in the\n+     *     processed {@code KDFParameterSpec} and containing the output from the\n+     *     key derivation function\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived key material is not extractable\n+     * @throws NullPointerException\n+     *     if {@code kdfParameterSpec} is null\n+     *\/\n+    protected abstract byte[] engineDeriveData(\n+        AlgorithmParameterSpec kdfParameterSpec)\n+        throws InvalidAlgorithmParameterException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,503 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.SecretKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Parameters for the combined Extract, Expand, or Extract-then-Expand\n+ * operations of the HMAC-based Key Derivation Function (HKDF). The HKDF\n+ * function is defined in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC\n+ * 5869<\/a>.\n+ * <p>\n+ * In the Extract and Extract-then-Expand cases, the {@code addIKM} and\n+ * {@code addSalt} methods may be called repeatedly (and chained). This provides\n+ * for use-cases where a {@code SecretKey} may reside on an HSM and not be\n+ * exportable. The caller may wish to provide a label (or other components) of\n+ * the IKM without having access to the portion stored on the HSM. The same\n+ * feature is available for salts.\n+ * <p>\n+ * The above feature is particularly useful for \"labeled\" HKDF Extract used in\n+ * TLS 1.3 and HPKE, where the IKM consists of concatenated components, which\n+ * may include both byte arrays and (possibly non-extractable) secret keys.\n+ * <p>\n+ * Examples:\n+ * {@snippet lang = java:\n+ *\n+ * AlgorithmParameterSpec kdfParameterSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikmPart1)\n+ *                              .addIKM(ikmPart2)\n+ *                              .addSalt(salt).extractOnly();\n+ *\n+ *\n+ *}\n+ * {@snippet lang = java:\n+ *\n+ * AlgorithmParameterSpec kdfParameterSpec = HKDFParameterSpec.expandOnly(prk,\n+ * info, 32);\n+ *\n+ *}\n+ * {@snippet lang = java:\n+ *\n+ * AlgorithmParameterSpec kdfParameterSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 42);\n+ *\n+ *}\n+ *\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface HKDFParameterSpec extends AlgorithmParameterSpec {\n+\n+    \/**\n+     * This {@code Builder} builds {@code Extract} and {@code ExtractThenExpand}\n+     * objects.\n+     * <p>\n+     * The {@code Builder} is initialized via the {@code ofExtract} method of\n+     * {@code HKDFParameterSpec}. As stated in the class description,\n+     * {@code addIKM} and\/or {@code addSalt} may be called as needed. Finally,\n+     * the object is \"built\" by calling either {@code extractOnly} or\n+     * {@code thenExpand} for {@code Extract} and {@code ExtractThenExpand}\n+     * use-cases respectively. Note that the {@code Builder} is not\n+     * thread-safe.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Builder {\n+\n+        List<SecretKey> ikms = new ArrayList<>();\n+        List<SecretKey> salts = new ArrayList<>();\n+\n+        Builder() {}\n+\n+        \/**\n+         * Creates a {@code Builder} for an {@code Extract}.\n+         *\n+         * @return a {@code Builder} to mutate\n+         *\/\n+        private Builder createBuilder() {\n+            return this;\n+        }\n+\n+        \/**\n+         * Builds an {@code Extract} from the current state of the\n+         * {@code Builder}.\n+         *\n+         * @return an immutable {@code Extract}\n+         *\/\n+        public Extract extractOnly() {\n+            return new Extract(ikms, salts);\n+        }\n+\n+        \/**\n+         * Builds an {@code ExtractThenExpand}.\n+         *\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output key material\n+         *\n+         * @return an {@code ExtractThenExpand}\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} is not &gt; 0\n+         *\/\n+        public ExtractThenExpand thenExpand(byte[] info, int length) {\n+            return new ExtractThenExpand(\n+                extractOnly(), info,\n+                length);\n+        }\n+\n+        \/**\n+         * Adds input key material to the builder.\n+         * <p>\n+         * {@code addIKM} may be called when the input key material value is to\n+         * be assembled piece-meal or if part of the IKM is to be supplied by a\n+         * hardware crypto device. This method appends to the existing list of\n+         * values or creates a new list if there is none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM\n+         * but the actual value of the IKM is not yet available.\n+         * <p>\n+         * An implementation should concatenate the input key materials into a\n+         * single value once all components are available.\n+         *\n+         * @param ikm\n+         *     the input key material value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code ikm} is null\n+         *\/\n+        public Builder addIKM(SecretKey ikm) {\n+            if (ikm != null) {\n+                ikms.add(ikm);\n+            } else {\n+                throw new NullPointerException(\"ikm must not be null\");\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds input key material to the builder.\n+         * <p>\n+         * {@code addIKM} may be called when the input key material value is to\n+         * be assembled piece-meal or if part of the IKM is to be supplied by a\n+         * hardware crypto device. This method appends to the existing list of\n+         * values or creates a new list if there is none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the IKM\n+         * but the actual value of the IKM is not yet available.\n+         * <p>\n+         * An implementation should concatenate the input key materials into a\n+         * single value once all components are available.\n+         *\n+         * @param ikm\n+         *     the input key material value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code ikm} is null\n+         *\/\n+        public Builder addIKM(byte[] ikm) {\n+            if (ikm == null) {\n+                throw new NullPointerException(\"ikm must not be null or empty\");\n+            }\n+            if (ikm.length != 0) {\n+                return addIKM(new SecretKeySpec(ikm, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder.\n+         * <p>\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there is none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt\n+         * but the actual value of the salt is not yet available.\n+         * <p>\n+         * An implementation should concatenate the salt into a single value\n+         * once all components are available.\n+         *\n+         * @param salt\n+         *     the salt value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(SecretKey salt) {\n+            if (salt != null) {\n+                salts.add(salt);\n+            } else {\n+                throw new NullPointerException(\"salt must not be null\");\n+            }\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder.\n+         * <p>\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there is none yet.\n+         * <p>\n+         * This supports the use-case where a label can be applied to the salt\n+         * but the actual value of the salt is not yet available. An\n+         * implementation should concatenate the salt into a single value once\n+         * all components are available.\n+         *\n+         * @param salt\n+         *     the salt value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(byte[] salt) {\n+            if (salt == null) {\n+                throw new NullPointerException(\n+                    \"salt must not be null or empty\");\n+            }\n+            if (salt.length != 0) {\n+                return addSalt(new SecretKeySpec(salt, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a builder for building {@code Extract} and\n+     * {@code ExtractThenExpand} objects.\n+     * <p>\n+     * Note: one or more of the methods {@code addIKM} or {@code addSalt} should\n+     * be called next, before calling build methods, such as\n+     * {@code Builder.extractOnly()}\n+     *\n+     * @return a {@code Builder} to mutate\n+     *\/\n+    static Builder ofExtract() {\n+        return new Builder().createBuilder();\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an {@code Expand} object\n+     *\n+     * @param prk\n+     *     the pseudorandom key; must not be {@code null} in the Expand case\n+     * @param info\n+     *     the optional context and application specific information (may be\n+     *     {@code null}); the byte[] is copied to prevent subsequent\n+     *     modification\n+     * @param length\n+     *     the length of the output key material (must be &gt; 0 and &lt; 255 *\n+     *     HMAC length)\n+     *\n+     * @return a new {@code Expand} object\n+     *\n+     * @throws NullPointerException\n+     *     if {@code prk} is {@code null}\n+     * @throws IllegalArgumentException\n+     *     if {@code length} is not > 0\n+     *\/\n+    static Expand expandOnly(SecretKey prk, byte[] info, int length) {\n+        if (prk == null) {\n+            throw new NullPointerException(\"prk must not be null\");\n+        }\n+        return new Expand(prk, info, length);\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Extract operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Extract implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Extract(salt, IKM) -> PRK\n+        private final List<SecretKey> ikms;\n+        private final List<SecretKey> salts;\n+\n+        private Extract() {\n+            this(new ArrayList<>(), new ArrayList<>());\n+        }\n+\n+        private Extract(List<SecretKey> ikms, List<SecretKey> salts) {\n+            this.ikms = List.copyOf(ikms);\n+            this.salts = List.copyOf(salts);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input key material values in\n+         * the order they were added.\n+         *\n+         * @return the unmodifiable {@code List} of input key material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ikms;\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return salts;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Expand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Expand implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Expand(PRK, info, L) -> OKM\n+        private final SecretKey prk;\n+        private final byte[] info;\n+        private final int length;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code Expand} object\n+         *\n+         * @param prk\n+         *     the pseudorandom key; may be {@code null}\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output key material (must be > 0 and < 255 *\n+         *     HMAC length)\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} not > 0\n+         *\/\n+        private Expand(SecretKey prk, byte[] info, int length) {\n+            \/\/ a null prk could be indicative of ExtractThenExpand\n+            this.prk = prk;\n+            this.info = (info == null) ? null : info.clone();\n+            if (!(length > 0)) {\n+                throw new IllegalArgumentException(\"length must be > 0\");\n+            }\n+            this.length = length;\n+        }\n+\n+        \/**\n+         * Returns the pseudorandom key.\n+         *\n+         * @return the pseudorandom key\n+         *\/\n+        public SecretKey prk() {\n+            return prk;\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a copy of the optional context and application specific\n+         *     information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return (info == null) ? null : info.clone();\n+        }\n+\n+        \/**\n+         * Returns the length of the output key material.\n+         *\n+         * @return the length of the output key material\n+         *\/\n+        public int length() {\n+            return length;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an ExtractThenExpand operation as defined\n+     * in\n+     * <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class ExtractThenExpand implements HKDFParameterSpec {\n+        private final Extract ext;\n+        private final Expand exp;\n+\n+        \/**\n+         * Constructor that may be used to initialize an\n+         * {@code ExtractThenExpand} object\n+         * <p>\n+         * Note: {@code addIKMValue} and {@code addSaltValue} may be called\n+         * afterward to supply additional values, if desired\n+         *\n+         * @param ext\n+         *     a pre-generated {@code Extract}\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output key material (must be > 0 and < 255 *\n+         *     HMAC length)\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} is not > 0\n+         *\/\n+        private ExtractThenExpand(Extract ext, byte[] info, int length) {\n+            \/\/ null-checked previously\n+            this.ext = ext;\n+            \/\/ - null prk is ok here (it's a signal)\n+            \/\/ - {@code Expand} constructor can deal with a null info\n+            \/\/ - length is checked in {@code Expand} constructor\n+            this.exp = new Expand(null, info, length);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input key material values in\n+         * the order they were added.\n+         *\n+         * @return the input key material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ext.ikms();\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added.\n+         *\n+         * @return the salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return ext.salts();\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a copy of the optional context and application specific\n+         *     information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return exp.info();\n+        }\n+\n+        \/**\n+         * Returns the length of the output key material.\n+         *\n+         * @return the length of the output key material\n+         *\/\n+        public int length() {\n+            return exp.length();\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":503,"deletions":0,"binary":false,"changes":503,"status":"added"},{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=478, title=\"Key Derivation Function API\", status=\"Preview\")\n+        KEY_DERIVATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        System.err.println(\"              Cipher, KeyAgreement, KeyGenerator,\");\n+        System.err.println(\"              Cipher, KDF, KeyAgreement, KeyGenerator,\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary basic HKDF operations\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+public class Functions {\n+    public static void main(String[] args) throws Exception {\n+        var ikm = HexFormat.of().parseHex(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\");\n+        var salt = HexFormat.of().parseHex(\"000102030405060708090a0b0c\");\n+        var info = HexFormat.of().parseHex(\"f0f1f2f3f4f5f6f7f8f9\");\n+        var len = 42;\n+\n+        var kdf = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+        var expectedPrk = HexFormat.of().parseHex(\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\");\n+        var expectedOkm = HexFormat.of().parseHex(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\");\n+\n+        var extractOnly = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).extractOnly();\n+        var prk = kdf.deriveKey(\"PRK\", extractOnly);\n+        var expandOnly = HKDFParameterSpec.expandOnly(prk, info, len);\n+        var okm1 = kdf.deriveKey(\"OKM\", expandOnly);\n+        var extractAndExpand = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(info, len);\n+        var okm2 = kdf.deriveKey(\"OKM\", extractAndExpand);\n+\n+        if (!Arrays.equals(prk.getEncoded(), expectedPrk)) {\n+            throw new Exception();\n+        }\n+        if (!Arrays.equals(okm1.getEncoded(), expectedOkm)) {\n+            throw new Exception();\n+        }\n+        if (!Arrays.equals(okm2.getEncoded(), expectedOkm)) {\n+            throw new Exception();\n+        }\n+\n+        test(HKDFParameterSpec.ofExtract().extractOnly());\n+        test(HKDFParameterSpec.ofExtract().thenExpand(new byte[0], 32));\n+        test(HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(new byte[0]).extractOnly());\n+    }\n+\n+    static void test(HKDFParameterSpec p) throws Exception {\n+        var kdf = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+        System.out.println(HexFormat.of().formatHex(kdf.deriveData(p)));\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/Functions.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @run main TestHKDF\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class TestHKDF {\n+    public static class TestData {\n+        public TestData(String name, String algStr, String ikmStr,\n+                        String saltStr, String infoStr, int oLen,\n+                        String expPrkStr,\n+                        String expOkmStr) {\n+            testName = Objects.requireNonNull(name);\n+            algName = Objects.requireNonNull(algStr);\n+            IKM = hex2bin(Objects.requireNonNull(ikmStr));\n+            if ((outLen = oLen) <= 0) {\n+                throw new IllegalArgumentException(\n+                    \"Output length must be greater than 0\");\n+            }\n+            expectedPRK = hex2bin(Objects.requireNonNull(expPrkStr));\n+            expectedOKM = hex2bin(Objects.requireNonNull(expOkmStr));\n+\n+            \/\/ Non-mandatory fields - may be null\n+            salt = (saltStr != null) ? hex2bin(saltStr) : null;\n+            info = (infoStr != null) ? hex2bin(infoStr) : null;\n+        }\n+\n+        public final String testName;\n+        public final String algName;\n+        public final byte[] IKM;\n+        public final byte[] salt;\n+        public final byte[] info;\n+        public final int outLen;\n+        public final byte[] expectedPRK;\n+        public final byte[] expectedOKM;\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 5689 Test Case 1\", \"HKDFWithHmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         \"000102030405060708090a0b0c\",\n+                         \"f0f1f2f3f4f5f6f7f8f9\",\n+                         42,\n+                         \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n+                         \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\"\n+                         +\n+                         \"34007208d5b887185865\"));\n+        add(new TestData(\"RFC 5689 Test Case 2\", \"HKDFWithHmacSHA256\",\n+                         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n+                         +\n+                         \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n+                         +\n+                         \"404142434445464748494a4b4c4d4e4f\",\n+                         \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\"\n+                         +\n+                         \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\"\n+                         +\n+                         \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                         \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\"\n+                         +\n+                         \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\"\n+                         +\n+                         \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                         82,\n+                         \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n+                         \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\"\n+                         +\n+                         \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\"\n+                         +\n+                         \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n+        add(new TestData(\"RFC 5689 Test Case 3\", \"HKDFWithHmacSHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         new String(new byte[0]), new String(new byte[0]), 42,\n+                         \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n+                         \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\"\n+                         +\n+                         \"9d201395faa4b61a96c8\"));\n+    }};\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+\n+        int testNo = 0;\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNo + \": \" +\n+                               test.testName);\n+            if (runVector(test)) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total tests: \" + testList.size() +\n+                           \", Passed: \" + testsPassed + \", Failed: \" +\n+                           (testList.size() - testsPassed));\n+        if (testsPassed != testList.size()) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                                       \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runVector(TestData testData)\n+        throws InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException,\n+               InvalidKeyException {\n+        String kdfName, prfName;\n+        KDF kdfHkdf, kdfExtract, kdfExpand;\n+        boolean result = true;\n+        SecretKey actualPRK;\n+        SecretKey actualOKM;\n+        byte[] deriveData;\n+\n+        try {\n+            kdfHkdf = KDF.getInstance(testData.algName);\n+            kdfExtract = KDF.getInstance(testData.algName);\n+            kdfExpand = KDF.getInstance(testData.algName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            InvalidParameterSpecException exc =\n+                new InvalidParameterSpecException();\n+            exc.initCause(nsae);\n+            throw exc;\n+        }\n+\n+        \/\/ Set up the input keying material\n+        SecretKey ikmKey = new SecretKeySpec(testData.IKM, \"HKDF-IKM\");\n+\n+        \/\/ *** HKDF-Extract-only testing\n+        \/\/ Create KDFParameterSpec for the Extract-only operation\n+        AlgorithmParameterSpec kdfParameterSpecExtract =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .extractOnly();\n+        actualPRK = kdfExtract.deriveKey(\"RAW\", kdfParameterSpecExtract);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExtract.deriveData(kdfParameterSpecExtract);\n+\n+        System.out.println(\"* HKDF-Extract-Only:\");\n+        result &= compareKeyAndData(actualPRK, deriveData,\n+                                    testData.expectedPRK);\n+\n+        \/\/ *** HKDF Expand-Only testing\n+        \/\/ For these tests, we'll use the actualPRK as the input key\n+        \/\/ Create KDFParameterSpec for key output and raw byte output\n+        AlgorithmParameterSpec kdfParameterSpecExpand = HKDFParameterSpec.expandOnly(\n+            actualPRK, testData.info,\n+            testData.outLen);\n+        actualOKM = kdfExpand.deriveKey(\"RAW\", kdfParameterSpecExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExpand.deriveData(kdfParameterSpecExpand);\n+\n+        System.out.println(\"* HKDF-Expand-Only:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        \/\/ *** HKDF Extract-then-Expand testing\n+        \/\/ We can reuse the KDFParameterSpec from the Expand-only test\n+\n+        \/\/ Use the KDF to make us a key\n+        AlgorithmParameterSpec kdfParameterSpecExtractExpand =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .thenExpand(testData.info,\n+                                         testData.outLen);\n+        actualOKM = kdfHkdf.deriveKey(\"RAW\", kdfParameterSpecExtractExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfHkdf.deriveData(kdfParameterSpecExtractExpand);\n+\n+        System.out.println(\"* HKDF-Extract-then-Expand:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Compare key-based and data-based productions from the KDF against an\n+     * expected output value.\n+     *\n+     * @param outKey\n+     *     the KDF output in key form\n+     * @param outData\n+     *     the KDF output as raw bytes\n+     * @param expectedOut\n+     *     the expected value\n+     *\n+     * @return true if the underlying data for outKey, outData and expectedOut\n+     * are the same.\n+     *\/\n+    private static boolean compareKeyAndData(Key outKey, byte[] outData,\n+                                             byte[] expectedOut) {\n+        boolean result = true;\n+\n+        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n+            System.out.println(\"\\t* Key output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Key output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outKey.getEncoded(), 16, \"\\n\",\n+                                            \" \"));\n+            System.out.println();\n+        }\n+\n+        if (Arrays.equals(outData, expectedOut)) {\n+            System.out.println(\"\\t* Data output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Data output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data\n+     *     The array of bytes to dump to stdout.\n+     * @param itemsPerLine\n+     *     The number of bytes to display per line if the {@code lineDelim}\n+     *     character is blank then all bytes will be printed on a single line.\n+     * @param lineDelim\n+     *     The delimiter between lines\n+     * @param itemDelim\n+     *     The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+                                       String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static byte[] hex2bin(String hex) {\n+        int i;\n+        int len = hex.length();\n+        byte[] data = new byte[len \/ 2];\n+        for (i = 0; i < len; i += 2) {\n+            data[i \/ 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) +\n+                                  Character.digit(hex.charAt(i + 1), 16));\n+        }\n+        return data;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHKDF.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main Delayed\n+ * @summary delayed provider selection\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+public class Delayed {\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new Provider1());\n+        Security.addProvider(new Provider2());\n+        Security.addProvider(new Provider3());\n+        KDF kdf;\n+\n+        kdf = KDF.getInstance(\"X\", new KDFParameters() {});\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P1\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new MyKDFParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P2\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P3\");\n+    }\n+\n+    public static class Provider1 extends Provider {\n+        public Provider1() {\n+            super(\"P1\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF1.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF1 requires a params at getInstance()\n+    public static class KDF1 extends KDF0 {\n+        public KDF1(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(Objects.requireNonNull(e));\n+        }\n+    }\n+\n+    public static class Provider2 extends Provider {\n+        public Provider2() {\n+            super(\"P2\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF2.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF2 requires input to be a specific type\n+    public static class KDF2 extends KDF0 {\n+        public KDF2(KDFParameters e)\n+            throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec kdfParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            if (kdfParameterSpec instanceof MyKDFParameterSpec) {\n+                return null;\n+            } else {\n+                throw new InvalidAlgorithmParameterException();\n+            }\n+        }\n+    }\n+\n+    public static class Provider3 extends Provider {\n+        public Provider3() {\n+            super(\"P3\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF3.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF3 doesn't care about anything\n+    public static class KDF3 extends KDF0 {\n+        public KDF3(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+    }\n+\n+    public abstract static class KDF0 extends KDFSpi {\n+        public KDF0(KDFParameters a) throws InvalidAlgorithmParameterException {\n+            super(a);\n+        }\n+\n+        protected SecretKey engineDeriveKey(String alg,\n+                                            AlgorithmParameterSpec kdfParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return null;\n+        }\n+\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec kdfParameterSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return new byte[0];\n+        }\n+    }\n+\n+    static class MyKDFParameterSpec implements AlgorithmParameterSpec {}\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/Delayed.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib\n+ * @run testng Threading\n+ * @summary multi-threading test for KDF\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.HexFormat;\n+\n+public class Threading {\n+    KDF kdfUnderTest;\n+    byte[] ikm = new BigInteger(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                                16).toByteArray();\n+    byte[] salt = new BigInteger(\"000102030405060708090a0b0c\",\n+                                 16).toByteArray();\n+    byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+    AlgorithmParameterSpec kdfParameterSpec =\n+        HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(\n+            info, 42);\n+    String expectedResult =\n+        \"666b33562ebc5e2f041774192e0534efca06f82a5fca17ec8c6ae1b9f5466adba1d77d06480567ddd2d1\";\n+\n+    @BeforeClass\n+    public void setUp() throws NoSuchAlgorithmException {\n+        kdfUnderTest = KDF.getInstance(\"HKDFWithHmacSHA256\");\n+    }\n+\n+    @Test(threadPoolSize = 50, invocationCount = 100, timeOut = 30)\n+    public void testDeriveKey() throws InvalidAlgorithmParameterException {\n+        SecretKey result = kdfUnderTest.deriveKey(\"AES\", kdfParameterSpec);\n+        assert (HexFormat.of().formatHex(result.getEncoded()).equals(\n+            expectedResult));\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/Threading.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"","filename":"test\/jdk\/security\/unsignedjce\/java.base\/javax\/crypto\/ProviderVerifier.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/share\/classes\/javax\/crypto\/ProviderVerifier.java","status":"copied"}]}