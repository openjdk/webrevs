{"files":[{"patch":"@@ -0,0 +1,418 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import javax.crypto.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * KDF implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC\n+ * 5869.  This implementation provides the complete Extract-then-Expand HKDF\n+ * function as well as Extract-only and Expand-only variants.\n+ *\/\n+abstract class HKDFKeyDerivation extends KDFSpi {\n+\n+    private final int hmacLen;\n+    private final String hmacAlgName;\n+\n+    private static final int SHA256_HMAC_SIZE = 32;\n+    private static final int SHA384_HMAC_SIZE = 48;\n+    private static final int SHA512_HMAC_SIZE = 64;\n+\n+    private static final Integer[] SUPPORTED_HMAC_SIZES = new Integer[] {\n+        SHA256_HMAC_SIZE,\n+        SHA384_HMAC_SIZE,\n+        SHA512_HMAC_SIZE\n+    };\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param kdfParameters\n+     *     the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    private HKDFKeyDerivation(String hmacAlgName, int hmacLen,\n+                              KDFParameters kdfParameters)\n+        throws InvalidAlgorithmParameterException {\n+        super(kdfParameters);\n+        if (kdfParameters != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                hmacAlgName + \" does not support parameters\");\n+        }\n+        \/\/ added to enforce valid values at reviewer's request\n+        if (!Arrays.asList(SUPPORTED_HMAC_SIZES).contains(hmacLen)){\n+            throw new InternalError(\n+                \"Subclass attempted to use an invalid hmacLen\");\n+        }\n+        this.hmacAlgName = hmacAlgName;\n+        this.hmacLen = hmacLen;\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey} object.\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationParameterSpec} is\n+     *     invalid or if the combination of {@code alg} and the {@code derivationParameterSpec}\n+     *     results in something invalid, ie - a key of inappropriate length\n+     *     for the specified algorithm\n+     * @throws NoSuchAlgorithmException\n+     *     if {@code alg} is empty\n+     * @throws NullPointerException\n+     *     if {@code alg} is {@code null}\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg,\n+                                        AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+\n+        if (alg == null) {\n+            throw new NullPointerException(\n+                \"the algorithm for the SecretKey return value must not be null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\n+                \"the algorithm for the SecretKey return value must not be \"\n+                + \"empty\");\n+        }\n+\n+        return new SecretKeySpec(engineDeriveData(derivationSpec), alg);\n+\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived keying material is not extractable\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n+                throws InvalidAlgorithmParameterException {\n+        List<SecretKey> ikms, salts;\n+        byte[] inputKeyMaterial, salt, pseudoRandomKey, info;\n+        int length;\n+        \/\/ A switch would be nicer, but we may need to backport this before\n+        \/\/ JDK 17\n+        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable\n+        \/\/ in instanceof either\n+        if (derivationSpec instanceof HKDFParameterSpec.Extract) {\n+            HKDFParameterSpec.Extract anExtract =\n+                (HKDFParameterSpec.Extract) derivationSpec;\n+            ikms = anExtract.ikms();\n+            salts = anExtract.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            inputKeyMaterial = null;\n+            salt = null;\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+\n+                \/\/ perform extract\n+                return hkdfExtract(inputKeyMaterial, salt);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF Extract could not be initialized with the given \"\n+                    + \"key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            } finally {\n+                if (inputKeyMaterial != null) {\n+                    Arrays.fill(inputKeyMaterial, (byte) 0x00);\n+                }\n+                if (salt != null) {\n+                    Arrays.fill(salt, (byte) 0x00);\n+                }\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.Expand) {\n+            HKDFParameterSpec.Expand anExpand =\n+                (HKDFParameterSpec.Expand) derivationSpec;\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk().getEncoded()) == null) {\n+                throw new AssertionError(\n+                    \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Requested length exceeds maximum allowed length\");\n+            }\n+            \/\/ perform expand\n+            try {\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF Expand could not be initialized with the given \"\n+                    + \"keying material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            } finally {\n+                Arrays.fill(pseudoRandomKey, (byte) 0x00);\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.ExtractThenExpand) {\n+            HKDFParameterSpec.ExtractThenExpand anExtractThenExpand =\n+                (HKDFParameterSpec.ExtractThenExpand) derivationSpec;\n+            ikms = anExtractThenExpand.ikms();\n+            salts = anExtractThenExpand.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            inputKeyMaterial = null;\n+            salt = null;\n+            pseudoRandomKey = null;\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+\n+                \/\/ set this value in the \"if\"\n+                if ((info = anExtractThenExpand.info()) == null) {\n+                    info = new byte[0];\n+                }\n+                length = anExtractThenExpand.length();\n+                if (length > (hmacLen * 255)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                        \"Requested length exceeds maximum allowed length\");\n+                }\n+\n+                \/\/ perform extract and then expand\n+                pseudoRandomKey = hkdfExtract(inputKeyMaterial, salt);\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF ExtractThenExpand could not be initialized with \"\n+                    + \"the given key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/HMAC.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            } finally {\n+                if (inputKeyMaterial != null) {\n+                    Arrays.fill(inputKeyMaterial, (byte) 0x00);\n+                }\n+                if (salt != null) {\n+                    Arrays.fill(salt, (byte) 0x00);\n+                }\n+                if (pseudoRandomKey != null) {\n+                    Arrays.fill(pseudoRandomKey, (byte) 0x00);\n+                }\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"an HKDF derivation requires a valid HKDFParameterSpec\");\n+    }\n+\n+    \/\/ throws an InvalidKeyException if any key is unextractable\n+    private byte[] consolidateKeyMaterial(List<SecretKey> keys)\n+        throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                SecretKey checkIt = localKeys.get(0);\n+                return CipherCore.getKeyBytes(checkIt);\n+            } else {\n+                ByteArrayOutputStream os = new ByteArrayOutputStream();\n+                for (SecretKey workItem : localKeys) {\n+                    os.writeBytes(CipherCore.getKeyBytes(workItem));\n+                }\n+                \/\/ deliberately omitting os.flush(), since we are writing to\n+                \/\/ memory, and toByteArray() reads like there isn't an explicit\n+                \/\/ need for this call\n+                return os.toByteArray();\n+            }\n+        } else if(keys != null) {\n+                return new byte[0];\n+        } else {\n+            throw new InvalidKeyException(\n+                \"List of key segments could not be consolidated\");\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Extract operation.\n+     *\n+     * @param inputKeyMaterial\n+     *     the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *     the salt value used for HKDF-Extract\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid salt was provided through the\n+     *     {@code HKDFParameterSpec}\n+     *\/\n+    private byte[] hkdfExtract(byte[] inputKeyMaterial, byte[] salt)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+\n+        \/\/ salt will not be null\n+        if (salt.length == 0) {\n+            salt = new byte[hmacLen];\n+        }\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+        hmacObj.init(new SecretKeySpec(salt, hmacAlgName));\n+\n+        \/\/ inputKeyMaterial will not be null\n+        return hmacObj.doFinal(inputKeyMaterial);\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Expand operation.\n+     *\n+     * @param prk\n+     *     the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *     optional context and application specific information or {@code null}\n+     *     if no info data is provided.\n+     * @param outLen\n+     *     the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete {@code KDF} output.  This\n+     *     will be at least as long as the requested length in the {@code outLen}\n+     *     parameter, but will be rounded up to the nearest multiple of the HMAC\n+     *     output length.\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid PRK was provided through the {@code HKDFParameterSpec}\n+     *     or derived during the extract phase.\n+     *\/\n+    private byte[] hkdfExpand(byte[] prk, byte[] info, int outLen)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+        byte[] kdfOutput;\n+\n+        if (prk == null || prk.length < hmacLen) {\n+            throw new InvalidKeyException(\n+                \"prk must be at least \" + hmacLen + \" bytes\");\n+        }\n+\n+        SecretKey pseudoRandomKey = new SecretKeySpec(prk, hmacAlgName);\n+\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        hmacObj.init(pseudoRandomKey);\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[outLen];\n+        int i = 0;\n+        int offset = 0;\n+        try {\n+            while (i < rounds) {\n+                if (i > 0) {\n+                    hmacObj.update(kdfOutput, offset - hmacLen, hmacLen); \/\/ add T(i-1)\n+                }\n+                hmacObj.update(info);                   \/\/ Add info\n+                hmacObj.update((byte) ++i);             \/\/ Add round number\n+                if (i == rounds && (outLen - offset < hmacLen)) {\n+                    \/\/ special handling for last chunk\n+                    byte[] tmp = hmacObj.doFinal();\n+                    System.arraycopy(tmp, 0, kdfOutput, offset,\n+                                     outLen - offset);\n+                    Arrays.fill(tmp, (byte)0x00);\n+                    offset = outLen;\n+                } else {\n+                    hmacObj.doFinal(kdfOutput, offset);\n+                    offset += hmacLen;\n+                }\n+            }\n+        } catch (ShortBufferException sbe) {\n+            \/\/ This really shouldn't happen given that we've\n+            \/\/ sized the buffers to their largest possible size up-front,\n+            \/\/ but just in case...\n+            throw new ProviderException(sbe);\n+        }\n+        return kdfOutput;\n+    }\n+\n+    protected KDFParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    public static final class HKDFSHA256 extends HKDFKeyDerivation {\n+        public HKDFSHA256(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA256\", SHA256_HMAC_SIZE, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HKDFSHA384 extends HKDFKeyDerivation {\n+        public HKDFSHA384(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA384\", SHA384_HMAC_SIZE, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HKDFSHA512 extends HKDFKeyDerivation {\n+        public HKDFSHA512(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA512\", SHA512_HMAC_SIZE, kdfParameters);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HKDFKeyDerivation.java","additions":418,"deletions":0,"binary":false,"changes":418,"status":"added"},{"patch":"@@ -1,415 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import javax.crypto.KDFSpi;\n-import javax.crypto.Mac;\n-import javax.crypto.SecretKey;\n-import javax.crypto.ShortBufferException;\n-import javax.crypto.spec.HKDFParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.io.ByteArrayOutputStream;\n-import java.security.InvalidAlgorithmParameterException;\n-import java.security.InvalidKeyException;\n-import javax.crypto.KDFParameters;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.ProviderException;\n-import java.security.spec.AlgorithmParameterSpec;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-\/**\n- * KDF implementation for the HKDF function.\n- * <p>\n- * This class implements the HKDF-Extract and HKDF-Expand functions from RFC\n- * 5869.  This implementation provides the complete Extract-then-Expand HKDF\n- * function as well as Extract-only and Expand-only variants.\n- *\/\n-abstract class HkdfKeyDerivation extends KDFSpi {\n-\n-    private final int hmacLen;\n-    private final String hmacAlgName;\n-\n-    private static final int SHA256_HMAC_SIZE = 32;\n-    private static final int SHA384_HMAC_SIZE = 48;\n-    private static final int SHA512_HMAC_SIZE = 64;\n-\n-    private static final Integer[] SUPPORTED_HMAC_SIZES = new Integer[] {\n-        SHA256_HMAC_SIZE,\n-        SHA384_HMAC_SIZE,\n-        SHA512_HMAC_SIZE\n-    };\n-\n-    \/**\n-     * The sole constructor.\n-     *\n-     * @param kdfParameters\n-     *     the initialization parameters (may be {@code null})\n-     *\n-     * @throws InvalidAlgorithmParameterException\n-     *     if the initialization parameters are inappropriate for this\n-     *     {@code KDFSpi}\n-     *\/\n-    private HkdfKeyDerivation(String hmacAlgName, int hmacLen,\n-                      KDFParameters kdfParameters)\n-        throws InvalidAlgorithmParameterException {\n-        super(kdfParameters);\n-        if (kdfParameters != null) {\n-            throw new InvalidAlgorithmParameterException(\n-                hmacAlgName + \" does not support parameters\");\n-        }\n-        \/\/ added to enforce valid values at reviewer's request\n-        if (!Arrays.asList(SUPPORTED_HMAC_SIZES).contains(hmacLen)){\n-            throw new InternalError(\n-                \"Subclass attempted to use an invalid hmacLen\");\n-        }\n-        this.hmacAlgName = hmacAlgName;\n-        this.hmacLen = hmacLen;\n-    }\n-\n-    \/**\n-     * Derive a key, returned as a {@code SecretKey}.\n-     *\n-     * @return a derived {@code SecretKey} object of the specified algorithm\n-     *\n-     * @throws InvalidAlgorithmParameterException\n-     *     if the information contained within the {@code derivationParameterSpec} is\n-     *     invalid or if the combination of {@code alg} and the {@code derivationParameterSpec}\n-     *     results in something invalid, ie - a key of inappropriate length\n-     *     for the specified algorithm\n-     * @throws NoSuchAlgorithmException\n-     *     if {@code alg} is empty\n-     * @throws NullPointerException\n-     *     if {@code alg} is {@code null}\n-     *\/\n-    @Override\n-    protected SecretKey engineDeriveKey(String alg,\n-                                        AlgorithmParameterSpec derivationSpec)\n-        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n-\n-        if (alg == null) {\n-            throw new NullPointerException(\n-                \"the algorithm for the SecretKey return value must not be null\");\n-        }\n-        if (alg.isEmpty()) {\n-            throw new NoSuchAlgorithmException(\n-                \"the algorithm for the SecretKey return value must not be \"\n-                + \"empty\");\n-        }\n-\n-        return new SecretKeySpec(engineDeriveData(derivationSpec), alg);\n-\n-    }\n-\n-    \/**\n-     * Obtain raw data from a key derivation function.\n-     *\n-     * @return a derived {@code byte[]}\n-     *\n-     * @throws InvalidAlgorithmParameterException\n-     *     if the information contained within the {@code KDFParameterSpec} is\n-     *     invalid or incorrect for the type of key to be derived\n-     * @throws UnsupportedOperationException\n-     *     if the derived keying material is not extractable\n-     *\/\n-    @Override\n-    protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n-                throws InvalidAlgorithmParameterException {\n-        List<SecretKey> ikms, salts;\n-        byte[] inputKeyMaterial, salt, pseudoRandomKey, info;\n-        int length;\n-        \/\/ A switch would be nicer, but we may need to backport this before\n-        \/\/ JDK 17\n-        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable\n-        \/\/ in instanceof either\n-        if (derivationSpec instanceof HKDFParameterSpec.Extract) {\n-            HKDFParameterSpec.Extract anExtract =\n-                (HKDFParameterSpec.Extract) derivationSpec;\n-            ikms = anExtract.ikms();\n-            salts = anExtract.salts();\n-            \/\/ we should be able to combine both of the above Lists of key\n-            \/\/ segments into one SecretKey object each, unless we were passed\n-            \/\/ something bogus or an unexportable P11 key\n-            try {\n-                inputKeyMaterial = consolidateKeyMaterial(ikms);\n-                salt = consolidateKeyMaterial(salts);\n-            } catch (InvalidKeyException ike) {\n-                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n-                    \"Issue encountered when combining ikm or salt values into\"\n-                    + \" single keys\").initCause(ike);\n-            }\n-            \/\/ perform extract\n-            try {\n-                return hkdfExtract(inputKeyMaterial, salt);\n-            } catch (InvalidKeyException ike) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"an HKDF Extract could not be initialized with the given \"\n-                    + \"key or salt material\", ike);\n-            } catch (NoSuchAlgorithmException nsae) {\n-                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n-                \/\/ Since we're defining these values internally, it is unlikely.\n-                throw new ProviderException(\n-                    \"could not instantiate a Mac with the provided algorithm\",\n-                    nsae);\n-            } finally {\n-                Arrays.fill(inputKeyMaterial, (byte)0x00);\n-                Arrays.fill(salt, (byte)0x00);\n-            }\n-        } else if (derivationSpec instanceof HKDFParameterSpec.Expand) {\n-            HKDFParameterSpec.Expand anExpand =\n-                (HKDFParameterSpec.Expand) derivationSpec;\n-            \/\/ set this value in the \"if\"\n-            if ((pseudoRandomKey = anExpand.prk().getEncoded()) == null) {\n-                throw new AssertionError(\n-                    \"PRK is required for HKDFParameterSpec.Expand\");\n-            }\n-            \/\/ set this value in the \"if\"\n-            if ((info = anExpand.info()) == null) {\n-                info = new byte[0];\n-            }\n-            length = anExpand.length();\n-            if (length > (hmacLen * 255)) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"Requested length exceeds maximum allowed length\");\n-            }\n-            \/\/ perform expand\n-            try {\n-                return hkdfExpand(pseudoRandomKey, info, length);\n-            } catch (InvalidKeyException ike) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"an HKDF Expand could not be initialized with the given \"\n-                    + \"keying material\", ike);\n-            } catch (NoSuchAlgorithmException nsae) {\n-                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n-                \/\/ Since we're defining these values internally, it is unlikely.\n-                throw new ProviderException(\n-                    \"could not instantiate a Mac with the provided algorithm\",\n-                    nsae);\n-            } finally {\n-                Arrays.fill(pseudoRandomKey, (byte) 0x00);\n-            }\n-        } else if (derivationSpec instanceof HKDFParameterSpec.ExtractThenExpand) {\n-            HKDFParameterSpec.ExtractThenExpand anExtractThenExpand =\n-                (HKDFParameterSpec.ExtractThenExpand) derivationSpec;\n-            ikms = anExtractThenExpand.ikms();\n-            salts = anExtractThenExpand.salts();\n-            \/\/ we should be able to combine both of the above Lists of key\n-            \/\/ segments into one SecretKey object each, unless we were passed\n-            \/\/ something bogus or an unexportable P11 key\n-            try {\n-                inputKeyMaterial = consolidateKeyMaterial(ikms);\n-                salt = consolidateKeyMaterial(salts);\n-            } catch (InvalidKeyException ike) {\n-                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n-                    \"Issue encountered when combining ikm or salt values into\"\n-                    + \" single keys\").initCause(ike);\n-            }\n-            \/\/ set this value in the \"if\"\n-            if ((info = anExtractThenExpand.info()) == null) {\n-                info = new byte[0];\n-            }\n-            length = anExtractThenExpand.length();\n-            if (length > (hmacLen * 255)) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"Requested length exceeds maximum allowed length\");\n-            }\n-            \/\/ perform extract and then expand\n-            pseudoRandomKey = null;\n-            try {\n-                pseudoRandomKey = hkdfExtract(inputKeyMaterial, salt);\n-                return hkdfExpand(pseudoRandomKey, info, length);\n-            } catch (InvalidKeyException ike) {\n-                throw new InvalidAlgorithmParameterException(\n-                    \"an HKDF ExtractThenExpand could not be initialized with \"\n-                    + \"the given key or salt material\", ike);\n-            } catch (NoSuchAlgorithmException nsae) {\n-                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n-                \/\/ Since we're defining these values internally, it is unlikely.\n-                throw new ProviderException(\n-                    \"could not instantiate a Mac with the provided algorithm\",\n-                    nsae);\n-            } finally {\n-                Arrays.fill(inputKeyMaterial, (byte)0x00);\n-                Arrays.fill(salt, (byte)0x00);\n-                if(pseudoRandomKey != null) {\n-                    Arrays.fill(pseudoRandomKey, (byte)0x00);\n-                }\n-            }\n-        }\n-        throw new InvalidAlgorithmParameterException(\n-            \"an HKDF derivation requires a valid HKDFParameterSpec\");\n-    }\n-\n-    \/\/ throws an InvalidKeyException if any key is unextractable\n-    private byte[] consolidateKeyMaterial(List<SecretKey> keys)\n-        throws InvalidKeyException {\n-        if (keys != null && !keys.isEmpty()) {\n-            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n-            if (localKeys.size() == 1) {\n-                \/\/ return this element\n-                SecretKey checkIt = localKeys.get(0);\n-                return CipherCore.getKeyBytes(checkIt);\n-            } else {\n-                ByteArrayOutputStream os = new ByteArrayOutputStream();\n-                for (SecretKey workItem : localKeys) {\n-                    os.writeBytes(CipherCore.getKeyBytes(workItem));\n-                }\n-                \/\/ deliberately omitting os.flush(), since we are writing to\n-                \/\/ memory, and toByteArray() reads like there isn't an explicit\n-                \/\/ need for this call\n-                return os.toByteArray();\n-            }\n-        } else if(keys != null) {\n-                return new byte[0];\n-        } else {\n-            throw new InvalidKeyException(\n-                \"List of key segments could not be consolidated\");\n-        }\n-    }\n-\n-    \/**\n-     * Perform the HKDF-Extract operation.\n-     *\n-     * @param inputKeyMaterial\n-     *     the input keying material used for the HKDF-Extract operation.\n-     * @param salt\n-     *     the salt value used for HKDF-Extract\n-     *\n-     * @return a byte array containing the pseudorandom key (PRK)\n-     *\n-     * @throws InvalidKeyException\n-     *     if an invalid salt was provided through the\n-     *     {@code HkdfParameterSpec}\n-     *\/\n-    private byte[] hkdfExtract(byte[] inputKeyMaterial, byte[] salt)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-\n-        \/\/ salt will not be null\n-        if (salt.length == 0) {\n-            salt = new byte[hmacLen];\n-        }\n-        Mac hmacObj = Mac.getInstance(hmacAlgName);\n-        hmacObj.init(new SecretKeySpec(salt, hmacAlgName));\n-\n-        \/\/ inputKeyMaterial will not be null\n-        return hmacObj.doFinal(inputKeyMaterial);\n-    }\n-\n-    \/**\n-     * Perform the HKDF-Expand operation.\n-     *\n-     * @param prk\n-     *     the pseudorandom key used for HKDF-Expand\n-     * @param info\n-     *     optional context and application specific information or {@code null}\n-     *     if no info data is provided.\n-     * @param outLen\n-     *     the length in bytes of the required output\n-     *\n-     * @return a byte array containing the complete KDF output.  This will be at\n-     *     least as long as the requested length in the {@code outLen}\n-     *     parameter, but will be rounded up to the nearest multiple of the HMAC\n-     *     output length.\n-     *\n-     * @throws InvalidKeyException\n-     *     if an invalid PRK was provided through the {@code HKDFParameterSpec}\n-     *     or derived during the extract phase.\n-     *\/\n-    private byte[] hkdfExpand(byte[] prk, byte[] info, int outLen)\n-        throws InvalidKeyException, NoSuchAlgorithmException {\n-        byte[] kdfOutput;\n-\n-        if (prk == null || prk.length < hmacLen) {\n-            throw new InvalidKeyException(\n-                \"prk must be at least \" + hmacLen + \" bytes\");\n-        }\n-\n-        SecretKey pseudoRandomKey = new SecretKeySpec(prk, hmacAlgName);\n-\n-        Mac hmacObj = Mac.getInstance(hmacAlgName);\n-\n-        \/\/ Calculate the number of rounds of HMAC that are needed to\n-        \/\/ meet the requested data.  Then set up the buffers we will need.\n-        hmacObj.init(pseudoRandomKey);\n-        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n-        kdfOutput = new byte[outLen];\n-        int i = 0;\n-        int offset = 0;\n-        try {\n-            while (i < rounds) {\n-                if (i > 0) {\n-                    hmacObj.update(kdfOutput, offset - hmacLen, hmacLen); \/\/ add T(i-1)\n-                }\n-                hmacObj.update(info);                   \/\/ Add info\n-                hmacObj.update((byte) ++i);             \/\/ Add round number\n-                if (i == rounds && (outLen - offset < hmacLen)) {\n-                    \/\/ special handling for last chunk\n-                    byte[] tmp = hmacObj.doFinal();\n-                    System.arraycopy(tmp, 0, kdfOutput, offset,\n-                                     outLen - offset);\n-                    Arrays.fill(tmp, (byte)0x00);\n-                    offset = outLen;\n-                } else {\n-                    hmacObj.doFinal(kdfOutput, offset);\n-                    offset += hmacLen;\n-                }\n-            }\n-        } catch (ShortBufferException sbe) {\n-            \/\/ This really shouldn't happen given that we've\n-            \/\/ sized the buffers to their largest possible size up-front,\n-            \/\/ but just in case...\n-            throw new ProviderException(sbe);\n-        }\n-        return kdfOutput;\n-    }\n-\n-    protected KDFParameters engineGetParameters() {\n-        return null;\n-    }\n-\n-    public static final class HkdfSHA256 extends HkdfKeyDerivation {\n-        public HkdfSHA256(KDFParameters kdfParameters)\n-            throws InvalidAlgorithmParameterException {\n-            super(\"HmacSHA256\", SHA256_HMAC_SIZE, kdfParameters);\n-        }\n-    }\n-\n-    public static final class HkdfSHA384 extends HkdfKeyDerivation {\n-        public HkdfSHA384(KDFParameters kdfParameters)\n-            throws InvalidAlgorithmParameterException {\n-            super(\"HmacSHA384\", SHA384_HMAC_SIZE, kdfParameters);\n-        }\n-    }\n-\n-    public static final class HkdfSHA512 extends HkdfKeyDerivation {\n-        public HkdfSHA512(KDFParameters kdfParameters)\n-            throws InvalidAlgorithmParameterException {\n-            super(\"HmacSHA512\", SHA512_HMAC_SIZE, kdfParameters);\n-        }\n-    }\n-\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":0,"deletions":415,"binary":false,"changes":415,"status":"deleted"},{"patch":"@@ -464,1 +464,1 @@\n-                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA256\");\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA256\");\n@@ -466,1 +466,1 @@\n-                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA384\");\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA384\");\n@@ -468,1 +468,1 @@\n-                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA512\");\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA512\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * keying material and (optionally) other data.\n+ * keying material (IKM) and (optionally) other data.\n@@ -91,2 +91,2 @@\n- * provider supporting the KDF algorithm and optional {@code KDFParameters} is\n- * chosen. This provider may not support the key material that is subsequently\n+ * provider supporting the {@code KDF} algorithm and optional {@code KDFParameters}\n+ * is chosen. This provider may not support the key material that is subsequently\n@@ -515,1 +515,1 @@\n-     * Derives a key, returned as a {@code SecretKey}.\n+     * Derives a key, returned as a {@code SecretKey} object.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,4 +103,1 @@\n-     * Derives a key, returned as a {@code SecretKey}.\n-     * <p>\n-     * The {@code engineDeriveKey} method may be called multiple times on a particular\n-     * {@code KDFSpi} instance, but it is not considered thread-safe.\n+     * Derives a key, returned as a {@code SecretKey} object.\n@@ -134,3 +131,0 @@\n-     * <p>\n-     * The {@code engineDeriveData} method may be called multiple times on a\n-     * particular {@code KDFSpi} instance, but it is not considered thread-safe.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,3 +44,3 @@\n- * for use-cases where a portion of the IKM resides in a non-extractable\n- * {@code SecretKey} and the whole IKM cannot be provided as a single object.\n- * The caller may wish to provide a label (or other components) of\n+ * for use-cases where a portion of the input keying material (IKM) resides in a\n+ * non-extractable {@code SecretKey} and the whole IKM cannot be provided as a\n+ * single object. The caller may wish to provide a label (or other components) of\n@@ -119,1 +119,1 @@\n-         * Builds an {@code Extract} from the current state of the\n+         * Builds an {@code Extract} object from the current state of the\n@@ -122,1 +122,1 @@\n-         * @return an immutable {@code Extract}\n+         * @return an immutable {@code Extract} object\n@@ -129,1 +129,1 @@\n-         * Builds an {@code ExtractThenExpand}.\n+         * Builds an {@code ExtractThenExpand} object.\n@@ -141,1 +141,1 @@\n-         * @return an {@code ExtractThenExpand}\n+         * @return an {@code ExtractThenExpand} object\n@@ -153,1 +153,1 @@\n-         * Adds input keying material to the builder.\n+         * Adds input keying material (IKM) to the builder.\n@@ -161,1 +161,1 @@\n-         *     the input keying material value\n+         *     the input keying material (IKM) value\n@@ -166,1 +166,1 @@\n-         *     if the {@code ikm} is null\n+         *     if the {@code ikm} argument is null\n@@ -175,1 +175,1 @@\n-         * Adds input keying material to the builder.\n+         * Adds input keying material (IKM) to the builder.\n@@ -183,1 +183,1 @@\n-         *     the input keying material value\n+         *     the input keying material (IKM) value\n@@ -188,1 +188,1 @@\n-         *     if the {@code ikm} is null\n+         *     if the {@code ikm} argument is null\n@@ -261,1 +261,1 @@\n-     *     the pseudorandom key; must not be {@code null}\n+     *     the pseudorandom key (PRK); must not be {@code null}\n@@ -270,2 +270,2 @@\n-     * 255 * HMAC length. Implementations will also enforce that the prk is at least as\n-     * many bytes as the HMAC length.\n+     * 255 * HMAC length. Implementations will also enforce that the prk argument\n+     * is at least as many bytes as the HMAC length.\n@@ -273,1 +273,1 @@\n-     * @return a new {@code Expand} object\n+     * @return an {@code Expand} object\n@@ -276,1 +276,1 @@\n-     *     if {@code prk} is {@code null}\n+     *     if the {@code prk} argument is {@code null}\n@@ -354,2 +354,3 @@\n-         *     the pseudorandom key; in the case of {@code ExtractThenExpand},\n-         *     prk may be {@null} since the output of extract phase is used\n+         *     the pseudorandom key (PRK); in the case of {@code ExtractThenExpand},\n+         *     the {@code prk} argument may be {@null} since the output of\n+         *     extract phase is used\n@@ -358,1 +359,1 @@\n-         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     {@code null}); the byte array is copied to prevent subsequent\n@@ -367,1 +368,1 @@\n-            \/\/ a null prk could be indicative of ExtractThenExpand\n+            \/\/ a null prk argument could be indicative of ExtractThenExpand\n@@ -377,1 +378,1 @@\n-         * Returns the pseudorandom key.\n+         * Returns the pseudorandom key (PRK).\n@@ -423,1 +424,1 @@\n-         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     {@code null}); the byte array is copied to prevent subsequent\n@@ -434,1 +435,1 @@\n-            \/\/ - null prk is ok here (it's a signal)\n+            \/\/ - null prk argument is ok here (it's a signal)\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"}]}