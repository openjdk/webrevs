{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.test.lib.Utils;\n@@ -36,0 +37,2 @@\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n@@ -75,0 +78,8 @@\n+\n+        \/\/ EXPECTED EXCEPTIONS\n+\n+        \/\/ short PRK should throw IAPE\n+        Utils.runAndCheckException(() -> test(HKDFParameterSpec.expandOnly(new SecretKeySpec(new byte[] {0x00}, \"PRK\"), null, 32)), InvalidAlgorithmParameterException.class);\n+\n+        \/\/ long length should throw IAPE; 8162 is greater than 255 * hmacLen\n+        Utils.runAndCheckException(() -> test(HKDFParameterSpec.expandOnly(new SecretKeySpec(expectedPrk, \"PRK\"), null, 8162 )), InvalidAlgorithmParameterException.class);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFBasicFunctionsTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary addIKM and addSalt consistency checks\n+ * @library \/test\/lib\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class HKDFSaltIKMTest {\n+    byte[] concat(List<SecretKey> items) {\n+        return items.stream().map(SecretKey::getEncoded)\n+                    .reduce(new byte[0], (a, b) -> {\n+                        byte[] c = Arrays.copyOf(a, a.length + b.length);\n+                        System.arraycopy(b, 0, c, a.length, b.length);\n+                        return c;\n+                    });\n+    }\n+    static String[] NAMES = {\"HKDF-SHA256\", \"HKDF-SHA384\", \"HKDF-SHA512\"};\n+    public static void main(String[] args) throws Exception {\n+        var r = SeededSecureRandom.one();\n+        var atlast = 0;\n+        KDF kdf = null;\n+        var alg = \"\";\n+        for (var i = 0; i < 1_000_000; i++) {\n+            if (kdf == null || r.nextBoolean()) {\n+                alg = NAMES[r.nextInt(3)];\n+                kdf = KDF.getInstance(alg); \/\/ randomly recreate KDF object\n+            }\n+            var b = HKDFParameterSpec.ofExtract();\n+            var salts = new ByteArrayOutputStream(); \/\/ accumulate salt fragments\n+            var ikms = new ByteArrayOutputStream(); \/\/ accumulate ikm fragments\n+            while (r.nextBoolean()) {\n+                if (r.nextBoolean()) {\n+                    var ikm = r.nBytes(r.nextInt(10));\n+                    if (r.nextBoolean() && ikm.length > 0) {\n+                        b.addIKM(new SecretKeySpec(ikm, \"X\"));\n+                    } else {\n+                        b.addIKM(ikm);\n+                    }\n+                    ikms.writeBytes(ikm);\n+                } else {\n+                    var salt = r.nBytes(r.nextInt(10));\n+                    if (r.nextBoolean() && salt.length > 0) {\n+                        b.addSalt(new SecretKeySpec(salt, \"X\"));\n+                    } else {\n+                        b.addSalt(salt);\n+                    }\n+                    salts.writeBytes(salt);\n+                }\n+            }\n+            var info = r.nextBoolean() ? null : r.nBytes(r.nextInt(100));\n+            var l = r.nextInt(200) + 1;\n+            var kdf2 = r.nextBoolean() ? kdf : KDF.getInstance(alg);\n+            var k1 = kdf2.deriveData(HKDFParameterSpec.ofExtract().addIKM(ikms.toByteArray())\n+                                                      .addSalt(salts.toByteArray()).thenExpand(info, l));\n+            atlast = Arrays.hashCode(k1) + 17 * atlast;\n+            if (r.nextBoolean()) {\n+                var k2 = kdf.deriveData(b.thenExpand(info, l));\n+                Asserts.assertEqualsByteArray(k1, k2);\n+            } else {\n+                var prk = kdf.deriveKey(\"PRK\", b.extractOnly());\n+                var k2 = kdf.deriveData(HKDFParameterSpec.expandOnly(prk, info, l));\n+                Asserts.assertEqualsByteArray(k1, k2);\n+            }\n+        }\n+        System.out.println(atlast);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFSaltIKMTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}