{"files":[{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import javax.crypto.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * KDF implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC\n+ * 5869.  This implementation provides the complete Extract-then-Expand HKDF\n+ * function as well as Extract-only and Expand-only variants.\n+ *\/\n+abstract class HKDFKeyDerivation extends KDFSpi {\n+\n+    private final int hmacLen;\n+    private final String hmacAlgName;\n+\n+    private enum SupportedHmac {\n+        SHA256(\"HmacSHA256\", 32),\n+        SHA384(\"HmacSHA384\", 48),\n+        SHA512(\"HmacSHA512\", 64);\n+\n+        private final String hmacAlg;\n+        private final int hmacLen;\n+        SupportedHmac(String hmacAlg, int hmacLen) {\n+            this.hmacAlg = hmacAlg;\n+            this.hmacLen = hmacLen;\n+        }\n+    };\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param kdfParameters\n+     *         the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the initialization parameters are inappropriate for this\n+     *         {@code KDFSpi}\n+     *\/\n+    private HKDFKeyDerivation(SupportedHmac supportedHmac,\n+                              KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+        super(kdfParameters);\n+        if (kdfParameters != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    supportedHmac.hmacAlg + \" does not support parameters\");\n+        }\n+        this.hmacAlgName = supportedHmac.hmacAlg;\n+        this.hmacLen = supportedHmac.hmacLen;\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey} object.\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code derivationSpec} is\n+     *         invalid or if the combination of {@code alg} and the\n+     *         {@code derivationSpec} results in something invalid\n+     * @throws NoSuchAlgorithmException\n+     *         if {@code alg} is empty\n+     * @throws NullPointerException\n+     *         if {@code alg} is {@code null}\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg,\n+                                        AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException,\n+                   NoSuchAlgorithmException {\n+\n+        if (alg == null) {\n+            throw new NullPointerException(\n+                    \"the algorithm for the SecretKey return value must not be\"\n+                    + \" null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\n+                    \"the algorithm for the SecretKey return value must not be \"\n+                    + \"empty\");\n+        }\n+\n+        return new SecretKeySpec(engineDeriveData(derivationSpec), alg);\n+\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code KDFParameterSpec}\n+     *         is invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *         if the derived keying material is not extractable\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+        List<SecretKey> ikms, salts;\n+        byte[] inputKeyMaterial, salt, pseudoRandomKey, info;\n+        int length;\n+        if (derivationSpec instanceof HKDFParameterSpec.Extract anExtract) {\n+            ikms = anExtract.ikms();\n+            salts = anExtract.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            inputKeyMaterial = null;\n+            salt = null;\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+\n+                \/\/ perform extract\n+                return hkdfExtract(inputKeyMaterial, salt);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"an HKDF Extract could not be initialized with the \"\n+                        + \"given key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                        \"could not instantiate a Mac with the provided \"\n+                        + \"algorithm\",\n+                        nsae);\n+            } finally {\n+                if (inputKeyMaterial != null) {\n+                    Arrays.fill(inputKeyMaterial, (byte) 0x00);\n+                }\n+                if (salt != null) {\n+                    Arrays.fill(salt, (byte) 0x00);\n+                }\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.Expand anExpand) {\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk().getEncoded()) == null) {\n+                throw new AssertionError(\n+                        \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"Requested length exceeds maximum allowed length\");\n+            }\n+            \/\/ perform expand\n+            try {\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"an HKDF Expand could not be initialized with the \"\n+                        + \"given keying material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                        \"could not instantiate a Mac with the provided \"\n+                        + \"algorithm\",\n+                        nsae);\n+            } finally {\n+                Arrays.fill(pseudoRandomKey, (byte) 0x00);\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.ExtractThenExpand anExtractThenExpand) {\n+            ikms = anExtractThenExpand.ikms();\n+            salts = anExtractThenExpand.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            inputKeyMaterial = null;\n+            salt = null;\n+            pseudoRandomKey = null;\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+\n+                \/\/ set this value in the \"if\"\n+                if ((info = anExtractThenExpand.info()) == null) {\n+                    info = new byte[0];\n+                }\n+                length = anExtractThenExpand.length();\n+                if (length > (hmacLen * 255)) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Requested length exceeds maximum allowed length\");\n+                }\n+\n+                \/\/ perform extract and then expand\n+                pseudoRandomKey = hkdfExtract(inputKeyMaterial, salt);\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"an HKDF ExtractThenExpand could not be initialized \"\n+                        + \"with the given key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/HMAC.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                        \"could not instantiate a Mac with the provided \"\n+                        + \"algorithm\",\n+                        nsae);\n+            } finally {\n+                if (inputKeyMaterial != null) {\n+                    Arrays.fill(inputKeyMaterial, (byte) 0x00);\n+                }\n+                if (salt != null) {\n+                    Arrays.fill(salt, (byte) 0x00);\n+                }\n+                if (pseudoRandomKey != null) {\n+                    Arrays.fill(pseudoRandomKey, (byte) 0x00);\n+                }\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+                \"an HKDF derivation requires a valid HKDFParameterSpec\");\n+    }\n+\n+    \/\/ throws an InvalidKeyException if any key is unextractable\n+    private byte[] consolidateKeyMaterial(List<SecretKey> keys)\n+            throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                SecretKey checkIt = localKeys.get(0);\n+                return CipherCore.getKeyBytes(checkIt);\n+            } else {\n+                ByteArrayOutputStream os = new ByteArrayOutputStream();\n+                for (SecretKey workItem : localKeys) {\n+                    os.writeBytes(CipherCore.getKeyBytes(workItem));\n+                }\n+                \/\/ deliberately omitting os.flush(), since we are writing to\n+                \/\/ memory, and toByteArray() reads like there isn't an explicit\n+                \/\/ need for this call\n+                return os.toByteArray();\n+            }\n+        } else if (keys != null) {\n+            return new byte[0];\n+        } else {\n+            throw new InvalidKeyException(\n+                    \"List of key segments could not be consolidated\");\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Extract operation.\n+     *\n+     * @param inputKeyMaterial\n+     *         the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *         the salt value used for HKDF-Extract\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *         if an invalid salt was provided through the\n+     *         {@code HKDFParameterSpec}\n+     *\/\n+    private byte[] hkdfExtract(byte[] inputKeyMaterial, byte[] salt)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+\n+        \/\/ salt will not be null\n+        if (salt.length == 0) {\n+            salt = new byte[hmacLen];\n+        }\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+        hmacObj.init(new SecretKeySpec(salt, hmacAlgName));\n+\n+        \/\/ inputKeyMaterial will not be null\n+        return hmacObj.doFinal(inputKeyMaterial);\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Expand operation.\n+     *\n+     * @param prk\n+     *         the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *         optional context and application specific information or\n+     *         {@code null} if no info data is provided.\n+     * @param outLen\n+     *         the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete {@code KDF} output.  This\n+     *         will be at least as long as the requested length in the\n+     *         {@code outLen} parameter, but will be rounded up to the nearest\n+     *         multiple of the HMAC output length.\n+     *\n+     * @throws InvalidKeyException\n+     *         if an invalid PRK was provided through the\n+     *         {@code HKDFParameterSpec} or derived during the extract phase.\n+     *\/\n+    private byte[] hkdfExpand(byte[] prk, byte[] info, int outLen)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+        byte[] kdfOutput;\n+\n+        if (prk == null || prk.length < hmacLen) {\n+            throw new InvalidKeyException(\n+                    \"prk must be at least \" + hmacLen + \" bytes\");\n+        }\n+\n+        SecretKey pseudoRandomKey = new SecretKeySpec(prk, hmacAlgName);\n+\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        hmacObj.init(pseudoRandomKey);\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[outLen];\n+        int i = 0;\n+        int offset = 0;\n+        try {\n+            while (i < rounds) {\n+                if (i > 0) {\n+                    hmacObj.update(kdfOutput, offset - hmacLen,\n+                                   hmacLen); \/\/ add T(i-1)\n+                }\n+                hmacObj.update(info);                   \/\/ Add info\n+                hmacObj.update((byte) ++i);             \/\/ Add round number\n+                if (i == rounds && (outLen - offset < hmacLen)) {\n+                    \/\/ special handling for last chunk\n+                    byte[] tmp = hmacObj.doFinal();\n+                    System.arraycopy(tmp, 0, kdfOutput, offset,\n+                                     outLen - offset);\n+                    Arrays.fill(tmp, (byte) 0x00);\n+                    offset = outLen;\n+                } else {\n+                    hmacObj.doFinal(kdfOutput, offset);\n+                    offset += hmacLen;\n+                }\n+            }\n+        } catch (ShortBufferException sbe) {\n+            \/\/ This really shouldn't happen given that we've\n+            \/\/ sized the buffers to their largest possible size up-front,\n+            \/\/ but just in case...\n+            throw new ProviderException(sbe);\n+        }\n+        return kdfOutput;\n+    }\n+\n+    protected KDFParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    public static final class HKDFSHA256 extends HKDFKeyDerivation {\n+        public HKDFSHA256(KDFParameters kdfParameters)\n+                throws InvalidAlgorithmParameterException {\n+            super(SupportedHmac.SHA256, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HKDFSHA384 extends HKDFKeyDerivation {\n+        public HKDFSHA384(KDFParameters kdfParameters)\n+                throws InvalidAlgorithmParameterException {\n+            super(SupportedHmac.SHA384, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HKDFSHA512 extends HKDFKeyDerivation {\n+        public HKDFSHA512(KDFParameters kdfParameters)\n+                throws InvalidAlgorithmParameterException {\n+            super(SupportedHmac.SHA512, kdfParameters);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HKDFKeyDerivation.java","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -460,0 +460,10 @@\n+        \/*\n+         * Key Derivation engines\n+         *\/\n+        ps(\"KDF\", \"HKDF-SHA256\",\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA256\");\n+        ps(\"KDF\", \"HKDF-SHA384\",\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA384\");\n+        ps(\"KDF\", \"HKDF-SHA512\",\n+                \"com.sun.crypto.provider.HKDFKeyDerivation$HKDFSHA512\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import javax.crypto.KDFParameters;\n@@ -1607,0 +1608,1 @@\n+        addEngine(\"KDF\",                                false, KDFParameters.class);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,679 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.GetInstance.Instance;\n+import sun.security.util.Debug;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Security;\n+import java.security.Provider;\n+import java.security.Provider.Service;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Derivation Function (KDF),\n+ * which is a cryptographic algorithm for deriving additional keys from input\n+ * keying material (IKM) and (optionally) other data.\n+ * <p>\n+ * {@code KDF} objects are instantiated with the {@code getInstance} family of\n+ * methods.\n+ * <p>\n+ * The class has two derive methods, {@code deriveKey} and {@code deriveData}.\n+ * The {@code deriveKey} method accepts an algorithm name and returns a\n+ * {@code SecretKey} object with the specified algorithm. The {@code deriveData}\n+ * method returns a byte array of raw data.\n+ * <p>\n+ * API Usage Example:\n+ * {@snippet lang = java:\n+ *    KDF kdfHkdf = KDF.getInstance(\"HKDF-SHA256\");\n+ *\n+ *    AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 32);\n+ *\n+ *    SecretKey sKey = kdfHkdf.deriveKey(\"AES\", derivationSpec);\n+ *}\n+ * <br>\n+ * <h2><a id=\"ConcurrentAccess\">Concurrent Access<\/a><\/h2>\n+ * Unless otherwise documented by an implementation, the methods defined in this\n+ * class are not thread-safe. Multiple threads that need to access a single\n+ * object concurrently should synchronize amongst themselves and provide the\n+ * necessary locking. Multiple threads each manipulating separate objects need\n+ * not synchronize.\n+ * <br>\n+ * <h2><a id=\"DelayedProviderSelection\">Delayed Provider Selection<\/a><\/h2>\n+ * If a provider is not specified when calling one of the {@code getInstance}\n+ * methods, the implementation delays the selection of the provider until the\n+ * {@code deriveKey} or {@code deriveData} method is called. This is called\n+ * <i>delayed provider selection<\/i>. The primary reason this is done is to\n+ * ensure that the selected provider can handle the key material that is passed\n+ * to those methods - for example, the key material may reside on a hardware\n+ * device that only a specific {@code KDF} provider can utilize. The {@code\n+ * getInstance} method returns a {@code KDF} object as long as there exists\n+ * at least one registered security provider that implements the algorithm\n+ * and supports the optional parameters. The delayed provider selection\n+ * process traverses the list of registered security providers, starting with\n+ * the most preferred {@code Provider}. The first provider that supports the\n+ * specified algorithm, optional parameters, and key material is selected.\n+ * <p>\n+ * If the {@code getProviderName} or {@code getParameters} method is called\n+ * before the {@code deriveKey} or {@code deriveData} methods, the first\n+ * provider supporting the {@code KDF} algorithm and optional\n+ * {@code KDFParameters} is chosen. This provider may not support the key\n+ * material that is subsequently passed to the {@code deriveKey} or\n+ * {@code deriveData} methods. Therefore, it is recommended not to call the\n+ * {@code getProviderName} or {@code getParameters} methods until after a key\n+ * derivation operation. Once a provider is selected, it cannot be changed.\n+ *\n+ * @see KDFParameters\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public final class KDF {\n+\n+    private static final Debug pdebug = Debug.getInstance(\"provider\",\n+                                                          \"Provider\");\n+    private static final boolean skipDebug = Debug.isOn(\"engine=\")\n+                                             && !Debug.isOn(\"kdf\");\n+\n+    private record Delegate(KDFSpi spi, Provider provider) {}\n+\n+    \/\/guarded by 'lock'\n+    private Delegate theOne;\n+    \/\/guarded by 'lock'\n+    private final Delegate candidate;\n+\n+    \/\/ The name of the KDF algorithm.\n+    private final String algorithm;\n+\n+    \/\/ Additional KDF configuration parameters\n+    private final KDFParameters kdfParameters;\n+\n+    \/\/ remaining services to try in provider selection\n+    \/\/ null once provider is selected\n+    private final Iterator<Service> serviceIterator;\n+\n+    \/\/ This lock provides mutual exclusion, preventing multiple threads from\n+    \/\/ concurrently initializing the same instance (delayed provider selection)\n+    \/\/ in a way which would corrupt the internal state.\n+    private final Object lock = new Object();\n+\n+\n+    \/\/ Instantiates a {@code KDF} object. This constructor is called when a\n+    \/\/ provider is supplied to {@code getInstance}.\n+    \/\/\n+    \/\/ @param delegate the delegate\n+    \/\/ @param algorithm the algorithm\n+    \/\/ @param kdfParameters the parameters\n+    private KDF(Delegate delegate, String algorithm) {\n+        this.theOne = delegate;\n+        this.algorithm = algorithm;\n+        \/\/ note that the parameters are being passed to the impl in getInstance\n+        this.kdfParameters = null;\n+        this.candidate = null;\n+        serviceIterator = null;\n+    }\n+\n+    \/\/ Instantiates a {@code KDF} object. This constructor is called when a\n+    \/\/ provider is not supplied to {@code getInstance}.\n+    \/\/\n+    \/\/ @param firstPairOfSpiAndProv the delegate\n+    \/\/ @param t the service iterator\n+    \/\/ @param algorithm the algorithm\n+    \/\/ @param kdfParameters the algorithm parameters\n+    private KDF(Delegate firstPairOfSpiAndProv, Iterator<Service> t,\n+                String algorithm,\n+                KDFParameters kdfParameters) {\n+        this.candidate = firstPairOfSpiAndProv;\n+        serviceIterator = t;\n+        this.algorithm = algorithm;\n+        this.kdfParameters = kdfParameters;\n+    }\n+\n+    \/**\n+     * Returns the algorithm name of this {@code KDF} object.\n+     *\n+     * @return the algorithm name of this {@code KDF} object\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+\n+    \/**\n+     * Returns the name of the provider.\n+     *\n+     * @return the name of the provider\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\/\n+    public String getProviderName() {\n+        useFirstSpi();\n+        return theOne.provider().getName();\n+    }\n+\n+    \/**\n+     * Returns the {@code KDFParameters} used with this {@code KDF} object.\n+     * <p>\n+     * The returned parameters may be the same that were used to initialize\n+     * this {@code KDF} object, or may contain additional default or\n+     * random parameter values used by the underlying KDF algorithm.\n+     * If the required parameters were not supplied and can be generated by\n+     * the {@code KDF} object, the generated parameters are returned;\n+     * otherwise {@code null} is returned.\n+     *\n+     * @return the parameters used with this {@code KDF} object, or\n+     *         {@code null}\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\/\n+    public KDFParameters getParameters() {\n+        useFirstSpi();\n+        return theOne.spi().engineGetParameters();\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if no {@code Provider} supports a {@code KDF} implementation for\n+     *         the specified algorithm\n+     * @throws NullPointerException\n+     *         if {@code algorithm} is {@code null}\n+     * @implNote The JDK Reference Implementation additionally uses the\n+     *         {@code jdk.security.provider.preferred}\n+     *         {@link Security#getProperty(String) Security} property to\n+     *         determine the preferred provider order for the specified\n+     *         algorithm. This may be different than the order of providers\n+     *         returned by\n+     *         {@link Security#getProviders() Security.getProviders()}.\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\/\n+    public static KDF getInstance(String algorithm)\n+            throws NoSuchAlgorithmException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        try {\n+            return getInstance(algorithm, (KDFParameters) null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                    \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider. The specified provider must be\n+     * registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     * @param provider\n+     *         the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if the specified provider does not support the specified\n+     *         {@code KDF} algorithm\n+     * @throws NoSuchProviderException\n+     *         if the specified provider is not registered in the security\n+     *         provider list\n+     * @throws NullPointerException\n+     *         if {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                    \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     * @param provider\n+     *         the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if the specified provider does not support the specified\n+     *         {@code KDF} algorithm\n+     * @throws NullPointerException\n+     *         if {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, Provider provider)\n+            throws NoSuchAlgorithmException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                    \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm and\n+     * is initialized with the specified parameters.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *         the {@code KDFParameters} used to configure the derivation\n+     *         algorithm or {@code null} if no parameters are provided\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if no {@code Provider} supports a {@code KDF} implementation for\n+     *         the specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *         if at least one {@code Provider} supports a {@code KDF}\n+     *         implementation for the specified algorithm but none of them\n+     *         support the specified parameters\n+     * @throws NullPointerException\n+     *         if {@code algorithm} is {@code null}\n+     * @implNote The JDK Reference Implementation additionally uses the\n+     *         {@code jdk.security.provider.preferred}\n+     *         {@link Security#getProperty(String) Security} property to\n+     *         determine the preferred provider order for the specified\n+     *         algorithm. This may be different than the order of providers\n+     *         returned by\n+     *         {@link Security#getProviders() Security.getProviders()}.\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters)\n+            throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        \/\/ make sure there is at least one service from a signed provider\n+        Iterator<Service> t = GetInstance.getServices(\"KDF\", algorithm);\n+\n+        Delegate d = getNext(t, kdfParameters);\n+        return (t.hasNext() ?\n+                        new KDF(d, t, algorithm, kdfParameters) :\n+                        new KDF(d, algorithm));\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     * The specified provider must be registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *         the {@code KDFParameters} used to configure the derivation\n+     *         algorithm or {@code null} if no parameters are provided\n+     * @param provider\n+     *         the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if the specified provider does not support the specified\n+     *         {@code KDF} algorithm\n+     * @throws NoSuchProviderException\n+     *         if the specified provider is not registered in the security\n+     *         provider list\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the specified provider does not support a {@code KDF}\n+     *         implementation for the specified algorithm and parameters\n+     * @throws NullPointerException\n+     *         if {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException,\n+                   InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+\n+        Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                    algorithm,\n+                                                    kdfParameters,\n+                                                    provider);\n+        if (!JceSecurity.canUseProvider(instance.provider)) {\n+            String msg = \"JCE cannot authenticate the provider \"\n+                         + instance.provider.getName();\n+            throw new NoSuchProviderException(msg);\n+        }\n+        return new KDF(new Delegate((KDFSpi) instance.impl,\n+                                    instance.provider), algorithm\n+        );\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     *\n+     * @param algorithm\n+     *         the key derivation algorithm to use. See the {@code KDF} section\n+     *         in the <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *         Java Security Standard Algorithm Names Specification<\/a> for\n+     *         information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *         the {@code KDFParameters} used to configure the derivation\n+     *         algorithm or {@code null} if no parameters are provided\n+     * @param provider\n+     *         the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *         if the specified provider does not support the specified\n+     *         {@code KDF} algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the specified provider does not support a {@code KDF}\n+     *         implementation for the specified algorithm and parameters\n+     * @throws NullPointerException\n+     *         if {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  Provider provider)\n+            throws NoSuchAlgorithmException,\n+                   InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                    algorithm,\n+                                                    kdfParameters,\n+                                                    provider);\n+        if (!JceSecurity.canUseProvider(instance.provider)) {\n+            String msg = \"JCE cannot authenticate the provider \"\n+                         + instance.provider.getName();\n+            throw new SecurityException(msg);\n+        }\n+        return new KDF(new Delegate((KDFSpi) instance.impl,\n+                                    instance.provider), algorithm\n+        );\n+    }\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey} object.\n+     *\n+     * @param alg\n+     *         the algorithm of the resultant {@code SecretKey} object\n+     * @param derivationSpec\n+     *         the object describing the inputs to the derivation function\n+     *\n+     * @return the derived key\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code derivationSpec} is\n+     *         invalid or if the combination of {@code alg} and the\n+     *         {@code derivationSpec} results in something invalid\n+     * @throws NoSuchAlgorithmException\n+     *         if {@code alg} is empty or invalid\n+     * @throws NullPointerException\n+     *         if {@code alg} or {@code derivationSpec} is null\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\n+     *\/\n+    public SecretKey deriveKey(String alg,\n+                               AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException,\n+                   NoSuchAlgorithmException {\n+        if (alg == null) {\n+            throw new NullPointerException(\n+                    \"the algorithm for the SecretKey return value must not be\"\n+                    + \" null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\n+                    \"the algorithm for the SecretKey return value must not be \"\n+                    + \"empty\");\n+        }\n+        Objects.requireNonNull(derivationSpec);\n+        if (checkSpiNonNull(theOne)) {\n+            return theOne.spi().engineDeriveKey(alg, derivationSpec);\n+        } else {\n+            return (SecretKey) chooseProvider(alg, derivationSpec);\n+        }\n+    }\n+\n+    \/**\n+     * Derives a key, returns raw data as a byte array.\n+     *\n+     * @param derivationSpec\n+     *         the object describing the inputs to the derivation function\n+     *\n+     * @return the derived key in its raw bytes\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code derivationSpec} is\n+     *         invalid\n+     * @throws UnsupportedOperationException\n+     *         if the derived keying material is not extractable\n+     * @throws NullPointerException\n+     *         if {@code derivationSpec} is null\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider\n+     *         Selection<\/a>\n+     *\n+     *\/\n+    public byte[] deriveData(AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+\n+        Objects.requireNonNull(derivationSpec);\n+        if (checkSpiNonNull(theOne)) {\n+            return theOne.spi().engineDeriveData(derivationSpec);\n+        } else {\n+            try {\n+                return (byte[]) chooseProvider(null, derivationSpec);\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ this will never be thrown in the deriveData case\n+                throw new AssertionError(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Use the firstSpi as the chosen KDFSpi and set the fields accordingly\n+     *\/\n+    private void useFirstSpi() {\n+        if (checkSpiNonNull(theOne)) return;\n+\n+        synchronized (lock) {\n+            if (!checkSpiNonNull(theOne)) {\n+                theOne = candidate;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Selects the provider which supports the passed {@code algorithm} and\n+     * {@code derivationSpec} values, and assigns the global spi and provider\n+     * variables if they have not been assigned yet.\n+     * <p>\n+     * If the spi has already been set, it will just return the result.\n+     *\/\n+    private Object chooseProvider(String algorithm,\n+                                  AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException,\n+                   NoSuchAlgorithmException {\n+\n+        boolean isDeriveData = (algorithm == null);\n+\n+        synchronized (lock) {\n+            if (checkSpiNonNull(theOne)) {\n+                return (isDeriveData) ?\n+                               theOne.spi().engineDeriveData(derivationSpec) :\n+                               theOne.spi().engineDeriveKey(algorithm, derivationSpec);\n+            }\n+\n+            Exception lastException = null;\n+            if (!checkSpiNonNull(candidate)) {\n+                throw new AssertionError(\"Unexpected Error: candidate is null!\");\n+            }\n+            Delegate currOne = candidate;\n+            try {\n+                while (true) {\n+                    try {\n+                        Object result = (isDeriveData) ?\n+                                currOne.spi().engineDeriveData(derivationSpec) :\n+                                currOne.spi().engineDeriveKey(algorithm,\n+                                        derivationSpec);\n+                        \/\/ found a working KDFSpi\n+                        this.theOne = currOne;\n+                        return result;\n+                    } catch (Exception e) {\n+                        if (!skipDebug && pdebug != null) {\n+                            pdebug.println(\"A \" + this.getAlgorithm()\n+                                           + \" derivation cannot be performed \"\n+                                           + \"using the supplied derivation \"\n+                                           + \"inputs, using \"\n+                                           + currOne.provider().getName()\n+                                           + \". Another Provider will be \"\n+                                           + \"attempted.\");\n+                            e.printStackTrace(pdebug.getPrintStream());\n+                        }\n+                        if (lastException == null) {\n+                            lastException = e;\n+                        }\n+                        \/\/ try next one if available\n+                        assert serviceIterator != null : \"serviceIterator was null\";\n+                        currOne = getNext(serviceIterator, kdfParameters);\n+                    }\n+                }\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw e; \/\/ getNext reached end and have seen IAPE\n+            } catch (NoSuchAlgorithmException e) {\n+                if (!skipDebug && pdebug != null) {\n+                    pdebug.println(\n+                            \"All available Providers have been examined \"\n+                            + \"without a match for performing the \"\n+                            + this.getAlgorithm()\n+                            + \" derivation using the supplied derivation \"\n+                            + \"inputs. Therefore, the caught \"\n+                            + \"NoSuchAlgorithmException will be logged, and \"\n+                            + \"an InvalidAlgorithmParameterException will \"\n+                            + \"then be thrown with the last known Exception.\");\n+                    e.printStackTrace(pdebug.getPrintStream());\n+                }\n+                \/\/ getNext reached end without finding an implementation\n+                throw new InvalidAlgorithmParameterException(lastException);\n+            }\n+        }\n+    }\n+\n+    private static Delegate getNext(Iterator<Service> serviceIter,\n+                                    KDFParameters kdfParameters)\n+            throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        \/\/ fetch next one if available\n+        boolean hasOne = false;\n+        while (serviceIter.hasNext()) {\n+            Service s = serviceIter.next();\n+            Provider prov = s.getProvider();\n+            if (!JceSecurity.canUseProvider(prov)) {\n+                \/\/ continue to next iteration\n+                continue;\n+            }\n+            hasOne = true;\n+            try {\n+                Object obj = s.newInstance(kdfParameters);\n+                if (!(obj instanceof KDFSpi)) {\n+                    if (!skipDebug && pdebug != null) {\n+                        pdebug.println(\n+                                \"obj was not an instance of KDFSpi (should not \"\n+                                + \"happen)\");\n+                    }\n+                    continue;\n+                }\n+                return new Delegate((KDFSpi) obj, prov);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ continue to the next provider\n+                if (!skipDebug && pdebug != null) {\n+                    pdebug.println(\"A derivation cannot be performed \"\n+                                   + \"using the supplied KDFParameters, using \"\n+                                   + prov.getName()\n+                                   + \". Another Provider will be attempted.\");\n+                    nsae.printStackTrace(pdebug.getPrintStream());\n+                }\n+            }\n+        }\n+        if (!skipDebug && pdebug != null) {\n+            pdebug.println(\n+                    \"No provider can be found that supports the \"\n+                    + \"specified algorithm and parameters\");\n+        }\n+        if (hasOne) throw new InvalidAlgorithmParameterException(\n+                \"The KDFParameters supplied could not be used in combination \"\n+                + \"with the supplied algorithm for the selected Provider\");\n+        else throw new NoSuchAlgorithmException();\n+    }\n+\n+    private static boolean checkSpiNonNull(Delegate d) {\n+        \/\/ d.spi() cannot be null if d != null\n+        return (d != null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":679,"deletions":0,"binary":false,"changes":679,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A specification of Key Derivation Function ({@link KDF}) parameters.\n+ * <p>\n+ * The purpose of this interface is to group (and provide type safety for) all\n+ * {@code KDF} parameter specifications. All {@code KDF} parameter\n+ * specifications must implement this interface.\n+ * <p>\n+ * When supplied, the\n+ * {@link KDF#getInstance(String, KDFParameters) KDF.getInstance} methods return\n+ * a {@code KDF} that is initialized with the specified parameters.\n+ * <p>\n+ * The {@code KDFParameters} used for initialization are returned by\n+ * {@link KDF#getParameters()} and may contain additional default or random\n+ * parameter values used by the underlying KDF implementation.\n+ *\n+ * @see KDF#getInstance(String, KDFParameters)\n+ * @see KDF#getParameters()\n+ * @see KDF\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface KDFParameters {}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFParameters.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ * This class defines the <i>Service Provider Interface<\/i> (<b>SPI<\/b>) for the\n+ * Key Derivation Function ({@link KDF}) class.\n+ * <p>\n+ * All the abstract methods in this class must be implemented by each\n+ * cryptographic service provider who wishes to supply the implementation of a\n+ * particular key derivation algorithm.\n+ * <p>\n+ * Implementations must provide a public constructor which accepts a {@code\n+ * KDFParameters} object if they depend on the default implementation of\n+ * {@code Provider.Service.newInstance} to construct {@code KDFSpi} instances.\n+ * The constructor must call {@code super(params)} passing the parameters\n+ * supplied. The constructor must also throw an\n+ * {@code InvalidAlgorithmParameterException} if the supplied parameters are\n+ * inappropriate. If a {@code KDF} object is instantiated with one of the\n+ * {@code getInstance} methods that contains a {@code KDFParameters} parameter,\n+ * the user-provided {@code KDFParameters} object will be passed to the\n+ * constructor of the {@code KDFSpi} implementation. Otherwise, if it is\n+ * instantiated with one of the {@code getInstance} methods without a\n+ * {@code KDFParameters} parameter, a {@code null} value will be passed to the\n+ * constructor.\n+ * <p>\n+ * Implementations which do not support {@code KDFParameters} must require\n+ * {@code null} to be passed, otherwise an\n+ * {@code InvalidAlgorithmParameterException} will be thrown. On the other hand,\n+ * implementations which require {@code KDFParameters} should throw an\n+ * {@code InvalidAlgorithmParameterException} upon receiving a {@code null}\n+ * value if default parameters cannot be generated or upon receiving {@code\n+ * KDFParameters} which are not supported by the implementation.\n+ * <p>\n+ * To aid the caller, implementations may return parameters with additional\n+ * default values or supply random values as used by the underlying {@code KDF}\n+ * algorithm. See {@link KDFSpi#engineGetParameters()} for more details.\n+ *\n+ * @see KDF\n+ * @see KDFParameters\n+ * @see KDF#getParameters()\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public abstract class KDFSpi {\n+\n+    \/**\n+     * The sole constructor.\n+     * <p>\n+     * A {@code KDFParameters} object may be specified for KDF algorithms that\n+     * support initialization parameters.\n+     *\n+     * @param kdfParameters\n+     *         the initialization parameters for the {@code KDF} algorithm (may\n+     *         be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the initialization parameters are inappropriate for this\n+     *         {@code KDFSpi}\n+     * @see KDF#getParameters()\n+     *\/\n+    protected KDFSpi(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {}\n+\n+    \/**\n+     * Returns the {@code KDFParameters} used with this {@code KDF} object.\n+     * <p>\n+     * The returned parameters may be the same that were used to initialize\n+     * this {@code KDF} object, or may contain additional default or\n+     * random parameter values used by the underlying KDF algorithm.\n+     * If the required parameters were not supplied and can be generated by\n+     * the {@code KDF} object, the generated parameters are returned;\n+     * otherwise {@code null} is returned.\n+     *\n+     * @return the parameters used with this {@code KDF} object, or\n+     *         {@code null}\n+     *\/\n+    protected abstract KDFParameters engineGetParameters();\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey} object.\n+     *\n+     * @param alg\n+     *         the algorithm of the resultant {@code SecretKey} object\n+     * @param derivationSpec\n+     *         derivation parameters\n+     *\n+     * @return the derived key.\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code derivationSpec} is\n+     *         invalid or if the combination of {@code alg} and the\n+     *         {@code derivationSpec} results in something invalid\n+     * @throws NoSuchAlgorithmException\n+     *         if {@code alg} is empty or invalid\n+     * @throws NullPointerException\n+     *         if {@code alg} or {@code derivationSpec} is null\n+     * @implNote If the resultant key is extractable, then its\n+     *         {@code getEncoded} value should have the same content as the\n+     *         result of {@code deriveData}.\n+     *\/\n+    protected abstract SecretKey engineDeriveKey(String alg,\n+                                                 AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException, NoSuchAlgorithmException;\n+\n+    \/**\n+     * Derives a key, returns raw data as a byte array.\n+     *\n+     * @param derivationSpec\n+     *         derivation parameters\n+     *\n+     * @return the derived key in its raw bytes.\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *         if the information contained within the {@code derivationSpec} is\n+     *         invalid\n+     * @throws UnsupportedOperationException\n+     *         if the derived keying material is not extractable\n+     * @throws NullPointerException\n+     *         if {@code derivationSpec} is null\n+     *\/\n+    protected abstract byte[] engineDeriveData(\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,505 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.SecretKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Parameters for the combined Extract, Expand, or Extract-then-Expand\n+ * operations of the HMAC-based Key Derivation Function (HKDF). The HKDF\n+ * function is defined in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC\n+ * 5869<\/a>.\n+ * <p>\n+ * In the Extract and Extract-then-Expand cases, users may call the {@code\n+ * addIKM} and\/or {@code addSalt} methods repeatedly (and chain these calls).\n+ * This provides for use-cases where a portion of the input keying material\n+ * (IKM) resides in a non-extractable {@code SecretKey} and the whole IKM\n+ * cannot be provided as a single object. The same feature is available for\n+ * salts.\n+ * <p>\n+ * The above feature is particularly useful for \"labeled\" HKDF Extract used in\n+ * TLS 1.3 and HPKE, where the IKM consists of concatenated components, which\n+ * may include both byte arrays and (possibly non-extractable) secret keys.\n+ * <p>\n+ * Examples:\n+ * {@snippet lang = java:\n+ * \/\/ this usage depicts the initialization of an HKDF-Extract AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(label)\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).extractOnly();\n+ *}\n+ * {@snippet lang = java:\n+ * \/\/ this usage depicts the initialization of an HKDF-Expand AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.expandOnly(prk, info, 32);\n+ *}\n+ * {@snippet lang = java:\n+ * \/\/ this usage depicts the initialization of an HKDF-ExtractExpand AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 32);\n+ *}\n+ *\n+ * @see javax.crypto.KDF\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface HKDFParameterSpec extends AlgorithmParameterSpec {\n+\n+    \/**\n+     * This {@code Builder} builds {@code Extract} and {@code ExtractThenExpand}\n+     * objects.\n+     * <p>\n+     * The {@code Builder} is initialized via the {@code ofExtract} method of\n+     * {@code HKDFParameterSpec}. As stated in the class description,\n+     * {@code addIKM} and\/or {@code addSalt} may be called as needed. Finally,\n+     * an object is \"built\" by calling either {@code extractOnly} or\n+     * {@code thenExpand} for {@code Extract} and {@code ExtractThenExpand}\n+     * use-cases respectively. Note that the {@code Builder} is not\n+     * thread-safe.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Builder {\n+\n+        private List<SecretKey> ikms = new ArrayList<>();\n+        private List<SecretKey> salts = new ArrayList<>();\n+\n+        private Builder() {}\n+\n+        \/**\n+         * Builds an {@code Extract} object from the current state of the\n+         * {@code Builder}.\n+         *\n+         * @return an immutable {@code Extract} object\n+         *\/\n+        public Extract extractOnly() {\n+            return new Extract(ikms, salts);\n+        }\n+\n+        \/**\n+         * Builds an {@code ExtractThenExpand} object from the current state of\n+         * the {@code Builder}.\n+         *\n+         * @param info\n+         *         the optional context and application specific information\n+         *         (may be {@code null}); the byte array is cloned to prevent\n+         *         subsequent modification\n+         * @param length\n+         *         the length of the output keying material (must be greater\n+         *         than 0)\n+         *\n+         * @return an {@code ExtractThenExpand} object\n+         *\n+         * @throws IllegalArgumentException\n+         *         if {@code length} is not greater than 0\n+         * @implNote HKDF implementations will enforce that the length\n+         *         is not greater than 255 * HMAC length. HKDF implementations\n+         *         will also enforce that a {code null} info value is treated as\n+         *         zero-length byte array.\n+         *\/\n+        public ExtractThenExpand thenExpand(byte[] info, int length) {\n+            return new ExtractThenExpand(\n+                    extractOnly(), info,\n+                    length);\n+        }\n+\n+        \/**\n+         * Adds input keying material (IKM) to the builder.\n+         * <p>\n+         * Users may call {@code addIKM} multiple times when the input keying\n+         * material value is to be assembled piece-meal or if part of the IKM is\n+         * to be supplied by a hardware crypto device. The {@code ikms()}\n+         * method of the {@code Extract} or {@code ExtractThenExpand} object\n+         * that is subsequently built returns the assembled input keying\n+         * material as a list of {@code SecretKey} objects.\n+         *\n+         * @param ikm\n+         *         the input keying material (IKM) value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *         if the {@code ikm} argument is null\n+         *\/\n+        public Builder addIKM(SecretKey ikm) {\n+            Objects.requireNonNull(ikm, \"ikm must not be null\");\n+            ikms.add(ikm);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds input keying material (IKM) to the builder. Note that an\n+         * {@code ikm} byte array of length zero will be discarded.\n+         * <p>\n+         * Users may call {@code addIKM} multiple times when the input keying\n+         * material value is to be assembled piece-meal or if part of the IKM is\n+         * to be supplied by a hardware crypto device. The {@code ikms()}\n+         * method of the {@code Extract} or {@code ExtractThenExpand} object\n+         * that is subsequently built returns the assembled input keying\n+         * material as a list of {@code SecretKey} objects.\n+         *\n+         * @param ikm\n+         *         the input keying material (IKM) value; the {@code ikm}\n+         *         byte array will be converted to a {@code SecretKeySpec},\n+         *         which means that the byte array will be cloned inside the\n+         *         {@code SecretKeySpec} constructor\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *         if the {@code ikm} argument is null\n+         *\/\n+        public Builder addIKM(byte[] ikm) {\n+            Objects.requireNonNull(ikm, \"ikm must not be null\");\n+            if (ikm.length != 0) {\n+                return addIKM(new SecretKeySpec(ikm, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder.\n+         * <p>\n+         * Users may call {@code addSalt} multiple times when the salt value is\n+         * to be assembled piece-meal or if part of the salt is to be supplied\n+         * by a hardware crypto device. The {@code salts()} method of the\n+         * {@code Extract} or {@code ExtractThenExpand} object that is\n+         * subsequently built returns the assembled salt as a list of\n+         * {@code SecretKey} objects.\n+         *\n+         * @param salt\n+         *         the salt value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *         if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(SecretKey salt) {\n+            Objects.requireNonNull(salt, \"salt must not be null\");\n+            salts.add(salt);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder. Note that a {@code salt} byte array of\n+         * length zero will be discarded.\n+         * <p>\n+         * Users may call {@code addSalt} multiple times when the salt value is\n+         * to be assembled piece-meal or if part of the salt is to be supplied\n+         * by a hardware crypto device. The {@code salts()} method of the\n+         * {@code Extract} or {@code ExtractThenExpand} object that is\n+         * subsequently built returns the assembled salt as a list of\n+         * {@code SecretKey} objects.\n+         *\n+         * @param salt\n+         *         the salt value; the {@code salt} byte array will be\n+         *         converted to a {@code SecretKeySpec}, which means that the\n+         *         byte array will be cloned inside the {@code SecretKeySpec}\n+         *         constructor\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *         if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(byte[] salt) {\n+            Objects.requireNonNull(salt, \"salt must not be null\");\n+            if (salt.length != 0) {\n+                return addSalt(new SecretKeySpec(salt, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code Builder} for building {@code Extract} and\n+     * {@code ExtractThenExpand} objects.\n+     *\n+     * @return a new {@code Builder}\n+     *\/\n+    static Builder ofExtract() {\n+        return new Builder();\n+    }\n+\n+    \/**\n+     * Creates an {@code Expand} object.\n+     *\n+     * @param prk\n+     *         the pseudorandom key (PRK); must not be {@code null}\n+     * @param info\n+     *         the optional context and application specific information (may be\n+     *         {@code null}); the byte array is cloned to prevent subsequent\n+     *         modification\n+     * @param length\n+     *         the length of the output keying material (must be greater than\n+     *         0)\n+     *\n+     * @return an {@code Expand} object\n+     *\n+     * @throws NullPointerException\n+     *         if the {@code prk} argument is {@code null}\n+     * @throws IllegalArgumentException\n+     *         if {@code length} is not greater than 0\n+     * @implNote HKDF implementations will enforce that the length is\n+     *         not greater than 255 * HMAC length. Implementations will also\n+     *         enforce that the prk argument is at least as many bytes as the\n+     *         HMAC length. Implementations will also enforce that a {code null}\n+     *         info value is treated as zero-length byte array.\n+     *\/\n+    static Expand expandOnly(SecretKey prk, byte[] info, int length) {\n+        if (prk == null) {\n+            throw new NullPointerException(\"prk must not be null\");\n+        }\n+        return new Expand(prk, info, length);\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Extract operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Extract implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Extract(salt, IKM) -> PRK\n+        private final List<SecretKey> ikms;\n+        private final List<SecretKey> salts;\n+\n+        private Extract(List<SecretKey> ikms, List<SecretKey> salts) {\n+            this.ikms = List.copyOf(ikms);\n+            this.salts = List.copyOf(salts);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input keying material values\n+         * in the order they were added. Returns an empty list if there are no\n+         * input keying material values.\n+         * <p>\n+         * Input keying material values added by {@link Builder#addIKM(byte[])}\n+         * are converted to a {@code SecretKeySpec} object. Empty arrays are\n+         * discarded.\n+         *\n+         * @return the unmodifiable {@code List} of input keying material\n+         *         values\n+         *\n+         * @implNote An HKDF implementation should concatenate the input\n+         *         keying materials into a single value to be used in\n+         *         HKDF-Extract.\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ikms;\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added. Returns an empty list if there are no salt values.\n+         * <p>\n+         * Salt values added by {@link Builder#addSalt(byte[])} are converted to\n+         * a {@code SecretKeySpec} object. Empty arrays are discarded.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\n+         * @implNote An HKDF implementation should concatenate the salt\n+         *         into a single value to be used in HKDF-Extract.\n+         *\/\n+        public List<SecretKey> salts() {\n+            return salts;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Expand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Expand implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Expand(PRK, info, L) -> OKM\n+        private final SecretKey prk;\n+        private final byte[] info;\n+        private final int length;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code Expand} object\n+         *\n+         * @param prk\n+         *         the pseudorandom key (PRK); in the case of\n+         *         {@code ExtractThenExpand}, the {@code prk} argument may be\n+         *         {@null} since the output of extract phase is used\n+         * @param info\n+         *         the optional context and application specific information\n+         *         (may be {@code null}); the byte array is cloned to prevent\n+         *         subsequent modification\n+         * @param length\n+         *         the length of the output keying material\n+         *\n+         * @throws IllegalArgumentException\n+         *         if {@code length} not greater than 0\n+         *\/\n+        private Expand(SecretKey prk, byte[] info, int length) {\n+            \/\/ a null prk argument could be indicative of ExtractThenExpand\n+            this.prk = prk;\n+            this.info = (info == null) ? null : info.clone();\n+            if (!(length > 0)) {\n+                throw new IllegalArgumentException(\"length must be > 0\");\n+            }\n+            this.length = length;\n+        }\n+\n+        \/**\n+         * Returns the pseudorandom key (PRK).\n+         *\n+         * @return the pseudorandom key\n+         *\/\n+        public SecretKey prk() {\n+            return prk;\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a clone of the optional context and application specific\n+         *         information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return (info == null) ? null : info.clone();\n+        }\n+\n+        \/**\n+         * Returns the length of the output keying material.\n+         *\n+         * @return the length of the output keying material\n+         *\/\n+        public int length() {\n+            return length;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an ExtractThenExpand operation as defined\n+     * in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class ExtractThenExpand implements HKDFParameterSpec {\n+        private final Extract ext;\n+        private final Expand exp;\n+\n+        \/**\n+         * Constructor that may be used to initialize an\n+         * {@code ExtractThenExpand} object\n+         *\n+         * @param ext\n+         *         a pre-generated {@code Extract}\n+         * @param info\n+         *         the optional context and application specific information\n+         *         (may be {@code null}); the byte array is cloned to prevent\n+         *         subsequent modification\n+         * @param length\n+         *         the length of the output keying material\n+         *\n+         * @throws IllegalArgumentException\n+         *         if {@code length} is not greater than 0\n+         *\/\n+        private ExtractThenExpand(Extract ext, byte[] info, int length) {\n+            Objects.requireNonNull(ext, \"Extract object must not be null\");\n+            this.ext = ext;\n+            \/\/ - null prk argument is ok here (it's a signal)\n+            \/\/ - {@code Expand} constructor can deal with a null info\n+            \/\/ - length is checked in {@code Expand} constructor\n+            this.exp = new Expand(null, info, length);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input keying material values\n+         * in the order they were added. Returns an empty list if there are no\n+         * input keying material values.\n+         * <p>\n+         * Input keying material values added by {@link Builder#addIKM(byte[])}\n+         * are converted to a {@code SecretKeySpec} object. Empty arrays are\n+         * discarded.\n+         *\n+         * @return the unmodifiable {@code List} of input keying material\n+         *         values\n+         *\n+         * @implNote An HKDF implementation should concatenate the input\n+         *         keying materials into a single value to be used in the\n+         *         HKDF-Extract phase.\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ext.ikms();\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added. Returns an empty list if there are no salt values.\n+         * <p>\n+         * Salt values added by {@link Builder#addSalt(byte[])} are converted to\n+         * a {@code SecretKeySpec} object. Empty arrays are discarded.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\n+         * @implNote An HKDF implementation should concatenate the salt\n+         *         into a single value to be used in the HKDF-Extract phase.\n+         *\/\n+        public List<SecretKey> salts() {\n+            return ext.salts();\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a clone of the optional context and application specific\n+         *         information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return exp.info();\n+        }\n+\n+        \/**\n+         * Returns the length of the output keying material.\n+         *\n+         * @return the length of the output keying material\n+         *\/\n+        public int length() {\n+            return exp.length();\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":505,"deletions":0,"binary":false,"changes":505,"status":"added"},{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=478, title=\"Key Derivation Function API\", status=\"Preview\")\n+        KEY_DERIVATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        System.err.println(\"              Cipher, KeyAgreement, KeyGenerator,\");\n+        System.err.println(\"              Cipher, KDF, KeyAgreement, KeyGenerator,\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary basic HKDF operations\n+ * @library \/test\/lib\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.util.HexFormat;\n+\n+public class HKDFBasicFunctionsTest {\n+    public static void main(String[] args) throws Exception {\n+        var ikm = HexFormat.of().parseHex(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\");\n+        var salt = HexFormat.of().parseHex(\"000102030405060708090a0b0c\");\n+        var info = HexFormat.of().parseHex(\"f0f1f2f3f4f5f6f7f8f9\");\n+        var len = 42;\n+\n+        var kdf = KDF.getInstance(\"HKDF-SHA256\");\n+        var expectedPrk = HexFormat.of().parseHex(\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\");\n+        var expectedOkm = HexFormat.of().parseHex(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\");\n+\n+        var extractOnly = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).extractOnly();\n+        var prk = kdf.deriveKey(\"PRK\", extractOnly);\n+        var expandOnly = HKDFParameterSpec.expandOnly(prk, info, len);\n+        var okm1 = kdf.deriveKey(\"OKM\", expandOnly);\n+        var extractAndExpand = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(info, len);\n+        var okm2 = kdf.deriveKey(\"OKM\", extractAndExpand);\n+\n+        Asserts.assertEqualsByteArray(prk.getEncoded(), expectedPrk,\n+                                      \"the PRK must match the expected value\");\n+\n+        Asserts.assertEqualsByteArray(okm1.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(expand)\");\n+\n+        Asserts.assertEqualsByteArray(okm2.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(extract expand)\");\n+\n+        \/\/ test empty extract\n+        test(HKDFParameterSpec.ofExtract().extractOnly());\n+        \/\/ test expand with empty info\n+        test(HKDFParameterSpec.ofExtract().thenExpand(new byte[0], 32));\n+        \/\/ test expand with null info\n+        test(HKDFParameterSpec.ofExtract().thenExpand(null, 32));\n+        \/\/ test extract with zero-length salt\n+        test(HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(new byte[0]).extractOnly());\n+    }\n+\n+    static void test(HKDFParameterSpec p) throws Exception {\n+        var kdf = KDF.getInstance(\"HKDF-SHA256\");\n+        System.out.println(HexFormat.of().formatHex(kdf.deriveData(p)));\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFBasicFunctionsTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,552 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary KDF API tests\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.egd=file:\/dev\/urandom -Djava.security.debug=provider,engine=kdf HKDFExhaustiveTest\n+ * @enablePreview\n+ *\/\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.crypto.KDF;\n+import javax.crypto.KDFParameters;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class HKDFExhaustiveTest {\n+\n+  private static final String JDK_HKDF_SHA256 = \"HKDF-SHA256\";\n+  private static final String JDK_HKDF_SHA384 = \"HKDF-SHA384\";\n+  private static final String JDK_HKDF_SHA512 = \"HKDF-SHA512\";\n+  private static final String[] KDF_ALGORITHMS = {\n+    JDK_HKDF_SHA256, JDK_HKDF_SHA384, JDK_HKDF_SHA512\n+  };\n+  private static final String SUNJCE = \"SunJCE\";\n+\n+  \/\/ SECRET_KEY_SPEC_KEYS and RAW_DATA holds valid values for IKM and SALTS\n+  private static final List<SecretKey> SECRET_KEY_SPEC_KEYS =\n+      List.of(\n+          new SecretKeySpec(new byte[] {0}, \"HKDF-IKM\"),\n+          new SecretKeySpec(\"IKM\".getBytes(), \"HKDF-IKM\"));\n+  private static final List<byte[]> RAW_DATA = List.of(new byte[] {0}, \"RAW\".getBytes());\n+\n+  private static final byte[] EMPTY = new byte[0];\n+  private static final int SHORT_LENGTH = 42;\n+  private static final int LARGE_LENGTH = 1000;\n+  private static final int NEGATIVE_LENGTH = -1;\n+\n+  private static final KdfVerifier<String, String, AlgorithmParameterSpec> KdfGetInstanceVerifier =\n+      (a, p, s) -> {\n+\n+        \/\/ Test KDF getInstance methods, all should have same algo and provider\n+        KDF k1 = KDF.getInstance(a);\n+        KDF k2 = KDF.getInstance(a, p);\n+        KDF k3 = KDF.getInstance(a, Security.getProvider(p));\n+        Asserts.assertEquals(k1.getAlgorithm(), k2.getAlgorithm());\n+        Asserts.assertEquals(k2.getAlgorithm(), k3.getAlgorithm());\n+        Asserts.assertEquals(k1.getProviderName(), k2.getProviderName());\n+        Asserts.assertEquals(k2.getProviderName(), k3.getProviderName());\n+        Asserts.assertEquals(k1.getParameters(), k2.getParameters());\n+        Asserts.assertEquals(k2.getParameters(), k3.getParameters());\n+\n+        \/\/ Test KDF getInstance methods with parameters\n+        KDFParameters spec = (KDFParameters) s;\n+        k1 = KDF.getInstance(a, spec);\n+        k2 = KDF.getInstance(a, spec, p);\n+        k3 = KDF.getInstance(a, spec, Security.getProvider(p));\n+        Asserts.assertEquals(k1.getAlgorithm(), k2.getAlgorithm());\n+        Asserts.assertEquals(k2.getAlgorithm(), k3.getAlgorithm());\n+        Asserts.assertEquals(k1.getProviderName(), k2.getProviderName());\n+        Asserts.assertEquals(k2.getProviderName(), k3.getProviderName());\n+        Asserts.assertEquals(k1.getParameters(), k2.getParameters());\n+        Asserts.assertEquals(k2.getParameters(), k3.getParameters());\n+      };\n+\n+  private static final KdfExtractVerifier<Object, Object> KdfExtractVerifierImpl =\n+      (ikm, salt) -> {\n+        \/\/ ofExtract\n+        HKDFParameterSpec.Builder hkdfParameterSpecBuilder = HKDFParameterSpec.ofExtract();\n+        addIkmAndSalt(hkdfParameterSpecBuilder, ikm, salt);\n+\n+        \/\/ extractOnly - it is possible to have empty key param so skip when length is 0\n+        HKDFParameterSpec.Extract parameterSpec = hkdfParameterSpecBuilder.extractOnly();\n+        checkIKMSaltPresence(ikm, salt, parameterSpec);\n+\n+        return parameterSpec;\n+      };\n+\n+  private static final KdfExpandVerifier<SecretKey, byte[], Integer> KdfExpandVerifierImpl =\n+      (prk, info, len) -> {\n+        \/\/ Expand\n+        HKDFParameterSpec.Expand parameterSpec = HKDFParameterSpec.expandOnly(prk, info, len);\n+\n+        Asserts.assertEqualsByteArray(prk.getEncoded(), parameterSpec.prk().getEncoded());\n+        Asserts.assertEqualsByteArray(info, parameterSpec.info());\n+        Asserts.assertEquals(len, parameterSpec.length());\n+\n+        return parameterSpec;\n+      };\n+\n+  private static final KdfExtThenExpVerifier<Object, Object, byte[], Integer>\n+      KdfExtThenExpVerifierImpl =\n+          (ikm, salt, info, len) -> {\n+            \/\/ ofExtract\n+            HKDFParameterSpec.Builder hkdfParameterSpecBuilder = HKDFParameterSpec.ofExtract();\n+            addIkmAndSalt(hkdfParameterSpecBuilder, ikm, salt);\n+\n+            \/\/ thenExpand\n+            HKDFParameterSpec.ExtractThenExpand parameterSpec =\n+                hkdfParameterSpecBuilder.thenExpand(info, len);\n+            checkIKMSaltPresence(ikm, salt, parameterSpec);\n+\n+            \/\/ Validate info and length\n+            Asserts.assertEqualsByteArray(info, parameterSpec.info());\n+            Asserts.assertEquals(len, parameterSpec.length());\n+\n+            return parameterSpec;\n+          };\n+  private static final DeriveComparator<\n+          KDF, HKDFParameterSpec, HKDFParameterSpec, String, SecretKey, Integer>\n+      deriveComparatorImpl =\n+          (hk, lhs, rhs, t, s, len) -> {\n+            \/\/ deriveKey using two passed in HKDFParameterSpec and compare\n+            byte[] skUsingLhs = hk.deriveKey(t, lhs).getEncoded();\n+            byte[] skUsingRhs = hk.deriveKey(t, rhs).getEncoded();\n+\n+            \/\/ compare deriveData and keys using same HKDFParameterSpec are equal\n+            Asserts.assertEqualsByteArray(skUsingLhs, skUsingRhs);\n+            Asserts.assertEqualsByteArray(hk.deriveData(lhs), skUsingLhs);\n+            Asserts.assertEqualsByteArray(hk.deriveData(lhs), skUsingRhs);\n+            Asserts.assertEqualsByteArray(hk.deriveData(lhs), hk.deriveData(rhs));\n+\n+            \/\/ if 'len < 0' then deriveKey()\/deriveData() length check is not required\n+            if (len >= 0) {\n+              Asserts.assertEquals(skUsingLhs.length, len);\n+            }\n+\n+            \/\/ Compare with if SecretKey is passed in parameter\n+            if (s != null) {\n+              Asserts.assertEqualsByteArray(skUsingLhs, s.getEncoded());\n+            }\n+          };\n+  \/\/ Passed in HKDFParameterSpec returned from different methods and algorithms a1, a2.\n+  \/\/ Keys and data derived should be equal.\n+  private static final DeriveVerifier<KDF, HKDFParameterSpec, HKDFParameterSpec, String, String>\n+      deriveVerifierImpl =\n+          (hk, lhs, rhs, a1, a2) -> {\n+            SecretKey sk1 = hk.deriveKey(a1, lhs);\n+            SecretKey sk2 = hk.deriveKey(a2, rhs);\n+            Asserts.assertEqualsByteArray(sk1.getEncoded(), sk2.getEncoded());\n+\n+            byte[] bk1 = hk.deriveData(lhs);\n+            Asserts.assertEqualsByteArray(bk1, sk1.getEncoded());\n+          };\n+\n+  private static void checkIKMSaltPresence(\n+      Object ikm, Object salt, HKDFParameterSpec parameterSpec) {\n+    final List<SecretKey> ikms;\n+    final List<SecretKey> salts;\n+    if (parameterSpec instanceof HKDFParameterSpec.Extract) {\n+      ikms = ((HKDFParameterSpec.Extract) parameterSpec).ikms();\n+      salts = ((HKDFParameterSpec.Extract) parameterSpec).salts();\n+    } else { \/\/ must be HKDFParameterSpec.ExtractThenExpand\n+      ikms = ((HKDFParameterSpec.ExtractThenExpand) parameterSpec).ikms();\n+      salts = ((HKDFParameterSpec.ExtractThenExpand) parameterSpec).salts();\n+    }\n+    if ((ikm instanceof SecretKey) || ((byte[]) ikm).length != 0) {\n+      Asserts.assertTrue(ikms.contains(getSecretKey(ikm)));\n+    }\n+\n+    if ((salt instanceof SecretKey) || ((byte[]) salt).length != 0) {\n+      Asserts.assertTrue(salts.contains(getSecretKey(salt)));\n+    }\n+  }\n+\n+  private static SecretKey getSecretKey(Object data) {\n+    return (data instanceof SecretKey)\n+        ? (SecretKey) data\n+        : new SecretKeySpec((byte[]) data, \"Generic\");\n+  }\n+\n+  private static void addIkmAndSalt(\n+      HKDFParameterSpec.Builder hkdfParameterSpecBuilder, Object ikm, Object salt) {\n+    if (ikm instanceof SecretKey) {\n+      hkdfParameterSpecBuilder.addIKM((SecretKey) ikm);\n+    } else {\n+      hkdfParameterSpecBuilder.addIKM((byte[]) ikm);\n+    }\n+\n+    if (salt instanceof SecretKey) {\n+      hkdfParameterSpecBuilder.addSalt((SecretKey) salt);\n+    } else {\n+      hkdfParameterSpecBuilder.addSalt((byte[]) salt);\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    System.out.println(\"Starting Test '\" + HKDFExhaustiveTest.class.getName() + \"'\");\n+\n+    \/\/ Test KDF.getInstance methods\n+    System.out.println(\"Testing getInstance methods\");\n+    testGetInstanceMethods();\n+    testGetInstanceNegative();\n+\n+    \/* Executing following test cases with one supported algorithm is sufficient *\/\n+    KDF hk = KDF.getInstance(KDF_ALGORITHMS[0]);\n+\n+    \/\/ Test extract\n+    System.out.println(\"Testing extract method\");\n+    testExtractMethod(hk);\n+\n+    System.out.println(\"Testing deriveKey and deriveData with extract method\");\n+    testDeriveKeyDataWithExtract(hk);\n+\n+    \/\/ Test expand\n+    System.out.println(\"Testing expand method\");\n+    testExpandMethod(hk);\n+\n+    System.out.println(\"Testing deriveKey and deriveData with expand method\");\n+    testDeriveKeyDataWithExpand(hk);\n+\n+    \/\/ Test ExtractThenExpand\n+    System.out.println(\"Testing extractThenExpand method\");\n+    testExtractExpandMethod(hk);\n+\n+    System.out.println(\"Testing deriveKey and deriveData with extExpand method\");\n+    testDeriveKeyDataWithExtExpand(hk);\n+\n+    System.out.println(\"Test executed successfully.\");\n+  }\n+\n+  private static void testGetInstanceMethods()\n+      throws InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchProviderException {\n+    \/\/ POSITIVE TestCase: KDF getInstance methods test\n+    for (String algo : KDF_ALGORITHMS) {\n+      KdfGetInstanceVerifier.test(algo, SUNJCE, null);\n+    }\n+  }\n+\n+  private static void testGetInstanceNegative() {\n+    final String INVALID_STRING = \"INVALID\";\n+    final Provider SUNJCE_PROVIDER = Security.getProvider(SUNJCE);\n+\n+    \/\/ getInstance(String algorithm)\n+    Utils.runAndCheckException(() -> KDF.getInstance(null), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING), NoSuchAlgorithmException.class);\n+\n+    \/\/ getInstance(String algorithm, String provider)\n+    Utils.runAndCheckException(() -> KDF.getInstance(null, SUNJCE), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING, SUNJCE), NoSuchAlgorithmException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], (String) null), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], INVALID_STRING), NoSuchProviderException.class);\n+\n+    \/\/ getInstance(String algorithm, Provider provider)\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(null, SUNJCE_PROVIDER), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING, SUNJCE_PROVIDER), NoSuchAlgorithmException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], (Provider) null), NullPointerException.class);\n+\n+    \/\/ getInstance(String algorithm, KDFParameters kdfParameters)\n+    \/\/ null spec is a valid case but different class is not\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(null, (KDFParameters) null), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING, (KDFParameters) null),\n+        NoSuchAlgorithmException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], (KDFParameters) new KDFAlgorithmParameterSpec()),\n+        ClassCastException.class);\n+\n+    \/\/ getInstance(String algorithm, KDFParameters kdfParameters, String provider)\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(null, null, SUNJCE), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING, null, SUNJCE), NoSuchAlgorithmException.class);\n+    Utils.runAndCheckException(\n+        () ->\n+            KDF.getInstance(\n+                KDF_ALGORITHMS[0], (KDFParameters) new KDFAlgorithmParameterSpec(), SUNJCE),\n+        ClassCastException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], null, (String) null), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], null, INVALID_STRING),\n+        NoSuchProviderException.class);\n+\n+    \/\/ getInstance(String algorithm, KDFParameters kdfParameters, Provider provider)\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(null, null, SUNJCE_PROVIDER), NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(INVALID_STRING, null, SUNJCE_PROVIDER),\n+        NoSuchAlgorithmException.class);\n+    Utils.runAndCheckException(\n+        () ->\n+            KDF.getInstance(\n+                KDF_ALGORITHMS[0],\n+                (KDFParameters) new KDFAlgorithmParameterSpec(),\n+                SUNJCE_PROVIDER),\n+        ClassCastException.class);\n+    Utils.runAndCheckException(\n+        () -> KDF.getInstance(KDF_ALGORITHMS[0], null, (Provider) null),\n+        NullPointerException.class);\n+  }\n+\n+  private static void testExtractMethod(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          InvalidParameterSpecException,\n+          NoSuchAlgorithmException {\n+    List<Object> ikmSaltTestData = new ArrayList<>();\n+    ikmSaltTestData.add(null);\n+    ikmSaltTestData.add(EMPTY);\n+    ikmSaltTestData.add(RAW_DATA.getFirst());\n+    ikmSaltTestData.add(SECRET_KEY_SPEC_KEYS.getFirst());\n+\n+    for (Object ikm : ikmSaltTestData) {\n+      for (Object salt : ikmSaltTestData) {\n+        \/\/ NEGATIVE Testcase: expects NullPointerException\n+        if (ikm == null || salt == null) {\n+          Utils.runAndCheckException(\n+              () -> KdfExtractVerifierImpl.extract(ikm, salt), NullPointerException.class);\n+        } else {\n+          \/\/ POSITIVE Testcase: Extract - Empty bytes for IKM\/SALT\n+          HKDFParameterSpec ext1 = KdfExtractVerifierImpl.extract(ikm, salt);\n+          HKDFParameterSpec ext2 = KdfExtractVerifierImpl.extract(ikm, salt);\n+          deriveComparatorImpl.deriveAndCompare(hk, ext1, ext2, \"PRK\", null, NEGATIVE_LENGTH);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static void testDeriveKeyDataWithExtract(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          InvalidParameterSpecException,\n+          NoSuchAlgorithmException {\n+    \/\/ POSITIVE TestCase: Extract - Derive keys\/data with unknown algorithm name\n+    deriveVerifierImpl.derive(\n+        hk,\n+        KdfExtractVerifierImpl.extract(SECRET_KEY_SPEC_KEYS.getFirst(), RAW_DATA.getFirst()),\n+        KdfExtractVerifierImpl.extract(SECRET_KEY_SPEC_KEYS.getFirst(), RAW_DATA.getFirst()),\n+        \"XYZ\",\n+        \"ABC\");\n+\n+    \/\/ NEGATIVE TestCase: Extract - {null, \"\"} algo to derive key\n+    Utils.runAndCheckException(\n+        () ->\n+            hk.deriveKey(\n+                null,\n+                KdfExtractVerifierImpl.extract(\n+                    SECRET_KEY_SPEC_KEYS.getFirst(), RAW_DATA.getFirst())),\n+        NullPointerException.class);\n+    Utils.runAndCheckException(\n+        () ->\n+            hk.deriveKey(\n+                \"\",\n+                KdfExtractVerifierImpl.extract(\n+                    SECRET_KEY_SPEC_KEYS.getFirst(), RAW_DATA.getFirst())),\n+        NoSuchAlgorithmException.class);\n+  }\n+\n+  private static void testExpandMethod(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          InvalidParameterSpecException,\n+          NoSuchAlgorithmException {\n+    SecretKey prk =\n+        hk.deriveKey(\n+            \"PRK\",\n+            KdfExtractVerifierImpl.extract(SECRET_KEY_SPEC_KEYS.get(1), RAW_DATA.getFirst()));\n+\n+    \/\/ Test extExp with {null, EMPTY} info and {SHORT_LENGTH, LARGE_LENGTH} length\n+    for (byte[] info : new byte[][] {null, EMPTY}) {\n+      for (int length : new Integer[] {SHORT_LENGTH, LARGE_LENGTH}) {\n+        HKDFParameterSpec exp1 = KdfExpandVerifierImpl.expand(prk, info, length);\n+        HKDFParameterSpec exp2 = KdfExpandVerifierImpl.expand(prk, info, length);\n+        deriveComparatorImpl.deriveAndCompare(hk, exp1, exp2, \"OKM\", null, length);\n+      }\n+    }\n+\n+    \/\/ NEGATIVE TestCase: Expand - PRK=null\n+    Utils.runAndCheckException(\n+        () -> KdfExpandVerifierImpl.expand(null, RAW_DATA.getFirst(), SHORT_LENGTH),\n+        NullPointerException.class);\n+\n+    \/\/ NEGATIVE TestCase: Expand - Derive keys\/data of negative length\n+    Utils.runAndCheckException(\n+        () ->\n+            KdfExpandVerifierImpl.expand(\n+                SECRET_KEY_SPEC_KEYS.getFirst(), RAW_DATA.getFirst(), NEGATIVE_LENGTH),\n+        IllegalArgumentException.class);\n+  }\n+\n+  private static void testDeriveKeyDataWithExpand(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          NoSuchAlgorithmException,\n+          InvalidParameterSpecException {\n+    SecretKey prk =\n+        hk.deriveKey(\n+            \"PRK\",\n+            KdfExtractVerifierImpl.extract(SECRET_KEY_SPEC_KEYS.get(1), RAW_DATA.getFirst()));\n+\n+    \/\/ POSITIVE TestCase: Expand - Derive keys\/data with unknown algorithm name\n+    deriveVerifierImpl.derive(\n+        hk,\n+        KdfExpandVerifierImpl.expand(prk, RAW_DATA.getFirst(), SHORT_LENGTH),\n+        KdfExpandVerifierImpl.expand(prk, RAW_DATA.getFirst(), SHORT_LENGTH),\n+        \"XYZ\",\n+        \"ABC\");\n+\n+    \/\/ NEGATIVE TestCase: Expand - PRK is not derived\n+    Utils.runAndCheckException(\n+        () ->\n+            hk.deriveKey(\n+                \"PRK\",\n+                KdfExpandVerifierImpl.expand(\n+                    SECRET_KEY_SPEC_KEYS.get(1), RAW_DATA.getFirst(), SHORT_LENGTH)),\n+        InvalidAlgorithmParameterException.class);\n+  }\n+\n+  private static void testExtractExpandMethod(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          InvalidParameterSpecException,\n+          NoSuchAlgorithmException {\n+    \/\/ Test extExp with {null, EMPTY} info and {SHORT_LENGTH, LARGE_LENGTH} length\n+    for (byte[] info : new byte[][] {null, EMPTY}) {\n+      for (int length : new Integer[] {SHORT_LENGTH, LARGE_LENGTH}) {\n+        HKDFParameterSpec extractExpand1 =\n+            KdfExtThenExpVerifierImpl.extExp(\n+                RAW_DATA.getFirst(), RAW_DATA.getFirst(), info, length);\n+        HKDFParameterSpec extractExpand2 =\n+            KdfExtThenExpVerifierImpl.extExp(\n+                RAW_DATA.getFirst(), RAW_DATA.getFirst(), info, length);\n+        deriveComparatorImpl.deriveAndCompare(\n+            hk, extractExpand1, extractExpand2, \"OKM\", null, length);\n+      }\n+    }\n+\n+    \/\/ NEGATIVE TestCases: ExtractExpand\n+    List<Object> ikmSaltTestData = new ArrayList<>();\n+    ikmSaltTestData.add(null);\n+    ikmSaltTestData.add(RAW_DATA.getFirst());\n+    ikmSaltTestData.add(SECRET_KEY_SPEC_KEYS.getFirst());\n+\n+    for (Object ikm : ikmSaltTestData) {\n+      for (Object salt : ikmSaltTestData) {\n+        if (ikm == null || salt == null) {\n+          \/\/ ikm and\/or salt are null, expect NullPointerException\n+          Utils.runAndCheckException(\n+              () -> KdfExtThenExpVerifierImpl.extExp(ikm, salt, RAW_DATA.getFirst(), SHORT_LENGTH),\n+              NullPointerException.class);\n+        } else {\n+          \/\/ ikm and salt are not null, test with negative length\n+          Utils.runAndCheckException(\n+              () ->\n+                  KdfExtThenExpVerifierImpl.extExp(ikm, salt, RAW_DATA.getFirst(), NEGATIVE_LENGTH),\n+              IllegalArgumentException.class);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static void testDeriveKeyDataWithExtExpand(KDF hk)\n+      throws InvalidAlgorithmParameterException,\n+          InvalidParameterSpecException,\n+          NoSuchAlgorithmException {\n+    \/\/ POSITIVE TestCase: ExtractExpand - Derive keys\/data with unknown algorithm names\n+    deriveVerifierImpl.derive(\n+        hk,\n+        KdfExtThenExpVerifierImpl.extExp(\n+            SECRET_KEY_SPEC_KEYS.getFirst(),\n+            RAW_DATA.getFirst(),\n+            RAW_DATA.getFirst(),\n+            SHORT_LENGTH),\n+        KdfExtThenExpVerifierImpl.extExp(\n+            SECRET_KEY_SPEC_KEYS.getFirst(),\n+            RAW_DATA.getFirst(),\n+            RAW_DATA.getFirst(),\n+            SHORT_LENGTH),\n+        \"XYZ\",\n+        \"ABC\");\n+  }\n+\n+  @FunctionalInterface\n+  private interface KdfVerifier<A, P, S> {\n+    void test(A a, P p, S s)\n+        throws NoSuchAlgorithmException,\n+            NoSuchProviderException,\n+            InvalidAlgorithmParameterException;\n+  }\n+\n+  @FunctionalInterface\n+  private interface KdfExtractVerifier<K, S> {\n+    HKDFParameterSpec extract(K k, S s);\n+  }\n+\n+  @FunctionalInterface\n+  private interface KdfExpandVerifier<P, I, L> {\n+    HKDFParameterSpec expand(P p, I i, L l);\n+  }\n+\n+  @FunctionalInterface\n+  private interface KdfExtThenExpVerifier<K, S, I, L> {\n+    HKDFParameterSpec extExp(K k, S s, I i, L l);\n+  }\n+\n+  @FunctionalInterface\n+  private interface DeriveComparator<HK, L, R, T, S, LN> {\n+    void deriveAndCompare(HK hk, L lh, R rh, T t, S s, LN l)\n+        throws InvalidParameterSpecException,\n+            InvalidAlgorithmParameterException,\n+            NoSuchAlgorithmException;\n+  }\n+\n+  @FunctionalInterface\n+  private interface DeriveVerifier<HK, L, R, A1, A2> {\n+    void derive(HK hk, L lh, R rh, A1 a1, A2 a2)\n+        throws InvalidParameterSpecException,\n+            InvalidAlgorithmParameterException,\n+            NoSuchAlgorithmException;\n+  }\n+\n+  private static class KDFAlgorithmParameterSpec implements AlgorithmParameterSpec {\n+    public KDFAlgorithmParameterSpec() {}\n+  }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFExhaustiveTest.java","additions":552,"deletions":0,"binary":false,"changes":552,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @run main HKDFKnownAnswerTests\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class HKDFKnownAnswerTests {\n+    public static class TestData {\n+        public TestData(String name, String algStr, String ikmStr,\n+                        String saltStr, String infoStr, int oLen,\n+                        String expPrkStr,\n+                        String expOkmStr) {\n+            testName = Objects.requireNonNull(name);\n+            algName = Objects.requireNonNull(algStr);\n+            ikm = HexFormat.of().parseHex(Objects.requireNonNull(ikmStr));\n+            if ((outLen = oLen) <= 0) {\n+                throw new IllegalArgumentException(\n+                    \"Output length must be greater than 0\");\n+            }\n+            expectedPRK = HexFormat.of().parseHex(Objects.requireNonNull(expPrkStr));\n+            expectedOKM = HexFormat.of().parseHex(Objects.requireNonNull(expOkmStr));\n+\n+            \/\/ Non-mandatory fields - may be null\n+            salt = (saltStr != null) ? HexFormat.of().parseHex(saltStr) : new byte[0];\n+            info = (infoStr != null) ? HexFormat.of().parseHex(infoStr) : null;\n+        }\n+\n+        public final String testName;\n+        public final String algName;\n+        public final byte[] ikm;\n+        public final byte[] salt;\n+        public final byte[] info;\n+        public final int outLen;\n+        public final byte[] expectedPRK;\n+        public final byte[] expectedOKM;\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 5869 Test Case 1\", \"HKDF-SHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         \"000102030405060708090a0b0c\",\n+                         \"f0f1f2f3f4f5f6f7f8f9\",\n+                         42,\n+                         \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n+                         \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\" +\n+                         \"34007208d5b887185865\"));\n+        add(new TestData(\"RFC 5869 Test Case 2\", \"HKDF-SHA256\",\n+                         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\" +\n+                         \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\" +\n+                         \"404142434445464748494a4b4c4d4e4f\",\n+                         \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\" +\n+                         \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\" +\n+                         \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                         \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\" +\n+                         \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\" +\n+                         \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                         82,\n+                         \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n+                         \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\" +\n+                         \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\" +\n+                         \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n+        add(new TestData(\"RFC 5869 Test Case 3\", \"HKDF-SHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         new String(new byte[0]), null, 42,\n+                         \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n+                         \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\" +\n+                         \"9d201395faa4b61a96c8\"));\n+    }};\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+\n+        int testNo = 0;\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNo + \": \" +\n+                               test.testName);\n+            if (runVector(test)) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total tests: \" + testList.size() +\n+                           \", Passed: \" + testsPassed + \", Failed: \" +\n+                           (testList.size() - testsPassed));\n+        if (testsPassed != testList.size()) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                                       \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runVector(TestData testData)\n+        throws InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException,\n+               NoSuchAlgorithmException {\n+        String kdfName, prfName;\n+        KDF kdfHkdf, kdfExtract, kdfExpand;\n+        boolean result = true;\n+        SecretKey actualPRK;\n+        SecretKey actualOKM;\n+        byte[] deriveData;\n+\n+        try {\n+            kdfHkdf = KDF.getInstance(testData.algName);\n+            kdfExtract = KDF.getInstance(testData.algName);\n+            kdfExpand = KDF.getInstance(testData.algName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            InvalidParameterSpecException exc =\n+                new InvalidParameterSpecException();\n+            exc.initCause(nsae);\n+            throw exc;\n+        }\n+\n+        \/\/ Set up the input keying material\n+        SecretKey ikmKey = new SecretKeySpec(testData.ikm, \"HKDF-IKM\");\n+\n+        \/\/ *** HKDF-Extract-only testing\n+        \/\/ Create KDFParameterSpec for the Extract-only operation\n+        AlgorithmParameterSpec derivationSpecExtract =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .extractOnly();\n+        actualPRK = kdfExtract.deriveKey(\"Generic\", derivationSpecExtract);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExtract.deriveData(derivationSpecExtract);\n+\n+        System.out.println(\"* HKDF-Extract-Only:\");\n+        result &= compareKeyAndData(actualPRK, deriveData,\n+                                    testData.expectedPRK);\n+\n+        \/\/ *** HKDF Expand-Only testing\n+        \/\/ For these tests, we'll use the actualPRK as the input key\n+        \/\/ Create KDFParameterSpec for key output and raw byte output\n+        AlgorithmParameterSpec derivationSpecExpand = HKDFParameterSpec.expandOnly(\n+            actualPRK, testData.info,\n+            testData.outLen);\n+        actualOKM = kdfExpand.deriveKey(\"Generic\", derivationSpecExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExpand.deriveData(derivationSpecExpand);\n+\n+        System.out.println(\"* HKDF-Expand-Only:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        \/\/ *** HKDF Extract-then-Expand testing\n+        \/\/ We can reuse the KDFParameterSpec from the Expand-only test\n+\n+        \/\/ Use the KDF to make us a key\n+        AlgorithmParameterSpec derivationSpecExtractExpand =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .thenExpand(testData.info,\n+                                         testData.outLen);\n+        actualOKM = kdfHkdf.deriveKey(\"Generic\", derivationSpecExtractExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfHkdf.deriveData(derivationSpecExtractExpand);\n+\n+        System.out.println(\"* HKDF-Extract-then-Expand:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Compare key-based and data-based productions from the KDF against an\n+     * expected output value.\n+     *\n+     * @param outKey\n+     *     the KDF output in key form\n+     * @param outData\n+     *     the KDF output as raw bytes\n+     * @param expectedOut\n+     *     the expected value\n+     *\n+     * @return true if the underlying data for outKey, outData and expectedOut\n+     * are the same.\n+     *\/\n+    private static boolean compareKeyAndData(Key outKey, byte[] outData,\n+                                             byte[] expectedOut) {\n+        boolean result = true;\n+\n+        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n+            System.out.println(\"\\t* Key output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Key output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outKey.getEncoded(), 16, \"\\n\",\n+                                            \" \"));\n+            System.out.println();\n+        }\n+\n+        if (Arrays.equals(outData, expectedOut)) {\n+            System.out.println(\"\\t* Data output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Data output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data\n+     *     The array of bytes to dump to stdout.\n+     * @param itemsPerLine\n+     *     The number of bytes to display per line if the {@code lineDelim}\n+     *     character is blank then all bytes will be printed on a single line.\n+     * @param lineDelim\n+     *     The delimiter between lines\n+     * @param itemDelim\n+     *     The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+                                       String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFKnownAnswerTests.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib\n+ * @run testng KDFDelayedProviderSyncTest\n+ * @summary multi-threading test for KDF\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.HexFormat;\n+\n+public class KDFDelayedProviderSyncTest {\n+    KDF kdfUnderTest;\n+    byte[] ikm = new BigInteger(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                                16).toByteArray();\n+    byte[] salt = new BigInteger(\"000102030405060708090a0b0c\",\n+                                 16).toByteArray();\n+    byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+    AlgorithmParameterSpec derivationSpec =\n+        HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(\n+            info, 42);\n+    String expectedResult =\n+        \"666b33562ebc5e2f041774192e0534efca06f82a5fca17ec8c6ae1b9f5466adba1d77d06480567ddd2d1\";\n+\n+    @BeforeClass\n+    public void setUp() throws NoSuchAlgorithmException {\n+        kdfUnderTest = KDF.getInstance(\"HKDF-SHA256\");\n+    }\n+\n+    @Test(threadPoolSize = 50, invocationCount = 100, timeOut = 150)\n+    public void testDerive()\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+        SecretKey result = kdfUnderTest.deriveKey(\"Generic\", derivationSpec);\n+        assert (HexFormat.of().formatHex(result.getEncoded()).equals(\n+            expectedResult));\n+\n+        byte[] resultData = kdfUnderTest.deriveData(derivationSpec);\n+        assert (HexFormat.of().formatHex(resultData).equals(expectedResult));\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/KDFDelayedProviderSyncTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main\/othervm KDFDelayedProviderTest\n+ * @summary delayed provider selection\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import javax.crypto.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+public class KDFDelayedProviderTest {\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new Provider1());\n+        Security.addProvider(new Provider2());\n+        Security.addProvider(new Provider3());\n+        KDF kdf;\n+\n+        kdf = KDF.getInstance(\"X\", new KDFParameters() {});\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P1\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new MyDerivationSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P2\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P3\");\n+\n+        boolean thrown = true;\n+        try {\n+            kdf = KDF.getInstance(\"Y\");\n+            thrown = false;\n+        } catch(Exception nsae) {\n+            \/\/ Expected exception\n+            Asserts.assertTrue(nsae instanceof NoSuchAlgorithmException);\n+            System.out.println(\"Expected NoSuchAlgorithmException\");\n+        }\n+        Asserts.assertTrue(thrown);\n+\n+        thrown = true;\n+        try {\n+            kdf = KDF.getInstance(\"HKDF-SHA256\", new MyKDFParameters());\n+            thrown = false;\n+        } catch (Exception iape) {\n+            \/\/ Expected exception\n+            Asserts.assertTrue(iape instanceof InvalidAlgorithmParameterException);\n+            System.out.println(\"Expected InvalidAlgorithmParameterException\");\n+        }\n+        Asserts.assertTrue(thrown);\n+\n+        thrown = true;\n+        try {\n+            kdf = KDF.getInstance(\"HKDF-SHA256\");\n+            kdf.deriveData(new MyDerivationSpec());\n+            thrown = false;\n+        } catch (Exception iape) {\n+            \/\/ Expected exception\n+            Asserts.assertTrue(iape instanceof InvalidAlgorithmParameterException);\n+            System.out.println(\"Expected InvalidAlgorithmParameterException\");\n+        }\n+        Asserts.assertTrue(thrown);\n+    }\n+\n+    public static class Provider1 extends Provider {\n+        public Provider1() {\n+            super(\"P1\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF1.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF1 requires a params at getInstance()\n+    public static class KDF1 extends KDF0 {\n+        public KDF1(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(Objects.requireNonNull(e));\n+        }\n+    }\n+\n+    public static class Provider2 extends Provider {\n+        public Provider2() {\n+            super(\"P2\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF2.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF2 requires input to be a specific type\n+    public static class KDF2 extends KDF0 {\n+        public KDF2(KDFParameters e)\n+            throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            if (derivationSpec instanceof MyDerivationSpec) {\n+                return null;\n+            } else {\n+                throw new InvalidAlgorithmParameterException();\n+            }\n+        }\n+    }\n+\n+    public static class Provider3 extends Provider {\n+        public Provider3() {\n+            super(\"P3\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF3.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF3 doesn't care about anything\n+    public static class KDF3 extends KDF0 {\n+        public KDF3(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+    }\n+\n+    public abstract static class KDF0 extends KDFSpi {\n+        public KDF0(KDFParameters a) throws InvalidAlgorithmParameterException {\n+            super(a);\n+        }\n+\n+        protected SecretKey engineDeriveKey(String alg,\n+                                            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return null;\n+        }\n+\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return new byte[0];\n+        }\n+\n+        protected KDFParameters engineGetParameters(){\n+            return null;\n+        }\n+    }\n+\n+    static class MyDerivationSpec implements AlgorithmParameterSpec {}\n+\n+    static class MyKDFParameters implements KDFParameters {}\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/KDFDelayedProviderTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main\/othervm KDFDelayedProviderThreadingTest\n+ * @summary delayed provider selection threading test\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFParameters;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+public class KDFDelayedProviderThreadingTest {\n+    \/\/\/ This number of iterations is enough to see a case where the threads\n+    \/\/\/ arrange themselves such that both `deriveData` attempts cause \"ERROR\",\n+    \/\/\/ which is still a passing case.\n+    static final int ITERATIONS = 10000;\n+    static int threadOrderReversalCounter = 0;\n+    static final String ERROR = \"ERROR\";\n+    static volatile String out;\n+    static final HKDFParameterSpec input\n+            = HKDFParameterSpec.ofExtract().extractOnly();\n+\n+    static String derive(KDF kdf) {\n+        try {\n+            return Arrays.toString(kdf.deriveData(input));\n+        } catch (Exception e) {\n+            return ERROR;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.insertProviderAt(new P(), 1);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            test();\n+        }\n+\n+        \/\/ If the value of threadOrderReversalCounter is consistently zero,\n+        \/\/ then this test may need to be adjusted for newer hardware to ensure\n+        \/\/ a thorough test. This didn't seem fitting for a check, such as\n+        \/\/ `Asserts.assertTrue(threadOrderReversalCounter > 0);`, since we\n+        \/\/ may not want to start failing the test right away when running on\n+        \/\/ better hardware someday.\n+        System.out.println(\"Also tested atypical threading condition \"\n+                           + threadOrderReversalCounter + \"\/\" + ITERATIONS\n+                           + \" iterations (depends on hardware specs\/utilization).\");\n+    }\n+\n+    static void test() throws Exception {\n+        var k = KDF.getInstance(\"HKDF-SHA256\");\n+        var t1 = new Thread(() -> out = derive(k));\n+        var t2 = new Thread(() -> k.getProviderName());\n+        t1.start();\n+        t2.start();\n+        t1.join();\n+        t2.join();\n+\n+        String out2 = derive(k);\n+        Asserts.assertEquals(out, out2);\n+        if (out.length() < 10) { \/\/ \"error\"\n+            threadOrderReversalCounter++;\n+        }\n+    }\n+\n+    public static class P extends Provider {\n+        public P() {\n+            super(\"ME\", \"1\", \"ME\");\n+            put(\"KDF.HKDF-SHA256\", K.class.getName());\n+        }\n+    }\n+\n+    public static class K extends KDFSpi {\n+\n+        public K(KDFParameters p) throws InvalidAlgorithmParameterException {\n+            super(p);\n+        }\n+\n+        @Override\n+        protected KDFParameters engineGetParameters() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected SecretKey engineDeriveKey(String alg,\n+                                            AlgorithmParameterSpec derivationSpec)\n+                throws InvalidAlgorithmParameterException {\n+            throw new InvalidAlgorithmParameterException();\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n+                throws InvalidAlgorithmParameterException {\n+            throw new InvalidAlgorithmParameterException();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/crypto\/KDF\/KDFDelayedProviderThreadingTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.Provider;\n+\n+\/**\n+ * This class is included here to enable testing of Delayed Provider Selection\n+ * by certain KDF tests. It only stubs out the necessary methods.\n+ *\n+ * @since 24\n+ *\/\n+final class ProviderVerifier {\n+\n+    private final CryptoPermissions appPerms = null;\n+\n+    \/**\n+     * Creates a {@code ProviderVerifier} object to verify the given URL.\n+     *\n+     * @param jarURL the JAR file to be verified.\n+     * @param savePerms if {@code true}, save the permissions allowed by the\n+     *          exemption mechanism\n+     *\/\n+    ProviderVerifier(URL jarURL, boolean savePerms) {\n+        this(jarURL, null, savePerms);\n+    }\n+\n+    \/**\n+     * Creates a {@code ProviderVerifier} object to verify the given URL.\n+     *\n+     * @param jarURL the JAR file to be verified\n+     * @param provider the corresponding provider.\n+     * @param savePerms if {@code true}, save the permissions allowed by the\n+     *          exemption mechanism\n+     *\/\n+    ProviderVerifier(URL jarURL, Provider provider, boolean savePerms) {\n+        \/\/ The URL for the JAR file we want to verify.\n+    }\n+\n+    \/**\n+     * Only a stub is needed for the Delayed Provider Selection test.\n+     *\/\n+    void verify() throws IOException { return; }\n+\n+    \/**\n+     * Verify that the provided certs include the\n+     * framework signing certificate.\n+     *\n+     * @param certs the list of certs to be checked.\n+     * @throws Exception if the list of certs did not contain\n+     *          the framework signing certificate\n+     *\/\n+    static void verifyPolicySigned(java.security.cert.Certificate[] certs)\n+            throws Exception {\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the given provider is JDK trusted crypto provider\n+     * if the implementation supports fast-path verification.\n+     *\/\n+    static boolean isTrustedCryptoProvider(Provider provider) {\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the permissions which are bundled with the JAR file,\n+     * aka the \"cryptoperms\" file.\n+     * <p>\n+     * NOTE: if this {@code ProviderVerifier} instance is constructed\n+     * with \"savePerms\" equal to {@code false}, then this method would always\n+     * return {@code null}.\n+     *\/\n+    CryptoPermissions getPermissions() {\n+        return appPerms;\n+    }\n+}\n","filename":"test\/jdk\/security\/unsignedjce\/java.base\/javax\/crypto\/ProviderVerifier.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}