{"files":[{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import javax.crypto.KDFSpi;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\/**\n+ * KDF implementation for the HKDF function.\n+ * <p>\n+ * This class implements the HKDF-Extract and HKDF-Expand functions from RFC\n+ * 5869.  This implementation provides the complete Extract-then-Expand HKDF\n+ * function as well as Extract-only and Expand-only variants.\n+ *\/\n+abstract class HkdfKeyDerivation extends KDFSpi {\n+\n+    protected final int hmacLen;\n+    protected final String hmacAlgName;\n+\n+    \/**\n+     * The sole constructor.\n+     *\n+     * @param kdfParameters\n+     *     the initialization parameters (may be {@code null})\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    HkdfKeyDerivation(String hmacAlgName, int hmacLen,\n+                      KDFParameters kdfParameters)\n+        throws InvalidAlgorithmParameterException {\n+        super(kdfParameters);\n+        if (kdfParameters != null) {\n+            throw new InvalidAlgorithmParameterException(\n+                hmacAlgName + \" does not support parameters\");\n+        }\n+        this.hmacAlgName = hmacAlgName;\n+        this.hmacLen = hmacLen;\n+    }\n+\n+    \/**\n+     * Derive a key, returned as a {@code SecretKey}.\n+     *\n+     * @return a derived {@code SecretKey} object of the specified algorithm\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationParameterSpec} is\n+     *     invalid or if the combination of {@code alg} and the {@code derivationParameterSpec}\n+     *     results in something invalid, ie - a key of inappropriate length\n+     *     for the specified algorithm\n+     * @throws NoSuchAlgorithmException\n+     *     if {@code alg} is empty or invalid\n+     * @throws IllegalArgumentException\n+     *     if {@code alg} is {@code null} or empty\n+     *\/\n+    @Override\n+    protected SecretKey engineDeriveKey(String alg,\n+                                        AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+\n+        if (alg == null) {\n+            throw new NullPointerException(\n+                \"the algorithm for the SecretKey return value must not be null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\n+                \"the algorithm for the SecretKey return value must not be \"\n+                + \"empty\");\n+        }\n+\n+        return new SecretKeySpec(engineDeriveData(derivationSpec), alg);\n+\n+    }\n+\n+    \/**\n+     * Obtain raw data from a key derivation function.\n+     *\n+     * @return a derived {@code byte[]}\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code KDFParameterSpec} is\n+     *     invalid or incorrect for the type of key to be derived\n+     * @throws UnsupportedOperationException\n+     *     if the derived keying material is not extractable\n+     *\/\n+    @Override\n+    protected byte[] engineDeriveData(AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException {\n+        List<SecretKey> ikms;\n+        List<SecretKey> salts;\n+        byte[] inputKeyMaterial;\n+        byte[] salt;\n+        byte[] pseudoRandomKey;\n+        byte[] info;\n+        int length;\n+        \/\/ A switch would be nicer, but we may need to backport this before\n+        \/\/ JDK 17\n+        \/\/ Also, JEP 305 came out in JDK 14, so we can't declare a variable\n+        \/\/ in instanceof either\n+        if (derivationSpec instanceof HKDFParameterSpec.Extract) {\n+            HKDFParameterSpec.Extract anExtract =\n+                (HKDFParameterSpec.Extract) derivationSpec;\n+            ikms = anExtract.ikms();\n+            salts = anExtract.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"Issue encountered when combining ikm or salt values into\"\n+                    + \" single keys\").initCause(ike);\n+            }\n+            \/\/ perform extract\n+            try {\n+                return hkdfExtract(inputKeyMaterial, salt);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF Extract could not be initialized with the given \"\n+                    + \"key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.Expand) {\n+            HKDFParameterSpec.Expand anExpand =\n+                (HKDFParameterSpec.Expand) derivationSpec;\n+            \/\/ set this value in the \"if\"\n+            if ((pseudoRandomKey = anExpand.prk().getEncoded()) == null) {\n+                throw new AssertionError(\n+                    \"PRK is required for HKDFParameterSpec.Expand\");\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Requested length exceeds maximum allowed length\");\n+            }\n+            \/\/ perform expand\n+            try {\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF Expand could not be initialized with the given \"\n+                    + \"keying material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        } else if (derivationSpec instanceof HKDFParameterSpec.ExtractThenExpand) {\n+            HKDFParameterSpec.ExtractThenExpand anExtractThenExpand =\n+                (HKDFParameterSpec.ExtractThenExpand) derivationSpec;\n+            ikms = anExtractThenExpand.ikms();\n+            salts = anExtractThenExpand.salts();\n+            \/\/ we should be able to combine both of the above Lists of key\n+            \/\/ segments into one SecretKey object each, unless we were passed\n+            \/\/ something bogus or an unexportable P11 key\n+            try {\n+                inputKeyMaterial = consolidateKeyMaterial(ikms);\n+                salt = consolidateKeyMaterial(salts);\n+            } catch (InvalidKeyException ike) {\n+                throw (InvalidAlgorithmParameterException) new InvalidAlgorithmParameterException(\n+                    \"Issue encountered when combining ikm or salt values into\"\n+                    + \" single keys\").initCause(ike);\n+            }\n+            \/\/ set this value in the \"if\"\n+            if ((info = anExtractThenExpand.info()) == null) {\n+                info = new byte[0];\n+            }\n+            length = anExtractThenExpand.length();\n+            if (length > (hmacLen * 255)) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"Requested length exceeds maximum allowed length\");\n+            }\n+            \/\/ perform extract and then expand\n+            try {\n+                pseudoRandomKey = hkdfExtract(inputKeyMaterial, salt);\n+                return hkdfExpand(pseudoRandomKey, info, length);\n+            } catch (InvalidKeyException ike) {\n+                throw new InvalidAlgorithmParameterException(\n+                    \"an HKDF ExtractThenExpand could not be initialized with \"\n+                    + \"the given key or salt material\", ike);\n+            } catch (NoSuchAlgorithmException nsae) {\n+                \/\/ This is bubbling up from the getInstance of the Mac\/Hmac.\n+                \/\/ Since we're defining these values internally, it is unlikely.\n+                throw new ProviderException(\n+                    \"could not instantiate a Mac with the provided algorithm\",\n+                    nsae);\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"an HKDF derivation requires a valid HKDFParameterSpec\");\n+    }\n+\n+    private byte[] consolidateKeyMaterial(List<SecretKey> keys)\n+        throws InvalidKeyException {\n+        if (keys != null && !keys.isEmpty()) {\n+            ArrayList<SecretKey> localKeys = new ArrayList<>(keys);\n+            if (localKeys.size() == 1) {\n+                \/\/ return this element\n+                SecretKey checkIt = localKeys.get(0);\n+                return CipherCore.getKeyBytes(checkIt);\n+            } else {\n+                ByteArrayOutputStream os = new ByteArrayOutputStream();\n+                for (SecretKey workItem : localKeys) {\n+                    os.writeBytes(CipherCore.getKeyBytes(workItem));\n+                }\n+                return os.toByteArray();\n+            }\n+        } else if(keys != null) {\n+                return null;\n+        } else {\n+            throw new InvalidKeyException(\n+                \"List of key segments could not be consolidated\");\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Extract operation.\n+     *\n+     * @param inputKeyMaterial\n+     *     the input keying material used for the HKDF-Extract operation.\n+     * @param salt\n+     *     the salt value used for HKDF-Extract; {@code null} if no salt value\n+     *     is provided.\n+     *\n+     * @return a byte array containing the pseudorandom key (PRK)\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid salt was provided through the\n+     *     {@code HkdfParameterSpec}\n+     *\/\n+    private byte[] hkdfExtract(byte[] inputKeyMaterial, byte[] salt)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+\n+        if (salt == null) {\n+            salt = new byte[hmacLen];\n+        }\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+        hmacObj.init(new SecretKeySpec(salt, hmacAlgName));\n+\n+        if (inputKeyMaterial == null) {\n+            return hmacObj.doFinal();\n+        } else {\n+            return hmacObj.doFinal(inputKeyMaterial);\n+        }\n+    }\n+\n+    \/**\n+     * Perform the HKDF-Expand operation.\n+     *\n+     * @param prk\n+     *     the pseudorandom key used for HKDF-Expand\n+     * @param info\n+     *     optional context and application specific information or {@code null}\n+     *     if no info data is provided.\n+     * @param outLen\n+     *     the length in bytes of the required output\n+     *\n+     * @return a byte array containing the complete KDF output.  This will be at\n+     *     least as long as the requested length in the {@code outLen}\n+     *     parameter, but will be rounded up to the nearest multiple of the HMAC\n+     *     output length.\n+     *\n+     * @throws InvalidKeyException\n+     *     if an invalid PRK was provided through the {@code HKDFParameterSpec}\n+     *     or derived during the extract phase.\n+     *\/\n+    private byte[] hkdfExpand(byte[] prk, byte[] info, int outLen)\n+        throws InvalidKeyException, NoSuchAlgorithmException {\n+        byte[] kdfOutput;\n+        SecretKey pseudoRandomKey = new SecretKeySpec(prk, hmacAlgName);\n+\n+        Mac hmacObj = Mac.getInstance(hmacAlgName);\n+\n+        \/\/ Calculate the number of rounds of HMAC that are needed to\n+        \/\/ meet the requested data.  Then set up the buffers we will need.\n+        if (CipherCore.getKeyBytes(pseudoRandomKey).length < hmacLen) {\n+            throw new InvalidKeyException(\n+                \"prk must be at least \" + hmacLen + \" bytes\");\n+        }\n+        hmacObj.init(pseudoRandomKey);\n+        if (info == null) {\n+            info = new byte[0];\n+        }\n+        int rounds = (outLen + hmacLen - 1) \/ hmacLen;\n+        kdfOutput = new byte[outLen];\n+        int i = 0;\n+        int offset = 0;\n+        try {\n+            while (i < rounds) {\n+                if (i > 0) {\n+                    hmacObj.update(kdfOutput, Math.max(0,offset - hmacLen), hmacLen); \/\/ add T(i-1)\n+                }\n+                hmacObj.update(info);                   \/\/ Add info\n+                hmacObj.update((byte) ++i);             \/\/ Add round number\n+                if (i == rounds && (outLen - offset < hmacLen)) {\n+                    \/\/ special handling for last chunk\n+                    byte[] tmp = hmacObj.doFinal();\n+                    System.arraycopy(tmp, 0, kdfOutput, offset,\n+                                     outLen - offset);\n+                    offset = outLen;\n+                } else {\n+                    hmacObj.doFinal(kdfOutput, offset);\n+                    offset += hmacLen;\n+                }\n+            }\n+        } catch (ShortBufferException sbe) {\n+            \/\/ This really shouldn't happen given that we've\n+            \/\/ sized the buffers to their largest possible size up-front,\n+            \/\/ but just in case...\n+            throw new ProviderException(sbe);\n+        }\n+        return kdfOutput;\n+    }\n+\n+    protected KDFParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    public static final class HkdfSHA256 extends HkdfKeyDerivation {\n+        public HkdfSHA256(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA256\", 32, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HkdfSHA384 extends HkdfKeyDerivation {\n+        public HkdfSHA384(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA384\", 48, kdfParameters);\n+        }\n+    }\n+\n+    public static final class HkdfSHA512 extends HkdfKeyDerivation {\n+        public HkdfSHA512(KDFParameters kdfParameters)\n+            throws InvalidAlgorithmParameterException {\n+            super(\"HmacSHA512\", 64, kdfParameters);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -460,0 +460,10 @@\n+        \/*\n+         * Key Derivation engines\n+         *\/\n+        ps(\"KDF\", \"HKDF-SHA256\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA256\");\n+        ps(\"KDF\", \"HKDF-SHA384\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA384\");\n+        ps(\"KDF\", \"HKDF-SHA512\",\n+                \"com.sun.crypto.provider.HkdfKeyDerivation$HkdfSHA512\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A specification of {@code KDF} parameters.\n+ * <p>\n+ * The purpose of this interface is to group (and provide type safety for) all\n+ * {@code KDF} parameter specifications. All {@code KDF} parameter\n+ * specifications must implement this interface.\n+ * <p>\n+ * A {@code KDFParameters} object is passed as a parameter to one of\n+ * the\n+ * {@link javax.crypto.KDF#getInstance(String, KDFParameters) KDF.getInstance}\n+ * methods. The {@code getInstance} method returns a {@code KDF}.\n+ * <p>\n+ * {@code KDF} implementations may choose to supply additional default or\n+ * random parameter values used by the underlying KDF algorithm. If required\n+ * parameters were not supplied and can be generated by the {@code KDF}\n+ * object, these may be supplied by the implementation. For additional\n+ * information, see: {@link javax.crypto.KDF#getParameters()}.\n+ *\n+ * @see javax.crypto.KDF#getInstance(String, KDFParameters)\n+ * @see javax.crypto.KDF#getParameters()\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface KDFParameters {}\n","filename":"src\/java.base\/share\/classes\/java\/security\/KDFParameters.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1607,0 +1607,1 @@\n+        addEngine(\"KDF\",                                false, KDFParameters.class);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,676 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import sun.security.jca.GetInstance;\n+import sun.security.jca.GetInstance.Instance;\n+import sun.security.util.Debug;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Provider.Service;\n+import java.security.ProviderException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Derivation Function (KDF),\n+ * which is a cryptographic algorithm for deriving additional keys from input\n+ * keying material and (optionally) other data.\n+ * <p>\n+ * {@code KDF} objects are instantiated with the {@code getInstance} family\n+ * of methods.\n+ * <p>\n+ * The class has two derive methods, {@code deriveKey} and {@code deriveData}.\n+ * The {@code deriveKey} method accepts an algorithm {@code String} and\n+ * will return a {@code SecretKey} object with the specified algorithm. The\n+ * {@code deriveData} method returns a byte array of raw data.\n+ * <p>\n+ * API Usage Example:\n+ * {@snippet lang = java:\n+ *    KDF kdfHkdf = KDF.getInstance(\"HKDF-SHA256\");\n+ *\n+ *    AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 32);\n+ *\n+ *    SecretKey sKey = kdfHkdf.deriveKey(\"AES\", derivationSpec);\n+ *}\n+ * <br>\n+ * <h2><a id=\"ConcurrentAccess\">Concurrent Access<\/a><\/h2>\n+ * Unless otherwise documented by an implementation, the methods defined in\n+ * this class are not thread-safe. Multiple threads that need to access a\n+ * single object concurrently should synchronize amongst themselves and\n+ * provide the necessary locking. Multiple threads each manipulating separate\n+ * objects need not synchronize.\n+ * <br>\n+ * <h2><a id=\"DelayedProviderSelection\">Delayed Provider Selection<\/a><\/h2>\n+ * If a provider is not specified when calling one of the {@code getInstance}\n+ * methods, the implementation delays the selection of the provider until the\n+ * {@code deriveKey} or {@code deriveData} method is called. This is called\n+ * <i>delayed provider selection<\/i>. The primary reason this is done is to\n+ * ensure that the selected provider can handle the key material that is passed\n+ * to those methods - for example, the key material may reside on a\n+ * hardware device that only a specific {@code KDF} provider can utilize.\n+ * <p>\n+ * If a provider is not specified in the {@code getInstance} method when\n+ * instantiating a {@code KDF} object, the provider is selected the first time\n+ * the {@code deriveKey} or {@code deriveData} method is called, and a provider\n+ * is chosen that supports the parameters passed to the {@code deriveKey} or\n+ * {@code deriveData} method. If the {@code getProviderName} or {@code\n+ * getParameters} method is called before the {@code deriveKey} or {@code\n+ * deriveData} methods, the first provider supporting the KDF algorithm and\n+ * optional {@code KDFParameters} is chosen. This provider may not support\n+ * the key material that is subsequently passed to the deriveKey or\n+ * deriveData methods. Therefore, it is recommended not to call the {@code\n+ * getProviderName} or {@code getParameters} methods until after a key\n+ * derivation operation. Once a provider is selected, it cannot be changed.\n+ *\n+ * @see KDFParameters\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public final class KDF {\n+    private static final Debug debug = Debug.getInstance(\"jca\", \"KDF\");\n+\n+    private static final Debug pdebug = Debug.getInstance(\"provider\",\n+                                                          \"Provider\");\n+    private static final boolean skipDebug = Debug.isOn(\"engine=\")\n+                                             && !Debug.isOn(\"kdf\");\n+\n+    private record Delegate(KDFSpi spi, Provider provider) {}\n+\n+    private Delegate pairOfSpiAndProv;\n+    private Delegate firstPairOfSpiAndProv;\n+\n+    \/\/ The name of the KDF algorithm.\n+    private final String algorithm;\n+\n+    \/\/ Additional KDF configuration parameters\n+    private final KDFParameters kdfParameters;\n+\n+    \/\/ remaining services to try in provider selection\n+    \/\/ null once provider is selected\n+    private Iterator<Service> serviceIterator;\n+\n+    private final Object lock;\n+\n+    \/**\n+     * Instantiates a {@code KDF} object. This constructor is called when a\n+     * provider is supplied to {@code getInstance}.\n+     *\n+     * @param delegate the delegate\n+     * @param algorithm the algorithm\n+     *\/\n+    private KDF(Delegate delegate, String algorithm, KDFParameters kdfParameters) {\n+        this.pairOfSpiAndProv = delegate;\n+        this.algorithm = algorithm;\n+        \/\/ note that the parameters are being passed to the impl in getInstance\n+        this.kdfParameters = kdfParameters;\n+        serviceIterator = null;\n+        lock = new Object();\n+    }\n+\n+    \/**\n+     * Instantiates a {@code KDF} object. This constructor is called when a\n+     * provider is not supplied to {@code getInstance}.\n+     *\n+     * @param firstPairOfSpiAndProv the delegate\n+     * @param t the service iterator\n+     * @param algorithm the algorithm\n+     * @param kdfParameters the algorithm parameters\n+     *\/\n+    private KDF(Delegate firstPairOfSpiAndProv, Iterator<Service> t, String algorithm,\n+                KDFParameters kdfParameters) {\n+        this.firstPairOfSpiAndProv = firstPairOfSpiAndProv;\n+        serviceIterator = t;\n+        this.algorithm = algorithm;\n+        this.kdfParameters = kdfParameters;\n+        lock = new Object();\n+    }\n+\n+    \/**\n+     * Returns the algorithm name of this {@code KDF} object.\n+     *\n+     * @return the algorithm name of this {@code KDF} object\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+\n+    \/**\n+     * Returns the name of the provider.\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider Selection<\/a>\n+     *\n+     * @return the name of the provider\n+     *\/\n+    public String getProviderName() {\n+        useFirstSpi();\n+        return pairOfSpiAndProv.provider().getName();\n+    }\n+\n+    \/**\n+     * Returns the {@code KDFParameters} used with this {@code KDF} object.\n+     * <p>\n+     * The returned parameters may be the same that were used to initialize\n+     * this {@code KDF} object, or may contain additional default or\n+     * random parameter values used by the underlying KDF algorithm.\n+     * If the required parameters were not supplied and can be generated by\n+     * the {@code KDF} object, the generated parameters are returned;\n+     * otherwise {@code null} is returned.\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider Selection<\/a>\n+     *\n+     * @return the parameters used with this {@code KDF} object, or\n+     * {@code null}\n+     *\/\n+    public KDFParameters getParameters() {\n+        useFirstSpi();\n+        return pairOfSpiAndProv.spi().engineGetParameters();\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm.\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider Selection<\/a>\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDF} implementation for the\n+     *     specified algorithm\n+     * @throws NullPointerException\n+     *     if {@code algorithm} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm)\n+        throws NoSuchAlgorithmException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        try {\n+            return getInstance(algorithm, (KDFParameters) null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider. The specified provider must be\n+     * registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if the specified provider does not support the specified {@code KDF}\n+     *     algorithm\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws NullPointerException\n+     *     if the {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified security provider. The specified provider must be\n+     * registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if the specified provider does not support the specified {@code KDF}\n+     *     algorithm\n+     * @throws NullPointerException\n+     *     if the {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm, Provider provider)\n+        throws NoSuchAlgorithmException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            return getInstance(algorithm, null, provider);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new NoSuchAlgorithmException(\n+                \"No implementation found using null KDFParameters\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm and\n+     * is initialized with the specified parameters.\n+     *\n+     * @see <a href=\"#DelayedProviderSelection\">Delayed Provider Selection<\/a>\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure the derivation\n+     *     algorithm or {@code null} if no parameters are provided\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if no {@code Provider} supports a {@code KDF} implementation for the\n+     *     specified algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm and parameters\n+     * @throws NullPointerException\n+     *     if the {@code algorithm} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        \/\/ make sure there is at least one service from a signed provider\n+        Iterator<Service> t = GetInstance.getServices(\"KDF\", algorithm);\n+        NoSuchAlgorithmException lastException = null;\n+        while (t.hasNext()) {\n+            Service s = t.next();\n+            if (!JceSecurity.canUseProvider(s.getProvider())) {\n+                continue;\n+            }\n+            try {\n+                Object obj = s.newInstance(kdfParameters);\n+                if (!(obj instanceof KDFSpi spiObj)) {\n+                    lastException = new NoSuchAlgorithmException(\n+                        new InvalidAlgorithmParameterException(\n+                            \"No provider can be found that supports the \"\n+                            + \"specified parameters\"));\n+                    if (!skipDebug && pdebug != null) {\n+                        pdebug.println(\n+                            \"obj was not an instance of KDFSpi (should not \"\n+                            + \"happen)\");\n+                    }\n+                    \/\/ continue to next iteration\n+                } else if (t.hasNext()) {\n+                    return new KDF(new Delegate(spiObj, s.getProvider()), t,\n+                                   algorithm, kdfParameters);\n+                } else { \/\/ no other choices, lock down provider\n+                    return new KDF(new Delegate(spiObj, s.getProvider()),\n+                                   algorithm, kdfParameters);\n+                }\n+            } catch (NoSuchAlgorithmException e) {\n+                lastException =\n+                    new NoSuchAlgorithmException(\n+                        new InvalidAlgorithmParameterException(\n+                            \"No provider can be found that supports the \"\n+                            + \"specified parameters\"));\n+                if (!skipDebug && pdebug != null) {\n+                    pdebug.println(e.toString());\n+                }\n+                \/\/ continue to next iteration\n+            }\n+        }\n+        if (lastException != null) {\n+            return handleException(lastException);\n+        } else {\n+            throw new NoSuchAlgorithmException(\n+                \"Algorithm \" + algorithm + \" not available\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     * The specified provider must be registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure the derivation\n+     *     algorithm or {@code null} if no parameters are provided\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if the specified provider does not support the specified {@code KDF}\n+     *     algorithm\n+     * @throws NoSuchProviderException\n+     *     if the specified provider is not registered in the security provider\n+     *     list\n+     * @throws InvalidAlgorithmParameterException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm and parameters\n+     * @throws NullPointerException\n+     *     if the {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException,\n+               InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        kdfParameters,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new NoSuchProviderException(msg);\n+            }\n+            return new KDF(new Delegate((KDFSpi) instance.impl,\n+                                        instance.provider), algorithm, kdfParameters);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code KDF} object that implements the specified algorithm from\n+     * the specified provider and is initialized with the specified parameters.\n+     * The specified provider must be registered in the security provider list.\n+     *\n+     * @param algorithm\n+     *     the key derivation algorithm to use.\n+     *     See the {@code KDF} section in the <a href=\n+     *     \"{@docRoot}\/..\/specs\/security\/standard-names.html#kdf-algorithms\">\n+     *     Java Security Standard Algorithm Names Specification<\/a>\n+     *     for information about standard KDF algorithm names.\n+     * @param kdfParameters\n+     *     the {@code KDFParameters} used to configure the derivation\n+     *     algorithm or {@code null} if no parameters are provided\n+     * @param provider\n+     *     the provider to use for this key derivation\n+     *\n+     * @return a {@code KDF} object\n+     *\n+     * @throws NoSuchAlgorithmException\n+     *     if the specified provider does not support the specified {@code KDF}\n+     *     algorithm\n+     * @throws InvalidAlgorithmParameterException\n+     *     if no {@code Provider} supports a {@code KDFSpi} implementation for\n+     *     the specified algorithm and parameters\n+     * @throws NullPointerException\n+     *     if the {@code algorithm} or {@code provider} is {@code null}\n+     *\/\n+    public static KDF getInstance(String algorithm,\n+                                  KDFParameters kdfParameters,\n+                                  Provider provider)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Objects.requireNonNull(algorithm, \"algorithm must not be null\");\n+        Objects.requireNonNull(provider, \"provider must not be null\");\n+        try {\n+            Instance instance = GetInstance.getInstance(\"KDF\", KDFSpi.class,\n+                                                        algorithm,\n+                                                        kdfParameters,\n+                                                        provider);\n+            if (!JceSecurity.canUseProvider(instance.provider)) {\n+                String msg = \"JCE cannot authenticate the provider \"\n+                             + instance.provider.getName();\n+                throw new SecurityException(msg);\n+            }\n+            return new KDF(new Delegate((KDFSpi) instance.impl,\n+                                        instance.provider), algorithm, kdfParameters);\n+\n+        } catch (NoSuchAlgorithmException nsae) {\n+            return handleException(nsae);\n+        }\n+    }\n+\n+    private static KDF handleException(NoSuchAlgorithmException e)\n+        throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {\n+        Throwable cause = e.getCause();\n+        if (cause instanceof InvalidAlgorithmParameterException) {\n+            throw (InvalidAlgorithmParameterException) cause;\n+        }\n+        throw e;\n+    }\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code deriveKey} method may be called multiple times on a particular\n+     * {@code KDF} instance, but it is not considered thread-safe.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code SecretKey} object\n+     * @param derivationSpec\n+     *     the object describing the inputs to the derivation function\n+     *\n+     * @return the derived key\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationSpec} is\n+     *     invalid or if the combination of {@code alg} and the {@code derivationSpec}\n+     *     results in something invalid\n+     * @throws NoSuchAlgorithmException\n+     *     if {@code alg} is empty or invalid\n+     * @throws NullPointerException\n+     *     if {@code alg} or {@code derivationSpec} is null\n+     *\/\n+    public SecretKey deriveKey(String alg,\n+                               AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+        if (alg == null) {\n+            throw new NullPointerException(\n+                \"the algorithm for the SecretKey return value must not be null\");\n+        }\n+        if (alg.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\n+                \"the algorithm for the SecretKey return value must not be \"\n+                + \"empty\");\n+        }\n+        Objects.requireNonNull(derivationSpec);\n+        if (delegateAndSpiAreInitialized(pairOfSpiAndProv)) {\n+            return pairOfSpiAndProv.spi().engineDeriveKey(alg, derivationSpec);\n+        } else {\n+            return (SecretKey) chooseProvider(alg, derivationSpec);\n+        }\n+    }\n+\n+    \/**\n+     * Obtains raw data from a key derivation function.\n+     * <p>\n+     * The {@code deriveData} method may be called multiple times on a\n+     * particular {@code KDF} instance, but it is not considered thread-safe.\n+     *\n+     * @param derivationSpec\n+     *     the object describing the inputs to the derivation function\n+     *\n+     * @return the derived key in its raw bytes\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationSpec} is\n+     *     invalid\n+     * @throws UnsupportedOperationException\n+     *     if the derived keying material is not extractable\n+     * @throws NullPointerException\n+     *     if {@code derivationSpec} is null\n+     *\/\n+    public byte[] deriveData(AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException {\n+\n+        Objects.requireNonNull(derivationSpec);\n+        if (delegateAndSpiAreInitialized(pairOfSpiAndProv)) {\n+            return pairOfSpiAndProv.spi().engineDeriveData(derivationSpec);\n+        } else {\n+            try {\n+                return (byte[]) chooseProvider(null, derivationSpec);\n+            } catch (NoSuchAlgorithmException e) {\n+                \/\/ this will never be thrown in the deriveData case\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Use the firstSpi as the chosen KDFSpi and set the fields accordingly\n+     *\/\n+    private void useFirstSpi() {\n+        if ((delegateAndSpiAreInitialized(pairOfSpiAndProv)) || (serviceIterator == null)) return;\n+\n+        synchronized (lock) {\n+            if ((delegateIsNullOrSpiIsNull(pairOfSpiAndProv)) && (serviceIterator != null)) {\n+                pairOfSpiAndProv = firstPairOfSpiAndProv;\n+                \/\/ not needed any more\n+                firstPairOfSpiAndProv = new Delegate(null, null);\n+                serviceIterator = null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Selects the provider which supports the passed {@code algorithm} and\n+     * {@code derivationSpec} values, and assigns the global spi and\n+     * provider variables if they have not been assigned yet.\n+     * <p>\n+     * If the spi has already been set, it will just return the result.\n+     *\/\n+    private Object chooseProvider(String algorithm,\n+                                  AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+\n+        boolean isDeriveData = (algorithm == null);\n+\n+        synchronized (lock) {\n+            if (delegateAndSpiAreInitialized(pairOfSpiAndProv)) {\n+                return (isDeriveData) ? pairOfSpiAndProv.spi().engineDeriveData(\n+                    derivationSpec) : pairOfSpiAndProv.spi().engineDeriveKey(algorithm,\n+                                                                   derivationSpec);\n+            }\n+\n+            Exception lastException = null;\n+            while ((delegateAndSpiAreInitialized(firstPairOfSpiAndProv)) || serviceIterator.hasNext()) {\n+                KDFSpi currSpi;\n+                Provider currProv;\n+                if (delegateAndSpiAreInitialized(firstPairOfSpiAndProv)) {\n+                    currSpi = firstPairOfSpiAndProv.spi();\n+                    currProv = firstPairOfSpiAndProv.provider();\n+                    firstPairOfSpiAndProv = new Delegate(null, null);\n+                } else {\n+                    Service s = serviceIterator.next();\n+                    currProv = s.getProvider();\n+                    if (!JceSecurity.canUseProvider(currProv)) {\n+                        continue;\n+                    }\n+                    try {\n+                        Object obj = s.newInstance(kdfParameters);\n+                        if (!(obj instanceof KDFSpi)) {\n+                            continue;\n+                        }\n+                        currSpi = (KDFSpi) obj;\n+                    } catch (Exception e) {\n+                        \/\/ continue to the next provider\n+                        continue;\n+                    }\n+                }\n+\n+                try {\n+                    Object result = (isDeriveData) ? currSpi.engineDeriveData(\n+                        derivationSpec) : currSpi.engineDeriveKey(\n+                        algorithm, derivationSpec);\n+                    \/\/ found a working KDFSpi\n+                    this.pairOfSpiAndProv = new Delegate(currSpi, currProv);\n+                    \/\/ not looking further\n+                    serviceIterator = null;\n+                    return result;\n+                } catch (Exception e) {\n+                    if (lastException == null) {\n+                        lastException = e;\n+                    }\n+                }\n+            }\n+            \/\/ no working provider found, fail\n+            if (lastException instanceof InvalidAlgorithmParameterException) {\n+                throw (InvalidAlgorithmParameterException) lastException;\n+            }\n+            if (lastException instanceof RuntimeException) {\n+                throw (RuntimeException) lastException;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+            \"No installed provider supports the \" +\n+            ((isDeriveData) ? \"deriveData\" : \"deriveKey\")\n+            + \" method with these parameters\");\n+    }\n+\n+    boolean delegateAndSpiAreInitialized(Delegate delegate) {\n+        return (delegate != null && delegate.spi() != null);\n+    }\n+\n+    boolean delegateIsNullOrSpiIsNull(Delegate delegate) {\n+        return (delegate == null || delegate.spi() == null);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":676,"deletions":0,"binary":false,"changes":676,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ * This class defines the <i>Service Provider Interface<\/i> (<b>SPI<\/b>) for the\n+ * {@code KDF} class.\n+ * <p>\n+ * All the abstract methods in this class must be implemented by each\n+ * cryptographic service provider who wishes to supply the implementation of a\n+ * particular key derivation algorithm.\n+ * <p>\n+ * In addition, all implementations must provide a public constructor which\n+ * accepts a {@code KDFParameters} object. The constructor must call {@code\n+ * super(params)} passing the parameters supplied. The constructor must also\n+ * throw an {@code InvalidAlgorithmParameterException} if the supplied\n+ * parameters are inappropriate.\n+ * <p>\n+ * Implementations which do not support {@code KDFParameters} may require\n+ * {@code null} to be passed, otherwise an {@code InvalidAlgorithmParameterException}\n+ * may be thrown. On the other hand, implementations which require\n+ * {@code KDFParameters} should throw an {@code InvalidAlgorithmParameterException}\n+ * upon receiving a {@code null} value. Furthermore, implementations may\n+ * return parameters with additional default values or random parameter\n+ * values used by the underlying {@code KDF} algorithm. See\n+ * {@link KDFSpi#engineGetParameters()} for more details.\n+ *\n+ * @see KDF\n+ * @see KDFParameters\n+ * @see KDF#getParameters()\n+ * @see SecretKey\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public abstract class KDFSpi {\n+\n+    \/**\n+     * The sole constructor.\n+     * <p>\n+     * A {@code KDFParameters} object may be specified for KDF algorithms\n+     * that support initialization parameters.\n+     *\n+     * @param kdfParameters\n+     *     the initialization parameters for the {@code KDF} algorithm (may be\n+     *     {@code null})\n+     *\n+     * @see KDF#getParameters()\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the initialization parameters are inappropriate for this\n+     *     {@code KDFSpi}\n+     *\/\n+    protected KDFSpi(KDFParameters kdfParameters)\n+        throws InvalidAlgorithmParameterException {}\n+\n+    \/**\n+     * Returns the {@code KDFParameters} used with this {@code KDF} object.\n+     * <p>\n+     * The returned parameters may be the same that were used to initialize\n+     * this {@code KDF} object, or may contain additional default or\n+     * random parameter values used by the underlying KDF algorithm.\n+     * If the required parameters were not supplied and can be generated by\n+     * the {@code KDF} object, the generated parameters are returned;\n+     * otherwise {@code null} is returned.\n+     *\n+     * @return the parameters used with this {@code KDF} object, or\n+     * {@code null}\n+     *\/\n+    protected abstract KDFParameters engineGetParameters();\n+\n+    \/**\n+     * Derives a key, returned as a {@code SecretKey}.\n+     * <p>\n+     * The {@code engineDeriveKey} method may be called multiple times on a particular\n+     * {@code KDFSpi} instance, but it is not considered thread-safe.\n+     *\n+     * @param alg\n+     *     the algorithm of the resultant {@code SecretKey} object\n+     * @param derivationSpec\n+     *     derivation parameters\n+     *\n+     * @return the derived key.\n+     *\n+     * @implNote If the resultant key is extractable, then its {@code\n+     * getEncoded} value should have the same content as the result of {@code\n+     * deriveData}.\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationSpec} is\n+     *     invalid or if the combination of {@code alg} and the {@code derivationSpec}\n+     *     results in something invalid\n+     * @throws NoSuchAlgorithmException\n+     *     if {@code alg} is empty or invalid\n+     * @throws NullPointerException\n+     *     if {@code alg} or {@code derivationSpec} is null\n+     *\/\n+    protected abstract SecretKey engineDeriveKey(String alg,\n+                                                 AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException;\n+\n+    \/**\n+     * Obtains raw data from a key derivation function.\n+     * <p>\n+     * The {@code engineDeriveData} method may be called multiple times on a\n+     * particular {@code KDFSpi} instance, but it is not considered thread-safe.\n+     *\n+     * @param derivationSpec\n+     *     derivation parameters\n+     *\n+     * @return the derived key in its raw bytes.\n+     *\n+     * @throws InvalidAlgorithmParameterException\n+     *     if the information contained within the {@code derivationSpec} is\n+     *     invalid\n+     * @throws UnsupportedOperationException\n+     *     if the derived keying material is not extractable\n+     * @throws NullPointerException\n+     *     if {@code derivationSpec} is null\n+     *\/\n+    protected abstract byte[] engineDeriveData(\n+        AlgorithmParameterSpec derivationSpec)\n+        throws InvalidAlgorithmParameterException;\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDFSpi.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,493 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto.spec;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import javax.crypto.SecretKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * Parameters for the combined Extract, Expand, or Extract-then-Expand\n+ * operations of the HMAC-based Key Derivation Function (HKDF). The HKDF\n+ * function is defined in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC\n+ * 5869<\/a>.\n+ * <p>\n+ * In the Extract and Extract-then-Expand cases, the {@code addIKM} and\n+ * {@code addSalt} methods may be called repeatedly (and chained). This provides\n+ * for use-cases where a portion of the IKM resides in a non-extractable\n+ * {@code SecretKey} and the whole IKM cannot be provided as a single object.\n+ * The caller may wish to provide a label (or other components) of\n+ * the IKM without having access to all portions. The same feature is\n+ * available for salts.\n+ * <p>\n+ * The above feature is particularly useful for \"labeled\" HKDF Extract used in\n+ * TLS 1.3 and HPKE, where the IKM consists of concatenated components, which\n+ * may include both byte arrays and (possibly non-extractable) secret keys.\n+ * <p>\n+ * Examples:\n+ * {@snippet lang = java:\n+ *\n+ * \/\/ this usage depicts the initialization of an HKDF-Extract AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(label)\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).extractOnly();\n+ *\n+ *\n+ *}\n+ * {@snippet lang = java:\n+ *\n+ * \/\/ this usage depicts the initialization of an HKDF-Expand AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.expandOnly(prk, info, 32);\n+ *\n+ *}\n+ * {@snippet lang = java:\n+ *\n+ * \/\/ this usage depicts the initialization of an HKDF-ExtractExpand AlgorithmParameterSpec\n+ * AlgorithmParameterSpec derivationSpec =\n+ *             HKDFParameterSpec.ofExtract()\n+ *                              .addIKM(ikm)\n+ *                              .addSalt(salt).thenExpand(info, 32);\n+ *\n+ *}\n+ *\n+ * @since 24\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+public interface HKDFParameterSpec extends AlgorithmParameterSpec {\n+\n+    \/**\n+     * This {@code Builder} builds {@code Extract} and {@code ExtractThenExpand}\n+     * objects.\n+     * <p>\n+     * The {@code Builder} is initialized via the {@code ofExtract} method of\n+     * {@code HKDFParameterSpec}. As stated in the class description,\n+     * {@code addIKM} and\/or {@code addSalt} may be called as needed. Finally,\n+     * the object is \"built\" by calling either {@code extractOnly} or\n+     * {@code thenExpand} for {@code Extract} and {@code ExtractThenExpand}\n+     * use-cases respectively. Note that the {@code Builder} is not\n+     * thread-safe.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Builder {\n+\n+        List<SecretKey> ikms = new ArrayList<>();\n+        List<SecretKey> salts = new ArrayList<>();\n+\n+        private Builder() {}\n+\n+        \/**\n+         * Creates a {@code Builder} for an {@code Extract}.\n+         *\n+         * @return a {@code Builder} to mutate\n+         *\/\n+        private Builder createBuilder() {\n+            return this;\n+        }\n+\n+        \/**\n+         * Builds an {@code Extract} from the current state of the\n+         * {@code Builder}.\n+         *\n+         * @return an immutable {@code Extract}\n+         *\/\n+        public Extract extractOnly() {\n+            return new Extract(ikms, salts);\n+        }\n+\n+        \/**\n+         * Builds an {@code ExtractThenExpand}.\n+         *\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte array is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output keying material (must be greater than 0)\n+         *\n+         * @implNote HKDF implementations will enforce that the length is less\n+         * than 255 * HMAC length.\n+         *\n+         * @return an {@code ExtractThenExpand}\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} is not greater than 0\n+         *\/\n+        public ExtractThenExpand thenExpand(byte[] info, int length) {\n+            return new ExtractThenExpand(\n+                extractOnly(), info,\n+                length);\n+        }\n+\n+        \/**\n+         * Adds input keying material to the builder.\n+         * <p>\n+         * {@code addIKM} may be called when the input keying material value is to\n+         * be assembled piece-meal or if part of the IKM is to be supplied by a\n+         * hardware crypto device. This method appends to the existing list of\n+         * values or creates a new list if there is none yet.\n+         *\n+         * @param ikm\n+         *     the input keying material value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code ikm} is null\n+         *\/\n+        public Builder addIKM(SecretKey ikm) {\n+            Objects.requireNonNull(ikm, \"ikm must not be null\");\n+            ikms.add(ikm);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds input keying material to the builder.\n+         * <p>\n+         * {@code addIKM} may be called when the input keying material value is to\n+         * be assembled piece-meal or if part of the IKM is to be supplied by a\n+         * hardware crypto device. This method appends to the existing list of\n+         * values or creates a new list if there is none yet.\n+         *\n+         * @param ikm\n+         *     the input keying material value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code ikm} is null\n+         *\/\n+        public Builder addIKM(byte[] ikm) {\n+            Objects.requireNonNull(ikm, \"ikm must not be null\");\n+            if (ikm.length != 0) {\n+                return addIKM(new SecretKeySpec(ikm, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder.\n+         * <p>\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there is none yet.\n+         *\n+         * @param salt\n+         *     the salt value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(SecretKey salt) {\n+            Objects.requireNonNull(salt, \"salt must not be null\");\n+            salts.add(salt);\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a salt to the builder.\n+         * <p>\n+         * {@code addSalt} may be called when the salt value is to be assembled\n+         * piece-meal or if part of the salt is to be supplied by a hardware\n+         * crypto device. This method appends to the existing list of values or\n+         * creates a new list if there is none yet.\n+         *\n+         * @param salt\n+         *     the salt value\n+         *\n+         * @return this builder\n+         *\n+         * @throws NullPointerException\n+         *     if the {@code salt} is null\n+         *\/\n+        public Builder addSalt(byte[] salt) {\n+            Objects.requireNonNull(salt, \"salt must not be null\");\n+            if (salt.length != 0) {\n+                return addSalt(new SecretKeySpec(salt, \"Generic\"));\n+            } else {\n+                return this;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a builder for building {@code Extract} and\n+     * {@code ExtractThenExpand} objects.\n+     *\n+     * @return a new {@code Builder}\n+     *\/\n+    static Builder ofExtract() {\n+        return new Builder().createBuilder();\n+    }\n+\n+    \/**\n+     * Creates an {@code Expand} object.\n+     *\n+     * @param prk\n+     *     the pseudorandom key; must not be {@code null}\n+     * @param info\n+     *     the optional context and application specific information (may be\n+     *     {@code null}); the byte array is copied to prevent subsequent\n+     *     modification\n+     * @param length\n+     *     the length of the output keying material (must be greater than 0)\n+     *\n+     * @implNote HKDF implementations will enforce that the length is less than\n+     * 255 * HMAC length. Implementations will also enforce that the prk is at least as\n+     * many bytes as the HMAC length.\n+     *\n+     * @return a new {@code Expand} object\n+     *\n+     * @throws NullPointerException\n+     *     if {@code prk} is {@code null}\n+     * @throws IllegalArgumentException\n+     *     if {@code length} is not > 0\n+     *\/\n+    static Expand expandOnly(SecretKey prk, byte[] info, int length) {\n+        if (prk == null) {\n+            throw new NullPointerException(\"prk must not be null\");\n+        }\n+        return new Expand(prk, info, length);\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Extract operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Extract implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Extract(salt, IKM) -> PRK\n+        private final List<SecretKey> ikms;\n+        private final List<SecretKey> salts;\n+\n+        private Extract(List<SecretKey> ikms, List<SecretKey> salts) {\n+            this.ikms = List.copyOf(ikms);\n+            this.salts = List.copyOf(salts);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input keying material values\n+         * in the order they were added. Returns an empty list if there are no\n+         * input keying material values.\n+         * <p>\n+         * Input keying material values added by {@link Builder#addIKM(byte[])}\n+         * are converted to a {@code SecretKeySpec} object.\n+         *\n+         * @implNote An HKDF implementation should concatenate the input keying\n+         * materials into a single value to be used in HKDF-Extract.\n+         *\n+         * @return the unmodifiable {@code List} of input keying material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ikms;\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added. Returns an empty list if there are no salt values.\n+         * <p>\n+         * Salt values added by {@link Builder#addSalt(byte[])}\n+         * are converted to a {@code SecretKeySpec} object.\n+         *\n+         * @implNote An HKDF implementation should concatenate the salt into a\n+         * single value to be used in HKDF-Extract.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return salts;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an Expand operation as defined in <a\n+     * href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class Expand implements HKDFParameterSpec {\n+\n+        \/\/ HKDF-Expand(PRK, info, L) -> OKM\n+        private final SecretKey prk;\n+        private final byte[] info;\n+        private final int length;\n+\n+        \/**\n+         * Constructor that may be used to initialize an {@code Expand} object\n+         *\n+         * @param prk\n+         *     the pseudorandom key; in the case of {@code ExtractThenExpand},\n+         *     prk may be {@null} since the output of extract phase is used\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output keying material\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} not > 0\n+         *\/\n+        private Expand(SecretKey prk, byte[] info, int length) {\n+            \/\/ a null prk could be indicative of ExtractThenExpand\n+            this.prk = prk;\n+            this.info = (info == null) ? null : info.clone();\n+            if (!(length > 0)) {\n+                throw new IllegalArgumentException(\"length must be > 0\");\n+            }\n+            this.length = length;\n+        }\n+\n+        \/**\n+         * Returns the pseudorandom key.\n+         *\n+         * @return the pseudorandom key\n+         *\/\n+        public SecretKey prk() {\n+            return prk;\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a copy of the optional context and application specific\n+         *     information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return (info == null) ? null : info.clone();\n+        }\n+\n+        \/**\n+         * Returns the length of the output keying material.\n+         *\n+         * @return the length of the output keying material\n+         *\/\n+        public int length() {\n+            return length;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Defines the input parameters of an ExtractThenExpand operation as defined\n+     * in <a href=\"http:\/\/tools.ietf.org\/html\/rfc5869\">RFC 5869<\/a>.\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.KEY_DERIVATION)\n+    final class ExtractThenExpand implements HKDFParameterSpec {\n+        private final Extract ext;\n+        private final Expand exp;\n+\n+        \/**\n+         * Constructor that may be used to initialize an\n+         * {@code ExtractThenExpand} object\n+         *\n+         * @param ext\n+         *     a pre-generated {@code Extract}\n+         * @param info\n+         *     the optional context and application specific information (may be\n+         *     {@code null}); the byte[] is copied to prevent subsequent\n+         *     modification\n+         * @param length\n+         *     the length of the output keying material\n+         *\n+         * @throws IllegalArgumentException\n+         *     if {@code length} is not > 0\n+         *\/\n+        private ExtractThenExpand(Extract ext, byte[] info, int length) {\n+            Objects.requireNonNull(ext, \"Extract object must not be null\");\n+            this.ext = ext;\n+            \/\/ - null prk is ok here (it's a signal)\n+            \/\/ - {@code Expand} constructor can deal with a null info\n+            \/\/ - length is checked in {@code Expand} constructor\n+            this.exp = new Expand(null, info, length);\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of input keying material values\n+         * in the order they were added. Returns an empty list if there are no\n+         * input keying material values.\n+         * <p>\n+         * Input keying material values added by {@link Builder#addIKM(byte[])}\n+         * are converted to a {@code SecretKeySpec} object.\n+         *\n+         * @implNote An HKDF implementation should concatenate the input keying\n+         * materials into a single value to be used in the HKDF-Extract phase.\n+         *\n+         * @return the unmodifiable {@code List} of input keying material values\n+         *\/\n+        public List<SecretKey> ikms() {\n+            return ext.ikms();\n+        }\n+\n+        \/**\n+         * Returns an unmodifiable {@code List} of salt values in the order they\n+         * were added. Returns an empty list if there are no salt values.\n+         * <p>\n+         * Salt values added by {@link Builder#addSalt(byte[])}\n+         * are converted to a {@code SecretKeySpec} object.\n+         *\n+         * @implNote An HKDF implementation should concatenate the salt into a\n+         * single value to be used in the HKDF-Extract phase.\n+         *\n+         * @return the unmodifiable {@code List} of salt values\n+         *\/\n+        public List<SecretKey> salts() {\n+            return ext.salts();\n+        }\n+\n+        \/**\n+         * Returns the optional context and application specific information.\n+         *\n+         * @return a copy of the optional context and application specific\n+         *     information, or {@code null} if not specified\n+         *\/\n+        public byte[] info() {\n+            return exp.info();\n+        }\n+\n+        \/**\n+         * Returns the length of the output keying material.\n+         *\n+         * @return the length of the output keying material\n+         *\/\n+        public int length() {\n+            return exp.length();\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":493,"deletions":0,"binary":false,"changes":493,"status":"added"},{"patch":"@@ -84,0 +84,2 @@\n+        @JEP(number=478, title=\"Key Derivation Function API\", status=\"Preview\")\n+        KEY_DERIVATION,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        System.err.println(\"              Cipher, KeyAgreement, KeyGenerator,\");\n+        System.err.println(\"              Cipher, KDF, KeyAgreement, KeyGenerator,\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @summary basic HKDF operations\n+ * @library \/test\/lib\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+public class BasicHKDFFunctions {\n+    public static void main(String[] args) throws Exception {\n+        var ikm = HexFormat.of().parseHex(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\");\n+        var salt = HexFormat.of().parseHex(\"000102030405060708090a0b0c\");\n+        var info = HexFormat.of().parseHex(\"f0f1f2f3f4f5f6f7f8f9\");\n+        var len = 42;\n+\n+        var kdf = KDF.getInstance(\"HKDF-SHA256\");\n+        var expectedPrk = HexFormat.of().parseHex(\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\");\n+        var expectedOkm = HexFormat.of().parseHex(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\");\n+\n+        var extractOnly = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).extractOnly();\n+        var prk = kdf.deriveKey(\"PRK\", extractOnly);\n+        var expandOnly = HKDFParameterSpec.expandOnly(prk, info, len);\n+        var okm1 = kdf.deriveKey(\"OKM\", expandOnly);\n+        var extractAndExpand = HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(info, len);\n+        var okm2 = kdf.deriveKey(\"OKM\", extractAndExpand);\n+\n+        Asserts.assertEqualsByteArray(prk.getEncoded(), expectedPrk,\n+                                      \"the PRK must match the expected value\");\n+\n+        Asserts.assertEqualsByteArray(okm1.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(expand)\");\n+\n+        Asserts.assertEqualsByteArray(okm2.getEncoded(), expectedOkm,\n+                                      \"the OKM must match the expected value \"\n+                                      + \"(extract expand)\");\n+\n+        \/\/ test empty extract\n+        test(HKDFParameterSpec.ofExtract().extractOnly());\n+        \/\/ test expand with empty info\n+        test(HKDFParameterSpec.ofExtract().thenExpand(new byte[0], 32));\n+        \/\/ test expand with null info\n+        test(HKDFParameterSpec.ofExtract().thenExpand(null, 32));\n+        \/\/ test extract with zero-length salt\n+        test(HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(new byte[0]).extractOnly());\n+    }\n+\n+    static void test(HKDFParameterSpec p) throws Exception {\n+        var kdf = KDF.getInstance(\"HKDF-SHA256\");\n+        System.out.println(HexFormat.of().formatHex(kdf.deriveData(p)));\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/BasicHKDFFunctions.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @run main HKDFKnownAnswerTests\n+ * @summary Tests for HKDF Expand and Extract Key Derivation Functions\n+ * @enablePreview\n+ *\/\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class HKDFKnownAnswerTests {\n+    public static class TestData {\n+        public TestData(String name, String algStr, String ikmStr,\n+                        String saltStr, String infoStr, int oLen,\n+                        String expPrkStr,\n+                        String expOkmStr) {\n+            testName = Objects.requireNonNull(name);\n+            algName = Objects.requireNonNull(algStr);\n+            ikm = HexFormat.of().parseHex(Objects.requireNonNull(ikmStr));\n+            if ((outLen = oLen) <= 0) {\n+                throw new IllegalArgumentException(\n+                    \"Output length must be greater than 0\");\n+            }\n+            expectedPRK = HexFormat.of().parseHex(Objects.requireNonNull(expPrkStr));\n+            expectedOKM = HexFormat.of().parseHex(Objects.requireNonNull(expOkmStr));\n+\n+            \/\/ Non-mandatory fields - may be null\n+            salt = (saltStr != null) ? HexFormat.of().parseHex(saltStr) : null;\n+            info = (infoStr != null) ? HexFormat.of().parseHex(infoStr) : null;\n+        }\n+\n+        public final String testName;\n+        public final String algName;\n+        public final byte[] ikm;\n+        public final byte[] salt;\n+        public final byte[] info;\n+        public final int outLen;\n+        public final byte[] expectedPRK;\n+        public final byte[] expectedOKM;\n+    }\n+\n+    public static final List<TestData> testList = new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 5869 Test Case 1\", \"HKDF-SHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         \"000102030405060708090a0b0c\",\n+                         \"f0f1f2f3f4f5f6f7f8f9\",\n+                         42,\n+                         \"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\",\n+                         \"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf\"\n+                         +\n+                         \"34007208d5b887185865\"));\n+        add(new TestData(\"RFC 5869 Test Case 2\", \"HKDF-SHA256\",\n+                         \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n+                         +\n+                         \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n+                         +\n+                         \"404142434445464748494a4b4c4d4e4f\",\n+                         \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\"\n+                         +\n+                         \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\"\n+                         +\n+                         \"a0a1a2a3a4a5a6a7a8a9aaabacadaeaf\",\n+                         \"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\"\n+                         +\n+                         \"d0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeef\"\n+                         +\n+                         \"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\",\n+                         82,\n+                         \"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\",\n+                         \"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c\"\n+                         +\n+                         \"59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71\"\n+                         +\n+                         \"cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n+        add(new TestData(\"RFC 5869 Test Case 3\", \"HKDF-SHA256\",\n+                         \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                         new String(new byte[0]), new String(new byte[0]), 42,\n+                         \"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\",\n+                         \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\"\n+                         +\n+                         \"9d201395faa4b61a96c8\"));\n+    }};\n+\n+    public static void main(String args[]) throws Exception {\n+        int testsPassed = 0;\n+\n+        int testNo = 0;\n+        for (TestData test : testList) {\n+            System.out.println(\"*** Test \" + ++testNo + \": \" +\n+                               test.testName);\n+            if (runVector(test)) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total tests: \" + testList.size() +\n+                           \", Passed: \" + testsPassed + \", Failed: \" +\n+                           (testList.size() - testsPassed));\n+        if (testsPassed != testList.size()) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                                       \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runVector(TestData testData)\n+        throws InvalidParameterSpecException,\n+               InvalidAlgorithmParameterException,\n+               NoSuchAlgorithmException {\n+        String kdfName, prfName;\n+        KDF kdfHkdf, kdfExtract, kdfExpand;\n+        boolean result = true;\n+        SecretKey actualPRK;\n+        SecretKey actualOKM;\n+        byte[] deriveData;\n+\n+        try {\n+            kdfHkdf = KDF.getInstance(testData.algName);\n+            kdfExtract = KDF.getInstance(testData.algName);\n+            kdfExpand = KDF.getInstance(testData.algName);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            InvalidParameterSpecException exc =\n+                new InvalidParameterSpecException();\n+            exc.initCause(nsae);\n+            throw exc;\n+        }\n+\n+        \/\/ Set up the input keying material\n+        SecretKey ikmKey = new SecretKeySpec(testData.ikm, \"HKDF-IKM\");\n+\n+        \/\/ *** HKDF-Extract-only testing\n+        \/\/ Create KDFParameterSpec for the Extract-only operation\n+        AlgorithmParameterSpec derivationSpecExtract =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .extractOnly();\n+        actualPRK = kdfExtract.deriveKey(\"Generic\", derivationSpecExtract);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExtract.deriveData(derivationSpecExtract);\n+\n+        System.out.println(\"* HKDF-Extract-Only:\");\n+        result &= compareKeyAndData(actualPRK, deriveData,\n+                                    testData.expectedPRK);\n+\n+        \/\/ *** HKDF Expand-Only testing\n+        \/\/ For these tests, we'll use the actualPRK as the input key\n+        \/\/ Create KDFParameterSpec for key output and raw byte output\n+        AlgorithmParameterSpec derivationSpecExpand = HKDFParameterSpec.expandOnly(\n+            actualPRK, testData.info,\n+            testData.outLen);\n+        actualOKM = kdfExpand.deriveKey(\"Generic\", derivationSpecExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfExpand.deriveData(derivationSpecExpand);\n+\n+        System.out.println(\"* HKDF-Expand-Only:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        \/\/ *** HKDF Extract-then-Expand testing\n+        \/\/ We can reuse the KDFParameterSpec from the Expand-only test\n+\n+        \/\/ Use the KDF to make us a key\n+        AlgorithmParameterSpec derivationSpecExtractExpand =\n+            HKDFParameterSpec.ofExtract().addIKM(ikmKey)\n+                             .addSalt(testData.salt)\n+                             .thenExpand(testData.info,\n+                                         testData.outLen);\n+        actualOKM = kdfHkdf.deriveKey(\"Generic\", derivationSpecExtractExpand);\n+\n+        \/\/ Re-run the KDF to give us raw output data\n+        deriveData = kdfHkdf.deriveData(derivationSpecExtractExpand);\n+\n+        System.out.println(\"* HKDF-Extract-then-Expand:\");\n+        result &= compareKeyAndData(actualOKM, deriveData,\n+                                    testData.expectedOKM);\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Compare key-based and data-based productions from the KDF against an\n+     * expected output value.\n+     *\n+     * @param outKey\n+     *     the KDF output in key form\n+     * @param outData\n+     *     the KDF output as raw bytes\n+     * @param expectedOut\n+     *     the expected value\n+     *\n+     * @return true if the underlying data for outKey, outData and expectedOut\n+     * are the same.\n+     *\/\n+    private static boolean compareKeyAndData(Key outKey, byte[] outData,\n+                                             byte[] expectedOut) {\n+        boolean result = true;\n+\n+        if (Arrays.equals(outKey.getEncoded(), expectedOut)) {\n+            System.out.println(\"\\t* Key output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Key output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outKey.getEncoded(), 16, \"\\n\",\n+                                            \" \"));\n+            System.out.println();\n+        }\n+\n+        if (Arrays.equals(outData, expectedOut)) {\n+            System.out.println(\"\\t* Data output: Pass\");\n+        } else {\n+            result = false;\n+            System.out.println(\"\\t* Data output: FAIL\");\n+            System.out.println(\"Expected:\\n\" +\n+                               dumpHexBytes(expectedOut, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                               dumpHexBytes(outData, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data\n+     *     The array of bytes to dump to stdout.\n+     * @param itemsPerLine\n+     *     The number of bytes to display per line if the {@code lineDelim}\n+     *     character is blank then all bytes will be printed on a single line.\n+     * @param lineDelim\n+     *     The delimiter between lines\n+     * @param itemDelim\n+     *     The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+                                       String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data[i])).append(itemDelim);\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFKnownAnswerTests.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib\n+ * @run testng KDFDelayedProviderSyncTest\n+ * @summary multi-threading test for KDF\n+ * @enablePreview\n+ *\/\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HKDFParameterSpec;\n+import java.math.BigInteger;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.HexFormat;\n+\n+public class KDFDelayedProviderSyncTest {\n+    KDF kdfUnderTest;\n+    byte[] ikm = new BigInteger(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                                16).toByteArray();\n+    byte[] salt = new BigInteger(\"000102030405060708090a0b0c\",\n+                                 16).toByteArray();\n+    byte[] info = new BigInteger(\"f0f1f2f3f4f5f6f7f8f9\", 16).toByteArray();\n+    AlgorithmParameterSpec derivationSpec =\n+        HKDFParameterSpec.ofExtract().addIKM(ikm).addSalt(salt).thenExpand(\n+            info, 42);\n+    String expectedResult =\n+        \"666b33562ebc5e2f041774192e0534efca06f82a5fca17ec8c6ae1b9f5466adba1d77d06480567ddd2d1\";\n+\n+    @BeforeClass\n+    public void setUp() throws NoSuchAlgorithmException {\n+        kdfUnderTest = KDF.getInstance(\"HKDF-SHA256\");\n+    }\n+\n+    @Test(threadPoolSize = 50, invocationCount = 100, timeOut = 100)\n+    public void testDerive()\n+        throws InvalidAlgorithmParameterException, NoSuchAlgorithmException {\n+        SecretKey result = kdfUnderTest.deriveKey(\"Generic\", derivationSpec);\n+        assert (HexFormat.of().formatHex(result.getEncoded()).equals(\n+            expectedResult));\n+\n+        byte[] resultData = kdfUnderTest.deriveData(derivationSpec);\n+        assert (HexFormat.of().formatHex(resultData).equals(expectedResult));\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/KDFDelayedProviderSyncTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331008\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @run main KDFDelayedProviderTest\n+ * @summary delayed provider selection\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KDFParameters;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+public class KDFDelayedProviderTest {\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new Provider1());\n+        Security.addProvider(new Provider2());\n+        Security.addProvider(new Provider3());\n+        KDF kdf;\n+\n+        kdf = KDF.getInstance(\"X\", new KDFParameters() {});\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P1\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new MyDerivationSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P2\");\n+\n+        kdf = KDF.getInstance(\"X\");\n+        kdf.deriveData(new AlgorithmParameterSpec() {});\n+        Asserts.assertEquals(kdf.getProviderName(), \"P3\");\n+    }\n+\n+    public static class Provider1 extends Provider {\n+        public Provider1() {\n+            super(\"P1\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF1.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF1 requires a params at getInstance()\n+    public static class KDF1 extends KDF0 {\n+        public KDF1(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(Objects.requireNonNull(e));\n+        }\n+    }\n+\n+    public static class Provider2 extends Provider {\n+        public Provider2() {\n+            super(\"P2\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF2.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF2 requires input to be a specific type\n+    public static class KDF2 extends KDF0 {\n+        public KDF2(KDFParameters e)\n+            throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            if (derivationSpec instanceof MyDerivationSpec) {\n+                return null;\n+            } else {\n+                throw new InvalidAlgorithmParameterException();\n+            }\n+        }\n+    }\n+\n+    public static class Provider3 extends Provider {\n+        public Provider3() {\n+            super(\"P3\", \"1\", \"1\");\n+            put(\"KDF.X\", KDF3.class.getName());\n+        }\n+    }\n+\n+    \/\/ KDF3 doesn't care about anything\n+    public static class KDF3 extends KDF0 {\n+        public KDF3(KDFParameters e) throws InvalidAlgorithmParameterException {\n+            super(null);\n+        }\n+    }\n+\n+    public abstract static class KDF0 extends KDFSpi {\n+        public KDF0(KDFParameters a) throws InvalidAlgorithmParameterException {\n+            super(a);\n+        }\n+\n+        protected SecretKey engineDeriveKey(String alg,\n+                                            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return null;\n+        }\n+\n+        protected byte[] engineDeriveData(\n+            AlgorithmParameterSpec derivationSpec)\n+            throws InvalidAlgorithmParameterException {\n+            return new byte[0];\n+        }\n+\n+        protected KDFParameters engineGetParameters(){\n+            return null;\n+        }\n+    }\n+\n+    static class MyDerivationSpec implements AlgorithmParameterSpec {}\n+}\n","filename":"test\/jdk\/javax\/crypto\/KDF\/KDFDelayedProviderTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crypto;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.Provider;\n+\n+\/**\n+ * This class is included here to enable testing of Delayed Provider Selection\n+ * by certain KDF tests. It only stubs out the necessary methods.\n+ *\n+ * @since 24\n+ *\/\n+final class ProviderVerifier {\n+\n+    private final CryptoPermissions appPerms = null;\n+\n+    \/**\n+     * Creates a {@code ProviderVerifier} object to verify the given URL.\n+     *\n+     * @param jarURL the JAR file to be verified.\n+     * @param savePerms if {@code true}, save the permissions allowed by the\n+     *          exemption mechanism\n+     *\/\n+    ProviderVerifier(URL jarURL, boolean savePerms) {\n+        this(jarURL, null, savePerms);\n+    }\n+\n+    \/**\n+     * Creates a {@code ProviderVerifier} object to verify the given URL.\n+     *\n+     * @param jarURL the JAR file to be verified\n+     * @param provider the corresponding provider.\n+     * @param savePerms if {@code true}, save the permissions allowed by the\n+     *          exemption mechanism\n+     *\/\n+    ProviderVerifier(URL jarURL, Provider provider, boolean savePerms) {\n+        \/\/ The URL for the JAR file we want to verify.\n+    }\n+\n+    \/**\n+     * Only a stub is needed for the Delayed Provider Selection test.\n+     *\/\n+    void verify() throws IOException { return; }\n+\n+    \/**\n+     * Verify that the provided certs include the\n+     * framework signing certificate.\n+     *\n+     * @param certs the list of certs to be checked.\n+     * @throws Exception if the list of certs did not contain\n+     *          the framework signing certificate\n+     *\/\n+    static void verifyPolicySigned(java.security.cert.Certificate[] certs)\n+            throws Exception {\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the given provider is JDK trusted crypto provider\n+     * if the implementation supports fast-path verification.\n+     *\/\n+    static boolean isTrustedCryptoProvider(Provider provider) {\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the permissions which are bundled with the JAR file,\n+     * aka the \"cryptoperms\" file.\n+     * <p>\n+     * NOTE: if this {@code ProviderVerifier} instance is constructed\n+     * with \"savePerms\" equal to {@code false}, then this method would always\n+     * return {@code null}.\n+     *\/\n+    CryptoPermissions getPermissions() {\n+        return appPerms;\n+    }\n+}\n","filename":"test\/jdk\/security\/unsignedjce\/java.base\/javax\/crypto\/ProviderVerifier.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}