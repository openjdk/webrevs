{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -102,1 +103,1 @@\n-                \"the algorithm for the SecretKey return value may not be null\");\n+                \"the algorithm for the SecretKey return value should not be null\");\n@@ -106,1 +107,1 @@\n-                \"the algorithm for the SecretKey return value may not be \"\n+                \"the algorithm for the SecretKey return value should not be \"\n@@ -144,3 +145,3 @@\n-            \/\/ we should be able to combine these Lists of keys into single\n-            \/\/ SecretKey Objects,\n-            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            \/\/ we should be able to combine these Lists of key segments into\n+            \/\/ single SecretKey Objects, unless we were passed something bogus\n+            \/\/ or an unexportable P11 key\n@@ -208,3 +209,3 @@\n-            \/\/ we should be able to combine these Lists of keys into single\n-            \/\/ SecretKey Objects,\n-            \/\/ unless we were passed something bogus or an unexportable P11 key\n+            \/\/ we should be able to combine these Lists of key segments into\n+            \/\/ single SecretKey Objects, unless we were passed something bogus\n+            \/\/ or an unexportable P11 key\n@@ -233,1 +234,1 @@\n-                pseudoRandomKey = new SecretKeySpec(extractResult, \"RAW\");\n+                pseudoRandomKey = new SecretKeySpec(extractResult, hmacAlgName);\n@@ -262,1 +263,1 @@\n-                byte[] bb = new byte[0];\n+                ByteArrayOutputStream os = new ByteArrayOutputStream();\n@@ -264,6 +265,1 @@\n-                    byte[] workItemBytes = CipherCore.getKeyBytes(workItem);\n-\n-                    bb = Arrays.copyOf(bb, bb.length + workItemBytes.length);\n-                    System.arraycopy(workItemBytes, 0, bb,\n-                                     bb.length - workItemBytes.length,\n-                                     workItemBytes.length);\n+                    os.writeBytes(CipherCore.getKeyBytes(workItem));\n@@ -271,1 +267,1 @@\n-                return new SecretKeySpec(bb, \"Generic\");\n+                return new SecretKeySpec(os.toByteArray(), \"Generic\");\n@@ -273,2 +269,2 @@\n-        } else if (keys.isEmpty()) {\n-            return null;\n+        } else if(keys != null) {\n+                return null;\n@@ -277,1 +273,1 @@\n-                \"List of keys could not be consolidated\");\n+                \"List of key segments could not be consolidated\");\n@@ -303,1 +299,1 @@\n-        hmacObj.init(new SecretKeySpec(salt, \"HKDF-Salt\"));\n+        hmacObj.init(new SecretKeySpec(salt, hmacAlgName));\n@@ -329,2 +325,2 @@\n-     *     if an invalid key was provided through the {@code HkdfParameterSpec}\n-     *     or derived during the generation of the PRK.\n+     *     if an invalid PRK was provided through the {@code HKDFParameterSpec}\n+     *     or derived during the extract phase.\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HkdfKeyDerivation.java","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -122,3 +122,0 @@\n-    int DERIVE_KEY = 0;\n-    int DERIVE_DATA = 1;\n-\n@@ -227,1 +224,1 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n@@ -262,2 +259,2 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n-        Objects.requireNonNull(provider, \"provider may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n+        Objects.requireNonNull(provider, \"provider should not be null\");\n@@ -295,2 +292,2 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n-        Objects.requireNonNull(provider, \"provider may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n+        Objects.requireNonNull(provider, \"provider should not be null\");\n@@ -334,1 +331,1 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n@@ -384,2 +381,2 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n-        Objects.requireNonNull(provider, \"provider may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n+        Objects.requireNonNull(provider, \"provider should not be null\");\n@@ -436,2 +433,2 @@\n-        Objects.requireNonNull(algorithm, \"algorithm may not be null\");\n-        Objects.requireNonNull(provider, \"provider may not be null\");\n+        Objects.requireNonNull(algorithm, \"algorithm should not be null\");\n+        Objects.requireNonNull(provider, \"provider should not be null\");\n@@ -494,1 +491,1 @@\n-                \"the algorithm for the SecretKey return value may not be null\");\n+                \"the algorithm for the SecretKey return value should not be null\");\n@@ -498,1 +495,1 @@\n-                \"the algorithm for the SecretKey return value may not be \"\n+                \"the algorithm for the SecretKey return value should not be \"\n@@ -604,1 +601,1 @@\n-        int mechanism = (algorithm == null) ? DERIVE_DATA : DERIVE_KEY;\n+        boolean isDeriveData = (algorithm == null);\n@@ -608,1 +605,1 @@\n-                return (mechanism == DERIVE_DATA) ? spi.engineDeriveData(\n+                return (isDeriveData) ? spi.engineDeriveData(\n@@ -628,1 +625,1 @@\n-                        (mechanism == DERIVE_DATA) ? spi.engineDeriveData(\n+                        (isDeriveData) ? spi.engineDeriveData(\n@@ -651,6 +648,3 @@\n-            \"No installed provider supports the \" + ((mechanism\n-                                                      == DERIVE_DATA) ?\n-                                                         \"deriveData\" :\n-                                                         \"deriveKey\")\n-            + \" method with\"\n-            + \" these parameters\");\n+            \"No installed provider supports the \" +\n+            ((isDeriveData) ? \"deriveData\" : \"deriveKey\")\n+            + \" method with these parameters\");\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KDF.java","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -353,1 +353,2 @@\n-         *     the pseudorandom key; may be {@code null}\n+         *     the pseudorandom key; in the case of {@code ExtractThenExpand},\n+         *     prk may be {@null} since the output of extract phase is used\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HKDFParameterSpec.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        add(new TestData(\"RFC 5689 Test Case 1\", \"HKDFWithHmacSHA256\",\n+        add(new TestData(\"RFC 5869 Test Case 1\", \"HKDFWithHmacSHA256\",\n@@ -88,1 +88,1 @@\n-        add(new TestData(\"RFC 5689 Test Case 2\", \"HKDFWithHmacSHA256\",\n+        add(new TestData(\"RFC 5869 Test Case 2\", \"HKDFWithHmacSHA256\",\n@@ -111,1 +111,1 @@\n-        add(new TestData(\"RFC 5689 Test Case 3\", \"HKDFWithHmacSHA256\",\n+        add(new TestData(\"RFC 5869 Test Case 3\", \"HKDFWithHmacSHA256\",\n@@ -144,1 +144,1 @@\n-               InvalidKeyException {\n+               NoSuchAlgorithmException {\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/TestHKDF.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}