{"files":[{"patch":"@@ -782,1 +782,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -788,1 +787,0 @@\n-          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -705,2 +705,0 @@\n-      \/\/ f2hf treats tmp as live_in. Workaround: initialize to some value.\n-      __ move(LIR_OprFact::floatConst(-0.0), tmp); \/\/ just to satisfy LinearScan\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2396,14 +2396,2 @@\n-#ifdef _LP64\n-          if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-            assert(tmp->is_valid(), \"need temporary\");\n-            __ vpandn(dest->as_xmm_double_reg(), tmp->as_xmm_double_reg(), value->as_xmm_double_reg(), 2);\n-          } else\n-#endif\n-          {\n-            if (dest->as_xmm_double_reg() != value->as_xmm_double_reg()) {\n-              __ movdbl(dest->as_xmm_double_reg(), value->as_xmm_double_reg());\n-            }\n-            assert(!tmp->is_valid(), \"do not need temporary\");\n-            __ andpd(dest->as_xmm_double_reg(),\n-                     ExternalAddress((address)double_signmask_pool),\n-                     rscratch1);\n+          if (dest->as_xmm_double_reg() != value->as_xmm_double_reg()) {\n+            __ movdbl(dest->as_xmm_double_reg(), value->as_xmm_double_reg());\n@@ -2411,0 +2399,4 @@\n+          assert(!tmp->is_valid(), \"do not need temporary\");\n+          __ andpd(dest->as_xmm_double_reg(),\n+                   ExternalAddress((address)double_signmask_pool),\n+                   rscratch1);\n@@ -3801,16 +3793,3 @@\n-#ifdef _LP64\n-    if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-      assert(tmp->is_valid(), \"need temporary\");\n-      assert_different_registers(left->as_xmm_float_reg(), tmp->as_xmm_float_reg());\n-      __ vpxor(dest->as_xmm_float_reg(), tmp->as_xmm_float_reg(), left->as_xmm_float_reg(), 2);\n-    }\n-    else\n-#endif\n-    {\n-      assert(!tmp->is_valid(), \"do not need temporary\");\n-      if (left->as_xmm_float_reg() != dest->as_xmm_float_reg()) {\n-        __ movflt(dest->as_xmm_float_reg(), left->as_xmm_float_reg());\n-      }\n-      __ xorps(dest->as_xmm_float_reg(),\n-               ExternalAddress((address)float_signflip_pool),\n-               rscratch1);\n+    assert(!tmp->is_valid(), \"do not need temporary\");\n+    if (left->as_xmm_float_reg() != dest->as_xmm_float_reg()) {\n+      __ movflt(dest->as_xmm_float_reg(), left->as_xmm_float_reg());\n@@ -3818,0 +3797,3 @@\n+    __ xorps(dest->as_xmm_float_reg(),\n+             ExternalAddress((address)float_signflip_pool),\n+             rscratch1);\n@@ -3819,16 +3801,3 @@\n-#ifdef _LP64\n-    if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-      assert(tmp->is_valid(), \"need temporary\");\n-      assert_different_registers(left->as_xmm_double_reg(), tmp->as_xmm_double_reg());\n-      __ vpxor(dest->as_xmm_double_reg(), tmp->as_xmm_double_reg(), left->as_xmm_double_reg(), 2);\n-    }\n-    else\n-#endif\n-    {\n-      assert(!tmp->is_valid(), \"do not need temporary\");\n-      if (left->as_xmm_double_reg() != dest->as_xmm_double_reg()) {\n-        __ movdbl(dest->as_xmm_double_reg(), left->as_xmm_double_reg());\n-      }\n-      __ xorpd(dest->as_xmm_double_reg(),\n-               ExternalAddress((address)double_signflip_pool),\n-               rscratch1);\n+    assert(!tmp->is_valid(), \"do not need temporary\");\n+    if (left->as_xmm_double_reg() != dest->as_xmm_double_reg()) {\n+      __ movdbl(dest->as_xmm_double_reg(), left->as_xmm_double_reg());\n@@ -3836,0 +3805,3 @@\n+    __ xorpd(dest->as_xmm_double_reg(),\n+             ExternalAddress((address)double_signflip_pool),\n+             rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":18,"deletions":46,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -347,14 +347,1 @@\n-  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n-#ifdef _LP64\n-  if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n-    if (x->type()->tag() == doubleTag) {\n-      tmp = new_register(T_DOUBLE);\n-      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n-    }\n-    else if (x->type()->tag() == floatTag) {\n-      tmp = new_register(T_FLOAT);\n-      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n-    }\n-  }\n-#endif\n-  __ negate(value.result(), reg, tmp);\n+  __ negate(value.result(), reg);\n@@ -833,7 +820,0 @@\n-#ifdef _LP64\n-  if (UseAVX > 2 && (!VM_Version::supports_avx512vl()) &&\n-      (x->id() == vmIntrinsics::_dabs)) {\n-    tmp = new_register(T_DOUBLE);\n-    __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n-  }\n-#endif\n@@ -842,1 +822,0 @@\n-    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -638,0 +638,18 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_neg: {\n+      assert(in->is_fpu_register(), \"must be\");\n+      assert(res->is_fpu_register(), \"must be\");\n+      assert(in->is_last_use(), \"old value gets destroyed\");\n+\n+      insert_free_if_dead(res, in);\n+      insert_exchange(in);\n+      do_rename(in, res);\n+\n+      new_in = to_fpu_stack_top(res);\n+      new_res = new_in;\n+\n+      op1->set_fpu_stack_size(sim()->stack_size());\n+      break;\n+    }\n+\n@@ -759,20 +777,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_neg: {\n-      \/\/ Right argument appears to be unused\n-      assert(right->is_illegal(), \"must be\");\n-      assert(left->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(left->is_last_use(), \"old value gets destroyed\");\n-\n-      insert_free_if_dead(res, left);\n-      insert_exchange(left);\n-      do_rename(left, res);\n-\n-      new_left = to_fpu_stack_top(res);\n-      new_res = new_left;\n-\n-      op2->set_fpu_stack_size(sim()->stack_size());\n-      break;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,29 +69,1 @@\n-  switch (op->code()) {\n-    case lir_tan: {\n-      \/\/ The slow path for these functions may need to save and\n-      \/\/ restore all live registers but we don't want to save and\n-      \/\/ restore everything all the time, so mark the xmms as being\n-      \/\/ killed.  If the slow path were explicit or we could propagate\n-      \/\/ live register masks down to the assembly we could do better\n-      \/\/ but we don't have any easy way to do that right now.  We\n-      \/\/ could also consider not killing all xmm registers if we\n-      \/\/ assume that slow paths are uncommon but it's not clear that\n-      \/\/ would be a good idea.\n-      if (UseSSE > 0) {\n-#ifdef ASSERT\n-        if (TraceLinearScanLevel >= 2) {\n-          tty->print_cr(\"killing XMMs for trig\");\n-        }\n-#endif\n-        int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();\n-        int op_id = op->id();\n-        for (int xmm = 0; xmm < num_caller_save_xmm_regs; xmm++) {\n-          LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(xmm);\n-          add_temp(reg_num(opr), op_id, noUse, T_ILLEGAL);\n-        }\n-      }\n-      break;\n-    }\n-    default:\n-      break;\n-  }\n+  \/\/ No special case behaviours yet\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1197,1 +1197,5 @@\n-  if (reachable(src)) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpand(dst, dst, src, AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n@@ -3335,1 +3339,6 @@\n-  if (reachable(src)) {\n+\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpxor(dst, dst, src, Assembler::AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n@@ -3344,1 +3353,3 @@\n-  if (UseAVX > 2 && !VM_Version::supports_avx512dq() && (dst->encoding() == src->encoding())) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      ((dst->encoding() >= 16) || (src->encoding() >= 16))) {\n@@ -3346,2 +3357,1 @@\n-  }\n-  else {\n+  } else {\n@@ -3353,1 +3363,3 @@\n-  if (UseAVX > 2 && !VM_Version::supports_avx512dq() && (dst->encoding() == src->encoding())) {\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      ((dst->encoding() >= 16) || (src->encoding() >= 16))) {\n@@ -3365,1 +3377,6 @@\n-  if (reachable(src)) {\n+\n+  if (UseAVX > 2 &&\n+      (!VM_Version::supports_avx512dq() || !VM_Version::supports_avx512vl()) &&\n+      (dst->encoding() >= 16)) {\n+    vpxor(dst, dst, src, Assembler::AVX_512bit, rscratch);\n+  } else if (reachable(src)) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -455,0 +455,5 @@\n+    case lir_sqrt:           \/\/ FP Ops have no info, but input and result\n+    case lir_abs:\n+    case lir_neg:\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -461,0 +466,1 @@\n+      if (op1->_tmp->is_valid())       do_temp(op1->_tmp);\n@@ -486,0 +492,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -569,5 +576,0 @@\n-    case lir_sqrt:\n-    case lir_abs:\n-    case lir_neg:\n-    case lir_f2hf:\n-    case lir_hf2f:\n@@ -670,0 +672,1 @@\n+      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -1733,0 +1736,5 @@\n+     case lir_abs:                   s = \"abs\";           break;\n+     case lir_neg:                   s = \"neg\";           break;\n+     case lir_sqrt:                  s = \"sqrt\";          break;\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n@@ -1749,5 +1757,0 @@\n-     case lir_abs:                   s = \"abs\";           break;\n-     case lir_neg:                   s = \"neg\";           break;\n-     case lir_sqrt:                  s = \"sqrt\";          break;\n-     case lir_f2hf:                  s = \"f2hf\";          break;\n-     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -942,0 +942,5 @@\n+      , lir_sqrt\n+      , lir_abs\n+      , lir_neg\n+      , lir_f2hf\n+      , lir_hf2f\n@@ -958,7 +963,0 @@\n-      , lir_sqrt\n-      , lir_abs\n-      , lir_neg\n-      , lir_tan\n-      , lir_f2hf\n-      , lir_hf2f\n-      , lir_log10\n@@ -1360,0 +1358,1 @@\n+  LIR_Opr         _tmp;\n@@ -1374,0 +1373,8 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n+    , _type(type)\n+    , _patch(patch)                    { assert(is_in_range(code, begin_op1, end_op1), \"code check\"); }\n+\n+  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result, LIR_Opr tmp, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n+    : LIR_Op(code, result, info)\n+    , _opr(opr)\n+    , _tmp(tmp)\n@@ -1380,0 +1387,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1389,0 +1397,1 @@\n+    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1393,0 +1402,1 @@\n+  LIR_Opr tmp_opr()          const               { return _tmp;   }\n@@ -2275,3 +2285,3 @@\n-  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_abs , from, tmp, to)); }\n-  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr)              { append(new LIR_Op2(lir_neg, from, tmp, to)); }\n-  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_sqrt, from, tmp, to)); }\n+  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_abs , from, to, tmp)); }\n+  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr) { append(new LIR_Op1(lir_neg, from, to, tmp)); }\n+  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_sqrt, from, to, tmp)); }\n@@ -2280,4 +2290,2 @@\n-  void log10 (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)              { append(new LIR_Op2(lir_log10, from, LIR_OprFact::illegalOpr, to, tmp)); }\n-  void tan (LIR_Opr from, LIR_Opr to, LIR_Opr tmp1, LIR_Opr tmp2) { append(new LIR_Op2(lir_tan , from, tmp1, to, tmp2)); }\n-  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n-  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_f2hf, from, to, tmp)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_hf2f, from, to, tmp)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -529,0 +529,11 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_f2hf:\n+    case lir_hf2f:\n+      intrinsic_op(op->code(), op->in_opr(), op->tmp_opr(), op->result_opr(), op);\n+      break;\n+\n+    case lir_neg:\n+      negate(op->in_opr(), op->result_opr(), op->tmp_opr());\n+      break;\n+\n@@ -726,13 +737,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_tan:\n-    case lir_log10:\n-    case lir_f2hf:\n-    case lir_hf2f:\n-      intrinsic_op(op->code(), op->in_opr1(), op->in_opr2(), op->result_opr(), op);\n-      break;\n-\n-    case lir_neg:\n-      negate(op->in_opr1(), op->result_opr(), op->in_opr2());\n-      break;\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);\n+  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr temp, LIR_Opr dest, LIR_Op* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6742,1 +6742,0 @@\n-        case lir_log10:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}