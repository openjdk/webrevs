{"files":[{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.Main;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/**\n+ * Exploration of vectorized latin1 equalsIgnoreCase taking advantage of the fact\n+ * that ASCII and Latin1 were designed to optimize case-twiddling operations.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class EqualsIgnoreCaseBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+    private byte[] a;\n+    private byte[] b;\n+    private int len;\n+    @Param({\"16\", \"32\", \"64\", \"128\", \"1024\"})\n+    private int size;\n+\n+    @Setup\n+    public void setup() {\n+        a = (\"a\\u00e5\".repeat(size\/2) + \"A\").getBytes(StandardCharsets.ISO_8859_1);\n+        b = (\"A\\u00c5\".repeat(size\/2) + \"B\").getBytes(StandardCharsets.ISO_8859_1);\n+        len = a.length;\n+    }\n+\n+    @Benchmark\n+    public boolean scalar() {\n+        return scalarEqualsIgnoreCase(a, b, len);\n+    }\n+\n+    @Benchmark\n+    public boolean vectorized() {\n+        return vectorizedEqualsIgnoreCase(a, b, len);\n+    }\n+\n+    private boolean vectorizedEqualsIgnoreCase(byte[] a, byte[] b, int len) {\n+        int i = 0;\n+        for (; i < SPECIES.loopBound(b.length); i += SPECIES.length()) {\n+            ByteVector va = ByteVector.fromArray(SPECIES, a, i);\n+            ByteVector vb = ByteVector.fromArray(SPECIES, b, i);\n+            VectorMask<Byte> equal = va.eq(vb);\n+\n+            \/\/ If all bytes are equal, we can skip ahead early\n+            if (equal.allTrue()) {\n+                continue;\n+            }\n+\n+            \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+            ByteVector upperA = va.and((byte) 0xDF);\n+\n+            \/\/ Determine which bytes represent ASCII or Latin-1 letters:\n+            VectorMask<Byte> asciiLetter = upperA.compare(GE, (byte) 'A') \/\/ >= 'A'\n+                    .and(upperA.compare(LE, (byte) 'Z')); \/\/ <= 'Z'\n+\n+            VectorMask<Byte> lat1Letter = upperA.compare(GE, (byte) 0XC0) \/\/ >= A-grave\n+                    .and(upperA.compare(LE, (byte) 0xDE))  \/\/ <= Thorn\n+                    .and(upperA.compare(NE, (byte) 0xD7)); \/\/ Excluding multiplication\n+\n+            VectorMask<Byte> letter = asciiLetter.or(lat1Letter);\n+\n+            \/\/ Uppercase b\n+            ByteVector upperB = vb.and((byte) 0xDF);\n+\n+            \/\/ va equalsIgnoreCase vb if:\n+            \/\/ 1: all bytes are equal (checked above), or\n+            \/\/ 2: all bytes are letters in the ASCII or latin1 ranges\n+            \/\/    AND their uppercase is the same\n+            VectorMask<Byte> equalsIgnoreCase = letter.and(upperA.eq(upperB));\n+\n+            if(equalsIgnoreCase.allTrue()) {\n+                continue;\n+            } else {\n+                return false;\n+            }\n+        }\n+        \/\/ Process the tail\n+        while (i < len) {\n+            byte b1 = a[i];\n+            byte b2 = b[i];\n+            if (equalsIgnoreCase(b1, b2)) {\n+                i++;\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean scalarEqualsIgnoreCase(byte[] a, byte[] b, int len) {\n+        int i = 0;\n+        while (i < len) {\n+            byte b1 = a[i];\n+            byte b2 = b[i];\n+            if (equalsIgnoreCase(b1, b2)) {\n+                i++;\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    static boolean equalsIgnoreCase(byte b1, byte b2) {\n+        if (b1 == b2) {\n+            return true;\n+        }\n+        \/\/ ASCII and Latin-1 were designed to optimize case-twiddling operations\n+        int upper = b1 & 0xDF;\n+        if (upper < 'A') {\n+            return false;  \/\/ Low ASCII\n+        }\n+        return (upper <= 'Z' \/\/ In range A-Z\n+                || (upper >= 0xC0 && upper <= 0XDE && upper != 0xD7)) \/\/ ..or A-grave-Thorn, excl. multiplication\n+                && upper == (b2 & 0xDF); \/\/ b2 has same uppercase\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/EqualsIgnoreCaseBenchmark.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"}]}