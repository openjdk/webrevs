{"files":[{"patch":"@@ -3519,14 +3519,202 @@\n-\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n-\/\/ If (conIL == conIR && conIR <= num_bits)  this simplifies to\n-\/\/ (StoreB ... (valIn) )\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_RShiftI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n-      Node *shl = val->in(1);\n-      if( shl->Opcode() == Op_LShiftI ) {\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ If (conIL == conIR && conIR <= num_rejected_bits) this simplifies to\n+\/\/ (StoreB ... (v))\n+\/\/ If (conIL > conIR) under some conditions, it can be simplified into\n+\/\/ (StoreB ... (LShiftI _ v (conIL - conIR)))\n+\/\/ This case happens when the value of the store was itself a left shift, that\n+\/\/ gets merged into the inner left shift of the sign-extension. For instance,\n+\/\/ if we have\n+\/\/ array_of_shorts[0] = (short)(v << 2)\n+\/\/ We get a structure such as:\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ v 2) 16) 16))\n+\/\/ that is simplified into\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v 18) 16)).\n+\/\/ It is thus useful to handle cases where conIL > conIR. But this simplification\n+\/\/ does not always hold. Let's see in which cases it's valid.\n+\/\/\n+\/\/ Let's assume we have the following 32 bits integer v:\n+\/\/ +----------------------------------+\n+\/\/ |             v[0..31]             |\n+\/\/ +----------------------------------+\n+\/\/  31                               0\n+\/\/ that will be stuffed in 8 bits byte after a shift left and a shift right of\n+\/\/ potentially different magnitudes.\n+\/\/ We denote num_rejected_bits the number of bits of the discarded part. In this\n+\/\/ case, num_rejected_bits == 24.\n+\/\/\n+\/\/ Statement (proved further below in case analysis):\n+\/\/   Given:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - 0 <= conIR < BitsPerJavaInteger   (no wrap in shift, enforced by maskShiftAmount)\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/   Then this form:\n+\/\/      (RShiftI _ (LShiftI _ v conIL) conIR)\n+\/\/   can be replaced with this form:\n+\/\/      (LShiftI _ v (conIL-conIR))\n+\/\/\n+\/\/ Note: We only have to show that the non-rejected lowest bits (8 bits for byte)\n+\/\/       have to be correct, as the higher bits are rejected \/ truncated by the store.\n+\/\/\n+\/\/ The hypotheses\n+\/\/   0 <= conIL < BitsPerJavaInteger\n+\/\/   0 <= conIR < BitsPerJavaInteger\n+\/\/ are ensured by maskShiftAmount (called from ::Ideal of shift nodes). Indeed,\n+\/\/ (v << 31) << 2 must be simplified into 0, not into v << 33 (which is equivalent\n+\/\/ to v << 1).\n+\/\/\n+\/\/\n+\/\/ If you don't like case analysis, jump after the conclusion.\n+\/\/ ### Case 1 : conIL == conIR\n+\/\/ ###### Case 1.1: conIL == conIR == num_rejected_bits\n+\/\/ If we do the shift left then right by 24 bits, we get:\n+\/\/ after: v << 24\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..7] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     24 23                      0\n+\/\/ after: (v << 24) >> 24\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ The non-rejected bits (bits kept by the store, that is the 8 lower bits of the\n+\/\/ result) are the same before and after, so, indeed, simplifying is correct.\n+\n+\/\/ ###### Case 1.2: conIL == conIR < num_rejected_bits\n+\/\/ If we do the shift left then right by 22 bits, we get:\n+\/\/ after: v << 22\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..9] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     22 21                      0\n+\/\/ after: (v << 22) >> 22\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..9] |\n+\/\/ +------------------------+---------+\n+\/\/  31                    10 9        0\n+\/\/ The non-rejected bits are the 8 lower bits of v. The bits 8 and 9 of v are still\n+\/\/ present in (v << 22) >> 22 but will be dropped by the store. The simplification is\n+\/\/ still correct.\n+\n+\/\/ ###### But! Case 1.3: conIL == conIR > num_rejected_bits\n+\/\/ If we do the shift left then right by 26 bits, we get:\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 26\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..5] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     6 5        0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-5 => the bits 0 to 5 of v\n+\/\/ - 6-7 => the sign bit of v[0..5] (that is v[5])\n+\/\/ Simplifying this as v is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 1\n+\/\/\n+\/\/ ### Case 2: conIL > conIR\n+\/\/ ###### Case 2.1: num_rejected_bits == conIR\n+\/\/ We take conIL == 26 for this example.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 24\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               8 7       2 1   0\n+\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The simplification is still correct.\n+\/\/\n+\/\/ ###### Case 2.2: num_rejected_bits > conIR.\n+\/\/ Let's say conIL == 26 and conIR == 22.\n+\/\/ after: v << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after: (v << 26) >> 22\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31              10 9       4 3   0\n+\/\/ The bits non-rejected by the store are exactly the 8 lower ones of (v << (conIL - conIR)):\n+\/\/ - 0-3 => 0\n+\/\/ - 4-7 => bits 0 to 3 of v\n+\/\/ The simplification is still correct.\n+\/\/ The bits 4 and 5 of v are still present in (v << (conIL - conIR)) but they don't\n+\/\/ matter as they are not in the 8 lower bits: they will be cut out by the store.\n+\/\/\n+\/\/ ###### But! Case 2.3: num_rejected_bits < conIR.\n+\/\/ Let's see that this case is not as easy to simplify.\n+\/\/ Let's say conIL == 28 and conIR == 26.\n+\/\/ after: v << 28\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..3] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     28 27                      0\n+\/\/ after: (v << 28) >> 26\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..3] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               6 5       2 1   0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-1 => 0\n+\/\/ - 2-5 => the bits 0 to 3 of v\n+\/\/ - 6-7 => the sign bit of v[0..3] (that is v[3])\n+\/\/ Simplifying this as (v << 2) is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary in Case 2.\n+\/\/\n+\/\/ ### Conclusion:\n+\/\/ Our hypotheses are indeed sufficient:\n+\/\/   - 0 <= conIL < BitsPerJavaInteger\n+\/\/   - 0 <= conIR < BitsPerJavaInteger\n+\/\/   - conIL >= conIR\n+\/\/   - num_rejected_bits >= conIR\n+\/\/\n+\/\/ ### A rationale without case analysis:\n+\/\/ After the shift left, conIL upper  bits of v are discarded and conIL lower bit\n+\/\/ zeroes are added. After the shift right, conIR lower bits of the previous result\n+\/\/ are discarded. If conIL >= conIR, we discard only the zeroes we made up during\n+\/\/ the shift left, but if conIL < conIR, then we discard also lower bits of v. But\n+\/\/ the point of the simplification is to get an expression of the form\n+\/\/ (v << (conIL - conIR)). This expression discard only higher bits of v, thus the\n+\/\/ simplification is not correct if conIL < conIR.\n+\/\/\n+\/\/ Moreover, after the shift right, the higher bit of (v << conIL) is repeated on the\n+\/\/ conIR higher bits of ((v << conIL) >> conIR), it's the sign-extension. If\n+\/\/ conIR > num_rejected_bits, then at least one artificial copy of this sign bit will\n+\/\/ be in the window of the store. Thus ((v << conIL) >> conIR) is not equivalent to\n+\/\/ (v << (conIL-conIR)) if conIR > num_rejected_bits.\n+\/\/\n+\/\/ We do not treat the case conIL < conIR here since the point of this function is\n+\/\/ to skip sign-extensions (that is conIL == conIR == num_rejected_bits). The need\n+\/\/ of treating conIL > conIR comes from the cases where the sign-extended value is\n+\/\/ also left-shift expression. Computing the sign-extension of a right-shift expression\n+\/\/ doesn't yield a situation such as\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ v conIL) conIR))\n+\/\/ where conIL < conIR.\n+Node* StoreNode::Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits) {\n+  Node* shr = in(MemNode::ValueIn);\n+  if (shr->Opcode() == Op_RShiftI) {\n+    const TypeInt* conIR = phase->type(shr->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && conIR->get_con() >= 0 && conIR->get_con() < BitsPerJavaInteger && conIR->get_con() <= num_rejected_bits) {\n+      Node* shl = shr->in(1);\n+      if (shl->Opcode() == Op_LShiftI) {\n+        const TypeInt* conIL = phase->type(shl->in(2))->isa_int();\n+        if (conIL != nullptr && conIL->is_con() && conIL->get_con() >= 0 && conIL->get_con() < BitsPerJavaInteger) {\n+          if (conIL->get_con() == conIR->get_con()) {\n+            set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+            return this;\n+          }\n+          if (conIL->get_con() > conIR->get_con()) {\n+            Node* new_shl = phase->transform(new LShiftINode(shl->in(1), phase->intcon(conIL->get_con() - conIR->get_con())));\n+            set_req_X(MemNode::ValueIn, new_shl, phase);\n+            return this;\n+          }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":202,"deletions":14,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-  Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);\n+  Node* Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -973,0 +973,37 @@\n+\/\/ Called with\n+\/\/    outer_shift = (_ << con0)\n+\/\/ We are looking for the pattern:\n+\/\/   outer_shift = ((X << con1) << con0)\n+\/\/   we denote inner_shift the nested expression (X << con1)\n+\/\/\n+\/\/ con0 and con1 are both in [0..nbits), as they are computed by maskShiftAmount.\n+\/\/\n+\/\/ There are 2 cases:\n+\/\/ if con0 + con1 >= nbits => 0\n+\/\/ if con0 + con1 < nbits => X << (con1 + con0)\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, Node* outer_shift, int con0, BasicType bt) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+  int nbits = static_cast<int>(bits_per_java_integer(bt));\n+  Node* inner_shift = outer_shift->in(1);\n+  if (inner_shift->Opcode() != Op_LShift(bt)) {\n+    return nullptr;\n+  }\n+\n+  int con1 = maskShiftAmount(phase, inner_shift, nbits);\n+  if (con1 == 0) { \/\/ Either non-const, or actually 0 (up to mask) and then delegated to Identity()\n+    return nullptr;\n+  }\n+\n+  if (con0 + con1 >= nbits) {\n+    \/\/ While it might be tempting to use\n+    \/\/ phase->zerocon(bt);\n+    \/\/ it would be incorrect: zerocon caches nodes, while Ideal is only allowed\n+    \/\/ to return a new node, this or nullptr, but not an old (cached) node.\n+    return ConNode::make(TypeInteger::zero(bt));\n+  }\n+\n+  \/\/ con0 + con1 < nbits ==> actual shift happens now\n+  Node* con0_plus_con1 = phase->intcon(con0 + con1);\n+  return LShiftNode::make(inner_shift->in(1), con0_plus_con1, bt);\n+}\n+\n@@ -986,0 +1023,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1098,0 +1138,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_INT);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n@@ -1162,0 +1209,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1274,0 +1324,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_LONG);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -800,0 +800,8 @@\n+inline uint bits_per_java_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return BitsPerJavaInteger;\n+  }\n+  assert(bt == T_LONG, \"int or long only\");\n+  return BitsPerJavaLong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static compiler.lib.generators.Generators.G;\n+\n@@ -36,0 +38,3 @@\n+    private static final int CON0 = G.ints().next();\n+    private static final int CON1 = G.ints().next();\n+\n@@ -40,1 +45,13 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+            \"testDoubleShift8\",\n+            \"testDoubleShift9\",\n+            \"testDoubleShiftSliceAndStore\",\n+            \"testRandom\",\n+    })\n@@ -69,0 +86,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -134,0 +153,117 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(int a) {\n+        Asserts.assertEQ((a << 2) << 3, testDoubleShift1(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift1(a));\n+\n+        Asserts.assertEQ(((a << 2) << 3) << 1, testDoubleShift2(a));\n+        Asserts.assertEQ(a << 6, testDoubleShift2(a));\n+\n+        Asserts.assertEQ((a << 31) << 1, testDoubleShift3(a));\n+        Asserts.assertEQ(0, testDoubleShift3(a));\n+\n+        Asserts.assertEQ((a << 1) << 31, testDoubleShift4(a));\n+        Asserts.assertEQ(0, testDoubleShift4(a));\n+\n+        Asserts.assertEQ(((a << 30) << 1) << 1, testDoubleShift5(a));\n+        Asserts.assertEQ(0, testDoubleShift5(a));\n+\n+        Asserts.assertEQ((a * 4) << 3, testDoubleShift6(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift6(a));\n+\n+        Asserts.assertEQ((a << 3) * 4, testDoubleShift7(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift7(a));\n+\n+        Asserts.assertEQ(a << 33, testDoubleShift8(a));\n+        Asserts.assertEQ(a << 1, testDoubleShift8(a));\n+\n+        Asserts.assertEQ((a << 30) << 3, testDoubleShift9(a));\n+        Asserts.assertEQ(0, testDoubleShift9(a));\n+\n+        short[] arr = new short[1];\n+        arr[0] = (short)a;\n+        Asserts.assertEQ((short)(a << 3), testDoubleShiftSliceAndStore(arr)[0]);\n+\n+        Asserts.assertEQ((a << CON0) << CON1, testRandom(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public int testDoubleShift1(int x) {\n+        return (x << 2) << 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public int testDoubleShift2(int x) {\n+        return ((x << 2) << 3) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 31) << 1 => 0\n+    public int testDoubleShift3(int x) {\n+        return (x << 31) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 31 => 0\n+    public int testDoubleShift4(int x) {\n+        return (x << 1) << 31;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 30) << 1) << 1 => 0\n+    public int testDoubleShift5(int x) {\n+        return ((x << 30) << 1) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public int testDoubleShift6(int x) {\n+        return (x * 4) << 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public int testDoubleShift7(int x) {\n+        return (x << 3) * 4;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x << 33 => x << 1\n+    public int testDoubleShift8(int x) {\n+        return x << 33;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 30) << 3 => 0\n+    public int testDoubleShift9(int x) {\n+        return (x << 30) << 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.RSHIFT})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (short) (a[0] << 3) => (((a[0] << 3) << 16) >> 16) => ((a[0] << 19) >> 16) => (a[0] << 3)\n+    public short[] testDoubleShiftSliceAndStore(short[] a) {\n+        short[] res = new short[1];\n+        res[0] = (short) (a[0] << 3);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"<= 1\"})\n+    public int testRandom(int x) {\n+        return (x << CON0) << CON1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":137,"deletions":1,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static compiler.lib.generators.Generators.G;\n@@ -36,0 +37,3 @@\n+    private static final long CON0 = G.longs().next();\n+    private static final long CON1 = G.longs().next();\n+\n@@ -40,1 +44,12 @@\n-    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+            \"testDoubleShift8\",\n+            \"testDoubleShift9\",\n+            \"testRandom\",\n+    })\n@@ -67,0 +82,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -116,0 +133,103 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(long a) {\n+        Asserts.assertEQ((a << 2L) << 3L, testDoubleShift1(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift1(a));\n+\n+        Asserts.assertEQ(((a << 2L) << 3L) << 1L, testDoubleShift2(a));\n+        Asserts.assertEQ(a << 6L, testDoubleShift2(a));\n+\n+        Asserts.assertEQ((a << 63L) << 1L, testDoubleShift3(a));\n+        Asserts.assertEQ(0L, testDoubleShift3(a));\n+\n+        Asserts.assertEQ((a << 1L) << 63L, testDoubleShift4(a));\n+        Asserts.assertEQ(0L, testDoubleShift4(a));\n+\n+        Asserts.assertEQ(((a << 62L) << 1L) << 1L, testDoubleShift5(a));\n+        Asserts.assertEQ(0L, testDoubleShift5(a));\n+\n+        Asserts.assertEQ((a * 4L) << 3L, testDoubleShift6(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift6(a));\n+\n+        Asserts.assertEQ((a << 3L) * 4L, testDoubleShift7(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift7(a));\n+\n+        Asserts.assertEQ(a << 65L, testDoubleShift8(a));\n+        Asserts.assertEQ(a << 1L, testDoubleShift8(a));\n+\n+        Asserts.assertEQ((a << 62L) << 3L, testDoubleShift9(a));\n+        Asserts.assertEQ(0L, testDoubleShift9(a));\n+\n+        Asserts.assertEQ((a << CON0) << CON1, testRandom(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public long testDoubleShift1(long x) {\n+        return (x << 2L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public long testDoubleShift2(long x) {\n+        return ((x << 2L) << 3L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 63) << 1 => 0\n+    public long testDoubleShift3(long x) {\n+        return (x << 63L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 63 => 0\n+    public long testDoubleShift4(long x) {\n+        return (x << 1L) << 63L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 62) << 1) << 1 => 0\n+    public long testDoubleShift5(long x) {\n+        return ((x << 62L) << 1L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public long testDoubleShift6(long x) {\n+        return (x * 4L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public long testDoubleShift7(long x) {\n+        return (x << 3L) * 4L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x << 65 => x << 1\n+    public long testDoubleShift8(long x) {\n+        return x << 65L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 62) << 3 => 0\n+    public long testDoubleShift9(long x) {\n+        return (x << 62L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"<= 1\"})\n+    public long testRandom(long x) {\n+        return (x << CON0) << CON1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":121,"deletions":1,"binary":false,"changes":122,"status":"modified"}]}