{"files":[{"patch":"@@ -3553,1 +3553,5 @@\n-\/\/ left shift, we always have at least one bit of the original v.\n+\/\/ left shift, we always have at least one bit of v remaining after the double shift.\n+\/\/ Thus, after the right shift, the upper bits will be a repetition of the higher bit\n+\/\/ of v that wasn't discarded by the left shift. The point is that there is no case\n+\/\/ to study where the left shift returns 0 unconditionally (clears all the bits):\n+\/\/ it might look like a corner case to pay attention to, but it actually is not.\n@@ -3567,1 +3571,1 @@\n-\/\/ The non-rejected bits are the same before and after, so, indeed, simplifying is fine.\n+\/\/ The non-rejected bits are the same before and after, so, indeed, simplifying is correct.\n@@ -3581,1 +3585,1 @@\n-\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n@@ -3583,1 +3587,1 @@\n-\/\/ The simplification is still fine.\n+\/\/ The simplification is still correct.\n@@ -3597,1 +3601,1 @@\n-\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n@@ -3600,1 +3604,1 @@\n-\/\/ The simplification is still fine.\n+\/\/ The simplification is still correct.\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"}]}