{"files":[{"patch":"@@ -3522,1 +3522,52 @@\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n+\/\/ If (conIL > conIR) we are inventing 0 lower bits, and throwing\n+\/\/ away upper bits, but we are not introducing garbage bits by above.\n+\/\/ We can simplify into\n+\/\/ (StoreB ... (LShiftI _ valIn (conIL - conIR)) )\n+\/\/ This case happens when the store source was itself a left shift, that gets merged\n+\/\/ into the inner left shift of the sign-extension.\n+\/\/ Let's assume we have the following 32 bits integer that we want to stuff in 8 bits char:\n+\/\/ +------------------------+---------+\n+\/\/ |        v[8..31]        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ v[0..7] is meaningful, but v[8..31] is not. In this case, num_rejected_bits == 24\n+\/\/ If we do the shift left then right by 24 bits, we get:\n+\/\/ after << 24\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..7] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     24 23                      0\n+\/\/ after >> 24\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ so, indeed, simplifying is fine. If we shift by more than 24 (e.g. 26),\n+\/\/ but then, shift right by 24:\n+\/\/ after << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after >> 24\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               8 7       2 1   0\n+\/\/ Now, if we shift right by less than the number of rejected bits:\n+\/\/ after << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after >> 22\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31              10 9       4 3   0\n+\/\/\n+\/\/ Basically, we decompose\n+\/\/ StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR)\n+\/\/ into\n+\/\/ StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ valIn (conIL - conIR)) conIR ) conIR)\n+Node* StoreNode::Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits) {\n@@ -3525,2 +3576,2 @@\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n+    const TypeInt* conIR = phase->type(val->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && (conIR->get_con() <= num_rejected_bits)) {\n@@ -3529,4 +3580,11 @@\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+        const TypeInt* conIL = phase->type(shl->in(2))->isa_int();\n+        if (conIL != nullptr && conIL->is_con()) {\n+          if (conIL->get_con() == conIR->get_con()) {\n+            set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+            return this;\n+          }\n+          if (conIL->get_con() > conIR->get_con()) {\n+            Node* new_shl = phase->transform(new LShiftINode(shl->in(1), phase->intcon(conIL->get_con() - conIR->get_con())));\n+            set_req_X(MemNode::ValueIn, new_shl, phase);\n+            return this;\n+          }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-  Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);\n+  Node* Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -973,0 +973,31 @@\n+\/\/ (X << con1) << con0 with con0 < nbits && con1 < nbits ==>\n+\/\/ if con0 + con1 >= nbits => 0\n+\/\/ if con0 + con1 < nbits => X << (con1 + con0)\n+\/\/\n+\/\/ outer_shift is, with the notation above, the (...) << con0\n+\/\/ con0 is the rhs of outer_shift (since it's already computed in the callers)\n+\/\/ con0 is assumed to be masked already (as computed by maskShiftAmount) and non-zero\n+\/\/ bt must be T_LONG or T_INT.\n+static Node* collapseDoubleShiftLeft(PhaseGVN* phase, Node* outer_shift, int con0, BasicType bt) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+  int nbits = bt == T_LONG ? BitsPerJavaLong : BitsPerJavaInteger;\n+  Node* inner_shift = outer_shift->in(1);\n+  int inner_shift_op = inner_shift->Opcode();\n+  if (inner_shift_op != Op_LShift(bt)) {\n+    return nullptr;\n+  }\n+\n+  int con1 = maskShiftAmount(phase, inner_shift, nbits);\n+  if (con1 == 0) { \/\/ Either non-const, or actually 0 (up to mask) and then delegated to Identity()\n+    return nullptr;\n+  }\n+\n+  if (con0 + con1 >= nbits) {\n+    return ConNode::make(TypeInteger::zero(bt));\n+  }\n+\n+  \/\/ con0 + con1 < nbits ==> actual shift happens now\n+  Node* con0_plus_con1 = phase->intcon(con0 + con1);\n+  return LShiftNode::make(inner_shift->in(1), con0_plus_con1, bt);\n+}\n+\n@@ -986,0 +1017,2 @@\n+\/\/\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2) (see collapseDoubleShiftLeft for details)\n@@ -1098,0 +1131,5 @@\n+  Node* doubleShift = collapseDoubleShiftLeft(phase, this, con, T_INT);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n@@ -1162,0 +1200,2 @@\n+\/\/\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2) (see collapseDoubleShiftLeft for details)\n@@ -1274,0 +1314,5 @@\n+  Node* doubleShift = collapseDoubleShiftLeft(phase, this, con, T_LONG);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -40,1 +40,10 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+            \"testDoubleShiftSliceAndStore\",\n+    })\n@@ -69,0 +78,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -134,0 +145,76 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(int a) {\n+        Asserts.assertEQ((a << 2) << 3, testDoubleShift1(a));\n+        Asserts.assertEQ(((a << 2) << 3) << 1, testDoubleShift2(a));\n+        Asserts.assertEQ((a << 31) << 1, testDoubleShift3(a));\n+        Asserts.assertEQ((a << 1) << 31, testDoubleShift4(a));\n+        Asserts.assertEQ(((a << 30) << 1) << 1, testDoubleShift5(a));\n+        Asserts.assertEQ((a * 4) << 3, testDoubleShift6(a));\n+        Asserts.assertEQ((a << 3) * 4, testDoubleShift7(a));\n+\n+        short[] arr = new short[1];\n+        arr[0] = (short)1;\n+        Asserts.assertEQ((short)(1 << 3), testDoubleShiftSliceAndStore(arr)[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public int testDoubleShift1(int x) {\n+        return (x << 2) << 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public int testDoubleShift2(int x) {\n+        return ((x << 2) << 3) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 31) << 1 => 0\n+    public int testDoubleShift3(int x) {\n+        return (x << 31) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 31 => 0\n+    public int testDoubleShift4(int x) {\n+        return (x << 1) << 31;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 30) << 1) << 1 => 0\n+    public int testDoubleShift5(int x) {\n+        return ((x << 30) << 1) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public int testDoubleShift6(int x) {\n+        return (x * 4) << 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public int testDoubleShift7(int x) {\n+        return (x << 3) * 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.RSHIFT})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (short) (a[0] << 3) => (((a[0] << 3) << 16) >> 16) => ((a[0] << 19) >> 16) => (a[0] << 3)\n+    public short[] testDoubleShiftSliceAndStore(short[] a) {\n+        short[] res = new short[1];\n+        res[0] = (short) (a[0] << 3);\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":88,"deletions":1,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -40,1 +40,9 @@\n-    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+    })\n@@ -67,0 +75,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -116,0 +126,62 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(long a) {\n+        Asserts.assertEQ((a << 2L) << 3L, testDoubleShift1(a));\n+        Asserts.assertEQ(((a << 2L) << 3L) << 1L, testDoubleShift2(a));\n+        Asserts.assertEQ((a << 63L) << 1L, testDoubleShift3(a));\n+        Asserts.assertEQ((a << 1L) << 63L, testDoubleShift4(a));\n+        Asserts.assertEQ(((a << 62L) << 1L) << 1L, testDoubleShift5(a));\n+        Asserts.assertEQ((a * 4L) << 3L, testDoubleShift6(a));\n+        Asserts.assertEQ((a << 3L) * 4L, testDoubleShift7(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public long testDoubleShift1(long x) {\n+        return (x << 2L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public long testDoubleShift2(long x) {\n+        return ((x << 2L) << 3L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 63) << 1 => 0\n+    public long testDoubleShift3(long x) {\n+        return (x << 63L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 63 => 0\n+    public long testDoubleShift4(long x) {\n+        return (x << 1L) << 63L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 62) << 1) << 1 => 0\n+    public long testDoubleShift5(long x) {\n+        return ((x << 62L) << 1L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public long testDoubleShift6(long x) {\n+        return (x * 4L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public long testDoubleShift7(long x) {\n+        return (x << 3L) * 4L;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"}]}