{"files":[{"patch":"@@ -3548,1 +3548,1 @@\n-\/\/ - conIR <= num_rejected_bits\n+\/\/ - num_rejected_bits >= conIR\n@@ -3559,0 +3559,1 @@\n+\/\/ If you don't like case analysis, jump after the conclusion.\n@@ -3560,0 +3561,1 @@\n+\/\/ ###### Case 1.1: conIL == conIR == num_rejected_bits\n@@ -3571,1 +3573,34 @@\n-\/\/ The non-rejected bits are the same before and after, so, indeed, simplifying is correct.\n+\/\/ The non-rejected bits (bits kept by the store, that is the 8 lower bits of the\n+\/\/ result) are the same before and after, so, indeed, simplifying is correct.\n+\n+\/\/ ###### Case 1.2: conIL == conIR < num_rejected_bits\n+\/\/ If we do the shift left then right by 22 bits, we get:\n+\/\/ after << 22\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..9] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     22 21                      0\n+\/\/ after >> 22\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..9] |\n+\/\/ +------------------------+---------+\n+\/\/  31                    10 9        0\n+\/\/ The non-rejected bits are the 8 lower bits of v. The bits 8 and 9 of v are still\n+\/\/ present in (v << 22) >> 22 but will be dropped by the store. The simplification is\n+\/\/ still correct.\n+\n+\/\/ ###### But! Case 1.3: conIL == conIR > num_rejected_bits\n+\/\/ If we do the shift left then right by 26 bits, we get:\n+\/\/ after << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after >> 26\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..6] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     6 5        0\n+\/\/ The non-rejected bits are the 8 lower bits of v. The bits 8 and 9 of v are still\n+\/\/ present in (v << 22) >> 22 but will be dropped by the store. The simplification is\n+\/\/ still correct.\n@@ -3573,1 +3608,2 @@\n-\/\/ ### Case 2: conIL > conIR == num_rejected_bits\n+\/\/ ### Case 2: conIL > conIR\n+\/\/ ###### Case 2.1: num_rejected_bits == conIR\n@@ -3589,1 +3625,1 @@\n-\/\/ ### Case 3: conIL > conIR < num_rejected_bits.\n+\/\/ ###### Case 2.2: num_rejected_bits > conIR.\n@@ -3601,3 +3637,3 @@\n-\/\/ The non-rejected bits are the 8 lower ones of (v << conIL - conIR).\n-\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n-\/\/ The bits 4 and 5 of v are still present, but outside the kept bits (the 8 lower ones).\n+\/\/ The bits non-rejected by the store are exactly the 8 lower ones of (v << (conIL - conIR)):\n+\/\/ - 0-3 => 0\n+\/\/ - 4-7 => bits 0 to 3 of v\n@@ -3605,0 +3641,2 @@\n+\/\/ The bits 4 and 5 of v are still present in (v << (conIL - conIR)) but they don't\n+\/\/ matter as they are not in the 8 lower bits: they will be cut out by the store.\n@@ -3606,1 +3644,1 @@\n-\/\/ ### But! Case 4: conIL > conIR > num_rejected_bits.\n+\/\/ ###### But! Case 2.3: num_rejected_bits < conIR.\n@@ -3627,1 +3665,18 @@\n-\/\/ Valid if conIL >= conIR <= num_rejected_bits\n+\/\/ Valid if:\n+\/\/ - conIL >= conIR\n+\/\/ - num_rejected_bits >= conIR\n+\/\/\n+\/\/ ### A rationale without case analysis:\n+\/\/ After the shift left, conIL upper  bits of v are discarded and conIL lower bit\n+\/\/ zeroes are added. After the shift right, conIR lower bits of the previous result\n+\/\/ are discarded. If conIL >= conIR, we discard only the zeroes we made up during\n+\/\/ the shift left, but if conIL < conIR, then we discard also lower bits of v. But\n+\/\/ the point of the simplification is to get an expression of the form\n+\/\/ (v << (conIL - conIR)). This expression discard only higher bits of v, thus the\n+\/\/ simplification is not correct if conIL < conIR.\n+\/\/\n+\/\/ Moreover, after the shift right, the higher bit of (v << conIL) is repeated on the\n+\/\/ conIR higher bits of ((v << conIL) >> conIR), it's the sign-extension. If\n+\/\/ conIR > num_rejected_bits, then at least one artificial copy of this sign bit will\n+\/\/ be in the window of the store. Thus ((v << conIL) >> conIR) is not equivalent to\n+\/\/ (v << (conIL-conIR)) if conIR > num_rejected_bits.\n@@ -3629,1 +3684,1 @@\n-\/\/ We do not treat the case conIR > conIL here since the point of this function is\n+\/\/ We do not treat the case conIL < conIR here since the point of this function is\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":65,"deletions":10,"binary":false,"changes":75,"status":"modified"}]}