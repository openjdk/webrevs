{"files":[{"patch":"@@ -3522,11 +3522,124 @@\n-Node *StoreNode::Ideal_sign_extended_input(PhaseGVN *phase, int num_bits) {\n-  Node *val = in(MemNode::ValueIn);\n-  if( val->Opcode() == Op_RShiftI ) {\n-    const TypeInt *t = phase->type( val->in(2) )->isa_int();\n-    if( t && t->is_con() && (t->get_con() <= num_bits) ) {\n-      Node *shl = val->in(1);\n-      if( shl->Opcode() == Op_LShiftI ) {\n-        const TypeInt *t2 = phase->type( shl->in(2) )->isa_int();\n-        if( t2 && t2->is_con() && (t2->get_con() == t->get_con()) ) {\n-          set_req_X(MemNode::ValueIn, shl->in(1), phase);\n-          return this;\n+\/\/ If (conIL > conIR) we are inventing 0 lower bits, and throwing\n+\/\/ away upper bits, but we are not introducing garbage bits from the upper bits\n+\/\/ (the right in the notation below).\n+\/\/ We can simplify into\n+\/\/ (StoreB ... (LShiftI _ valIn (conIL - conIR)) )\n+\/\/ This case happens when the right-hand side of the store was itself a left shift, that gets merged\n+\/\/ into the inner left shift of the sign-extension. For instance, if we have\n+\/\/ array_of_shorts[0] = (short)(X << 2)\n+\/\/ We get a structure such as:\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ X 2) 16) 16))\n+\/\/ that is simplified into\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ X 18) 16)).\n+\/\/ It is thus useful to handle the case where conIL > conIR.\n+\/\/\n+\/\/ Let's assume we have the following 32 bits integer that we want to stuff in 8 bits char:\n+\/\/ +------------------------+---------+\n+\/\/ |        v[8..31]        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ v[0..7] is meaningful, but v[8..31] is not. In this case, num_rejected_bits == 24.\n+\/\/ Let's study what happens in different cases to see that the simplification into\n+\/\/ (StoreB ... (LShiftI _ valIn (conIL - conIR)) )\n+\/\/ is valid if:\n+\/\/ - conIL >= conIR\n+\/\/ - conIR <= num_rejected_bits\n+\/\/ Let's also remember that conIL < 32 since (x << 33) is simplified into (x << 1)\n+\/\/ and (x << 31) << 2 is simplified into 0. This means that in any case, after the\n+\/\/ left shift, we always have at least one bit of the original v.\n+\/\/\n+\/\/ ### Case 1 : conIL == conIR\n+\/\/ If we do the shift left then right by 24 bits, we get:\n+\/\/ after << 24\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..7] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     24 23                      0\n+\/\/ after >> 24\n+\/\/ +------------------------+---------+\n+\/\/ |        sign bit        | v[0..7] |\n+\/\/ +------------------------+---------+\n+\/\/  31                     8 7        0\n+\/\/ The non-rejected bits are the same before and after, so, indeed, simplifying is fine.\n+\/\/\n+\/\/ ### Case 2: conIL > conIR == num_rejected_bits\n+\/\/ We take conIL == 26 for this example.\n+\/\/ after << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after >> 24\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               8 7       2 1   0\n+\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The simplification is still fine.\n+\/\/\n+\/\/ ### Case 3: conIL > conIR < num_rejected_bits.\n+\/\/ Let's say conIL == 26 and conIR == 22.\n+\/\/ after << 26\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..5] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     26 25                      0\n+\/\/ after >> 22\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..5] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31              10 9       4 3   0\n+\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The bits 4 and 5 of v are still present, but outside of the kept bits (the 8 lower ones).\n+\/\/ The simplification is still fine.\n+\/\/\n+\/\/ ### But! Case 4: conIL > conIR > num_rejected_bits.\n+\/\/ Let's see that this case is not as easy to simplify.\n+\/\/ Let's say conIL == 28 and conIR == 26.\n+\/\/ after << 28\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..3] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     28 27                      0\n+\/\/ after >> 26\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..3] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               6 5       2 1   0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-1 => 0\n+\/\/ - 2-5 => the bits 0 to 3 of v\n+\/\/ - 6-7 => the sign bit of v[0..3] (that is v[3])\n+\/\/ Simplifying this as (X << 2) is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary.\n+\/\/\n+\/\/ ### Conclusion:\n+\/\/ Valid if conIL >= conIR <= num_rejected_bits\n+\/\/\n+\/\/ We do not treat the case conIR > conIL here since the point of this function is\n+\/\/ to skip sign-extensions (that is conIL == conIR == num_rejected_bits). The need\n+\/\/ of treating conIL > conIR comes from the cases where the sign-extended value is\n+\/\/ also left-shift expression. Computing the sign-extension of a right-shift expression\n+\/\/ doesn't yield a situation such as\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n+\/\/ where conIL < conIR.\n+Node* StoreNode::Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits) {\n+  Node* shr = in(MemNode::ValueIn);\n+  if (shr->Opcode() == Op_RShiftI) {\n+    const TypeInt* conIR = phase->type(shr->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && conIR->get_con() <= num_rejected_bits) {\n+      Node* shl = shr->in(1);\n+      if (shl->Opcode() == Op_LShiftI) {\n+        const TypeInt* conIL = phase->type(shl->in(2))->isa_int();\n+        if (conIL != nullptr && conIL->is_con()) {\n+          if (conIL->get_con() == conIR->get_con()) {\n+            set_req_X(MemNode::ValueIn, shl->in(1), phase);\n+            return this;\n+          }\n+          if (conIL->get_con() > conIR->get_con()) {\n+            Node* new_shl = phase->transform(new LShiftINode(shl->in(1), phase->intcon(conIL->get_con() - conIR->get_con())));\n+            set_req_X(MemNode::ValueIn, new_shl, phase);\n+            return this;\n+          }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":124,"deletions":11,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -582,1 +582,1 @@\n-  Node *Ideal_sign_extended_input(PhaseGVN *phase, int  num_bits);\n+  Node* Ideal_sign_extended_input(PhaseGVN* phase, int num_rejected_bits);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -973,0 +973,37 @@\n+\/\/ Called with\n+\/\/    outer_shift = (_ << con0)\n+\/\/ We are looking for the pattern:\n+\/\/   outer_shift = ((X << con1) << con0)\n+\/\/   we denote inner_shift the nested expression (X << con1)\n+\/\/\n+\/\/ con0 and con1 are both in [0..nbits), as they are computed by maskShiftAmount.\n+\/\/\n+\/\/ There are 2 cases:\n+\/\/ if con0 + con1 >= nbits => 0\n+\/\/ if con0 + con1 < nbits => X << (con1 + con0)\n+static Node* collapse_nested_shift_left(PhaseGVN* phase, Node* outer_shift, int con0, BasicType bt) {\n+  assert(bt == T_LONG || bt == T_INT, \"Unexpected type\");\n+  int nbits = bt == T_LONG ? BitsPerJavaLong : BitsPerJavaInteger;\n+  Node* inner_shift = outer_shift->in(1);\n+  if (inner_shift->Opcode() != Op_LShift(bt)) {\n+    return nullptr;\n+  }\n+\n+  int con1 = maskShiftAmount(phase, inner_shift, nbits);\n+  if (con1 == 0) { \/\/ Either non-const, or actually 0 (up to mask) and then delegated to Identity()\n+    return nullptr;\n+  }\n+\n+  if (con0 + con1 >= nbits) {\n+    \/\/ While it might be tempting to use\n+    \/\/ phase->zerocon(bt);\n+    \/\/ it would be incorrect: zerocon caches nodes, while Ideal is only allowed\n+    \/\/ to return a new node, this or nullptr, but not an old (cached) node.\n+    return ConNode::make(TypeInteger::zero(bt));\n+  }\n+\n+  \/\/ con0 + con1 < nbits ==> actual shift happens now\n+  Node* con0_plus_con1 = phase->intcon(con0 + con1);\n+  return LShiftNode::make(inner_shift->in(1), con0_plus_con1, bt);\n+}\n+\n@@ -986,0 +1023,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1098,0 +1138,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_INT);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n@@ -1162,0 +1209,3 @@\n+\/\/\n+\/\/ Also collapse nested left-shifts with constant rhs:\n+\/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1274,0 +1324,7 @@\n+  \/\/ Performs:\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n+  Node* doubleShift = collapse_nested_shift_left(phase, this, con, T_LONG);\n+  if (doubleShift != nullptr) {\n+    return doubleShift;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static compiler.lib.generators.Generators.G;\n+\n@@ -36,0 +38,3 @@\n+    private static final int CON0 = G.ints().next();\n+    private static final int CON1 = G.ints().next();\n+\n@@ -40,1 +45,13 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+            \"testDoubleShift8\",\n+            \"testDoubleShift9\",\n+            \"testDoubleShiftSliceAndStore\",\n+            \"testRandom\",\n+    })\n@@ -69,0 +86,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -134,0 +153,117 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(int a) {\n+        Asserts.assertEQ((a << 2) << 3, testDoubleShift1(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift1(a));\n+\n+        Asserts.assertEQ(((a << 2) << 3) << 1, testDoubleShift2(a));\n+        Asserts.assertEQ(a << 6, testDoubleShift2(a));\n+\n+        Asserts.assertEQ((a << 31) << 1, testDoubleShift3(a));\n+        Asserts.assertEQ(0, testDoubleShift3(a));\n+\n+        Asserts.assertEQ((a << 1) << 31, testDoubleShift4(a));\n+        Asserts.assertEQ(0, testDoubleShift4(a));\n+\n+        Asserts.assertEQ(((a << 30) << 1) << 1, testDoubleShift5(a));\n+        Asserts.assertEQ(0, testDoubleShift5(a));\n+\n+        Asserts.assertEQ((a * 4) << 3, testDoubleShift6(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift6(a));\n+\n+        Asserts.assertEQ((a << 3) * 4, testDoubleShift7(a));\n+        Asserts.assertEQ(a << 5, testDoubleShift7(a));\n+\n+        Asserts.assertEQ(a << 33, testDoubleShift8(a));\n+        Asserts.assertEQ(a << 1, testDoubleShift8(a));\n+\n+        Asserts.assertEQ((a << 30) << 3, testDoubleShift9(a));\n+        Asserts.assertEQ(0, testDoubleShift9(a));\n+\n+        short[] arr = new short[1];\n+        arr[0] = (short)a;\n+        Asserts.assertEQ((short)(a << 3), testDoubleShiftSliceAndStore(arr)[0]);\n+\n+        Asserts.assertEQ((a << CON0) << CON1, testRandom(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public int testDoubleShift1(int x) {\n+        return (x << 2) << 3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public int testDoubleShift2(int x) {\n+        return ((x << 2) << 3) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 31) << 1 => 0\n+    public int testDoubleShift3(int x) {\n+        return (x << 31) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 31 => 0\n+    public int testDoubleShift4(int x) {\n+        return (x << 1) << 31;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 30) << 1) << 1 => 0\n+    public int testDoubleShift5(int x) {\n+        return ((x << 30) << 1) << 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public int testDoubleShift6(int x) {\n+        return (x * 4) << 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public int testDoubleShift7(int x) {\n+        return (x << 3) * 4;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x << 33 => x << 1\n+    public int testDoubleShift8(int x) {\n+        return x << 33;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 30) << 3 => 0\n+    public int testDoubleShift9(int x) {\n+        return (x << 30) << 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL, IRNode.RSHIFT})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (short) (a[0] << 3) => (((a[0] << 3) << 16) >> 16) => ((a[0] << 19) >> 16) => (a[0] << 3)\n+    public short[] testDoubleShiftSliceAndStore(short[] a) {\n+        short[] res = new short[1];\n+        res[0] = (short) (a[0] << 3);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"<= 1\"})\n+    public int testRandom(int x) {\n+        return (x << CON0) << CON1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftINodeIdealizationTests.java","additions":137,"deletions":1,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static compiler.lib.generators.Generators.G;\n@@ -36,0 +37,3 @@\n+    private static final long CON0 = G.longs().next();\n+    private static final long CON1 = G.longs().next();\n+\n@@ -40,1 +44,12 @@\n-    @Run(test = { \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = {\"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\",\n+            \"testDoubleShift1\",\n+            \"testDoubleShift2\",\n+            \"testDoubleShift3\",\n+            \"testDoubleShift4\",\n+            \"testDoubleShift5\",\n+            \"testDoubleShift6\",\n+            \"testDoubleShift7\",\n+            \"testDoubleShift8\",\n+            \"testDoubleShift9\",\n+            \"testRandom\",\n+    })\n@@ -67,0 +82,2 @@\n+\n+        assertDoubleShiftResult(a);\n@@ -116,0 +133,103 @@\n+\n+    @DontCompile\n+    public void assertDoubleShiftResult(long a) {\n+        Asserts.assertEQ((a << 2L) << 3L, testDoubleShift1(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift1(a));\n+\n+        Asserts.assertEQ(((a << 2L) << 3L) << 1L, testDoubleShift2(a));\n+        Asserts.assertEQ(a << 6L, testDoubleShift2(a));\n+\n+        Asserts.assertEQ((a << 63L) << 1L, testDoubleShift3(a));\n+        Asserts.assertEQ(0L, testDoubleShift3(a));\n+\n+        Asserts.assertEQ((a << 1L) << 63L, testDoubleShift4(a));\n+        Asserts.assertEQ(0L, testDoubleShift4(a));\n+\n+        Asserts.assertEQ(((a << 62L) << 1L) << 1L, testDoubleShift5(a));\n+        Asserts.assertEQ(0L, testDoubleShift5(a));\n+\n+        Asserts.assertEQ((a * 4L) << 3L, testDoubleShift6(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift6(a));\n+\n+        Asserts.assertEQ((a << 3L) * 4L, testDoubleShift7(a));\n+        Asserts.assertEQ(a << 5L, testDoubleShift7(a));\n+\n+        Asserts.assertEQ(a << 65L, testDoubleShift8(a));\n+        Asserts.assertEQ(a << 1L, testDoubleShift8(a));\n+\n+        Asserts.assertEQ((a << 62L) << 3L, testDoubleShift9(a));\n+        Asserts.assertEQ(0L, testDoubleShift9(a));\n+\n+        Asserts.assertEQ((a << CON0) << CON1, testRandom(a));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 2) << 3 => x << 5\n+    public long testDoubleShift1(long x) {\n+        return (x << 2L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks ((x << 2) << 3) << 1 => x << 6\n+    public long testDoubleShift2(long x) {\n+        return ((x << 2L) << 3L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 63) << 1 => 0\n+    public long testDoubleShift3(long x) {\n+        return (x << 63L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 1) << 63 => 0\n+    public long testDoubleShift4(long x) {\n+        return (x << 1L) << 63L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks ((x << 62) << 1) << 1 => 0\n+    public long testDoubleShift5(long x) {\n+        return ((x << 62L) << 1L) << 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x * 4) << 3 => x << 5\n+    public long testDoubleShift6(long x) {\n+        return (x * 4L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks (x << 3) * 4 => x << 5\n+    public long testDoubleShift7(long x) {\n+        return (x << 3L) * 4L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"1\"})\n+    \/\/ Checks x << 65 => x << 1\n+    public long testDoubleShift8(long x) {\n+        return x << 65L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.LSHIFT})\n+    \/\/ Checks (x << 62) << 3 => 0\n+    public long testDoubleShift9(long x) {\n+        return (x << 62L) << 3L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LSHIFT, \"<= 1\"})\n+    public long testRandom(long x) {\n+        return (x << CON0) << CON1;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/LShiftLNodeIdealizationTests.java","additions":121,"deletions":1,"binary":false,"changes":122,"status":"modified"}]}