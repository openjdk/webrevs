{"files":[{"patch":"@@ -3523,1 +3523,2 @@\n-\/\/ away upper bits, but we are not introducing garbage bits by above.\n+\/\/ away upper bits, but we are not introducing garbage bits from the upper bits\n+\/\/ (the right in the notation below).\n@@ -3526,2 +3527,9 @@\n-\/\/ This case happens when the store source was itself a left shift, that gets merged\n-\/\/ into the inner left shift of the sign-extension.\n+\/\/ This case happens when the right-hand side of the store was itself a left shift, that gets merged\n+\/\/ into the inner left shift of the sign-extension. For instance, if we have\n+\/\/ array_of_shorts[0] = (short)(X << 2)\n+\/\/ We get a structure such as:\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ X 2) 16) 16))\n+\/\/ that is simplified into\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ X 18) 16)).\n+\/\/ It is thus useful to handle the case where conIL > conIR.\n+\/\/\n@@ -3533,1 +3541,11 @@\n-\/\/ v[0..7] is meaningful, but v[8..31] is not. In this case, num_rejected_bits == 24\n+\/\/ v[0..7] is meaningful, but v[8..31] is not. In this case, num_rejected_bits == 24.\n+\/\/ Let's study what happens in different cases to see that the simplification into\n+\/\/ (StoreB ... (LShiftI _ valIn (conIL - conIR)) )\n+\/\/ is valid if:\n+\/\/ - conIL >= conIR\n+\/\/ - conIR <= num_rejected_bits\n+\/\/ Let's also remember that conIL < 32 since (x << 33) is simplified into (x << 1)\n+\/\/ and (x << 31) << 2 is simplified into 0. This means that in any case, after the\n+\/\/ left shift, we always have at least one bit of the original v.\n+\/\/\n+\/\/ ### Case 1 : conIL == conIR\n@@ -3545,2 +3563,4 @@\n-\/\/ so, indeed, simplifying is fine. If we shift by more than 24 (e.g. 26),\n-\/\/ but then, shift right by 24:\n+\/\/ The non-rejected bits are the same before and after, so, indeed, simplifying is fine.\n+\/\/\n+\/\/ ### Case 2: conIL > conIR == num_rejected_bits\n+\/\/ We take conIL == 26 for this example.\n@@ -3557,1 +3577,6 @@\n-\/\/ Now, if we shift right by less than the number of rejected bits:\n+\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The simplification is still fine.\n+\/\/\n+\/\/ ### Case 3: conIL > conIR < num_rejected_bits.\n+\/\/ Let's say conIL == 26 and conIR == 22.\n@@ -3568,0 +3593,4 @@\n+\/\/ The non-rejected bits are the 8 lower one of (v << conIL - conIR).\n+\/\/ The bits 6 and 7 of v have been thrown away after the shift left.\n+\/\/ The bits 4 and 5 of v are still present, but outside of the kept bits (the 8 lower ones).\n+\/\/ The simplification is still fine.\n@@ -3569,4 +3598,30 @@\n-\/\/ Basically, we decompose\n-\/\/ StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR)\n-\/\/ into\n-\/\/ StoreB ... (RShiftI _ (LShiftI _ (LShiftI _ valIn (conIL - conIR)) conIR ) conIR)\n+\/\/ ### But! Case 4: conIL > conIR > num_rejected_bits.\n+\/\/ Let's see that this case is not as easy to simplify.\n+\/\/ Let's say conIL == 28 and conIR == 26.\n+\/\/ after << 28\n+\/\/ +---------+------------------------+\n+\/\/ | v[0..3] |           0            |\n+\/\/ +---------+------------------------+\n+\/\/  31     28 27                      0\n+\/\/ after >> 26\n+\/\/ +------------------+---------+-----+\n+\/\/ |     sign bit     | v[0..3] |  0  |\n+\/\/ +------------------+---------+-----+\n+\/\/  31               6 5       2 1   0\n+\/\/ The non-rejected bits are made of\n+\/\/ - 0-1 => 0\n+\/\/ - 2-5 => the bits 0 to 3 of v\n+\/\/ - 6-7 => the sign bit of v[0..3] (that is v[3])\n+\/\/ Simplifying this as (X << 2) is not correct.\n+\/\/ The condition conIR <= num_rejected_bits is indeed necessary.\n+\/\/\n+\/\/ ### Conclusion:\n+\/\/ Valid if conIL >= conIR <= num_rejected_bits\n+\/\/\n+\/\/ We do not treat the case conIR > conIL here since the point of this function is\n+\/\/ to skip sign-extensions (that is conIL == conIR == num_rejected_bits). The need\n+\/\/ of treating conIL > conIR comes from the cases where the sign-extended value is\n+\/\/ also left-shift expression. Computing the sign-extension of a right-shift expression\n+\/\/ doesn't yield a situation such as\n+\/\/ (StoreB ... (RShiftI _ (LShiftI _ valIn conIL ) conIR) )\n+\/\/ where conIL < conIR.\n@@ -3574,5 +3629,5 @@\n-  Node* val = in(MemNode::ValueIn);\n-  if (val->Opcode() == Op_RShiftI) {\n-    const TypeInt* conIR = phase->type(val->in(2))->isa_int();\n-    if (conIR != nullptr && conIR->is_con() && (conIR->get_con() <= num_rejected_bits)) {\n-      Node* shl = val->in(1);\n+  Node* shr = in(MemNode::ValueIn);\n+  if (shr->Opcode() == Op_RShiftI) {\n+    const TypeInt* conIR = phase->type(shr->in(2))->isa_int();\n+    if (conIR != nullptr && conIR->is_con() && conIR->get_con() <= num_rejected_bits) {\n+      Node* shl = shr->in(1);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":71,"deletions":16,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1136,1 +1136,1 @@\n-  \/\/ (X << con1) << con2 ==> X << (con1 + con2) (see implementation for subtleties)\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n@@ -1322,1 +1322,1 @@\n-  \/\/ (X << con1) << con2 ==> X << (con1 + con2) (see implementation for subtleties)\n+  \/\/ (X << con1) << con2 ==> X << (con1 + con2)\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}