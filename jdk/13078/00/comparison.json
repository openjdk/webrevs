{"files":[{"patch":"@@ -544,0 +544,2 @@\n+    remove_cycles();\n+\n@@ -2349,0 +2351,198 @@\n+class PacksetGraph {\n+private:\n+  \/\/ pid: packset graph node id.\n+  GrowableArray<int> _pid; \/\/ Node.idx -> pid\n+  GrowableArray<int> _incnt;\n+  GrowableArray<GrowableArray<int>> _out;\n+  int _max_pid = 0;\n+\n+  GrowableArray<Node*> &_block;\n+  GrowableArray<Node_List*> &_packset;\n+  DepGraph &_dg;\n+public:\n+  PacksetGraph(Arena* a,\n+                GrowableArray<Node*> &block,\n+                GrowableArray<Node_List*> &packset,\n+                DepGraph &dg)\n+  : _pid(a, 8, 0, \/* default *\/ 0), _block(block), _packset(packset), _dg(dg) {\n+  }\n+  \/\/ Get pid, if there is a packset node that n belongs to. Else return 0.\n+  int get_pid_or_zero(const Node* n) const {\n+    if ((int)n->_idx >= _pid.length()) {\n+      return 0;\n+    } else {\n+      return _pid.at(n->_idx);\n+    }\n+  }\n+  int get_pid(const Node* n) {\n+    int poz = get_pid_or_zero(n);\n+    assert(poz != 0, \"pid should not be zero\");\n+    return poz;\n+  }\n+  void set_pid(const Node* n, int pid) {\n+    assert(n != nullptr && pid > 0, \"sane inputs\");\n+    _pid.at_put_grow(n->_idx, pid);\n+  }\n+  int new_pid() {\n+    _incnt.push(0);\n+    _out.push(GrowableArray<int>());\n+    return ++_max_pid;\n+  }\n+  int incnt(int pid) { return _incnt.at(pid - 1); }\n+  void incnt_set(int pid, int cnt) { return _incnt.at_put(pid - 1, cnt); }\n+  GrowableArray<int>& out(int pid) { return _out.at(pid - 1); }\n+\n+  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on DepPreds.\n+  void build() {\n+    \/\/ Map nodes in packsets\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* p = _packset.at(i);\n+      int pid = new_pid();\n+      for (uint k = 0; k < p->size(); k++) {\n+        Node* n = p->at(k);\n+        set_pid(n, pid);\n+      }\n+    }\n+\n+    int max_pid_packset = _max_pid;\n+\n+    \/\/ Map nodes not in packset\n+    for (int i = 0; i < _block.length(); i++) {\n+      Node* n = _block.at(i);\n+      if (n->is_Phi() || n->is_CFG()) {\n+        continue; \/\/ ignore control flow\n+      }\n+      int pid = get_pid_or_zero(n);\n+      if (pid == 0) {\n+        pid = new_pid();\n+        set_pid(n, pid);\n+      }\n+    }\n+\n+    \/\/ Map edges for packset nodes\n+    VectorSet set;\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* p = _packset.at(i);\n+      set.clear();\n+      for (uint k = 0; k < p->size(); k++) {\n+        Node* n = p->at(k);\n+        int pid = get_pid(n);\n+        for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+          Node* pred = preds.current();\n+          int pred_pid = get_pid_or_zero(pred);\n+          if (pred_pid == pid && n->is_reduction()) {\n+            continue; \/\/ reduction -> self-cycle is not a cyclic dependency\n+          }\n+          \/\/ Only add edges once, and only for mapped nodes (in _block)\n+          if (pred_pid > 0 && !set.test_set(pred_pid)) {\n+            incnt_set(pid, incnt(pid) + 1); \/\/ increment\n+            out(pred_pid).push(pid);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ Map edges for nodes not in packset\n+    for (int i = 0; i < _block.length(); i++) {\n+      Node* n = _block.at(i);\n+      int pid = get_pid_or_zero(n);\n+      if (pid == 0 || pid <= max_pid_packset) {\n+        continue; \/\/ Only scalar-nodes\n+      }\n+      for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+        Node* pred = preds.current();\n+        int pred_pid = get_pid_or_zero(pred);\n+        \/\/ Only add edges for mapped nodes (in _block)\n+        if (pred_pid > 0) {\n+          incnt_set(pid, incnt(pid) + 1); \/\/ increment\n+          out(pred_pid).push(pid);\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Schedule the graph to worklist. Returns true iff all nodes were scheduled.\n+  \/\/ This implies that we return true iff the PacksetGraph is acyclic.\n+  \/\/ We schedule with topological sort: schedule any node that has zero incnt.\n+  \/\/ Then remove that node, which decrements the incnt of all its uses (outputs).\n+  bool schedule() {\n+    GrowableArray<int> worklist;\n+    \/\/ Directly schedule all nodes without precedence\n+    for (int pid = 1; pid <= _max_pid; pid++) {\n+      if (incnt(pid) == 0) {\n+        worklist.push(pid);\n+      }\n+    }\n+    \/\/ Continue scheduling via topological sort\n+    for (int i = 0; i < worklist.length(); i++) {\n+      int pid = worklist.at(i);\n+      for (int j = 0; j < out(pid).length(); j++){\n+        int pid_use = out(pid).at(j);\n+        int incnt_use = incnt(pid_use) - 1;\n+        incnt_set(pid_use, incnt_use);\n+        \/\/ Did use lose its last input?\n+        if (incnt_use == 0) {\n+          worklist.push(pid_use);\n+        }\n+      }\n+    }\n+    \/\/ Was every pid scheduled?\n+    return worklist.length() == _max_pid;\n+  }\n+  void print(bool print_nodes, bool print_zero_incnt) {\n+    tty->print_cr(\"PacksetGraph\");\n+    for (int pid = 1; pid <= _max_pid; pid++) {\n+      if (incnt(pid) == 0 && !print_zero_incnt) {\n+        continue;\n+      }\n+      tty->print(\"Node %d. incnt %d [\", pid, incnt(pid));\n+      for (int j = 0; j < out(pid).length(); j++) {\n+        tty->print(\"%d \", out(pid).at(j));\n+      }\n+      tty->print_cr(\"]\");\n+#ifndef PRODUCT\n+      if (print_nodes) {\n+        for (int i = 0; i < _block.length(); i++) {\n+          Node* n = _block.at(i);\n+          if (get_pid_or_zero(n) == pid) {\n+            tty->print(\"    \");\n+            n->dump();\n+          }\n+        }\n+      }\n+#endif\n+    }\n+  }\n+};\n+\n+\/\/------------------------------remove_cycles---------------------------\n+\/\/ We now know that we only have independent packs, see verify_packs.\n+\/\/ This is a necessary but not a sufficient condition for an acyclic\n+\/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n+\/\/ introduced a cycle. The SuperWord paper mentions the need for this\n+\/\/ in \"3.7 Scheduling\".\n+\/\/ Approach: given all nodes from the _block, we create a new graph.\n+\/\/ The nodes that are not in a pack are their own nodes (scalar-node)\n+\/\/ in that new graph. Every pack is also a node (pack-node). We then\n+\/\/ add the edges according to DepPreds: a scalar-node has all edges\n+\/\/ to its node's DepPreds. A pack-node has all edges from every pack\n+\/\/ member to all their DepPreds.\n+void SuperWord::remove_cycles() {\n+  if (_packset.length() == 0) {\n+    return; \/\/ empty packset\n+  }\n+  ResourceMark rm;\n+\n+  PacksetGraph graph(arena(), _block, _packset, _dg);\n+\n+  graph.build();\n+\n+  if (!graph.schedule()) {\n+    if (TraceSuperWord) {\n+      tty->print_cr(\"remove_cycles found cycle in PacksetGraph:\");\n+      graph.print(true, false);\n+      tty->print_cr(\"removing all packs from packset.\");\n+    }\n+    _packset.clear();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -559,0 +559,2 @@\n+  \/\/ Remove cycles in packset.\n+  void remove_cycles();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -727,0 +727,10 @@\n+    public static final String MUL_VF = PREFIX + \"MUL_VF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VF, \"MulVF\");\n+    }\n+\n+    public static final String MUL_VD = PREFIX + \"MUL_VD\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MUL_VD, \"MulVD\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,482 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304042\n+ * @summary Test some examples with indepenednet packs with cyclic dependency\n+ *          between the packs.\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64\n+ * @requires vm.cpu.features ~= \".*avx2.*\" | vm.cpu.features ~= \".*asimd.*\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestIndependentPacksWithCyclicDependency {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10_000;\n+    static Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    int[]   goldI0 = new int[RANGE];\n+    float[] goldF0 = new float[RANGE];\n+    int[]   goldI1 = new int[RANGE];\n+    float[] goldF1 = new float[RANGE];\n+    int[]   goldI2 = new int[RANGE];\n+    float[] goldF2 = new float[RANGE];\n+    int[]   goldI3 = new int[RANGE];\n+    float[] goldF3 = new float[RANGE];\n+    int[]   goldI4 = new int[RANGE];\n+    float[] goldF4 = new float[RANGE];\n+    int[]   goldI5 = new int[RANGE];\n+    float[] goldF5 = new float[RANGE];\n+    int[]   goldI6 = new int[RANGE];\n+    float[] goldF6 = new float[RANGE];\n+    long[]  goldL6 = new long[RANGE];\n+    int[]   goldI7 = new int[RANGE];\n+    float[] goldF7 = new float[RANGE];\n+    long[]  goldL7 = new long[RANGE];\n+    int[]   goldI8 = new int[RANGE];\n+    float[] goldF8 = new float[RANGE];\n+    long[]  goldL8 = new long[RANGE];\n+    int[]   goldI9 = new int[RANGE];\n+    float[] goldF9 = new float[RANGE];\n+    long[]  goldL9 = new long[RANGE];\n+    int[]   goldI10 = new int[RANGE];\n+    float[] goldF10 = new float[RANGE];\n+    long[]  goldL10 = new long[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::test*\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::verify\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency::init\",\n+                                   \"-XX:LoopUnrollLimit=1000\");\n+    }\n+\n+    TestIndependentPacksWithCyclicDependency() {\n+        \/\/ compute the gold standard in interpreter mode\n+        init(goldI0, goldF0);\n+        test0(goldI0, goldI0, goldF0, goldF0);\n+        init(goldI1, goldF1);\n+        test1(goldI1, goldI1, goldF1, goldF1);\n+        init(goldI2, goldF2);\n+        test2(goldI2, goldI2, goldF2, goldF2);\n+        init(goldI3, goldF3);\n+        test3(goldI3, goldI3, goldF3, goldF3);\n+        init(goldI4, goldF4);\n+        test4(goldI4, goldI4, goldF4, goldF4);\n+\/\/        init(goldI5, goldF5);\n+\/\/        test5(goldI5, goldI5, goldF5, goldF5);\n+        init(goldI6, goldF6, goldL6);\n+        test6(goldI6, goldI6, goldF6, goldF6, goldL6, goldL6);\n+        init(goldI7, goldF7, goldL7);\n+        test7(goldI7, goldI7, goldF7, goldF7, goldL7, goldL7);\n+        init(goldI8, goldF8, goldL8);\n+        test8(goldI8, goldI8, goldF8, goldF8, goldL8, goldL8);\n+        init(goldI9, goldF9, goldL9);\n+        test9(goldI9, goldI9, goldF9, goldF9, goldL9, goldL9);\n+        init(goldI10, goldF10, goldL10);\n+        test10(goldI10, goldI10, goldF10, goldF10, goldL10, goldL10);\n+    }\n+\n+    @Run(test = \"test0\")\n+    @Warmup(100)\n+    public void runTest0() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test0(dataI, dataI, dataF, dataF);\n+        verify(\"test0\", dataI, goldI0);\n+        verify(\"test0\", dataF, goldF0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.MUL_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test0(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Hand-unrolled 2x. Int and Float slice are completely separate.\n+            dataIb[i+0] = dataIa[i+0] + 3;\n+            dataIb[i+1] = dataIa[i+1] + 3;\n+            dataFb[i+0] = dataFa[i+0] * 1.3f;\n+            dataFb[i+1] = dataFa[i+1] * 1.3f;\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test1(dataI, dataI, dataF, dataF);\n+        verify(\"test1\", dataI, goldI1);\n+        verify(\"test1\", dataF, goldF1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.MUL_VF, \"> 0\", IRNode.VECTOR_CAST_F2X, \"> 0\", IRNode.VECTOR_CAST_I2X, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static void test1(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Hand-unrolled 2x. Converst to and from. StoreF -> LoadF dependency.\n+            dataFa[i+0] = dataIa[i+0] + 3;\n+            dataFa[i+1] = dataIa[i+1] + 3;\n+            dataIb[i+0] = (int)(dataFb[i+0] * 1.3f);\n+            dataIb[i+1] = (int)(dataFb[i+1] * 1.3f);\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void runTest2() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test2(dataI, dataI, dataF, dataF);\n+        verify(\"test2\", dataI, goldI2);\n+        verify(\"test2\", dataF, goldF2);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.MUL_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test2(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ int and float arrays are two slices. But we pretend both are of type int.\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1);\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1);\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0);\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4);\n+        }\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(100)\n+    public void runTest3() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test3(dataI, dataI, dataF, dataF);\n+        verify(\"test3\", dataI, goldI3);\n+        verify(\"test3\", dataF, goldF3);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.MUL_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test3(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Inversion of orders. But because we operate on separate slices, this should\n+            \/\/ safely vectorize. It should detect that each line is independent, so it can\n+            \/\/ reorder them.\n+            dataIb[i+0] = dataIa[i+0] + 3;\n+            dataFb[i+1] = dataFa[i+1] * 1.3f;\n+            dataFb[i+0] = dataFa[i+0] * 1.3f;\n+            dataIb[i+1] = dataIa[i+1] + 3;\n+        }\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(100)\n+    public void runTest4() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test4(dataI, dataI, dataF, dataF);\n+        verify(\"test4\", dataI, goldI4);\n+        verify(\"test4\", dataF, goldF4);\n+    }\n+\n+    @Test\n+    static void test4(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ same as test1, except that reordering leads to different semantics\n+            \/\/ [A,B] and [X,Y] are both packs that are internally independent\n+            \/\/ But we have dependencies A -> X (StoreF -> LoadF)\n+            \/\/                      and Y -> B (StoreI -> LoadI)\n+            \/\/ Hence the two packs have a cyclic dependency, we cannot schedule\n+            \/\/ one before the other.\n+            dataFa[i+0] = dataIa[i+0] + 3;            \/\/ A\n+            dataIb[i+0] = (int)(dataFb[i+0] * 1.3f);  \/\/ X\n+            dataIb[i+1] = (int)(dataFb[i+1] * 1.3f);  \/\/ Y\n+            dataFa[i+1] = dataIa[i+1] + 3;            \/\/ B\n+        }\n+    }\n+\n+\/\/ TODO uncomment after fixing JDK-8304720\n+\/\/\n+\/\/    @Run(test = \"test5\")\n+\/\/    public void runTest5() {\n+\/\/        int[] dataI = new int[RANGE];\n+\/\/        float[] dataF = new float[RANGE];\n+\/\/        init(dataI, dataF);\n+\/\/        test5(dataI, dataI, dataF, dataF);\n+\/\/        verify(\"test5\", dataI, goldI5);\n+\/\/        verify(\"test5\", dataF, goldF5);\n+\/\/    }\n+\/\/\n+\/\/    @Test\n+\/\/    static void test5(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+\/\/        for (int i = 0; i < RANGE; i+=2) {\n+\/\/            \/\/ same as test2, except that reordering leads to different semantics\n+\/\/            \/\/ explanation analogue to test4\n+\/\/            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1); \/\/ A\n+\/\/            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0); \/\/ X\n+\/\/            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4); \/\/ Y\n+\/\/            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1); \/\/ B\n+\/\/        }\n+\/\/    }\n+\n+    @Run(test = \"test6\")\n+    public void runTest6() {\n+        int[]   dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        long[]  dataL = new long[RANGE];\n+        init(dataI, dataF, dataL);\n+        test6(dataI, dataI, dataF, dataF, dataL, dataL);\n+        verify(\"test6\", dataI, goldI6);\n+        verify(\"test6\", dataF, goldF6);\n+        verify(\"test6\", dataL, goldL6);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\", IRNode.MUL_VI, \"> 0\", IRNode.ADD_VF, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test6(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                      long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Chain of parallelizable op and conversion\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+        }\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void runTest7() {\n+        int[]   dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        long[]  dataL = new long[RANGE];\n+        init(dataI, dataF, dataL);\n+        test7(dataI, dataI, dataF, dataF, dataL, dataL);\n+        verify(\"test7\", dataI, goldI7);\n+        verify(\"test7\", dataF, goldF7);\n+        verify(\"test7\", dataL, goldL7);\n+    }\n+\n+    @Test\n+    static void test7(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                      long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Cycle involving 3 memory slices\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+        }\n+    }\n+\n+\n+    @Run(test = \"test8\")\n+    public void runTest8() {\n+        int[]   dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        long[]  dataL = new long[RANGE];\n+        init(dataI, dataF, dataL);\n+        test8(dataI, dataI, dataF, dataF, dataL, dataL);\n+        verify(\"test8\", dataI, goldI8);\n+        verify(\"test8\", dataF, goldF8);\n+        verify(\"test8\", dataL, goldL8);\n+    }\n+\n+    @Test\n+    static void test8(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                      long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ 2-cycle, with more ops after\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+            \/\/ more stuff after\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+        }\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void runTest9() {\n+        int[]   dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        long[]  dataL = new long[RANGE];\n+        init(dataI, dataF, dataL);\n+        test9(dataI, dataI, dataF, dataF, dataL, dataL);\n+        verify(\"test9\", dataI, goldI9);\n+        verify(\"test9\", dataF, goldF9);\n+        verify(\"test9\", dataL, goldL9);\n+    }\n+\n+    @Test\n+    static void test9(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                      long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ 2-cycle, with more stuff before\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            \/\/ 2-cycle\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) * 45;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+        }\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void runTest10() {\n+        int[]   dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        long[]  dataL = new long[RANGE];\n+        init(dataI, dataF, dataL);\n+        test10(dataI, dataI, dataF, dataF, dataL, dataL);\n+        verify(\"test10\", dataI, goldI10);\n+        verify(\"test10\", dataF, goldF10);\n+        verify(\"test10\", dataL, goldL10);\n+    }\n+\n+    @Test\n+    static void test10(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                      long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ This creates the following graph before SuperWord:\n+            \/\/\n+            \/\/ A -> R -> U\n+            \/\/      S -> V -> B\n+            \/\/\n+            \/\/ SuperWord analyzes the graph, and sees that [A,B] and [U,V]\n+            \/\/ are adjacent, isomorphic and independent packs. However,\n+            \/\/ [R,S] are not isomorphic (R mul, S add).\n+            \/\/ So it vectorizes [A,B] and [U,V] this gives us this graph:\n+            \/\/\n+            \/\/        -> R\n+            \/\/  [A,B]      -> [U,V] -+\n+            \/\/    ^   -> S           |\n+            \/\/    |                  |\n+            \/\/    +------------------+\n+            \/\/\n+            \/\/ The cycle thus does not only go via packs, but also scalar ops.\n+            \/\/\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3; \/\/ A\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45; \/\/ R: constant mismatch\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) + 43; \/\/ S\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f; \/\/ U\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f; \/\/ V\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ B: moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+        }\n+    }\n+\n+    static void init(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE; i++) {\n+            dataI[i] = i + 1;\n+            dataF[i] = i + 0.1f;\n+        }\n+    }\n+\n+    static void init(int[] dataI, float[] dataF, long[] dataL) {\n+        for (int i = 0; i < RANGE; i++) {\n+            dataI[i] = i + 1;\n+            dataF[i] = i + 0.1f;\n+            dataL[i] = i + 1;\n+        }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataI[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            if (datav != goldv) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + datav + \" != \" + goldv);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataL[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":482,"deletions":0,"binary":false,"changes":482,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304042\n+ * @summary Test some examples with indepenednet packs with cyclic dependency\n+ *          between the packs.\n+ *          Before fix, this hit: \"assert(!is_visited) failed: visit only once\"\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.bits == 64\n+ * @requires vm.cpu.features ~= \".*avx2.*\" | vm.cpu.features ~= \".*asimd.*\"\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:LoopUnrollLimit=250\n+ *                   -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency2::test\n+ *                   compiler.loopopts.superword.TestIndependentPacksWithCyclicDependency2\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestIndependentPacksWithCyclicDependency2 {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10_000;\n+\n+    static Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    static void init(int[] dataI, float[] dataF, long[] dataL) {\n+        for (int i = 0; i < RANGE; i++) {\n+            dataI[i] = i + 1;\n+            dataF[i] = i + 0.1f;\n+            dataL[i] = (long)(i + 1);\n+        }\n+    }\n+\n+    static void test(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb,\n+                     long[] dataLa, long[] dataLb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ For explanation, see test 10 in TestIndependentPacksWithCyclicDependency.java\n+            int v00 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0) + 3;\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, v00);\n+            int v10 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0) * 45;\n+            int v11 = unsafe.getInt(dataFb, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4) + 43;\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0, v10);\n+            unsafe.putInt(dataLa, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4, v11);\n+            float v20 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 0) + 0.55f;\n+            float v21 = unsafe.getFloat(dataLb, unsafe.ARRAY_LONG_BASE_OFFSET + 4 * i + 4) + 0.55f;\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0, v20);\n+            unsafe.putFloat(dataIb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4, v21);\n+            int v01 = unsafe.getInt(dataIa, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4) + 3; \/\/ moved down\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, v01);\n+        }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            if (datav != goldv) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + datav + \" != \" + goldv);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, long[] data, long[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] dataI = new int[RANGE];\n+        int[] goldI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        float[] goldF = new float[RANGE];\n+        long[] dataL = new long[RANGE];\n+        long[] goldL = new long[RANGE];\n+        init(goldI, goldF, goldL);\n+        test(goldI, goldI, goldF, goldF, goldL, goldL);\n+        for (int i = 0; i < ITER; i++) {\n+            init(dataI, dataF, dataL);\n+            test(dataI, dataI, dataF, dataF, dataL, dataL);\n+        }\n+        verify(\"test\", dataI, goldI);\n+        verify(\"test\", dataF, goldF);\n+        verify(\"test\", dataL, goldL);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency2.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}