{"files":[{"patch":"@@ -69,2 +69,2 @@\n-static bool current_epoch() {\n-  return _class_unload || _flushpoint;\n+static inline bool flushpoint() {\n+  return _flushpoint;\n@@ -73,1 +73,9 @@\n-static bool previous_epoch() {\n+static inline bool unloading() {\n+  return _class_unload;\n+}\n+\n+static inline bool current_epoch() {\n+  return flushpoint() || unloading();\n+}\n+\n+static inline bool previous_epoch() {\n@@ -77,2 +85,9 @@\n-static bool is_initial_typeset_for_chunk() {\n-  return _initial_type_set && !_class_unload;\n+template <typename T>\n+static inline bool used(const T* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  return current_epoch() ? USED_THIS_EPOCH(ptr) : USED_PREVIOUS_EPOCH(ptr);\n+}\n+\n+template <typename T>\n+static inline bool not_used(const T* ptr) {\n+  return !used(ptr);\n@@ -81,2 +96,5 @@\n-static bool is_complete() {\n-  return !_artifacts->has_klass_entries() && current_epoch();\n+template <typename T>\n+static void do_artifact(const T* ptr) {\n+  if (used(ptr)) {\n+    _subsystem_callback->do_artifact(ptr);\n+  }\n@@ -97,10 +115,15 @@\n-static const char* primitive_name(KlassPtr type_array_klass) {\n-  switch (type_array_klass->name()->base()[1]) {\n-    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n-    case JVM_SIGNATURE_BYTE: return \"byte\";\n-    case JVM_SIGNATURE_CHAR: return \"char\";\n-    case JVM_SIGNATURE_SHORT: return \"short\";\n-    case JVM_SIGNATURE_INT: return \"int\";\n-    case JVM_SIGNATURE_LONG: return \"long\";\n-    case JVM_SIGNATURE_FLOAT: return \"float\";\n-    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+template <typename T>\n+static traceid artifact_id(const T* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  return JfrTraceId::load_raw(ptr);\n+}\n+\n+template <typename T>\n+static traceid artifact_tag(const T* ptr, bool leakp) {\n+  assert(ptr != nullptr, \"invariant\");\n+  if (leakp) {\n+    if (IS_NOT_LEAKP(ptr)) {\n+      SET_LEAKP(ptr);\n+    }\n+    assert(IS_LEAKP(ptr), \"invariant\");\n+    return artifact_id(ptr);\n@@ -108,2 +131,5 @@\n-  assert(false, \"invalid type array klass\");\n-  return nullptr;\n+  if (not_used(ptr)) {\n+    SET_TRANSIENT(ptr);\n+  }\n+  assert(used(ptr), \"invariant\");\n+  return artifact_id(ptr);\n@@ -112,6 +138,7 @@\n-static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n-  if (type_array_klass == nullptr) {\n-    \/\/ void.class\n-    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n-    assert(void_class_name != nullptr, \"invariant\");\n-    return void_class_name;\n+static inline bool should_do_cld_klass(const Klass* klass, bool leakp) {\n+  return klass != nullptr && _artifacts->should_do_cld_klass(klass, leakp);\n+}\n+\n+static inline KlassPtr get_cld_klass(CldPtr cld, bool leakp) {\n+  if (cld == nullptr) {\n+    return nullptr;\n@@ -119,5 +146,7 @@\n-  const char* const primitive_type_str = primitive_name(type_array_klass);\n-  assert(primitive_type_str != nullptr, \"invariant\");\n-  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n-  assert(primitive_type_sym != nullptr, \"invariant\");\n-  return primitive_type_sym;\n+  assert(leakp ? IS_LEAKP(cld) : used(cld), \"invariant\");\n+  KlassPtr cld_klass = cld->class_loader_klass();\n+  if (should_do_cld_klass(cld_klass, leakp)) {\n+    artifact_tag(cld_klass, leakp);\n+    return cld_klass;\n+  }\n+  return nullptr;\n@@ -126,4 +155,2 @@\n-template <typename T>\n-static traceid artifact_id(const T* ptr) {\n-  assert(ptr != nullptr, \"invariant\");\n-  return JfrTraceId::load_raw(ptr);\n+static inline CldPtr get_cld(ModPtr mod) {\n+  return mod != nullptr ? mod->loader_data() : nullptr;\n@@ -132,1 +159,1 @@\n-static traceid package_id(KlassPtr klass, bool leakp) {\n+static ClassLoaderData* get_cld(const Klass* klass) {\n@@ -134,6 +161,2 @@\n-  PkgPtr pkg_entry = klass->package();\n-  if (pkg_entry == nullptr) {\n-    return 0;\n-  }\n-  if (leakp) {\n-    SET_LEAKP(pkg_entry);\n+  if (klass->is_objArray_klass()) {\n+    klass = ObjArrayKlass::cast(klass)->bottom_klass();\n@@ -141,2 +164,19 @@\n-  \/\/ package implicitly tagged already\n-  return artifact_id(pkg_entry);\n+  return klass->is_non_strong_hidden() ? nullptr : klass->class_loader_data();\n+}\n+\n+static inline ModPtr get_module(PkgPtr pkg) {\n+  return pkg != nullptr ? pkg->module() : nullptr;\n+}\n+\n+static inline PkgPtr get_package(KlassPtr klass) {\n+  return klass != nullptr ? klass->package() : nullptr;\n+}\n+\n+static inline KlassPtr get_module_cld_klass(KlassPtr klass, bool leakp) {\n+  assert(klass != nullptr, \"invariant\");\n+  return get_cld_klass(get_cld(get_module(get_package(klass))), leakp);\n+}\n+\n+static traceid cld_id(CldPtr cld, bool leakp) {\n+  assert(cld != nullptr, \"invariant\");\n+  return artifact_tag(cld, leakp);\n@@ -147,2 +187,2 @@\n-  ModPtr module_entry = pkg->module();\n-  if (module_entry == nullptr) {\n+  ModPtr mod = get_module(pkg);\n+  if (mod == nullptr) {\n@@ -151,4 +191,12 @@\n-  if (leakp) {\n-    SET_LEAKP(module_entry);\n-  } else {\n-    SET_TRANSIENT(module_entry);\n+  CldPtr cld = get_cld(mod);\n+  if (cld != nullptr) {\n+    cld_id(cld, leakp);\n+  }\n+  return artifact_tag(mod, leakp);\n+}\n+\n+static traceid package_id(KlassPtr klass, bool leakp) {\n+  assert(klass != nullptr, \"invariant\");\n+  PkgPtr pkg = get_package(klass);\n+  if (pkg == nullptr) {\n+    return 0;\n@@ -156,1 +204,3 @@\n-  return artifact_id(module_entry);\n+  \/\/ Ensure module and its CLD gets tagged.\n+  module_id(pkg, leakp);\n+  return artifact_tag(pkg, leakp);\n@@ -165,10 +215,0 @@\n-static traceid cld_id(CldPtr cld, bool leakp) {\n-  assert(cld != nullptr, \"invariant\");\n-  if (leakp) {\n-    SET_LEAKP(cld);\n-  } else {\n-    SET_TRANSIENT(cld);\n-  }\n-  return artifact_id(cld);\n-}\n-\n@@ -186,4 +226,6 @@\n-static ClassLoaderData* get_cld(const Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  if (klass->is_objArray_klass()) {\n-    klass = ObjArrayKlass::cast(klass)->bottom_klass();\n+class PackageFieldSelector {\n+ public:\n+  typedef PkgPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return klass->package();\n@@ -191,3 +233,63 @@\n-  if (klass->is_non_strong_hidden()) return nullptr;\n-  return klass->class_loader_data();\n-}\n+};\n+\n+class ModuleFieldSelector {\n+ public:\n+  typedef ModPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    PkgPtr pkg = klass->package();\n+    return pkg != nullptr ? pkg->module() : nullptr;\n+  }\n+};\n+\n+class KlassCldFieldSelector {\n+ public:\n+  typedef CldPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return get_cld(klass);\n+  }\n+};\n+\n+class ModuleCldFieldSelector {\n+ public:\n+  typedef CldPtr TypePtr;\n+  static TypePtr select(KlassPtr klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    ModPtr mod = ModuleFieldSelector::select(klass);\n+    return mod != nullptr ? mod->loader_data() : nullptr;\n+  }\n+};\n+\n+template <typename T>\n+class SerializePredicate {\n+  bool _class_unload;\n+ public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(T const& value) {\n+    assert(value != nullptr, \"invariant\");\n+    return _class_unload ? _artifacts->should_do_unloading_artifact(value) : IS_NOT_SERIALIZED(value);\n+  }\n+};\n+\n+template <>\n+class SerializePredicate<const Klass*> {\n+  bool _class_unload;\n+public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(const Klass* klass) {\n+    assert(klass != nullptr, \"invariant\");\n+    return _class_unload ? true : IS_NOT_SERIALIZED(klass);\n+  }\n+};\n+\n+template <>\n+class SerializePredicate<const Method*> {\n+  bool _class_unload;\n+public:\n+  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n+  bool operator()(const Method* method) {\n+    assert(method != nullptr, \"invariant\");\n+    return _class_unload ? true : METHOD_IS_NOT_SERIALIZED(method);\n+  }\n+};\n@@ -198,2 +300,0 @@\n-  SET_SERIALIZED(ptr);\n-  assert(IS_SERIALIZED(ptr), \"invariant\");\n@@ -203,0 +303,3 @@\n+  assert(unloading() ? true : IS_NOT_SERIALIZED(ptr), \"invariant\");\n+  SET_SERIALIZED(ptr);\n+  assert(IS_SERIALIZED(ptr), \"invariant\");\n@@ -206,3 +309,19 @@\n- * In C++03, functions used as template parameters must have external linkage;\n- * this restriction was removed in C++11. Change back to \"static\" and\n- * rename functions when C++11 becomes available.\n+ ***********************    Klasses    *************************\n+ *\n+ * When we process a Klass, we need to process its transitive closure.\n+ *\n+ * This includes two branches:\n+ *\n+ * [1] Klass -> CLD -> class_loader_Klass\n+ * [2] Klass -> PackageEntry -> ModuleEntry -> CLD -> class_loader_Klass\n+ *\n+ *    A Klass viewed as this closure becomes a node in a binary tree:\n+ *\n+ *                           Klass\n+ *                             O\n+ *                            \/ \\\n+ *                           \/   \\\n+ *                      [1] O     O [2]\n+ *\n+ * We write the Klass and tag the artifacts in its closure (subtree)\n+ * using preorder traversal by recursing the class_loader_Klass(es).\n@@ -210,1 +329,0 @@\n- * The weird naming is an effort to decrease the risk of name clashes.\n@@ -213,1 +331,1 @@\n-static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {\n+static void do_write_klass(JfrCheckpointWriter* writer, CldPtr cld, KlassPtr klass, bool leakp) {\n@@ -218,1 +336,0 @@\n-  ClassLoaderData* cld = get_cld(klass);\n@@ -224,1 +341,22 @@\n-  return 1;\n+  if (!leakp) {\n+    set_serialized(klass);\n+  }\n+}\n+\n+static void write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp, int& elements) {\n+  assert(elements >= 0, \"invariant\");\n+  ClassLoaderData* cld = get_cld(klass);\n+  do_write_klass(writer, cld, klass, leakp);\n+  ++elements;\n+  if (cld != nullptr) {\n+    \/\/ Write the klass for the direct cld.\n+    KlassPtr cld_klass = get_cld_klass(cld, leakp);\n+    if (cld_klass != nullptr) {\n+      write_klass(writer, cld_klass, leakp, elements);\n+    }\n+  }\n+  KlassPtr mod_klass = get_module_cld_klass(klass, leakp);\n+  if (mod_klass != nullptr) {\n+    \/\/ Write the klass for the module cld.\n+    write_klass(writer, mod_klass, leakp, elements);\n+  }\n@@ -227,0 +365,7 @@\n+\/*\n+ * In C++03, functions used as template parameters must have external linkage;\n+ * this restriction was removed in C++11. Change back to \"static\" and\n+ * rename functions when C++11 becomes available.\n+ *\n+ * The weird naming is an effort to decrease the risk of name clashes.\n+ *\/\n@@ -229,3 +374,4 @@\n-  KlassPtr klass = (KlassPtr)k;\n-  set_serialized(klass);\n-  return write_klass(writer, klass, false);\n+  KlassPtr klass = static_cast<KlassPtr>(k);\n+  int elements = 0;\n+  write_klass(writer, klass, false, elements);\n+  return elements;\n@@ -236,1 +382,1 @@\n-  KlassPtr klass = (KlassPtr)k;\n+  KlassPtr klass = static_cast<KlassPtr>(k);\n@@ -238,1 +384,3 @@\n-  return write_klass(writer, klass, true);\n+  int elements = 0;\n+  write_klass(writer, klass, true, elements);\n+  return elements;\n@@ -241,4 +389,1 @@\n-static bool is_implied(const Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  return klass->is_subclass_of(vmClasses::ClassLoader_klass()) || klass == vmClasses::Object_klass();\n-}\n+static int primitives_count = 9;\n@@ -246,5 +391,13 @@\n-static void do_klass(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  assert(_flushpoint ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass), \"invariant\");\n-  assert(_subsystem_callback != nullptr, \"invariant\");\n-  _subsystem_callback->do_artifact(klass);\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return nullptr;\n@@ -253,0 +406,14 @@\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == nullptr) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != nullptr, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != nullptr, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str,\n+                                                        (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != nullptr, \"invariant\");\n+  return primitive_type_sym;\n+}\n@@ -274,42 +441,2 @@\n-static void do_loader_klass(const Klass* klass) {\n-  if (klass != nullptr && _artifacts->should_do_loader_klass(klass)) {\n-    if (_leakp_writer != nullptr) {\n-      SET_LEAKP(klass);\n-    }\n-    SET_TRANSIENT(klass);\n-    _subsystem_callback->do_artifact(klass);\n-  }\n-}\n-\n-static bool register_klass_unload(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  return JfrKlassUnloading::on_unload(klass);\n-}\n-\n-static void do_unloading_klass(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  assert(_subsystem_callback != nullptr, \"invariant\");\n-  if (register_klass_unload(klass)) {\n-    _subsystem_callback->do_artifact(klass);\n-    do_loader_klass(klass->class_loader_data()->class_loader_klass());\n-  }\n-}\n-\n-\/*\n- * Abstract klasses are filtered out unconditionally.\n- * If a klass is not yet initialized, i.e yet to run its <clinit>\n- * it is also filtered out so we don't accidentally\n- * trigger initialization.\n- *\/\n-static bool is_classloader_klass_allowed(const Klass* k) {\n-  assert(k != nullptr, \"invariant\");\n-  return !(k->is_abstract() || k->should_be_initialized());\n-}\n-\n-static void do_classloaders() {\n-  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n-    Klass* subk = iter.klass();\n-    if (is_classloader_klass_allowed(subk)) {\n-      do_loader_klass(subk);\n-    }\n-  }\n+static bool is_initial_typeset_for_chunk() {\n+  return _initial_type_set && !unloading();\n@@ -318,2 +445,0 @@\n-static int primitives_count = 9;\n-\n@@ -326,17 +451,10 @@\n-  \/\/ Only write the primitive classes once per chunk.\n-  if (is_initial_typeset_for_chunk()) {\n-    write_primitive(_writer, Universe::boolArrayKlassObj());\n-    write_primitive(_writer, Universe::byteArrayKlassObj());\n-    write_primitive(_writer, Universe::charArrayKlassObj());\n-    write_primitive(_writer, Universe::shortArrayKlassObj());\n-    write_primitive(_writer, Universe::intArrayKlassObj());\n-    write_primitive(_writer, Universe::longArrayKlassObj());\n-    write_primitive(_writer, Universe::floatArrayKlassObj());\n-    write_primitive(_writer, Universe::doubleArrayKlassObj());\n-    write_primitive(_writer, nullptr); \/\/ void.class\n-  }\n-}\n-\n-static void do_object() {\n-  SET_TRANSIENT(vmClasses::Object_klass());\n-  do_klass(vmClasses::Object_klass());\n+  assert(is_initial_typeset_for_chunk(), \"invariant\");\n+  write_primitive(_writer, Universe::boolArrayKlassObj());\n+  write_primitive(_writer, Universe::byteArrayKlassObj());\n+  write_primitive(_writer, Universe::charArrayKlassObj());\n+  write_primitive(_writer, Universe::shortArrayKlassObj());\n+  write_primitive(_writer, Universe::intArrayKlassObj());\n+  write_primitive(_writer, Universe::longArrayKlassObj());\n+  write_primitive(_writer, Universe::floatArrayKlassObj());\n+  write_primitive(_writer, Universe::doubleArrayKlassObj());\n+  write_primitive(_writer, nullptr); \/\/ void.class\n@@ -345,29 +463,5 @@\n-static void do_klasses() {\n-  if (_class_unload) {\n-    ClassLoaderDataGraph::classes_unloading_do(&do_unloading_klass);\n-    return;\n-  }\n-  JfrTraceIdLoadBarrier::do_klasses(&do_klass, previous_epoch());\n-  do_classloaders();\n-  do_primitives();\n-  do_object();\n-}\n-\n-template <typename T>\n-static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {\n-  assert(callback != nullptr, \"invariant\");\n-  assert(value != nullptr, \"invariant\");\n-  if (USED_PREVIOUS_EPOCH(value)) {\n-    callback->do_artifact(value);\n-  }\n-  if (IS_SERIALIZED(value)) {\n-    CLEAR_SERIALIZED(value);\n-  }\n-  assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-}\n-\n-static void do_previous_epoch_klass(JfrArtifactClosure* callback, const Klass* value) {\n-  assert(callback != nullptr, \"invariant\");\n-  assert(value != nullptr, \"invariant\");\n-  if (USED_PREVIOUS_EPOCH(value)) {\n-    callback->do_artifact(value);\n+static void do_unloading_klass(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(_subsystem_callback != nullptr, \"invariant\");\n+  if (JfrKlassUnloading::on_unload(klass)) {\n+    _subsystem_callback->do_artifact(klass);\n@@ -377,1 +471,1 @@\n-static void do_klass_on_clear(Klass* klass) {\n+static void do_klass(Klass* klass) {\n@@ -379,0 +473,1 @@\n+  assert(used(klass), \"invariant\");\n@@ -380,1 +475,1 @@\n-  do_previous_epoch_klass(_subsystem_callback, klass);\n+  _subsystem_callback->do_artifact(klass);\n@@ -383,7 +478,4 @@\n-static void do_loader_klass_on_clear(const Klass* klass) {\n-  if (klass != nullptr && _artifacts->should_do_loader_klass(klass)) {\n-    if (_leakp_writer != nullptr) {\n-      SET_LEAKP(klass);\n-    }\n-    SET_TRANSIENT(klass);\n-    do_previous_epoch_klass(_subsystem_callback, klass);\n+static void do_klasses() {\n+  if (unloading()) {\n+    ClassLoaderDataGraph::classes_unloading_do(&do_unloading_klass);\n+    return;\n@@ -391,8 +483,3 @@\n-}\n-\n-static void do_classloaders_on_clear() {\n-  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n-    Klass* subk = iter.klass();\n-    if (is_classloader_klass_allowed(subk)) {\n-      do_loader_klass_on_clear(subk);\n-    }\n+  if (is_initial_typeset_for_chunk()) {\n+    \/\/ Only write the primitive classes once per chunk.\n+    do_primitives();\n@@ -400,0 +487,1 @@\n+  JfrTraceIdLoadBarrier::do_klasses(&do_klass, previous_epoch());\n@@ -402,3 +490,2 @@\n-static void do_object_on_clear() {\n-  SET_TRANSIENT(vmClasses::Object_klass());\n-  do_klass_on_clear(vmClasses::Object_klass());\n+static void do_klass_on_clear(Klass* klass) {\n+  do_artifact(klass);\n@@ -409,2 +496,0 @@\n-  do_classloaders_on_clear();\n-  do_object_on_clear();\n@@ -413,0 +498,1 @@\n+\/\/ KlassWriter.\n@@ -416,0 +502,2 @@\n+\n+\/\/ Klass registration.\n@@ -425,1 +513,1 @@\n-    return IS_LEAKP(klass) || is_implied(klass);\n+    return IS_LEAKP(klass);\n@@ -429,0 +517,1 @@\n+\/\/ KlassWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -433,0 +522,1 @@\n+\/\/ Composite KlassWriter with registration.\n@@ -437,1 +527,1 @@\n-static bool write_klasses() {\n+static void write_klasses() {\n@@ -441,1 +531,1 @@\n-  KlassWriter kw(_writer, _class_unload);\n+  KlassWriter kw(_writer, unloading());\n@@ -447,1 +537,1 @@\n-    LeakKlassWriter lkw(_leakp_writer, _class_unload);\n+    LeakKlassWriter lkw(_leakp_writer, unloading());\n@@ -458,3 +548,0 @@\n-  if (is_complete()) {\n-    return false;\n-  }\n@@ -462,1 +549,0 @@\n-  return true;\n@@ -465,1 +551,1 @@\n-static bool write_klasses_on_clear() {\n+static void write_klasses_on_clear() {\n@@ -470,1 +556,1 @@\n-  KlassWriter kw(_writer, _class_unload);\n+  KlassWriter kw(_writer, unloading());\n@@ -472,1 +558,1 @@\n-  LeakKlassWriter lkw(_leakp_writer, _class_unload);\n+  LeakKlassWriter lkw(_leakp_writer, unloading());\n@@ -477,3 +563,0 @@\n-  if (is_complete()) {\n-    return false;\n-  }\n@@ -481,1 +564,0 @@\n-  return true;\n@@ -484,0 +566,2 @@\n+\/***** Packages *****\/\n+\n@@ -497,1 +581,1 @@\n-  PkgPtr pkg = (PkgPtr)p;\n+  PkgPtr pkg = static_cast<PkgPtr>(p);\n@@ -504,1 +588,1 @@\n-  PkgPtr pkg = (PkgPtr)p;\n+  PkgPtr pkg = static_cast<PkgPtr>(p);\n@@ -509,17 +593,1 @@\n-static void do_package(PackageEntry* entry) {\n-  do_previous_epoch_artifact(_subsystem_callback, entry);\n-}\n-\n-static void do_packages() {\n-  ClassLoaderDataGraph::packages_do(&do_package);\n-}\n-\n-class PackageFieldSelector {\n- public:\n-  typedef PkgPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    return klass->package();\n-  }\n-};\n-\n+\/\/ PackageWriter.\n@@ -529,1 +597,3 @@\n-typedef CompositeFunctor<PkgPtr, PackageWriter, ClearArtifact<PkgPtr> > PackageWriterWithClear;\n+typedef JfrArtifactCallbackHost<PkgPtr, PackageWriter> PackageCallback;\n+\n+\/\/ PackageWriter used during unloading.\n@@ -531,1 +601,0 @@\n-typedef JfrArtifactCallbackHost<PkgPtr, PackageWriterWithClear> PackageCallback;\n@@ -533,0 +602,5 @@\n+\/\/ PackageWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<PkgPtr, PackageWriter, ClearArtifact<PkgPtr> > PackageWriterWithClear;\n+typedef JfrArtifactCallbackHost<PkgPtr, PackageWriterWithClear> PackageClearCallback;\n+\n+\/\/ PackageWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -537,0 +611,1 @@\n+\/\/ Composite PackageWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n@@ -538,2 +613,0 @@\n-typedef KlassToFieldEnvelope<PackageFieldSelector, CompositePackageWriter> KlassCompositePackageWriter;\n-typedef KlassToFieldEnvelope<PackageFieldSelector, PackageWriterWithClear> KlassPackageWriterWithClear;\n@@ -541,1 +614,32 @@\n-typedef JfrArtifactCallbackHost<PkgPtr, CompositePackageWriterWithClear> CompositePackageCallback;\n+typedef JfrArtifactCallbackHost<PkgPtr, CompositePackageWriterWithClear> CompositePackageClearCallback;\n+\n+static void do_package(PackageEntry* pkg) {\n+  do_artifact(pkg);\n+}\n+\n+static void do_all_packages() {\n+  ClassLoaderDataGraph::packages_do(&do_package);\n+}\n+\n+static void do_all_packages(PackageWriter& pw) {\n+  do_all_packages();\n+  _artifacts->tally(pw);\n+}\n+\n+static void do_unloading_packages(PackageWriter& pw) {\n+  KlassPackageWriter kpw(&pw);\n+  _artifacts->iterate_klasses(kpw);\n+  _artifacts->tally(pw);\n+}\n+\n+static void write_packages_with_leakp(PackageWriter& pw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakPackageWriter lpw(_leakp_writer, unloading());\n+  CompositePackageWriter cpw(&lpw, &pw);\n+  ClearArtifact<PkgPtr> clear;\n+  CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n+  CompositePackageClearCallback callback(&_subsystem_callback, &cpwwc);\n+  do_all_packages(pw);\n+}\n@@ -545,5 +649,8 @@\n-  PackageWriter pw(_writer, _class_unload);\n-  KlassPackageWriter kpw(&pw);\n-  if (current_epoch()) {\n-    _artifacts->iterate_klasses(kpw);\n-    _artifacts->tally(pw);\n+  PackageWriter pw(_writer, unloading());\n+  if (unloading()) {\n+    do_unloading_packages(pw);\n+    return;\n+  }\n+  if (flushpoint()) {\n+    PackageCallback callback(&_subsystem_callback, &pw);\n+    do_all_packages(pw);\n@@ -554,1 +661,0 @@\n-    _artifacts->iterate_klasses(kpw);\n@@ -557,11 +663,3 @@\n-    PackageCallback callback(&_subsystem_callback, &pwwc);\n-    do_packages();\n-  } else {\n-    LeakPackageWriter lpw(_leakp_writer, _class_unload);\n-    CompositePackageWriter cpw(&lpw, &pw);\n-    KlassCompositePackageWriter kcpw(&cpw);\n-    _artifacts->iterate_klasses(kcpw);\n-    ClearArtifact<PkgPtr> clear;\n-    CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n-    CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n-    do_packages();\n+    PackageClearCallback callback(&_subsystem_callback, &pwwc);\n+    do_all_packages(pw);\n+    return;\n@@ -569,1 +667,1 @@\n-  _artifacts->tally(pw);\n+  write_packages_with_leakp(pw);\n@@ -576,11 +674,2 @@\n-  PackageWriter pw(_writer, _class_unload);\n-  KlassPackageWriter kpw(&pw);\n-  LeakPackageWriter lpw(_leakp_writer, _class_unload);\n-  CompositePackageWriter cpw(&lpw, &pw);\n-  KlassCompositePackageWriter kcpw(&cpw);\n-  _artifacts->iterate_klasses(kcpw);\n-  ClearArtifact<PkgPtr> clear;\n-  CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n-  CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n-  do_packages();\n-  _artifacts->tally(pw);\n+  PackageWriter pw(_writer, unloading());\n+  write_packages_with_leakp(pw);\n@@ -589,0 +678,2 @@\n+\/***** Modules *****\/\n+\n@@ -602,1 +693,1 @@\n-  ModPtr mod = (ModPtr)m;\n+  ModPtr mod = static_cast<ModPtr>(m);\n@@ -609,1 +700,1 @@\n-  ModPtr mod = (ModPtr)m;\n+  ModPtr mod = static_cast<ModPtr>(m);\n@@ -614,18 +705,1 @@\n-static void do_module(ModuleEntry* entry) {\n-  do_previous_epoch_artifact(_subsystem_callback, entry);\n-}\n-\n-static void do_modules() {\n-  ClassLoaderDataGraph::modules_do(&do_module);\n-}\n-\n-class ModuleFieldSelector {\n- public:\n-  typedef ModPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    PkgPtr pkg = klass->package();\n-    return pkg != nullptr ? pkg->module() : nullptr;\n-  }\n-};\n-\n+\/\/ ModuleWriter.\n@@ -635,2 +709,3 @@\n-typedef CompositeFunctor<ModPtr, ModuleWriter, ClearArtifact<ModPtr> > ModuleWriterWithClear;\n-typedef JfrArtifactCallbackHost<ModPtr, ModuleWriterWithClear> ModuleCallback;\n+typedef JfrArtifactCallbackHost<ModPtr, ModuleWriter> ModuleCallback;\n+\n+\/\/ ModuleWriter used during unloading.\n@@ -639,0 +714,5 @@\n+\/\/ ModuleWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<ModPtr, ModuleWriter, ClearArtifact<ModPtr> > ModuleWriterWithClear;\n+typedef JfrArtifactCallbackHost<ModPtr, ModuleWriterWithClear> ModuleClearCallback;\n+\n+\/\/ ModuleWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n@@ -643,0 +723,1 @@\n+\/\/ Composite ModuleWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n@@ -644,1 +725,0 @@\n-typedef KlassToFieldEnvelope<ModuleFieldSelector, CompositeModuleWriter> KlassCompositeModuleWriter;\n@@ -646,1 +726,33 @@\n-typedef JfrArtifactCallbackHost<ModPtr, CompositeModuleWriterWithClear> CompositeModuleCallback;\n+typedef JfrArtifactCallbackHost<ModPtr, CompositeModuleWriterWithClear> CompositeModuleClearCallback;\n+\n+static void do_module(ModuleEntry* mod) {\n+  do_artifact(mod);\n+}\n+\n+static void do_all_modules() {\n+  ClassLoaderDataGraph::modules_do(&do_module);\n+}\n+\n+static void do_all_modules(ModuleWriter& mw) {\n+  do_all_modules();\n+  _artifacts->tally(mw);\n+}\n+\n+static void do_unloading_modules(ModuleWriter& mw) {\n+  assert(unloading(), \"invariant\");\n+  KlassModuleWriter kmw(&mw);\n+  _artifacts->iterate_klasses(kmw);\n+  _artifacts->tally(mw);\n+}\n+\n+static void write_modules_with_leakp(ModuleWriter& mw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakModuleWriter lmw(_leakp_writer, unloading());\n+  CompositeModuleWriter cmw(&lmw, &mw);\n+  ClearArtifact<ModPtr> clear;\n+  CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n+  CompositeModuleClearCallback callback(&_subsystem_callback, &cmwwc);\n+  do_all_modules(mw);\n+}\n@@ -650,5 +762,8 @@\n-  ModuleWriter mw(_writer, _class_unload);\n-  KlassModuleWriter kmw(&mw);\n-  if (current_epoch()) {\n-    _artifacts->iterate_klasses(kmw);\n-    _artifacts->tally(mw);\n+  ModuleWriter mw(_writer, unloading());\n+  if (unloading()) {\n+    do_unloading_modules(mw);\n+    return;\n+  }\n+  if (flushpoint()) {\n+    ModuleCallback callback(&_subsystem_callback, &mw);\n+    do_all_modules(mw);\n@@ -659,1 +774,0 @@\n-    _artifacts->iterate_klasses(kmw);\n@@ -662,11 +776,3 @@\n-    ModuleCallback callback(&_subsystem_callback, &mwwc);\n-    do_modules();\n-  } else {\n-    LeakModuleWriter lmw(_leakp_writer, _class_unload);\n-    CompositeModuleWriter cmw(&lmw, &mw);\n-    KlassCompositeModuleWriter kcpw(&cmw);\n-    _artifacts->iterate_klasses(kcpw);\n-    ClearArtifact<ModPtr> clear;\n-    CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n-    CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n-    do_modules();\n+    ModuleClearCallback callback(&_subsystem_callback, &mwwc);\n+    do_all_modules(mw);\n+    return;\n@@ -674,1 +780,1 @@\n-  _artifacts->tally(mw);\n+  write_modules_with_leakp(mw);\n@@ -681,11 +787,2 @@\n-  ModuleWriter mw(_writer, _class_unload);\n-  KlassModuleWriter kmw(&mw);\n-  LeakModuleWriter lmw(_leakp_writer, _class_unload);\n-  CompositeModuleWriter cmw(&lmw, &mw);\n-  KlassCompositeModuleWriter kcpw(&cmw);\n-  _artifacts->iterate_klasses(kcpw);\n-  ClearArtifact<ModPtr> clear;\n-  CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n-  CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n-  do_modules();\n-  _artifacts->tally(mw);\n+  ModuleWriter mw(_writer, unloading());\n+  write_modules_with_leakp(mw);\n@@ -694,1 +791,3 @@\n-static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {\n+\/***** ClassLoaderData - CLD *****\/\n+\n+static int write_cld(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {\n@@ -704,1 +803,1 @@\n-    assert(_class_unload ? true : IS_SERIALIZED(class_loader_klass), \"invariant\");\n+    assert(IS_SERIALIZED(class_loader_klass), \"invariant\");\n@@ -712,1 +811,1 @@\n-int write__classloader(JfrCheckpointWriter* writer, const void* c) {\n+int write__cld(JfrCheckpointWriter* writer, const void* c) {\n@@ -714,1 +813,1 @@\n-  CldPtr cld = (CldPtr)c;\n+  CldPtr cld = static_cast<CldPtr>(c);\n@@ -716,1 +815,1 @@\n-  return write_classloader(writer, cld, false);\n+  return write_cld(writer, cld, false);\n@@ -719,1 +818,1 @@\n-int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {\n+int write__cld__leakp(JfrCheckpointWriter* writer, const void* c) {\n@@ -721,1 +820,1 @@\n-  CldPtr cld = (CldPtr)c;\n+  CldPtr cld = static_cast<CldPtr>(c);\n@@ -723,1 +822,1 @@\n-  return write_classloader(writer, cld, true);\n+  return write_cld(writer, cld, true);\n@@ -726,3 +825,5 @@\n-static void do_class_loader_data(ClassLoaderData* cld) {\n-  do_previous_epoch_artifact(_subsystem_callback, cld);\n-}\n+\/\/ CldWriter.\n+typedef SerializePredicate<CldPtr> CldPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<CldPtr, CldPredicate, write__cld> CldWriterImpl;\n+typedef JfrTypeWriterHost<CldWriterImpl, TYPE_CLASSLOADER> CldWriter;\n+typedef JfrArtifactCallbackHost<CldPtr, CldWriter> CldCallback;\n@@ -730,8 +831,4 @@\n-class KlassCldFieldSelector {\n- public:\n-  typedef CldPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    return get_cld(klass);\n-  }\n-};\n+\/\/ CldWriter used during unloading.\n+typedef KlassToFieldEnvelope<KlassCldFieldSelector, CldWriter> KlassCldWriter;\n+typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CldWriter> ModuleCldWriter;\n+typedef CompositeFunctor<KlassPtr, KlassCldWriter, ModuleCldWriter> KlassAndModuleCldWriter;\n@@ -739,9 +836,13 @@\n-class ModuleCldFieldSelector {\n-public:\n-  typedef CldPtr TypePtr;\n-  static TypePtr select(KlassPtr klass) {\n-    assert(klass != nullptr, \"invariant\");\n-    ModPtr mod = ModuleFieldSelector::select(klass);\n-    return mod != nullptr ? mod->loader_data() : nullptr;\n-  }\n-};\n+\/\/ CldWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<CldPtr, CldWriter, ClearArtifact<CldPtr> > CldWriterWithClear;\n+typedef JfrArtifactCallbackHost<CldPtr, CldWriterWithClear> CldClearCallback;\n+\n+\/\/ CldWriter for leakp. Only used during start or rotation, i.e. the previous epoch.\n+typedef LeakPredicate<CldPtr> LeakCldPredicate;\n+typedef JfrPredicatedTypeWriterImplHost<CldPtr, LeakCldPredicate, write__cld__leakp> LeakCldWriterImpl;\n+typedef JfrTypeWriterHost<LeakCldWriterImpl, TYPE_CLASSLOADER> LeakCldWriter;\n+\n+\/\/ Composite CldWriter with clear. Only used during start or rotation, i.e. the previous epoch.\n+typedef CompositeFunctor<CldPtr, LeakCldWriter, CldWriter> CompositeCldWriter;\n+typedef CompositeFunctor<CldPtr, CompositeCldWriter, ClearArtifact<CldPtr> > CompositeCldWriterWithClear;\n+typedef JfrArtifactCallbackHost<CldPtr, CompositeCldWriterWithClear> CompositeCldClearCallback;\n@@ -751,1 +852,0 @@\n-  CLDCallback() {}\n@@ -754,2 +854,2 @@\n-    if (cld->has_class_mirror_holder()) {\n-      return;\n+    if (!cld->has_class_mirror_holder()) {\n+      do_artifact(cld);\n@@ -757,1 +857,0 @@\n-    do_class_loader_data(cld);\n@@ -761,1 +860,1 @@\n-static void do_class_loaders() {\n+static void do_all_clds() {\n@@ -766,19 +865,4 @@\n-typedef SerializePredicate<CldPtr> CldPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CldPtr, CldPredicate, write__classloader> CldWriterImpl;\n-typedef JfrTypeWriterHost<CldWriterImpl, TYPE_CLASSLOADER> CldWriter;\n-typedef CompositeFunctor<CldPtr, CldWriter, ClearArtifact<CldPtr> > CldWriterWithClear;\n-typedef JfrArtifactCallbackHost<CldPtr, CldWriterWithClear> CldCallback;\n-typedef KlassToFieldEnvelope<KlassCldFieldSelector, CldWriter> KlassCldWriter;\n-typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CldWriter> ModuleCldWriter;\n-typedef CompositeFunctor<KlassPtr, KlassCldWriter, ModuleCldWriter> KlassAndModuleCldWriter;\n-\n-typedef LeakPredicate<CldPtr> LeakCldPredicate;\n-typedef JfrPredicatedTypeWriterImplHost<CldPtr, LeakCldPredicate, write__classloader__leakp> LeakCldWriterImpl;\n-typedef JfrTypeWriterHost<LeakCldWriterImpl, TYPE_CLASSLOADER> LeakCldWriter;\n-\n-typedef CompositeFunctor<CldPtr, LeakCldWriter, CldWriter> CompositeCldWriter;\n-typedef KlassToFieldEnvelope<KlassCldFieldSelector, CompositeCldWriter> KlassCompositeCldWriter;\n-typedef KlassToFieldEnvelope<ModuleCldFieldSelector, CompositeCldWriter> ModuleCompositeCldWriter;\n-typedef CompositeFunctor<KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter> KlassAndModuleCompositeCldWriter;\n-typedef CompositeFunctor<CldPtr, CompositeCldWriter, ClearArtifact<CldPtr> > CompositeCldWriterWithClear;\n-typedef JfrArtifactCallbackHost<CldPtr, CompositeCldWriterWithClear> CompositeCldCallback;\n+static void do_all_clds(CldWriter& cldw) {\n+  do_all_clds();\n+  _artifacts->tally(cldw);\n+}\n@@ -786,3 +870,2 @@\n-static void write_classloaders() {\n-  assert(_writer != nullptr, \"invariant\");\n-  CldWriter cldw(_writer, _class_unload);\n+static void do_unloading_clds(CldWriter& cldw) {\n+  assert(unloading(), \"invariant\");\n@@ -792,3 +875,26 @@\n-  if (current_epoch()) {\n-    _artifacts->iterate_klasses(kmcw);\n-    _artifacts->tally(cldw);\n+  _artifacts->iterate_klasses(kmcw);\n+  _artifacts->tally(cldw);\n+}\n+\n+static void write_clds_with_leakp(CldWriter& cldw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakCldWriter lcldw(_leakp_writer, unloading());\n+  CompositeCldWriter ccldw(&lcldw, &cldw);\n+  ClearArtifact<CldPtr> clear;\n+  CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n+  CompositeCldClearCallback callback(&_subsystem_callback, &ccldwwc);\n+  do_all_clds(cldw);\n+}\n+\n+static void write_clds() {\n+  assert(_writer != nullptr, \"invariant\");\n+  CldWriter cldw(_writer, unloading());\n+  if (unloading()) {\n+    do_unloading_clds(cldw);\n+    return;\n+  }\n+  if (flushpoint()) {\n+    CldCallback callback(&_subsystem_callback, &cldw);\n+    do_all_clds(cldw);\n@@ -799,1 +905,0 @@\n-    _artifacts->iterate_klasses(kmcw);\n@@ -802,13 +907,3 @@\n-    CldCallback callback(&_subsystem_callback, &cldwwc);\n-    do_class_loaders();\n-  } else {\n-    LeakCldWriter lcldw(_leakp_writer, _class_unload);\n-    CompositeCldWriter ccldw(&lcldw, &cldw);\n-    KlassCompositeCldWriter kccldw(&ccldw);\n-    ModuleCompositeCldWriter mccldw(&ccldw);\n-    KlassAndModuleCompositeCldWriter kmccldw(&kccldw, &mccldw);\n-    _artifacts->iterate_klasses(kmccldw);\n-    ClearArtifact<CldPtr> clear;\n-    CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n-    CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n-    do_class_loaders();\n+    CldClearCallback callback(&_subsystem_callback, &cldwwc);\n+    do_all_clds(cldw);\n+    return;\n@@ -816,1 +911,1 @@\n-  _artifacts->tally(cldw);\n+  write_clds_with_leakp(cldw);\n@@ -819,1 +914,1 @@\n-static void write_classloaders_on_clear() {\n+static void write_clds_on_clear() {\n@@ -822,15 +917,3 @@\n-  CldWriter cldw(_writer, _class_unload);\n-  KlassCldWriter kcw(&cldw);\n-  ModuleCldWriter mcw(&cldw);\n-  KlassAndModuleCldWriter kmcw(&kcw, &mcw);\n-  LeakCldWriter lcldw(_leakp_writer, _class_unload);\n-  CompositeCldWriter ccldw(&lcldw, &cldw);\n-  KlassCompositeCldWriter kccldw(&ccldw);\n-  ModuleCompositeCldWriter mccldw(&ccldw);\n-  KlassAndModuleCompositeCldWriter kmccldw(&kccldw, &mccldw);\n-  _artifacts->iterate_klasses(kmccldw);\n-  ClearArtifact<CldPtr> clear;\n-  CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n-  CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n-  do_class_loaders();\n-  _artifacts->tally(cldw);\n+  assert(previous_epoch(), \"invariant\");\n+  CldWriter cldw(_writer, unloading());\n+  write_clds_with_leakp(cldw);\n@@ -839,4 +922,1 @@\n-static u1 get_visibility(MethodPtr method) {\n-  assert(method != nullptr, \"invariant\");\n-  return const_cast<Method*>(method)->is_hidden() ? (u1)1 : (u1)0;\n-}\n+\/***** Methods *****\/\n@@ -847,2 +927,0 @@\n-  SET_METHOD_SERIALIZED(method);\n-  assert(METHOD_IS_SERIALIZED(method), \"invariant\");\n@@ -852,0 +930,8 @@\n+  assert(METHOD_IS_NOT_SERIALIZED(method), \"invariant\");\n+  SET_METHOD_SERIALIZED(method);\n+  assert(METHOD_IS_SERIALIZED(method), \"invariant\");\n+}\n+\n+static inline u1 get_visibility(MethodPtr method) {\n+  assert(method != nullptr, \"invariant\");\n+  return const_cast<Method*>(method)->is_hidden() ? (u1)1 : (u1)0;\n@@ -864,1 +950,1 @@\n-  writer->write((u2)get_flags(method));\n+  writer->write(static_cast<u2>(get_flags(method)));\n@@ -871,1 +957,1 @@\n-  MethodPtr method = (MethodPtr)m;\n+  MethodPtr method = static_cast<MethodPtr>(m);\n@@ -878,1 +964,1 @@\n-  MethodPtr method = (MethodPtr)m;\n+  MethodPtr method = static_cast<MethodPtr>(m);\n@@ -883,25 +969,1 @@\n-class BitMapFilter {\n-  ResourceBitMap _bitmap;\n- public:\n-  explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}\n-  bool operator()(size_t idx) {\n-    if (_bitmap.size() == 0) {\n-      return true;\n-    }\n-    if (_bitmap.at(idx)) {\n-      return false;\n-    }\n-    _bitmap.set_bit(idx);\n-    return true;\n-  }\n-};\n-\n-class AlwaysTrue {\n- public:\n-  explicit AlwaysTrue(int length = 0) {}\n-  bool operator()(size_t idx) {\n-    return true;\n-  }\n-};\n-\n-template <typename MethodCallback, typename KlassCallback, class Filter, bool leakp>\n+template <typename MethodCallback, typename KlassCallback, bool leakp>\n@@ -967,1 +1029,1 @@\n-typedef MethodIteratorHost<MethodWriterImpl, KlassCallbackStub, BitMapFilter, false> MethodWriter;\n+typedef MethodIteratorHost<MethodWriterImpl, KlassCallbackStub, false> MethodWriter;\n@@ -972,2 +1034,2 @@\n-typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true> LeakMethodWriter;\n-typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true> LeakMethodWriter;\n+typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, true> LeakMethodWriter;\n+typedef MethodIteratorHost<LeakMethodWriterImpl, KlassCallbackStub, true> LeakMethodWriter;\n@@ -976,0 +1038,10 @@\n+static void write_methods_with_leakp(MethodWriter& mw) {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), unloading());\n+  CompositeMethodWriter cmw(&lpmw, &mw);\n+  _artifacts->iterate_klasses(cmw);\n+  _artifacts->tally(mw);\n+}\n+\n@@ -978,1 +1050,1 @@\n-  MethodWriter mw(_writer, current_epoch(), _class_unload);\n+  MethodWriter mw(_writer, current_epoch(), unloading());\n@@ -981,4 +1053,2 @@\n-  } else {\n-    LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);\n-    CompositeMethodWriter cmw(&lpmw, &mw);\n-    _artifacts->iterate_klasses(cmw);\n+    _artifacts->tally(mw);\n+    return;\n@@ -986,1 +1056,1 @@\n-  _artifacts->tally(mw);\n+  write_methods_with_leakp(mw);\n@@ -993,5 +1063,2 @@\n-  MethodWriter mw(_writer, current_epoch(), _class_unload);\n-  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);\n-  CompositeMethodWriter cmw(&lpmw, &mw);\n-  _artifacts->iterate_klasses(cmw);\n-  _artifacts->tally(mw);\n+  MethodWriter mw(_writer, current_epoch(), unloading());\n+  write_methods_with_leakp(mw);\n@@ -1025,1 +1092,1 @@\n-  SymbolEntryPtr entry = (SymbolEntryPtr)e;\n+  SymbolEntryPtr entry = static_cast<SymbolEntryPtr>(e);\n@@ -1032,1 +1099,1 @@\n-  SymbolEntryPtr entry = (SymbolEntryPtr)e;\n+  SymbolEntryPtr entry = static_cast<SymbolEntryPtr>(e);\n@@ -1046,1 +1113,1 @@\n-  StringEntryPtr entry = (StringEntryPtr)e;\n+  StringEntryPtr entry = static_cast<StringEntryPtr>(e);\n@@ -1053,1 +1120,1 @@\n-  StringEntryPtr entry = (StringEntryPtr)e;\n+  StringEntryPtr entry = static_cast<StringEntryPtr>(e);\n@@ -1074,15 +1141,0 @@\n-  assert(_leakp_writer != nullptr, \"invariant\");\n-  SymbolEntryWriter sw(_writer, _class_unload);\n-  LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);\n-  CompositeSymbolWriter csw(&lsw, &sw);\n-  _artifacts->iterate_symbols(csw);\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n-  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n-  CompositeStringWriter csew(&lsew, &sew);\n-  _artifacts->iterate_strings(csew);\n-  sw.add(sew.count());\n-  lsw.add(lsew.count());\n-  _artifacts->tally(sw);\n-}\n-\n-static void write_symbols_on_clear() {\n@@ -1092,2 +1144,2 @@\n-  SymbolEntryWriter sw(_writer, _class_unload);\n-  LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);\n+  SymbolEntryWriter sw(_writer, unloading());\n+  LeakSymbolEntryWriter lsw(_leakp_writer, unloading());\n@@ -1096,2 +1148,2 @@\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n-  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n+  StringEntryWriter sew(_writer, unloading(), true); \/\/ skip header\n+  LeakStringEntryWriter lsew(_leakp_writer, unloading(), true); \/\/ skip header\n@@ -1111,1 +1163,1 @@\n-  SymbolEntryWriter sw(_writer, _class_unload);\n+  SymbolEntryWriter sw(_writer, unloading());\n@@ -1113,1 +1165,1 @@\n-  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n+  StringEntryWriter sew(_writer, unloading(), true); \/\/ skip header\n@@ -1119,0 +1171,7 @@\n+static void write_symbols_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  write_symbols_with_leakp();\n+}\n+\n@@ -1121,1 +1180,1 @@\n-typedef MethodIteratorHost<ClearMethodFlag, ClearKlassBits, AlwaysTrue, false> ClearKlassAndMethods;\n+typedef MethodIteratorHost<ClearMethodFlag, ClearKlassBits, false> ClearKlassAndMethods;\n@@ -1168,3 +1227,1 @@\n-  if (!write_klasses()) {\n-    return 0;\n-  }\n+  write_klasses();\n@@ -1173,1 +1230,1 @@\n-  write_classloaders();\n+  write_clds();\n@@ -1180,1 +1237,1 @@\n- * Clear all tags from the previous epoch.\n+ * Clear all tags from the previous epoch. Reset support structures.\n@@ -1188,1 +1245,1 @@\n-  write_classloaders_on_clear();\n+  write_clds_on_clear();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":549,"deletions":492,"binary":false,"changes":1041,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                                                    _total_count(0) {\n+                                                    _total_count(0),\n+                                                    _class_unload(class_unload) {\n@@ -44,0 +45,1 @@\n+  _class_unload = class_unload;\n@@ -54,0 +56,5 @@\n+  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n+\n+  if (class_unload) {\n+    _unloading_set = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  }\n@@ -100,1 +107,7 @@\n-bool JfrArtifactSet::should_do_loader_klass(const Klass* k) {\n+static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+  assert(set != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n+  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+}\n+\n+bool JfrArtifactSet::should_do_cld_klass(const Klass* k, bool leakp) {\n@@ -103,1 +116,15 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(_klass_loader_set, k);\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  if (leakp) {\n+    return not_in_set(_klass_loader_leakp_set, k);\n+  }\n+  return _class_unload || IS_NOT_SERIALIZED(k) ? not_in_set(_klass_loader_set, k) : false;\n+}\n+\n+bool JfrArtifactSet::should_do_unloading_artifact(const void* ptr) {\n+  assert(ptr != nullptr, \"invariant\");\n+  assert(_class_unload, \"invariant\");\n+  assert(_unloading_set != nullptr, \"invariant\");\n+  \/\/ The incoming pointers are of all kinds of different types.\n+  \/\/ However, we are only interested in set membership.\n+  \/\/ Treat them uniformly as const Klass* for simplicity and code reuse.\n+  return not_in_set(_unloading_set, static_cast<const Klass*>(ptr));\n@@ -120,1 +147,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -117,22 +117,0 @@\n-template <typename T>\n-class SerializePredicate {\n-  bool _class_unload;\n- public:\n-  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n-  bool operator()(T const& value) {\n-    assert(value != nullptr, \"invariant\");\n-    return _class_unload ? true : IS_NOT_SERIALIZED(value);\n-  }\n-};\n-\n-template <>\n-class SerializePredicate<const Method*> {\n-  bool _class_unload;\n- public:\n-  SerializePredicate(bool class_unload) : _class_unload(class_unload) {}\n-  bool operator()(const Method* method) {\n-    assert(method != nullptr, \"invariant\");\n-    return _class_unload ? true : METHOD_IS_NOT_SERIALIZED(method);\n-  }\n-};\n-\n@@ -213,0 +191,2 @@\n+  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  GrowableArray<const Klass*>* _unloading_set;\n@@ -214,0 +194,1 @@\n+  bool _class_unload;\n@@ -238,1 +219,2 @@\n-  bool should_do_loader_klass(const Klass* k);\n+  bool should_do_cld_klass(const Klass* k, bool leakp);\n+  bool should_do_unloading_artifact(const void* ptr);\n@@ -245,1 +227,6 @@\n-        break;\n+        return;\n+      }\n+    }\n+    for (int i = 0; i < _klass_loader_set->length(); ++i) {\n+      if (!functor(_klass_loader_set->at(i))) {\n+        return;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -70,3 +70,3 @@\n-    SET_USED_THIS_EPOCH(klass);\n-    enqueue(klass);\n-    JfrTraceIdEpoch::set_changed_tag_state();\n+  SET_USED_THIS_EPOCH(klass);\n+  enqueue(klass);\n+  JfrTraceIdEpoch::set_changed_tag_state();\n@@ -116,8 +116,0 @@\n-inline traceid JfrTraceIdLoadBarrier::load(const ModuleEntry* module) {\n-  return set_used_and_get(module);\n-}\n-\n-inline traceid JfrTraceIdLoadBarrier::load(const PackageEntry* package) {\n-  return set_used_and_get(package);\n-}\n-\n@@ -130,2 +122,2 @@\n-  if (class_loader_klass != nullptr && should_tag(class_loader_klass)) {\n-    load_barrier(class_loader_klass);\n+  if (class_loader_klass != nullptr) {\n+    load(class_loader_klass);\n@@ -136,0 +128,18 @@\n+inline traceid JfrTraceIdLoadBarrier::load(const ModuleEntry* module) {\n+  assert(module != nullptr, \"invariant\");\n+  const ClassLoaderData* cld = module->loader_data();\n+  if (cld != nullptr) {\n+    load(cld);\n+  }\n+  return set_used_and_get(module);\n+}\n+\n+inline traceid JfrTraceIdLoadBarrier::load(const PackageEntry* package) {\n+  assert(package != nullptr, \"invariant\");\n+  const ModuleEntry* const module_entry = package->module();\n+  if (module_entry != nullptr) {\n+    load(module_entry);\n+  }\n+  return set_used_and_get(package);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"}]}