{"files":[{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test that Response Message gets set even if a non 100 response\n+ *          gets return when Expect Continue is set\n+ * @bug 8352502\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.internal.httpclient.debug=true\n+ *                    -Djdk.httpclient.HttpClient.log=all\n+ *                    HttpUrlConnectionExpectContinueResponseMessageTest\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.Socket;\n+import java.net.ServerSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.util.Arrays;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class HttpUrlConnectionExpectContinueResponseMessageTest {\n+    class Control {\n+        volatile ServerSocket serverSocket = null;\n+        volatile boolean stop = false;\n+        volatile String response = null;\n+        volatile Socket acceptingSocket = null;\n+    }\n+\n+    private Thread serverThread = null;\n+    private volatile Control control;\n+    static final Logger logger;\n+\n+    static {\n+        logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n+        logger.setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    public Object[][] args() {\n+        return new Object[][]{\n+                \/\/ Expected Status Code, Status Line, Expected responseMessage\n+                { 404, \"HTTP\/1.1 404 Not Found\", \"Not Found\" },\n+                { 405, \"HTTP\/1.1 405 Method Not Allowed\", \"Method Not Allowed\" },\n+                { 401, \"HTTP\/1.1 401 Unauthorized\", \"Unauthorized\"}\n+        };\n+    }\n+\n+    @BeforeAll\n+    public void startServerSocket() throws Exception {\n+        Control control = this.control = new Control();\n+\n+        control.serverSocket = new ServerSocket();\n+        control.serverSocket.setReuseAddress(true);\n+        control.serverSocket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        Runnable runnable = () -> {\n+            while (!control.stop) {\n+                try {\n+                    control.acceptingSocket = control.serverSocket.accept();\n+                    InputStream inputStream = control.acceptingSocket.getInputStream();\n+                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\n+\n+                    StringBuilder stringBuilder = new StringBuilder();\n+\n+                    \/\/ Read initial request\n+                    byte b;\n+                    while (true) {\n+                        b = (byte) inputStreamReader.read();\n+                        stringBuilder.append((char) b);\n+\n+                        if (stringBuilder.length() >= 4) {\n+                            char[] lastBytes = new char[4];\n+                            stringBuilder.getChars(\n+                                    stringBuilder.length() - 4,\n+                                    stringBuilder.length(), lastBytes, 0);\n+                            if (Arrays.equals(lastBytes, new char[]{'\\r', '\\n', '\\r', '\\n'})) {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    OutputStream outputStream = control.acceptingSocket.getOutputStream();\n+\n+                    \/\/send a wrong response\n+                    outputStream.write(control.response.getBytes());\n+                    outputStream.flush();\n+                    control.acceptingSocket.shutdownOutput();\n+                } catch (Exception e) {\n+                    \/\/ Any exceptions will be ignored\n+                }\n+            }\n+        };\n+        serverThread = new Thread(runnable);\n+        serverThread.start();\n+    }\n+\n+    @AfterAll\n+    public void stopServerSocket() throws Exception {\n+        Control control = this.control;\n+        control.stop = true;\n+        control.serverSocket.close();\n+        serverThread.join();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"args\")\n+    public void test(int expectedCode, String statusLine, String expectedMessage) throws Exception {\n+        String body = \"Testing: \" + expectedCode;\n+        Control control = this.control;\n+        control.response = statusLine + \"\\r\\n\"\n+                + \"Content-Length: 0\\r\\n\"\n+                + \"\\r\\n\";\n+\n+        HttpURLConnection connection = createConnection();\n+        try {\n+            connection.setFixedLengthStreamingMode(body.getBytes().length);\n+            OutputStream outputStream = connection.getOutputStream();\n+            outputStream.write(body.getBytes());\n+            outputStream.close();\n+        } catch (Exception ex) {\n+            \/\/ server returning 4xx responses can result in exceptions\n+            \/\/ but we can just swallow them\n+        }\n+\n+        int responseCode = connection.getResponseCode();\n+        String responseMessage = connection.getResponseMessage();\n+        assertTrue(responseCode == expectedCode,\n+                String.format(\"Expected %s response, instead received %s\", expectedCode, responseCode));\n+        assertTrue(expectedMessage.equals(responseMessage),\n+                String.format(\"Expected Response Message  %s, instead received %s\",\n+                        expectedMessage, responseMessage));\n+        control.acceptingSocket.close();\n+    }\n+\n+    \/\/ Creates a connection with all the common settings used in each test\n+    private HttpURLConnection createConnection() throws Exception {\n+        URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .port(control.serverSocket.getLocalPort())\n+                .toURL();\n+\n+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+        connection.setDoOutput(true);\n+        connection.setRequestMethod(\"POST\");\n+        connection.setRequestProperty(\"Connection\", \"Close\");\n+        connection.setRequestProperty(\"Expect\", \"100-Continue\");\n+\n+        return connection;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/HttpUrlConnectionExpectContinueResponseMessageTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that Response Message gets set even if a non 100 response\n- *          gets return when Expect Continue is set\n- * @bug 8352502\n- * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n- * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n- * @run junit\/othervm -Djdk.internal.httpclient.debug=true\n- *                    -Djdk.httpclient.HttpClient.log=all\n- *                    ExpectContinueResponseMessageTest\n- *\/\n-\n-import jdk.test.lib.net.URIBuilder;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.TestInstance;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.net.HttpURLConnection;\n-import java.net.Socket;\n-import java.net.SocketException;\n-import java.net.ServerSocket;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.URL;\n-import java.util.Arrays;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n-public class ExpectContinueResponseMessageTest {\n-    class Control {\n-        volatile ServerSocket serverSocket = null;\n-        volatile boolean stop = false;\n-        volatile String statusLine = null;\n-    }\n-\n-    private Thread serverThread = null;\n-    private volatile Control control;\n-    static final Logger logger;\n-\n-    static {\n-        logger = Logger.getLogger(\"sun.net.www.protocol.http.HttpURLConnection\");\n-        logger.setLevel(Level.ALL);\n-        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n-    }\n-\n-    public Object[][] args() {\n-        return new Object[][]{\n-                \/\/ Expected Status Code, Status Line, Expected responseMessage\n-                { 404, \"HTTP\/1.1 404 Not Found\", \"Not Found\" },\n-                { 405, \"HTTP\/1.1 405 Method Not Allowed\", \"Method Not Allowed\" },\n-                { 401, \"HTTP\/1.1 401 Unauthorized\", \"Unauthorized\"}\n-        };\n-    }\n-\n-    @BeforeAll\n-    public void startServerSocket() throws Exception {\n-        Control control = this.control = new Control();\n-\n-        control.serverSocket = new ServerSocket();\n-        control.serverSocket.setReuseAddress(true);\n-        control.serverSocket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n-        Runnable runnable = () -> {\n-            while (!control.stop) {\n-                try {\n-                    Socket socket = control.serverSocket.accept();\n-                    InputStream inputStream = socket.getInputStream();\n-                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\n-\n-                    StringBuilder stringBuilder = new StringBuilder();\n-\n-                    \/\/ Read initial request\n-                    byte b;\n-                    while (true) {\n-                        b = (byte) inputStreamReader.read();\n-                        stringBuilder.append((char) b);\n-\n-                        if (stringBuilder.length() >= 4) {\n-                            char[] lastBytes = new char[4];\n-                            stringBuilder.getChars(\n-                                    stringBuilder.length() - 4,\n-                                    stringBuilder.length(), lastBytes, 0);\n-                            if (Arrays.equals(lastBytes, new char[]{'\\r', '\\n', '\\r', '\\n'})) {\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    OutputStream outputStream = socket.getOutputStream();\n-\n-                    \/\/send a wrong response\n-                    outputStream.write(control.statusLine.getBytes());\n-                    outputStream.flush();\n-                } catch (SocketException e) {\n-                    \/\/ ignore\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            }\n-        };\n-        serverThread = new Thread(runnable);\n-        serverThread.start();\n-    }\n-\n-    @AfterAll\n-    public void stopServerSocket() throws Exception {\n-        Control control = this.control;\n-        control.stop = true;\n-        control.serverSocket.close();\n-        serverThread.join();\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"args\")\n-    public void test(int expectedCode, String statusLine, String expectedMessage) throws Exception {\n-        String body = \"Testing: \" + expectedCode;\n-        Control control = this.control;\n-        control.statusLine = statusLine + \"\\r\\n\\r\\n\";\n-\n-        HttpURLConnection connection = createConnection();\n-        connection.setFixedLengthStreamingMode(body.getBytes().length);\n-        try {\n-            OutputStream outputStream = connection.getOutputStream();\n-            outputStream.write(body.getBytes());\n-            outputStream.close();\n-        } catch (Exception ex) {\n-            \/\/ swallow the exception\n-        }\n-\n-        int responseCode = connection.getResponseCode();\n-        String responseMessage = connection.getResponseMessage();\n-        assertTrue(responseCode == expectedCode,\n-                String.format(\"Expected %s response, instead received %s\", expectedCode, responseCode));\n-        assertTrue(expectedMessage.equals(responseMessage),\n-                String.format(\"Expected Response Message  %s, instead received %s\",\n-                        expectedMessage, responseMessage));\n-    }\n-\n-    \/\/ Creates a connection with all the common settings used in each test\n-    private HttpURLConnection createConnection() throws Exception {\n-            URL url = URIBuilder.newBuilder()\n-                    .scheme(\"http\")\n-                    .loopback()\n-                    .port(control.serverSocket.getLocalPort())\n-                    .toURL();\n-\n-            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-            connection.setDoOutput(true);\n-            connection.setRequestMethod(\"POST\");\n-            connection.setRequestProperty(\"Connection\", \"Close\");\n-            connection.setRequestProperty(\"Expect\", \"100-Continue\");\n-\n-            return connection;\n-        }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueResponseMessageTest.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"}]}