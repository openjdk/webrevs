{"files":[{"patch":"@@ -4517,2 +4517,1 @@\n-instruct ReplS_imm(vec dst, immH con, rRegI rtmp) %{\n-  predicate(VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct ReplH_imm(vec dst, immH con, rRegI rtmp) %{\n@@ -4521,1 +4520,1 @@\n-  format %{ \"replicateS $dst, $con\" %}\n+  format %{ \"replicateH $dst, $con \\t! using $rtmp as TEMP\" %}\n@@ -4524,0 +4523,2 @@\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(VM_Version::supports_avx512_fp16() && bt == T_SHORT, \"\");\n@@ -4529,0 +4530,24 @@\n+\n+instruct ReplH_short_reg(vec dst, rRegI src) %{\n+  predicate(VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate (ReinterpretS2HF src)));\n+  format %{ \"replicateH $dst, $src\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct ReplH_reg(vec dst, regF src, rRegI rtmp) %{\n+  predicate(VM_Version::supports_avx512_fp16() && Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (Replicate src));\n+  effect(TEMP rtmp);\n+  format %{ \"replicateH $dst, $src \\t! using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vmovw($rtmp$$Register, $src$$XMMRegister);\n+    __ evpbroadcastw($dst$$XMMRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -10905,1 +10930,1 @@\n-instruct scalar_sqrt_fp16(regF dst, regF src)\n+instruct scalar_sqrt_fp16_reg(regF dst, regF src)\n@@ -10915,1 +10940,1 @@\n-instruct scalar_binOps_fp16(regF dst, regF src1, regF src2)\n+instruct scalar_binOps_fp16_reg(regF dst, regF src1, regF src2)\n@@ -10931,1 +10956,1 @@\n-instruct scalar_fma_fp16(regF dst, regF src1, regF src2)\n+instruct scalar_fma_fp16_reg(regF dst, regF src1, regF src2)\n@@ -11011,1 +11036,1 @@\n-instruct vector_fmah_fp16_mem(vec dst, memory src1, vec src2)\n+instruct vector_fma_fp16_mem(vec dst, memory src1, vec src2)\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-const Type *AddHFNode::add_of_identity( const Type *t1, const Type *t2 ) const {\n+const Type *AddHFNode::add_of_identity(const Type *t1, const Type *t2) const {\n@@ -721,1 +721,1 @@\n-const Type *AddHFNode::add_ring( const Type *t0, const Type *t1 ) const {\n+const Type *AddHFNode::add_ring(const Type *t0, const Type *t1) const {\n@@ -1604,1 +1604,1 @@\n-const Type* MinHFNode::add_ring(const Type* t0, const Type* t1 ) const {\n+const Type* MinHFNode::add_ring(const Type* t0, const Type* t1) const {\n@@ -1679,3 +1679,3 @@\n-const Type* MaxFNode::add_ring(const Type* t0, const Type* t1) const {\n-  const TypeF* r0 = t0->isa_float_constant();\n-  const TypeF* r1 = t1->isa_float_constant();\n+const Type* MaxHFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeH* r0 = t0->isa_half_float_constant();\n+  const TypeH* r1 = t1->isa_half_float_constant();\n@@ -1703,0 +1703,1 @@\n+\n@@ -1704,3 +1705,3 @@\n-const Type* MaxHFNode::add_ring(const Type* t0, const Type* t1) const {\n-  const TypeH* r0 = t0->isa_half_float_constant();\n-  const TypeH* r1 = t1->isa_half_float_constant();\n+const Type* MaxFNode::add_ring(const Type* t0, const Type* t1) const {\n+  const TypeF* r0 = t0->isa_float_constant();\n+  const TypeF* r1 = t1->isa_float_constant();\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  AddHFNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  AddHFNode(Node *in1, Node *in2) : AddNode(in1,in2) {}\n@@ -171,4 +171,4 @@\n-  virtual const Type *add_of_identity( const Type *t1, const Type *t2 ) const;\n-  virtual const Type *add_ring( const Type *, const Type * ) const;\n-  virtual const Type *add_id() const { return TypeH::ZERO; }\n-  virtual const Type *bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual const Type* add_of_identity(const Type *t1, const Type *t2) const;\n+  virtual const Type* add_ring(const Type*, const Type*) const;\n+  virtual const Type* add_id() const { return TypeH::ZERO; }\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/connode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-  case T_SHORT:   return sizeof(jshort );\n+  case T_SHORT:   return sizeof(jint   );\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-    if (Matcher::match_rule_supported(in(1)->Opcode()) &&\n+    if (Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(in(1)->Opcode())) &&\n@@ -962,0 +962,19 @@\n+int Float16NodeFactory::get_float16_binary_oper(int opc) {\n+  switch(opc) {\n+    case Op_AddF:\n+      return Op_AddHF;\n+    case Op_SubF:\n+      return Op_SubHF;\n+    case Op_MulF:\n+      return Op_MulHF;\n+    case Op_DivF:\n+      return Op_DivHF;\n+    case Op_MaxF:\n+      return Op_MaxHF;\n+    case Op_MinF:\n+      return Op_MinHF;\n+    default:\n+      return false;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  static int get_float16_binary_oper(int opc);\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -756,4 +756,4 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if(t1 == Type::TOP) return Type::TOP;\n+  if(t2 == Type::TOP) return Type::TOP;\n@@ -762,3 +762,3 @@\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+  const Type* bot = bottom_type();\n+  if((t1 == bot) || (t2 == bot) ||\n+     (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM))\n@@ -775,1 +775,1 @@\n-  if( t2 == TypeH::ONE )\n+  if(t2 == TypeH::ONE)\n@@ -779,4 +779,4 @@\n-  if( t1->base() == Type::HalfFloatCon &&\n-      t2->base() == Type::HalfFloatCon &&\n-      t2->getf() != 0.0 ) \/\/ could be negative zero\n-    return TypeH::make( t1->getf()\/t2->getf() );\n+  if(t1->base() == Type::HalfFloatCon &&\n+     t2->base() == Type::HalfFloatCon &&\n+     t2->getf() != 0.0) \/\/ could be negative zero\n+    return TypeH::make(t1->getf()\/t2->getf());\n@@ -788,1 +788,1 @@\n-  if( t1 == TypeH::ZERO && !g_isnan(t2->getf()) && t2->getf() != 0.0 )\n+  if(t1 == TypeH::ZERO && !g_isnan(t2->getf()) && t2->getf() != 0.0)\n@@ -804,1 +804,1 @@\n-Node *DivHFNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node *DivHFNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n@@ -807,1 +807,1 @@\n-  if( in(0) && in(0)->is_top() )  return nullptr;\n+  if(in(0) && in(0)->is_top())  return nullptr;\n@@ -809,3 +809,3 @@\n-  const Type *t2 = phase->type( in(2) );\n-  if( t2 == TypeH::ONE )         \/\/ Identity?\n-    return nullptr;              \/\/ Skip it\n+  const Type* t2 = phase->type(in(2));\n+  if(t2 == TypeH::ONE)         \/\/ Identity?\n+    return nullptr;            \/\/ Skip it\n@@ -813,3 +813,3 @@\n-  const TypeH *tf = t2->isa_half_float_constant();\n-  if( !tf ) return nullptr;\n-  if( tf->base() != Type::HalfFloatCon ) return nullptr;\n+  const TypeH* tf = t2->isa_half_float_constant();\n+  if(!tf) return nullptr;\n+  if(tf->base() != Type::HalfFloatCon) return nullptr;\n@@ -818,1 +818,1 @@\n-  if( tf->is_nan() || !tf->is_finite() ) return nullptr;\n+  if(tf->is_nan() || !tf->is_finite()) return nullptr;\n@@ -825,1 +825,1 @@\n-  if( frexp((double)f, &exp) != 0.5 ) return nullptr;\n+  if(frexp((double)f, &exp) != 0.5) return nullptr;\n@@ -828,1 +828,1 @@\n-  if( exp < -14 || exp > 15 ) return nullptr;\n+  if(exp < -14 || exp > 15) return nullptr;\n@@ -833,1 +833,1 @@\n-  assert( frexp((double)reciprocal, &exp) == 0.5, \"reciprocal should be power of 2\" );\n+  assert(frexp((double)reciprocal, &exp) == 0.5, \"reciprocal should be power of 2\");\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-  DivHFNode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor) {}\n+  DivHFNode(Node* c, Node* dividend, Node* divisor) : Node(c, dividend, divisor) {}\n@@ -88,1 +88,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -90,1 +90,1 @@\n-  virtual const Type *bottom_type() const { return Type::HALF_FLOAT; }\n+  virtual const Type* bottom_type() const { return Type::HALF_FLOAT; }\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -556,16 +556,0 @@\n-\/\/------------------------------Ideal------------------------------------------\n-Node *SubHFNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  const Type *t2 = phase->type( in(2) );\n-  \/\/ Convert \"x-c0\" into \"x+ -c0\".\n-  if( t2->base() == Type::HalfFloatCon ) {  \/\/ Might be bottom or top...\n-    \/\/ return new (phase->C, 3) AddFNode(in(1), phase->makecon( TypeF::make(-t2->getf()) ) );\n-  }\n-\n-  \/\/ Cannot replace 0.0-X with -X because a 'fsub' bytecode computes\n-  \/\/ 0.0-0.0 as +0.0, while a 'fneg' bytecode computes -0.0.\n-  \/\/if( phase->type(in(1)) == TypeF::ZERO )\n-  \/\/return new (phase->C, 2) NegFNode(in(2));\n-\n-  return nullptr;\n-}\n-\n@@ -574,1 +558,1 @@\n-const Type *SubHFNode::sub( const Type *t1, const Type *t2 ) const {\n+const Type* SubHFNode::sub(const Type* t1, const Type* t2) const {\n@@ -576,2 +560,2 @@\n-  if( g_isfinite(t1->getf()) && g_isfinite(t2->getf()) ) {\n-    return TypeH::make( t1->getf() - t2->getf() );\n+  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+    return TypeH::make(t1->getf() - t2->getf());\n@@ -579,1 +563,1 @@\n-  else if( g_isnan(t1->getf()) ) {\n+  else if(g_isnan(t1->getf())) {\n@@ -582,1 +566,1 @@\n-  else if( g_isnan(t2->getf()) ) {\n+  else if(g_isnan(t2->getf())) {\n@@ -589,0 +573,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1184,0 +1184,1 @@\n+  case HalfFloatTop:\n@@ -1192,0 +1193,1 @@\n+  case HalfFloatBot:\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-    @IR(counts = {IRNode.REINTERPRET_S2HF, \">=1\", IRNode.REINTERPRET_HF2S, \">=1\", IRNode.ADD_HF, \">=1\" },\n-        failOn = {IRNode.ADD_F, IRNode.CONV_HF2F, IRNode.CONV_F2HF},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,3 +60,0 @@\n-    @IR(counts = {IRNode.ADD_HF, \"1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"},\n-        failOn = {IRNode.MUL_HF})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-\n@@ -36,1 +35,0 @@\n-import java.util.Random;\n@@ -39,0 +37,1 @@\n+import java.util.Random;\n@@ -54,0 +53,1 @@\n+        Random r = jdk.test.lib.Utils.getRandomInstance();\n@@ -55,1 +55,10 @@\n-            src[i] = Float.floatToFloat16(i);\n+            src[i] = Float.floatToFloat16(r.nextFloat());\n+        }\n+    }\n+\n+    static void assertResult(float actual, float expected, String msg) {\n+        if (actual != expected) {\n+            if (!Float.isNaN(actual) || !Float.isNaN(expected)) {\n+                String error = \"TEST: \" + msg + \": actual(\" + actual + \") != expected(\" + expected + \")\";\n+                throw new AssertionError(error);\n+            }\n@@ -62,2 +71,0 @@\n-    @IR(counts = {IRNode.ADD_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -75,2 +82,0 @@\n-    @IR(failOn = {IRNode.ADD_HF, IRNode.REINTERPRET_S2HF, IRNode.REINTERPRET_HF2S},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -89,2 +94,0 @@\n-    @IR(counts = {IRNode.SUB_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -102,2 +105,0 @@\n-    @IR(counts = {IRNode.MUL_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -115,2 +116,0 @@\n-    @IR(counts = {IRNode.DIV_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -128,2 +127,0 @@\n-    @IR(counts = {IRNode.MAX_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -141,2 +138,0 @@\n-    @IR(counts = {IRNode.MIN_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -154,2 +149,0 @@\n-    @IR(counts = {IRNode.SQRT_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -167,2 +160,0 @@\n-    @IR(counts = {IRNode.FMA_HF, \"> 0\", IRNode.REINTERPRET_S2HF, \"> 0\", IRNode.REINTERPRET_HF2S, \"> 0\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n@@ -173,1 +164,1 @@\n-            res = Float16.fma(in, in, in) ;\n+            res = Float16.fma(in, in, in);\n@@ -177,0 +168,79 @@\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testAddConstantFolding() {\n+        assertResult(add(valueOf(1.0f), valueOf(2.0f)).floatValue(), 3.0f, \"testAddConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MAX_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMaxConstantFolding() {\n+        assertResult(max(valueOf(1.0f), valueOf(2.0f)).floatValue(), 2.0f, \"testMaxConstantFolding\");\n+        assertResult(max(valueOf(0.0f), valueOf(-0.0f)).floatValue(), 0.0f, \"testMaxConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MIN_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMinConstantFolding() {\n+        assertResult(min(valueOf(1.0f), valueOf(2.0f)).floatValue(), 1.0f, \"testMinConstantFolding\");\n+        assertResult(min(valueOf(0.0f), valueOf(-0.0f)).floatValue(), -0.0f, \"testMinConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivConstantFolding() {\n+        assertResult(divide(valueOf(2.0f), valueOf(2.0f)).floatValue(), 1.0f, \"testDivConstantFolding\");\n+        assertResult(divide(valueOf(0.0f), valueOf(2.0f)).floatValue(), 0.0f, \"testDivConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testDivByPOT() {\n+        Float16 actual = valueOf(0.0f);\n+        for (int i = 0; i < 100; i++) {\n+            Float16 divisor = valueOf(8.0f);\n+            Float16 dividend = shortBitsToFloat16(src[i]);\n+            actual = add(actual, divide(dividend, divisor));\n+        }\n+        float expected = 0.0f;\n+        for (int i = 0; i < 100; i++) {\n+            float dividend = Float.float16ToFloat(src[i]);\n+            expected += dividend \/ 8.0f;\n+        }\n+        assertResult(Math.round(actual.floatValue()), Math.round(expected), \"testDivByPOT\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.ADD_HF, \" >0 \", IRNode.REINTERPRET_S2HF, \" >0 \", IRNode.REINTERPRET_HF2S, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMulByTWO() {\n+        Float16 res = valueOf(0.0f);\n+        Float16 multiplier = valueOf(2.0f);\n+        for (int i = 0; i < 20; i++) {\n+            Float16 multiplicand = valueOf((float)i);\n+            res = add(res, multiply(multiplicand, multiplier));\n+        }\n+        assertResult(res.floatValue(), (float)((20 * (20 - 1))\/2) * 2.0f, \"testMulByTWO\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testMulConstantFolding() {\n+        float expected = 1.0f * 2.0f * 3.0f * 4.0f;\n+        float actual = multiply(multiply(multiply(valueOf(1.0f), valueOf(2.0f)), valueOf(3.0f)), valueOf(4.0f)).floatValue();\n+        assertResult(actual, expected, \"testMulConstantFolding\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.FMA_HF, \" 0 \", IRNode.REINTERPRET_S2HF, \" 0 \", IRNode.REINTERPRET_HF2S, \" 0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void testFMAConstantFolding() {\n+        assertResult(fma(valueOf(1.0f), valueOf(2.0f), valueOf(3.0f)).floatValue(), 1.0f * 2.0f + 3.0f, \"testFMAConstantFolding\");\n+        assertResult(fma(valueOf(Float.NaN), valueOf(2.0f), valueOf(3.0f)).floatValue(), Float.NaN, \"testFMAConstantFolding\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":92,"deletions":22,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,3 +70,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -92,3 +90,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -114,3 +110,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -136,3 +130,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -158,3 +150,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -180,3 +170,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -202,3 +190,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -224,3 +210,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -246,3 +230,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n@@ -268,3 +250,1 @@\n-        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"sve\", \"true\"})\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n-        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":10,"deletions":30,"binary":false,"changes":40,"status":"modified"}]}