{"files":[{"patch":"@@ -2693,0 +2693,5 @@\n+\n+            @Override\n+            public boolean allowSecurityManager() {\n+                return System.allowSecurityManager();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -93,0 +94,35 @@\n+ * <h2>Deprecated Methods and Replacements<\/h2>\n+ *\n+ * <p> The following methods in this class for user-based authorization\n+ * that are dependent on Security Manager APIs are deprecated for removal:\n+ * <ul>\n+ *     <li>{@link #getSubject(AccessControlContext)}\n+ *     <li>{@link #doAs(Subject, PrivilegedAction)}\n+ *     <li>{@link #doAs(Subject, PrivilegedExceptionAction)}\n+ *     <li>{@link #doAsPrivileged(Subject, PrivilegedAction, AccessControlContext)}\n+ *     <li>{@link #doAsPrivileged(Subject, PrivilegedExceptionAction, AccessControlContext)}\n+ * <\/ul>\n+ * Methods {@link #current()} and {@link #callAs(Subject, Callable)}\n+ * are replacements for these methods, where {@code current}\n+ * is mostly equivalent to {@code getSubject(AccessController.getContext())}\n+ * and {@code callAs} is similar to {@code doAs} except that the\n+ * input type and exceptions thrown are slightly different.\n+ *\n+ * <p><b><a id=\"sm-allowed\">These methods behave differently depending on\n+ * whether a security manager is\n+ * <a href=\"..\/..\/..\/java\/lang\/SecurityManager.html#set-security-manager\">allowed or disallowed<\/a><\/a><\/b>:\n+ * <ul>\n+ * <li>If a security manager is allowed, which means it is either already set\n+ * or allowed to be set dynamically, a {@code Subject} object is associated\n+ * with an {@code AccessControlContext} through a {@code doAs} or\n+ * {@code callAs} call, and the subject can then be retrieved using the\n+ * {@code getSubject(AccessControlContext)} or {@code current} method.\n+*  <li>If a security manager is not allowed, which means it is not set and\n+ * not allowed to be set dynamically, a {@code doAs} or {@code callAs} call\n+ * binds a {@code Subject} object to the period of execution of an action,\n+ * and the subject can be retrieved using the {@code current} method inside\n+ * the action. This subject can be inherited by child threads if they are\n+ * started and terminate within the execution of its parent thread using\n+ * structured concurrency.\n+ * <\/ul>\n+ *\n@@ -261,1 +297,3 @@\n-     * {@code AccessControlContext}.\n+     * {@code AccessControlContext}. This method is intended to be used with\n+     * a security manager. It throws an {@code UnsupportedOperationException}\n+     * if a security manager is not allowed.\n@@ -276,0 +314,3 @@\n+     * @throws UnsupportedOperationException if a security manager is\n+     *          not allowed\n+     *\n@@ -305,12 +346,17 @@\n-        \/\/ return the Subject from the DomainCombiner of the provided context\n-        return AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<>() {\n-            public Subject run() {\n-                DomainCombiner dc = acc.getDomainCombiner();\n-                if (!(dc instanceof SubjectDomainCombiner)) {\n-                    return null;\n-                }\n-                SubjectDomainCombiner sdc = (SubjectDomainCombiner)dc;\n-                return sdc.getSubject();\n-            }\n-        });\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            throw new UnsupportedOperationException(\n+                    \"getSubject is supported only if a security manager is allowed\");\n+        } else {\n+            \/\/ return the Subject from the DomainCombiner of the provided context\n+            return AccessController.doPrivileged\n+                    (new java.security.PrivilegedAction<>() {\n+                        public Subject run() {\n+                            DomainCombiner dc = acc.getDomainCombiner();\n+                            if (!(dc instanceof SubjectDomainCombiner)) {\n+                                return null;\n+                            }\n+                            SubjectDomainCombiner sdc = (SubjectDomainCombiner) dc;\n+                            return sdc.getSubject();\n+                        }\n+                    });\n+        }\n@@ -319,0 +365,3 @@\n+    private static final ScopedValue<Subject> SCOPED_SUBJECT =\n+            ScopedValue.newInstance();\n+\n@@ -321,2 +370,2 @@\n-     * <p>\n-     * The current subject is installed by the {@link #callAs} method.\n+     *\n+     * <p> The current subject is installed by the {@link #callAs} method.\n@@ -329,6 +378,7 @@\n-     * @implNote\n-     * This method returns the same value as\n-     * {@code Subject.getSubject(AccessController.getContext())}. This\n-     * preserves compatibility with code that may still be calling {@code doAs}\n-     * which installs the subject in an {@code AccessControlContext}. This\n-     * behavior is subject to change in a future version.\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>, this\n+     * method is equivalent to calling {@link #getSubject} with the current\n+     * {@code AccessControlContext}.\n+     *\n+     * <p> If a security manager is not allowed, this method returns the\n+     * {@code Subject} bound to the period of the execution of the current\n+     * thread.\n@@ -343,1 +393,5 @@\n-        return getSubject(AccessController.getContext());\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            return SCOPED_SUBJECT.orElse(null);\n+        } else {\n+            return getSubject(AccessController.getContext());\n+        }\n@@ -350,10 +404,15 @@\n-     * @implNote\n-     * This method calls {@link #doAs(Subject, PrivilegedExceptionAction)\n-     * Subject.doAs(subject, altAction)} which stores the subject in\n-     * a new {@code AccessControlContext}, where {@code altAction.run()}\n-     * is equivalent to {@code action.call()} and the exception thrown is\n-     * modified to match the specification of this method. This preserves\n-     * compatibility with code that may still be calling\n-     * {@code getSubject(AccessControlContext)} which retrieves the subject\n-     * from an {@code AccessControlContext}. This behavior is subject\n-     * to change in a future version.\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>,\n+     * this method first retrieves the current Thread's\n+     * {@code AccessControlContext} via\n+     * {@code AccessController.getContext},\n+     * and then instantiates a new {@code AccessControlContext}\n+     * using the retrieved context along with a new\n+     * {@code SubjectDomainCombiner} (constructed using\n+     * the provided {@code Subject}).\n+     * Finally, this method invokes {@code AccessController.doPrivileged},\n+     * passing it the provided {@code PrivilegedAction},\n+     * as well as the newly constructed {@code AccessControlContext}.\n+     *\n+     * <p> If a security manager is not allowed,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n@@ -378,9 +437,17 @@\n-        try {\n-            PrivilegedExceptionAction<T> pa = () -> action.call();\n-            @SuppressWarnings(\"removal\")\n-            var result = doAs(subject, pa);\n-            return result;\n-        } catch (PrivilegedActionException e) {\n-            throw new CompletionException(e.getCause());\n-        } catch (Exception e) {\n-            throw new CompletionException(e);\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return ScopedValue.callWhere(SCOPED_SUBJECT, subject, action);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        } else {\n+            try {\n+                PrivilegedExceptionAction<T> pa = () -> action.call();\n+                @SuppressWarnings(\"removal\")\n+                var result = doAs(subject, pa);\n+                return result;\n+            } catch (PrivilegedActionException e) {\n+                throw new CompletionException(e.getCause());\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n@@ -393,1 +460,2 @@\n-     * <p> This method first retrieves the current Thread's\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>,\n+     * this method first retrieves the current Thread's\n@@ -404,0 +472,4 @@\n+     * <p> If a security manager is not allowed,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n+     *\n@@ -447,8 +519,23 @@\n-        \/\/ set up the new Subject-based AccessControlContext\n-        \/\/ for doPrivileged\n-        final AccessControlContext currentAcc = AccessController.getContext();\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, currentAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else {\n+                    throw new AssertionError(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext\n+            \/\/ for doPrivileged\n+            final AccessControlContext currentAcc = AccessController.getContext();\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, currentAcc));\n+        }\n@@ -460,1 +547,2 @@\n-     * <p> This method first retrieves the current Thread's\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>,\n+     * this method first retrieves the current Thread's\n@@ -471,0 +559,4 @@\n+     * <p> If a security manager is not allowed,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n+\n@@ -520,7 +612,24 @@\n-        \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n-        final AccessControlContext currentAcc = AccessController.getContext();\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, currentAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else if (cause instanceof Exception e) {\n+                    throw new PrivilegedActionException(e);\n+                } else {\n+                    throw new PrivilegedActionException(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n+            final AccessControlContext currentAcc = AccessController.getContext();\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, currentAcc));\n+        }\n@@ -532,1 +641,2 @@\n-     * <p> This method behaves exactly as {@code Subject.doAs},\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>,\n+     * this method behaves exactly as {@code Subject.doAs},\n@@ -540,0 +650,4 @@\n+     * <p> If a security manager is not allowed,\n+     * this method ignores the {@code acc} argument, launches {@code action},\n+     * and binds {@code subject} to the period of its execution.\n+     *\n@@ -586,11 +700,26 @@\n-        \/\/ set up the new Subject-based AccessControlContext\n-        \/\/ for doPrivileged\n-        final AccessControlContext callerAcc =\n-                (acc == null ?\n-                new AccessControlContext(NULL_PD_ARRAY) :\n-                acc);\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, callerAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else {\n+                    throw new AssertionError(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext\n+            \/\/ for doPrivileged\n+            final AccessControlContext callerAcc =\n+                    (acc == null ?\n+                            new AccessControlContext(NULL_PD_ARRAY) :\n+                            acc);\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, callerAcc));\n+        }\n@@ -602,1 +731,2 @@\n-     * <p> This method behaves exactly as {@code Subject.doAs},\n+     * <p> If a security manager is <a href=#sm-allowed>allowed<\/a>,\n+     * this method behaves exactly as {@code Subject.doAs},\n@@ -610,0 +740,4 @@\n+     * <p> If a security manager is not allowed,\n+     * this method ignores the {@code acc} argument, launches {@code action},\n+     * and binds {@code subject} to the period of its execution.\n+     *\n@@ -662,10 +796,27 @@\n-        \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n-        final AccessControlContext callerAcc =\n-                (acc == null ?\n-                new AccessControlContext(NULL_PD_ARRAY) :\n-                acc);\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, callerAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else if (cause instanceof Exception e) {\n+                    throw new PrivilegedActionException(e);\n+                } else {\n+                    throw new PrivilegedActionException(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n+            final AccessControlContext callerAcc =\n+                    (acc == null ?\n+                            new AccessControlContext(NULL_PD_ARRAY) :\n+                            acc);\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, callerAcc));\n+        }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":233,"deletions":82,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -595,0 +595,6 @@\n+\n+    \/**\n+     * Is a security manager already set or allowed to be set\n+     * (using -Djava.security.manager=allow)?\n+     *\/\n+    boolean allowSecurityManager();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main ThreadPoolAccTest\n+ * @run main\/othervm -Djava.security.manager=allow ThreadPoolAccTest\n","filename":"test\/jdk\/javax\/management\/monitor\/ThreadPoolAccTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main NotificationAccessControllerTest\n+ * @run main\/othervm -Djava.security.manager=allow NotificationAccessControllerTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotificationAccessControllerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main NonJMXPrincipalsTest\n+ * @run main\/othervm -Djava.security.manager=allow NonJMXPrincipalsTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAccessFile\/NonJMXPrincipalsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main RMIAltAuthTest\n+ * @run main\/othervm -Djava.security.manager=allow RMIAltAuthTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIAltAuthTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main RMIPasswdAuthTest\n+ * @run main\/othervm -Djava.security.manager=allow RMIPasswdAuthTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIPasswdAuthTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,6 +34,6 @@\n- * @run main SubjectDelegation1Test policy11 ok\n- * @run main SubjectDelegation1Test policy12 ko\n- * @run main SubjectDelegation1Test policy13 ko\n- * @run main SubjectDelegation1Test policy14 ko\n- * @run main SubjectDelegation1Test policy15 ok\n- * @run main SubjectDelegation1Test policy16 ko\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy11 ok\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy12 ko\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy13 ko\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy14 ko\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy15 ok\n+ * @run main\/othervm -Djava.security.manager=allow SubjectDelegation1Test policy16 ko\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SubjectDelegation1Test.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n- * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username1 -Dpassword=password1 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials\n- * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username2 -Dpassword=password2 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedSetException -expectedInvokeException\n- * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username6 -Dpassword=password6 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedGetException -expectedSetException -expectedInvokeException\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow -DDEBUG_STANDARD -Dusername=username1 -Dpassword=password1 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow -DDEBUG_STANDARD -Dusername=username2 -Dpassword=password2 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedSetException -expectedInvokeException\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow -DDEBUG_STANDARD -Dusername=username6 -Dpassword=password6 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedGetException -expectedSetException -expectedInvokeException\n","filename":"test\/jdk\/javax\/management\/security\/AuthorizationTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296244\n+ * @enablePreview\n+ * @summary Implement Subject.current and Subject.callAs using scoped values.\n+ *      Need enablePreview to use StructuredTaskScope.\n+ * @run main\/othervm -Djava.security.manager=allow CallAsWithScopedValue false\n+ * @run main\/othervm -Djava.security.manager=disallow CallAsWithScopedValue true\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+\n+import javax.security.auth.Subject;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.StructuredTaskScope;\n+\n+public class CallAsWithScopedValue {\n+\n+    private static Map results = new ConcurrentHashMap<Integer,Boolean>();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean usv = Boolean.parseBoolean(args[0]);\n+\n+        Subject subject = new Subject();\n+        subject.getPrincipals().add(new UserPrincipal(\"Duke\"));\n+\n+        \/\/ Always observable in the same thread\n+        Subject.callAs(subject, () -> check(0, Subject.current(), \"Duke\"));\n+\n+        \/\/ Observable in a new platform thread in ACC mode, but not in the SV mode\n+        Subject.callAs(subject, () -> {\n+            Thread.ofPlatform().start(() -> check(1, Subject.current(), usv ? null : \"Duke\")).join();\n+            return null;\n+        });\n+\n+        \/\/ Never observable in a new virtual thread\n+        Subject.callAs(subject, () -> {\n+            Thread.ofVirtual().start(() -> check(2, Subject.current(), null)).join();\n+            return null;\n+        });\n+\n+        \/\/ Observable in structured concurrency in SV mode, but not in ACC mode\n+        Subject.callAs(subject, () -> {\n+            try (var scope = new StructuredTaskScope<>()) {\n+                scope.fork(() -> check(3, Subject.current(), usv ? \"Duke\" : null));\n+                scope.join();\n+            }\n+            return null;\n+        });\n+\n+        \/\/ Suggested way to pass the current subject into arbitrary\n+        \/\/ threads. Grab one using current() and explicitly pass it\n+        \/\/ into the new thread.\n+        Subject.callAs(subject, () -> {\n+            Subject current = Subject.current();\n+            Thread.ofPlatform().start(() -> {\n+                Subject.callAs(current, () -> check(4, Subject.current(), \"Duke\"));\n+            }).join();\n+            return null;\n+        });\n+\n+        if (results.size() != 5 || results.containsValue(false)) {\n+            System.out.println(results);\n+            throw new RuntimeException(\"Failed\");\n+        }\n+    }\n+\n+    static String check(int type, Subject current, String expected) {\n+        String actual;\n+        if (current == null) {\n+            actual = null;\n+        } else {\n+            var set = current.getPrincipals(UserPrincipal.class);\n+            actual = set.isEmpty()\n+                    ? null\n+                    : set.iterator().next().getName();\n+        }\n+        results.put(type, Objects.equals(actual, expected));\n+        return actual;\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CallAsWithScopedValue.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.SubjectDomainCombiner;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8296244\n+ * @run main\/othervm -Djava.security.manager=allow Compat\n+ * @summary ensures the old implementation still works when SM is allowed\n+ *\/\n+public class Compat {\n+\n+    static PrivilegedExceptionAction<AccessControlContext> action\n+            = () -> AccessController.getContext();\n+\n+    static boolean failed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        main0(null);\n+        var t = new Thread(() -> {\n+            try {\n+                main0(null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+        t.start();\n+        t.join();\n+    }\n+    public static void main0(String[] args) throws Exception {\n+        System.out.println(\">>> bare run\");\n+        run(null);\n+        System.out.println(\">>> run inside\");\n+        Subject subject = makeSubject(\"three\");\n+        Subject.doAs(subject, (PrivilegedExceptionAction<? extends Object>)\n+                () -> run(\"three\"));\n+        if (failed) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    public static Void run(String from) throws Exception {\n+        Subject subject = makeSubject(\"one\");\n+        var a1 = Subject.doAs(subject, action);\n+        Subject subject2 = makeSubject(\"two\");\n+        var a2 = Subject.doAs(subject2, action);\n+\n+        test(\"from ether\", AccessController.getContext(), from);\n+        test(\"from a1\", a1, \"one\");\n+        test(\"from a2\", a2, \"two\");\n+\n+        var a3 = Subject.doAsPrivileged(subject, action, a1);\n+        test(\"doAsPriv with one and a1\", a3, \"one\");\n+\n+        var a4 = Subject.doAsPrivileged(subject, action, a2);\n+        test(\"doAsPriv with one and a2\", a4, \"one\");\n+\n+        var a5 = Subject.doAsPrivileged(null, action, a2);\n+        test(\"doAsPriv with null and a2\", a5, null);\n+\n+        var a6 = Subject.doAs(null, action);\n+        test(\"doAsPriv with null and this\", a6, null);\n+\n+        var ax = new AccessControlContext(a2, new SubjectDomainCombiner(subject));\n+        test(\"a2 plus subject\", ax, \"one\");\n+\n+            ax = AccessController.doPrivileged(action, a2);\n+            test(\"doPriv on a2\", ax, \"two\");\n+\n+        ax = AccessController.doPrivilegedWithCombiner(action);\n+        test(\"doPrivWC\", ax, from == null ? null : from);\n+\n+        ax = AccessController.doPrivilegedWithCombiner(action, a2);\n+        test(\"doPrivWC on a2\", ax, from == null ? \"two\" : from);\n+        return null;\n+    }\n+\n+    static Subject makeSubject(String name) {\n+        Subject subject = new Subject();\n+        subject.getPrincipals().add(new UserPrincipal(name));\n+        return subject;\n+    }\n+\n+    static String getSubject(AccessControlContext acc) {\n+        var subj = Subject.getSubject(acc);\n+        if (subj == null) return null;\n+        var princ = subj.getPrincipals(UserPrincipal.class);\n+        return (princ == null || princ.isEmpty())\n+                ? null\n+                : princ.iterator().next().getName();\n+    }\n+\n+    static void test(String label, AccessControlContext acc, String expected) {\n+        var actual = getSubject(acc);\n+        System.out.println(label + \": \" + actual);\n+        if (!Objects.equals(actual, expected)) {\n+            System.out.println(\"    Expect \" + expected + \", but see \" + actual);\n+            failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/Compat.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import java.security.AccessController;\n@@ -28,2 +27,1 @@\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.security.PrivilegedExceptionAction;\n@@ -35,1 +33,2 @@\n- * @run main\/othervm CurrentSubject\n+ * @run main\/othervm -Djava.security.manager=allow CurrentSubject\n+ * @run main\/othervm -Djava.security.manager=disallow CurrentSubject\n@@ -39,3 +38,1 @@\n-    static transient boolean failed = false;\n-    static CountDownLatch cl = new CountDownLatch(1);\n-    static AtomicInteger count = new AtomicInteger();\n+    static boolean failed = false;\n@@ -46,1 +43,0 @@\n-        cl.await();\n@@ -60,6 +56,0 @@\n-        Subject accs = Subject.getSubject(AccessController.getContext());\n-        if (cas != accs) {\n-            failed = true;\n-            System.out.println(label + \": current \" + s2s(cas)\n-                    + \" but getSubject is \" + s2s(accs));\n-        }\n@@ -92,0 +82,7 @@\n+            Subject.doAsPrivileged(another, (PrivilegedAction<Void>) () -> test(name + 'e', another), null);\n+            try {\n+                Subject.doAs(another, (PrivilegedExceptionAction<Void>) () -> test(name + 'f', another));\n+                Subject.doAsPrivileged(another, (PrivilegedExceptionAction<Void>) () -> test(name + 'g', another), null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n@@ -95,22 +92,7 @@\n-            \/\/ new thread, inside current subject is unchanged\n-            count.incrementAndGet();\n-            new Thread(() -> {\n-                try {\n-                    test(name + 't', expected);\n-                    try {\n-                        Thread.sleep(500);\n-                    } catch (Exception e) {\n-                        throw new AssertionError(e);\n-                    }\n-                    \/\/ by this time, parent thread should have exited the\n-                    \/\/ action and current subject reset, but here\n-                    \/\/ current subject unchanged.\n-                    test(name + 'T', expected);\n-                } finally {\n-                    var n = count.decrementAndGet();\n-                    if (n == 0) {\n-                        cl.countDown();\n-                    }\n-                    assert n >= 0;\n-                }\n-            }).start();\n+            Subject.doAsPrivileged(null, (PrivilegedAction<Void>) () -> test(name + 'E', null), null);\n+            try {\n+                Subject.doAs(null, (PrivilegedExceptionAction<Void>) () -> test(name + 'F', null));\n+                Subject.doAsPrivileged(null, (PrivilegedExceptionAction<Void>) () -> test(name + 'G', null), null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CurrentSubject.java","additions":19,"deletions":37,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @run main\/othervm -Djava.security.manager=disallow FromACC\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/FromACC.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296244\n+ * @library \/test\/lib\n+ * @summary Implement Subject.current and Subject.callAs using scoped values\n+ * @run main\/othervm -Djava.security.manager=disallow UnsupportedSV t1\n+ * @run main\/othervm -Djava.security.manager=allow UnsupportedSV t2\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+import jdk.test.lib.Utils;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.SubjectDomainCombiner;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+public class UnsupportedSV {\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"t1\" -> t1();\n+            case \"t2\" -> t2();\n+        }\n+    }\n+\n+    \/\/ ScopedValue-based implementation is used\n+    static void t1() throws Exception {\n+        AccessControlContext acc = AccessController.getContext();\n+        Utils.runAndCheckException(() -> Subject.getSubject(acc),\n+                UnsupportedOperationException.class);\n+\n+        Subject s = new Subject();\n+        s.getPrincipals().add(new UserPrincipal(\"Duke\"));\n+\n+        \/\/ TODO: Still has no way to reject the following code.\n+        \/\/ Here, AccessController::getContext returns a plain ACC without\n+        \/\/ the subject inside.\n+        AccessControlContext acc2 = Subject.callAs(s, AccessController::getContext);\n+        Subject ns = AccessController.doPrivileged(\n+                (PrivilegedAction<Subject>) Subject::current, acc2);\n+        System.out.println(ns);\n+    }\n+\n+    \/\/ When a security manager is set, ScopedValue-based implementation\n+    \/\/ will not be used\n+    static void t2() {\n+        AccessControlContext acc = AccessController.getContext();\n+        Subject.getSubject(acc);\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/UnsupportedSV.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}