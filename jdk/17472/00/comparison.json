{"files":[{"patch":"@@ -2690,0 +2690,5 @@\n+\n+            @Override\n+            public boolean allowSecurityManager() {\n+                return System.allowSecurityManager();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -93,0 +94,34 @@\n+ * <h2>Deprecated Methods and Replacements<\/h2>\n+ *\n+ * <p> The following methods in this class for user-based authorization\n+ * that are dependent on Security Manager APIs are deprecated for removal:\n+ * <ul>\n+ *     <li>{@link #getSubject(AccessControlContext)}\n+ *     <li>{@link #doAs(Subject, PrivilegedAction)}\n+ *     <li>{@link #doAs(Subject, PrivilegedExceptionAction)}\n+ *     <li>{@link #doAsPrivileged(Subject, PrivilegedAction, AccessControlContext)}\n+ *     <li>{@link #doAsPrivileged(Subject, PrivilegedExceptionAction, AccessControlContext)}\n+ * <\/ul>\n+ * Methods {@link #current()} and {@link #callAs(Subject, Callable)}\n+ * are replacements for these methods, where {@code current}\n+ * is mostly equivalent to {@code getSubject(AccessController.getContext())}\n+ * and {@code callAs} is similar to {@code doAs} except that the\n+ * input type and exceptions thrown are slightly different.\n+ *\n+ * <p><b><a id=\"sm-not-allowed\">These methods behave differently depending on\n+ * whether a security manager is allowed or disallowed<\/a><\/b>:\n+ * <ul>\n+*  <li>If a security manager is not allowed, which means it\n+ * {@linkplain System#setSecurityManager is not set and not allowed to be set\n+ * dynamically}, a {@code doAs} or {@code callAs} call binds a {@code Subject}\n+ * object to the period of execution of an action, and the subject can be\n+ * retrieved using the {@code current} method inside the action. This subject\n+ * can be inherited by child threads if they are started and terminate within\n+ * the execution of its parent thread using structured concurrency.\n+ * <li>If a security manager is allowed, which means it is either already set\n+ * or allowed to be set dynamically, a {@code Subject} object is associated\n+ * with an {@code AccessControlContext} through a {@code doAs} or\n+ * {@code callAs} call, and the subject can then be retrieved using the\n+ * {@code getSubject(AccessControlContext)} method.\n+ * <\/ul>\n+ *\n@@ -261,1 +296,3 @@\n-     * {@code AccessControlContext}.\n+     * {@code AccessControlContext}. When a security manager is\n+     * <a href=#sm-not-allowed>not allowed<\/a>, this method is not supported\n+     * and throws an {@code UnsupportedOperationException}.\n@@ -276,0 +313,3 @@\n+     * @throws UnsupportedOperationException if a security manager is\n+     *          <a href=#sm-not-allowed>not allowed<\/a>\n+     *\n@@ -305,12 +345,16 @@\n-        \/\/ return the Subject from the DomainCombiner of the provided context\n-        return AccessController.doPrivileged\n-            (new java.security.PrivilegedAction<>() {\n-            public Subject run() {\n-                DomainCombiner dc = acc.getDomainCombiner();\n-                if (!(dc instanceof SubjectDomainCombiner)) {\n-                    return null;\n-                }\n-                SubjectDomainCombiner sdc = (SubjectDomainCombiner)dc;\n-                return sdc.getSubject();\n-            }\n-        });\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            throw new UnsupportedOperationException(\"getSubject is supported only if a security manager is allowed\");\n+        } else {\n+            \/\/ return the Subject from the DomainCombiner of the provided context\n+            return AccessController.doPrivileged\n+                    (new java.security.PrivilegedAction<>() {\n+                        public Subject run() {\n+                            DomainCombiner dc = acc.getDomainCombiner();\n+                            if (!(dc instanceof SubjectDomainCombiner)) {\n+                                return null;\n+                            }\n+                            SubjectDomainCombiner sdc = (SubjectDomainCombiner) dc;\n+                            return sdc.getSubject();\n+                        }\n+                    });\n+        }\n@@ -319,0 +363,3 @@\n+    private static final ScopedValue<Subject> SCOPED_SUBJECT =\n+            ScopedValue.newInstance();\n+\n@@ -328,7 +375,5 @@\n-     *\n-     * @implNote\n-     * This method returns the same value as\n-     * {@code Subject.getSubject(AccessController.getContext())}. This\n-     * preserves compatibility with code that may still be calling {@code doAs}\n-     * which installs the subject in an {@code AccessControlContext}. This\n-     * behavior is subject to change in a future version.\n+     * <p>\n+     * If a security manager is <a href=#sm-not-allowed>not allowed<\/a>, the\n+     * current subject binds to the period of the execution of the current\n+     * thread. Otherwise, it is associated with the current\n+     * {@code AccessControlContext}.\n@@ -343,1 +388,5 @@\n-        return getSubject(AccessController.getContext());\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            return SCOPED_SUBJECT.orElse(null);\n+        } else {\n+            return getSubject(AccessController.getContext());\n+        }\n@@ -350,10 +399,13 @@\n-     * @implNote\n-     * This method calls {@link #doAs(Subject, PrivilegedExceptionAction)\n-     * Subject.doAs(subject, altAction)} which stores the subject in\n-     * a new {@code AccessControlContext}, where {@code altAction.run()}\n-     * is equivalent to {@code action.call()} and the exception thrown is\n-     * modified to match the specification of this method. This preserves\n-     * compatibility with code that may still be calling\n-     * {@code getSubject(AccessControlContext)} which retrieves the subject\n-     * from an {@code AccessControlContext}. This behavior is subject\n-     * to change in a future version.\n+     * <p> If a security manager is <a href=#sm-not-allowed>not allowed<\/a>,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n+     * <p> Otherwise, this method first retrieves the\n+     * current Thread's {@code AccessControlContext} via\n+     * {@code AccessController.getContext},\n+     * and then instantiates a new {@code AccessControlContext}\n+     * using the retrieved context along with a new\n+     * {@code SubjectDomainCombiner} (constructed using\n+     * the provided {@code Subject}).\n+     * Finally, this method invokes {@code AccessController.doPrivileged},\n+     * passing it the provided {@code PrivilegedAction},\n+     * as well as the newly constructed {@code AccessControlContext}.\n@@ -378,9 +430,17 @@\n-        try {\n-            PrivilegedExceptionAction<T> pa = () -> action.call();\n-            @SuppressWarnings(\"removal\")\n-            var result = doAs(subject, pa);\n-            return result;\n-        } catch (PrivilegedActionException e) {\n-            throw new CompletionException(e.getCause());\n-        } catch (Exception e) {\n-            throw new CompletionException(e);\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return ScopedValue.callWhere(SCOPED_SUBJECT, subject, action);\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n+        } else {\n+            try {\n+                PrivilegedExceptionAction<T> pa = () -> action.call();\n+                @SuppressWarnings(\"removal\")\n+                var result = doAs(subject, pa);\n+                return result;\n+            } catch (PrivilegedActionException e) {\n+                throw new CompletionException(e.getCause());\n+            } catch (Exception e) {\n+                throw new CompletionException(e);\n+            }\n@@ -393,1 +453,4 @@\n-     * <p> This method first retrieves the current Thread's\n+     * <p> If a security manager is <a href=#sm-not-allowed>not allowed<\/a>,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n+     * <p> Otherwise, this method first retrieves the current Thread's\n@@ -447,8 +510,23 @@\n-        \/\/ set up the new Subject-based AccessControlContext\n-        \/\/ for doPrivileged\n-        final AccessControlContext currentAcc = AccessController.getContext();\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, currentAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else {\n+                    throw new AssertionError(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext\n+            \/\/ for doPrivileged\n+            final AccessControlContext currentAcc = AccessController.getContext();\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, currentAcc));\n+        }\n@@ -460,1 +538,4 @@\n-     * <p> This method first retrieves the current Thread's\n+     * <p> If a security manager is <a href=#sm-not-allowed>not allowed<\/a>,\n+     * this method launches {@code action} and binds {@code subject} to the\n+     * period of its execution.\n+     * <p> Otherwise, this method first retrieves the current Thread's\n@@ -520,7 +601,24 @@\n-        \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n-        final AccessControlContext currentAcc = AccessController.getContext();\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, currentAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else if (cause instanceof Exception e) {\n+                    throw new PrivilegedActionException(e);\n+                } else {\n+                    throw new PrivilegedActionException(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n+            final AccessControlContext currentAcc = AccessController.getContext();\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, currentAcc));\n+        }\n@@ -532,1 +630,4 @@\n-     * <p> This method behaves exactly as {@code Subject.doAs},\n+     * <p> If a security manager is <a href=#sm-not-allowed>not allowed<\/a>,\n+     * this method ignores the {@code acc} argument, launches {@code action},\n+     * and binds {@code subject} to the period of its execution.\n+     * <p> Otherwise, this method behaves exactly as {@code Subject.doAs},\n@@ -586,11 +687,26 @@\n-        \/\/ set up the new Subject-based AccessControlContext\n-        \/\/ for doPrivileged\n-        final AccessControlContext callerAcc =\n-                (acc == null ?\n-                new AccessControlContext(NULL_PD_ARRAY) :\n-                acc);\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, callerAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else {\n+                    throw new AssertionError(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext\n+            \/\/ for doPrivileged\n+            final AccessControlContext callerAcc =\n+                    (acc == null ?\n+                            new AccessControlContext(NULL_PD_ARRAY) :\n+                            acc);\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, callerAcc));\n+        }\n@@ -602,1 +718,4 @@\n-     * <p> This method behaves exactly as {@code Subject.doAs},\n+     * <p> If a security manager is <a href=#sm-not-allowed>not allowed<\/a>,\n+     * this method ignores the {@code acc} argument, launches {@code action},\n+     * and binds {@code subject} to the period of its execution.\n+     * <p> Otherwise, this method behaves exactly as {@code Subject.doAs},\n@@ -662,10 +781,27 @@\n-        \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n-        final AccessControlContext callerAcc =\n-                (acc == null ?\n-                new AccessControlContext(NULL_PD_ARRAY) :\n-                acc);\n-\n-        \/\/ call doPrivileged and push this new context on the stack\n-        return java.security.AccessController.doPrivileged\n-                                        (action,\n-                                        createContext(subject, callerAcc));\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            try {\n+                return callAs(subject, action::run);\n+            } catch (CompletionException ce) {\n+                var cause = ce.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                } else if (cause instanceof Error er) {\n+                    throw er;\n+                } else if (cause instanceof Exception e) {\n+                    throw new PrivilegedActionException(e);\n+                } else {\n+                    throw new PrivilegedActionException(ce);\n+                }\n+            }\n+        } else {\n+            \/\/ set up the new Subject-based AccessControlContext for doPrivileged\n+            final AccessControlContext callerAcc =\n+                    (acc == null ?\n+                            new AccessControlContext(NULL_PD_ARRAY) :\n+                            acc);\n+\n+            \/\/ call doPrivileged and push this new context on the stack\n+            return java.security.AccessController.doPrivileged\n+                    (action,\n+                            createContext(subject, callerAcc));\n+        }\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/Subject.java","additions":216,"deletions":80,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -589,0 +589,6 @@\n+\n+    \/**\n+     * Is a security manager already set or allowed to be set\n+     * (using -Djava.security.manager=allow)?\n+     *\/\n+    boolean allowSecurityManager();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-        return Subject.getSubject(AccessController.getContext());\n+        return Subject.current();\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ServerNotifForwarder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AccessControlContext;\n@@ -304,2 +303,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc = AccessController.getContext();\n@@ -310,1 +307,1 @@\n-                        return Subject.getSubject(acc);\n+                        return Subject.current();\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/MBeanServerFileAccessController.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.security.AccessController;\n@@ -70,1 +69,1 @@\n-            Subject subject = Subject.getSubject(AccessController.getContext());\n+            Subject subject = Subject.current();\n","filename":"test\/jdk\/javax\/management\/monitor\/ThreadPoolAccTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -155,2 +153,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/SimpleStandard.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n@@ -153,2 +151,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/subjectDelegation\/SimpleStandard.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296244\n+ * @enablePreview\n+ * @summary Implement Subject.current and Subject.callAs using scoped values\n+ * @run main\/othervm -Djava.security.manager=allow CallAsWithScopedValue false\n+ * @run main\/othervm -Djava.security.manager=disallow CallAsWithScopedValue true\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+\n+import javax.security.auth.Subject;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.StructuredTaskScope;\n+\n+public class CallAsWithScopedValue {\n+\n+    private static Map results = new ConcurrentHashMap<Integer,Boolean>();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        boolean usv = Boolean.parseBoolean(args[0]);\n+\n+        Subject subject = new Subject();\n+        subject.getPrincipals().add(new UserPrincipal(\"Duke\"));\n+\n+        \/\/ Always observable in the same thread\n+        Subject.callAs(subject, () -> check(0, Subject.current(), \"Duke\"));\n+\n+        \/\/ Observable in the same thread in ACC mode, but not in the SV mode\n+        Subject.callAs(subject, () -> {\n+            Thread.ofPlatform().start(() -> check(1, Subject.current(), usv ? null : \"Duke\")).join();\n+            return null;\n+        });\n+\n+        \/\/ Never observable in a new virtual thread\n+        Subject.callAs(subject, () -> {\n+            Thread.ofVirtual().start(() -> check(2, Subject.current(), null)).join();\n+            return null;\n+        });\n+\n+        \/\/ Observable in structured concurrency in SV mode, but not in ACC mode\n+        Subject.callAs(subject, () -> {\n+            try (var scope = new StructuredTaskScope<>()) {\n+                scope.fork(() -> check(3, Subject.current(), usv ? \"Duke\" : null));\n+                scope.join();\n+            }\n+            return null;\n+        });\n+\n+        \/\/ Suggested way to pass the current subject into arbitrary\n+        \/\/ threads. Grab one using current() and explicitly pass it\n+        \/\/ into the new thread.\n+        Subject.callAs(subject, () -> {\n+            Subject current = Subject.current();\n+            Thread.ofPlatform().start(() -> {\n+                Subject.callAs(current, () -> check(4, Subject.current(), \"Duke\"));\n+            }).join();\n+            return null;\n+        });\n+\n+        if (results.size() != 5 || results.containsValue(false)) {\n+            System.out.println(results);\n+            throw new RuntimeException(\"Failed\");\n+        }\n+    }\n+\n+    static String check(int type, Subject current, String expected) {\n+        String actual;\n+        if (current == null) {\n+            actual = null;\n+        } else {\n+            var set = current.getPrincipals(UserPrincipal.class);\n+            actual = set.isEmpty()\n+                    ? null\n+                    : set.iterator().next().getName();\n+        }\n+        results.put(type, Objects.equals(actual, expected));\n+        return actual;\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CallAsWithScopedValue.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.SubjectDomainCombiner;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @run main\/othervm -Djava.security.manager=allow Compat\n+ *\/\n+public class Compat {\n+\n+\/\/    static PrivilegedAction<AccessControlContext> action\n+\/\/            = () -> AccessController.getContext();\n+\n+    static PrivilegedExceptionAction<AccessControlContext> action\n+            = () -> AccessController.getContext();\n+\n+    static boolean failed = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        main0(null);\n+        var t = new Thread(() -> {\n+            try {\n+                main0(null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+        t.start();\n+        t.join();\n+    }\n+    public static void main0(String[] args) throws Exception {\n+        System.out.println(\">>> bare run\");\n+        run(null);\n+        System.out.println(\">>> run inside\");\n+        Subject subject = makeSubject(\"three\");\n+        Subject.doAs(subject, (PrivilegedExceptionAction<? extends Object>)\n+                () -> run(\"three\"));\n+        if (failed) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    public static Void run(String from) throws Exception {\n+        Subject subject = makeSubject(\"one\");\n+        var a1 = Subject.doAs(subject, action);\n+        Subject subject2 = makeSubject(\"two\");\n+        var a2 = Subject.doAs(subject2, action);\n+\n+        test(\"from ether\", AccessController.getContext(), from);\n+        test(\"from a1\", a1, \"one\");\n+        test(\"from a2\", a2, \"two\");\n+\n+        var a3 = Subject.doAsPrivileged(subject, action, a1);\n+        test(\"doAsPriv with one and a1\", a3, \"one\");\n+\n+        var a4 = Subject.doAsPrivileged(subject, action, a2);\n+        test(\"doAsPriv with one and a2\", a4, \"one\");\n+\n+        var a5 = Subject.doAsPrivileged(null, action, a2);\n+        test(\"doAsPriv with null and a2\", a5, null);\n+\n+        var a6 = Subject.doAs(null, action);\n+        test(\"doAsPriv with null and this\", a6, null);\n+\n+        var ax = new AccessControlContext(a2, new SubjectDomainCombiner(subject));\n+        test(\"a2 plus subject\", ax, \"one\");\n+\n+            ax = AccessController.doPrivileged(action, a2);\n+            test(\"doPriv on a2\", ax, \"two\");\n+\n+        ax = AccessController.doPrivilegedWithCombiner(action);\n+        test(\"doPrivWC\", ax, from == null ? null : from);\n+\n+        ax = AccessController.doPrivilegedWithCombiner(action, a2);\n+        test(\"doPrivWC on a2\", ax, from == null ? \"two\" : from);\n+        return null;\n+    }\n+\n+    static Subject makeSubject(String name) {\n+        Subject subject = new Subject();\n+        subject.getPrincipals().add(new UserPrincipal(name));\n+        return subject;\n+    }\n+\n+    static String getSubject(AccessControlContext acc) {\n+        var subj = Subject.getSubject(acc);\n+        if (subj == null) return null;\n+        var princ = subj.getPrincipals(UserPrincipal.class);\n+        return (princ == null || princ.isEmpty())\n+                ? null\n+                : princ.iterator().next().getName();\n+    }\n+\n+    static void test(String label, AccessControlContext acc, String expected) {\n+        var actual = getSubject(acc);\n+        System.out.println(label + \": \" + actual);\n+        if (!Objects.equals(actual, expected)) {\n+            System.out.println(\"    Expect \" + expected + \", but see \" + actual);\n+            failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/Compat.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import java.security.AccessController;\n@@ -28,2 +27,1 @@\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.security.PrivilegedExceptionAction;\n@@ -35,1 +33,2 @@\n- * @run main\/othervm CurrentSubject\n+ * @run main\/othervm -Djava.security.manager=allow CurrentSubject\n+ * @run main\/othervm -Djava.security.manager=disallow CurrentSubject\n@@ -39,3 +38,1 @@\n-    static transient boolean failed = false;\n-    static CountDownLatch cl = new CountDownLatch(1);\n-    static AtomicInteger count = new AtomicInteger();\n+    static boolean failed = false;\n@@ -46,1 +43,0 @@\n-        cl.await();\n@@ -60,6 +56,0 @@\n-        Subject accs = Subject.getSubject(AccessController.getContext());\n-        if (cas != accs) {\n-            failed = true;\n-            System.out.println(label + \": current \" + s2s(cas)\n-                    + \" but getSubject is \" + s2s(accs));\n-        }\n@@ -92,0 +82,7 @@\n+            Subject.doAsPrivileged(another, (PrivilegedAction<Void>) () -> test(name + 'e', another), null);\n+            try {\n+                Subject.doAs(another, (PrivilegedExceptionAction<Void>) () -> test(name + 'f', another));\n+                Subject.doAsPrivileged(another, (PrivilegedExceptionAction<Void>) () -> test(name + 'g', another), null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n@@ -95,22 +92,7 @@\n-            \/\/ new thread, inside current subject is unchanged\n-            count.incrementAndGet();\n-            new Thread(() -> {\n-                try {\n-                    test(name + 't', expected);\n-                    try {\n-                        Thread.sleep(500);\n-                    } catch (Exception e) {\n-                        throw new AssertionError(e);\n-                    }\n-                    \/\/ by this time, parent thread should have exited the\n-                    \/\/ action and current subject reset, but here\n-                    \/\/ current subject unchanged.\n-                    test(name + 'T', expected);\n-                } finally {\n-                    var n = count.decrementAndGet();\n-                    if (n == 0) {\n-                        cl.countDown();\n-                    }\n-                    assert n >= 0;\n-                }\n-            }).start();\n+            Subject.doAsPrivileged(null, (PrivilegedAction<Void>) () -> test(name + 'E', null), null);\n+            try {\n+                Subject.doAs(null, (PrivilegedExceptionAction<Void>) () -> test(name + 'F', null));\n+                Subject.doAsPrivileged(null, (PrivilegedExceptionAction<Void>) () -> test(name + 'G', null), null);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CurrentSubject.java","additions":18,"deletions":36,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n- * @run main\/othervm -Djava.security.manager=disallow FromACC\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/FromACC.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296244\n+ * @library \/test\/lib\n+ * @summary Implement Subject.current and Subject.callAs using scoped values\n+ * @run main\/othervm -Djava.security.manager=disallow UnsupportedSV t1\n+ * @run main\/othervm -Djava.security.manager=allow UnsupportedSV t2\n+ *\/\n+import com.sun.security.auth.UserPrincipal;\n+import jdk.test.lib.Utils;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.SubjectDomainCombiner;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+public class UnsupportedSV {\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"t1\" -> t1();\n+            case \"t2\" -> t2();\n+        }\n+    }\n+\n+    \/\/ ScopedValue-based implementation is used\n+    static void t1() throws Exception {\n+        AccessControlContext acc = AccessController.getContext();\n+        Utils.runAndCheckException(() -> Subject.getSubject(acc),\n+                UnsupportedOperationException.class);\n+\n+        Subject s = new Subject();\n+        s.getPrincipals().add(new UserPrincipal(\"Duke\"));\n+\n+        \/\/ TODO: Still has no way to reject the following code.\n+        \/\/ Here, AccessController::getContext returns a plan ACC without\n+        \/\/ the subject inside.\n+        AccessControlContext acc2 = Subject.callAs(s, AccessController::getContext);\n+        Subject ns = AccessController.doPrivileged(\n+                (PrivilegedAction<Subject>) Subject::current, acc2);\n+        System.out.println(ns);\n+    }\n+\n+    \/\/ When a security manager is set, ScopedValue-based implementation\n+    \/\/ will not be used\n+    static void t2() {\n+        AccessControlContext acc = AccessController.getContext();\n+        Subject.getSubject(acc);\n+    }\n+}\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/UnsupportedSV.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.AccessControlContext;\n@@ -31,1 +30,0 @@\n-import java.security.AccessController;\n@@ -285,2 +283,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -297,2 +294,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -328,2 +324,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -353,2 +348,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -372,2 +366,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject s = Subject.getSubject(acc);\n+        Subject s = Subject.current();\n@@ -393,2 +386,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -425,2 +417,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -452,2 +443,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject s = Subject.getSubject(acc);\n+        Subject s = Subject.current();\n@@ -483,2 +473,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -503,2 +492,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Subject.current();\n@@ -518,2 +506,1 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject s = Subject.getSubject(acc);\n+        Subject s = Subject.current();\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/doAs\/NestedActions.java","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"}]}