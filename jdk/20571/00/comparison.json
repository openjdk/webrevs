{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.internal.net.http.common.Log;\n@@ -495,1 +496,1 @@\n-    private void removeFromPool(HttpConnection c) {\n+    private boolean removeFromPool(HttpConnection c) {\n@@ -498,1 +499,1 @@\n-            removeFromPool(c, plainPool);\n+            return removeFromPool(c, plainPool);\n@@ -501,1 +502,1 @@\n-            removeFromPool(c, sslPool);\n+            return removeFromPool(c, sslPool);\n@@ -532,0 +533,1 @@\n+        boolean removed;\n@@ -533,1 +535,1 @@\n-            removeFromPool(c);\n+            removed = removeFromPool(c);\n@@ -538,1 +540,16 @@\n-        c.close();\n+        if (!removed) {\n+            \/\/ this should not happen; the cleanup may have consumed\n+            \/\/ some data that wasn't supposed to be consumed, so\n+            \/\/ the only thing we can do is log it and close the\n+            \/\/ connection.\n+            if (Log.errors()) {\n+                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing {0}\", c);\n+            } else if (debug.on()) {\n+                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing %s\", c);\n+            }\n+            c.close(new IOException(\"Unexpected cleanup triggered for non pooled connection\"));\n+        } else {\n+            c.close();\n+        }\n@@ -552,0 +569,1 @@\n+        private volatile boolean dropped;\n@@ -569,0 +587,1 @@\n+            if (dropped || done) return;\n@@ -589,0 +608,5 @@\n+\n+        @Override\n+        public void dropSubscription() {\n+            dropped = true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,0 +576,2 @@\n+                \/\/ make sure no data will be routed to the old subscriber.\n+                previous.stopReading();\n@@ -609,0 +611,1 @@\n+            volatile boolean stopped;\n@@ -626,1 +629,1 @@\n-                if (!cancelled) {\n+                if (!cancelled && !stopped) {\n@@ -630,1 +633,1 @@\n-                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n@@ -664,0 +667,14 @@\n+\n+            \/**\n+             * Called when switching subscriber on the {@link InternalReadSubscription}.\n+             * This subscriber is the old subscriber. Demand on the internal\n+             * subscription will be reset and reading will be paused until the\n+             * new subscriber is subscribed.\n+             * This should ensure that no data is routed to this subscriber\n+             * until the new subscriber is subscribed.\n+             *\/\n+            void stopReading() {\n+                stopped = true;\n+                impl.demand.reset();\n+                impl.pauseReadEvent();\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112\n+ * @bug 8087112 8336655\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}