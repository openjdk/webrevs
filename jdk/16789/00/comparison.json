{"files":[{"patch":"@@ -1650,1 +1650,1 @@\n-     *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?<\/a>.\n+     *       is Thread.stop deprecated and the ability to stop a thread removed?<\/a>.\n@@ -1791,38 +1791,0 @@\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @throws  UnsupportedOperationException always\n-     *\n-     * @deprecated This method was originally specified to suspend a thread.\n-     *     It was inherently deadlock-prone. If the target thread held a lock on\n-     *     a monitor protecting a critical system resource when it was suspended,\n-     *     no thread could access the resource until the target thread was resumed.\n-     *     If the thread intending to resume the target thread attempted to lock\n-     *     the monitor prior to calling {@code resume}, deadlock would result.\n-     *     Such deadlocks typically manifested themselves as \"frozen\" processes.\n-     *     For more information, see\n-     *     <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n-     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?<\/a>.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void suspend() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @throws  UnsupportedOperationException always\n-     *\n-     * @deprecated This method was originally specified to resume a thread\n-     *     suspended with {@link #suspend()}. Suspending a thread was\n-     *     inherently deadlock-prone.\n-     *     For more information, see\n-     *     <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html\">Why\n-     *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?<\/a>.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void resume() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":1,"deletions":39,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,22 +590,0 @@\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @deprecated This method was originally specified to suspend all threads\n-     *             in the thread group.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void suspend() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/**\n-     * Throws {@code UnsupportedOperationException}.\n-     *\n-     * @deprecated This method was originally specified to resume all threads\n-     *             in the thread group.\n-     *\/\n-    @Deprecated(since=\"1.2\", forRemoval=true)\n-    public final void resume() {\n-        throw new UnsupportedOperationException();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadGroup.java","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,168 +161,0 @@\n-<hr>\n-<h2>Why are <code>Thread.suspend<\/code> and\n-<code>Thread.resume<\/code> deprecated and the ability to suspend or\n-resume a thread removed?<\/h2>\n-<p><code>Thread.suspend<\/code> was inherently deadlock-prone. If the\n-target thread held a lock on a monitor protecting a critical\n-system resource when it is suspended, no thread could access the\n-resource until the target thread was resumed. If the thread intending\n-to resume the target thread attempted to lock the monitor prior\n-to calling <code>resume<\/code>, deadlock resulted. Such deadlocks\n-typically manifest themselves as \"frozen\" processes.<\/p>\n-<hr>\n-<h2>What should I use instead of <code>Thread.suspend<\/code> and\n-<code>Thread.resume<\/code>?<\/h2>\n-<p>As with <code>Thread.stop<\/code>, the prudent approach is to\n-have the \"target thread\" poll a variable indicating the desired\n-state of the thread (active or suspended). When the desired state\n-is suspended, the thread waits using <code>Object.wait<\/code>. When\n-the thread is resumed, the target thread is notified using\n-<code>Object.notify<\/code>.<\/p>\n-<p>For example, suppose your applet contains the following\n-mousePressed event handler, which toggles the state of a thread\n-called <code>blinker<\/code>:<\/p>\n-<pre>\n-    private boolean threadSuspended;\n-\n-    Public void mousePressed(MouseEvent e) {\n-        e.consume();\n-\n-        if (threadSuspended)\n-            blinker.resume();\n-        else\n-            blinker.suspend();  \/\/ DEADLOCK-PRONE!\n-\n-        threadSuspended = !threadSuspended;\n-    }\n-<\/pre>\n-You can avoid the use of <code>Thread.suspend<\/code> and\n-<code>Thread.resume<\/code> by replacing the event handler above\n-with:\n-<pre>\n-    public synchronized void mousePressed(MouseEvent e) {\n-        e.consume();\n-\n-        threadSuspended = !threadSuspended;\n-\n-        if (!threadSuspended)\n-            notify();\n-    }\n-<\/pre>\n-and adding the following code to the \"run loop\":\n-<pre>\n-                synchronized(this) {\n-                    while (threadSuspended)\n-                        wait();\n-                }\n-<\/pre>\n-The <code>wait<\/code> method throws the\n-<code>InterruptedException<\/code>, so it must be inside a <code>try\n-... catch<\/code> clause. It's fine to put it in the same clause as\n-the <code>sleep<\/code>. The check should follow (rather than\n-precede) the <code>sleep<\/code> so the window is immediately\n-repainted when the thread is \"resumed.\" The resulting\n-<code>run<\/code> method follows:\n-<pre>\n-    public void run() {\n-        while (true) {\n-            try {\n-                Thread.sleep(interval);\n-\n-                synchronized(this) {\n-                    while (threadSuspended)\n-                        wait();\n-                }\n-            } catch (InterruptedException e){\n-            }\n-            repaint();\n-        }\n-    }\n-<\/pre>\n-Note that the <code>notify<\/code> in the <code>mousePressed<\/code>\n-method and the <code>wait<\/code> in the <code>run<\/code> method are\n-inside <code>synchronized<\/code> blocks. This is required by the\n-language, and ensures that <code>wait<\/code> and\n-<code>notify<\/code> are properly serialized. In practical terms,\n-this eliminates race conditions that could cause the \"suspended\"\n-thread to miss a <code>notify<\/code> and remain suspended\n-indefinitely.\n-<p>While the cost of synchronization in Java is decreasing as the\n-platform matures, it will never be free. A simple trick can be used\n-to remove the synchronization that we've added to each iteration of\n-the \"run loop.\" The synchronized block that was added is replaced\n-by a slightly more complex piece of code that enters a synchronized\n-block only if the thread has actually been suspended:<\/p>\n-<pre>\n-                if (threadSuspended) {\n-                    synchronized(this) {\n-                        while (threadSuspended)\n-                            wait();\n-                    }\n-                }\n-<\/pre>\n-<p>In the absence of explicit synchronization,\n-<code>threadSuspended<\/code> must be made <code>volatile<\/code> to ensure\n-prompt communication of the suspend-request.<\/p>\n-The resulting <code>run<\/code> method is:\n-<pre>\n-    private volatile boolean threadSuspended;\n-\n-    public void run() {\n-        while (true) {\n-            try {\n-                Thread.sleep(interval);\n-\n-                if (threadSuspended) {\n-                    synchronized(this) {\n-                        while (threadSuspended)\n-                            wait();\n-                    }\n-                }\n-            } catch (InterruptedException e){\n-            }\n-            repaint();\n-        }\n-    }\n-<\/pre>\n-<hr>\n-<h2>Can I combine the two techniques to produce a thread that may\n-be safely \"stopped\" or \"suspended\"?<\/h2>\n-Yes, it's reasonably straightforward. The one subtlety is that the\n-target thread may already be suspended at the time that another\n-thread tries to stop it. If the <code>stop<\/code> method merely sets\n-the state variable (<code>blinker<\/code>) to null, the target thread\n-will remain suspended (waiting on the monitor), rather than exiting\n-gracefully as it should. If the applet is restarted, multiple\n-threads could end up waiting on the monitor at the same time,\n-resulting in erratic behavior.\n-<p>To rectify this situation, the <code>stop<\/code> method must ensure\n-that the target thread resumes immediately if it is suspended. Once\n-the target thread resumes, it must recognize immediately that it\n-has been stopped, and exit gracefully. Here's how the resulting\n-<code>run<\/code> and <code>stop<\/code> methods look:<\/p>\n-<pre>\n-    public void run() {\n-        Thread thisThread = Thread.currentThread();\n-        while (blinker == thisThread) {\n-            try {\n-                Thread.sleep(interval);\n-\n-                synchronized(this) {\n-                    while (threadSuspended &amp;&amp; blinker==thisThread)\n-                        wait();\n-                }\n-            } catch (InterruptedException e){\n-            }\n-            repaint();\n-        }\n-    }\n-\n-    public synchronized void stop() {\n-        blinker = null;\n-        notify();\n-    }\n-<\/pre>\n-If the <code>stop<\/code> method calls <code>Thread.interrupt<\/code>, as\n-described above, it needn't call <code>notify<\/code> as well, but it\n-still must be synchronized. This ensures that the target thread\n-won't miss an interrupt due to a race condition.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":1,"deletions":169,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -535,3 +535,2 @@\n-     * Tests if the thread associated with this {@code ThreadInfo}\n-     * is suspended.  This method returns {@code true} if\n-     * {@link Thread#suspend} has been called.\n+     * Tests if the thread associated with this {@code ThreadInfo} is\n+     * <a href=\"{@docRoot}\/..\/specs\/jvmti.html#SuspendThread\">suspended<\/a>.\n@@ -541,0 +540,2 @@\n+     *\n+     * @spec jvmti.html JVM Tool Interface\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ThreadInfo.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug  8289610 8249627 8205132\n- * @summary Test that Thread stop\/suspend\/resume throw UOE\n- * @run junit DegradedMethodsThrowUOE\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class DegradedMethodsThrowUOE {\n-\n-    \/**\n-     * Returns a stream of operations on a Thread that should throw UOE.\n-     *\/\n-    static Stream<Consumer<Thread>> ops() {\n-        return Stream.<Consumer<Thread>>of(\n-                Thread::stop,\n-                Thread::suspend,\n-                Thread::resume\n-        );\n-    }\n-\n-    \/**\n-     * Test degraded method on current thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"ops\")\n-    void testCurrentThread(Consumer<Thread> op) {\n-        var thread = Thread.currentThread();\n-        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n-    }\n-\n-    \/**\n-     * Test degraded method on an unstarted thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"ops\")\n-    void testUnstartedThread(Consumer<Thread> op) {\n-        Thread thread = new Thread(() -> { });\n-        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n-        assertTrue(thread.getState() == Thread.State.NEW);\n-    }\n-\n-    \/**\n-     * Test degraded method on a thread spinning in a loop.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"ops\")\n-    void testRunnableThread(Consumer<Thread> op) throws Exception {\n-        AtomicBoolean done = new AtomicBoolean();\n-        Thread thread = new Thread(() -> {\n-            while (!done.get()) {\n-                Thread.onSpinWait();\n-            }\n-        });\n-        thread.start();\n-        try {\n-            assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n-\n-            \/\/ thread should not terminate\n-            boolean terminated = thread.join(Duration.ofMillis(500));\n-            assertFalse(terminated);\n-        } finally {\n-            done.set(true);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test degraded method on a thread that is parked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"ops\")\n-    void testWaitingThread(Consumer<Thread> op) throws Exception {\n-        Thread thread = new Thread(LockSupport::park);\n-        thread.start();\n-        try {\n-            \/\/ wait for thread to park\n-            while ((thread.getState() != Thread.State.WAITING)) {\n-                Thread.sleep(10);\n-            }\n-            assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n-            assertTrue(thread.getState() == Thread.State.WAITING);\n-        } finally {\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test degraded method on a terminated thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"ops\")\n-    void testTerminatedThread(Consumer<Thread> op) throws Exception {\n-        Thread thread = new Thread(() -> { });\n-        thread.start();\n-        thread.join();\n-        assertThrows(UnsupportedOperationException.class, () -> op.accept(thread));\n-        assertTrue(thread.getState() == Thread.State.TERMINATED);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/DegradedMethodsThrowUOE.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8289610 8249627 8205132 8320532\n+ * @summary Test that Thread stops throws UOE\n+ * @run junit ThreadStopTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ThreadStopTest {\n+\n+    \/**\n+     * Test current thread calling Thread.stop on itself.\n+     *\/\n+    @Test\n+    void testCurrentThread() {\n+        var thread = Thread.currentThread();\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+    }\n+\n+    \/**\n+     * Test Thread.stop on an unstarted thread.\n+     *\/\n+    @Test\n+    void testUnstartedThread() {\n+        Thread thread = new Thread(() -> { });\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+        assertTrue(thread.getState() == Thread.State.NEW);\n+    }\n+\n+    \/**\n+     * Test Thread.stop on a thread spinning in a loop.\n+     *\/\n+    @Test\n+    void testRunnableThread() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        Thread thread = new Thread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        thread.start();\n+        try {\n+            assertThrows(UnsupportedOperationException.class, thread::stop);\n+\n+            \/\/ thread should not terminate\n+            boolean terminated = thread.join(Duration.ofMillis(500));\n+            assertFalse(terminated);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread.stop on a thread that is parked.\n+     *\/\n+    @Test\n+    void testWaitingThread() throws Exception {\n+        Thread thread = new Thread(LockSupport::park);\n+        thread.start();\n+        try {\n+            \/\/ wait for thread to park\n+            while ((thread.getState() != Thread.State.WAITING)) {\n+                Thread.sleep(10);\n+            }\n+            assertThrows(UnsupportedOperationException.class, thread::stop);\n+            assertTrue(thread.getState() == Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread.stop on a terminated thread.\n+     *\/\n+    @Test\n+    void testTerminatedThread() throws Exception {\n+        Thread thread = new Thread(() -> { });\n+        thread.start();\n+        thread.join();\n+        assertThrows(UnsupportedOperationException.class, thread::stop);\n+        assertTrue(thread.getState() == Thread.State.TERMINATED);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/ThreadStopTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -276,58 +276,0 @@\n-    \/**\n-     * Test Thread::suspend from current thread.\n-     *\/\n-    @Test\n-    void testSuspend1() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            assertThrows(UnsupportedOperationException.class, t::suspend);\n-        });\n-    }\n-\n-    \/**\n-     * Test Thread::suspend from another thread.\n-     *\/\n-    @Test\n-    void testSuspend2() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try {\n-                Thread.sleep(20*1000);\n-            } catch (InterruptedException e) { }\n-        });\n-        try {\n-            assertThrows(UnsupportedOperationException.class, () -> thread.suspend());\n-        } finally {\n-            thread.interrupt();\n-            thread.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Thread::resume from current thread.\n-     *\/\n-    @Test\n-    void testResume1() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            assertThrows(UnsupportedOperationException.class, t::resume);\n-        });\n-    }\n-\n-    \/**\n-     * Test Thread::resume from another thread.\n-     *\/\n-    @Test\n-    void testResume2() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> {\n-            try {\n-                Thread.sleep(20*1000);\n-            } catch (InterruptedException e) { }\n-        });\n-        try {\n-            assertThrows(UnsupportedOperationException.class, () -> thread.resume());\n-        } finally {\n-            thread.interrupt();\n-            thread.join();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -735,12 +735,0 @@\n-    @Test\n-    void testSuspend() {\n-        ThreadGroup group = new ThreadGroup(\"foo\");\n-        assertThrows(UnsupportedOperationException.class, () -> group.suspend());\n-    }\n-\n-    @Test\n-    void testResume() {\n-        ThreadGroup group = new ThreadGroup(\"foo\");\n-        assertThrows(UnsupportedOperationException.class, () -> group.resume());\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/ThreadGroup\/BasicTests.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-            Thread.currentThread().suspend();\n+            while (true) {\n+                Thread.sleep(60_000);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/SendUrgentData.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}