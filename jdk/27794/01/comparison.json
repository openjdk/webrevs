{"files":[{"patch":"@@ -87,4 +87,0 @@\n-  virtual bool card_mark_must_follow_store() const {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1394,1 +1394,0 @@\n-  bs->initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  barrier_set->initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -185,1 +185,0 @@\n-  bs->initialize();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  _defer_initial_card_mark(false),\n@@ -69,1 +68,0 @@\n-  _defer_initial_card_mark(false),\n@@ -73,4 +71,0 @@\n-void CardTableBarrierSet::initialize() {\n-  initialize_deferred_card_mark_barriers();\n-}\n-\n@@ -111,3 +105,1 @@\n-\/\/     that this barrier need only be applied to a non-young write,\n-\/\/     but, because of the presence of concurrent refinement,\n-\/\/     must strictly follow the oop-store.\n+\/\/     that this barrier need only be applied to a non-young write.\n@@ -123,2 +115,0 @@\n-  \/\/ If a previous card-mark was deferred, flush it now.\n-  flush_deferred_card_mark_barrier(thread);\n@@ -133,7 +123,2 @@\n-    if (_defer_initial_card_mark) {\n-      \/\/ Defer the card mark\n-      thread->set_deferred_card_mark(mr);\n-    } else {\n-      \/\/ Do the card mark\n-      write_region(mr);\n-    }\n+    \/\/ Do the card mark\n+    write_region(mr);\n@@ -142,50 +127,1 @@\n-}\n-\n-void CardTableBarrierSet::initialize_deferred_card_mark_barriers() {\n-  \/\/ Used for ReduceInitialCardMarks (when COMPILER2 or JVMCI is used);\n-  \/\/ otherwise remains unused.\n-#if COMPILER2_OR_JVMCI\n-  _defer_initial_card_mark = CompilerConfig::is_c2_or_jvmci_compiler_enabled() && ReduceInitialCardMarks\n-                             && (DeferInitialCardMark || card_mark_must_follow_store());\n-#else\n-  assert(_defer_initial_card_mark == false, \"Who would set it?\");\n-#endif\n-}\n-\n-void CardTableBarrierSet::flush_deferred_card_mark_barrier(JavaThread* thread) {\n-#if COMPILER2_OR_JVMCI\n-  MemRegion deferred = thread->deferred_card_mark();\n-  if (!deferred.is_empty()) {\n-    assert(_defer_initial_card_mark, \"Otherwise should be empty\");\n-    {\n-      \/\/ Verify that the storage points to a parsable object in heap\n-      DEBUG_ONLY(oop old_obj = cast_to_oop(deferred.start());)\n-      assert(!_card_table->is_in_young(old_obj),\n-             \"Else should have been filtered in on_slowpath_allocation_exit()\");\n-      assert(oopDesc::is_oop(old_obj), \"Not an oop\");\n-      assert(deferred.word_size() == old_obj->size(),\n-             \"Mismatch: multiple objects?\");\n-    }\n-    write_region(thread, deferred);\n-    \/\/ \"Clear\" the deferred_card_mark field\n-    thread->set_deferred_card_mark(MemRegion());\n-  }\n-  assert(thread->deferred_card_mark().is_empty(), \"invariant\");\n-#else\n-  assert(!_defer_initial_card_mark, \"Should be false\");\n-  assert(thread->deferred_card_mark().is_empty(), \"Should be empty\");\n-#endif\n-}\n-\n-void CardTableBarrierSet::on_thread_detach(Thread* thread) {\n-  \/\/ The deferred store barriers must all have been flushed to the\n-  \/\/ card-table (or other remembered set structure) before GC starts\n-  \/\/ processing the card-table (or other remembered set).\n-  if (thread->is_Java_thread()) { \/\/ Only relevant for Java threads.\n-    flush_deferred_card_mark_barrier(JavaThread::cast(thread));\n-  }\n-}\n-\n-bool CardTableBarrierSet::card_mark_must_follow_store() const {\n-  return false;\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":4,"deletions":68,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-  \/\/ Used in support of ReduceInitialCardMarks; only consulted if COMPILER2\n-  \/\/ or INCLUDE_JVMCI is being used\n-  bool       _defer_initial_card_mark;\n@@ -67,2 +64,0 @@\n-  void initialize();\n-\n@@ -73,1 +68,0 @@\n- public:\n@@ -83,19 +77,0 @@\n-  \/\/ ReduceInitialCardMarks\n-  void initialize_deferred_card_mark_barriers();\n-\n-  \/\/ If the CollectedHeap was asked to defer a store barrier above,\n-  \/\/ this informs it to flush such a deferred store barrier to the\n-  \/\/ remembered set.\n-  void flush_deferred_card_mark_barrier(JavaThread* thread);\n-\n-  \/\/ If a compiler is eliding store barriers for TLAB-allocated objects,\n-  \/\/ we will be informed of a slow-path allocation by a call\n-  \/\/ to on_slowpath_allocation_exit() below. Such a call precedes the\n-  \/\/ initialization of the object itself, and no post-store-barriers will\n-  \/\/ be issued. Some heap types require that the barrier strictly follows\n-  \/\/ the initializing stores. (This is currently implemented by deferring the\n-  \/\/ barrier until the next slow-path allocation or gc-related safepoint.)\n-  \/\/ This interface answers whether a particular barrier type needs the card\n-  \/\/ mark to be thus strictly sequenced after the stores.\n-  virtual bool card_mark_must_follow_store() const;\n-\n@@ -103,3 +78,0 @@\n-  virtual void on_thread_detach(Thread* thread);\n-\n-  virtual void make_parsable(JavaThread* thread) { flush_deferred_card_mark_barrier(thread); }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -421,4 +421,0 @@\n-  product(bool, DeferInitialCardMark, false, DIAGNOSTIC,                    \\\n-          \"When +ReduceInitialCardMarks, explicitly defer any that \"        \\\n-          \"may arise from new_pre_store_barrier\")                           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  nonstatic_field(CardTableBarrierSet,         _defer_initial_card_mark,                      bool)                                  \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}