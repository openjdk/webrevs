{"files":[{"patch":"@@ -219,0 +219,4 @@\n+  \/\/ The 24 rounds of the keccak transformation.\n+  \/\/ The implementation closely follows the Java version, with the state\n+  \/\/ array \"rows\" in the lowest 5 64-bit slots of zmm0 - zmm4, i.e.\n+  \/\/ each row of the SHA3 specification is located in one zmm register.\n@@ -220,1 +224,1 @@\n-  __ subl( roundsLeft, 1);\n+  __ subl(roundsLeft, 1);\n@@ -223,0 +227,1 @@\n+  \/\/ vpternlogq(x, 150, y, z) does x = x ^ y ^ z\n@@ -225,0 +230,3 @@\n+  \/\/ Now the \"c row\", i.e. c0-c4 are in zmm5.\n+  \/\/ Rotate each element of the c row by one bit to zmm6, call the\n+  \/\/ rotated version c'.\n@@ -226,0 +234,2 @@\n+  \/\/ Rotate elementwise the c row so that c4 becomes c0,\n+  \/\/ c0 becomes c1, etc.\n@@ -227,0 +237,2 @@\n+  \/\/ rotate elementwise the c' row so that c'0 becomes c'4,\n+  \/\/ c'1 becomes c'0, etc.\n@@ -233,0 +245,5 @@\n+  \/\/ Now the theta mapping has been finished.\n+\n+  \/\/ Do the cyclical permutation of the 24 moving state elements\n+  \/\/ and the required rotations within each element (the combined\n+  \/\/ rho and sigma steps).\n@@ -238,0 +255,2 @@\n+  \/\/ The 24 moving elements are now in zmm1, zmm3 and zmm4,\n+  \/\/ do the rotations now.\n@@ -252,0 +271,1 @@\n+  \/\/ The combined rho and sigma steps are done.\n@@ -253,0 +273,2 @@\n+  \/\/ Do the chi step (the same operation on all 5 rows).\n+  \/\/ vpternlogq(x, 180, y, z) does x = x ^ (y & ~z).\n@@ -261,0 +283,1 @@\n+  \/\/ xor the round constant into a0 (the lowest 64 bits of zmm0\n@@ -271,0 +294,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}