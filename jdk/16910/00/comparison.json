{"files":[{"patch":"@@ -761,0 +761,2 @@\n+  INSN(amocas_w,  0b0101111, 0b010, 0b00101);\n+  INSN(amocas_d,  0b0101111, 0b011, 0b00101);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+  product(bool, UseZacas, false, EXPERIMENTAL, \"Use Zacas instructions\")         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2627,14 +2627,21 @@\n-  Label retry_load, nope;\n-  bind(retry_load);\n-  \/\/ Load reserved from the memory location\n-  load_reserved(tmp, addr, int64, Assembler::aqrl);\n-  \/\/ Fail and exit if it is not what we expect\n-  bne(tmp, oldv, nope);\n-  \/\/ If the store conditional succeeds, tmp will be zero\n-  store_conditional(tmp, newv, addr, int64, Assembler::rl);\n-  beqz(tmp, succeed);\n-  \/\/ Retry only when the store conditional failed\n-  j(retry_load);\n-\n-  bind(nope);\n-  membar(AnyAny);\n+  if (UseZacas) {\n+    mv(tmp, oldv);\n+    atomic_cas(tmp, newv, addr, Assembler::int64, Assembler::aq, Assembler::rl);\n+    beq(tmp, oldv, succeed);\n+  } else {\n+    Label retry_load, nope;\n+    bind(retry_load);\n+    \/\/ Load reserved from the memory location\n+    load_reserved(tmp, addr, int64, Assembler::aqrl);\n+    \/\/ Fail and exit if it is not what we expect\n+    bne(tmp, oldv, nope);\n+    \/\/ If the store conditional succeeds, tmp will be zero\n+    store_conditional(tmp, newv, addr, int64, Assembler::rl);\n+    beqz(tmp, succeed);\n+    \/\/ Retry only when the store conditional failed\n+    j(retry_load);\n+\n+    bind(nope);\n+    membar(AnyAny);\n+  }\n+\n@@ -2714,1 +2721,1 @@\n-  xori(not_mask, mask, -1);\n+  notr(not_mask, mask);\n@@ -2724,1 +2731,1 @@\n-\/\/ It's designed to implement compare and swap byte\/boolean\/char\/short by lr.w\/sc.w,\n+\/\/ It's designed to implement compare and swap byte\/boolean\/char\/short by lr.w\/sc.w or amocas.w,\n@@ -2739,3 +2746,0 @@\n-  lr_w(old, aligned_addr, acquire);\n-  andr(tmp, old, mask);\n-  bne(tmp, expected, fail);\n@@ -2743,4 +2747,22 @@\n-  andr(tmp, old, not_mask);\n-  orr(tmp, tmp, new_val);\n-  sc_w(tmp, tmp, aligned_addr, release);\n-  bnez(tmp, retry);\n+  if (UseZacas) {\n+    lw(old, aligned_addr);\n+\n+    \/\/ if old & mask != expected\n+    andr(tmp, old, mask);\n+    bne(tmp, expected, fail);\n+\n+    andr(tmp, old, not_mask);\n+    orr(tmp, tmp, new_val);\n+\n+    atomic_cas(old, tmp, aligned_addr, size, acquire, release);\n+    bne(tmp, old, retry);\n+  } else {\n+    lr_w(old, aligned_addr, acquire);\n+    andr(tmp, old, mask);\n+    bne(tmp, expected, fail);\n+\n+    andr(tmp, old, not_mask);\n+    orr(tmp, tmp, new_val);\n+    sc_w(tmp, tmp, aligned_addr, release);\n+    bnez(tmp, retry);\n+  }\n@@ -2786,3 +2808,9 @@\n-  lr_w(old, aligned_addr, acquire);\n-  andr(tmp, old, mask);\n-  bne(tmp, expected, fail);\n+  if (UseZacas) {\n+    lw(old, aligned_addr);\n+\n+    \/\/ if old & mask != expected\n+    andr(tmp, old, mask);\n+    bne(tmp, expected, fail);\n+\n+    andr(tmp, old, not_mask);\n+    orr(tmp, tmp, new_val);\n@@ -2790,4 +2818,12 @@\n-  andr(tmp, old, not_mask);\n-  orr(tmp, tmp, new_val);\n-  sc_w(tmp, tmp, aligned_addr, release);\n-  bnez(tmp, fail);\n+    atomic_cas(tmp, new_val, addr, size, acquire, release);\n+    bne(tmp, old, fail);\n+  } else {\n+    lr_w(old, aligned_addr, acquire);\n+    andr(tmp, old, mask);\n+    bne(tmp, expected, fail);\n+\n+    andr(tmp, old, not_mask);\n+    orr(tmp, tmp, new_val);\n+    sc_w(tmp, tmp, aligned_addr, release);\n+    bnez(tmp, fail);\n+  }\n@@ -2816,0 +2852,15 @@\n+  if (UseZacas) {\n+    if (result_as_bool) {\n+      mv(t0, expected);\n+      atomic_cas(t0, new_val, addr, size, acquire, release);\n+      xorr(t0, t0, expected);\n+      seqz(result, t0);\n+    } else {\n+      if (result != expected) {\n+        mv(result, expected);\n+      }\n+      atomic_cas(result, new_val, addr, size, acquire, release);\n+    }\n+    return;\n+  }\n+\n@@ -2847,0 +2898,5 @@\n+  if (UseZacas) {\n+    cmpxchg(addr, expected, new_val, size, acquire, release, result, false);\n+    return;\n+  }\n+\n@@ -2913,0 +2969,83 @@\n+#define ATOMIC_CAS(OP, AOP, ACQUIRE, RELEASE)                                        \\\n+void MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) {      \\\n+  assert(UseZacas, \"invariant\");                                                     \\\n+  prev = prev->is_valid() ? prev : zr;                                               \\\n+  AOP(prev, addr, newv, (Assembler::Aqrl)(ACQUIRE | RELEASE));                       \\\n+  return;                                                                            \\\n+}\n+\n+ATOMIC_CAS(cas, amocas_d, Assembler::relaxed, Assembler::relaxed)\n+ATOMIC_CAS(casw, amocas_w, Assembler::relaxed, Assembler::relaxed)\n+ATOMIC_CAS(casl, amocas_d, Assembler::relaxed, Assembler::rl)\n+ATOMIC_CAS(caslw, amocas_w, Assembler::relaxed, Assembler::rl)\n+ATOMIC_CAS(casal, amocas_d, Assembler::aq, Assembler::rl)\n+ATOMIC_CAS(casalw, amocas_w, Assembler::aq, Assembler::rl)\n+\n+#undef ATOMIC_CAS\n+\n+#define ATOMIC_CASU(OP1, OP2)                                                       \\\n+void MacroAssembler::atomic_##OP1(Register prev, Register newv, Register addr) {     \\\n+  atomic_##OP2(prev, newv, addr);                                                    \\\n+  zero_extend(prev, prev, 32);                                                       \\\n+  return;                                                                            \\\n+}\n+\n+ATOMIC_CASU(caswu, casw)\n+ATOMIC_CASU(caslwu, caslw)\n+ATOMIC_CASU(casalwu, casalw)\n+\n+#undef ATOMIC_CASU\n+\n+void MacroAssembler::atomic_cas(\n+    Register prev, Register newv, Register addr, enum operand_size size, Assembler::Aqrl acquire, Assembler::Aqrl release) {\n+  switch (size) {\n+    case int64:\n+      switch ((Assembler::Aqrl)(acquire | release)) {\n+        case Assembler::relaxed:\n+          atomic_cas(prev, newv, addr);\n+          break;\n+        case Assembler::rl:\n+          atomic_casl(prev, newv, addr);\n+          break;\n+        case Assembler::aqrl:\n+          atomic_casal(prev, newv, addr);\n+          break;\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      break;\n+    case int32:\n+      switch ((Assembler::Aqrl)(acquire | release)) {\n+        case Assembler::relaxed:\n+          atomic_casw(prev, newv, addr);\n+          break;\n+        case Assembler::rl:\n+          atomic_caslw(prev, newv, addr);\n+          break;\n+        case Assembler::aqrl:\n+          atomic_casalw(prev, newv, addr);\n+          break;\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      break;\n+    case uint32:\n+      switch ((Assembler::Aqrl)(acquire | release)) {\n+        case Assembler::relaxed:\n+          atomic_caswu(prev, newv, addr);\n+          break;\n+        case Assembler::rl:\n+          atomic_caslwu(prev, newv, addr);\n+          break;\n+        case Assembler::aqrl:\n+          atomic_casalwu(prev, newv, addr);\n+          break;\n+        default:\n+          ShouldNotReachHere();\n+      }\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":169,"deletions":30,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -1060,0 +1060,13 @@\n+  void atomic_cas(Register prev, Register newv, Register addr);\n+  void atomic_casw(Register prev, Register newv, Register addr);\n+  void atomic_casl(Register prev, Register newv, Register addr);\n+  void atomic_caslw(Register prev, Register newv, Register addr);\n+  void atomic_casal(Register prev, Register newv, Register addr);\n+  void atomic_casalw(Register prev, Register newv, Register addr);\n+  void atomic_caswu(Register prev, Register newv, Register addr);\n+  void atomic_caslwu(Register prev, Register newv, Register addr);\n+  void atomic_casalwu(Register prev, Register newv, Register addr);\n+\n+  void atomic_cas(Register prev, Register newv, Register addr, enum operand_size size,\n+              Assembler::Aqrl acquire = Assembler::relaxed, Assembler::Aqrl release = Assembler::relaxed);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+  decl(ext_Zacas       , \"Zacas\"       , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZacas))       \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}