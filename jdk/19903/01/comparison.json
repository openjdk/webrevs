{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -42,1 +41,0 @@\n-import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;\n@@ -70,2 +68,0 @@\n-import javax.lang.model.type.TypeKind;\n-\n@@ -3906,331 +3902,0 @@\n-    @Override\n-    public void visitReference(JCMemberReference tree) {\n-        if (needsConversionToLambda(tree)) {\n-            \/\/ Convert to a lambda, and process as such\n-            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n-            result = translate(conv.lambda());\n-        } else {\n-            super.visitReference(tree);\n-        }\n-    }\n-    \/\/ where\n-        boolean needsVarArgsConversion(JCMemberReference tree) {\n-            return tree.varargsElement != null;\n-        }\n-\n-        \/**\n-         * @return Is this an array operation like clone()\n-         *\/\n-        boolean isArrayOp(JCMemberReference tree) {\n-            return tree.sym.owner == syms.arrayClass;\n-        }\n-\n-        boolean receiverAccessible(JCMemberReference tree) {\n-            \/\/hack needed to workaround 292 bug (7087658)\n-            \/\/when 292 issue is fixed we should remove this and change the backend\n-            \/\/code to always generate a method handle to an accessible method\n-            return tree.ownerAccessible;\n-        }\n-\n-        \/**\n-         * Erasure destroys the implementation parameter subtype\n-         * relationship for intersection types.\n-         * Have similar problems for union types too.\n-         *\/\n-        boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n-            List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n-            for (; tl.nonEmpty(); tl = tl.tail) {\n-                Type pt = tl.head;\n-                if (isIntersectionOrUnionType(pt))\n-                    return true;\n-            }\n-            return false;\n-        }\n-\n-        boolean isIntersectionOrUnionType(Type t) {\n-            switch (t.getKind()) {\n-                case INTERSECTION:\n-                case UNION:\n-                    return true;\n-                case TYPEVAR:\n-                    TypeVar tv = (TypeVar) t;\n-                    return isIntersectionOrUnionType(tv.getUpperBound());\n-            }\n-            return false;\n-        }\n-\n-        private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n-                                                                              Symbol currentClass) {\n-            return ((targetReference.flags() & PROTECTED) != 0 &&\n-                    targetReference.packge() != currentClass.packge());\n-        }\n-\n-        \/**\n-         * This method should be called only when target release <= 14\n-         * where LambdaMetaFactory does not spin nestmate classes.\n-         *\n-         * This method should be removed when --release 14 is not supported.\n-         *\/\n-        boolean isPrivateInOtherClass(JCMemberReference tree) {\n-            assert !target.runtimeUseNestAccess();\n-            return  (tree.sym.flags() & PRIVATE) != 0 &&\n-                    !types.isSameType(\n-                            types.erasure(tree.sym.enclClass().asType()),\n-                            types.erasure(currentClass.asType()));\n-        }\n-\n-        \/**\n-         * Does this reference need to be converted to a lambda\n-         * (i.e. var args need to be expanded or \"super\" is used)\n-         *\/\n-        boolean needsConversionToLambda(JCMemberReference tree) {\n-            return interfaceParameterIsIntersectionOrUnionType(tree) ||\n-                    tree.hasKind(ReferenceKind.SUPER) ||\n-                    needsVarArgsConversion(tree) ||\n-                    isArrayOp(tree) ||\n-                    (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass) ||\n-                    !receiverAccessible(tree) ||\n-                    (tree.getMode() == ReferenceMode.NEW &&\n-                            tree.kind != ReferenceKind.ARRAY_CTOR &&\n-                            (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n-        }\n-\n-    \/**\n-     * Converts a method reference which cannot be used directly into a lambda\n-     *\/\n-    private class MemberReferenceToLambda {\n-\n-        private final JCMemberReference tree;\n-        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n-        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n-        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, currentClass);\n-\n-        private JCExpression receiverExpression = null;\n-\n-        MemberReferenceToLambda(JCMemberReference tree) {\n-            this.tree = tree;\n-        }\n-\n-        JCExpression lambda() {\n-            int prevPos = make.pos;\n-            try {\n-                make.at(tree);\n-\n-                \/\/body generation - this can be either a method call or a\n-                \/\/new instance creation expression, depending on the member reference kind\n-                VarSymbol rcvr = addParametersReturnReceiver();\n-                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n-                        ? expressionInvoke(rcvr)\n-                        : expressionNew();\n-\n-                JCLambda slam = make.Lambda(params.toList(), expr);\n-                slam.target = tree.target;\n-                slam.type = tree.type;\n-                slam.pos = tree.pos;\n-                slam.wasMethodReference = true;\n-                if (receiverExpression != null) {\n-                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n-                    return make.at(tree.pos).LetExpr(\n-                            make.VarDef(rcvr, translate(receiverExpression)), slam).setType(tree.type);\n-                } else {\n-                    return slam;\n-                }\n-            } finally {\n-                make.at(prevPos);\n-            }\n-        }\n-\n-        \/**\n-         * Generate the parameter list for the converted member reference.\n-         *\n-         * @return The receiver variable symbol, if any\n-         *\/\n-        VarSymbol addParametersReturnReceiver() {\n-            Type samDesc = types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);\n-            List<Type> samPTypes = samDesc.getParameterTypes();\n-            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n-\n-            \/\/ Determine the receiver, if any\n-            VarSymbol rcvr;\n-            switch (tree.kind) {\n-                case BOUND:\n-                    \/\/ The receiver is explicit in the method reference\n-                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n-                    rcvr.pos = tree.pos;\n-                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n-                    break;\n-                case UNBOUND:\n-                    \/\/ The receiver is the first parameter, extract it and\n-                    \/\/ adjust the SAM and unerased type lists accordingly\n-                    rcvr = addParameter(\"rec$\", samDesc.getParameterTypes().head, false);\n-                    samPTypes = samPTypes.tail;\n-                    descPTypes = descPTypes.tail;\n-                    break;\n-                default:\n-                    rcvr = null;\n-                    break;\n-            }\n-            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n-            int implSize = implPTypes.size();\n-            int samSize = samPTypes.size();\n-            \/\/ Last parameter to copy from referenced method, exclude final var args\n-            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n-\n-            \/\/ Failsafe -- assure match-up\n-            boolean checkForIntersection = tree.varargsElement != null || implSize == descPTypes.size();\n-\n-            \/\/ Use parameter types of the implementation method unless the unerased\n-            \/\/ SAM parameter type is an intersection type, in that case use the\n-            \/\/ erased SAM parameter type so that the supertype relationship\n-            \/\/ the implementation method parameters is not obscured.\n-            \/\/ Note: in this loop, the lists implPTypes, samPTypes, and descPTypes\n-            \/\/ are used as pointers to the current parameter type information\n-            \/\/ and are thus not usable afterwards.\n-            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n-                \/\/ By default use the implementation method parameter type\n-                Type parmType = implPTypes.head;\n-                if (checkForIntersection) {\n-                    if (descPTypes.head.getKind() == TypeKind.INTERSECTION) {\n-                        parmType = samPTypes.head;\n-                    }\n-                    \/\/ If the unerased parameter type is a type variable whose\n-                    \/\/ bound is an intersection (eg. <T extends A & B>) then\n-                    \/\/ use the SAM parameter type\n-                    if (descPTypes.head.getKind() == TypeKind.TYPEVAR) {\n-                        TypeVar tv = (TypeVar) descPTypes.head;\n-                        if (tv.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-                            parmType = samPTypes.head;\n-                        }\n-                    }\n-                }\n-                addParameter(\"x$\" + i, parmType, true);\n-\n-                \/\/ Advance to the next parameter\n-                implPTypes = implPTypes.tail;\n-                samPTypes = samPTypes.tail;\n-                descPTypes = descPTypes.tail;\n-            }\n-            \/\/ Flatten out the var args\n-            for (int i = last; i < samSize; ++i) {\n-                addParameter(\"xva$\" + i, tree.varargsElement, true);\n-            }\n-\n-            return rcvr;\n-        }\n-\n-        private JCExpression makeReceiver(VarSymbol rcvr) {\n-            if (rcvr == null) return null;\n-            JCExpression rcvrExpr = make.Ident(rcvr);\n-            boolean protAccess =\n-                    isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, currentClass);\n-            Type rcvrType = tree.ownerAccessible && !protAccess ? tree.sym.enclClass().type\n-                    : tree.expr.type;\n-            if (rcvrType == syms.arrayClass.type) {\n-                \/\/ Map the receiver type to the actually type, not just \"array\"\n-                rcvrType = tree.getQualifierExpression().type;\n-            }\n-            if (!rcvr.type.tsym.isSubClass(rcvrType.tsym, types)) {\n-                rcvrExpr = make.TypeCast(make.Type(rcvrType), rcvrExpr).setType(rcvrType);\n-            }\n-            return rcvrExpr;\n-        }\n-\n-        \/**\n-         * determine the receiver of the method call - the receiver can\n-         * be a type qualifier, the synthetic receiver parameter or 'super'.\n-         *\/\n-        private JCExpression expressionInvoke(VarSymbol rcvr) {\n-            JCExpression qualifier =\n-                    (rcvr != null) ?\n-                            makeReceiver(rcvr) :\n-                            tree.getQualifierExpression();\n-\n-            \/\/create the qualifier expression\n-            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n-            select.sym = tree.sym;\n-            select.type = tree.sym.erasure(types);\n-\n-            \/\/create the method call expression\n-            JCExpression apply = make.Apply(List.nil(), select,\n-                            convertArgs(tree.sym, args.toList(), tree.varargsElement)).\n-                    setType(tree.sym.erasure(types).getReturnType());\n-\n-            apply = transTypes.coerce(attrEnv, apply,\n-                    types.erasure(tree.referentType.getReturnType()));\n-\n-            setVarargsIfNeeded(apply, tree.varargsElement);\n-            return apply;\n-        }\n-\n-        \/**\n-         * Lambda body to use for a 'new'.\n-         *\/\n-        private JCExpression expressionNew() {\n-            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n-                \/\/create the array creation expression\n-                JCNewArray newArr = make.NewArray(\n-                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n-                        List.of(make.Ident(params.first())),\n-                        null);\n-                newArr.type = tree.getQualifierExpression().type;\n-                return newArr;\n-            } else {\n-                \/\/create the instance creation expression\n-                \/\/note that method reference syntax does not allow an explicit\n-                \/\/enclosing class (so the enclosing class is null)\n-                \/\/ but this may need to be patched up later with the proxy for the outer this\n-                JCNewClass newClass = make.NewClass(null,\n-                        List.nil(),\n-                        make.Type(tree.getQualifierExpression().type),\n-                        convertArgs(tree.sym, args.toList(), tree.varargsElement),\n-                        null);\n-                newClass.constructor = tree.sym;\n-                newClass.constructorType = tree.sym.erasure(types);\n-                newClass.type = tree.getQualifierExpression().type;\n-                setVarargsIfNeeded(newClass, tree.varargsElement);\n-                return newClass;\n-            }\n-        }\n-\n-        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n-            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n-            vsym.pos = tree.pos;\n-            params.append(make.VarDef(vsym, null));\n-            if (genArg) {\n-                args.append(make.Ident(vsym));\n-            }\n-            return vsym;\n-        }\n-    }\n-\n-    \/**\n-     * Convert method\/constructor arguments by inserting appropriate cast\n-     * as required by type-erasure - this is needed when bridging a lambda\/method\n-     * reference, as the bridged signature might require downcast to be compatible\n-     * with the generated signature.\n-     *\/\n-    private List<JCExpression> convertArgs(Symbol meth, List<JCExpression> args, Type varargsElement) {\n-        Assert.check(meth.kind == MTH);\n-        List<Type> formals = types.erasure(meth.type).getParameterTypes();\n-        if (varargsElement != null) {\n-            Assert.check((meth.flags() & VARARGS) != 0);\n-        }\n-        return transTypes.translateArgs(args, formals, varargsElement, attrEnv);\n-    }\n-\n-    \/**\n-     * Set varargsElement field on a given tree (must be either a new class tree\n-     * or a method call tree)\n-     *\/\n-    private void setVarargsIfNeeded(JCTree tree, Type varargsElement) {\n-        if (varargsElement != null) {\n-            switch (tree.getTag()) {\n-                case APPLY: ((JCMethodInvocation)tree).varargsElement = varargsElement; break;\n-                case NEWCLASS: ((JCNewClass)tree).varargsElement = varargsElement; break;\n-                case TYPECAST: setVarargsIfNeeded(((JCTypeCast) tree).expr, varargsElement); break;\n-                default: throw new AssertionError();\n-            }\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":0,"deletions":335,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.source.tree.MemberReferenceTree.ReferenceMode;\n@@ -33,0 +34,2 @@\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import com.sun.tools.javac.jvm.Target;\n@@ -49,0 +52,2 @@\n+import javax.lang.model.type.TypeKind;\n+\n@@ -78,0 +83,1 @@\n+    private final Target target;\n@@ -92,0 +98,1 @@\n+        target = Target.instance(context);\n@@ -542,0 +549,262 @@\n+    @Override\n+    public void visitReference(JCMemberReference tree) {\n+        if (needsConversionToLambda(tree)) {\n+            \/\/ Convert to a lambda, and process as such\n+            MemberReferenceToLambda conv = new MemberReferenceToLambda(tree);\n+            result = translate(conv.lambda());\n+        } else {\n+            Type t = types.skipTypeVars(tree.expr.type, false);\n+            Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n+            if (tree.kind == ReferenceKind.UNBOUND) {\n+                tree.expr = make.Type(receiverTarget);\n+            } else {\n+                tree.expr = translate(tree.expr, receiverTarget);\n+            }\n+            if (!tree.type.isIntersection()) {\n+                tree.type = erasure(tree.type);\n+            } else {\n+                tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n+            }\n+            result = tree;\n+        }\n+    }\n+    \/\/ where\n+    boolean needsVarArgsConversion(JCMemberReference tree) {\n+        return tree.varargsElement != null;\n+    }\n+\n+    \/**\n+     * @return Is this an array operation like clone()\n+     *\/\n+    boolean isArrayOp(JCMemberReference tree) {\n+        return tree.sym.owner == syms.arrayClass;\n+    }\n+\n+    boolean receiverAccessible(JCMemberReference tree) {\n+        \/\/hack needed to workaround 292 bug (7087658)\n+        \/\/when 292 issue is fixed we should remove this and change the backend\n+        \/\/code to always generate a method handle to an accessible method\n+        return tree.ownerAccessible;\n+    }\n+\n+    \/**\n+     * Erasure destroys the implementation parameter subtype\n+     * relationship for intersection types.\n+     * Have similar problems for union types too.\n+     *\/\n+    boolean interfaceParameterIsIntersectionOrUnionType(JCMemberReference tree) {\n+        List<Type> tl = tree.getDescriptorType(types).getParameterTypes();\n+        for (; tl.nonEmpty(); tl = tl.tail) {\n+            Type pt = tl.head;\n+            if (isIntersectionOrUnionType(pt))\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    boolean isIntersectionOrUnionType(Type t) {\n+        return switch (t.getKind()) {\n+            case INTERSECTION, UNION -> true;\n+            case TYPEVAR -> {\n+                TypeVar tv = (TypeVar) t;\n+                yield isIntersectionOrUnionType(tv.getUpperBound());\n+            }\n+            default -> false;\n+        };\n+    }\n+\n+    private boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage(Symbol targetReference,\n+                                                                          Symbol currentClass) {\n+        return ((targetReference.flags() & PROTECTED) != 0 &&\n+                targetReference.packge() != currentClass.packge());\n+    }\n+\n+    \/**\n+     * This method should be called only when target release <= 14\n+     * where LambdaMetaFactory does not spin nestmate classes.\n+     *\n+     * This method should be removed when --release 14 is not supported.\n+     *\/\n+    boolean isPrivateInOtherClass(JCMemberReference tree) {\n+        return  (tree.sym.flags() & PRIVATE) != 0 &&\n+                !types.isSameType(\n+                        types.erasure(tree.sym.enclClass().asType()),\n+                        types.erasure(env.enclClass.sym.asType()));\n+    }\n+\n+    \/**\n+     * Does this reference need to be converted to a lambda\n+     * (i.e. var args need to be expanded or \"super\" is used)\n+     *\/\n+    boolean needsConversionToLambda(JCMemberReference tree) {\n+        return interfaceParameterIsIntersectionOrUnionType(tree) ||\n+                tree.hasKind(ReferenceKind.SUPER) ||\n+                needsVarArgsConversion(tree) ||\n+                isArrayOp(tree) ||\n+                (!target.runtimeUseNestAccess() && isPrivateInOtherClass(tree)) ||\n+                isProtectedInSuperClassOfEnclosingClassInOtherPackage(tree.sym, env.enclClass.sym) ||\n+                !receiverAccessible(tree) ||\n+                (tree.getMode() == ReferenceMode.NEW &&\n+                        tree.kind != ReferenceKind.ARRAY_CTOR &&\n+                        (tree.sym.owner.isDirectlyOrIndirectlyLocal() || tree.sym.owner.isInner()));\n+    }\n+\n+    \/**\n+     * Converts a method reference which cannot be used directly into a lambda\n+     *\/\n+    private class MemberReferenceToLambda {\n+\n+        private final JCMemberReference tree;\n+        private final ListBuffer<JCExpression> args = new ListBuffer<>();\n+        private final ListBuffer<JCVariableDecl> params = new ListBuffer<>();\n+        private final MethodSymbol owner = new MethodSymbol(0, names.empty, Type.noType, env.enclClass.sym);\n+\n+        private JCExpression receiverExpression = null;\n+\n+        MemberReferenceToLambda(JCMemberReference tree) {\n+            this.tree = tree;\n+        }\n+\n+        JCExpression lambda() {\n+            int prevPos = make.pos;\n+            try {\n+                make.at(tree);\n+\n+                \/\/body generation - this can be either a method call or a\n+                \/\/new instance creation expression, depending on the member reference kind\n+                VarSymbol rcvr = addParametersReturnReceiver();\n+                JCExpression expr = (tree.getMode() == ReferenceMode.INVOKE)\n+                        ? expressionInvoke(rcvr)\n+                        : expressionNew();\n+\n+                JCLambda slam = make.Lambda(params.toList(), expr);\n+                slam.target = tree.target;\n+                slam.type = tree.type;\n+                slam.pos = tree.pos;\n+                slam.wasMethodReference = true;\n+                if (receiverExpression != null) {\n+                    \/\/ use a let expression so that the receiver expression is evaluated eagerly\n+                    return make.at(tree.pos).LetExpr(\n+                            make.VarDef(rcvr, receiverExpression), slam).setType(tree.type);\n+                } else {\n+                    return slam;\n+                }\n+            } finally {\n+                make.at(prevPos);\n+            }\n+        }\n+\n+        \/**\n+         * Generate the parameter list for the converted member reference.\n+         *\n+         * @return The receiver variable symbol, if any\n+         *\/\n+        VarSymbol addParametersReturnReceiver() {\n+            List<Type> descPTypes = tree.getDescriptorType(types).getParameterTypes();\n+\n+            \/\/ Determine the receiver, if any\n+            VarSymbol rcvr;\n+            switch (tree.kind) {\n+                case BOUND:\n+                    \/\/ The receiver is explicit in the method reference\n+                    rcvr = new VarSymbol(SYNTHETIC, names.fromString(\"rec$\"), tree.getQualifierExpression().type, owner);\n+                    rcvr.pos = tree.pos;\n+                    receiverExpression = attr.makeNullCheck(tree.getQualifierExpression());\n+                    break;\n+                case UNBOUND:\n+                    \/\/ The receiver is the first parameter, extract it and\n+                    \/\/ adjust the SAM and unerased type lists accordingly\n+                    rcvr = addParameter(\"rec$\", descPTypes.head, false);\n+                    descPTypes = descPTypes.tail;\n+                    break;\n+                default:\n+                    rcvr = null;\n+                    break;\n+            }\n+            List<Type> implPTypes = tree.sym.type.getParameterTypes();\n+            int implSize = implPTypes.size();\n+            int samSize = descPTypes.size();\n+            \/\/ Last parameter to copy from referenced method, exclude final var args\n+            int last = needsVarArgsConversion(tree) ? implSize - 1 : implSize;\n+\n+            for (int i = 0; implPTypes.nonEmpty() && i < last; ++i) {\n+                \/\/ Use the descriptor parameter type\n+                Type parmType = descPTypes.head;\n+                addParameter(\"x$\" + i, parmType, true);\n+\n+                \/\/ Advance to the next parameter\n+                implPTypes = implPTypes.tail;\n+                descPTypes = descPTypes.tail;\n+            }\n+            \/\/ Flatten out the var args\n+            for (int i = last; i < samSize; ++i) {\n+                addParameter(\"xva$\" + i, tree.varargsElement, true);\n+            }\n+\n+            return rcvr;\n+        }\n+\n+        \/**\n+         * determine the receiver of the method call - the receiver can\n+         * be a type qualifier, the synthetic receiver parameter or 'super'.\n+         *\/\n+        private JCExpression expressionInvoke(VarSymbol rcvr) {\n+            JCExpression qualifier =\n+                    (rcvr != null) ?\n+                            make.Ident(rcvr) :\n+                            tree.getQualifierExpression();\n+\n+            \/\/create the qualifier expression\n+            JCFieldAccess select = make.Select(qualifier, tree.sym.name);\n+            select.sym = tree.sym;\n+            select.type = tree.referentType;\n+\n+            \/\/create the method call expression\n+            JCExpression apply = make.Apply(List.nil(), select,\n+                            args.toList()).setType(tree.referentType.getReturnType());\n+\n+            TreeInfo.setVarargsElement(apply, tree.varargsElement);\n+            return apply;\n+        }\n+\n+        \/**\n+         * Lambda body to use for a 'new'.\n+         *\/\n+        private JCExpression expressionNew() {\n+            if (tree.kind == ReferenceKind.ARRAY_CTOR) {\n+                \/\/create the array creation expression\n+                JCNewArray newArr = make.NewArray(\n+                        make.Type(types.elemtype(tree.getQualifierExpression().type)),\n+                        List.of(make.Ident(params.first())),\n+                        null);\n+                newArr.type = tree.getQualifierExpression().type;\n+                return newArr;\n+            } else {\n+                \/\/create the instance creation expression\n+                \/\/note that method reference syntax does not allow an explicit\n+                \/\/enclosing class (so the enclosing class is null)\n+                \/\/ but this may need to be patched up later with the proxy for the outer this\n+                JCNewClass newClass = make.NewClass(null,\n+                        List.nil(),\n+                        make.Type(tree.getQualifierExpression().type),\n+                        args.toList(),\n+                        null);\n+                newClass.constructor = tree.sym;\n+                newClass.constructorType = tree.sym.erasure(types);\n+                newClass.type = tree.getQualifierExpression().type;\n+                TreeInfo.setVarargsElement(newClass, tree.varargsElement);\n+                return newClass;\n+            }\n+        }\n+\n+        private VarSymbol addParameter(String name, Type p, boolean genArg) {\n+            VarSymbol vsym = new VarSymbol(PARAMETER | SYNTHETIC, names.fromString(name), p, owner);\n+            vsym.pos = tree.pos;\n+            params.append(make.VarDef(vsym, null));\n+            if (genArg) {\n+                args.append(make.Ident(vsym));\n+            }\n+            return vsym;\n+        }\n+    }\n+\n@@ -863,18 +1132,0 @@\n-    public void visitReference(JCMemberReference tree) {\n-        Type t = types.skipTypeVars(tree.expr.type, false);\n-        Type receiverTarget = t.isCompound() ? erasure(tree.sym.owner.type) : erasure(t);\n-        if (tree.kind == ReferenceKind.UNBOUND) {\n-            tree.expr = make.Type(receiverTarget);\n-        } else {\n-            tree.expr = translate(tree.expr, receiverTarget);\n-        }\n-        if (!tree.type.isIntersection()) {\n-            tree.type = erasure(tree.type);\n-        } else {\n-            tree.type = types.erasure(types.findDescriptorSymbol(tree.type.tsym).owner.type);\n-        }\n-        if (tree.varargsElement != null)\n-            tree.varargsElement = erasure(tree.varargsElement);\n-        result = tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":269,"deletions":18,"binary":false,"changes":287,"status":"modified"}]}