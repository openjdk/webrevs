{"files":[{"patch":"@@ -304,30 +304,0 @@\n-\n-    \/\/ Views\n-\n-    \/**\n-     * Each of these fields are initialized to contain an instance of the\n-     * appropriate view the first time this view is requested.  The views are\n-     * stateless, so there's no reason to create more than one of each.\n-     *\n-     * <p>Since there is no synchronization performed while accessing these fields,\n-     * it is expected that java.util.Map view classes using these fields have\n-     * no non-final fields (or any fields at all except for outer-this). Adhering\n-     * to this rule would make the races on these fields benign.\n-     *\n-     * <p>It is also imperative that implementations read the field only once,\n-     * as in:\n-     *\n-     * <pre> {@code\n-     * public Set<K> keySet() {\n-     *   Set<K> ks = keySet;  \/\/ single racy read\n-     *   if (ks == null) {\n-     *     ks = new KeySet();\n-     *     keySet = ks;\n-     *   }\n-     *   return ks;\n-     * }\n-     *}<\/pre>\n-     *\/\n-    transient Set<K>        keySet;\n-    transient Collection<V> values;\n-\n@@ -338,1 +308,1 @@\n-     * This implementation returns a set that subclasses {@link AbstractSet}.\n+     * This implementation returns a fresh set that subclasses {@link AbstractSet}.\n@@ -345,4 +315,0 @@\n-     * <p>The set is created the first time this method is called,\n-     * and returned in response to all subsequent calls.  No synchronization\n-     * is performed, so there is a slight chance that multiple calls to this\n-     * method will not all return the same set.\n@@ -351,26 +317,7 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new AbstractSet<>() {\n-                public Iterator<K> iterator() {\n-                    return new KeyIterator();\n-                }\n-\n-                public int size() {\n-                    return AbstractMap.this.size();\n-                }\n-\n-                public boolean isEmpty() {\n-                    return AbstractMap.this.isEmpty();\n-                }\n-\n-                public void clear() {\n-                    AbstractMap.this.clear();\n-                }\n-\n-                public boolean contains(Object k) {\n-                    return AbstractMap.this.containsKey(k);\n-                }\n-            };\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new AbstractSet<>() {\n+            public Iterator<K> iterator() { return new KeyIterator(); }\n+            public int size() { return AbstractMap.this.size(); }\n+            public boolean isEmpty() { return AbstractMap.this.isEmpty(); }\n+            public void clear() { AbstractMap.this.clear(); }\n+            public boolean contains(Object k) { return AbstractMap.this.containsKey(k); }\n+        };\n@@ -383,1 +330,1 @@\n-     * This implementation returns a collection that subclasses {@link\n+     * This implementation returns a fresh collection that subclasses {@link\n@@ -390,4 +337,0 @@\n-     * <p>The collection is created the first time this method is called, and\n-     * returned in response to all subsequent calls.  No synchronization is\n-     * performed, so there is a slight chance that multiple calls to this\n-     * method will not all return the same collection.\n@@ -396,26 +339,7 @@\n-        Collection<V> vals = values;\n-        if (vals == null) {\n-            vals = new AbstractCollection<>() {\n-                public Iterator<V> iterator() {\n-                    return new ValueIterator();\n-                }\n-\n-                public int size() {\n-                    return AbstractMap.this.size();\n-                }\n-\n-                public boolean isEmpty() {\n-                    return AbstractMap.this.isEmpty();\n-                }\n-\n-                public void clear() {\n-                    AbstractMap.this.clear();\n-                }\n-\n-                public boolean contains(Object v) {\n-                    return AbstractMap.this.containsValue(v);\n-                }\n-            };\n-            values = vals;\n-        }\n-        return vals;\n+        return new AbstractCollection<>() {\n+            public Iterator<V> iterator() { return new ValueIterator(); }\n+            public int size() { return AbstractMap.this.size(); }\n+            public boolean isEmpty() { return AbstractMap.this.isEmpty(); }\n+            public void clear() { AbstractMap.this.clear(); }\n+            public boolean contains(Object v) { return AbstractMap.this.containsValue(v); }\n+        };\n@@ -543,4 +467,1 @@\n-        AbstractMap<?,?> result = (AbstractMap<?,?>)super.clone();\n-        result.keySet = null;\n-        result.values = null;\n-        return result;\n+        return super.clone();\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":17,"deletions":96,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -381,6 +381,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -420,6 +415,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/EnumMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -912,6 +912,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -1040,6 +1035,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n@@ -1933,2 +1923,0 @@\n-        keySet = null;\n-        values = null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -986,6 +986,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -1092,6 +1087,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+\n+import jdk.internal.ValueBased;\n@@ -1072,2 +1074,2 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n-    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n+    @ValueBased\n+    sealed abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n@@ -1103,1 +1105,1 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n+    @ValueBased\n@@ -1170,1 +1172,1 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n+    @ValueBased\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -641,10 +641,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            SequencedSet<K> sks = new LinkedKeySet(false);\n-            keySet = sks;\n-            return sks;\n-        } else {\n-            \/\/ The cast should never fail, since the only assignment of non-null to keySet is\n-            \/\/ above, and assignments in AbstractMap and HashMap are in overridden methods.\n-            return (SequencedSet<K>) ks;\n-        }\n+        return new LinkedKeySet(false);\n@@ -790,10 +781,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            SequencedCollection<V> svs = new LinkedValues(false);\n-            values = svs;\n-            return svs;\n-        } else {\n-            \/\/ The cast should never fail, since the only assignment of non-null to values is\n-            \/\/ above, and assignments in AbstractMap and HashMap are in overridden methods.\n-            return (SequencedCollection<V>) vs;\n-        }\n+        return new LinkedValues(false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -954,1 +954,0 @@\n-        clone.navigableKeySet = null;\n@@ -1100,1 +1099,0 @@\n-    private transient KeySet<K> navigableKeySet;\n@@ -1136,2 +1134,1 @@\n-        KeySet<K> nks = navigableKeySet;\n-        return (nks != null) ? nks : (navigableKeySet = new KeySet<>(this));\n+        return new KeySet<>(this);\n@@ -1169,6 +1166,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeMap.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -876,6 +876,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -929,6 +924,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -818,2 +818,0 @@\n-    private transient KeySetView<K,V> keySet;\n-    private transient ValuesView<K,V> values;\n@@ -1237,3 +1235,1 @@\n-        KeySetView<K,V> ks;\n-        if ((ks = keySet) != null) return ks;\n-        return keySet = new KeySetView<K,V>(this, null);\n+        return new KeySetView<>(this, null);\n@@ -1261,3 +1257,1 @@\n-        ValuesView<K,V> vs;\n-        if ((vs = values) != null) return vs;\n-        return values = new ValuesView<K,V>(this);\n+        return new ValuesView<K,V>(this);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-    \/** Lazily initialized key set *\/\n-    private transient KeySet<K,V> keySet;\n-    \/** Lazily initialized values collection *\/\n-    private transient Values<K,V> values;\n@@ -1129,1 +1125,0 @@\n-            clone.keySet = null;\n@@ -1131,1 +1126,0 @@\n-            clone.values = null;\n@@ -1614,3 +1608,1 @@\n-        KeySet<K,V> ks;\n-        if ((ks = keySet) != null) return ks;\n-        return keySet = new KeySet<>(this);\n+        return navigableKeySet();\n@@ -1620,3 +1612,1 @@\n-        KeySet<K,V> ks;\n-        if ((ks = keySet) != null) return ks;\n-        return keySet = new KeySet<>(this);\n+        return new KeySet<>(this);\n@@ -1645,3 +1635,1 @@\n-        Values<K,V> vs;\n-        if ((vs = values) != null) return vs;\n-        return values = new Values<>(this);\n+        return new Values<>(this);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentSkipListMap.java","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(1)\n+@State(Scope.Thread)\n+public class HashMapViews {\n+\n+    @Param({\"1\", \"1000\"})\n+    public int size;\n+\n+    @Param({\"HashMap\"})\n+    public String mapType;\n+\n+    private Map<Integer, Integer> map;\n+\n+    @Setup\n+    public void setup() {\n+        switch (mapType) {\n+            case \"HashMap\":\n+                map = new HashMap<>();\n+                break;\n+            case \"LinkedHashMap\":\n+                map = new LinkedHashMap<>();\n+                break;\n+            default:\n+                throw new IllegalStateException();\n+        }\n+        for (int i = 0; i < size; i++) {\n+            map.put(i, i * i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int keySetSize() {\n+        return map.keySet().size();\n+    }\n+\n+    @Benchmark\n+    public int valuesSize() {\n+        return map.values().size();\n+    }\n+\n+    @Benchmark\n+    public int entrySetSize() {\n+        return map.entrySet().size();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HashMapViews.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}