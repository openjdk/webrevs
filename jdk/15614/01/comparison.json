{"files":[{"patch":"@@ -304,30 +304,0 @@\n-\n-    \/\/ Views\n-\n-    \/**\n-     * Each of these fields are initialized to contain an instance of the\n-     * appropriate view the first time this view is requested.  The views are\n-     * stateless, so there's no reason to create more than one of each.\n-     *\n-     * <p>Since there is no synchronization performed while accessing these fields,\n-     * it is expected that java.util.Map view classes using these fields have\n-     * no non-final fields (or any fields at all except for outer-this). Adhering\n-     * to this rule would make the races on these fields benign.\n-     *\n-     * <p>It is also imperative that implementations read the field only once,\n-     * as in:\n-     *\n-     * <pre> {@code\n-     * public Set<K> keySet() {\n-     *   Set<K> ks = keySet;  \/\/ single racy read\n-     *   if (ks == null) {\n-     *     ks = new KeySet();\n-     *     keySet = ks;\n-     *   }\n-     *   return ks;\n-     * }\n-     *}<\/pre>\n-     *\/\n-    transient Set<K>        keySet;\n-    transient Collection<V> values;\n-\n@@ -345,4 +315,0 @@\n-     * <p>The set is created the first time this method is called,\n-     * and returned in response to all subsequent calls.  No synchronization\n-     * is performed, so there is a slight chance that multiple calls to this\n-     * method will not all return the same set.\n@@ -351,20 +317,18 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new AbstractSet<K>() {\n-                public Iterator<K> iterator() {\n-                    return new Iterator<K>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public K next() {\n-                            return i.next().getKey();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n-                }\n+        return new AbstractSet<>() {\n+            public Iterator<K> iterator() {\n+                return new Iterator<>() {\n+                    private final Iterator<Entry<K, V>> i = entrySet().iterator();\n+\n+                    public boolean hasNext() {\n+                        return i.hasNext();\n+                    }\n+\n+                    public K next() {\n+                        return i.next().getKey();\n+                    }\n+\n+                    public void remove() {\n+                        i.remove();\n+                    }\n+                };\n+            }\n@@ -372,3 +336,3 @@\n-                public int size() {\n-                    return AbstractMap.this.size();\n-                }\n+            public int size() {\n+                return AbstractMap.this.size();\n+            }\n@@ -376,3 +340,3 @@\n-                public boolean isEmpty() {\n-                    return AbstractMap.this.isEmpty();\n-                }\n+            public boolean isEmpty() {\n+                return AbstractMap.this.isEmpty();\n+            }\n@@ -380,3 +344,3 @@\n-                public void clear() {\n-                    AbstractMap.this.clear();\n-                }\n+            public void clear() {\n+                AbstractMap.this.clear();\n+            }\n@@ -384,7 +348,4 @@\n-                public boolean contains(Object k) {\n-                    return AbstractMap.this.containsKey(k);\n-                }\n-            };\n-            keySet = ks;\n-        }\n-        return ks;\n+            public boolean contains(Object k) {\n+                return AbstractMap.this.containsKey(k);\n+            }\n+        };\n@@ -404,4 +365,0 @@\n-     * <p>The collection is created the first time this method is called, and\n-     * returned in response to all subsequent calls.  No synchronization is\n-     * performed, so there is a slight chance that multiple calls to this\n-     * method will not all return the same collection.\n@@ -410,20 +367,18 @@\n-        Collection<V> vals = values;\n-        if (vals == null) {\n-            vals = new AbstractCollection<V>() {\n-                public Iterator<V> iterator() {\n-                    return new Iterator<V>() {\n-                        private Iterator<Entry<K,V>> i = entrySet().iterator();\n-\n-                        public boolean hasNext() {\n-                            return i.hasNext();\n-                        }\n-\n-                        public V next() {\n-                            return i.next().getValue();\n-                        }\n-\n-                        public void remove() {\n-                            i.remove();\n-                        }\n-                    };\n-                }\n+        return new AbstractCollection<>() {\n+            public Iterator<V> iterator() {\n+                return new Iterator<>() {\n+                    private final Iterator<Entry<K, V>> i = entrySet().iterator();\n+\n+                    public boolean hasNext() {\n+                        return i.hasNext();\n+                    }\n+\n+                    public V next() {\n+                        return i.next().getValue();\n+                    }\n+\n+                    public void remove() {\n+                        i.remove();\n+                    }\n+                };\n+            }\n@@ -431,3 +386,3 @@\n-                public int size() {\n-                    return AbstractMap.this.size();\n-                }\n+            public int size() {\n+                return AbstractMap.this.size();\n+            }\n@@ -435,3 +390,3 @@\n-                public boolean isEmpty() {\n-                    return AbstractMap.this.isEmpty();\n-                }\n+            public boolean isEmpty() {\n+                return AbstractMap.this.isEmpty();\n+            }\n@@ -439,3 +394,3 @@\n-                public void clear() {\n-                    AbstractMap.this.clear();\n-                }\n+            public void clear() {\n+                AbstractMap.this.clear();\n+            }\n@@ -443,7 +398,4 @@\n-                public boolean contains(Object v) {\n-                    return AbstractMap.this.containsValue(v);\n-                }\n-            };\n-            values = vals;\n-        }\n-        return vals;\n+            public boolean contains(Object v) {\n+                return AbstractMap.this.containsValue(v);\n+            }\n+        };\n@@ -572,2 +524,0 @@\n-        result.keySet = null;\n-        result.values = null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/AbstractMap.java","additions":62,"deletions":112,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -381,6 +381,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -420,6 +415,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/EnumMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -912,6 +912,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -1040,6 +1035,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n@@ -1933,2 +1923,0 @@\n-        keySet = null;\n-        values = null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/HashMap.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -986,6 +986,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -1092,6 +1087,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+\n+import jdk.internal.ValueBased;\n@@ -1072,2 +1074,2 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n-    abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n+    @ValueBased\n+    sealed abstract static class AbstractImmutableMap<K,V> extends AbstractMap<K,V> implements Serializable {\n@@ -1103,1 +1105,1 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n+    @ValueBased\n@@ -1170,1 +1172,1 @@\n-    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n+    @ValueBased\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -641,10 +641,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            SequencedSet<K> sks = new LinkedKeySet(false);\n-            keySet = sks;\n-            return sks;\n-        } else {\n-            \/\/ The cast should never fail, since the only assignment of non-null to keySet is\n-            \/\/ above, and assignments in AbstractMap and HashMap are in overridden methods.\n-            return (SequencedSet<K>) ks;\n-        }\n+        return new LinkedKeySet(false);\n@@ -790,10 +781,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            SequencedCollection<V> svs = new LinkedValues(false);\n-            values = svs;\n-            return svs;\n-        } else {\n-            \/\/ The cast should never fail, since the only assignment of non-null to values is\n-            \/\/ above, and assignments in AbstractMap and HashMap are in overridden methods.\n-            return (SequencedCollection<V>) vs;\n-        }\n+        return new LinkedValues(false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/LinkedHashMap.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1169,6 +1169,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/TreeMap.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -876,6 +876,1 @@\n-        Set<K> ks = keySet;\n-        if (ks == null) {\n-            ks = new KeySet();\n-            keySet = ks;\n-        }\n-        return ks;\n+        return new KeySet();\n@@ -929,6 +924,1 @@\n-        Collection<V> vs = values;\n-        if (vs == null) {\n-            vs = new Values();\n-            values = vs;\n-        }\n-        return vs;\n+        return new Values();\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(1)\n+@State(Scope.Thread)\n+public class HashMapViews {\n+\n+    @Param({\"1\", \"1000\"})\n+    public int size;\n+\n+    @Param({\"HashMap\"})\n+    public String mapType;\n+\n+    private Map<Integer, Integer> map;\n+\n+    @Setup\n+    public void setup() {\n+        switch (mapType) {\n+            case \"HashMap\":\n+                map = new HashMap<>();\n+                break;\n+            case \"LinkedHashMap\":\n+                map = new LinkedHashMap<>();\n+                break;\n+            default:\n+                throw new IllegalStateException();\n+        }\n+        for (int i = 0; i < size; i++) {\n+            map.put(i, i * i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int keySetSize() {\n+        return map.keySet().size();\n+    }\n+\n+    @Benchmark\n+    public int valuesSize() {\n+        return map.values().size();\n+    }\n+\n+    @Benchmark\n+    public int entrySetSize() {\n+        return map.entrySet().size();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/HashMapViews.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}