{"files":[{"patch":"@@ -324,0 +324,4 @@\n+\n+    if (ik->name()->starts_with(\"java\/lang\/invoke\/MethodHandleImpl\")) {\n+      return true;\n+    }\n@@ -342,0 +346,1 @@\n+         ik == vmClasses::MethodHandleImpl_klass() ||\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-      log_debug(cds, resolve)(\"Checking indy callsite signature [%d]: %s\", cp_index, factory_type_sig->as_C_string());\n+      log_debug(cds, resolve)(\"Checking lambda callsite signature [%d]: %s\", cp_index, factory_type_sig->as_C_string());\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,5 +141,4 @@\n-    ADD_EXCL(\"java\/lang\/invoke\/MethodHandleImpl$ArrayAccessor\",\n-                                                          \"OBJECT_ARRAY_GETTER\",    \/\/ D\n-                                                          \"OBJECT_ARRAY_SETTER\",    \/\/ D\n-                                                          \"OBJECT_ARRAY_LENGTH\");   \/\/ D\n-\n+    ADD_EXCL(\"java\/lang\/runtime\/ObjectMethods\",           \"CLASS_IS_INSTANCE\",     \/\/ D\n+                                                          \"FALSE\",                 \/\/ D\n+                                                          \"TRUE\",                  \/\/ D\n+                                                          \"ZERO\");                 \/\/ D\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  do_klass(MethodHandleImpl_klass,                      java_lang_invoke_MethodHandleImpl                     ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -863,0 +863,6 @@\n+  if (is_runtime_setup_required()) {\n+    \/\/ Need to take the slow path, which will call the runtimeSetup() function instead\n+    \/\/ of <clinit>\n+    initialize(CHECK);\n+    return;\n+  }\n@@ -881,1 +887,0 @@\n-  AOTClassInitializer::call_runtime_setup(THREAD, this);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1529,0 +1529,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Also called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -309,1 +309,0 @@\n-    \/\/ Called from JVM when loading an AOT cache\n@@ -314,0 +313,1 @@\n+    \/\/ Also called from JVM when loading an AOT cache\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+ *             UnsupportedBSMs UnsupportedBSMs$MyEnum\n+ *             ObjectMethodsTest ObjectMethodsTest$C\n@@ -39,0 +41,2 @@\n+import java.io.Serializable;\n+import java.lang.invoke.CallSite;\n@@ -43,0 +47,1 @@\n+import java.lang.runtime.ObjectMethods;\n@@ -46,0 +51,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -90,0 +96,1 @@\n+            out.shouldContain(\"SwitchBootstraps.typeSwitch: 5678\");\n@@ -98,0 +105,1 @@\n+                out.shouldContain(\"intElm = 777\");\n@@ -144,0 +152,6 @@\n+    static MethodHandle arrayGetMH;\n+\n+    \/\/ Created in assembly phase.\n+    \/\/ Used in production run.\n+    static MethodHandle ObjectMethodsTest_handle;\n+\n@@ -148,1 +162,3 @@\n-            setupCachedStatics();\n+            setupCachedMHs();\n+            ObjectMethodsTest_handle = ObjectMethodsTest.makeHandle();\n+            UnsupportedBSMs.invokeUnsupportedBSMs();\n@@ -154,1 +170,5 @@\n-    static void setupCachedStatics() throws Throwable {\n+    \/\/ This method is executed during the assembly phase.\n+    \/\/\n+    \/\/ Store some MHs into the AOT cache. Make sure they can be used during the production run.\n+    \/\/ Also check that the class initialization order is consistent with specification.\n+    static void setupCachedMHs() throws Throwable {\n@@ -164,1 +184,0 @@\n-\n@@ -169,0 +188,3 @@\n+\n+        \/\/ Array access MHs\n+        arrayGetMH = MethodHandles.arrayElementGetter(int[].class);\n@@ -187,1 +209,0 @@\n-    }\n@@ -189,0 +210,4 @@\n+        ObjectMethodsTest.testEqualsC(ObjectMethodsTest_handle);\n+\n+        UnsupportedBSMs.invokeUnsupportedBSMs();\n+    }\n@@ -215,0 +240,8 @@\n+\n+        \/\/ (3) Test an array access MH\n+        int[] intArray = new int[] {111, 222, 777};\n+        int intElm = (Integer)arrayGetMH.invoke(intArray, 2);\n+        System.out.println(\"intElm = \" + intElm);\n+        if (intElm != 777) {\n+            throw new RuntimeException(\"intElm should be 777 but is: \" + intElm);\n+        }\n@@ -249,0 +282,116 @@\n+\n+\/\/ Excerpt from test\/jdk\/java\/lang\/runtime\/ObjectMethodsTest.java\n+class ObjectMethodsTest {\n+    public static class C {\n+        static final MethodType EQUALS_DESC = methodType(boolean.class, C.class, Object.class);\n+        static final MethodType HASHCODE_DESC = methodType(int.class, C.class);\n+        static final MethodType TO_STRING_DESC = methodType(String.class, C.class);\n+\n+        static final MethodHandle[] ACCESSORS = accessors();\n+        static final String NAME_LIST = \"x;y\";\n+        private static MethodHandle[] accessors() {\n+            try {\n+                return  new MethodHandle[]{\n+                        MethodHandles.lookup().findGetter(C.class, \"x\", int.class),\n+                        MethodHandles.lookup().findGetter(C.class, \"y\", int.class),\n+                };\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        private final int x;\n+        private final int y;\n+        C (int x, int y) { this.x = x; this.y = y; }\n+        public int x() { return x; }\n+        public int y() { return y; }\n+    }\n+\n+    public static MethodHandle makeHandle() throws Throwable {\n+        MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        CallSite cs = (CallSite)ObjectMethods.bootstrap(LOOKUP, \"equals\", C.EQUALS_DESC, C.class, C.NAME_LIST, C.ACCESSORS);\n+        return cs.dynamicInvoker();\n+    }\n+\n+    public static void testEqualsC(MethodHandle handle) throws Throwable {\n+        C c = new C(5, 5);\n+        assertTrue((boolean)handle.invokeExact(c, (Object)c));\n+        assertTrue((boolean)handle.invokeExact(c, (Object)new C(5, 5)));\n+        assertFalse((boolean)handle.invokeExact(c, (Object)new C(5, 4)));\n+        assertFalse((boolean)handle.invokeExact(c, (Object)new C(4, 5)));\n+        assertFalse((boolean)handle.invokeExact(c, (Object)null));\n+        assertFalse((boolean)handle.invokeExact(c, new Object()));\n+    }\n+\n+    private static void assertTrue(boolean b) {\n+        if (b != true) {\n+            throw new RuntimeException(\"Assertion fails\");\n+        }\n+    }\n+\n+    private static void assertFalse(boolean b) {\n+        assertTrue(!b);\n+    }\n+}\n+\n+class UnsupportedBSMs {\n+    \/\/ This method is executed during the assembly phase.\n+    \/\/\n+    \/\/ Try to invoke some BSMs that are normally not executed in the assembly phase. However, these\n+    \/\/ BSMs may be executed in rare cases (such as when loading signed classes -- see JDK-8353330.)\n+    \/\/ Let's make sure the assembly phase can tolerate such BSMs, even if the call sites that they\n+    \/\/ produce are not stored into the AOT cache.\n+    \/\/\n+    \/\/ Hopefully with enough testing in here, we can avoid situations where innocent changes in\n+    \/\/ core libs might cause the AOT assembly phase to fail.\n+    static void invokeUnsupportedBSMs() throws Throwable {\n+        int n = testTypeSwitch((Integer)1234);\n+        System.out.println(\"SwitchBootstraps.typeSwitch: \" + n);\n+        if (n != 5678) {\n+            throw new RuntimeException(\"n should be \" + 5678 + \" but is: \" + n);\n+        }\n+\n+        Object o = getRunnableAndSerializable();\n+        System.out.println(o.getClass());\n+        if (!(o instanceof Runnable) || !(o instanceof Serializable)) {\n+            throw new RuntimeException(\"o has wrong interfaces\");\n+        }\n+\n+        String s = statementEnum(MyEnum.A);\n+        if (!s.equals(\"A\")) {\n+            throw new RuntimeException(\"enum switch incorrect\");\n+        }\n+    }\n+\n+    static int testTypeSwitch(Number n) {\n+        \/\/ BSM = java\/lang\/runtime\/SwitchBootstraps::typeSwitch\n+        return switch (n) {\n+            case Integer in -> {\n+                yield 5678;\n+            }\n+            default -> {\n+                yield 0;\n+            }\n+        };\n+    }\n+\n+    static Runnable getRunnableAndSerializable() {\n+        \/\/ BSM = java\/lang\/invoke\/LambdaMetafactory.altMetafactory\n+        return (Runnable & Serializable) () -> {\n+            System.out.println(\"Inside getRunnableAndSerializable\");\n+        };\n+    }\n+\n+    \/\/ Excerpt from test\/langtools\/tools\/javac\/patterns\/EnumTypeChanges.java\n+    enum MyEnum { A, B; }\n+    static String statementEnum(MyEnum e) {\n+        \/\/ BSM = java\/lang\/runtime\/SwitchBootstraps.enumSwitch\n+        switch (e) {\n+            case A ->  { return \"A\"; }\n+            case B ->  { return \"B\"; }\n+            case MyEnum e1 when e1 == null -> throw new AssertionError();\n+            default -> { return \"D\"; }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java","additions":153,"deletions":4,"binary":false,"changes":157,"status":"modified"}]}