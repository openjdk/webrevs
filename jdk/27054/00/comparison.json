{"files":[{"patch":"@@ -37,1 +37,1 @@\n-#define PRAGMA_DISABLE_GCC_WARNING(optstring) _Pragma(STR(GCC diagnostic ignored optstring))\n+#define PRAGMA_DISABLE_GCC_WARNING(option) _Pragma(STR(GCC diagnostic ignored option))\n@@ -74,0 +74,2 @@\n+#define __null _Pragma(STR(GCC warning \"NULL is forbidden in HotSpot code\")) nullptr\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#pragma deprecated(NULL)\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_visCPP.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8343802\n- * @summary Test prevent NULL backsliding in hotspot code and tests\n- * @run main TestNoNULL\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.MalformedInputException;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.regex.Pattern;\n-\n-public class TestNoNULL {\n-    private static final Set<String> excludedSourceFiles = new HashSet<>();\n-    private static final Set<String> excludedTestFiles = new HashSet<>();\n-    private static final Set<String> excludedTestExtensions = extend(new HashSet<>(List.of(\".c\", \".java\", \".jar\", \".class\", \".zip\")), \"excludedTestExtensions\");\n-    private static final Pattern NULL_PATTERN = Pattern.compile(\"\\\\bNULL\\\\b\");\n-    private static Path dir = Paths.get(System.getProperty(\"test.src\"));\n-    private static int errorCount = 0;\n-\n-    \/**\n-     * Extends {@code toExtend} with the comma separated entries in the value of the\n-     * {@code propertyName} system property.\n-     *\/\n-    private static <T extends Collection<String>> T extend(T toExtend, String propertyName) {\n-        String extensions = System.getProperty(propertyName);\n-        if (extensions != null) {\n-            toExtend.addAll(List.of(extensions.split(\",\")));\n-        }\n-        return toExtend;\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        int maxIter = 20;\n-        while (maxIter-- > 0 && dir != null && !Files.exists(dir.resolve(\"src\"))) {\n-            dir = dir.getParent();\n-        }\n-\n-        if (dir == null) {\n-            throw new RuntimeException(\"Could not locate the 'src' directory within 20 parent directories.\");\n-        }\n-\n-        Path srcPath = dir.resolve(\"src\").resolve(\"hotspot\");\n-        Path testPath = dir.resolve(\"test\").resolve(\"hotspot\");\n-\n-        initializeExcludedPaths(dir);\n-\n-        if (Files.exists(srcPath)) {\n-            processFiles(srcPath, excludedSourceFiles, Set.of());\n-        }\n-        processFiles(testPath, excludedTestFiles, excludedTestExtensions);\n-\n-        if (errorCount > 0) {\n-            throw new RuntimeException(\"Test found \" + errorCount + \" usages of 'NULL' in source files. See errors above.\");\n-        }\n-    }\n-\n-    private static void initializeExcludedPaths(Path rootDir) {\n-        List<String> sourceExclusions = extend(new ArrayList<>(List.of(\n-                \"src\/hotspot\/share\/prims\/jvmti.xml\",\n-                \"src\/hotspot\/share\/prims\/jvmti.xsl\"\n-        )), \"sourceExclusions\");\n-\n-        List<String> testExclusions = extend(new ArrayList<>(List.of(\n-                \"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/README\",\n-                \"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/README\"\n-        )), \"testExclusions\");\n-\n-        sourceExclusions.forEach(relativePath ->\n-                excludedSourceFiles.add(rootDir.resolve(relativePath).normalize().toString()));\n-        testExclusions.forEach(relativePath ->\n-                excludedTestFiles.add(rootDir.resolve(relativePath).normalize().toString()));\n-    }\n-\n-    private static void processFiles(Path directory, Set<String> excludedFiles, Set<String> excludedExtensions) throws IOException {\n-        Files.walkFileTree(directory, new SimpleFileVisitor<>() {\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n-                if (isIncluded(file, excludedFiles, excludedExtensions)) {\n-                    checkForNull(file);\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-\n-    private static boolean isIncluded(Path file, Set<String> excludedFiles, Set<String> excludedExtensions) {\n-        String filePath = file.normalize().toString();\n-\n-        if (excludedFiles.contains(filePath)) {\n-            return false;\n-        }\n-\n-        for (String ext : excludedExtensions) {\n-            if (filePath.endsWith(ext)) {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    private static void checkForNull(Path path) {\n-        try {\n-            List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);\n-            for (int i = 0; i < lines.size(); i++) {\n-                if (NULL_PATTERN.matcher(lines.get(i)).find()) {\n-                    errorCount++;\n-                    System.err.printf(\"Error: 'NULL' found in %s at line %d:%n%s%n\", path, i + 1, lines.get(i));\n-                }\n-            }\n-        } catch (MalformedInputException e) {\n-            System.err.println(\"Skipping binary file: \" + path);\n-        } catch (IOException e) {\n-            System.err.printf(\"Skipping unreadable file: \" + path);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/sources\/TestNoNULL.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"}]}