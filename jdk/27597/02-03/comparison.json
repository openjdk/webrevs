{"files":[{"patch":"@@ -643,54 +643,0 @@\n-    \/**\n-     * Test no deadlock happens when Object.wait is called from a mix of pinned and non-pinned\n-     * paths and notification is done using notifyAll.\n-     *\/\n-    @Test\n-    void testMixedPinnedUnmounted() throws Exception {\n-        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n-        try (ExecutorService scheduler = Executors.newFixedThreadPool(1)) {\n-            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n-            var lock = new Object();\n-\n-            var startedNotPinned = new CountDownLatch(1);\n-            var vthreadNotPinned = factory.newThread(() -> {\n-                synchronized (lock) {\n-                    try {\n-                        startedNotPinned.countDown();\n-                        lock.wait();\n-                    } catch (InterruptedException e) {\n-                        fail(\"wait interrupted\");\n-                    }\n-                }\n-            });\n-            vthreadNotPinned.start();\n-            startedNotPinned.await();\n-            await(vthreadNotPinned, Thread.State.WAITING);\n-\n-            var startedPinned = new CountDownLatch(1);\n-            var vthreadPinned = factory.newThread(() -> {\n-                synchronized (lock) {\n-                    try {\n-                        startedPinned.countDown();\n-                        VThreadPinner.runPinned(() -> {\n-                            lock.wait();\n-                        });\n-                    } catch (InterruptedException e) {\n-                        fail(\"wait interrupted\");\n-                    }\n-                }\n-            });\n-            vthreadPinned.start();\n-            startedPinned.await();\n-            await(vthreadPinned, Thread.State.WAITING);\n-\n-            \/\/ wakeup threads\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-\n-            \/\/ thread should terminate\n-            vthreadNotPinned.join();\n-            vthreadPinned.join();\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @summary Test that a virtual thread waiting to enter a monitor, while pinning its\n- *   carrier, will retry until it enters the monitor. This avoids starvation when the\n+ * @summary Test that a virtual thread waiting to enter\/reenter a monitor, while pinning\n+ *   its carrier, will retry until it enters the monitor. This avoids starvation when the\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n@@ -41,0 +41,6 @@\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -43,7 +49,5 @@\n-    public static void main(String[] args) throws Exception {\n-        int iterations = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n-        for (int i = 1; i <= iterations; i++) {\n-            System.out.printf(\"%s -- iteration %d --%n\", Instant.now(), i);\n-            run();\n-            System.out.println();\n-        }\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        VThreadRunner.ensureParallelism(2);\n@@ -52,1 +56,2 @@\n-    static void run() throws Exception {\n+    @RepeatedTest(10)\n+    void testMonitorEnter() throws Exception {\n@@ -109,0 +114,88 @@\n+            for (Thread t : threads) {\n+                if (t.join(Duration.ofSeconds(1))) {\n+                    terminated++;\n+                }\n+            }\n+            threadsRemaining = threads.size() - terminated;\n+        }\n+        System.out.printf(\"%s done%n\", Instant.now());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testMonitorReenter(int timeout) throws Exception {\n+        var threads = new ArrayList<Thread>();\n+\n+        Object lock = new Object();\n+\n+        \/\/ start virtual threads that wait on Object.wait\n+        for (int i = 0; i < 100; i++) {\n+            var started = new CountDownLatch(1);\n+            Thread thread = Thread.startVirtualThread(() -> {\n+                try {\n+                    synchronized (lock) {\n+                        started.countDown();\n+                        if (timeout > 0) {\n+                            lock.wait(timeout);\n+                        } else {\n+                            lock.wait();\n+                        }\n+                    }\n+                } catch (InterruptedException e) { }\n+            });\n+\n+            \/\/ wait for thread to start and wait\n+            started.await();\n+            await(thread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+            threads.add(thread);\n+        }\n+\n+        \/\/ start virtual threads that wait on Object.wait while pinnned\n+        int carriersAvailable = Runtime.getRuntime().availableProcessors();\n+        if (Thread.currentThread().isVirtual()) {\n+            carriersAvailable--;\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            var started = new CountDownLatch(1);\n+            boolean hasCarrier = carriersAvailable > 0;\n+            Thread thread = Thread.startVirtualThread(() -> {\n+                VThreadPinner.runPinned(() -> {\n+                    try {\n+                        synchronized (lock) {\n+                            started.countDown();\n+                            if (!hasCarrier) {\n+                                \/\/ This thread will run at the very\n+                                \/\/ end and won't be notified.\n+                                lock.wait(1);\n+                            } else if (timeout > 0) {\n+                                lock.wait(timeout);\n+                            } else {\n+                                lock.wait();\n+                            }\n+                        }\n+                    } catch (InterruptedException e) { }\n+                });\n+            });\n+\n+            \/\/ if there are carriers available when wait until the thread blocks.\n+            if (hasCarrier) {\n+                System.out.printf(\"%s waiting for thread #%d to block%n\",\n+                        Instant.now(), thread.threadId());\n+                started.await();\n+                await(thread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+                carriersAvailable--;\n+            }\n+            threads.add(thread);\n+        }\n+\n+        \/\/ wakeup all threads\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ wait for all threads to terminate\n+        int threadsRemaining = threads.size();\n+        while (threadsRemaining > 0) {\n+            System.out.printf(\"%s waiting for %d threads to terminate%n\",\n+                    Instant.now(), threadsRemaining);\n+            int terminated = 0;\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":104,"deletions":11,"binary":false,"changes":115,"status":"modified"}]}