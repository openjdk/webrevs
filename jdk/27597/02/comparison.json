{"files":[{"patch":"@@ -120,0 +120,2 @@\n+static const jlong MAX_RECHECK_INTERVAL = 1000;\n+\n@@ -297,0 +299,1 @@\n+  _unmounted_vthreads(0),\n@@ -986,13 +989,12 @@\n-  \/\/ For virtual threads that are pinned, do a timed-park instead to\n-  \/\/ alleviate some deadlocks cases where the succesor is an unmounted\n-  \/\/ virtual thread that cannot run. This can happen in particular when\n-  \/\/ this virtual thread is currently loading\/initializing a class, and\n-  \/\/ all other carriers have a vthread pinned to it waiting for said class\n-  \/\/ to be loaded\/initialized.\n-  static int MAX_RECHECK_INTERVAL = 1000;\n-  int recheck_interval = 1;\n-  bool do_timed_parked = false;\n-  ContinuationEntry* ce = current->last_continuation();\n-  if (ce != nullptr && ce->is_virtual_thread()) {\n-    do_timed_parked = true;\n-  }\n+  \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+  \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+  \/\/ of them is picked as the successor but cannot run due to having run out\n+  \/\/ of carriers. This can happen, for example, if this is a pinned virtual\n+  \/\/ thread currently loading or initializining a class, and all other carriers\n+  \/\/ have a pinned vthread waiting for said class to be loaded\/initialized.\n+  \/\/ Read counter *after* adding this thread to the _entry_list. Adding to\n+  \/\/ _entry_list uses Atomic::cmpxchg() which already provides a fence that\n+  \/\/ prevents this load from floating up previous store.\n+  \/\/ Note that we can have false positives where timed-park is not necessary.\n+  bool do_timed_parked = has_unmounted_vthreads();\n+  jlong recheck_interval = 1;\n@@ -1009,1 +1011,1 @@\n-      current->_ParkEvent->park((jlong) recheck_interval);\n+      current->_ParkEvent->park(recheck_interval);\n@@ -1093,0 +1095,16 @@\n+  \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+  \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+  \/\/ of them is picked as the successor but cannot run due to having run out\n+  \/\/ of carriers. This can happen, for example, if a mixed of unmounted and\n+  \/\/ pinned vthreads taking up all the carriers are waiting for a class to be\n+  \/\/ initialized, and the selected successor is one of the unmounted vthreads.\n+  \/\/ Although this method is used for the \"notification\" case, it could be\n+  \/\/ that this thread reached here without been added to the _entry_list yet.\n+  \/\/ This can happen if it was interrupted or the wait timed-out at the same\n+  \/\/ time. In that case we rely on currentNode->_do_timed_park, which will be\n+  \/\/ read on the next loop iteration, after consuming the park permit set by\n+  \/\/ the notifier in notify_internal.\n+  \/\/ Note that we can have false positives where timed-park is not necessary.\n+  bool do_timed_parked = has_unmounted_vthreads();\n+  jlong recheck_interval = 1;\n+\n@@ -1117,1 +1135,10 @@\n-        current->_ParkEvent->park();\n+        if (do_timed_parked) {\n+          current->_ParkEvent->park(recheck_interval);\n+          \/\/ Increase the recheck_interval, but clamp the value.\n+          recheck_interval *= 8;\n+          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+            recheck_interval = MAX_RECHECK_INTERVAL;\n+          }\n+        } else {\n+          current->_ParkEvent->park();\n+        }\n@@ -1137,0 +1164,3 @@\n+\n+    \/\/ See comment in notify_internal\n+    do_timed_parked |= currentNode->_do_timed_park;\n@@ -1164,0 +1194,6 @@\n+\n+  \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+  \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+  \/\/ a fence that prevents reordering of the stores.\n+  inc_unmounted_vthreads();\n+\n@@ -1167,0 +1203,1 @@\n+    dec_unmounted_vthreads();\n@@ -1178,0 +1215,1 @@\n+    dec_unmounted_vthreads();\n@@ -1233,0 +1271,1 @@\n+  dec_unmounted_vthreads();\n@@ -2007,0 +2046,4 @@\n+      \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+      \/\/ a fence that prevents reordering of the stores.\n+      inc_unmounted_vthreads();\n@@ -2024,0 +2067,18 @@\n+\n+      \/\/ Read counter *after* adding the thread to the _entry_list.\n+      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+      \/\/ a fence that prevents this load from floating up previous store.\n+      if (has_unmounted_vthreads()) {\n+        \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n+        \/\/ that will be picked up when this thread releases the monitor is an unmounted\n+        \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n+        \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n+        \/\/ there is contention and there are still vthreads in the _entry_list.\n+        \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n+        \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n+        \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n+        \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n+        iterator->_do_timed_park = true;\n+        JavaThread* t = iterator->thread();\n+        t->_ParkEvent->unpark();\n+      }\n@@ -2463,0 +2524,1 @@\n+  _do_timed_park = false;\n@@ -2635,0 +2697,1 @@\n+  st->print_cr(\"  _unmounted_vthreads = \" INT64_FORMAT, _unmounted_vthreads);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":78,"deletions":15,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  bool     _do_timed_park;\n@@ -202,0 +203,2 @@\n+  int64_t _unmounted_vthreads;      \/\/ Number of nodes in the _entry_list associated with unmounted vthreads.\n+                                    \/\/ It might be temporarily more than the actual number but never less.\n@@ -328,0 +331,3 @@\n+  void      inc_unmounted_vthreads();\n+  void      dec_unmounted_vthreads();\n+  bool      has_unmounted_vthreads() const;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,0 +146,15 @@\n+inline void ObjectMonitor::inc_unmounted_vthreads() {\n+  assert(_unmounted_vthreads >= 0, \"\");\n+  AtomicAccess::inc(&_unmounted_vthreads, memory_order_relaxed);\n+}\n+\n+inline void ObjectMonitor::dec_unmounted_vthreads() {\n+  assert(_unmounted_vthreads > 0, \"\");\n+  AtomicAccess::dec(&_unmounted_vthreads, memory_order_relaxed);\n+}\n+\n+inline bool ObjectMonitor::has_unmounted_vthreads() const {\n+  assert(_unmounted_vthreads >= 0, \"\");\n+  return AtomicAccess::load(&_unmounted_vthreads) > 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -643,0 +643,54 @@\n+    \/**\n+     * Test no deadlock happens when Object.wait is called from a mix of pinned and non-pinned\n+     * paths and notification is done using notifyAll.\n+     *\/\n+    @Test\n+    void testMixedPinnedUnmounted() throws Exception {\n+        assumeTrue(VThreadScheduler.supportsCustomScheduler(), \"No support for custom schedulers\");\n+        try (ExecutorService scheduler = Executors.newFixedThreadPool(1)) {\n+            ThreadFactory factory = VThreadScheduler.virtualThreadFactory(scheduler);\n+            var lock = new Object();\n+\n+            var startedNotPinned = new CountDownLatch(1);\n+            var vthreadNotPinned = factory.newThread(() -> {\n+                synchronized (lock) {\n+                    try {\n+                        startedNotPinned.countDown();\n+                        lock.wait();\n+                    } catch (InterruptedException e) {\n+                        fail(\"wait interrupted\");\n+                    }\n+                }\n+            });\n+            vthreadNotPinned.start();\n+            startedNotPinned.await();\n+            await(vthreadNotPinned, Thread.State.WAITING);\n+\n+            var startedPinned = new CountDownLatch(1);\n+            var vthreadPinned = factory.newThread(() -> {\n+                synchronized (lock) {\n+                    try {\n+                        startedPinned.countDown();\n+                        VThreadPinner.runPinned(() -> {\n+                            lock.wait();\n+                        });\n+                    } catch (InterruptedException e) {\n+                        fail(\"wait interrupted\");\n+                    }\n+                }\n+            });\n+            vthreadPinned.start();\n+            startedPinned.await();\n+            await(vthreadPinned, Thread.State.WAITING);\n+\n+            \/\/ wakeup threads\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+\n+            \/\/ thread should terminate\n+            vthreadNotPinned.join();\n+            vthreadPinned.join();\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"}]}