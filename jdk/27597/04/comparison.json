{"files":[{"patch":"@@ -120,0 +120,2 @@\n+static const jlong MAX_RECHECK_INTERVAL = 1000;\n+\n@@ -297,0 +299,1 @@\n+  _unmounted_vthreads(0),\n@@ -986,13 +989,12 @@\n-  \/\/ For virtual threads that are pinned, do a timed-park instead to\n-  \/\/ alleviate some deadlocks cases where the succesor is an unmounted\n-  \/\/ virtual thread that cannot run. This can happen in particular when\n-  \/\/ this virtual thread is currently loading\/initializing a class, and\n-  \/\/ all other carriers have a vthread pinned to it waiting for said class\n-  \/\/ to be loaded\/initialized.\n-  static int MAX_RECHECK_INTERVAL = 1000;\n-  int recheck_interval = 1;\n-  bool do_timed_parked = false;\n-  ContinuationEntry* ce = current->last_continuation();\n-  if (ce != nullptr && ce->is_virtual_thread()) {\n-    do_timed_parked = true;\n-  }\n+  \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+  \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+  \/\/ of them is picked as the successor but cannot run due to having run out\n+  \/\/ of carriers. This can happen, for example, if this is a pinned virtual\n+  \/\/ thread currently loading or initializining a class, and all other carriers\n+  \/\/ have a pinned vthread waiting for said class to be loaded\/initialized.\n+  \/\/ Read counter *after* adding this thread to the _entry_list. Adding to\n+  \/\/ _entry_list uses Atomic::cmpxchg() which already provides a fence that\n+  \/\/ prevents this load from floating up previous store.\n+  \/\/ Note that we can have false positives where timed-park is not necessary.\n+  bool do_timed_parked = has_unmounted_vthreads();\n+  jlong recheck_interval = 1;\n@@ -1009,1 +1011,1 @@\n-      current->_ParkEvent->park((jlong) recheck_interval);\n+      current->_ParkEvent->park(recheck_interval);\n@@ -1093,0 +1095,16 @@\n+  \/\/ If there are unmounted virtual threads ahead in the _entry_list we want\n+  \/\/ to do a timed-park instead to alleviate some deadlock cases where one\n+  \/\/ of them is picked as the successor but cannot run due to having run out\n+  \/\/ of carriers. This can happen, for example, if a mixed of unmounted and\n+  \/\/ pinned vthreads taking up all the carriers are waiting for a class to be\n+  \/\/ initialized, and the selected successor is one of the unmounted vthreads.\n+  \/\/ Although this method is used for the \"notification\" case, it could be\n+  \/\/ that this thread reached here without been added to the _entry_list yet.\n+  \/\/ This can happen if it was interrupted or the wait timed-out at the same\n+  \/\/ time. In that case we rely on currentNode->_do_timed_park, which will be\n+  \/\/ read on the next loop iteration, after consuming the park permit set by\n+  \/\/ the notifier in notify_internal.\n+  \/\/ Note that we can have false positives where timed-park is not necessary.\n+  bool do_timed_parked = has_unmounted_vthreads();\n+  jlong recheck_interval = 1;\n+\n@@ -1117,1 +1135,10 @@\n-        current->_ParkEvent->park();\n+        if (do_timed_parked) {\n+          current->_ParkEvent->park(recheck_interval);\n+          \/\/ Increase the recheck_interval, but clamp the value.\n+          recheck_interval *= 8;\n+          if (recheck_interval > MAX_RECHECK_INTERVAL) {\n+            recheck_interval = MAX_RECHECK_INTERVAL;\n+          }\n+        } else {\n+          current->_ParkEvent->park();\n+        }\n@@ -1137,0 +1164,3 @@\n+\n+    \/\/ See comment in notify_internal\n+    do_timed_parked |= currentNode->_do_timed_park;\n@@ -1164,0 +1194,6 @@\n+\n+  \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+  \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+  \/\/ a fence that prevents reordering of the stores.\n+  inc_unmounted_vthreads();\n+\n@@ -1167,0 +1203,1 @@\n+    dec_unmounted_vthreads();\n@@ -1178,0 +1215,1 @@\n+    dec_unmounted_vthreads();\n@@ -1233,0 +1271,1 @@\n+  dec_unmounted_vthreads();\n@@ -2007,0 +2046,4 @@\n+      \/\/ Increment counter *before* adding the vthread to the _entry_list.\n+      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+      \/\/ a fence that prevents reordering of the stores.\n+      inc_unmounted_vthreads();\n@@ -2024,0 +2067,18 @@\n+\n+      \/\/ Read counter *after* adding the thread to the _entry_list.\n+      \/\/ Adding to _entry_list uses Atomic::cmpxchg() which already provides\n+      \/\/ a fence that prevents this load from floating up previous store.\n+      if (has_unmounted_vthreads()) {\n+        \/\/ Wake up the thread to alleviate some deadlock cases where the successor\n+        \/\/ that will be picked up when this thread releases the monitor is an unmounted\n+        \/\/ virtual thread that cannot run due to having run out of carriers. Upon waking\n+        \/\/ up, the thread will call reenter_internal() which will use timed-park in case\n+        \/\/ there is contention and there are still vthreads in the _entry_list.\n+        \/\/ If the target was interrupted or the wait timed-out at the same time, it could\n+        \/\/ have reached reenter_internal and read a false value of has_unmounted_vthreads()\n+        \/\/ before we added it to the _entry_list above. To deal with that case, we set _do_timed_park\n+        \/\/ which will be read by the target on the next loop iteration in reenter_internal.\n+        iterator->_do_timed_park = true;\n+        JavaThread* t = iterator->thread();\n+        t->_ParkEvent->unpark();\n+      }\n@@ -2463,0 +2524,1 @@\n+  _do_timed_park = false;\n@@ -2635,0 +2697,1 @@\n+  st->print_cr(\"  _unmounted_vthreads = \" INT64_FORMAT, _unmounted_vthreads);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":78,"deletions":15,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  bool     _do_timed_park;\n@@ -202,0 +203,2 @@\n+  int64_t _unmounted_vthreads;      \/\/ Number of nodes in the _entry_list associated with unmounted vthreads.\n+                                    \/\/ It might be temporarily more than the actual number but never less.\n@@ -328,0 +331,3 @@\n+  void      inc_unmounted_vthreads();\n+  void      dec_unmounted_vthreads();\n+  bool      has_unmounted_vthreads() const;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,0 +146,15 @@\n+inline void ObjectMonitor::inc_unmounted_vthreads() {\n+  assert(_unmounted_vthreads >= 0, \"invariant\");\n+  AtomicAccess::inc(&_unmounted_vthreads, memory_order_relaxed);\n+}\n+\n+inline void ObjectMonitor::dec_unmounted_vthreads() {\n+  assert(_unmounted_vthreads > 0, \"invariant\");\n+  AtomicAccess::dec(&_unmounted_vthreads, memory_order_relaxed);\n+}\n+\n+inline bool ObjectMonitor::has_unmounted_vthreads() const {\n+  assert(_unmounted_vthreads >= 0, \"invariant\");\n+  return AtomicAccess::load(&_unmounted_vthreads) > 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @summary Test that a virtual thread waiting to enter a monitor, while pinning its\n- *   carrier, will retry until it enters the monitor. This avoids starvation when the\n+ * @summary Test that a virtual thread waiting to enter\/reenter a monitor, while pinning\n+ *   its carrier, will retry until it enters the monitor. This avoids starvation when the\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n@@ -41,0 +41,6 @@\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.RepeatedTest;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -43,7 +49,5 @@\n-    public static void main(String[] args) throws Exception {\n-        int iterations = (args.length > 0) ? Integer.parseInt(args[0]) : 10;\n-        for (int i = 1; i <= iterations; i++) {\n-            System.out.printf(\"%s -- iteration %d --%n\", Instant.now(), i);\n-            run();\n-            System.out.println();\n-        }\n+\n+    @BeforeAll\n+    static void setup() {\n+        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n+        VThreadRunner.ensureParallelism(2);\n@@ -52,1 +56,2 @@\n-    static void run() throws Exception {\n+    @RepeatedTest(10)\n+    void testMonitorEnter() throws Exception {\n@@ -109,0 +114,88 @@\n+            for (Thread t : threads) {\n+                if (t.join(Duration.ofSeconds(1))) {\n+                    terminated++;\n+                }\n+            }\n+            threadsRemaining = threads.size() - terminated;\n+        }\n+        System.out.printf(\"%s done%n\", Instant.now());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = { 0, 30000, Integer.MAX_VALUE })\n+    void testMonitorReenter(int timeout) throws Exception {\n+        var threads = new ArrayList<Thread>();\n+\n+        Object lock = new Object();\n+\n+        \/\/ start virtual threads that wait on Object.wait\n+        for (int i = 0; i < 100; i++) {\n+            var started = new CountDownLatch(1);\n+            Thread thread = Thread.startVirtualThread(() -> {\n+                try {\n+                    synchronized (lock) {\n+                        started.countDown();\n+                        if (timeout > 0) {\n+                            lock.wait(timeout);\n+                        } else {\n+                            lock.wait();\n+                        }\n+                    }\n+                } catch (InterruptedException e) { }\n+            });\n+\n+            \/\/ wait for thread to start and wait\n+            started.await();\n+            await(thread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+            threads.add(thread);\n+        }\n+\n+        \/\/ start virtual threads that wait on Object.wait while pinnned\n+        int carriersAvailable = Runtime.getRuntime().availableProcessors();\n+        if (Thread.currentThread().isVirtual()) {\n+            carriersAvailable--;\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            var started = new CountDownLatch(1);\n+            boolean hasCarrier = carriersAvailable > 0;\n+            Thread thread = Thread.startVirtualThread(() -> {\n+                VThreadPinner.runPinned(() -> {\n+                    try {\n+                        synchronized (lock) {\n+                            started.countDown();\n+                            if (!hasCarrier) {\n+                                \/\/ This thread will run at the very\n+                                \/\/ end and won't be notified.\n+                                lock.wait(1);\n+                            } else if (timeout > 0) {\n+                                lock.wait(timeout);\n+                            } else {\n+                                lock.wait();\n+                            }\n+                        }\n+                    } catch (InterruptedException e) { }\n+                });\n+            });\n+\n+            \/\/ if there are carriers available when wait until the thread blocks.\n+            if (hasCarrier) {\n+                System.out.printf(\"%s waiting for thread #%d to block%n\",\n+                        Instant.now(), thread.threadId());\n+                started.await();\n+                await(thread, timeout > 0 ? Thread.State.TIMED_WAITING : Thread.State.WAITING);\n+                carriersAvailable--;\n+            }\n+            threads.add(thread);\n+        }\n+\n+        \/\/ wakeup all threads\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+\n+        \/\/ wait for all threads to terminate\n+        int threadsRemaining = threads.size();\n+        while (threadsRemaining > 0) {\n+            System.out.printf(\"%s waiting for %d threads to terminate%n\",\n+                    Instant.now(), threadsRemaining);\n+            int terminated = 0;\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":104,"deletions":11,"binary":false,"changes":115,"status":"modified"}]}