{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1044,1 +1044,6 @@\n-            if (((JCPatternCaseLabel) l).pat.type.isReference()) {\n+\n+            if (target.switchBootstrapOnlyAllowsReferenceTypesAsCaseLabels()) {\n+                principalType = types.boxedTypeOrType(principalType);\n+            }\n+\n+            if (principalType.isReference()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,0 +248,7 @@\n+\n+    \/** Releases prior to JDK 23 don't allow primitive types as case labels in\n+     *  SwitchBootstrap.typeSwitch\n+     *\/\n+    public boolean switchBootstrapOnlyAllowsReferenceTypesAsCaseLabels() {\n+        return compareTo(Target.JDK1_23) < 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8352621\n+ * @summary Verify javac does not use primitive types in SwitchBootstraps.typeSwitch\n+ *          when compiling with target older than JDK 23\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main NoPrimitivesAsCaseLabelsFor21\n+*\/\n+\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.LoadableConstantEntry;\n+import java.lang.classfile.constantpool.MethodHandleEntry;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import toolbox.JavacTask;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class NoPrimitivesAsCaseLabelsFor21 extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new NoPrimitivesAsCaseLabelsFor21().runTests();\n+    }\n+\n+    NoPrimitivesAsCaseLabelsFor21() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class Test {\n+                                private int test(Object obj) {\n+                                  return switch (obj) {\n+                                      case R1(String s1, String s2) when s1.isEmpty() -> 0;\n+                                      case R1(String s1, String s2) -> 1;\n+                                      case R2(int i1, int i2) when i1 == 0 -> 2;\n+                                      case R2(int i1, int i2) -> 3;\n+                                      default -> 4;\n+                                  };\n+                              }\n+                              record R1(String s1, String s2) {}\n+                              record R2(int i1, int i2) {}\n+                          }\n+                          \"\"\");\n+\n+        Path classes = current.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        for (String version : new String[] {\"23\", System.getProperty(\"java.specification.version\")}) {\n+            new JavacTask(tb)\n+                .options(\"--release\", version)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+            Path testClassFile = classes.resolve(\"test\").resolve(\"Test.class\");\n+            String primitivesInBoostrapArgsForNewer =\n+                    findPrimitiveBootstrapArguments(testClassFile);\n+\n+            if (!primitivesInBoostrapArgsForNewer.contains(\"I-Ljava\/lang\/Class\")) {\n+                throw new AssertionError(\"Expected primitive types in switch bootstrap arguments: \" + primitivesInBoostrapArgsForNewer);\n+            }\n+        }\n+\n+        for (String version : new String[] {\"21\", \"22\"}) {\n+            new JavacTask(tb)\n+                .options(\"--release\", version)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+            Path testClassFile = classes.resolve(\"test\").resolve(\"Test.class\");\n+            String primitivesInBoostrapArgsForOlder =\n+                    findPrimitiveBootstrapArguments(testClassFile);\n+\n+\n+            if (!primitivesInBoostrapArgsForOlder.isEmpty()) {\n+                throw new AssertionError(\"Unexpected primitive types in switch bootstrap arguments: \" + primitivesInBoostrapArgsForOlder);\n+            }\n+        }\n+    }\n+\n+    private String findPrimitiveBootstrapArguments(Path forFile) throws IOException {\n+        AtomicBoolean hasTypeSwitchBootStrap = new AtomicBoolean();\n+        StringBuilder nonClassInTypeSwitchBootStrap = new StringBuilder();\n+        ClassModel testClassFileModel = ClassFile.of().parse(forFile);\n+\n+        testClassFileModel.findAttribute(Attributes.bootstrapMethods())\n+                          .orElseThrow()\n+                          .bootstrapMethods()\n+                          .stream()\n+                          .filter(bme -> isTypeSwitchBoostrap(bme.bootstrapMethod()))\n+                          .forEach(bme -> {\n+            hasTypeSwitchBootStrap.set(true);\n+            for (LoadableConstantEntry e : bme.arguments()) {\n+                if (!(e instanceof ClassEntry)) {\n+                    nonClassInTypeSwitchBootStrap.append(String.valueOf(e));\n+                }\n+            }\n+        });\n+\n+        if (!hasTypeSwitchBootStrap.get()) {\n+            throw new AssertionError(\"Didn't find any typeSwitch bootstraps!\");\n+        }\n+\n+        return nonClassInTypeSwitchBootStrap.toString();\n+    }\n+\n+    private static boolean isTypeSwitchBoostrap(MethodHandleEntry entry) {\n+        DirectMethodHandleDesc desc = entry.asSymbol();\n+        return \"Ljava\/lang\/runtime\/SwitchBootstraps;\".equals(desc.owner().descriptorString()) &&\n+               \"typeSwitch\".equals(desc.methodName()) &&\n+               \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\".equals(desc.lookupDescriptor());\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/NoPrimitivesAsCaseLabelsFor21.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}