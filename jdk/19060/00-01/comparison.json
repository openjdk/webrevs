{"files":[{"patch":"@@ -559,0 +559,152 @@\n+bool CgroupController::read_string(const char* filename, char** result) {\n+  char res[1024];\n+  bool ok = read_from_file<char*>(filename, \"%1023s\", res);\n+  if (!ok) {\n+    return false;\n+  }\n+  *result = os::strdup(res);\n+  return true;\n+}\n+\n+bool CgroupController::read_number(const char* filename, julong* result) {\n+  return read_from_file<julong*>(filename, JULONG_FORMAT, result);\n+}\n+\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+  if (filename == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: filename is null\");\n+    return false;\n+  }\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: subsystem path is null\");\n+    return false;\n+  }\n+  if (key == nullptr || result == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: key or return pointer is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n+    return false;\n+  }\n+\n+  bool found_match = false;\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const int key_len = (int)strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char* key_substr = strstr(line, key);\n+    char after_key = line[key_len];\n+    if (key_substr == line\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n+      }\n+    }\n+  }\n+  fclose(fp);\n+  if (found_match) {\n+    return true;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+                           key, absolute_path);\n+  return false;\n+}\n+\n+bool CgroupController::read_numerical_tuple_value(const char* filename, TupleValue tup, jlong* result) {\n+  char token[1024];\n+  bool is_ok = read_from_file<char*>(filename, tuple_format(tup), token);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  char* t = os::strdup(token);\n+  jlong val = CgroupSubsystem::limit_from_str(t);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED \/\/ Only string\/number literal formats used. See read_*() functions.\n+template <typename T>\n+bool CgroupController::read_from_file(const char* filename, const char* scan_fmt, T result) {\n+  assert(scan_fmt != nullptr, \"invariant\");\n+  if (filename == nullptr) {\n+    log_debug(os, container)(\"read_from_file: filename is null\");\n+    return false;\n+  }\n+  if (result == nullptr) {\n+    log_debug(os, container)(\"read_from_file: return pointer is null\");\n+    return false;\n+  }\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_from_file: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    return false;\n+  }\n+\n+  int matched = sscanf(line, scan_fmt, result);\n+  if (matched == 1) {\n+    return true;\n+  } else {\n+    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n+  }\n+  return false;\n+}\n+PRAGMA_DIAG_POP\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -72,33 +72,9 @@\n-class CgroupController: public CHeapObj<mtInternal> {\n-  public:\n-    virtual char *subsystem_path() = 0;\n-};\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int __cg_file_contents_impl(const char *absolute_path,\n-                                                  const char *scan_fmt,\n-                                                  T returnval) {\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n-  fclose(fp);\n-\n-  int matched = sscanf(line, scan_fmt, returnval);\n-  if (matched == 1) {\n-    return 0;\n-  } else {\n-    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n-  }\n-  return OSCONTAINER_ERROR;\n+#define CONTAINER_READ_NUMBER_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n@@ -106,20 +82,0 @@\n-PRAGMA_DIAG_POP\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int cg_file_contents_ctrl(CgroupController* c,\n-                                                const char *filename,\n-                                                const char *scan_fmt,\n-                                                T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"cg_file_contents_ctrl: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"cg_file_contents_ctrl: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (scan_fmt == nullptr || returnval == nullptr) {\n-    log_debug(os, container)(\"cg_file_contents_ctrl: scan_fmt or return pointer is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n@@ -127,11 +83,9 @@\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > MAXPATHLEN) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-  return __cg_file_contents_impl<T>(absolute_path, scan_fmt, returnval);\n+#define CONTAINER_READ_STRING_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_string(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return nullptr;                                                                   \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: %s\", retval);                             \\\n@@ -139,1 +93,0 @@\n-PRAGMA_DIAG_POP\n@@ -141,11 +94,0 @@\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int __cg_file_multi_line_impl(const char *absolute_path,\n-                                                    const char *key,\n-                                                    const char *scan_fmt,\n-                                                    T returnval) {\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n@@ -153,8 +95,1 @@\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n+enum TupleValue { FIRST, SECOND };\n@@ -162,16 +97,12 @@\n-  bool found_match = false;\n-  \/\/ File consists of multiple lines in a \"key value\"\n-  \/\/ fashion, we have to find the key.\n-  const int key_len = (int)strlen(key);\n-  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-    char* key_substr = strstr(line, key);\n-    char after_key = line[key_len];\n-    if (key_substr == line\n-          && isspace(after_key) != 0\n-          && after_key != '\\n') {\n-      \/\/ Skip key, skip space\n-      const char* value_substr = line + key_len + 1;\n-      int matched = sscanf(value_substr, scan_fmt, returnval);\n-      found_match = matched == 1;\n-      if (found_match) {\n-        break;\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path() = 0;\n+    bool read_number(const char* filename, julong* result);\n+    bool read_string(const char* filename, char** result);\n+    bool read_numerical_tuple_value(const char* filename, TupleValue val, jlong* result);\n+    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+  private:\n+    inline static const char* tuple_format(TupleValue val) {\n+      switch(val) {\n+        case FIRST:  return \"%1023s %*s\";\n+        case SECOND: return \"%*s %1023s\";\n@@ -179,0 +110,1 @@\n+      return nullptr;\n@@ -180,44 +112,3 @@\n-  }\n-  fclose(fp);\n-  if (found_match) {\n-    return 0;\n-  }\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n-                           key, absolute_path);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int cg_file_multi_line_ctrl(CgroupController* c,\n-                                                  const char *filename,\n-                                                  const char *key,\n-                                                  const char *scan_fmt,\n-                                                  T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"cg_file_multi_line_ctrl: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"cg_file_multi_line_ctrl: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (key == nullptr || scan_fmt == nullptr || returnval == nullptr) {\n-    log_debug(os, container)(\"cg_file_multi_line_ctrl: key, scan_fmt or return pointer is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > MAXPATHLEN) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-  return __cg_file_multi_line_impl<T>(absolute_path, key, scan_fmt, returnval);\n-}\n-PRAGMA_DIAG_POP\n+    template <typename T>\n+       bool read_from_file(const char* filename, const char* scan_fmt, T result);\n+};\n@@ -268,1 +159,1 @@\n-    jlong limit_from_str(char* limit_str);\n+    static jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":36,"deletions":145,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -78,8 +78,3 @@\n-  jlong use_hierarchy;\n-  int err = cg_file_contents_ctrl(this, \"\/memory.use_hierarchy\", JLONG_FORMAT, &use_hierarchy);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Use Hierarchy is: %d\", OSCONTAINER_ERROR);\n-    return (jlong)OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Use Hierarchy is: \" JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  julong use_hierarchy;\n+  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  return (jlong)use_hierarchy;\n@@ -98,7 +93,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.limit_in_bytes\", JULONG_FORMAT, &memlimit);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Memory Limit is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Memory Limit is: \" JULONG_FORMAT, memlimit);\n-\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n@@ -110,3 +99,3 @@\n-      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n-                                    \"hierarchical_memory_limit\", JULONG_FORMAT, &hier_memlimit);\n-      if (err != 0) {\n+      bool is_ok = _memory->controller()->\n+                        read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n+      if (!is_ok) {\n@@ -145,6 +134,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", JULONG_FORMAT, &memswlimit);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Memory and Swap Limit is: \" JULONG_FORMAT, memswlimit);\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -157,2 +141,3 @@\n-      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", matchline, JULONG_FORMAT, &hier_memswlimit);\n-      if (err != 0) {\n+      bool is_ok = _memory->controller()->\n+                      read_numerical_key_value(\"\/memory.stat\", matchline, &hier_memswlimit);\n+      if (!is_ok) {\n@@ -161,1 +146,1 @@\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, hier_memswlimit);\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n@@ -198,6 +183,1 @@\n-  int err = cg_file_contents_ctrl(ctrl, \"\/memory.memsw.usage_in_bytes\", JULONG_FORMAT, &memory_swap_usage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"mem swap usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"mem swap usage is: \" JULONG_FORMAT, memory_swap_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n@@ -221,7 +201,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.swappiness\",\n-                                  JULONG_FORMAT, &swappiness);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Swappiness is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Swappiness is: \" JULONG_FORMAT, swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -233,7 +207,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                                  JULONG_FORMAT, &memsoftlimit);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Memory Soft Limit is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Memory Soft Limit is: \" JULONG_FORMAT, memsoftlimit);\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n@@ -258,9 +226,3 @@\n-  jlong memusage;\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.usage_in_bytes\",\n-                                  JLONG_FORMAT, &memusage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -278,9 +240,3 @@\n-  jlong memmaxusage;\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                                  JLONG_FORMAT, &memmaxusage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Maximum Memory Usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Maximum Memory Usage is: \" JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n+  julong memmaxusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  return (jlong)memmaxusage;\n@@ -291,2 +247,3 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"rss\", JULONG_FORMAT, &rss);\n-  if (err != 0) {\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n+  if (!is_ok) {\n@@ -296,1 +253,1 @@\n-  return rss;\n+  return (jlong)rss;\n@@ -301,2 +258,3 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"cache\", JULONG_FORMAT, &cache);\n-  if (err != 0) {\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n+  if (!is_ok) {\n@@ -310,9 +268,3 @@\n-  jlong kmem_usage;\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                                  JLONG_FORMAT, &kmem_usage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Kernel Memory Usage is: \" JLONG_FORMAT, kmem_usage);\n-  return kmem_usage;\n+  julong kmem_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  return (jlong)kmem_usage;\n@@ -323,7 +275,1 @@\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                                  JULONG_FORMAT, &kmem_limit);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Kernel Memory Limit is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Kernel Memory Limit is: \" JULONG_FORMAT, kmem_limit);\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n@@ -337,9 +283,3 @@\n-  jlong kmem_max_usage;\n-  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                                  JLONG_FORMAT, &kmem_max_usage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Maximum Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Maximum Kernel Memory Usage is: \" JLONG_FORMAT, kmem_max_usage);\n-  return kmem_max_usage;\n+  julong kmem_max_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  return (jlong)kmem_max_usage;\n@@ -359,7 +299,3 @@\n-  char cpus[1024];\n-  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.cpus\", \"%1023s\", cpus);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n-  return os::strdup(cpus);\n+  char* cpus = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n+  return cpus;\n@@ -369,7 +305,3 @@\n-  char mems[1024];\n-  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.mems\", \"%1023s\", mems);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n-  return os::strdup(mems);\n+  char* mems = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.mems\", \"cpuset.mems\", mems);\n+  return mems;\n@@ -389,4 +321,5 @@\n-  int quota;\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_quota_us\", \"%d\", &quota);\n-  if (err != 0) {\n-    log_trace(os, container)(\"CPU Quota is: %d\", OSCONTAINER_ERROR);\n+  julong quota;\n+  bool is_ok = _cpu->controller()->\n+                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n@@ -395,2 +328,5 @@\n-  log_trace(os, container)(\"CPU Quota is: %d\", quota);\n-  return quota;\n+  \/\/ cast to int since the read value might be negative\n+  \/\/ and we want to avoid logging -1 as a large unsigned value.\n+  int quota_int = (int)quota;\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota_int);\n+  return quota_int;\n@@ -400,8 +336,3 @@\n-  int period;\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_period_us\", \"%d\", &period);\n-  if (err != 0) {\n-    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"CPU Period is: %d\", period);\n-  return period;\n+  julong period;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  return (int)period;\n@@ -421,7 +352,3 @@\n-  int shares;\n-  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.shares\", \"%d\", &shares);\n-  if (err != 0) {\n-    log_trace(os, container)(\"CPU Shares is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"CPU Shares is: %d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -429,1 +356,1 @@\n-  if (shares == 1024) return -1;\n+  if (shares_int == 1024) return -1;\n@@ -431,1 +358,1 @@\n-  return shares;\n+  return shares_int;\n@@ -436,7 +363,3 @@\n-  char pidsmax[1024];\n-  int err = cg_file_contents_ctrl(_pids, \"\/pids.max\", \"%1023s\", pidsmax);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n-  return os::strdup(pidsmax);\n+  char* pidsmax = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_pids, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n+  return pidsmax;\n@@ -470,8 +393,3 @@\n-  jlong pids_current;\n-  int err = cg_file_contents_ctrl(_pids, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n-  return pids_current;\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  return (jlong)pids_current;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":65,"deletions":147,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -38,7 +38,3 @@\n-  int shares;\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.weight\", \"%d\", &shares);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Raw value for CPU Shares is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Raw value for CPU Shares is: %d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -46,1 +42,1 @@\n-  if (shares == 100) {\n+  if (shares_int == 100) {\n@@ -58,1 +54,1 @@\n-  int x = 262142 * shares - 1;\n+  int x = 262142 * shares_int - 1;\n@@ -91,2 +87,6 @@\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+  jlong quota_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", FIRST, &quota_val);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  int limit = (int)quota_val;\n@@ -98,17 +98,3 @@\n-  char cpus[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.cpus\", \"%1023s\", cpus);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n-  return os::strdup(cpus);\n-}\n-\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  char quota[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%1023s %*d\", quota);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Raw value for CPU quota is: %s\", quota);\n-  return os::strdup(quota);\n+  char* cpus = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n+  return cpus;\n@@ -118,7 +104,3 @@\n-  char mems[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.mems\", \"%1023s\", mems);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n-  return os::strdup(mems);\n+  char* mems;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems);\n+  return mems;\n@@ -128,4 +110,4 @@\n-  int period;\n-  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%*s %d\", &period);\n-  if (err != 0) {\n-    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n+  jlong period_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", SECOND, &period_val);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n@@ -134,0 +116,1 @@\n+  int period = (int)period_val;\n@@ -148,8 +131,3 @@\n-  jlong memusage;\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.current\", JLONG_FORMAT, &memusage);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -171,3 +149,3 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n-                                    \"anon\", JULONG_FORMAT, &rss);\n-  if (err != 0) {\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  if (!is_ok) {\n@@ -182,3 +160,3 @@\n-  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n-                                    \"file\", JULONG_FORMAT, &cache);\n-  if (err != 0) {\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  if (!is_ok) {\n@@ -192,7 +170,3 @@\n-  char mem_soft_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.low\", \"%1023s\", mem_soft_limit_str);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Memory Soft Limit is: %s\", mem_soft_limit_str);\n-  return os::strdup(mem_soft_limit_str);\n+  char* mem_soft_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit_str);\n+  return mem_soft_limit_str;\n@@ -235,9 +209,3 @@\n-  char mem_swp_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.max\", \"%1023s\", mem_swp_limit_str);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  \/\/ FIXME: This log-line is misleading, since it reads the swap limit only, not memory *and*\n-  \/\/ swap limit.\n-  log_trace(os, container)(\"Memory and Swap Limit is: %s\", mem_swp_limit_str);\n-  return os::strdup(mem_swp_limit_str);\n+  char* mem_swp_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.max\", \"Swap Limit\", mem_swp_limit_str);\n+  return mem_swp_limit_str;\n@@ -248,7 +216,3 @@\n-  char mem_swp_current_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.current\", \"%1023s\", mem_swp_current_str);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Swap currently used is: %s\", mem_swp_current_str);\n-  return os::strdup(mem_swp_current_str);\n+  char* mem_swp_current_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", mem_swp_current_str);\n+  return mem_swp_current_str;\n@@ -279,7 +243,3 @@\n-  char mem_limit_str[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/memory.max\", \"%1023s\", mem_limit_str);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Raw value for memory limit is: %s\", mem_limit_str);\n-  return os::strdup(mem_limit_str);\n+  char* mem_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.max\", \"Raw value for memory limit\", mem_limit_str);\n+  return mem_limit_str;\n@@ -309,7 +269,3 @@\n-  char pidsmax[1024];\n-  int err = cg_file_contents_ctrl(_unified, \"\/pids.max\", \"%1023s\", pidsmax);\n-  if (err != 0) {\n-    return nullptr;\n-  }\n-  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n-  return os::strdup(pidsmax);\n+  char* pidsmax;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n+  return pidsmax;\n@@ -341,7 +297,2 @@\n-  jlong pids_current;\n-  int err = cg_file_contents_ctrl(_unified, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n-  if (err != 0) {\n-    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n-    return OSCONTAINER_ERROR;\n-  }\n-  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":48,"deletions":97,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    char *cpu_quota_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-TEST(cgroupTest, cg_file_multi_line_impl_failure_cases) {\n+TEST(cgroupTest, read_numerical_key_value_failure_cases) {\n@@ -95,8 +95,6 @@\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n@@ -104,4 +102,2 @@\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong x = 0xBAD;\n@@ -109,4 +105,16 @@\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n+  fill_file(test_file, \"foo \");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"Value must not be missing in key\/value case\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"faulty_start foo 101\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be at the start\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foof 1002\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be exact match\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n@@ -118,1 +126,1 @@\n-TEST(cgroupTest, cg_file_multi_line_impl_success_cases) {\n+TEST(cgroupTest, read_numerical_key_value_success_cases) {\n@@ -120,29 +128,34 @@\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong x = 0xBAD;\n+\n+  fill_file(test_file, \"foo 100\");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)100, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foof 100\\nfoo 133\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)133, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foo\\t333\\nfoot 999\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)333, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n@@ -150,3 +163,3 @@\n-  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)1, x) << \"Incorrect!\";\n@@ -158,60 +171,1 @@\n-TEST(cgroupTest, cg_file_contents_impl) {\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"'foo' cannot be read as int\";\n-  EXPECT_EQ(x, 0);\n-\n-  fill_file(test_file, \"1337\");\n-  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = __cg_file_contents_impl(test_file, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = __cg_file_contents_impl(test_file, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = __cg_file_contents_impl(test_file, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = __cg_file_contents_impl(test_file, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, cg_file_contents_ctrl_null) {\n+TEST(cgroupTest, read_number_null) {\n@@ -220,2 +174,1 @@\n-  const char* scan_fmt = \"%d\";\n-  int a = -1;\n+  julong a = 0xBAD;\n@@ -223,8 +176,4 @@\n-  int err = cg_file_contents_ctrl<int*>(null_path_controller, test_file_path, scan_fmt, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n-  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n-  \/\/ null controller\n-  err = cg_file_contents_ctrl<int*>(nullptr, test_file_path, scan_fmt, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n-  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n-  \/\/ null scan_fmt, null return pointer\n+  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  \/\/ null file, null return pointer\n@@ -232,4 +181,5 @@\n-  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, nullptr, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n-  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, scan_fmt, nullptr);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+  is_ok = test_controller->read_number(nullptr, &a);\n+  EXPECT_FALSE(is_ok) << \"Null file should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  is_ok = test_controller->read_number(test_file_path, nullptr);\n+  EXPECT_FALSE(is_ok) << \"Null return pointer should be an error\";\n@@ -238,1 +188,1 @@\n-TEST(cgroupTest, cg_file_contents_ctrl_beyond_max_path) {\n+TEST(cgroupTest, read_string_beyond_max_path) {\n@@ -246,5 +196,4 @@\n-  const char* scan_fmt = \"%d\";\n-  int foo = -1;\n-  int err = cg_file_contents_ctrl<int*>(too_large_path_controller, test_file_path, scan_fmt, &foo);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n-  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+  char* foo = nullptr;\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, &foo);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_TRUE(nullptr == foo) << \"Expected untouched scan value\";\n@@ -253,1 +202,1 @@\n-TEST(cgroupTest, cg_file_contents_ctrl_file_not_exist) {\n+TEST(cgroupTest, read_number_file_not_exist) {\n@@ -256,5 +205,4 @@\n-  const char* scan_fmt = \"\/not-used\";\n-  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n-  int err = cg_file_contents_ctrl<const char*>(unknown_path_ctrl, test_file_path, scan_fmt, ret_val[0]);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n-  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+  julong result = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, result) << \"Expected untouched scan value\";\n@@ -263,1 +211,1 @@\n-TEST(cgroupTest, cg_file_multi_line_ctrl_null) {\n+TEST(cgroupTest, read_numerical_key_value_null) {\n@@ -266,1 +214,0 @@\n-  const char* scan_fmt = \"%d\";\n@@ -268,1 +215,1 @@\n-  int a = -1;\n+  julong a = 0xBAD;\n@@ -270,8 +217,4 @@\n-  int err = cg_file_multi_line_ctrl<int*>(null_path_controller, test_file_path, key, scan_fmt, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n-  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n-  \/\/ null controller\n-  err = cg_file_multi_line_ctrl<int*>(nullptr, test_file_path, key, scan_fmt, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n-  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n-  \/\/ null key, null scan_fmt, null return pointer\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  \/\/ null key, null file, null return pointer\n@@ -279,6 +222,117 @@\n-  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, nullptr, scan_fmt, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null key should be an error\";\n-  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, nullptr, &a);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n-  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, scan_fmt, nullptr);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+  is_ok = test_controller->read_numerical_key_value(test_file_path, nullptr, &a);\n+  EXPECT_FALSE(is_ok) << \"Null key should be an error\";\n+  is_ok = test_controller->read_numerical_key_value(nullptr, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null file should be an error\";\n+  is_ok = test_controller->read_numerical_key_value(test_file_path, key, nullptr);\n+  EXPECT_FALSE(is_ok) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, read_number_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"8888\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong foo = 0xBAD;\n+  bool ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  \/\/ Some interface files might have negative values, ensure we can read\n+  \/\/ them and manually cast them as needed.\n+  fill_file(test_file, \"-1\");\n+  foo = 0xBAD;\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  foo = 0xBAD;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_EQ((julong)0xBAD, foo) << \"foo was altered\";\n+\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_string_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"foo-bar\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  char* result = nullptr;\n+  bool ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"foo-bar\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  result = nullptr;\n+  fill_file(test_file, \"1234\");\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"1234\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  \/\/ values with a space only read in the first token\n+  result = nullptr;\n+  fill_file(test_file, \"abc def\");\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"abc\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  result = nullptr;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_TRUE(result == nullptr) << \"Expected untouched result\";\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_tuple_test) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"max 10000\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  jlong result = -10;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read value\";\n+  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, SECOND, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read the value\";\n+  EXPECT_EQ((jlong)10000, result) << \"result value incorrect\";\n+\n+  \/\/ non-max strings\n+  fill_file(test_file, \"abc 10000\");\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_FALSE(ok) << \"abc should not be parsable\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+\n+  fill_file(test_file, nullptr);\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should be an error\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n@@ -287,1 +341,1 @@\n-TEST(cgroupTest, cg_file_multi_line_ctrl_beyond_max_path) {\n+TEST(cgroupTest, read_numerical_key_beyond_max_path) {\n@@ -295,1 +349,0 @@\n-  const char* scan_fmt = \"%d\";\n@@ -297,4 +350,4 @@\n-  int foo = -1;\n-  int err = cg_file_multi_line_ctrl<int*>(too_large_path_controller, test_file_path, key, scan_fmt, &foo);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n-  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+  julong a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n@@ -303,1 +356,1 @@\n-TEST(cgroupTest, cg_file_multi_line_ctrl_file_not_exist) {\n+TEST(cgroupTest, read_numerical_key_file_not_exist) {\n@@ -306,1 +359,0 @@\n-  const char* scan_fmt = \"\/not-used\";\n@@ -308,4 +360,4 @@\n-  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n-  int err = cg_file_multi_line_ctrl<const char*>(unknown_path_ctrl, test_file_path, key, scan_fmt, ret_val[0]);\n-  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n-  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+  julong a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":217,"deletions":165,"binary":false,"changes":382,"status":"modified"},{"patch":"@@ -203,2 +203,2 @@\n-            .shouldMatch(\"Memory and Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n-            .shouldNotMatch(\"Memory and Swap Limit is:.*\" + neg2InUnsignedLong);\n+            .shouldMatch(\"(Memory and )?Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n+            .shouldNotMatch(\"(Memory and )?Swap Limit is:.*\" + neg2InUnsignedLong);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}