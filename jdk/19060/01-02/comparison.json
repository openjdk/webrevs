{"files":[{"patch":"@@ -559,4 +559,34 @@\n-bool CgroupController::read_string(const char* filename, char** result) {\n-  char res[1024];\n-  bool ok = read_from_file<char*>(filename, \"%1023s\", res);\n-  if (!ok) {\n+bool CgroupController::read_string(const char* filename, char* buf) {\n+  assert(buf != nullptr, \"invariant\");\n+  if (filename == nullptr) {\n+    log_debug(os, container)(\"read_string: filename is null\");\n+    return false;\n+  }\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_string: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  \/\/ Read a single line into the provided buffer. At most 1023 characters.\n+  char* line = fgets(buf, 1024, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n@@ -565,1 +595,5 @@\n-  *result = os::strdup(res);\n+  int len = strlen(line);\n+  assert(len <= 1023, \"At most 1023 bytes can be read\");\n+  if (line[len - 1] == '\\n') {\n+    line[len - 1] = '\\0'; \/\/ trim trailing new line\n+  }\n@@ -570,1 +604,24 @@\n-  return read_from_file<julong*>(filename, JULONG_FORMAT, result);\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  if (matched == 1) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(buf);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n@@ -642,2 +699,2 @@\n-  char token[1024];\n-  bool is_ok = read_from_file<char*>(filename, tuple_format(tup), token);\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf);\n@@ -647,35 +704,11 @@\n-  char* t = os::strdup(token);\n-  jlong val = CgroupSubsystem::limit_from_str(t);\n-  if (val == OSCONTAINER_ERROR) {\n-    return false;\n-  }\n-  *result = val;\n-  return true;\n-}\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED \/\/ Only string\/number literal formats used. See read_*() functions.\n-template <typename T>\n-bool CgroupController::read_from_file(const char* filename, const char* scan_fmt, T result) {\n-  assert(scan_fmt != nullptr, \"invariant\");\n-  if (filename == nullptr) {\n-    log_debug(os, container)(\"read_from_file: filename is null\");\n-    return false;\n-  }\n-  if (result == nullptr) {\n-    log_debug(os, container)(\"read_from_file: return pointer is null\");\n-    return false;\n-  }\n-  char* s_path = subsystem_path();\n-  if (s_path == nullptr) {\n-    log_debug(os, container)(\"read_from_file: subsystem path is null\");\n-    return false;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(s_path);\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > MAXPATHLEN) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return false;\n+  char token[1024];\n+  int matched = -1;\n+  switch(tup) {\n+    case TupleValue::FIRST:  {\n+      matched = sscanf(buf, \"%1023s %*s\", token);\n+      break;\n+    }\n+    case TupleValue::SECOND: {\n+      matched = sscanf(buf, \"%*s %1023s\", token);\n+      break;\n+    }\n@@ -683,6 +716,1 @@\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+  if (matched != 1) {\n@@ -691,7 +719,2 @@\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  fclose(fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+  jlong val = limit_from_str(token);\n+  if (val == OSCONTAINER_ERROR) {\n@@ -700,8 +723,2 @@\n-\n-  int matched = sscanf(line, scan_fmt, result);\n-  if (matched == 1) {\n-    return true;\n-  } else {\n-    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n-  }\n-  return false;\n+  *result = val;\n+  return true;\n@@ -709,1 +726,0 @@\n-PRAGMA_DIAG_POP\n@@ -711,1 +727,1 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+jlong CgroupController::limit_from_str(char* limit_str) {\n@@ -718,1 +734,0 @@\n-    os::free(limit_str);\n@@ -723,1 +738,0 @@\n-    os::free(limit_str);\n@@ -726,1 +740,0 @@\n-  os::free(limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":82,"deletions":69,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -83,0 +83,11 @@\n+#define CONTAINER_READ_NUMBER_CHECKED_MAX(controller, filename, log_string, retval)   \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n+}\n+\n@@ -86,1 +97,1 @@\n-  is_ok = controller->read_string(filename, &retval);                                 \\\n+  is_ok = controller->read_string(filename, retval);                                  \\\n@@ -94,2 +105,7 @@\n-\n-enum TupleValue { FIRST, SECOND };\n+\/*\n+ * Used to model the tuple-valued cgroup interface files like cpu.max, which\n+ * contains two values: <quota> <period>. In this case the first tuple value\n+ * is <quota> and the second tuple value is <period>. We use this to map the\n+ * tuple value to a constant string format for sscanf reading.\n+ *\/\n+enum class TupleValue { FIRST, SECOND };\n@@ -100,0 +116,6 @@\n+\n+    \/* Read a numerical value as unsigned long\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value is set in the provided julong pointer.\n+     *\/\n@@ -101,1 +123,28 @@\n-    bool read_string(const char* filename, char** result);\n+\n+    \/* Convenience method to deal with numbers as well as the string 'max'\n+     * in interface files. Otherwise same as read_number().\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value (which might be negative) is being set in\n+     * the provided jlong pointer.\n+     *\/\n+    bool read_number_handle_max(const char* filename, jlong* result);\n+\n+    \/* Read a string of at most 1K - 1 characters from the interface file.\n+     * The provided buffer must be at least 1K (1024) in size so as to account\n+     * for the null terminating character. Callers must ensure that the buffer\n+     * is appropriately in-scope and of sufficient size.\n+     *\n+     * returns: false if any error occured. true otherwise and the passed\n+     * in buffer will contain the first 1023 characters of the string or\n+     * up to the first new line character ('\\n') whichever comes first.\n+     *\/\n+    bool read_string(const char* filename, char* buf);\n+\n+    \/* Read a tuple value as a number. Tuple is: '<first> <second>'.\n+     * Handles 'max' (for unlimited) for any tuple value. This is handy for\n+     * parsing interface files like cpu.max which contain such tuples.\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed\n+     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     *\/\n@@ -103,0 +152,8 @@\n+\n+    \/* Read a numerical value from a multi-line interface file. The matched line is\n+     * determined by the provided 'key'. The associated numerical value is being set\n+     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed value is\n+     * being set in the provided julong pointer.\n+     *\/\n@@ -104,0 +161,1 @@\n+\n@@ -105,9 +163,1 @@\n-    inline static const char* tuple_format(TupleValue val) {\n-      switch(val) {\n-        case FIRST:  return \"%1023s %*s\";\n-        case SECOND: return \"%*s %1023s\";\n-      }\n-      return nullptr;\n-    }\n-    template <typename T>\n-       bool read_from_file(const char* filename, const char* scan_fmt, T result);\n+    static jlong limit_from_str(char* limit_str);\n@@ -159,1 +209,0 @@\n-    static jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":63,"deletions":14,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -298,2 +298,2 @@\n-char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n-  char* cpus = nullptr;\n+char* CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n@@ -301,1 +301,1 @@\n-  return cpus;\n+  return os::strdup(cpus);\n@@ -304,2 +304,2 @@\n-char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n-  char* mems = nullptr;\n+char* CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n@@ -307,1 +307,1 @@\n-  return mems;\n+  return os::strdup(mems);\n@@ -361,7 +361,0 @@\n-\n-char* CgroupV1Subsystem::pids_max_val() {\n-  char* pidsmax = nullptr;\n-  CONTAINER_READ_STRING_CHECKED(_pids, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n-  return pidsmax;\n-}\n-\n@@ -379,2 +372,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -117,2 +117,0 @@\n-    char * pids_max_val();\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", FIRST, &quota_val);\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", TupleValue::FIRST, &quota_val);\n@@ -97,2 +97,2 @@\n-char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n-  char* cpus = nullptr;\n+char* CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n@@ -100,1 +100,1 @@\n-  return cpus;\n+  return os::strdup(cpus);\n@@ -103,2 +103,2 @@\n-char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n-  char* mems;\n+char* CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n@@ -106,1 +106,1 @@\n-  return mems;\n+  return os::strdup(mems);\n@@ -111,1 +111,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", SECOND, &period_val);\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", TupleValue::SECOND, &period_val);\n@@ -137,2 +137,3 @@\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+  jlong mem_soft_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  return mem_soft_limit;\n@@ -169,6 +170,0 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  char* mem_soft_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit_str);\n-  return mem_soft_limit_str;\n-}\n-\n@@ -181,2 +176,3 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  if (mem_swp_limit_str == nullptr) {\n+  jlong swap_limit;\n+  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  if (!is_ok) {\n@@ -184,1 +180,1 @@\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n@@ -188,1 +184,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n@@ -201,2 +197,1 @@\n-        char* mem_swp_current_str = mem_swp_current_val();\n-        jlong swap_current = limit_from_str(mem_swp_current_str);\n+        jlong swap_current = mem_swp_current_val();\n@@ -208,4 +203,4 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  char* mem_swp_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.max\", \"Swap Limit\", mem_swp_limit_str);\n-  return mem_swp_limit_str;\n+jlong CgroupV2Subsystem::mem_swp_limit_val() {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -215,4 +210,4 @@\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  char* mem_swp_current_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", mem_swp_current_str);\n-  return mem_swp_current_str;\n+jlong CgroupV2Subsystem::mem_swp_current_val() {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -230,16 +225,3 @@\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n-  if (log_is_enabled(Trace, os, container)) {\n-    if (limit == -1) {\n-      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n-    } else {\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n-    }\n-  }\n-  return limit;\n-}\n-\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  char* mem_limit_str;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.max\", \"Raw value for memory limit\", mem_limit_str);\n-  return mem_limit_str;\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -249,5 +231,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n-\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_current = mem_swp_current_val();\n+  jlong swap_limit = mem_swp_limit_val();\n@@ -268,6 +247,0 @@\n-char* CgroupV2Subsystem::pids_max_val() {\n-  char* pidsmax;\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n-  return pidsmax;\n-}\n-\n@@ -284,2 +257,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":33,"deletions":59,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -59,5 +59,2 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *pids_max_val();\n+    jlong mem_swp_limit_val();\n+    jlong mem_swp_current_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,2 +196,3 @@\n-  char* foo = nullptr;\n-  bool is_ok = too_large_path_controller->read_string(test_file_path, &foo);\n+  char foo[1024];\n+  foo[0] = '\\0';\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, foo);\n@@ -199,1 +200,1 @@\n-  EXPECT_TRUE(nullptr == foo) << \"Expected untouched scan value\";\n+  EXPECT_STREQ(\"\", foo) << \"Expected untouched scan value\";\n@@ -260,0 +261,20 @@\n+  \/\/ Some interface files have numbers as well as the string\n+  \/\/ 'max', which means unlimited.\n+  jlong result = -10;\n+  fill_file(test_file, \"max\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for 'max' string should have been successful\";\n+  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+\n+  result = -10;\n+  fill_file(test_file, \"11114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+\n+  result = -10;\n+  fill_file(test_file, \"-51114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+\n@@ -274,2 +295,2 @@\n-  char* result = nullptr;\n-  bool ok = controller->read_string(base_with_slash, &result);\n+  char result[1024];\n+  bool ok = controller->read_string(base_with_slash, result);\n@@ -277,1 +298,0 @@\n-  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n@@ -279,1 +299,0 @@\n-  os::free(result);\n@@ -281,1 +300,1 @@\n-  result = nullptr;\n+  result[0] = '\\0';\n@@ -283,1 +302,1 @@\n-  ok = controller->read_string(base_with_slash, &result);\n+  ok = controller->read_string(base_with_slash, result);\n@@ -285,1 +304,0 @@\n-  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n@@ -287,1 +305,0 @@\n-  os::free(result);\n@@ -289,2 +306,2 @@\n-  \/\/ values with a space only read in the first token\n-  result = nullptr;\n+  \/\/ values with a space\n+  result[0] = '\\0';\n@@ -292,1 +309,1 @@\n-  ok = controller->read_string(base_with_slash, &result);\n+  ok = controller->read_string(base_with_slash, result);\n@@ -294,3 +311,1 @@\n-  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n-  EXPECT_STREQ(\"abc\", result) << \"Expected strings to be equal\";\n-  os::free(result);\n+  EXPECT_STREQ(\"abc def\", result) << \"Expected strings to be equal\";\n@@ -298,1 +313,8 @@\n-  result = nullptr;\n+  \/\/ only the first line are being returned\n+  result[0] = '\\0';\n+  fill_file(test_file, \"test\\nabc\");\n+  ok = controller->read_string(base_with_slash, result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"test\", result) << \"Expected strings to be equal\";\n+\n+  result[0] = '\\0';\n@@ -300,1 +322,1 @@\n-  ok = controller->read_string(base_with_slash, &result);\n+  ok = controller->read_string(base_with_slash, result);\n@@ -302,1 +324,1 @@\n-  EXPECT_TRUE(result == nullptr) << \"Expected untouched result\";\n+  EXPECT_STREQ(\"\", result) << \"Expected untouched result\";\n@@ -304,0 +326,16 @@\n+\n+  \/\/ File contents larger than 1K\n+  \/\/ We only read in the first 1K - 1 bytes\n+  char too_large[2 * 1024];\n+  for (int i = 0; i < (2 * 1024); i++) {\n+    too_large[i] = 'A' + (i % 26);\n+  }\n+  result[0] = '\\0';\n+  fill_file(test_file, too_large);\n+  ok = controller->read_string(base_with_slash, result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(1023 == strlen(result)) << \"Expected only the first 1023 chars to be read in\";\n+  for (int i = 0; i < 1023; i++) {\n+    EXPECT_EQ(too_large[i], result[i]) << \"Expected item at idx \" << i << \" to match\";\n+  }\n+  EXPECT_EQ(result[1023], '\\0') << \"The last character must be the null character\";\n@@ -318,1 +356,1 @@\n-  bool ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, TupleValue::FIRST, &result);\n@@ -323,1 +361,1 @@\n-  ok = controller->read_numerical_tuple_value(base_with_slash, SECOND, &result);\n+  ok = controller->read_numerical_tuple_value(base_with_slash, TupleValue::SECOND, &result);\n@@ -330,1 +368,1 @@\n-  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  ok = controller->read_numerical_tuple_value(base_with_slash, TupleValue::FIRST, &result);\n@@ -336,1 +374,1 @@\n-  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  ok = controller->read_numerical_tuple_value(base_with_slash, TupleValue::FIRST, &result);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":62,"deletions":24,"binary":false,"changes":86,"status":"modified"}]}