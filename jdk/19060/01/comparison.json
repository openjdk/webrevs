{"files":[{"patch":"@@ -559,0 +559,152 @@\n+bool CgroupController::read_string(const char* filename, char** result) {\n+  char res[1024];\n+  bool ok = read_from_file<char*>(filename, \"%1023s\", res);\n+  if (!ok) {\n+    return false;\n+  }\n+  *result = os::strdup(res);\n+  return true;\n+}\n+\n+bool CgroupController::read_number(const char* filename, julong* result) {\n+  return read_from_file<julong*>(filename, JULONG_FORMAT, result);\n+}\n+\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+  if (filename == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: filename is null\");\n+    return false;\n+  }\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: subsystem path is null\");\n+    return false;\n+  }\n+  if (key == nullptr || result == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: key or return pointer is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n+    return false;\n+  }\n+\n+  bool found_match = false;\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const int key_len = (int)strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char* key_substr = strstr(line, key);\n+    char after_key = line[key_len];\n+    if (key_substr == line\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n+      }\n+    }\n+  }\n+  fclose(fp);\n+  if (found_match) {\n+    return true;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+                           key, absolute_path);\n+  return false;\n+}\n+\n+bool CgroupController::read_numerical_tuple_value(const char* filename, TupleValue tup, jlong* result) {\n+  char token[1024];\n+  bool is_ok = read_from_file<char*>(filename, tuple_format(tup), token);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  char* t = os::strdup(token);\n+  jlong val = CgroupSubsystem::limit_from_str(t);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED \/\/ Only string\/number literal formats used. See read_*() functions.\n+template <typename T>\n+bool CgroupController::read_from_file(const char* filename, const char* scan_fmt, T result) {\n+  assert(scan_fmt != nullptr, \"invariant\");\n+  if (filename == nullptr) {\n+    log_debug(os, container)(\"read_from_file: filename is null\");\n+    return false;\n+  }\n+  if (result == nullptr) {\n+    log_debug(os, container)(\"read_from_file: return pointer is null\");\n+    return false;\n+  }\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_from_file: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    return false;\n+  }\n+\n+  int matched = sscanf(line, scan_fmt, result);\n+  if (matched == 1) {\n+    return true;\n+  } else {\n+    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n+  }\n+  return false;\n+}\n+PRAGMA_DIAG_POP\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -72,87 +72,9 @@\n-typedef char * cptr;\n-\n-class CgroupController: public CHeapObj<mtInternal> {\n-  public:\n-    virtual char *subsystem_path() = 0;\n-};\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  bool found_match = false;\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n-          && isspace(after_key) != 0\n-          && after_key != '\\n') {\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n-      }\n-    }\n-  }\n-  fclose(fp);\n-  if (found_match) {\n-    return 0;\n-  }\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n-  return OSCONTAINER_ERROR;\n+#define CONTAINER_READ_NUMBER_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n@@ -160,1 +82,0 @@\n-PRAGMA_DIAG_POP\n@@ -162,18 +83,9 @@\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n+#define CONTAINER_READ_STRING_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_string(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return nullptr;                                                                   \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: %s\", retval);                             \\\n@@ -182,15 +94,0 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n@@ -198,15 +95,1 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+enum TupleValue { FIRST, SECOND };\n@@ -214,0 +97,18 @@\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path() = 0;\n+    bool read_number(const char* filename, julong* result);\n+    bool read_string(const char* filename, char** result);\n+    bool read_numerical_tuple_value(const char* filename, TupleValue val, jlong* result);\n+    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+  private:\n+    inline static const char* tuple_format(TupleValue val) {\n+      switch(val) {\n+        case FIRST:  return \"%1023s %*s\";\n+        case SECOND: return \"%*s %1023s\";\n+      }\n+      return nullptr;\n+    }\n+    template <typename T>\n+       bool read_from_file(const char* filename, const char* scan_fmt, T result);\n+};\n@@ -258,1 +159,1 @@\n-    jlong limit_from_str(char* limit_str);\n+    static jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":38,"deletions":137,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -78,3 +78,3 @@\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  julong use_hierarchy;\n+  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  return (jlong)use_hierarchy;\n@@ -92,3 +92,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n+  julong memlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n@@ -99,2 +98,7 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+      julong hier_memlimit;\n+      bool is_ok = _memory->controller()->\n+                        read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n@@ -128,2 +132,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  julong hier_memswlimit;\n+  julong memswlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -136,2 +141,6 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n+      bool is_ok = _memory->controller()->\n+                      read_numerical_key_value(\"\/memory.stat\", matchline, &hier_memswlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n@@ -171,0 +180,7 @@\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n+}\n+\n@@ -177,3 +193,1 @@\n-      GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.usage_in_bytes\",\n-                         \"mem swap usage is: \", JULONG_FORMAT, JULONG_FORMAT, memory_swap_usage);\n-      return (jlong)memory_swap_usage;\n+      return memory_swap_usage_impl(_memory->controller());\n@@ -186,3 +200,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+  julong swappiness;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  return (jlong)swappiness;\n@@ -192,2 +206,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  julong memsoftlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n@@ -212,3 +226,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -226,3 +240,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n+  julong memmaxusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  return (jlong)memmaxusage;\n@@ -232,3 +246,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"rss\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+  julong rss;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -238,2 +257,7 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"cache\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+  julong cache;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n@@ -244,3 +268,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n-  return kmem_usage;\n+  julong kmem_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  return (jlong)kmem_usage;\n@@ -250,2 +274,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n+  julong kmem_limit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n@@ -259,3 +283,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n-  return kmem_max_usage;\n+  julong kmem_max_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  return (jlong)kmem_max_usage;\n@@ -275,3 +299,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+  char* cpus = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n+  return cpus;\n@@ -281,3 +305,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  char* mems = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.mems\", \"cpuset.mems\", mems);\n+  return mems;\n@@ -297,3 +321,12 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n-  return quota;\n+  julong quota;\n+  bool is_ok = _cpu->controller()->\n+                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ cast to int since the read value might be negative\n+  \/\/ and we want to avoid logging -1 as a large unsigned value.\n+  int quota_int = (int)quota;\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota_int);\n+  return quota_int;\n@@ -303,3 +336,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n-  return period;\n+  julong period;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  return (int)period;\n@@ -319,2 +352,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -322,1 +356,1 @@\n-  if (shares == 1024) return -1;\n+  if (shares_int == 1024) return -1;\n@@ -324,1 +358,1 @@\n-  return shares;\n+  return shares_int;\n@@ -329,3 +363,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n+  char* pidsmax = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_pids, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n+  return pidsmax;\n@@ -359,3 +393,3 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n-  return pids_current;\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  return (jlong)pids_current;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":95,"deletions":61,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -38,2 +38,3 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -41,1 +42,1 @@\n-  if (shares == 100) {\n+  if (shares_int == 100) {\n@@ -53,1 +54,1 @@\n-  int x = 262142 * shares - 1;\n+  int x = 262142 * shares_int - 1;\n@@ -86,2 +87,6 @@\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+  jlong quota_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", FIRST, &quota_val);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  int limit = (int)quota_val;\n@@ -93,9 +98,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n-}\n-\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n-  return os::strdup(quota);\n+  char* cpus = nullptr;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus);\n+  return cpus;\n@@ -105,3 +104,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  char* mems;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems);\n+  return mems;\n@@ -111,2 +110,8 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+  jlong period_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", SECOND, &period_val);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  int period = (int)period_val;\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -126,3 +131,3 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -143,3 +148,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"anon\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+  julong rss;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -149,3 +159,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"file\", JULONG_FORMAT, JULONG_FORMAT, cache);\n-  return cache;\n+  julong cache;\n+  bool is_ok = _memory->controller()->\n+                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return (jlong)cache;\n@@ -155,3 +170,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n-  return os::strdup(mem_soft_limit_str);\n+  char* mem_soft_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit_str);\n+  return mem_soft_limit_str;\n@@ -194,3 +209,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n-  return os::strdup(mem_swp_limit_str);\n+  char* mem_swp_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.max\", \"Swap Limit\", mem_swp_limit_str);\n+  return mem_swp_limit_str;\n@@ -201,3 +216,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n-  return os::strdup(mem_swp_current_str);\n+  char* mem_swp_current_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", mem_swp_current_str);\n+  return mem_swp_current_str;\n@@ -228,3 +243,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n-  return os::strdup(mem_limit_str);\n+  char* mem_limit_str;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/memory.max\", \"Raw value for memory limit\", mem_limit_str);\n+  return mem_limit_str;\n@@ -254,3 +269,3 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n+  char* pidsmax;\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/pids.max\", \"Maximum number of tasks\", pidsmax);\n+  return pidsmax;\n@@ -282,2 +297,2 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":61,"deletions":46,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    char *cpu_quota_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"runtime\/os.hpp\"\n-#include \"cgroupSubsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdio.h>\n-\n-\n-\/\/ Utilities\n-static bool file_exists(const char* filename) {\n-  struct stat st;\n-  return os::stat(filename, &st) == 0;\n-}\n-\n-static char* temp_file(const char* prefix) {\n-  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-  stringStream path;\n-  path.print_raw(os::get_temp_directory());\n-  path.print_raw(os::file_separator());\n-  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n-             test_info->test_case_name(), test_info->name());\n-  return path.as_string(true);\n-}\n-\n-static void delete_file(const char* filename) {\n-  if (!file_exists(filename)) {\n-    return;\n-  }\n-  int ret = remove(filename);\n-  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n-      << os::strerror(errno) << \" (\" << errno << \")\";\n-}\n-\n-class TestController : public CgroupController {\n-public:\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generated by temp_file()\n-    return (char*)\"\/\";\n-  };\n-};\n-\n-static void fill_file(const char* path, const char* content) {\n-  delete_file(path);\n-  FILE* fp = os::fopen(path, \"w\");\n-  if (fp == nullptr) {\n-    return;\n-  }\n-  if (content != nullptr) {\n-    fprintf(fp, \"%s\", content);\n-  }\n-  fclose(fp);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo 1\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+\/\/ Utilities\n+static bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+static char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+static void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+private:\n+  char* _path;\n+public:\n+  TestController(char *p) {\n+    _path = p;\n+  }\n+  char* subsystem_path() override {\n+    return _path;\n+  };\n+};\n+\n+static void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_failure_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong x = 0xBAD;\n+\n+  fill_file(test_file, \"foo \");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"Value must not be missing in key\/value case\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"faulty_start foo 101\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be at the start\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foof 1002\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be exact match\";\n+  EXPECT_EQ((julong)0xBAD, x) << \"x must be unchanged\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_success_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong x = 0xBAD;\n+\n+  fill_file(test_file, \"foo 100\");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)100, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foof 100\\nfoo 133\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)133, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foo\\t333\\nfoot 999\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)333, x) << \"Incorrect!\";\n+\n+  x = 0xBAD;\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)1, x) << \"Incorrect!\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  julong a = 0xBAD;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  \/\/ null file, null return pointer\n+  TestController* test_controller = new TestController((char*)\"\/something\");\n+  is_ok = test_controller->read_number(nullptr, &a);\n+  EXPECT_FALSE(is_ok) << \"Null file should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  is_ok = test_controller->read_number(test_file_path, nullptr);\n+  EXPECT_FALSE(is_ok) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, read_string_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  char* foo = nullptr;\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, &foo);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_TRUE(nullptr == foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  julong result = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, result) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+  \/\/ null key, null file, null return pointer\n+  TestController* test_controller = new TestController((char*)\"\/something\");\n+  is_ok = test_controller->read_numerical_key_value(test_file_path, nullptr, &a);\n+  EXPECT_FALSE(is_ok) << \"Null key should be an error\";\n+  is_ok = test_controller->read_numerical_key_value(nullptr, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null file should be an error\";\n+  is_ok = test_controller->read_numerical_key_value(test_file_path, key, nullptr);\n+  EXPECT_FALSE(is_ok) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, read_number_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"8888\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong foo = 0xBAD;\n+  bool ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  \/\/ Some interface files might have negative values, ensure we can read\n+  \/\/ them and manually cast them as needed.\n+  fill_file(test_file, \"-1\");\n+  foo = 0xBAD;\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  foo = 0xBAD;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_EQ((julong)0xBAD, foo) << \"foo was altered\";\n+\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_string_tests) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"foo-bar\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  char* result = nullptr;\n+  bool ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"foo-bar\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  result = nullptr;\n+  fill_file(test_file, \"1234\");\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"1234\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  \/\/ values with a space only read in the first token\n+  result = nullptr;\n+  fill_file(test_file, \"abc def\");\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(result != nullptr) << \"Expected non-null result\";\n+  EXPECT_STREQ(\"abc\", result) << \"Expected strings to be equal\";\n+  os::free(result);\n+\n+  result = nullptr;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_string(base_with_slash, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_TRUE(result == nullptr) << \"Expected untouched result\";\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_tuple_test) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"max 10000\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  jlong result = -10;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read value\";\n+  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, SECOND, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read the value\";\n+  EXPECT_EQ((jlong)10000, result) << \"result value incorrect\";\n+\n+  \/\/ non-max strings\n+  fill_file(test_file, \"abc 10000\");\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_FALSE(ok) << \"abc should not be parsable\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+\n+  fill_file(test_file, nullptr);\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, FIRST, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should be an error\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -203,2 +203,2 @@\n-            .shouldMatch(\"Memory and Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n-            .shouldNotMatch(\"Memory and Swap Limit is:.*\" + neg2InUnsignedLong);\n+            .shouldMatch(\"(Memory and )?Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n+            .shouldNotMatch(\"(Memory and )?Swap Limit is:.*\" + neg2InUnsignedLong);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}