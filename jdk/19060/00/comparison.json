{"files":[{"patch":"@@ -72,2 +72,0 @@\n-typedef char * cptr;\n-\n@@ -81,11 +79,35 @@\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n+template <typename T> int __cg_file_contents_impl(const char *absolute_path,\n+                                                  const char *scan_fmt,\n+                                                  T returnval) {\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    fclose(fp);\n+    return OSCONTAINER_ERROR;\n+  }\n+  fclose(fp);\n+\n+  int matched = sscanf(line, scan_fmt, returnval);\n+  if (matched == 1) {\n+    return 0;\n+  } else {\n+    log_debug(os, container)(\"Type %s not found in file %s\", scan_fmt, absolute_path);\n+  }\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int cg_file_contents_ctrl(CgroupController* c,\n+                                                const char *filename,\n+                                                const char *scan_fmt,\n+                                                T returnval) {\n@@ -93,1 +115,1 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n+    log_debug(os, container)(\"cg_file_contents_ctrl: CgroupController* is null\");\n@@ -97,1 +119,5 @@\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n+    log_debug(os, container)(\"cg_file_contents_ctrl: subsystem path is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (scan_fmt == nullptr || returnval == nullptr) {\n+    log_debug(os, container)(\"cg_file_contents_ctrl: scan_fmt or return pointer is null\");\n@@ -105,1 +131,1 @@\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n+  if (file_path.size() > MAXPATHLEN) {\n@@ -111,0 +137,3 @@\n+  return __cg_file_contents_impl<T>(absolute_path, scan_fmt, returnval);\n+}\n+PRAGMA_DIAG_POP\n@@ -112,0 +141,6 @@\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int __cg_file_multi_line_impl(const char *absolute_path,\n+                                                    const char *key,\n+                                                    const char *scan_fmt,\n+                                                    T returnval) {\n@@ -128,12 +163,7 @@\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const int key_len = (int)strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char* key_substr = strstr(line, key);\n+    char after_key = line[key_len];\n+    if (key_substr == line\n@@ -142,7 +172,6 @@\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, scan_fmt, returnval);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n@@ -157,1 +186,1 @@\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n+                           key, absolute_path);\n@@ -162,19 +191,19 @@\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n-}\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int cg_file_multi_line_ctrl(CgroupController* c,\n+                                                  const char *filename,\n+                                                  const char *key,\n+                                                  const char *scan_fmt,\n+                                                  T returnval) {\n+  if (c == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: CgroupController* is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: subsystem path is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (key == nullptr || scan_fmt == nullptr || returnval == nullptr) {\n+    log_debug(os, container)(\"cg_file_multi_line_ctrl: key, scan_fmt or return pointer is null\");\n+    return OSCONTAINER_ERROR;\n+  }\n@@ -182,15 +211,3 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+  stringStream file_path;\n+  file_path.print_raw(c->subsystem_path());\n+  file_path.print_raw(filename);\n@@ -198,14 +215,7 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return OSCONTAINER_ERROR;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  return __cg_file_multi_line_impl<T>(absolute_path, key, scan_fmt, returnval);\n@@ -213,1 +223,1 @@\n-\n+PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":95,"deletions":85,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -78,2 +78,7 @@\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n+  jlong use_hierarchy;\n+  int err = cg_file_contents_ctrl(this, \"\/memory.use_hierarchy\", JLONG_FORMAT, &use_hierarchy);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Use Hierarchy is: %d\", OSCONTAINER_ERROR);\n+    return (jlong)OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Use Hierarchy is: \" JLONG_FORMAT, use_hierarchy);\n@@ -92,2 +97,7 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n+  julong memlimit;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.limit_in_bytes\", JULONG_FORMAT, &memlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Limit is: \" JULONG_FORMAT, memlimit);\n@@ -99,2 +109,7 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+      julong hier_memlimit;\n+      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+                                    \"hierarchical_memory_limit\", JULONG_FORMAT, &hier_memlimit);\n+      if (err != 0) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n@@ -128,2 +143,8 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  julong hier_memswlimit;\n+  julong memswlimit;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", JULONG_FORMAT, &memswlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory and Swap Limit is: \" JULONG_FORMAT, memswlimit);\n@@ -136,2 +157,5 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n+      err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", matchline, JULONG_FORMAT, &hier_memswlimit);\n+      if (err != 0) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, hier_memswlimit);\n@@ -171,0 +195,12 @@\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  int err = cg_file_contents_ctrl(ctrl, \"\/memory.memsw.usage_in_bytes\", JULONG_FORMAT, &memory_swap_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"mem swap usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"mem swap usage is: \" JULONG_FORMAT, memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n+}\n+\n@@ -177,3 +213,1 @@\n-      GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.usage_in_bytes\",\n-                         \"mem swap usage is: \", JULONG_FORMAT, JULONG_FORMAT, memory_swap_usage);\n-      return (jlong)memory_swap_usage;\n+      return memory_swap_usage_impl(_memory->controller());\n@@ -186,3 +220,9 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+  julong swappiness;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.swappiness\",\n+                                  JULONG_FORMAT, &swappiness);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Swappiness is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Swappiness is: \" JULONG_FORMAT, swappiness);\n+  return (jlong)swappiness;\n@@ -192,2 +232,8 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  julong memsoftlimit;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+                                  JULONG_FORMAT, &memsoftlimit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Soft Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Soft Limit is: \" JULONG_FORMAT, memsoftlimit);\n@@ -212,2 +258,8 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  jlong memusage;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.usage_in_bytes\",\n+                                  JLONG_FORMAT, &memusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n@@ -226,2 +278,8 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+  jlong memmaxusage;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.max_usage_in_bytes\",\n+                                  JLONG_FORMAT, &memmaxusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Maximum Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Maximum Memory Usage is: \" JLONG_FORMAT, memmaxusage);\n@@ -232,2 +290,6 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"rss\", JULONG_FORMAT, JULONG_FORMAT, rss);\n+  julong rss;\n+  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"rss\", JULONG_FORMAT, &rss);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n@@ -238,2 +300,6 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"cache\", JULONG_FORMAT, JULONG_FORMAT, cache);\n+  julong cache;\n+  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\", \"cache\", JULONG_FORMAT, &cache);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n@@ -244,2 +310,8 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n+  jlong kmem_usage;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n+                                  JLONG_FORMAT, &kmem_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Kernel Memory Usage is: \" JLONG_FORMAT, kmem_usage);\n@@ -250,2 +322,8 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n+  julong kmem_limit;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n+                                  JULONG_FORMAT, &kmem_limit);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Kernel Memory Limit is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Kernel Memory Limit is: \" JULONG_FORMAT, kmem_limit);\n@@ -259,2 +337,8 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n+  jlong kmem_max_usage;\n+  int err = cg_file_contents_ctrl(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n+                                  JLONG_FORMAT, &kmem_max_usage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Maximum Kernel Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Maximum Kernel Memory Usage is: \" JLONG_FORMAT, kmem_max_usage);\n@@ -275,2 +359,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  char cpus[1024];\n+  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.cpus\", \"%1023s\", cpus);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n@@ -281,2 +369,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  char mems[1024];\n+  int err = cg_file_contents_ctrl(_cpuset, \"\/cpuset.mems\", \"%1023s\", mems);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n@@ -297,2 +389,7 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n+  int quota;\n+  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_quota_us\", \"%d\", &quota);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Quota is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota);\n@@ -303,2 +400,7 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n+  int period;\n+  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.cfs_period_us\", \"%d\", &period);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -319,2 +421,7 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+  int shares;\n+  int err = cg_file_contents_ctrl(_cpu->controller(), \"\/cpu.shares\", \"%d\", &shares);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Shares is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Shares is: %d\", shares);\n@@ -329,2 +436,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n+  char pidsmax[1024];\n+  int err = cg_file_contents_ctrl(_pids, \"\/pids.max\", \"%1023s\", pidsmax);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n@@ -359,2 +470,7 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  jlong pids_current;\n+  int err = cg_file_contents_ctrl(_pids, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":162,"deletions":46,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -38,2 +38,7 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+  int shares;\n+  int err = cg_file_contents_ctrl(_unified, \"\/cpu.weight\", \"%d\", &shares);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Raw value for CPU Shares is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Raw value for CPU Shares is: %d\", shares);\n@@ -93,2 +98,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  char cpus[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.cpus\", \"%1023s\", cpus);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.cpus is: %s\", cpus);\n@@ -99,2 +108,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n+  char quota[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%1023s %*d\", quota);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Raw value for CPU quota is: %s\", quota);\n@@ -105,2 +118,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  char mems[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/cpuset.mems\", \"%1023s\", mems);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"cpuset.mems is: %s\", mems);\n@@ -111,2 +128,7 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+  int period;\n+  int err = cg_file_contents_ctrl(_unified, \"\/cpu.max\", \"%*s %d\", &period);\n+  if (err != 0) {\n+    log_trace(os, container)(\"CPU Period is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -126,2 +148,7 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  jlong memusage;\n+  int err = cg_file_contents_ctrl(_unified, \"\/memory.current\", JLONG_FORMAT, &memusage);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Memory Usage is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Memory Usage is: \" JLONG_FORMAT, memusage);\n@@ -143,3 +170,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"anon\", JULONG_FORMAT, JULONG_FORMAT, rss);\n-  return rss;\n+  julong rss;\n+  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+                                    \"anon\", JULONG_FORMAT, &rss);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n@@ -149,3 +181,8 @@\n-  GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\",\n-                          \"file\", JULONG_FORMAT, JULONG_FORMAT, cache);\n-  return cache;\n+  julong cache;\n+  int err = cg_file_multi_line_ctrl(_memory->controller(), \"\/memory.stat\",\n+                                    \"file\", JULONG_FORMAT, &cache);\n+  if (err != 0) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return (jlong)cache;\n@@ -155,2 +192,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n+  char mem_soft_limit_str[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/memory.low\", \"%1023s\", mem_soft_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Memory Soft Limit is: %s\", mem_soft_limit_str);\n@@ -194,2 +235,8 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n+  char mem_swp_limit_str[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.max\", \"%1023s\", mem_swp_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  \/\/ FIXME: This log-line is misleading, since it reads the swap limit only, not memory *and*\n+  \/\/ swap limit.\n+  log_trace(os, container)(\"Memory and Swap Limit is: %s\", mem_swp_limit_str);\n@@ -201,2 +248,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n+  char mem_swp_current_str[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/memory.swap.current\", \"%1023s\", mem_swp_current_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Swap currently used is: %s\", mem_swp_current_str);\n@@ -228,2 +279,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n+  char mem_limit_str[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/memory.max\", \"%1023s\", mem_limit_str);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Raw value for memory limit is: %s\", mem_limit_str);\n@@ -254,2 +309,6 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n+  char pidsmax[1024];\n+  int err = cg_file_contents_ctrl(_unified, \"\/pids.max\", \"%1023s\", pidsmax);\n+  if (err != 0) {\n+    return nullptr;\n+  }\n+  log_trace(os, container)(\"Maximum number of tasks is: %s\", pidsmax);\n@@ -282,2 +341,7 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  jlong pids_current;\n+  int err = cg_file_contents_ctrl(_unified, \"\/pids.current\", JLONG_FORMAT, &pids_current);\n+  if (err != 0) {\n+    log_trace(os, container)(\"Current number of tasks is: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Current number of tasks is: \" JLONG_FORMAT, pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":94,"deletions":30,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"runtime\/os.hpp\"\n-#include \"cgroupSubsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdio.h>\n-\n-\n-\/\/ Utilities\n-static bool file_exists(const char* filename) {\n-  struct stat st;\n-  return os::stat(filename, &st) == 0;\n-}\n-\n-static char* temp_file(const char* prefix) {\n-  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-  stringStream path;\n-  path.print_raw(os::get_temp_directory());\n-  path.print_raw(os::file_separator());\n-  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n-             test_info->test_case_name(), test_info->name());\n-  return path.as_string(true);\n-}\n-\n-static void delete_file(const char* filename) {\n-  if (!file_exists(filename)) {\n-    return;\n-  }\n-  int ret = remove(filename);\n-  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n-      << os::strerror(errno) << \" (\" << errno << \")\";\n-}\n-\n-class TestController : public CgroupController {\n-public:\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generated by temp_file()\n-    return (char*)\"\/\";\n-  };\n-};\n-\n-static void fill_file(const char* path, const char* content) {\n-  delete_file(path);\n-  FILE* fp = os::fopen(path, \"w\");\n-  if (fp == nullptr) {\n-    return;\n-  }\n-  if (content != nullptr) {\n-    fprintf(fp, \"%s\", content);\n-  }\n-  fclose(fp);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo 1\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+\/\/ Utilities\n+static bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+static char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+static void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+private:\n+  char* _path;\n+public:\n+  TestController(char *p) {\n+    _path = p;\n+  }\n+  char* subsystem_path() override {\n+    return _path;\n+  };\n+};\n+\n+static void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_impl_failure_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo \");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"faulty_start foo bar\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be at start\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_NE(err, 0) << \"Key must be exact match\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_impl_success_cases) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo bar\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\tbar\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foof bar\\nfoo car\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"car\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"test\");\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  err = __cg_file_multi_line_impl(test_file, \"foo\", \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1\");\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, cg_file_contents_impl) {\n+  const char* test_file = temp_file(\"cgroups\");\n+  int x = 0;\n+  char s[1024];\n+  int err = 0;\n+\n+  fill_file(test_file, \"foo\");\n+  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"foo\");\n+\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n+  EXPECT_NE(err, 0) << \"'foo' cannot be read as int\";\n+  EXPECT_EQ(x, 0);\n+\n+  fill_file(test_file, \"1337\");\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"1337\");\n+  err = __cg_file_contents_impl(test_file, \"%s\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"1337\");\n+\n+  x = -1;\n+  fill_file(test_file, nullptr);\n+  err = __cg_file_contents_impl(test_file, \"%d\", &x);\n+  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n+  EXPECT_EQ(x, -1) << \"x was altered\";\n+\n+  jlong y;\n+  fill_file(test_file, \"1337\");\n+  err = __cg_file_contents_impl(test_file, JLONG_FORMAT, &y);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n+  julong z;\n+  fill_file(test_file, \"1337\");\n+  err = __cg_file_contents_impl(test_file, JULONG_FORMAT, &z);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n+\n+  s[0] = '\\0';\n+  fill_file(test_file, \"max 10000\");\n+  err = __cg_file_contents_impl(test_file, \"%s %*d\", &s);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_STREQ(s, \"max\");\n+\n+  x = -3;\n+  fill_file(test_file, \"max 10001\");\n+  err = __cg_file_contents_impl(test_file, \"%*s %d\", &x);\n+  EXPECT_EQ(err, 0);\n+  EXPECT_EQ(x, 10001);\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, cg_file_contents_ctrl_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* scan_fmt = \"%d\";\n+  int a = -1;\n+  \/\/ null subsystem_path() case\n+  int err = cg_file_contents_ctrl<int*>(null_path_controller, test_file_path, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null controller\n+  err = cg_file_contents_ctrl<int*>(nullptr, test_file_path, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null scan_fmt, null return pointer\n+  TestController* test_controller = new TestController((char*)\"\/something\");\n+  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, nullptr, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n+  err = cg_file_contents_ctrl<int*>(test_controller, test_file_path, scan_fmt, nullptr);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, cg_file_contents_ctrl_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"%d\";\n+  int foo = -1;\n+  int err = cg_file_contents_ctrl<int*>(too_large_path_controller, test_file_path, scan_fmt, &foo);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n+  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_contents_ctrl_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"\/not-used\";\n+  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n+  int err = cg_file_contents_ctrl<const char*>(unknown_path_ctrl, test_file_path, scan_fmt, ret_val[0]);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n+  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* scan_fmt = \"%d\";\n+  const char* key = \"something\";\n+  int a = -1;\n+  \/\/ null subsystem_path() case\n+  int err = cg_file_multi_line_ctrl<int*>(null_path_controller, test_file_path, key, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null controller\n+  err = cg_file_multi_line_ctrl<int*>(nullptr, test_file_path, key, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(-1, a) << \"Expected untouched scan value\";\n+  \/\/ null key, null scan_fmt, null return pointer\n+  TestController* test_controller = new TestController((char*)\"\/something\");\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, nullptr, scan_fmt, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null key should be an error\";\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, nullptr, &a);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null scan format should be an error\";\n+  err = cg_file_multi_line_ctrl<int*>(test_controller, test_file_path, key, scan_fmt, nullptr);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Null return pointer should be an error\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"%d\";\n+  const char* key = \"something\";\n+  int foo = -1;\n+  int err = cg_file_multi_line_ctrl<int*>(too_large_path_controller, test_file_path, key, scan_fmt, &foo);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"Too long path should be an error\";\n+  EXPECT_EQ(-1, foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, cg_file_multi_line_ctrl_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* scan_fmt = \"\/not-used\";\n+  const char* key = \"something\";\n+  const char* ret_val[2] = { \"\/one\", \"\/two\" };\n+  int err = cg_file_multi_line_ctrl<const char*>(unknown_path_ctrl, test_file_path, key, scan_fmt, ret_val[0]);\n+  EXPECT_EQ(err, OSCONTAINER_ERROR) << \"File not found should be an error\";\n+  EXPECT_EQ(\"\/one\", ret_val[0]) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"}]}