{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -37,2 +35,13 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -46,11 +55,2 @@\n-public class LoopbackAddresses implements HttpCallback {\n-    static TestHttpServer server;\n-\n-    public void request (HttpTransaction req) {\n-        req.setResponseEntityBody (\"Hello .\");\n-        try {\n-            req.sendResponse (200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n+public class LoopbackAddresses {\n+    static HttpServer server;\n@@ -66,2 +66,4 @@\n-            server = new TestHttpServer (new LoopbackAddresses(), 1, 10, 0);\n-            ProxyServer pserver = new ProxyServer(InetAddress.getByName(\"localhost\"), server.getLocalPort());\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new LoopbackAddressesHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            ProxyServer pserver = new ProxyServer(InetAddress.getByName(\"localhost\"), server.getAddress().getPort());\n@@ -74,1 +76,1 @@\n-            URL url = new URL(\"http:\/\/localhost:\"+server.getLocalPort());\n+            URL url = new URL(\"http:\/\/localhost:\"+server.getAddress().getPort());\n@@ -88,1 +90,1 @@\n-                      .port(server.getLocalPort())\n+                      .port(server.getAddress().getPort())\n@@ -100,1 +102,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -154,0 +156,15 @@\n+\n+class LoopbackAddressesHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody())) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ProxySelector\/LoopbackAddresses.java","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -35,2 +33,11 @@\n-import java.net.*;\n-import java.io.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ProxySelector;\n+import java.net.SocketAddress;\n+import java.net.URI;\n+import java.net.URL;\n@@ -38,0 +45,5 @@\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -40,2 +52,2 @@\n-public class ProxyTest implements HttpCallback {\n-    static TestHttpServer server;\n+public class ProxyTest {\n+    static HttpServer server;\n@@ -46,9 +58,0 @@\n-    public void request(HttpTransaction req) {\n-        req.setResponseEntityBody(\"Hello .\");\n-        try {\n-            req.sendResponse(200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n@@ -78,1 +81,3 @@\n-            server = new TestHttpServer(new ProxyTest(), 1, 10, loopback, 0);\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new ProxyTestHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n@@ -82,1 +87,1 @@\n-                      .port(server.getLocalPort())\n+                      .port(server.getAddress().getPort())\n@@ -96,1 +101,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -101,0 +106,15 @@\n+\n+class ProxyTestHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody())) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/ProxySelector\/ProxyTest.java","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/ \/test\/lib\n- * @build ClosedChannelList TestHttpServer HttpTransaction HttpCallback\n+ * @library \/test\/lib\n@@ -34,3 +32,16 @@\n-import java.net.*;\n-import java.io.*;\n-\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -39,11 +50,2 @@\n-public class PerConnectionProxy implements HttpCallback {\n-    static TestHttpServer server;\n-\n-    public void request (HttpTransaction req) {\n-        req.setResponseEntityBody (\"Hello .\");\n-        try {\n-            req.sendResponse (200, \"Ok\");\n-            req.orderlyClose();\n-        } catch (IOException e) {\n-        }\n-    }\n+public class PerConnectionProxy {\n+    static HttpServer server;\n@@ -54,2 +56,4 @@\n-            server = new TestHttpServer(new PerConnectionProxy(), 1, 10, loopbackAddress, 0);\n-            ProxyServer pserver = new ProxyServer(loopbackAddress, server.getLocalPort());\n+            server = HttpServer.create(new InetSocketAddress(loopbackAddress, 0), 10, \"\/\", new PerConnectionProxyHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            ProxyServer pserver = new ProxyServer(loopbackAddress, server.getAddress().getPort());\n@@ -62,1 +66,1 @@\n-                    .port(server.getLocalPort())\n+                    .port(server.getAddress().getPort())\n@@ -76,1 +80,0 @@\n-\n@@ -85,1 +88,0 @@\n-\n@@ -104,1 +106,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -107,1 +109,0 @@\n-\n@@ -148,1 +149,0 @@\n-\n@@ -164,1 +164,0 @@\n-\n@@ -224,0 +223,2 @@\n+    }\n+}\n@@ -225,0 +226,11 @@\n+class PerConnectionProxyHandler implements HttpHandler {\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.sendResponseHeaders(200, 0);\n+        } catch (IOException e) {\n+        }\n+        try(PrintWriter pw = new PrintWriter(exchange.getResponseBody())) {\n+            pw.print(\"Hello .\");\n+        }\n@@ -227,0 +239,1 @@\n+\n","filename":"test\/jdk\/java\/net\/URL\/PerConnectionProxy.java","additions":40,"deletions":27,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @modules java.base\/sun.net.www.protocol.file\n@@ -27,4 +28,2 @@\n- * @modules java.base\/sun.net.www java.base\/sun.net.www.protocol.file\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main B5052093\n+ * @library \/test\/lib\n+ * @run main\/othervm B5052093\n@@ -33,3 +32,12 @@\n-import java.net.*;\n-import java.io.*;\n-import sun.net.www.protocol.file.FileURLConnection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -37,0 +45,2 @@\n+import jdk.test.lib.net.URIBuilder;\n+import sun.net.www.protocol.file.FileURLConnection;\n@@ -38,3 +48,3 @@\n-public class B5052093 implements HttpCallback {\n-    private static TestHttpServer server;\n-    private static long testSize = ((long) (Integer.MAX_VALUE)) + 2;\n+public class B5052093 {\n+    private static HttpServer server;\n+    static long testSize = ((long) (Integer.MAX_VALUE)) + 2;\n@@ -58,9 +68,0 @@\n-    public void request(HttpTransaction req) {\n-        try {\n-            req.setResponseHeader(\"content-length\", Long.toString(testSize));\n-            req.sendResponse(200, \"OK\");\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n@@ -69,1 +70,3 @@\n-        server = new TestHttpServer(new B5052093(), 1, 10, loopback, 0);\n+        server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new B5052093Handler());\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -71,1 +74,6 @@\n-            URL url = new URL(\"http:\/\/\" + server.getAuthority() + \"\/foo\");\n+            URL url = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .path(\"\/foo\")\n+                    .build().toURL();\n@@ -92,1 +100,14 @@\n-            server.terminate();\n+            server.stop(1);\n+        }\n+    }\n+}\n+\n+class B5052093Handler implements HttpHandler {\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            exchange.getResponseHeaders().set(\"content-length\", Long.toString(B5052093.testSize));\n+            exchange.sendResponseHeaders(200, 0);\n+            exchange.close();\n+        } catch (IOException e) {\n+            e.printStackTrace();\n","filename":"test\/jdk\/java\/net\/URLConnection\/B5052093.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,2 @@\n- * @modules java.base\/sun.net.www\n- * @library ..\/..\/..\/sun\/net\/www\/httptest\/\n- * @build HttpCallback TestHttpServer ClosedChannelList HttpTransaction\n- * @run main AuthHeaderTest\n+ * @library \/test\/lib\n+ * @run main\/othervm AuthHeaderTest\n@@ -34,40 +32,19 @@\n-import java.io.*;\n-import java.net.*;\n-\n-public class AuthHeaderTest implements HttpCallback {\n-\n-    static int count = 0;\n-    static String authstring;\n-\n-    void errorReply (HttpTransaction req, String reply) throws IOException {\n-        req.addResponseHeader (\"Connection\", \"close\");\n-        req.addResponseHeader (\"Www-authenticate\", reply);\n-        req.sendResponse (401, \"Unauthorized\");\n-        req.orderlyClose();\n-    }\n-\n-    void okReply (HttpTransaction req) throws IOException {\n-        req.setResponseEntityBody (\"Hello .\");\n-        req.sendResponse (200, \"Ok\");\n-        req.orderlyClose();\n-    }\n-\n-    public void request (HttpTransaction req) {\n-        try {\n-            authstring = req.getRequestHeader (\"Authorization\");\n-            System.out.println (authstring);\n-            switch (count) {\n-            case 0:\n-                errorReply (req, \"Basic realm=\\\"wallyworld\\\"\");\n-                break;\n-            case 1:\n-                \/* client stores a username\/pw for wallyworld\n-                 *\/\n-                okReply (req);\n-                break;\n-            }\n-            count ++;\n-        } catch (IOException e) {\n-            e.printStackTrace();\n-        }\n-    }\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.net.Authenticator;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.PasswordAuthentication;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+\n+public class AuthHeaderTest {\n+    static HttpServer server;\n@@ -94,2 +71,0 @@\n-    static TestHttpServer server;\n-\n@@ -101,3 +76,13 @@\n-            server = new TestHttpServer (new AuthHeaderTest(), 1, 10, loopback, 0);\n-            System.out.println (\"Server: listening on port: \" + server.getAuthority());\n-            client (\"http:\/\/\" + server.getAuthority() + \"\/d1\/foo.html\");\n+            server = HttpServer.create(new InetSocketAddress(loopback, 0), 10, \"\/\", new AuthHeaderTestHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n+            System.out.println (\"Server: listening on port: \" + server.getAddress().getPort());\n+\n+            String serverURL = URIBuilder.newBuilder()\n+                    .scheme(\"http\")\n+                    .loopback()\n+                    .port(server.getAddress().getPort())\n+                    .path(\"\/\")\n+                    .build()\n+                    .toString();\n+            client (serverURL + \"d1\/foo.html\");\n@@ -106,1 +91,1 @@\n-                server.terminate();\n+                server.stop(1);\n@@ -114,1 +99,1 @@\n-        server.terminate();\n+        server.stop(1);\n@@ -118,1 +103,1 @@\n-        server.terminate();\n+        server.stop(1);\n@@ -141,0 +126,42 @@\n+\n+class AuthHeaderTestHandler implements HttpHandler {\n+    static int count = 0;\n+    static String authstring;\n+\n+    void errorReply (HttpExchange req, String reply) throws IOException {\n+        req.getResponseHeaders().set(\"Connection\", \"close\");\n+        req.getResponseHeaders().set(\"Www-authenticate\", reply);\n+        req.sendResponseHeaders(401, -1);\n+    }\n+\n+    void okReply (HttpExchange req) throws IOException {\n+        req.sendResponseHeaders (200, 0);\n+        try(PrintWriter pw = new PrintWriter(req.getResponseBody())) {\n+            pw.print(\"Hello .\");\n+        }\n+    }\n+\n+    @Override\n+    public void handle(HttpExchange exchange) throws IOException {\n+        try {\n+            if(exchange.getRequestHeaders().get(\"Authorization\") != null) {\n+                authstring = exchange.getRequestHeaders().get(\"Authorization\").get(0);\n+                System.out.println (authstring);\n+            }\n+\n+            switch (count) {\n+                case 0:\n+                    errorReply (exchange, \"Basic realm=\\\"wallyworld\\\"\");\n+                    break;\n+                case 1:\n+                    \/* client stores a username\/pw for wallyworld\n+                     *\/\n+                    okReply (exchange);\n+                    break;\n+            }\n+            count ++;\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/net\/www\/AuthHeaderTest.java","additions":80,"deletions":53,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,4 +27,1 @@\n- * @modules java.base\/sun.net.www\n- *          java.management\n- * @library ..\/..\/httptest\/\n- * @build HttpCallback TestHttpServer HttpTransaction\n+ * @library \/test\/lib\n@@ -35,3 +32,11 @@\n-import java.net.*;\n-import java.io.*;\n-import java.lang.management.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintWriter;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n@@ -40,0 +45,5 @@\n+import java.util.concurrent.Executors;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n@@ -54,4 +64,2 @@\n-public class B5045306\n-{\n-    static SimpleHttpTransaction httpTrans;\n-    static TestHttpServer server;\n+public class B5045306 {\n+    static HttpServer server;\n@@ -59,1 +67,1 @@\n-    public static void main(String[] args) throws Exception {\n+    public static void main(String[] args) {\n@@ -66,2 +74,3 @@\n-            httpTrans = new SimpleHttpTransaction();\n-            server = new TestHttpServer(httpTrans, 1, 10, InetAddress.getLocalHost(), 0);\n+            server = HttpServer.create(new InetSocketAddress(InetAddress.getLocalHost(), 0), 10, \"\/\", new SimpleHttpTransactionHandler());\n+            server.setExecutor(Executors.newSingleThreadExecutor());\n+            server.start();\n@@ -79,1 +88,1 @@\n-            System.out.println(\"http server listen on: \" + server.getLocalPort());\n+            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n@@ -82,1 +91,1 @@\n-            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getLocalPort() + \"\/\";\n+            String baseURLStr = \"http:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n@@ -101,1 +110,1 @@\n-            if (SimpleHttpTransaction.failed)\n+            if (SimpleHttpTransactionHandler.failed)\n@@ -140,1 +149,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -148,1 +157,1 @@\n-class SimpleHttpTransaction implements HttpCallback\n+class SimpleHttpTransactionHandler implements HttpHandler\n@@ -158,1 +167,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -162,1 +171,1 @@\n-                port1 = trans.channel().socket().getPort();\n+                port1 = trans.getLocalAddress().getPort();\n@@ -168,2 +177,4 @@\n-                trans.setResponseEntityBody (responseBody, responseBody.length);\n-                trans.sendResponse(200, \"OK\");\n+                trans.sendResponseHeaders(200, 0);\n+                try(PrintWriter pw = new PrintWriter(trans.getResponseBody())) {\n+                    pw.print(responseBody);\n+                }\n@@ -171,1 +182,1 @@\n-                int port2 = trans.channel().socket().getPort();\n+                int port2 = trans.getLocalAddress().getPort();\n@@ -177,1 +188,1 @@\n-                trans.setResponseHeader (\"Content-length\", Integer.toString(0));\n+                trans.getResponseHeaders().set(\"Content-length\", Integer.toString(0));\n@@ -186,1 +197,1 @@\n-                trans.sendResponse(200, \"OK\");\n+                trans.sendResponseHeaders(200, -1);\n@@ -192,1 +203,0 @@\n-                trans.setResponseEntityBody (responseBody, responseBody.length);\n@@ -195,3 +205,5 @@\n-                trans.setResponseHeader(\"Content-length\", Integer.toString(responseBody.length+1));\n-                trans.sendResponse(200, \"OK\");\n-\n+                trans.getResponseHeaders().set(\"Content-length\", Integer.toString(responseBody.length+1));\n+                trans.sendResponseHeaders(200, 0);\n+                try(PrintWriter pw = new PrintWriter(trans.getResponseBody())) {\n+                    pw.print(responseBody);\n+                }\n@@ -199,1 +211,1 @@\n-                trans.channel().socket().close();\n+                trans.close();\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B5045306.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-\n-class ClosedChannelList {\n-\n-    static final long TIMEOUT = 10 * 1000; \/* 10 sec *\/\n-\n-    static class Element {\n-        long expiry;\n-        SelectionKey key;\n-        Element (long l, SelectionKey key) {\n-            expiry = l;\n-            this.key = key;\n-        }\n-    }\n-\n-    LinkedList list;\n-\n-    public ClosedChannelList () {\n-        list = new LinkedList ();\n-    }\n-\n-    \/* close chan after TIMEOUT milliseconds *\/\n-\n-    public synchronized void add (SelectionKey key) {\n-        long exp = System.currentTimeMillis () + TIMEOUT;\n-        list.add (new Element (exp, key));\n-    }\n-\n-    public synchronized void check () {\n-        check (false);\n-    }\n-\n-    public synchronized void terminate () {\n-        check (true);\n-    }\n-\n-    public synchronized void check (boolean forceClose) {\n-        Iterator iter = list.iterator ();\n-        long now = System.currentTimeMillis();\n-        while (iter.hasNext ()) {\n-            Element elm = (Element)iter.next();\n-            if (forceClose || elm.expiry <= now) {\n-                SelectionKey k = elm.key;\n-                try {\n-                    k.channel().close ();\n-                } catch (IOException e) {}\n-                k.cancel();\n-                iter.remove();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/ClosedChannelList.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/HttpCallback.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpServer.Server server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SelectionKey  key;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpServer.Server server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SelectionKey  key) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.key = key;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (key.channel().toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (key);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(key);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return (SocketChannel) key.channel();\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpServer.NioOutputStream(channel());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpServer.NioOutputStream(channel());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"deleted"},{"patch":"@@ -1,797 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-\n-\/**\n- * This class implements a simple HTTP server. It uses multiple threads to\n- * handle connections in parallel, and also multiple connections\/requests\n- * can be handled per thread.\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If changes are made here, please sure they are propagated to\n- * the HTTPS equivalent in the JSSE regression test suite.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb) throws IOException {\n-        this (cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     * @param address the address to bind the server to. <code>Null<\/code>\n-     *  means bind to the wildcard address.\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, InetAddress address, int port) throws IOException {\n-        this (cb, 1, 10, address, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this (cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread, int port)\n-            throws IOException {\n-        this(cb, threads, cperthread, null, port);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param address the address to bind the server to. <code>Null<\/code>\n-     *  means bind to the wildcard address.\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpServer (HttpCallback cb, int threads, int cperthread,\n-                           InetAddress address, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open ();\n-        InetSocketAddress addr = new InetSocketAddress (address, port);\n-        schan.socket().bind (addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-        servers = new Server [threads];\n-        for (int i=0; i<threads; i++) {\n-            servers[i] = new Server (cb, schan, cperthread);\n-            servers[i].start();\n-        }\n-    }\n-\n-    \/**\n-     * Tell all threads in the server to exit within 5 seconds.\n-     * This is an abortive termination. Just prior to the thread exiting\n-     * all channels in that thread waiting to be closed are forceably closed.\n-     * @throws InterruptedException\n-     *\/\n-\n-    public void terminate () {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-\n-        for (int i = 0; i < threads; i++) {\n-            try {\n-                servers[i].join();\n-            } catch (InterruptedException e) {\n-                System.err.println(\"Unexpected InterruptedException during terminating server\");\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        volatile boolean shutdown;\n-\n-        Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate (512);\n-            clist = new ClosedChannelList ();\n-            try {\n-                selector = Selector.open ();\n-                schan.configureBlocking (false);\n-                listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println (\"Server could not start: \" + e);\n-                throw new RuntimeException(\"Server could not start: \" + e, e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public void terminate () {\n-            shutdown = true;\n-        }\n-\n-        public void run ()  {\n-            try {\n-                while (true) {\n-                    selector.select(1000);\n-                    Set<SelectionKey> selected = selector.selectedKeys();\n-                    Iterator<SelectionKey> iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept ();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking (false);\n-                            sock.register (selector, SelectionKey.OP_READ);\n-                            nconn ++;\n-                            System.out.println(\"SERVER: new connection. chan[\" + sock + \"]\");\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel ();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed;\n-                                SocketChannel chan = (SocketChannel) key.channel();\n-                                System.out.println(\"SERVER: connection readable. chan[\" + chan + \"]\");\n-                                if (key.attachment() != null) {\n-                                    System.out.println(\"Server: consume\");\n-                                    closed = consume (chan);\n-                                } else {\n-                                    closed = read (chan, key);\n-                                }\n-                                if (closed) {\n-                                    chan.close ();\n-                                    key.cancel ();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-                    if (shutdown) {\n-                        System.out.println(\"Force to Shutdown\");\n-                        SelectionKey sKey = schan.keyFor(selector);\n-                        if (sKey != null) {\n-                            sKey.cancel();\n-                        }\n-\n-                        clist.terminate ();\n-                        selector.close();\n-                        schan.socket().close();\n-                        schan.close();\n-                        return;\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println (\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-             * return true if connection closed\n-             *\/\n-        boolean consume (SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear ();\n-                int c = chan.read (consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read (SocketChannel chan, SelectionKey key) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream (new NioInputStream (chan));\n-                String requestline = readLine (is);\n-                MessageHeader mhead = new MessageHeader (is);\n-                String clen = mhead.findValue (\"Content-Length\");\n-                String trferenc = mhead.findValue (\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals (\"chunked\"))\n-                    data = new String (readChunkedData (is));\n-                else if (clen != null)\n-                    data = new String (readNormalData (is, Integer.parseInt (clen)));\n-                String[] req = requestline.split (\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI (req[1]);\n-                    msg = new HttpTransaction (this, cmd, uri, mhead, data, null, key);\n-                    cb.request (msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction (this, cmd, null, null, null, null, key);\n-                    msg.sendResponse (501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData (InputStream is, int len) throws IOException {\n-            byte [] buf  = new byte [len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData (InputStream is) throws IOException {\n-            LinkedList l = new LinkedList ();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add (readNormalData(is, len));\n-                total += len;\n-                readCRLF(is);  \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte [total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy (b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen (InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine (InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte [512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String (b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel (SelectionKey key) throws IOException {\n-            SocketChannel ch = (SocketChannel)key.channel ();\n-            System.out.println(\"SERVER: orderlyCloseChannel chan[\" + ch + \"]\");\n-            ch.socket().shutdownOutput();\n-            key.attach (this);\n-            clist.add (key);\n-        }\n-\n-        synchronized void abortiveCloseChannel (SelectionKey key) throws IOException {\n-            SocketChannel ch = (SocketChannel)key.channel ();\n-            System.out.println(\"SERVER: abortiveCloseChannel chan[\" + ch + \"]\");\n-\n-            Socket s = ch.socket ();\n-            s.setSoLinger (true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer chanbuf;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream (SocketChannel chan) throws IOException {\n-            this.channel = chan;\n-            selector = Selector.open();\n-            chanbuf = ByteBuffer.allocate (1024);\n-            key = chan.register (selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read (byte[] b) throws IOException {\n-            return read (b, 0, b.length);\n-        }\n-\n-        public synchronized int read () throws IOException {\n-            return read (one, 0, 1);\n-        }\n-\n-        public synchronized int read (byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining ();\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block ();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                chanbuf.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put (b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available () throws IOException {\n-            if (closed)\n-                throw new IOException (\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            chanbuf.clear ();\n-            available = channel.read (chanbuf);\n-            if (available > 0)\n-                chanbuf.flip();\n-            else if (available == -1)\n-                throw new IOException (\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block () throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select ();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available ();\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark (int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate (readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset () throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException (\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip ();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SocketChannel channel;\n-        ByteBuffer buf;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream (SocketChannel channel) throws IOException {\n-            this.channel = channel;\n-            selector = Selector.open ();\n-            key = channel.register (selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte [1];\n-        }\n-\n-        public synchronized void write (int b) throws IOException {\n-            one[0] = (byte)b;\n-            write (one, 0, 1);\n-        }\n-\n-        public synchronized void write (byte[] b) throws IOException {\n-            write (b, 0, b.length);\n-        }\n-\n-        public synchronized void write (byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException (\"stream is closed\");\n-\n-            buf = ByteBuffer.allocate (len);\n-            buf.put (b, off, len);\n-            buf.flip ();\n-            int n;\n-            while ((n = channel.write (buf)) < len) {\n-                len -= n;\n-                if (len == 0)\n-                    return;\n-                selector.select ();\n-                selector.selectedKeys().clear ();\n-            }\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue (int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond (String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put (condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous (String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get (name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException (\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue ();\n-                conditions.put (name, cond);\n-                iv = new IValue (N-1);\n-                rv.put (name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get (name);\n-                iv.v --;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition (name);\n-        } else {\n-            setCondition (name);\n-            synchronized (conditions) {\n-                clearCondition (name);\n-                rv.remove (name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove (condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/httptest\/TestHttpServer.java","additions":0,"deletions":797,"binary":false,"changes":797,"status":"deleted"}]}