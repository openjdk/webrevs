{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,1 @@\n-    final Set<ConstantDesc> catchTypes;\n+    final Set<Integer> catchIndices;\n@@ -49,1 +50,1 @@\n-        this.catchTypes = new HashSet<>();\n+        this.catchIndices = new HashSet<>();\n@@ -62,3 +63,14 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            if (!catchIndices.add(0)) {\n+                throw new IllegalArgumentException(\"Existing catch block catches exception of all type\");\n+            }\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                if (!catchIndices.add(entry.index())) {\n+                    throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+                }\n+                entries.add(entry);\n@@ -67,0 +79,1 @@\n+        \/\/ End validation\n@@ -68,3 +81,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +98,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_NPE, handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(null, handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"}]}