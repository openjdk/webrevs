{"files":[{"patch":"@@ -328,0 +328,5 @@\n+     * <p>\n+     * The order of catch blocks is significant.  When an exception is thrown\n+     * by the try block, the first catch block whose exception type is {@linkplain\n+     * Class#isAssignableFrom(Class) the same class as or a superclass of} the\n+     * class of exception thrown is branched to (JVMS {@jvms 2.10}).\n@@ -346,0 +351,4 @@\n+         * @apiNote\n+         * If the type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -350,3 +359,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         an exception of the given type or {@code exceptionType}\n-         *         represents a primitive type\n+         * @throws IllegalArgumentException if {@code exceptionType} represents\n+         *         a primitive type\n@@ -370,0 +378,4 @@\n+         * @apiNote\n+         * If every type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -374,2 +386,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         one or more exceptions of the given types\n+         * @throws IllegalArgumentException if any exception type represents a\n+         *         primitive type\n@@ -390,0 +402,4 @@\n+         * @apiNote\n+         * Since this block intercepts all exceptions, all subsequent catch\n+         * blocks will never be executed.\n+         *\n@@ -392,2 +408,0 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         all exceptions\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n- * table entries.  Delivered as a {@link CodeElement} when traversing the\n- * contents of a {@link CodeModel}.\n+ * table entries.  The order of exception table entries is significant: when an\n+ * exception is thrown in a method, execution branches to the first matching\n+ * exception handler if such a handler exists (JVMS {@jvms 2.4}). Delivered as\n+ * a {@link CodeElement} when traversing the contents of a {@link CodeModel}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,0 @@\n-    final Set<ConstantDesc> catchTypes;\n@@ -49,1 +49,0 @@\n-        this.catchTypes = new HashSet<>();\n@@ -62,3 +61,8 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                entries.add(entry);\n@@ -67,0 +71,1 @@\n+        \/\/ End validation\n@@ -68,3 +73,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +90,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(CD_NPE, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(null, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"}]}