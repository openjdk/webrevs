{"files":[{"patch":"@@ -160,0 +160,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/cpu\/ppc\/atomicAccess_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n@@ -61,0 +64,1 @@\n+  STATIC_ASSERT(byte_size == 4 || byte_size == 8);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomicAccess_bsd_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomicAccess_bsd_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomicAccess_bsd_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomicAccess_linux_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomicAccess_linux_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n@@ -167,0 +170,1 @@\n+  STATIC_ASSERT(byte_size == 4 || byte_size == 8);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomicAccess_linux_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/atomicAccess_linux_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomicAccess_linux_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomicAccess_linux_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n@@ -78,0 +81,2 @@\n+    STATIC_ASSERT(sizeof(IntrinsicType) == 4 ||                           \\\n+                  sizeof(IntrinsicType) == 8);                            \\\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomicAccess_windows_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+template<>\n+struct AtomicAccess::PlatformXchg<1> : AtomicAccess::XchgUsingCmpxchg<1> {};\n+\n@@ -80,0 +83,2 @@\n+    STATIC_ASSERT(sizeof(IntrinsicType) == 4 ||                           \\\n+                  sizeof(IntrinsicType) == 8);                            \\\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/atomicAccess_windows_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+\/\/     v.exchange(x [, o]) -> T\n@@ -95,1 +96,0 @@\n-\/\/     v.exchange(x [, o]) -> T\n@@ -105,4 +105,1 @@\n-\/\/ (4) An atomic translated type additionally provides the exchange\n-\/\/ function if its associated atomic decayed type provides that function.\n-\/\/\n-\/\/ (5) Atomic integers additionally provide\n+\/\/ (4) Atomic integers additionally provide\n@@ -118,1 +115,1 @@\n-\/\/ (6) Atomic pointers additionally provide\n+\/\/ (5) Atomic pointers additionally provide\n@@ -130,3 +127,0 @@\n-\/\/ Atomic bytes don't provide exchange(). This is because that operation\n-\/\/ hasn't been implemented for 1 byte values. That could be changed if needed.\n-\/\/\n@@ -187,1 +181,0 @@\n-  template<typename T> class SupportsExchange;\n@@ -190,6 +183,0 @@\n-  \/\/ Support conditional exchange() for atomic translated types.\n-  template<typename T> class HasExchange;\n-  template<typename T> class DecayedHasExchange;\n-  template<typename Derived, typename T, bool = DecayedHasExchange<T>::value>\n-  class TranslatedExchange;\n-\n@@ -278,7 +265,0 @@\n-};\n-\n-template<typename T>\n-class AtomicImpl::SupportsExchange : public CommonCore<T> {\n-protected:\n-  explicit SupportsExchange(T value) : CommonCore<T>(value) {}\n-  ~SupportsExchange() = default;\n@@ -286,1 +266,0 @@\n-public:\n@@ -294,1 +273,1 @@\n-class AtomicImpl::SupportsArithmetic : public SupportsExchange<T> {\n+class AtomicImpl::SupportsArithmetic : public CommonCore<T> {\n@@ -314,1 +293,1 @@\n-  explicit SupportsArithmetic(T value) : SupportsExchange<T>(value) {}\n+  explicit SupportsArithmetic(T value) : CommonCore<T>(value) {}\n@@ -427,41 +406,0 @@\n-\/\/ Test whether Atomic<T> has exchange().\n-template<typename T>\n-class AtomicImpl::HasExchange {\n-  template<typename Check> static void* test(decltype(&Check::exchange));\n-  template<typename> static int test(...);\n-  using test_type = decltype(test<Atomic<T>>(nullptr));\n-public:\n-  static constexpr bool value = std::is_pointer_v<test_type>;\n-};\n-\n-\/\/ Test whether the atomic decayed type associated with T has exchange().\n-template<typename T>\n-class AtomicImpl::DecayedHasExchange {\n-  using Translator = PrimitiveConversions::Translate<T>;\n-  using Decayed = typename Translator::Decayed;\n-\n-  \/\/ \"Unit test\" HasExchange<>.\n-  static_assert(HasExchange<int>::value);\n-  static_assert(HasExchange<int*>::value);\n-  static_assert(!HasExchange<char>::value);\n-\n-public:\n-  static constexpr bool value = HasExchange<Decayed>::value;\n-};\n-\n-\/\/ Base class for atomic translated type if atomic decayed type doesn't have\n-\/\/ exchange().\n-template<typename Derived, typename T, bool>\n-class AtomicImpl::TranslatedExchange {};\n-\n-\/\/ Base class for atomic translated type if atomic decayed type does have\n-\/\/ exchange().\n-template<typename Derived, typename T>\n-class AtomicImpl::TranslatedExchange<Derived, T, true> {\n-public:\n-  T exchange(T new_value,\n-             atomic_memory_order order = memory_order_conservative) {\n-    return static_cast<Derived*>(this)->exchange_impl(new_value, order);\n-  }\n-};\n-\n@@ -469,6 +407,1 @@\n-class AtomicImpl::Atomic<T, AtomicImpl::Category::Translated>\n-  : public TranslatedExchange<Atomic<T>, T>\n-{\n-  \/\/ Give TranslatedExchange<> access to exchange_impl() if needed.\n-  friend class TranslatedExchange<Atomic<T>, T>;\n-\n+class AtomicImpl::Atomic<T, AtomicImpl::Category::Translated> {\n@@ -536,6 +469,1 @@\n-private:\n-  \/\/ Implementation of exchange() if needed.\n-  \/\/ Exclude when not needed, to prevent reference to non-existent function\n-  \/\/ of atomic decayed type if someone explicitly instantiates Atomic<T>.\n-  template<typename Dep = Decayed, ENABLE_IF(HasExchange<Dep>::value)>\n-  T exchange_impl(T new_value, atomic_memory_order order) {\n+  T exchange(T new_value, atomic_memory_order order = memory_order_conservative) {\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":7,"deletions":79,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -422,2 +422,2 @@\n-  \/\/ of 4, and sizeof(intptr_t) are required.  The class is a function\n-  \/\/ object that must be default constructable, with these requirements:\n+  \/\/ of 1, 4, and 8 are required.  The class is a function object\n+  \/\/ that must be default constructable, with these requirements:\n","filename":"src\/hotspot\/share\/runtime\/atomicAccess.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-struct AtomicIntegerXchgTestSupport {\n+struct AtomicByteAndIntegerXchgTestSupport {\n@@ -107,1 +107,1 @@\n-  AtomicIntegerXchgTestSupport() : _test_value{} {}\n+  AtomicByteAndIntegerXchgTestSupport() : _test_value{} {}\n@@ -119,0 +119,5 @@\n+TEST_VM(AtomicIntegerTest, xchg_char) {\n+  using Support = AtomicByteAndIntegerXchgTestSupport<char>;\n+  Support().test();\n+}\n+\n@@ -120,1 +125,1 @@\n-  using Support = AtomicIntegerXchgTestSupport<int32_t>;\n+  using Support = AtomicByteAndIntegerXchgTestSupport<int32_t>;\n@@ -125,1 +130,1 @@\n-  using Support = AtomicIntegerXchgTestSupport<int64_t>;\n+  using Support = AtomicByteAndIntegerXchgTestSupport<int64_t>;\n@@ -162,1 +167,1 @@\n-struct AtomicCmpxchg1ByteStressSupport {\n+struct AtomicXchgAndCmpxchg1ByteStressSupport {\n@@ -167,1 +172,1 @@\n-  AtomicCmpxchg1ByteStressSupport() : _default_val(0x7a), _base(7) {}\n+  AtomicXchgAndCmpxchg1ByteStressSupport() : _default_val(0x7a), _base(7) {}\n@@ -185,0 +190,1 @@\n+  template <typename Exchange>\n@@ -186,0 +192,1 @@\n+    Exchange exchange;\n@@ -187,1 +194,1 @@\n-    _array[index].compare_exchange(_default_val, one);\n+    exchange(_array[index], _default_val, one);\n@@ -190,1 +197,1 @@\n-    _array[index].compare_exchange(one, _default_val);\n+    exchange(_array[index], one, _default_val);\n@@ -194,0 +201,1 @@\n+  template <typename Exchange>\n@@ -199,1 +207,1 @@\n-      test_index(i);\n+      test_index<Exchange>(i);\n@@ -202,0 +210,17 @@\n+  void test_exchange() {\n+    struct StressWithExchange {\n+      void operator()(Atomic<char>& atomic, char compare_value, char new_value) {\n+        EXPECT_EQ(compare_value, atomic.exchange(new_value));\n+      }\n+    };\n+    test<StressWithExchange>();\n+  }\n+\n+  void test_compare_exchange() {\n+    struct StressWithCompareExchange {\n+      void operator()(Atomic<char>& atomic, char compare_value, char new_value) {\n+        EXPECT_EQ(compare_value, atomic.compare_exchange(compare_value, new_value));\n+      }\n+    };\n+    test<StressWithCompareExchange>();\n+  }\n@@ -204,3 +229,8 @@\n-TEST_VM(AtomicCmpxchg1Byte, stress) {\n-  AtomicCmpxchg1ByteStressSupport support;\n-  support.test();\n+TEST_VM(AtomicByteTest, stress_xchg) {\n+  AtomicXchgAndCmpxchg1ByteStressSupport support;\n+  support.test_exchange();\n+}\n+\n+TEST_VM(AtomicByteTest, stress_cmpxchg) {\n+  AtomicXchgAndCmpxchg1ByteStressSupport support;\n+  support.test_compare_exchange();\n@@ -210,1 +240,1 @@\n-struct AtomicEnumTestSupport {\n+struct AtomicTestSupport {\n@@ -213,1 +243,1 @@\n-  AtomicEnumTestSupport() : _test_value{} {}\n+  AtomicTestSupport() : _test_value{} {}\n@@ -236,0 +266,7 @@\n+\n+  template <T B, T C>\n+  static void test() {\n+    AtomicTestSupport().test_store_load(B);\n+    AtomicTestSupport().test_cmpxchg(B, C);\n+    AtomicTestSupport().test_xchg(B, C);\n+  }\n@@ -244,5 +281,1 @@\n-  using Support = AtomicEnumTestSupport<TestEnum>;\n-\n-  Support().test_store_load(B);\n-  Support().test_cmpxchg(B, C);\n-  Support().test_xchg(B, C);\n+  AtomicTestSupport<TestEnum>::test<B, C>();\n@@ -256,1 +289,8 @@\n-  using Support = AtomicEnumTestSupport<AtomicEnumTestScoped>;\n+  AtomicTestSupport<AtomicEnumTestScoped>::test<B, C>();\n+}\n+\n+enum class AtomicEnumTestScoped64Bit : uint64_t { A, B, C };\n+\n+TEST_VM(AtomicEnumTest, scoped_enum_64_bit) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n@@ -258,3 +298,23 @@\n-  Support().test_store_load(B);\n-  Support().test_cmpxchg(B, C);\n-  Support().test_xchg(B, C);\n+  const AtomicEnumTestScoped64Bit B = AtomicEnumTestScoped64Bit::B;\n+  const AtomicEnumTestScoped64Bit C = AtomicEnumTestScoped64Bit::C;\n+  AtomicTestSupport<AtomicEnumTestScoped64Bit>::test<B, C>();\n+}\n+\n+enum class AtomicEnumTestScoped8Bit : uint8_t { A, B, C };\n+\n+TEST_VM(AtomicEnumTest, scoped_enum_8_bit) {\n+  const AtomicEnumTestScoped8Bit B = AtomicEnumTestScoped8Bit::B;\n+  const AtomicEnumTestScoped8Bit C = AtomicEnumTestScoped8Bit::C;\n+  AtomicTestSupport<AtomicEnumTestScoped8Bit>::test<B, C>();\n+}\n+\n+TEST_VM(AtomicByteTest, char_test) {\n+  const char B = 0xB;\n+  const char C = 0xC;\n+  AtomicTestSupport<char>::test<B, C>();\n+}\n+\n+TEST_VM(AtomicByteTest, bool_test) {\n+  const bool B = true;\n+  const bool C = false;\n+  AtomicTestSupport<bool>::test<B, C>();\n@@ -517,34 +577,0 @@\n-\/\/ Test whether Atomic<T> has exchange().\n-\/\/ Note: This is intentionally a different implementation from what is used\n-\/\/ by the atomic translated type to decide whether to provide exchange().\n-\/\/ The intent is to make related testing non-tautological.\n-\/\/ The two implementations must agree; it's a bug if they don't.\n-template<typename T>\n-class AtomicTypeHasExchange {\n-  template<typename U,\n-           typename AU = Atomic<U>,\n-           typename = decltype(declval<AU>().exchange(declval<U>()))>\n-  static char* test(int);\n-\n-  template<typename> static char test(...);\n-\n-  using test_type = decltype(test<T>(0));\n-\n-public:\n-  static constexpr bool value = std::is_pointer_v<test_type>;\n-};\n-\n-\/\/ Unit tests for AtomicTypeHasExchange.\n-static_assert(AtomicTypeHasExchange<int>::value);\n-static_assert(AtomicTypeHasExchange<int*>::value);\n-static_assert(AtomicTypeHasExchange<TranslatedAtomicTestObject1>::value);\n-static_assert(AtomicTypeHasExchange<TranslatedAtomicTestObject2>::value);\n-static_assert(!AtomicTypeHasExchange<uint8_t>::value);\n-\n-\/\/ Verify translated byte type *doesn't* have exchange.\n-static_assert(!AtomicTypeHasExchange<TranslatedAtomicByteObject>::value);\n-\n-\/\/ Verify that explicit instantiation doesn't attempt to reference the\n-\/\/ non-existent exchange of the atomic decayed type.\n-template class AtomicImpl::Atomic<TranslatedAtomicByteObject>;\n-\n@@ -565,4 +591,2 @@\n-  if constexpr (AtomicTypeHasExchange<T>::value) {\n-    EXPECT_EQ(10, Translated::decay(_test_value.exchange(Translated::recover(20))));\n-    EXPECT_EQ(20, Translated::decay(_test_value.load_relaxed()));\n-  }\n+  EXPECT_EQ(10, Translated::decay(_test_value.exchange(Translated::recover(20))));\n+  EXPECT_EQ(20, Translated::decay(_test_value.load_relaxed()));\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":85,"deletions":61,"binary":false,"changes":146,"status":"modified"}]}