{"files":[{"patch":"@@ -817,0 +817,19 @@\n+static const TypeFunc* clone_type() {\n+  \/\/ Create input type (domain)\n+  int argcnt = NOT_LP64(3) LP64_ONLY(4);\n+  const Type** const domain_fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ src\n+  domain_fields[argp++] = TypeInstPtr::NOTNULL;  \/\/ dst\n+  domain_fields[argp++] = TypeX_X;               \/\/ size lower\n+  LP64_ONLY(domain_fields[argp++] = Type::HALF); \/\/ size upper\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + argcnt, domain_fields);\n+\n+  \/\/ Create result type (range)\n+  const Type** const range_fields = TypeTuple::fields(0);\n+  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n+\n+  return TypeFunc::make(domain, range);\n+}\n+\n@@ -819,0 +838,31 @@\n+void BarrierSetC2::clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                                    address clone_addr, const char* clone_name) const {\n+  Node* const ctrl = ac->in(TypeFunc::Control);\n+  Node* const mem  = ac->in(TypeFunc::Memory);\n+  Node* const src  = ac->in(ArrayCopyNode::Src);\n+  Node* const dst  = ac->in(ArrayCopyNode::Dest);\n+  Node* const size = ac->in(ArrayCopyNode::Length);\n+\n+  assert(size->bottom_type()->base() == Type_X,\n+         \"Should be of object size type (int for 32 bits, long for 64 bits)\");\n+\n+  \/\/ The native clone we are calling here expects the object size in words.\n+  \/\/ Add header\/offset size to payload size to get object size.\n+  Node* const base_offset = phase->MakeConX(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n+  Node* const full_size = phase->transform_later(new AddXNode(size, base_offset));\n+  \/\/ HeapAccess<>::clone expects size in heap words.\n+  \/\/ For 64-bits platforms, this is a no-operation.\n+  \/\/ For 32-bits platforms, we need to multiply full_size by HeapWordsPerLong (2).\n+  Node* const full_size_in_heap_words = phase->transform_later(new LShiftXNode(full_size, phase->intcon(LogHeapWordsPerLong)));\n+\n+  Node* const call = phase->make_leaf_call(ctrl,\n+                                           mem,\n+                                           clone_type(),\n+                                           clone_addr,\n+                                           clone_name,\n+                                           TypeRawPtr::BOTTOM,\n+                                           src, dst, full_size_in_heap_words XTOP);\n+  phase->transform_later(call);\n+  phase->igvn().replace_node(ac, call);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -283,0 +283,2 @@\n+  void clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                        address call_addr, const char* call_name) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,17 +410,0 @@\n-\/\/ This TypeFunc assumes a 64bit system\n-static const TypeFunc* clone_type() {\n-  \/\/ Create input type (domain)\n-  const Type** const domain_fields = TypeTuple::fields(4);\n-  domain_fields[TypeFunc::Parms + 0] = TypeInstPtr::NOTNULL;  \/\/ src\n-  domain_fields[TypeFunc::Parms + 1] = TypeInstPtr::NOTNULL;  \/\/ dst\n-  domain_fields[TypeFunc::Parms + 2] = TypeLong::LONG;        \/\/ size lower\n-  domain_fields[TypeFunc::Parms + 3] = Type::HALF;            \/\/ size upper\n-  const TypeTuple* const domain = TypeTuple::make(TypeFunc::Parms + 4, domain_fields);\n-\n-  \/\/ Create result type (range)\n-  const Type** const range_fields = TypeTuple::fields(0);\n-  const TypeTuple* const range = TypeTuple::make(TypeFunc::Parms + 0, range_fields);\n-\n-  return TypeFunc::make(domain, range);\n-}\n-\n@@ -482,25 +465,4 @@\n-  \/\/ Clone instance\n-  Node* const ctrl       = ac->in(TypeFunc::Control);\n-  Node* const mem        = ac->in(TypeFunc::Memory);\n-  Node* const dst        = ac->in(ArrayCopyNode::Dest);\n-  Node* const size       = ac->in(ArrayCopyNode::Length);\n-\n-  assert(size->bottom_type()->is_long(), \"Should be long\");\n-\n-  \/\/ The native clone we are calling here expects the instance size in words\n-  \/\/ Add header\/offset size to payload size to get instance size.\n-  Node* const base_offset = phase->longcon(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n-  Node* const full_size = phase->transform_later(new AddLNode(size, base_offset));\n-\n-  Node* const call = phase->make_leaf_call(ctrl,\n-                                           mem,\n-                                           clone_type(),\n-                                           ZBarrierSetRuntime::clone_addr(),\n-                                           \"ZBarrierSetRuntime::clone\",\n-                                           TypeRawPtr::BOTTOM,\n-                                           src,\n-                                           dst,\n-                                           full_size,\n-                                           phase->top());\n-  phase->transform_later(call);\n-  phase->igvn().replace_node(ac, call);\n+  \/\/ Clone instance or array where 'src' is only known to be an object (ary_ptr\n+  \/\/ is null). This can happen in bytecode generated dynamically to implement\n+  \/\/ reflective array clones.\n+  clone_in_runtime(phase, ac, ZBarrierSetRuntime::clone_addr(), \"ZBarrierSetRuntime::clone\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":4,"deletions":42,"binary":false,"changes":46,"status":"modified"}]}