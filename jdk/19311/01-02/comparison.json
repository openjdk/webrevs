{"files":[{"patch":"@@ -838,3 +838,2 @@\n-void BarrierSetC2::clone_instance_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n-                                             address clone_addr, const char* clone_name) const {\n-  assert(ac->is_clone_inst(), \"this function is only defined for cloning instances\");\n+void BarrierSetC2::clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                                    address clone_addr, const char* clone_name) const {\n@@ -850,3 +849,3 @@\n-  \/\/ The native clone we are calling here expects the instance size in words.\n-  \/\/ Add header\/offset size to payload size to get instance size.\n-  Node* const base_offset = phase->MakeConX(arraycopy_payload_base_offset(false \/* is_array *\/) >> LogBytesPerLong);\n+  \/\/ The native clone we are calling here expects the object size in words.\n+  \/\/ Add header\/offset size to payload size to get object size.\n+  Node* const base_offset = phase->MakeConX(arraycopy_payload_base_offset(ac->is_clone_array()) >> LogBytesPerLong);\n@@ -857,2 +856,0 @@\n-  \/\/ There is no overflow risk at this point, since full_size is derived\n-  \/\/ from a value expressing the size in bytes (see GraphKit::new_instance()).\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -283,2 +283,2 @@\n-  void clone_instance_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n-                                 address call_addr, const char* call_name) const;\n+  void clone_in_runtime(PhaseMacroExpand* phase, ArrayCopyNode* ac,\n+                        address call_addr, const char* call_name) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,1 +465,4 @@\n-  clone_instance_in_runtime(phase, ac, ZBarrierSetRuntime::clone_addr(), \"ZBarrierSetRuntime::clone\");\n+  \/\/ Clone instance or array where 'src' is only known to be an object (ary_ptr\n+  \/\/ is null). This can happen in bytecode generated dynamically to implement\n+  \/\/ reflective array clones.\n+  clone_in_runtime(phase, ac, ZBarrierSetRuntime::clone_addr(), \"ZBarrierSetRuntime::clone\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}