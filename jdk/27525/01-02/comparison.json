{"files":[{"patch":"@@ -343,4 +343,5 @@\n-      \/\/ Additionally, a humongous object containing references induces\n-      \/\/ remembered set entries on other regions.  In order to reclaim such an\n-      \/\/ object, those remembered sets would need to be cleaned up or ignored\n-      \/\/ during iteration.\n+      \/\/ We handle humongous objects specially, because frequent allocation and\n+      \/\/ dropping of large binary blobs is an important use case for eager reclaim,\n+      \/\/ and this special handling increases needed headroom.\n+      \/\/ It also helps with G1 allocating humongous objects as old generation\n+      \/\/ objects although they might also die quite quickly.\n@@ -348,4 +349,3 @@\n-      \/\/ We treat is_typeArray() objects specially, allowing them\n-      \/\/ to be reclaimed even if allocated before the start of\n-      \/\/ concurrent mark.  For this we rely on mark stack insertion to\n-      \/\/ exclude is_typeArray() objects, preventing reclaiming an object\n+      \/\/ TypeArray objects are allowed to be reclaimed even if allocated before\n+      \/\/ the start of concurrent mark.  For this we rely on mark stack insertion\n+      \/\/ to exclude is_typeArray() objects, preventing reclaiming an object\n@@ -354,3 +354,0 @@\n-      \/\/ Frequent allocation and drop of large binary blobs is an\n-      \/\/ important use case for eager reclaim, and this special handling\n-      \/\/ may increase needed headroom.\n@@ -359,19 +356,3 @@\n-      \/\/ eager reclaim during marking.  The problem with these regions having\n-      \/\/ induced card marks in other region's remembered sets is, if they are\n-      \/\/ now free, handled by ignoring them during merging the remembered sets.\n-      \/\/ Second, wrt. to the remembered sets, there may be cases where eagerly\n-      \/\/ reclaimed regions were reallocated.  This may cause scanning of outdated\n-      \/\/ remembered sets, but apart from extra work this can not cause correctness\n-      \/\/ issues.  There is no difference between scanning cards covering an\n-      \/\/ effectively dead humongous object vs. some other objects in reallocated\n-      \/\/ regions.\n-\n-      \/\/ All regions that were allocated before marking have a TAMS != bottom.\n-      bool allocated_after_mark_start = region->bottom() == _g1h->concurrent_mark()->top_at_mark_start(region);\n-      \/\/ TAMSes are only reset after completing the entire mark cycle, during\n-      \/\/ bitmap clearing. It is worth to not wait until then, and allow reclamation\n-      \/\/ outside of actual (concurrent) SATB marking.\n-      \/\/ This also applies to the concurrent start pause - we only set\n-      \/\/ mark_in_progress() at the end of that GC: no mutator is running that can\n-      \/\/ sneakily install a new reference to the potentially reclaimed humongous\n-      \/\/ object.\n+      \/\/ eager reclaim during marking.  One issue is the problem described\n+      \/\/ above with scrubbing the mark stack, but there is also a problem\n+      \/\/ causing objects being collected incorrectly:\n@@ -385,1 +366,1 @@\n-      \/\/ o2 are in the same region. Object h might be reclaimed by the next\n+      \/\/ o2 are in the same region.  Object h might be reclaimed by the next\n@@ -389,2 +370,25 @@\n-      \/\/ During (concurrent start) GC this situation can not happen. No mutator\n-      \/\/ is modifying the object graph to install such an overlooked reference.\n+      \/\/ There is another minor problem with non-typeArray regions being the source\n+      \/\/ of remembered set entries in other region's remembered sets.  There are\n+      \/\/ two cases: first, the remembered set entry is in a Free region after reclaim.\n+      \/\/ We handle this case by ignoring these cards during merging the remembered\n+      \/\/ sets.\n+      \/\/\n+      \/\/ Second, there may be cases where eagerly reclaimed regions were already\n+      \/\/ reallocated.  This may cause scanning of these outdated remembered set\n+      \/\/ entries, containing some objects. But apart from extra work this does\n+      \/\/ not cause correctness issues.\n+      \/\/ There is no difference between scanning cards covering an effectively\n+      \/\/ dead humongous object vs. some other objects in reallocated regions.\n+\n+      \/\/ All regions that were allocated before marking have a TAMS != bottom.\n+      bool allocated_after_mark_start = region->bottom() == _g1h->concurrent_mark()->top_at_mark_start(region);\n+      \/\/ TAMSes are only reset after completing the entire mark cycle, during\n+      \/\/ bitmap clearing. It is worth to not wait until then, and allow reclamation\n+      \/\/ outside of actual (concurrent) SATB marking.\n+      \/\/ This also applies to the concurrent start pause - we only set\n+      \/\/ mark_in_progress() at the end of that GC: no mutator is running that can\n+      \/\/ sneakily install a new reference to the potentially reclaimed humongous\n+      \/\/ object.\n+      \/\/ During (concurrent start) GC the situation described above where we\n+      \/\/ miss a reference can not happen. No mutator is modifying the object\n+      \/\/ graph to install such an overlooked reference.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"}]}