{"files":[{"patch":"@@ -2562,0 +2562,1 @@\n+  _verifier->verify_free_regions_card_tables_clean();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -672,0 +672,17 @@\n+void G1HeapVerifier::verify_free_regions_card_tables_clean() {\n+  class G1VerifyFreeRegionsCleanClosure : public G1HeapRegionClosure {\n+  private:\n+    G1HeapVerifier* _verifier;\n+  public:\n+    G1VerifyFreeRegionsCleanClosure(G1HeapVerifier* verifier) : G1HeapRegionClosure(), _verifier(verifier) { }\n+    virtual bool do_heap_region(G1HeapRegion* r) {\n+      if (r->is_free()) {\n+        _verifier->verify_ct_clean_region(r);\n+        _verifier->verify_rt_clean_region(r);\n+      }\n+    return false;\n+    }\n+  } cl(this);\n+  _g1h->heap_region_iterate(&cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -91,0 +91,3 @@\n+\n+  \/\/ Verify that free regions's card table is all-clean.\n+  void verify_free_regions_card_tables_clean() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  if (cast_to_oop(r->bottom())->is_typeArray() && !r->rem_set()->is_tracked()) {\n+  if ((G1EagerReclaimWithRefs || cast_to_oop(r->bottom())->is_typeArray()) && !r->rem_set()->is_tracked()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -344,4 +344,5 @@\n-      \/\/ However, we presently only nominate is_typeArray() objects.\n-      \/\/ A humongous object containing references induces remembered\n-      \/\/ set entries on other regions.  In order to reclaim such an\n-      \/\/ object, those remembered sets would need to be cleaned up.\n+      \/\/ We handle humongous objects specially, because frequent allocation and\n+      \/\/ dropping of large binary blobs is an important use case for eager reclaim,\n+      \/\/ and this special handling increases needed headroom.\n+      \/\/ It also helps with G1 allocating humongous objects as old generation\n+      \/\/ objects although they might also die quite quickly.\n@@ -349,4 +350,3 @@\n-      \/\/ We also treat is_typeArray() objects specially, allowing them\n-      \/\/ to be reclaimed even if allocated before the start of\n-      \/\/ concurrent mark.  For this we rely on mark stack insertion to\n-      \/\/ exclude is_typeArray() objects, preventing reclaiming an object\n+      \/\/ TypeArray objects are allowed to be reclaimed even if allocated before\n+      \/\/ the start of concurrent mark.  For this we rely on mark stack insertion\n+      \/\/ to exclude is_typeArray() objects, preventing reclaiming an object\n@@ -355,5 +355,46 @@\n-      \/\/ Frequent allocation and drop of large binary blobs is an\n-      \/\/ important use case for eager reclaim, and this special handling\n-      \/\/ may reduce needed headroom.\n-\n-      return obj->is_typeArray() &&\n+      \/\/\n+      \/\/ Non-typeArrays that were allocated before marking are excluded from\n+      \/\/ eager reclaim during marking.  One issue is the problem described\n+      \/\/ above with scrubbing the mark stack, but there is also a problem\n+      \/\/ causing objects being collected incorrectly:\n+      \/\/\n+      \/\/ E.g. if the mutator is running, we may have objects o1 and o2 in the same\n+      \/\/ region, where o1 has already been scanned and o2 is only reachable by\n+      \/\/ the candidate object h, which is humongous.\n+      \/\/\n+      \/\/ If the mutator read the reference to o2 from h and installed it into o1,\n+      \/\/ no remembered set entry would be created for keeping alive o2, as o1 and\n+      \/\/ o2 are in the same region.  Object h might be reclaimed by the next\n+      \/\/ garbage collection. o1 still has the reference to o2, but since o1 had\n+      \/\/ already been scanned we do not detect o2 to be still live and reclaim it.\n+      \/\/\n+      \/\/ There is another minor problem with non-typeArray regions being the source\n+      \/\/ of remembered set entries in other region's remembered sets.  There are\n+      \/\/ two cases: first, the remembered set entry is in a Free region after reclaim.\n+      \/\/ We handle this case by ignoring these cards during merging the remembered\n+      \/\/ sets.\n+      \/\/\n+      \/\/ Second, there may be cases where eagerly reclaimed regions were already\n+      \/\/ reallocated.  This may cause scanning of these outdated remembered set\n+      \/\/ entries, containing some objects. But apart from extra work this does\n+      \/\/ not cause correctness issues.\n+      \/\/ There is no difference between scanning cards covering an effectively\n+      \/\/ dead humongous object vs. some other objects in reallocated regions.\n+\n+      \/\/ All regions that were allocated before marking have a TAMS != bottom.\n+      bool allocated_after_mark_start = region->bottom() == _g1h->concurrent_mark()->top_at_mark_start(region);\n+      \/\/ TAMSes are only reset after completing the entire mark cycle, during\n+      \/\/ bitmap clearing. It is worth to not wait until then, and allow reclamation\n+      \/\/ outside of actual (concurrent) SATB marking.\n+      \/\/ This also applies to the concurrent start pause - we only set\n+      \/\/ mark_in_progress() at the end of that GC: no mutator is running that can\n+      \/\/ sneakily install a new reference to the potentially reclaimed humongous\n+      \/\/ object.\n+      \/\/ During (concurrent start) GC the situation described above where we\n+      \/\/ miss a reference can not happen. No mutator is modifying the object\n+      \/\/ graph to install such an overlooked reference.\n+      \/\/\n+      \/\/ After the pause, having reclaimed h, obviously the mutator can't fetch\n+      \/\/ the reference from h any more.\n+      bool mark_in_progress = _g1h->collector_state()->mark_in_progress();\n+      return (obj->is_typeArray() || (G1EagerReclaimWithRefs && (allocated_after_mark_start || !mark_in_progress))) &&\n@@ -396,1 +437,1 @@\n-                               \"marked %d pinned count %zu reclaim candidate %d type array %d\",\n+                               \"marked %d pinned count %zu reclaim candidate %d type %s\",\n@@ -405,1 +446,2 @@\n-                               cast_to_oop(hr->bottom())->is_typeArray()\n+                               cast_to_oop(hr->bottom())->is_typeArray() ? \"tA\"\n+                                                                         : (cast_to_oop(hr->bottom())->is_objArray() ? \"oA\" : \"ob\")\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":57,"deletions":15,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -353,2 +353,2 @@\n-  \/\/ - any found outstanding (i.e. in the DCQ, or in its remembered set)\n-  \/\/ references will set the candidate state to false.\n+  \/\/ - any found outstanding (i.e. in its remembered set, or from the collection\n+  \/\/ set) references will set the candidate state to false.\n@@ -357,1 +357,1 @@\n-  \/\/ (I.e. there can be no intra-region references)\n+  \/\/ (I.e. there can be no intra-region references within humongous objects)\n@@ -366,2 +366,0 @@\n-  \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-  \/\/ are completely up-to-date wrt to references to the humongous object.\n@@ -369,1 +367,2 @@\n-  \/\/ So there is no need to re-check remembered set size of the humongous region.\n+  \/\/ Since remembered sets are only ever updated by concurrent refinement threads\n+  \/\/ at mutator time, the remembered sets do not need to be checked again.\n@@ -372,4 +371,2 @@\n-  \/\/ - never consider object arrays at this time because they would pose\n-  \/\/ considerable effort for cleaning up the remembered sets. This is\n-  \/\/ required because stale remembered sets might reference locations that\n-  \/\/ are currently allocated into.\n+  \/\/ - never consider non-typeArrays during marking as there is a considerable cost\n+  \/\/ for maintaining the SATB invariant.\n@@ -396,4 +393,9 @@\n-    guarantee(obj->is_typeArray(),\n-              \"Only eagerly reclaiming type arrays is supported, but the object \"\n-              PTR_FORMAT \" is not.\", p2i(r->bottom()));\n-\n+    {\n+      ResourceMark rm;\n+      bool allocated_after_mark_start = r->bottom() == _g1h->concurrent_mark()->top_at_mark_start(r);\n+      bool mark_in_progress = _g1h->collector_state()->mark_in_progress();\n+      guarantee(obj->is_typeArray() || (G1EagerReclaimWithRefs && (allocated_after_mark_start || !mark_in_progress)),\n+                \"Only eagerly reclaiming primitive arrays is supported, other humongous objects only if allocated after mark start, but the object \"\n+                PTR_FORMAT \" (%s) is not (mark %d allocated after mark: %d).\",\n+                p2i(r->bottom()), obj->klass()->name()->as_C_string(), mark_in_progress, allocated_after_mark_start);\n+    }\n@@ -419,0 +421,3 @@\n+      \/\/ Humongous non-typeArrays may have dirty card tables. Need to be cleared. Do it\n+      \/\/ for all types just in case.\n+      r->clear_both_card_tables();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+  product(bool, G1EagerReclaimWithRefs, true, DIAGNOSTIC,                   \\\n+          \"Allow eager reclaim of non-typeArray humongous objects.\")        \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n- * @bug 8027959\n- * @summary Test to make sure that eager reclaim of humongous objects work. We simply try to fill\n- * up the heap with humongous objects that should be eagerly reclaimable to avoid Full GC.\n+ * @bug 8051973\n+ * @summary Test to make sure that eager reclaim of humongous objects correctly works.\n@@ -32,1 +31,2 @@\n- * @library \/test\/lib\n+ * @requires vm.debug\n+ * @library \/test\/lib \/testlibrary \/\n@@ -35,1 +35,3 @@\n- * @run driver gc.g1.TestEagerReclaimHumongousRegions\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:+WhiteBoxAPI gc.g1.TestEagerReclaimHumongousRegions\n@@ -38,1 +40,2 @@\n-import java.util.regex.Pattern;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -40,1 +43,2 @@\n-import java.util.LinkedList;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Pattern;\n@@ -42,0 +46,1 @@\n+import jdk.test.lib.Asserts;\n@@ -44,1 +49,1 @@\n-import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n@@ -46,2 +51,25 @@\n-class TestEagerReclaimHumongousRegionsReclaimRegionFast {\n-    public static final int M = 1024*1024;\n+public class TestEagerReclaimHumongousRegions {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    enum ObjectType { TYPE_ARRAY, OBJ_ARRAY }\n+    enum ReferencePolicy { KEEP, DROP }\n+    enum AllocationTiming { BEFORE_MARK_START, AFTER_MARK_START}\n+\n+    enum ExpectedState {\n+        MARKED_CANDIDATE_RECLAIMED(true, true, true),\n+        MARKED_CANDIDATE_NOT_RECLAIMED(true, true, false),\n+        MARKED_NOTCANDIDATE_NOTRECLAIMED(true, false, false),\n+        NOTMARKED_CANDIDATE_RECLAIMED(false, true, true),\n+        NOTMARKED_CANDIDATE_NOTRECLAIMED(false, true, false),\n+        NOTMARKED_NOTCANDIDATE_NOTRECLAIMED(false, false, false);\n+\n+        final boolean marked;\n+        final boolean candidate;\n+        final boolean reclaimed;\n+\n+        ExpectedState(boolean marked, boolean candidate, boolean reclaimed) {\n+            this.marked = marked;\n+            this.candidate = candidate;\n+            this.reclaimed = reclaimed;\n+        }\n+    }\n@@ -49,1 +77,36 @@\n-    public static LinkedList<Object> garbageList = new LinkedList<Object>();\n+    \/**\n+     * Run the helper VM, passing configuration arguments, simulating an application allocating some kind of humongous object at a\n+     * point during the induced concurrent mark, and executing a young gc.\n+     *\n+     * @param useTypeArray The allocated humongous object should be a typeArray, otherwise an objArray.\n+     * @param keepReference Remove the reference to the allocated object after reaching the given phase or not.\n+     * @param allocateAfter Allocate the humongous objects before or after reaching the given phase.\n+     * @param phase The phase during concurrent mark to reach before triggering a young garbage collection.\n+     * @return Returns the stdout of the VM.\n+     *\/\n+    private static String runHelperVM(ObjectType type, ReferencePolicy refPolicy, AllocationTiming timing, String phase) throws Exception {\n+\n+        boolean useTypeArray = (type == ObjectType.TYPE_ARRAY);\n+        boolean keepReference = (refPolicy == ReferencePolicy.KEEP);\n+        boolean allocateAfter = (timing == AllocationTiming.AFTER_MARK_START);\n+\n+        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n+                                                                    \"-Xmx20M\",\n+                                                                    \"-Xms20m\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+VerifyAfterGC\",\n+                                                                    \"-Xbootclasspath\/a:.\",\n+                                                                    \"-Xlog:gc=debug,gc+humongous=debug\",\n+                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                    TestEagerReclaimHumongousRegionsClearMarkBitsRunner.class.getName(),\n+                                                                    String.valueOf(useTypeArray),\n+                                                                    String.valueOf(keepReference),\n+                                                                    String.valueOf(allocateAfter),\n+                                                                    phase);\n+\n+        String log = output.getStdout();\n+        System.out.println(log);\n+        output.shouldHaveExitValue(0);\n+        return log;\n+    }\n@@ -51,5 +114,2 @@\n-    public static void genGarbage() {\n-        for (int i = 0; i < 32*1024; i++) {\n-            garbageList.add(new int[100]);\n-        }\n-        garbageList.clear();\n+    private static String boolToInt(boolean value) {\n+        return value ? \"1\" : \"0\";\n@@ -58,2 +118,6 @@\n-    \/\/ A large object referenced by a static.\n-    static int[] filler = new int[10 * M];\n+    private static void runTest(ObjectType type,\n+                                ReferencePolicy refPolicy,\n+                                AllocationTiming timing,\n+                                String phase,\n+                                ExpectedState expected) throws Exception {\n+        String log = runHelperVM(type, refPolicy, timing, phase);\n@@ -61,1 +125,2 @@\n-    public static void main(String[] args) {\n+        \/\/ Find the log output indicating that the humongous object has been reclaimed, and marked and verify for the expected results.\n+\/\/ [0.351s][debug][gc,humongous] GC(3) Humongous region 2 (object size 4194320 @ 0x00000000fee00000) remset 0 code roots 0 marked 1 pinned count 0 reclaim candidate 1 type array 1\n@@ -63,1 +128,9 @@\n-        int[] large = new int[M];\n+        \/\/ Now check the result of the reclaim attempt. We are interested in the last such message (as mentioned above, we might get two).\n+        String patternString = \"gc,humongous.* marked (\\\\d) pin.*candidate (\\\\d)\";\n+        Pattern pattern = Pattern.compile(patternString);\n+        Matcher matcher = pattern.matcher(log);\n+\n+        List<MatchResult> found = new ArrayList<MatchResult>();\n+        while (matcher.find()) {\n+          found.add(matcher.toMatchResult());\n+        }\n@@ -65,1 +138,1 @@\n-        Object ref_from_stack = large;\n+        Asserts.assertTrue(found.size() == 1 || found.size() == 2, \"Unexpected number of log messages \" + found.size());\n@@ -67,7 +140,5 @@\n-        for (int i = 0; i < 100; i++) {\n-            \/\/ A large object that will be reclaimed eagerly.\n-            large = new int[6*M];\n-            genGarbage();\n-            \/\/ Make sure that the compiler cannot completely remove\n-            \/\/ the allocation of the large object until here.\n-            System.out.println(large);\n+        if (found.size() == 2) {\n+          Asserts.assertTrue(timing == AllocationTiming.BEFORE_MARK_START, \"Should only have two messages if allocating the object before mark start\");\n+          MatchResult mr = found.removeFirst();\n+          Asserts.assertTrue(mr.group(1).equals(boolToInt(false)), \"Should not be marked before mark start \" + mr.group());\n+          Asserts.assertTrue(mr.group(2).equals(boolToInt(true)), \"Should be candidate before mark start \" + mr.group());\n@@ -76,2 +147,43 @@\n-        \/\/ Keep the reference to the first object alive.\n-        System.out.println(ref_from_stack);\n+        MatchResult mr = found.removeFirst();\n+        Asserts.assertTrue(mr.group(1).equals(boolToInt(expected.marked)), \"Expected that region was \" + (expected.marked ? \"\" : \"not \") + \" marked but is \" + mr.group());\n+        Asserts.assertTrue(mr.group(2).equals(boolToInt(expected.candidate)), \"Expected that region was \" + (expected.candidate ? \"\" : \"not \") + \" candidate but is \" + mr.group());\n+\n+        boolean reclaimed = Pattern.compile(\"Reclaimed humongous region .*\").matcher(log).find();\n+        Asserts.assertTrue(expected.reclaimed == reclaimed, \"Wrong log output reclaiming humongous region\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Tests checking eager reclaim for when the object is allocated before mark start.\");\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.MARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.MARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.MARKED_CANDIDATE_NOT_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.MARKED_CANDIDATE_NOT_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.MARKED_NOTCANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.MARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.MARKED_NOTCANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.MARKED_CANDIDATE_NOT_RECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.BEFORE_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+\n+        System.out.println(\"Tests checking eager reclaim for when the object is allocated after mark start.\");\n+        \/\/ These must not be marked (as they were allocated after mark start), and they are always candidates. Reclamation depends on whether there is a reference.\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.TYPE_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.DROP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_RECLAIMED);\n+\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.BEFORE_MARKING_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_REBUILD_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n+        runTest(ObjectType.OBJ_ARRAY, ReferencePolicy.KEEP, AllocationTiming.AFTER_MARK_START, WB.G1_BEFORE_CLEANUP_COMPLETED, ExpectedState.NOTMARKED_CANDIDATE_NOTRECLAIMED);\n@@ -81,1 +193,4 @@\n-public class TestEagerReclaimHumongousRegions {\n+class TestEagerReclaimHumongousRegionsClearMarkBitsRunner {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int M = 1024 * 1024;\n+\n@@ -83,15 +198,7 @@\n-        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-            \"-XX:+UseG1GC\",\n-            \"-Xms128M\",\n-            \"-Xmx128M\",\n-            \"-Xmn16M\",\n-            \"-Xlog:gc\",\n-            TestEagerReclaimHumongousRegionsReclaimRegionFast.class.getName());\n-\n-        Pattern p = Pattern.compile(\"Full GC\");\n-\n-        int found = 0;\n-        Matcher m = p.matcher(output.getStdout());\n-        while (m.find()) { found++; }\n-        System.out.println(\"Issued \" + found + \" Full GCs\");\n-        Asserts.assertLT(found, 10, \"Found that \" + found + \" Full GCs were issued. This is larger than the bound. Eager reclaim seems to not work at all\");\n+        if (args.length != 4) {\n+            throw new Exception(\"Invalid number of arguments \" + args.length);\n+        }\n+        boolean useTypeArray = Boolean.parseBoolean(args[0]);\n+        boolean keepReference = Boolean.parseBoolean(args[1]);\n+        boolean allocateAfter = Boolean.parseBoolean(args[2]);\n+        String phase = args[3];\n@@ -99,1 +206,25 @@\n-        output.shouldHaveExitValue(0);\n+        System.out.println(\"useTypeArray: \" + useTypeArray + \" keepReference: \" + keepReference + \" allocateAfter \" + allocateAfter + \" phase: \" + phase);\n+        WB.fullGC();\n+\n+        Object largeObj = null; \/\/ Allocated humongous object.\n+        if (!allocateAfter) {\n+          largeObj = useTypeArray ? new int[M] : new Object[M];\n+        }\n+\n+        WB.concurrentGCAcquireControl();\n+        WB.concurrentGCRunTo(phase);\n+\n+        System.out.println(\"Phase \" + phase + \" reached\");\n+\n+        if (allocateAfter) {\n+          largeObj = useTypeArray ? new int[M] : new Object[M];\n+        }\n+\n+        if (!keepReference) {\n+          largeObj = null;\n+        }\n+        WB.youngGC(); \/\/ May reclaim the humongous object.\n+\n+        WB.concurrentGCRunToIdle();\n+\n+        System.out.println(\"Large object at \" + largeObj); \/\/ Keepalive.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegions.java","additions":179,"deletions":48,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestEagerReclaimHumongousRegionsClearMarkBits\n- * @bug 8051973\n- * @summary Test to make sure that eager reclaim of humongous objects correctly clears\n- * mark bitmaps at reclaim.\n- * @requires vm.gc.G1\n- * @requires vm.debug\n- * @library \/test\/lib \/testlibrary \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run driver gc.g1.TestEagerReclaimHumongousRegionsClearMarkBits\n- *\/\n-\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class TestEagerReclaimHumongousRegionsClearMarkBits {\n-    public static void main(String[] args) throws Exception {\n-        OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UseG1GC\",\n-                                                                    \"-Xmx20M\",\n-                                                                    \"-Xms20m\",\n-                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                    \"-XX:+VerifyAfterGC\",\n-                                                                    \"-Xbootclasspath\/a:.\",\n-                                                                    \"-Xlog:gc=debug,gc+humongous=debug\",\n-                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                    \"-XX:+WhiteBoxAPI\",\n-                                                                    TestEagerReclaimHumongousRegionsClearMarkBitsRunner.class.getName());\n-\n-        String log = output.getStdout();\n-        System.out.println(log);\n-        output.shouldHaveExitValue(0);\n-\n-        \/\/ Find the log output indicating that the humongous object has been reclaimed, and marked.\n-        Pattern pattern = Pattern.compile(\"Humongous region .* marked 1 .* reclaim candidate 1 type array 1\");\n-        Asserts.assertTrue(pattern.matcher(log).find(), \"Could not find log output matching marked humongous region.\");\n-\n-        pattern = Pattern.compile(\"Reclaimed humongous region .*\");\n-        Asserts.assertTrue(pattern.matcher(log).find(), \"Could not find log output reclaiming humongous region\");\n-    }\n-}\n-\n-class TestEagerReclaimHumongousRegionsClearMarkBitsRunner {\n-    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n-    private static final int M = 1024 * 1024;\n-\n-    public static void main(String[] args) {\n-        WB.fullGC();\n-\n-        Object largeObj = new int[M]; \/\/ Humongous object.\n-\n-        WB.concurrentGCAcquireControl();\n-        WB.concurrentGCRunTo(WB.BEFORE_MARKING_COMPLETED);\n-\n-        System.out.println(\"Large object at \" + largeObj);\n-\n-        largeObj = null;\n-        WB.youngGC(); \/\/ Should reclaim marked humongous object.\n-\n-        WB.concurrentGCRunToIdle();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEagerReclaimHumongousRegionsClearMarkBits.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}