{"files":[{"patch":"@@ -574,0 +574,4 @@\n+     * <p>\n+     * The returned method handle throws {@link IndexOutOfBoundsException} if the provided layout path has an open\n+     * path element whose size is {@code S}, and its corresponding trailing {@code long} parameter\n+     * has a value {@code I} such that {@code I >= S} or {@code I < 0}.\n@@ -612,1 +616,1 @@\n-     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(B, I1, I2, ... In);\n@@ -731,1 +735,1 @@\n-     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n@@ -841,1 +845,2 @@\n-     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>.\n+     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>. The <em>size<\/em>\n+     * of an open path element determines the number of element layouts that can be selected by it.\n@@ -909,0 +914,1 @@\n+         * That is, the size of the returned open path element is {@code B}.\n@@ -927,1 +933,1 @@\n-         * {@code 0 <= I < C}.\n+         * {@code 0 <= I < C}. That is, {@code C} is the size of the returned open path element.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -314,0 +316,18 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testOffsetHandleOOBIndex(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedByteOffset) throws Throwable {\n+        int[] badIndices = { -1, 10 };\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(badIndices[1], layout);\n+        for (int badIndex : badIndices) {\n+            PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+            long[] seqIndexes = new long[indexes.length + 1];\n+            System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+            System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+            seqPathElements[0] = PathElement.sequenceElement();\n+            seqIndexes[0] = badIndex;\n+            MethodHandle seqByteOffsetHandle = seqLayout.byteOffsetHandle(seqPathElements)\n+                    .asSpreader(long[].class, seqIndexes.length);\n+            assertThrows(IndexOutOfBoundsException.class, () -> seqByteOffsetHandle.invoke(0L, seqIndexes));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}