{"files":[{"patch":"@@ -574,0 +574,4 @@\n+     * <p>\n+     * For any given dynamic argument {@code x_i}, it must be that {@code 0 <= x_i < size_i},\n+     * where {@code size_i} is the size of the open path element associated with {@code x_i}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n@@ -612,1 +616,1 @@\n-     * O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(B, I1, I2, ... In);\n@@ -630,0 +634,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -731,1 +738,1 @@\n-     * O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n+     * O = this.byteOffsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);\n@@ -734,1 +741,1 @@\n-     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)},\n+     * More formally, the method handle returned by this method is obtained from {@link #varHandle(PathElement...)},\n@@ -739,0 +746,29 @@\n+     * <p>\n+     * Accessing a memory segment using the var handle returned by this method is subject\n+     * to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside\n+     *     the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n+     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n+     *     accessed memory segment.<\/li>\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n+     *     <li>The accessed memory segment must be\n+     *     {@link MemorySegment#isAccessibleBy(Thread) accessible} from the thread\n+     *     performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>For write operations, the accessed memory segment must not be\n+     *     {@link MemorySegment#isReadOnly() read only}, or an\n+     *     {@link IllegalArgumentException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed\n+     *     segment must be {@linkplain MemorySegment.Scope#isAlive() alive}, or an\n+     *     {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -795,0 +831,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 <= I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -841,1 +880,2 @@\n-     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>.\n+     * <a href=\"MemoryLayout.html#open-path-elements\">open path elements<\/a>. The <em>size<\/em>\n+     * of an open path element determines the number of element layouts that can be selected by it.\n@@ -909,0 +949,1 @@\n+         * That is, the size of the returned open path element is {@code B}.\n@@ -927,1 +968,1 @@\n-         * {@code 0 <= I < C}.\n+         * {@code 0 <= I < C}. That is, {@code C} is the size of the returned open path element.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -41,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -314,0 +316,18 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testOffsetHandleOOBIndex(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                 long expectedByteOffset) throws Throwable {\n+        int[] badIndices = { -1, 10 };\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(badIndices[1], layout);\n+        for (int badIndex : badIndices) {\n+            PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+            long[] seqIndexes = new long[indexes.length + 1];\n+            System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+            System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+            seqPathElements[0] = PathElement.sequenceElement();\n+            seqIndexes[0] = badIndex;\n+            MethodHandle seqByteOffsetHandle = seqLayout.byteOffsetHandle(seqPathElements)\n+                    .asSpreader(long[].class, seqIndexes.length);\n+            assertThrows(IndexOutOfBoundsException.class, () -> seqByteOffsetHandle.invoke(0L, seqIndexes));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"}]}