{"files":[{"patch":"@@ -634,0 +634,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 < I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n@@ -738,1 +741,1 @@\n-     * More formally, this method can be obtained from the {@link #varHandle(PathElement...)},\n+     * More formally, the method handle returned by this method is obtained from {@link #varHandle(PathElement...)},\n@@ -743,0 +746,29 @@\n+     * <p>\n+     * Accessing a memory segment using the var handle returned by this method is subject\n+     * to the following checks:\n+     * <ul>\n+     *     <li>The physical address of the accessed memory segment must be\n+     *     <a href=\"MemorySegment.html#segment-alignment\">aligned<\/a> according to the\n+     *     {@linkplain #byteAlignment() alignment constraint} of the root layout\n+     *     (this layout), or an {@link IllegalArgumentException} is thrown. Note\n+     *     that the alignment constraint of the root layout can be more strict\n+     *     (but not less) than the alignment constraint of the selected value layout.<\/li>\n+     *     <li>The offset of the access operation (computed as above) must fall inside\n+     *     the spatial bounds of the accessed memory segment, or an\n+     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n+     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n+     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n+     *     accessed memory segment.<\/li>\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 < I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n+     *     <li>The accessed memory segment must be\n+     *     {@link MemorySegment#isAccessibleBy(Thread) accessible} from the thread\n+     *     performing the access operation, or a {@link WrongThreadException} is thrown.<\/li>\n+     *     <li>For write operations, the accessed memory segment must not be\n+     *     {@link MemorySegment#isReadOnly() read only}, or an\n+     *     {@link IllegalArgumentException} is thrown.<\/li>\n+     *     <li>The {@linkplain MemorySegment#scope() scope} associated with the accessed\n+     *     segment must be {@linkplain MemorySegment.Scope#isAlive() alive}, or an\n+     *     {@link IllegalStateException} is thrown.<\/li>\n+     * <\/ul>\n@@ -799,0 +831,3 @@\n+     *     <li>If the provided layout path has an open path element whose size is {@code S},\n+     *     its corresponding trailing {@code long} coordinate value {@code I} must be\n+     *     {@code 0 < I < S}, or an {@link IndexOutOfBoundsException} is thrown.<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}