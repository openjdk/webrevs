{"files":[{"patch":"@@ -636,3 +636,0 @@\n-com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java                     8039280 generic-all\n-com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java            8039280 generic-all\n-com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java              8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -634,3 +634,0 @@\n-    com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java \\\n-    com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4634892\n- * @summary Ensure authentication via GSS-API\/Kerberos v5 works.\n- * @run main\/manual AuthOnly\n- *\/\n-\n-\/*\n- * Set logging to FINEST to view exchange.\n- * See runwjaas.csh for instructions for how to run this test.\n- *\/\n-\n-import javax.security.sasl.*;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.Subject;\n-import javax.security.auth.login.*;\n-import com.sun.security.auth.callback.*;\n-import java.util.HashMap;\n-import java.util.concurrent.Callable;\n-\n-public class AuthOnly {\n-    private static final String MECH = \"GSSAPI\";\n-    private static final String SERVER_FQDN = \"machineX.imc.org\";\n-    private static final String PROTOCOL = \"sample\";\n-\n-    private static String namesfile, proxyfile;\n-    private static final byte[] EMPTY = new byte[0];\n-    private static boolean auto;\n-    private static boolean verbose = false;\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            namesfile = null;\n-            auto = true;\n-        } else {\n-            int i = 0;\n-            if (args[i].equals(\"-m\")) {\n-                i++;\n-                auto = false;\n-            }\n-            if (args.length > i) {\n-                namesfile = args[i++];\n-                if (args.length > i) {\n-                    proxyfile = args[i];\n-                }\n-            } else {\n-                namesfile = null;\n-            }\n-        }\n-\n-        CallbackHandler clntCbh = null;\n-        final CallbackHandler srvCbh = new PropertiesFileCallbackHandler(\n-            null, namesfile, proxyfile);\n-\n-        Subject clntSubj = doLogin(\"client\");\n-        Subject srvSubj = doLogin(\"server\");\n-        final HashMap clntprops = new HashMap();\n-        final HashMap srvprops = new HashMap();\n-\n-        clntprops.put(Sasl.QOP, \"auth\");\n-        srvprops.put(Sasl.QOP, \"auth,auth-int,auth-conf\");\n-\n-        final SaslClient clnt = (SaslClient)\n-            Subject.callAs(clntSubj, new Callable<>() {\n-                public Object call() throws Exception {\n-                    return Sasl.createSaslClient(\n-                        new String[]{MECH}, null, PROTOCOL, SERVER_FQDN,\n-                        clntprops, null);\n-                }\n-            });\n-\n-        if (verbose) {\n-            System.out.println(clntSubj);\n-            System.out.println(srvSubj);\n-        }\n-        final SaslServer srv = (SaslServer)\n-            Subject.callAs(srvSubj, new Callable<Object>() {\n-                public Object call() throws Exception {\n-                    return Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n-                        srvprops, srvCbh);\n-                }\n-            });\n-\n-\n-        if (clnt == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find client impl for \" + MECH);\n-        }\n-        if (srv == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find server impl for \" + MECH);\n-        }\n-\n-        byte[] response;\n-        byte[] challenge;\n-\n-        response = (byte[]) Subject.callAs(clntSubj,\n-                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n-\n-        while (!clnt.isComplete() || !srv.isComplete()) {\n-            final byte[] responseCopy = response;\n-            challenge = (byte[]) Subject.callAs(srvSubj,\n-                    () -> srv.evaluateResponse(responseCopy));\n-\n-            if (challenge != null) {\n-                final byte[] challengeCopy = challenge;\n-                response = (byte[]) Subject.callAs(clntSubj,\n-                        () -> clnt.evaluateChallenge(challengeCopy));\n-            }\n-        }\n-\n-        if (clnt.isComplete() && srv.isComplete()) {\n-            if (verbose) {\n-                System.out.println(\"SUCCESS\");\n-                System.out.println(\"authzid is \" + srv.getAuthorizationID());\n-            }\n-        } else {\n-            throw new IllegalStateException(\"FAILURE: mismatched state:\" +\n-                \" client complete? \" + clnt.isComplete() +\n-                \" server complete? \" + srv.isComplete());\n-        }\n-    }\n-\n-    private static Subject doLogin(String msg) throws LoginException {\n-        LoginContext lc = null;\n-        if (verbose) {\n-            System.out.println(msg);\n-        }\n-        try {\n-            lc = new LoginContext(msg, new TextCallbackHandler());\n-\n-            \/\/ Attempt authentication\n-            \/\/ You might want to do this in a \"for\" loop to give\n-            \/\/ user more than one chance to enter correct username\/password\n-            lc.login();\n-\n-        } catch (LoginException le) {\n-            throw le;\n-        }\n-        return lc.getSubject();\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/AuthOnly.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,196 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 5014493\n- * @summary SaslServer.wrap throws NullPointerException when security\n- *    layer negotiated.\n- * @run main\/manual ConfSecurityLayer\n- *\/\n-\n-\/*\n- * Set logging to FINEST to view exchange.\n- * See run-conf-wjaas.csh for instructions for how to run this test.\n- *\/\n-\n-import javax.security.sasl.*;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.Subject;\n-import javax.security.auth.login.*;\n-import com.sun.security.auth.callback.*;\n-import java.util.HashMap;\n-\n-public class ConfSecurityLayer {\n-    private static final String MECH = \"GSSAPI\";\n-    private static final String SERVER_FQDN = \"machineX.imc.org\";\n-    private static final String PROTOCOL = \"sample\";\n-\n-    private static String namesfile, proxyfile;\n-    private static final byte[] EMPTY = new byte[0];\n-    private static boolean auto;\n-    private static boolean verbose = false;\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            namesfile = null;\n-            auto = true;\n-        } else {\n-            int i = 0;\n-            if (args[i].equals(\"-m\")) {\n-                i++;\n-                auto = false;\n-            }\n-            if (args.length > i) {\n-                namesfile = args[i++];\n-                if (args.length > i) {\n-                    proxyfile = args[i];\n-                }\n-            } else {\n-                namesfile = null;\n-            }\n-        }\n-\n-        CallbackHandler clntCbh = null;\n-        final CallbackHandler srvCbh = new PropertiesFileCallbackHandler(\n-            null, namesfile, proxyfile);\n-\n-        Subject clntSubj = doLogin(\"client\");\n-        Subject srvSubj = doLogin(\"server\");\n-        final HashMap clntprops = new HashMap();\n-        final HashMap srvprops = new HashMap();\n-\n-        clntprops.put(Sasl.QOP, \"auth-conf\");\n-        srvprops.put(Sasl.QOP, \"auth,auth-int,auth-conf\");\n-\n-        final SaslClient clnt = (SaslClient)\n-            Subject.callAs(clntSubj, () ->Sasl.createSaslClient(\n-                        new String[]{MECH}, null, PROTOCOL, SERVER_FQDN,\n-                        clntprops, null));\n-\n-        if (verbose) {\n-            System.out.println(clntSubj);\n-            System.out.println(srvSubj);\n-        }\n-        final SaslServer srv = (SaslServer)\n-            Subject.callAs(srvSubj, () ->\n-                    Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n-                        srvprops, srvCbh));\n-\n-\n-        if (clnt == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find client impl for \" + MECH);\n-        }\n-        if (srv == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find server impl for \" + MECH);\n-        }\n-\n-        byte[] response;\n-        byte[] challenge;\n-\n-        response = Subject.callAs(clntSubj,\n-                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n-\n-        while (!clnt.isComplete() || !srv.isComplete()) {\n-            final byte[] responseCopy = response;\n-            challenge = Subject.callAs(srvSubj,\n-                    () -> srv.evaluateResponse(responseCopy));\n-\n-            if (challenge != null) {\n-                final byte[] challengeCopy = challenge;\n-                response = Subject.callAs(clntSubj,\n-                        () -> clnt.evaluateChallenge(challengeCopy));\n-            }\n-        }\n-\n-        if (clnt.isComplete() && srv.isComplete()) {\n-            if (verbose) {\n-                System.out.println(\"SUCCESS\");\n-                System.out.println(\"authzid is \" + srv.getAuthorizationID());\n-            }\n-        } else {\n-            throw new IllegalStateException(\"FAILURE: mismatched state:\" +\n-                \" client complete? \" + clnt.isComplete() +\n-                \" server complete? \" + srv.isComplete());\n-        }\n-\n-        if (verbose) {\n-            System.out.println(clnt.getNegotiatedProperty(Sasl.QOP));\n-        }\n-\n-        \/\/ Now try to use security layer\n-\n-        byte[] clntBuf = new byte[]{0, 1, 2, 3};\n-        byte[] wrappedClnt = clnt.wrap(clntBuf, 0, clntBuf.length);\n-        System.out.println(\"plaintext2: \" + bytesToString(clntBuf));\n-        System.out.println(\"wrapped2: \" + bytesToString(wrappedClnt));\n-\n-        byte[] srvBuf = new byte[]{10, 11, 12, 13};\n-        byte[] wrappedSrv = srv.wrap(srvBuf, 0, srvBuf.length);\n-        System.out.println(\"plaintext1: \" + bytesToString(srvBuf));\n-        System.out.println(\"wrapped1: \" + bytesToString(wrappedSrv));\n-\n-        byte[] unwrapped1 = clnt.unwrap(wrappedSrv, 0, wrappedSrv.length);\n-        System.out.println(\"unwrapped1: \" + bytesToString(unwrapped1));\n-\n-        byte[] unwrapped2 = srv.unwrap(wrappedClnt, 0, wrappedClnt.length);\n-        System.out.println(\"unwrapped2: \" + bytesToString(unwrapped2));\n-    }\n-\n-    private static Subject doLogin(String msg) throws LoginException {\n-        LoginContext lc = null;\n-        if (verbose) {\n-            System.out.println(msg);\n-        }\n-        try {\n-            lc = new LoginContext(msg, new TextCallbackHandler());\n-\n-            \/\/ Attempt authentication\n-            \/\/ You might want to do this in a \"for\" loop to give\n-            \/\/ user more than one chance to enter correct username\/password\n-            lc.login();\n-\n-        } catch (LoginException le) {\n-            throw le;\n-        }\n-        return lc.getSubject();\n-    }\n-\n-    private static String bytesToString(byte[] digest) {\n-        \/\/ Get character representation of digest\n-        StringBuffer digestString = new StringBuffer();\n-\n-        for (int i = 0; i < digest.length; i++) {\n-            if ((digest[i] & 0x000000ff) < 0x10) {\n-                digestString.append(\"0\" +\n-                    Integer.toHexString(digest[i] & 0x000000ff));\n-            } else {\n-                digestString.append(\n-                    Integer.toHexString(digest[i] & 0x000000ff));\n-            }\n-        }\n-        return digestString.toString();\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/ConfSecurityLayer.java","additions":0,"deletions":196,"binary":false,"changes":196,"status":"deleted"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4873552\n- * @summary GSS-API\/krb5 SASL mechanism should throw IllegalStateException\n- *     for auth-only\n- * @run main\/manual NoSecurityLayer\n- *\/\n-\n-\/*\n- * Set logging to FINEST to view exchange.\n- * See run-nosec-wjaas.csh for instructions for how to run this test.\n- *\/\n-\n-import javax.security.sasl.*;\n-import javax.security.auth.callback.*;\n-import javax.security.auth.Subject;\n-import javax.security.auth.login.*;\n-import com.sun.security.auth.callback.*;\n-import java.util.HashMap;\n-\n-public class NoSecurityLayer {\n-    private static final String MECH = \"GSSAPI\";\n-    private static final String SERVER_FQDN = \"anti.imc.org\";\n-    private static final String PROTOCOL = \"sample\";\n-\n-    private static String namesfile, proxyfile;\n-    private static final byte[] EMPTY = new byte[0];\n-    private static boolean auto;\n-    private static boolean verbose = false;\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            namesfile = null;\n-            auto = true;\n-        } else {\n-            int i = 0;\n-            if (args[i].equals(\"-m\")) {\n-                i++;\n-                auto = false;\n-            }\n-            if (args.length > i) {\n-                namesfile = args[i++];\n-                if (args.length > i) {\n-                    proxyfile = args[i];\n-                }\n-            } else {\n-                namesfile = null;\n-            }\n-        }\n-\n-        CallbackHandler clntCbh = null;\n-        final CallbackHandler srvCbh = new PropertiesFileCallbackHandler(\n-            null, namesfile, proxyfile);\n-\n-        Subject clntSubj = doLogin(\"client\");\n-        Subject srvSubj = doLogin(\"server\");\n-        final HashMap clntprops = new HashMap();\n-        final HashMap srvprops = new HashMap();\n-\n-        clntprops.put(Sasl.QOP, \"auth\");\n-        srvprops.put(Sasl.QOP, \"auth,auth-int,auth-conf\");\n-\n-        final SaslClient clnt =\n-            Subject.callAs(clntSubj, () ->\n-                    Sasl.createSaslClient(\n-                        new String[]{MECH}, null, PROTOCOL, SERVER_FQDN,\n-                        clntprops, null));\n-\n-        if (verbose) {\n-            System.out.println(clntSubj);\n-            System.out.println(srvSubj);\n-        }\n-        final SaslServer srv =\n-            Subject.callAs(srvSubj, () ->\n-                Sasl.createSaslServer(MECH, PROTOCOL, SERVER_FQDN,\n-                        srvprops, srvCbh));\n-\n-\n-        if (clnt == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find client impl for \" + MECH);\n-        }\n-        if (srv == null) {\n-            throw new IllegalStateException(\n-                \"Unable to find server impl for \" + MECH);\n-        }\n-\n-        byte[] response;\n-        byte[] challenge;\n-\n-        response = Subject.callAs(clntSubj,\n-                () -> (clnt.hasInitialResponse()? clnt.evaluateChallenge(EMPTY) : EMPTY));\n-\n-        while (!clnt.isComplete() || !srv.isComplete()) {\n-            final byte[] responseCopy = response;\n-            challenge = Subject.callAs(srvSubj,\n-                    () -> srv.evaluateResponse(responseCopy));\n-\n-            if (challenge != null) {\n-                final byte[] challengeCopy = challenge;\n-                response = Subject.callAs(clntSubj,\n-                        () -> clnt.evaluateChallenge(challengeCopy));\n-            }\n-        }\n-\n-        if (clnt.isComplete() && srv.isComplete()) {\n-            if (verbose) {\n-                System.out.println(\"SUCCESS\");\n-                System.out.println(\"authzid is \" + srv.getAuthorizationID());\n-            }\n-        } else {\n-            throw new IllegalStateException(\"FAILURE: mismatched state:\" +\n-                \" client complete? \" + clnt.isComplete() +\n-                \" server complete? \" + srv.isComplete());\n-        }\n-\n-        if (verbose) {\n-            System.out.println(clnt.getNegotiatedProperty(Sasl.QOP));\n-        }\n-\n-        \/\/ Now try to use security layer\n-\n-        byte[] clntBuf = new byte[]{0, 1, 2, 3};\n-        try {\n-            byte[] wrapped = clnt.wrap(clntBuf, 0, clntBuf.length);\n-            throw new Exception(\n-                \"clnt wrap should not be allowed w\/no security layer\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected\n-        }\n-\n-        byte[] srvBuf = new byte[]{10, 11, 12, 13};\n-        try {\n-            byte[] wrapped = srv.wrap(srvBuf, 0, srvBuf.length);\n-            throw new Exception(\n-                \"srv wrap should not be allowed w\/no security layer\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected\n-        }\n-\n-        try {\n-            byte[] unwrapped = clnt.unwrap(clntBuf, 0, clntBuf.length);\n-            throw new Exception(\n-                \"clnt wrap should not be allowed w\/no security layer\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected\n-        }\n-\n-        try {\n-            byte[] unwrapped = srv.unwrap(srvBuf, 0, srvBuf.length);\n-            throw new Exception(\n-                \"srv wrap should not be allowed w\/no security layer\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static Subject doLogin(String msg) throws LoginException {\n-        LoginContext lc = null;\n-        if (verbose) {\n-            System.out.println(msg);\n-        }\n-        try {\n-            lc = new LoginContext(msg, new TextCallbackHandler());\n-\n-            \/\/ Attempt authentication\n-            \/\/ You might want to do this in a \"for\" loop to give\n-            \/\/ user more than one chance to enter correct username\/password\n-            lc.login();\n-\n-        } catch (LoginException le) {\n-            throw le;\n-        }\n-        return lc.getSubject();\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/NoSecurityLayer.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import javax.security.auth.callback.*;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.io.*;\n-import javax.security.sasl.AuthorizeCallback;\n-import javax.security.sasl.RealmCallback;\n-\n-public final class PropertiesFileCallbackHandler implements CallbackHandler {\n-    private Properties pwDb, namesDb, proxyDb;\n-\n-    \/**\n-     * Contents of files are in the Properties file format.\n-     *\n-     * @param pwFile name of file containing name\/password pairs\n-     * @param namesFile name of file containing name to canonicalized name\n-     * @param proxyFile name of file containing authname to list of authzids\n-     *\/\n-    public PropertiesFileCallbackHandler(String pwFile, String namesFile,\n-        String proxyFile) throws IOException {\n-        String dir = System.getProperty(\"test.src\");\n-        if (dir == null) {\n-            dir = \".\";\n-        }\n-        dir = dir + \"\/\";\n-\n-        if (pwFile != null) {\n-            pwDb = new Properties();\n-            pwDb.load(new FileInputStream(dir+pwFile));\n-        }\n-\n-        if (namesFile != null) {\n-            namesDb = new Properties();\n-            namesDb.load(new FileInputStream(dir+namesFile));\n-        }\n-\n-        if (proxyFile != null) {\n-            proxyDb = new Properties();\n-            proxyDb.load(new FileInputStream(dir+proxyFile));\n-        }\n-    }\n-\n-    public void handle(Callback[] callbacks)\n-        throws UnsupportedCallbackException {\n-        NameCallback ncb = null;\n-        PasswordCallback pcb = null;\n-        AuthorizeCallback acb = null;\n-        RealmCallback rcb = null;\n-\n-        for (int i = 0; i < callbacks.length; i++) {\n-            if (callbacks[i] instanceof NameCallback) {\n-                ncb = (NameCallback) callbacks[i];\n-            } else if (callbacks[i] instanceof PasswordCallback) {\n-                pcb = (PasswordCallback) callbacks[i];\n-            } else if (callbacks[i] instanceof AuthorizeCallback) {\n-                acb = (AuthorizeCallback) callbacks[i];\n-            } else if (callbacks[i] instanceof RealmCallback) {\n-                rcb = (RealmCallback) callbacks[i];\n-            } else {\n-                throw new UnsupportedCallbackException(callbacks[i]);\n-            }\n-        }\n-\n-        \/\/ Process retrieval of password; can get password iff\n-        \/\/ username is available in NameCallback\n-        \/\/\n-        \/\/ Ignore realm for now; could potentially use different dbs for\n-        \/\/ different realms\n-\n-        if (pcb != null && ncb != null) {\n-            String username = ncb.getDefaultName();\n-            String pw = pwDb.getProperty(username);\n-            if (pw != null) {\n-                char[] pwchars = pw.toCharArray();\n-                pcb.setPassword(pwchars);\n-                \/\/ Clear pw\n-                for (int i = 0; i <pwchars.length; i++) {\n-                    pwchars[i] = 0;\n-                }\n-\n-                \/\/ Set canonicalized username if any\n-                String canonAuthid =\n-                    (namesDb != null? namesDb.getProperty(username) : null);\n-                if (canonAuthid != null) {\n-                    ncb.setName(canonAuthid);\n-                }\n-            }\n-        }\n-\n-        \/\/ Check for authorization\n-\n-        \/\/ Ignore realm for now; could potentially use different dbs for\n-        \/\/ different realms\n-\n-        if (acb != null) {\n-            String authid = acb.getAuthenticationID();\n-            String authzid = acb.getAuthorizationID();\n-            if (authid.equals(authzid)) {\n-                \/\/ Self is always authorized\n-                acb.setAuthorized(true);\n-\n-            } else {\n-                \/\/ Check db for allowed authzids\n-                String authzes = (proxyDb != null ? proxyDb.getProperty(authid)\n-                    : null);\n-                if (authzes != null && authzes.indexOf(authzid) >= 0) {\n-                    \/\/ XXX need to search for subtrings or use StringTokenizer\n-                    \/\/ to avoid incorrectly matching subnames\n-                    acb.setAuthorized(true);\n-                }\n-            }\n-\n-            if (acb.isAuthorized()) {\n-                \/\/ Set canonicalized name\n-                String canonAuthzid = (namesDb != null ?\n-                    namesDb.getProperty(authzid) : null);\n-                if (canonAuthzid != null) {\n-                    acb.setAuthorizedID(canonAuthzid);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/PropertiesFileCallbackHandler.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,21 +0,0 @@\n-\/** \n- * Login Configuration for JAAS. \n- *\n- * Specify that Kerberos v5 is a required login module for the \n- * example classes: GssExample and Mutual.\n- *\/\n-other {\n-  com.sun.security.auth.module.Krb5LoginModule required;\n-};\n-\n-client {\n-  com.sun.security.auth.module.Krb5LoginModule required\n-\tprincipal=\"john@IMC.ORG\";\n-};\n-server {\n-  com.sun.security.auth.module.Krb5LoginModule required storeKey=true\n-\tprincipal=\"sample\/machineX.imc.org@IMC.ORG\" \n-\tuseKeyTab=true\n-\tkeyTab=machineX.keytab;\n-};\n-\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/gsseg_jaas.conf","additions":0,"deletions":21,"binary":false,"changes":21,"status":"deleted"},{"patch":"@@ -1,3 +0,0 @@\n-javax.security.sasl.level=FINE\n-#handlers=java.util.logging.ConsoleHandler\n-#java.util.logging.ConsoleHandler.level=FINE\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/log.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-#!\/bin\/csh -f\n-#\n-# @bug 5014493\n-# @summary SaslServer.wrap throws NullPointerException when security \n-#    layer negotiated\n-#\n-# BEFORE running this test, you need to set up the environment as follows.\n-# 1. Create a 'sample' service principal in the KDC.\n-# 2. Create a keytab for the server principal 'sample\/fqdn@REALM'\n-#    where 'fqdn' is the fully qualified domain name of the server and\n-#    REALM is the KDC's realm. The principal must be a host-based service.\n-#    For example, a principal name might be\n-#      'sample\/machineX.imc.org@IMC.ORG'. \n-#    On Windows, for example, you use the ktpass utility to create a host keytab \n-#    file.\n-#    c:> ktpass -princ sample\/machineX.imc.org@IMC.ORG -mapuser sample \\\n-#        -ptype KRB5_NT_SRV_HST \\\n-#        -pass servertest123 -out machineX.keytab\n-# 3. Create a user principal in the KDC.\n-# 4. Set up a JAAS login module configuration file like gsseg_jaas.conf, updating\n-#    the client and server entries according to the principal and machine names\n-#    used.\n-# 5. Update AuthOnly.SERVER_FQDN with fqdn of server machine.\n-# 6. To examine exchange, turn on logging by adding\n-#        -Djava.util.logging.config.file=log.properties\n-# 7. Update the realm and kdc settings in this script.\n-#\n-#\n-$JAVA_HOME\/bin\/java -Djava.security.krb5.realm=IMC.ORG -Djava.security.krb5.kdc=machineX.imc.org -Djava.security.auth.login.config=gsseg_jaas.conf  ConfSecurityLayer\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/run-conf-wjaas.csh","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-#!\/bin\/csh -f\n-#\n-# BEFORE running this test, you need to set up the environment as follows.\n-# 1. Create a 'sample' service principal in the KDC.\n-# 2. Create a keytab for the server principal 'sample\/fqdn@REALM'\n-#    where 'fqdn' is the fully qualified domain name of the server and\n-#    REALM is the KDC's realm. The principal must be a host-based service.\n-#    For example, a principal name might be\n-#      'sample\/machineX.imc.org@IMC.ORG'. \n-#    On Windows, for example, you use the ktpass utility to create a host keytab \n-#    file.\n-#    c:> ktpass -princ sample\/machineX.imc.org@IMC.ORG -mapuser sample \\\n-#        -ptype KRB5_NT_SRV_HST \\\n-#        -pass servertest123 -out machineX.keytab\n-# 3. Create a user principal in the KDC.\n-# 4. Set up a JAAS login module configuration file like gsseg_jaas.conf, updating\n-#    the client and server entries according to the principal and machine names\n-#    used.\n-# 5. Update AuthOnly.SERVER_FQDN with fqdn of server machine.\n-# 6. To examine exchange, turn on logging by adding\n-#        -Djava.util.logging.config.file=log.properties\n-# 7. Update the realm and kdc settings in this script.\n-#\n-java -Djava.security.krb5.realm=IMC.ORG -Djava.security.krb5.kdc=machineX.imc.org -Djava.security.auth.login.config=gsseg_jaas.conf  NoSecurityLayer\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/run-nosec-wjaas.csh","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-#!\/bin\/csh -f\n-#\n-# BEFORE running this test, you need to set up the environment as follows.\n-# 1. Create a 'sample' service principal in the KDC.\n-# 2. Create a keytab for the server principal 'sample\/fqdn@REALM'\n-#    where 'fqdn' is the fully qualified domain name of the server and\n-#    REALM is the KDC's realm. The principal must be a host-based service.\n-#    For example, a principal name might be\n-#      'sample\/machineX.imc.org@IMC.ORG'. \n-#    On Windows, for example, you use the ktpass utility to create a host keytab \n-#    file.\n-#    c:> ktpass -princ sample\/machineX.imc.org@IMC.ORG -mapuser sample \\\n-#        -ptype KRB5_NT_SRV_HST \\\n-#        -pass servertest123 -out machineX.keytab\n-# 3. Create a user principal in the KDC.\n-# 4. Set up a JAAS login module configuration file like gsseg_jaas.conf, updating\n-#    the client and server entries according to the principal and machine names\n-#    used.\n-# 5. Update AuthOnly.SERVER_FQDN with fqdn of server machine.\n-# 6. To examine exchange, turn on logging by adding\n-#        -Djava.util.logging.config.file=log.properties\n-# 7. Update the realm and kdc settings in this script.\n-#\n-java -Djava.security.krb5.realm=IMC.ORG -Djava.security.krb5.kdc=machineX.imc.org -Djava.security.auth.login.config=gsseg_jaas.conf  AuthOnly\n","filename":"test\/jdk\/com\/sun\/security\/sasl\/gsskerb\/runwjaas.csh","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-import java.io.IOException;\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n@@ -39,2 +40,0 @@\n-import javax.security.auth.callback.CallbackHandler;\n-import javax.security.auth.callback.UnsupportedCallbackException;\n@@ -64,9 +63,6 @@\n-                new CallbackHandler() {\n-                    public void handle(Callback[] callbacks)\n-                            throws IOException, UnsupportedCallbackException {\n-                        for (Callback cb : callbacks) {\n-                            if (cb instanceof RealmCallback) {\n-                                ((RealmCallback) cb).setText(OneKDC.REALM);\n-                            } else if (cb instanceof AuthorizeCallback) {\n-                                ((AuthorizeCallback) cb).setAuthorized(true);\n-                            }\n+                callbacks -> {\n+                    for (Callback cb : callbacks) {\n+                        if (cb instanceof RealmCallback) {\n+                            ((RealmCallback) cb).setText(OneKDC.REALM);\n+                        } else if (cb instanceof AuthorizeCallback) {\n+                            ((AuthorizeCallback) cb).setAuthorized(true);\n@@ -92,1 +88,1 @@\n-                throw new Exception(\"Wrong bound server name\");\n+                throw new RuntimeException(\"Wrong bound server name\");\n@@ -98,1 +94,1 @@\n-            throw new Exception(\"Extended negotiated property not read\");\n+            throw new RuntimeException(\"Extended negotiated property not read\");\n@@ -105,1 +101,1 @@\n-                throw new Exception(\"maximum size for auth must be 0\");\n+                throw new RuntimeException(\"maximum size for auth must be 0\");\n@@ -107,0 +103,1 @@\n+            testWrapUnwrapNoSecLayer(sc, ss);\n@@ -108,6 +105,62 @@\n-            byte[] hello = \"hello\".getBytes();\n-            token = sc.wrap(hello, 0, hello.length);\n-            token = ss.unwrap(token, 0, token.length);\n-            if (!Arrays.equals(hello, token)) {\n-                throw new Exception(\"Message altered\");\n-            }\n+            testWrapUnwrapWithSecLayer(sc, ss);\n+        }\n+    }\n+\n+    private static void testWrapUnwrapWithSecLayer(SaslClient sc, SaslServer ss)\n+        throws SaslException {\n+        byte[] token;\n+        byte[] hello = \"hello\".getBytes();\n+\n+        \/\/ test client wrap and server unwrap\n+        token = sc.wrap(hello, 0, hello.length);\n+        token = ss.unwrap(token, 0, token.length);\n+\n+        if (!Arrays.equals(hello, token)) {\n+            throw new RuntimeException(\"Client message altered\");\n+        }\n+\n+        \/\/ test server wrap and client unwrap\n+        token = ss.wrap(hello, 0, hello.length);\n+        token = sc.unwrap(token, 0, token.length);\n+\n+        if (!Arrays.equals(hello, token)) {\n+            throw new RuntimeException(\"Server message altered\");\n+        }\n+    }\n+\n+    private static void testWrapUnwrapNoSecLayer(SaslClient sc, SaslServer ss)\n+        throws SaslException {\n+        byte[] clntBuf = new byte[]{0, 1, 2, 3};\n+        byte[] srvBuf = new byte[]{10, 11, 12, 13};\n+        String expectedError = \"No security layer negotiated\";\n+\n+        try {\n+            sc.wrap(clntBuf, 0, clntBuf.length);\n+            throw new RuntimeException(\n+                    \"client wrap should not be allowed w\/no security layer\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(expectedError, e.getMessage());\n+        }\n+\n+        try {\n+            ss.wrap(srvBuf, 0, srvBuf.length);\n+            throw new RuntimeException(\n+                    \"server wrap should not be allowed w\/no security layer\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(expectedError, e.getMessage());\n+        }\n+\n+        try {\n+            sc.unwrap(clntBuf, 0, clntBuf.length);\n+            throw new RuntimeException(\n+                    \"client unwrap should not be allowed w\/no security layer\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(expectedError, e.getMessage());\n+        }\n+\n+        try {\n+            ss.unwrap(srvBuf, 0, srvBuf.length);\n+            throw new RuntimeException(\n+                    \"server unwrap should not be allowed w\/no security layer\");\n+        } catch (IllegalStateException e) {\n+            assertEquals(expectedError, e.getMessage());\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/SaslBasic.java","additions":75,"deletions":22,"binary":false,"changes":97,"status":"modified"}]}