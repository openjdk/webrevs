{"files":[{"patch":"@@ -64,0 +64,650 @@\n+\/*\n+ * HPROF binary format - description copied from:\n+ *   src\/share\/demo\/jvmti\/hprof\/hprof_io.c\n+ *\n+ *\n+ *  header    \"JAVA PROFILE 1.0.2\" (0-terminated)\n+ *\n+ *  u4        size of identifiers. Identifiers are used to represent\n+ *            UTF8 strings, objects, stack traces, etc. They usually\n+ *            have the same size as host pointers.\n+ * u4         high word\n+ * u4         low word    number of milliseconds since 0:00 GMT, 1\/1\/70\n+ * [record]*  a sequence of records.\n+ *\n+ *\n+ * Record format:\n+ *\n+ * u1         a TAG denoting the type of the record\n+ * u4         number of *microseconds* since the time stamp in the\n+ *            header. (wraps around in a little more than an hour)\n+ * u4         number of bytes *remaining* in the record. Note that\n+ *            this number excludes the tag and the length field itself.\n+ * [u1]*      BODY of the record (a sequence of bytes)\n+ *\n+ *\n+ * The following TAGs are supported:\n+ *\n+ * TAG           BODY       notes\n+ *----------------------------------------------------------\n+ * HPROF_UTF8               a UTF8-encoded name\n+ *\n+ *               id         name ID\n+ *               [u1]*      UTF8 characters (no trailing zero)\n+ *\n+ * HPROF_LOAD_CLASS         a newly loaded class\n+ *\n+ *                u4        class serial number (> 0)\n+ *                id        class object ID\n+ *                u4        stack trace serial number\n+ *                id        class name ID\n+ *\n+ * HPROF_UNLOAD_CLASS       an unloading class\n+ *\n+ *                u4        class serial_number\n+ *\n+ * HPROF_FRAME              a Java stack frame\n+ *\n+ *                id        stack frame ID\n+ *                id        method name ID\n+ *                id        method signature ID\n+ *                id        source file name ID\n+ *                u4        class serial number\n+ *                i4        line number. >0: normal\n+ *                                       -1: unknown\n+ *                                       -2: compiled method\n+ *                                       -3: native method\n+ *\n+ * HPROF_TRACE              a Java stack trace\n+ *\n+ *               u4         stack trace serial number\n+ *               u4         thread serial number\n+ *               u4         number of frames\n+ *               [id]*      stack frame IDs\n+ *\n+ *\n+ * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC\n+ *\n+ *               u2         flags 0x0001: incremental vs. complete\n+ *                                0x0002: sorted by allocation vs. live\n+ *                                0x0004: whether to force a GC\n+ *               u4         cutoff ratio\n+ *               u4         total live bytes\n+ *               u4         total live instances\n+ *               u8         total bytes allocated\n+ *               u8         total instances allocated\n+ *               u4         number of sites that follow\n+ *               [u1        is_array: 0:  normal object\n+ *                                    2:  object array\n+ *                                    4:  boolean array\n+ *                                    5:  char array\n+ *                                    6:  float array\n+ *                                    7:  double array\n+ *                                    8:  byte array\n+ *                                    9:  short array\n+ *                                    10: int array\n+ *                                    11: long array\n+ *                u4        class serial number (may be zero during startup)\n+ *                u4        stack trace serial number\n+ *                u4        number of bytes alive\n+ *                u4        number of instances alive\n+ *                u4        number of bytes allocated\n+ *                u4]*      number of instance allocated\n+ *\n+ * HPROF_START_THREAD       a newly started thread.\n+ *\n+ *               u4         thread serial number (> 0)\n+ *               id         thread object ID\n+ *               u4         stack trace serial number\n+ *               id         thread name ID\n+ *               id         thread group name ID\n+ *               id         thread group parent name ID\n+ *\n+ * HPROF_END_THREAD         a terminating thread.\n+ *\n+ *               u4         thread serial number\n+ *\n+ * HPROF_HEAP_SUMMARY       heap summary\n+ *\n+ *               u4         total live bytes\n+ *               u4         total live instances\n+ *               u8         total bytes allocated\n+ *               u8         total instances allocated\n+ *\n+ * HPROF_HEAP_DUMP          denote a heap dump\n+ *\n+ *               [heap dump sub-records]*\n+ *\n+ *                          There are four kinds of heap dump sub-records:\n+ *\n+ *               u1         sub-record type\n+ *\n+ *               HPROF_GC_ROOT_UNKNOWN         unknown root\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_ROOT_THREAD_OBJ      thread object\n+ *\n+ *                          id         thread object ID  (may be 0 for a\n+ *                                     thread newly attached through JNI)\n+ *                          u4         thread sequence number\n+ *                          u4         stack trace sequence number\n+ *\n+ *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root\n+ *\n+ *                          id         object ID\n+ *                          id         JNI global ref ID\n+ *\n+ *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *                          u4         frame # in stack trace (-1 for empty)\n+ *\n+ *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *                          u4         frame # in stack trace (-1 for empty)\n+ *\n+ *               HPROF_GC_ROOT_NATIVE_STACK    Native stack\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *\n+ *               HPROF_GC_ROOT_STICKY_CLASS    System class\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block\n+ *\n+ *                          id         object ID\n+ *                          u4         thread serial number\n+ *\n+ *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor\n+ *\n+ *                          id         object ID\n+ *\n+ *               HPROF_GC_CLASS_DUMP           dump of a class object\n+ *\n+ *                          id         class object ID\n+ *                          u4         stack trace serial number\n+ *                          id         super class object ID\n+ *                          id         class loader object ID\n+ *                          id         signers object ID\n+ *                          id         protection domain object ID\n+ *                          id         reserved\n+ *                          id         reserved\n+ *\n+ *                          u4         instance size (in bytes)\n+ *\n+ *                          u2         size of constant pool\n+ *                          [u2,       constant pool index,\n+ *                           ty,       type\n+ *                                     2:  object\n+ *                                     4:  boolean\n+ *                                     5:  char\n+ *                                     6:  float\n+ *                                     7:  double\n+ *                                     8:  byte\n+ *                                     9:  short\n+ *                                     10: int\n+ *                                     11: long\n+ *                           vl]*      and value\n+ *\n+ *                          u2         number of static fields\n+ *                          [id,       static field name,\n+ *                           ty,       type,\n+ *                           vl]*      and value\n+ *\n+ *                          u2         number of inst. fields (not inc. super)\n+ *                          [id,       instance field name,\n+ *                           ty]*      type\n+ *\n+ *               HPROF_GC_INSTANCE_DUMP        dump of a normal object\n+ *\n+ *                          id         object ID\n+ *                          u4         stack trace serial number\n+ *                          id         class object ID\n+ *                          u4         number of bytes that follow\n+ *                          [vl]*      instance field values (class, followed\n+ *                                     by super, super's super ...)\n+ *\n+ *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array\n+ *\n+ *                          id         array object ID\n+ *                          u4         stack trace serial number\n+ *                          u4         number of elements\n+ *                          id         array class ID\n+ *                          [id]*      elements\n+ *\n+ *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array\n+ *\n+ *                          id         array object ID\n+ *                          u4         stack trace serial number\n+ *                          u4         number of elements\n+ *                          u1         element type\n+ *                                     4:  boolean array\n+ *                                     5:  char array\n+ *                                     6:  float array\n+ *                                     7:  double array\n+ *                                     8:  byte array\n+ *                                     9:  short array\n+ *                                     10: int array\n+ *                                     11: long array\n+ *                          [u1]*      elements\n+ *\n+ * HPROF_CPU_SAMPLES        a set of sample traces of running threads\n+ *\n+ *                u4        total number of samples\n+ *                u4        # of traces\n+ *               [u4        # of samples\n+ *                u4]*      stack trace serial number\n+ *\n+ * HPROF_CONTROL_SETTINGS   the settings of on\/off switches\n+ *\n+ *                u4        0x00000001: alloc traces on\/off\n+ *                          0x00000002: cpu sampling on\/off\n+ *                u2        stack trace depth\n+ *\n+ *\n+ * When the header is \"JAVA PROFILE 1.0.2\" a heap dump can optionally\n+ * be generated as a sequence of heap dump segments. This sequence is\n+ * terminated by an end record. The additional tags allowed by format\n+ * \"JAVA PROFILE 1.0.2\" are:\n+ *\n+ * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment\n+ *\n+ *               [heap dump sub-records]*\n+ *               The same sub-record types allowed by HPROF_HEAP_DUMP\n+ *\n+ * HPROF_HEAP_DUMP_END      denotes the end of a heap dump\n+ *\n+ *\/\n+\n+\n+\/\/ HPROF tags\n+\n+enum hprofTag : u1 {\n+  \/\/ top-level records\n+  HPROF_UTF8                    = 0x01,\n+  HPROF_LOAD_CLASS              = 0x02,\n+  HPROF_UNLOAD_CLASS            = 0x03,\n+  HPROF_FRAME                   = 0x04,\n+  HPROF_TRACE                   = 0x05,\n+  HPROF_ALLOC_SITES             = 0x06,\n+  HPROF_HEAP_SUMMARY            = 0x07,\n+  HPROF_START_THREAD            = 0x0A,\n+  HPROF_END_THREAD              = 0x0B,\n+  HPROF_HEAP_DUMP               = 0x0C,\n+  HPROF_CPU_SAMPLES             = 0x0D,\n+  HPROF_CONTROL_SETTINGS        = 0x0E,\n+\n+  \/\/ 1.0.2 record types\n+  HPROF_HEAP_DUMP_SEGMENT       = 0x1C,\n+  HPROF_HEAP_DUMP_END           = 0x2C,\n+\n+  \/\/ field types\n+  HPROF_ARRAY_OBJECT            = 0x01,\n+  HPROF_NORMAL_OBJECT           = 0x02,\n+  HPROF_BOOLEAN                 = 0x04,\n+  HPROF_CHAR                    = 0x05,\n+  HPROF_FLOAT                   = 0x06,\n+  HPROF_DOUBLE                  = 0x07,\n+  HPROF_BYTE                    = 0x08,\n+  HPROF_SHORT                   = 0x09,\n+  HPROF_INT                     = 0x0A,\n+  HPROF_LONG                    = 0x0B,\n+\n+  \/\/ data-dump sub-records\n+  HPROF_GC_ROOT_UNKNOWN         = 0xFF,\n+  HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,\n+  HPROF_GC_ROOT_JNI_LOCAL       = 0x02,\n+  HPROF_GC_ROOT_JAVA_FRAME      = 0x03,\n+  HPROF_GC_ROOT_NATIVE_STACK    = 0x04,\n+  HPROF_GC_ROOT_STICKY_CLASS    = 0x05,\n+  HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,\n+  HPROF_GC_ROOT_MONITOR_USED    = 0x07,\n+  HPROF_GC_ROOT_THREAD_OBJ      = 0x08,\n+  HPROF_GC_CLASS_DUMP           = 0x20,\n+  HPROF_GC_INSTANCE_DUMP        = 0x21,\n+  HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,\n+  HPROF_GC_PRIM_ARRAY_DUMP      = 0x23\n+};\n+\n+\/\/ Default stack trace ID (used for dummy HPROF_TRACE record)\n+enum {\n+  STACK_TRACE_ID = 1,\n+  INITIAL_CLASS_COUNT = 200\n+};\n+\n+\/\/ Base class for dump and parallel dump\n+class AbstractDumpWriter : public ResourceObj {\n+ protected:\n+  enum {\n+    io_buffer_max_size = 1*M,\n+    dump_segment_header_size = 9\n+  };\n+\n+  char* _buffer;    \/\/ internal buffer\n+  size_t _size;\n+  size_t _pos;\n+\n+  bool _in_dump_segment; \/\/ Are we currently in a dump segment?\n+  bool _is_huge_sub_record; \/\/ Are we writing a sub-record larger than the buffer size?\n+  DEBUG_ONLY(size_t _sub_record_left;) \/\/ The bytes not written for the current sub-record.\n+  DEBUG_ONLY(bool _sub_record_ended;) \/\/ True if we have called the end_sub_record().\n+\n+  char* buffer() const                          { return _buffer; }\n+  size_t buffer_size() const                    { return _size; }\n+  void set_position(size_t pos)                 { _pos = pos; }\n+\n+  \/\/ Can be called if we have enough room in the buffer.\n+  void write_fast(const void* s, size_t len);\n+\n+  \/\/ Returns true if we have enough room in the buffer for 'len' bytes.\n+  bool can_write_fast(size_t len);\n+\n+  void write_address(address a);\n+\n+ public:\n+  AbstractDumpWriter() :\n+    _buffer(nullptr),\n+    _size(io_buffer_max_size),\n+    _pos(0),\n+    _in_dump_segment(false) { }\n+\n+  size_t position() const                       { return _pos; }\n+  \/\/ writer functions\n+  virtual void write_raw(const void* s, size_t len);\n+  void write_u1(u1 x);\n+  void write_u2(u2 x);\n+  void write_u4(u4 x);\n+  void write_u8(u8 x);\n+  void write_objectID(oop o);\n+  void write_rootID(oop* p);\n+  void write_symbolID(Symbol* o);\n+  void write_classID(Klass* k);\n+  void write_id(u4 x);\n+\n+  \/\/ Start a new sub-record. Starts a new heap dump segment if needed.\n+  void start_sub_record(u1 tag, u4 len);\n+  \/\/ Ends the current sub-record.\n+  void end_sub_record();\n+  \/\/ Finishes the current dump segment if not already finished.\n+  void finish_dump_segment();\n+  \/\/ Flush internal buffer to persistent storage\n+  virtual void flush() = 0;\n+  \/\/ Total number of bytes written to the disk\n+  virtual julong bytes_written() const = 0;\n+  \/\/ Return non-null if error occurred\n+  virtual char const* error() const = 0;\n+};\n+\n+void AbstractDumpWriter::write_fast(const void* s, size_t len) {\n+  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n+  assert(buffer_size() - position() >= len, \"Must fit\");\n+  debug_only(_sub_record_left -= len);\n+  memcpy(buffer() + position(), s, len);\n+  set_position(position() + len);\n+}\n+\n+bool AbstractDumpWriter::can_write_fast(size_t len) {\n+  return buffer_size() - position() >= len;\n+}\n+\n+\/\/ write raw bytes\n+void AbstractDumpWriter::write_raw(const void* s, size_t len) {\n+  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n+  debug_only(_sub_record_left -= len);\n+\n+  \/\/ flush buffer to make room.\n+  while (len > buffer_size() - position()) {\n+    assert(!_in_dump_segment || _is_huge_sub_record,\n+           \"Cannot overflow in non-huge sub-record.\");\n+    size_t to_write = buffer_size() - position();\n+    memcpy(buffer() + position(), s, to_write);\n+    s = (void*) ((char*) s + to_write);\n+    len -= to_write;\n+    set_position(position() + to_write);\n+    flush();\n+  }\n+\n+  memcpy(buffer() + position(), s, len);\n+  set_position(position() + len);\n+}\n+\n+\/\/ Makes sure we inline the fast write into the write_u* functions. This is a big speedup.\n+#define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \\\n+                                      else write_raw((p), (len)); } while (0)\n+\n+void AbstractDumpWriter::write_u1(u1 x) {\n+  WRITE_KNOWN_TYPE(&x, 1);\n+}\n+\n+void AbstractDumpWriter::write_u2(u2 x) {\n+  u2 v;\n+  Bytes::put_Java_u2((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 2);\n+}\n+\n+void AbstractDumpWriter::write_u4(u4 x) {\n+  u4 v;\n+  Bytes::put_Java_u4((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 4);\n+}\n+\n+void AbstractDumpWriter::write_u8(u8 x) {\n+  u8 v;\n+  Bytes::put_Java_u8((address)&v, x);\n+  WRITE_KNOWN_TYPE(&v, 8);\n+}\n+\n+void AbstractDumpWriter::write_address(address a) {\n+#ifdef _LP64\n+  write_u8((u8)a);\n+#else\n+  write_u4((u4)a);\n+#endif\n+}\n+\n+void AbstractDumpWriter::write_objectID(oop o) {\n+  write_address(cast_from_oop<address>(o));\n+}\n+\n+void AbstractDumpWriter::write_rootID(oop* p) {\n+  write_address((address)p);\n+}\n+\n+void AbstractDumpWriter::write_symbolID(Symbol* s) {\n+  write_address((address)((uintptr_t)s));\n+}\n+\n+void AbstractDumpWriter::write_id(u4 x) {\n+#ifdef _LP64\n+  write_u8((u8) x);\n+#else\n+  write_u4(x);\n+#endif\n+}\n+\n+\/\/ We use java mirror as the class ID\n+void AbstractDumpWriter::write_classID(Klass* k) {\n+  write_objectID(k->java_mirror());\n+}\n+\n+void AbstractDumpWriter::finish_dump_segment() {\n+  if (_in_dump_segment) {\n+    assert(_sub_record_left == 0, \"Last sub-record not written completely\");\n+    assert(_sub_record_ended, \"sub-record must have ended\");\n+\n+    \/\/ Fix up the dump segment length if we haven't written a huge sub-record last\n+    \/\/ (in which case the segment length was already set to the correct value initially).\n+    if (!_is_huge_sub_record) {\n+      assert(position() > dump_segment_header_size, \"Dump segment should have some content\");\n+      Bytes::put_Java_u4((address) (buffer() + 5),\n+                         (u4) (position() - dump_segment_header_size));\n+    } else {\n+      \/\/ Finish process huge sub record\n+      \/\/ Set _is_huge_sub_record to false so the parallel dump writer can flush data to file.\n+      _is_huge_sub_record = false;\n+    }\n+\n+    _in_dump_segment = false;\n+    flush();\n+  }\n+}\n+\n+void AbstractDumpWriter::start_sub_record(u1 tag, u4 len) {\n+  if (!_in_dump_segment) {\n+    if (position() > 0) {\n+      flush();\n+    }\n+\n+    assert(position() == 0 && buffer_size() > dump_segment_header_size, \"Must be at the start\");\n+\n+    write_u1(HPROF_HEAP_DUMP_SEGMENT);\n+    write_u4(0); \/\/ timestamp\n+    \/\/ Will be fixed up later if we add more sub-records.  If this is a huge sub-record,\n+    \/\/ this is already the correct length, since we don't add more sub-records.\n+    write_u4(len);\n+    assert(Bytes::get_Java_u4((address)(buffer() + 5)) == len, \"Inconsistent size!\");\n+    _in_dump_segment = true;\n+    _is_huge_sub_record = len > buffer_size() - dump_segment_header_size;\n+    ResourceMark rm;\n+  } else if (_is_huge_sub_record || (len > buffer_size() - position())) {\n+    \/\/ This object will not fit in completely or the last sub-record was huge.\n+    \/\/ Finish the current segment and try again.\n+    finish_dump_segment();\n+    start_sub_record(tag, len);\n+\n+    return;\n+  }\n+\n+  debug_only(_sub_record_left = len);\n+  debug_only(_sub_record_ended = false);\n+\n+  write_u1(tag);\n+}\n+\n+void AbstractDumpWriter::end_sub_record() {\n+  assert(_in_dump_segment, \"must be in dump segment\");\n+  assert(_sub_record_left == 0, \"sub-record not written completely\");\n+  assert(!_sub_record_ended, \"Must not have ended yet\");\n+  debug_only(_sub_record_ended = true);\n+}\n+\n+\/\/ Supports I\/O operations for a dump\n+\n+class DumpWriter : public AbstractDumpWriter {\n+private:\n+ FileWriter* _writer;\n+ AbstractCompressor* _compressor;\n+ size_t _bytes_written;\n+ char* _error;\n+ \/\/ Compression support\n+ char* _out_buffer;\n+ size_t _out_size;\n+ size_t _out_pos;\n+ char* _tmp_buffer;\n+ size_t _tmp_size;\n+\n+private:\n+  void do_compress();\n+\n+public:\n+  DumpWriter(FileWriter* writer, AbstractCompressor* compressor);\n+  ~DumpWriter();\n+  julong bytes_written() const override        { return (julong) _bytes_written; }\n+  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n+  char const* error() const override           { return _error; }\n+  void set_error(const char* error)            { _error = (char*)error; }\n+  bool has_error() const                       { return _error != nullptr; }\n+  const char* get_file_path() const            { return _writer->get_file_path(); }\n+  AbstractCompressor* compressor()             { return _compressor; }\n+  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n+  bool is_overwrite() const                    { return _writer->is_overwrite(); }\n+\n+  void flush() override;\n+};\n+\n+DumpWriter::DumpWriter(FileWriter* writer, AbstractCompressor* compressor) :\n+  AbstractDumpWriter(),\n+  _writer(writer),\n+  _compressor(compressor),\n+  _bytes_written(0),\n+  _error(nullptr),\n+  _out_buffer(nullptr),\n+  _out_size(0),\n+  _out_pos(0),\n+  _tmp_buffer(nullptr),\n+  _tmp_size(0) {\n+  _error = (char*)_writer->open_writer();\n+  if (_error == nullptr) {\n+    _buffer = (char*)os::malloc(io_buffer_max_size, mtInternal);\n+    if (compressor != nullptr) {\n+      _error = (char*)_compressor->init(io_buffer_max_size, &_out_size, &_tmp_size);\n+      if (_error == nullptr) {\n+        if (_out_size > 0) {\n+          _out_buffer = (char*)os::malloc(_out_size, mtInternal);\n+        }\n+        if (_tmp_size > 0) {\n+          _tmp_buffer = (char*)os::malloc(_tmp_size, mtInternal);\n+        }\n+      }\n+    }\n+  }\n+  \/\/ initialize internal buffer\n+  _pos = 0;\n+  _size = io_buffer_max_size;\n+}\n+\n+DumpWriter::~DumpWriter(){\n+  if (_buffer != nullptr) {\n+    os::free(_buffer);\n+  }\n+  if (_out_buffer != nullptr) {\n+    os::free(_out_buffer);\n+  }\n+  if (_tmp_buffer != nullptr) {\n+    os::free(_tmp_buffer);\n+  }\n+  _bytes_written = -1;\n+}\n+\n+\/\/ flush any buffered bytes to the file\n+void DumpWriter::flush() {\n+  if (_pos <= 0) {\n+    return;\n+  }\n+  if (has_error()) {\n+    _pos = 0;\n+    return;\n+  }\n+  char* result = nullptr;\n+  if (_compressor == nullptr) {\n+    result = (char*)_writer->write_buf(_buffer, _pos);\n+    _bytes_written += _pos;\n+  } else {\n+    do_compress();\n+    if (!has_error()) {\n+      result = (char*)_writer->write_buf(_out_buffer, _out_pos);\n+      _bytes_written += _out_pos;\n+    }\n+  }\n+  _pos = 0; \/\/ reset pos to make internal buffer available\n+\n+  if (result != nullptr) {\n+    set_error(result);\n+  }\n+}\n+\n+void DumpWriter::do_compress() {\n+  const char* msg = _compressor->compress(_buffer, _pos, _out_buffer, _out_size,\n+                                          _tmp_buffer, _tmp_size, &_out_pos);\n+\n+  if (msg != nullptr) {\n+    set_error(msg);\n+  }\n+}\n+\n@@ -838,4 +1488,4 @@\n- private:\n-   Monitor* _lock;\n-   uint   _dumper_number;\n-   uint   _complete_number;\n+private:\n+  Monitor* _lock;\n+  uint   _dumper_number;\n+  uint   _complete_number;\n@@ -843,21 +1493,21 @@\n- public:\n-   DumperController(uint number) :\n-     _lock(new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"DumperController_lock\")),\n-     _dumper_number(number),\n-     _complete_number(0) { }\n-\n-   ~DumperController() { delete _lock; }\n-\n-   void dumper_complete(DumpWriter* local_writer, DumpWriter* global_writer) {\n-     MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-     _complete_number++;\n-     \/\/ propagate local error to global if any\n-     if (local_writer->has_error()) {\n-      global_writer->set_error(local_writer->error());\n-     }\n-     ml.notify();\n-   }\n-\n-   void wait_all_dumpers_complete() {\n-     MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-     while (_complete_number != _dumper_number) {\n+public:\n+  DumperController(uint number) :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"DumperController_lock\")),\n+    _dumper_number(number),\n+    _complete_number(0) { }\n+\n+  ~DumperController() { delete _lock; }\n+\n+  void dumper_complete(DumpWriter* local_writer, DumpWriter* global_writer) {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _complete_number++;\n+    \/\/ propagate local error to global if any\n+    if (local_writer->has_error()) {\n+    global_writer->set_error(local_writer->error());\n+    }\n+    ml.notify();\n+  }\n+\n+  void wait_all_dumpers_complete() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    while (_complete_number != _dumper_number) {\n@@ -865,2 +1515,2 @@\n-     }\n-   }\n+    }\n+  }\n@@ -869,0 +1519,1 @@\n+\/\/ Merge segmented dump files into a complete one\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":678,"deletions":27,"binary":false,"changes":705,"status":"modified"},{"patch":"@@ -32,322 +32,0 @@\n-\/*\n- * HPROF binary format - description copied from:\n- *   src\/share\/demo\/jvmti\/hprof\/hprof_io.c\n- *\n- *\n- *  header    \"JAVA PROFILE 1.0.2\" (0-terminated)\n- *\n- *  u4        size of identifiers. Identifiers are used to represent\n- *            UTF8 strings, objects, stack traces, etc. They usually\n- *            have the same size as host pointers.\n- * u4         high word\n- * u4         low word    number of milliseconds since 0:00 GMT, 1\/1\/70\n- * [record]*  a sequence of records.\n- *\n- *\n- * Record format:\n- *\n- * u1         a TAG denoting the type of the record\n- * u4         number of *microseconds* since the time stamp in the\n- *            header. (wraps around in a little more than an hour)\n- * u4         number of bytes *remaining* in the record. Note that\n- *            this number excludes the tag and the length field itself.\n- * [u1]*      BODY of the record (a sequence of bytes)\n- *\n- *\n- * The following TAGs are supported:\n- *\n- * TAG           BODY       notes\n- *----------------------------------------------------------\n- * HPROF_UTF8               a UTF8-encoded name\n- *\n- *               id         name ID\n- *               [u1]*      UTF8 characters (no trailing zero)\n- *\n- * HPROF_LOAD_CLASS         a newly loaded class\n- *\n- *                u4        class serial number (> 0)\n- *                id        class object ID\n- *                u4        stack trace serial number\n- *                id        class name ID\n- *\n- * HPROF_UNLOAD_CLASS       an unloading class\n- *\n- *                u4        class serial_number\n- *\n- * HPROF_FRAME              a Java stack frame\n- *\n- *                id        stack frame ID\n- *                id        method name ID\n- *                id        method signature ID\n- *                id        source file name ID\n- *                u4        class serial number\n- *                i4        line number. >0: normal\n- *                                       -1: unknown\n- *                                       -2: compiled method\n- *                                       -3: native method\n- *\n- * HPROF_TRACE              a Java stack trace\n- *\n- *               u4         stack trace serial number\n- *               u4         thread serial number\n- *               u4         number of frames\n- *               [id]*      stack frame IDs\n- *\n- *\n- * HPROF_ALLOC_SITES        a set of heap allocation sites, obtained after GC\n- *\n- *               u2         flags 0x0001: incremental vs. complete\n- *                                0x0002: sorted by allocation vs. live\n- *                                0x0004: whether to force a GC\n- *               u4         cutoff ratio\n- *               u4         total live bytes\n- *               u4         total live instances\n- *               u8         total bytes allocated\n- *               u8         total instances allocated\n- *               u4         number of sites that follow\n- *               [u1        is_array: 0:  normal object\n- *                                    2:  object array\n- *                                    4:  boolean array\n- *                                    5:  char array\n- *                                    6:  float array\n- *                                    7:  double array\n- *                                    8:  byte array\n- *                                    9:  short array\n- *                                    10: int array\n- *                                    11: long array\n- *                u4        class serial number (may be zero during startup)\n- *                u4        stack trace serial number\n- *                u4        number of bytes alive\n- *                u4        number of instances alive\n- *                u4        number of bytes allocated\n- *                u4]*      number of instance allocated\n- *\n- * HPROF_START_THREAD       a newly started thread.\n- *\n- *               u4         thread serial number (> 0)\n- *               id         thread object ID\n- *               u4         stack trace serial number\n- *               id         thread name ID\n- *               id         thread group name ID\n- *               id         thread group parent name ID\n- *\n- * HPROF_END_THREAD         a terminating thread.\n- *\n- *               u4         thread serial number\n- *\n- * HPROF_HEAP_SUMMARY       heap summary\n- *\n- *               u4         total live bytes\n- *               u4         total live instances\n- *               u8         total bytes allocated\n- *               u8         total instances allocated\n- *\n- * HPROF_HEAP_DUMP          denote a heap dump\n- *\n- *               [heap dump sub-records]*\n- *\n- *                          There are four kinds of heap dump sub-records:\n- *\n- *               u1         sub-record type\n- *\n- *               HPROF_GC_ROOT_UNKNOWN         unknown root\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_ROOT_THREAD_OBJ      thread object\n- *\n- *                          id         thread object ID  (may be 0 for a\n- *                                     thread newly attached through JNI)\n- *                          u4         thread sequence number\n- *                          u4         stack trace sequence number\n- *\n- *               HPROF_GC_ROOT_JNI_GLOBAL      JNI global ref root\n- *\n- *                          id         object ID\n- *                          id         JNI global ref ID\n- *\n- *               HPROF_GC_ROOT_JNI_LOCAL       JNI local ref\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *                          u4         frame # in stack trace (-1 for empty)\n- *\n- *               HPROF_GC_ROOT_JAVA_FRAME      Java stack frame\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *                          u4         frame # in stack trace (-1 for empty)\n- *\n- *               HPROF_GC_ROOT_NATIVE_STACK    Native stack\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *\n- *               HPROF_GC_ROOT_STICKY_CLASS    System class\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_ROOT_THREAD_BLOCK    Reference from thread block\n- *\n- *                          id         object ID\n- *                          u4         thread serial number\n- *\n- *               HPROF_GC_ROOT_MONITOR_USED    Busy monitor\n- *\n- *                          id         object ID\n- *\n- *               HPROF_GC_CLASS_DUMP           dump of a class object\n- *\n- *                          id         class object ID\n- *                          u4         stack trace serial number\n- *                          id         super class object ID\n- *                          id         class loader object ID\n- *                          id         signers object ID\n- *                          id         protection domain object ID\n- *                          id         reserved\n- *                          id         reserved\n- *\n- *                          u4         instance size (in bytes)\n- *\n- *                          u2         size of constant pool\n- *                          [u2,       constant pool index,\n- *                           ty,       type\n- *                                     2:  object\n- *                                     4:  boolean\n- *                                     5:  char\n- *                                     6:  float\n- *                                     7:  double\n- *                                     8:  byte\n- *                                     9:  short\n- *                                     10: int\n- *                                     11: long\n- *                           vl]*      and value\n- *\n- *                          u2         number of static fields\n- *                          [id,       static field name,\n- *                           ty,       type,\n- *                           vl]*      and value\n- *\n- *                          u2         number of inst. fields (not inc. super)\n- *                          [id,       instance field name,\n- *                           ty]*      type\n- *\n- *               HPROF_GC_INSTANCE_DUMP        dump of a normal object\n- *\n- *                          id         object ID\n- *                          u4         stack trace serial number\n- *                          id         class object ID\n- *                          u4         number of bytes that follow\n- *                          [vl]*      instance field values (class, followed\n- *                                     by super, super's super ...)\n- *\n- *               HPROF_GC_OBJ_ARRAY_DUMP       dump of an object array\n- *\n- *                          id         array object ID\n- *                          u4         stack trace serial number\n- *                          u4         number of elements\n- *                          id         array class ID\n- *                          [id]*      elements\n- *\n- *               HPROF_GC_PRIM_ARRAY_DUMP      dump of a primitive array\n- *\n- *                          id         array object ID\n- *                          u4         stack trace serial number\n- *                          u4         number of elements\n- *                          u1         element type\n- *                                     4:  boolean array\n- *                                     5:  char array\n- *                                     6:  float array\n- *                                     7:  double array\n- *                                     8:  byte array\n- *                                     9:  short array\n- *                                     10: int array\n- *                                     11: long array\n- *                          [u1]*      elements\n- *\n- * HPROF_CPU_SAMPLES        a set of sample traces of running threads\n- *\n- *                u4        total number of samples\n- *                u4        # of traces\n- *               [u4        # of samples\n- *                u4]*      stack trace serial number\n- *\n- * HPROF_CONTROL_SETTINGS   the settings of on\/off switches\n- *\n- *                u4        0x00000001: alloc traces on\/off\n- *                          0x00000002: cpu sampling on\/off\n- *                u2        stack trace depth\n- *\n- *\n- * When the header is \"JAVA PROFILE 1.0.2\" a heap dump can optionally\n- * be generated as a sequence of heap dump segments. This sequence is\n- * terminated by an end record. The additional tags allowed by format\n- * \"JAVA PROFILE 1.0.2\" are:\n- *\n- * HPROF_HEAP_DUMP_SEGMENT  denote a heap dump segment\n- *\n- *               [heap dump sub-records]*\n- *               The same sub-record types allowed by HPROF_HEAP_DUMP\n- *\n- * HPROF_HEAP_DUMP_END      denotes the end of a heap dump\n- *\n- *\/\n-\n-\n-\/\/ HPROF tags\n-\n-enum hprofTag : u1 {\n-  \/\/ top-level records\n-  HPROF_UTF8                    = 0x01,\n-  HPROF_LOAD_CLASS              = 0x02,\n-  HPROF_UNLOAD_CLASS            = 0x03,\n-  HPROF_FRAME                   = 0x04,\n-  HPROF_TRACE                   = 0x05,\n-  HPROF_ALLOC_SITES             = 0x06,\n-  HPROF_HEAP_SUMMARY            = 0x07,\n-  HPROF_START_THREAD            = 0x0A,\n-  HPROF_END_THREAD              = 0x0B,\n-  HPROF_HEAP_DUMP               = 0x0C,\n-  HPROF_CPU_SAMPLES             = 0x0D,\n-  HPROF_CONTROL_SETTINGS        = 0x0E,\n-\n-  \/\/ 1.0.2 record types\n-  HPROF_HEAP_DUMP_SEGMENT       = 0x1C,\n-  HPROF_HEAP_DUMP_END           = 0x2C,\n-\n-  \/\/ field types\n-  HPROF_ARRAY_OBJECT            = 0x01,\n-  HPROF_NORMAL_OBJECT           = 0x02,\n-  HPROF_BOOLEAN                 = 0x04,\n-  HPROF_CHAR                    = 0x05,\n-  HPROF_FLOAT                   = 0x06,\n-  HPROF_DOUBLE                  = 0x07,\n-  HPROF_BYTE                    = 0x08,\n-  HPROF_SHORT                   = 0x09,\n-  HPROF_INT                     = 0x0A,\n-  HPROF_LONG                    = 0x0B,\n-\n-  \/\/ data-dump sub-records\n-  HPROF_GC_ROOT_UNKNOWN         = 0xFF,\n-  HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,\n-  HPROF_GC_ROOT_JNI_LOCAL       = 0x02,\n-  HPROF_GC_ROOT_JAVA_FRAME      = 0x03,\n-  HPROF_GC_ROOT_NATIVE_STACK    = 0x04,\n-  HPROF_GC_ROOT_STICKY_CLASS    = 0x05,\n-  HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,\n-  HPROF_GC_ROOT_MONITOR_USED    = 0x07,\n-  HPROF_GC_ROOT_THREAD_OBJ      = 0x08,\n-  HPROF_GC_CLASS_DUMP           = 0x20,\n-  HPROF_GC_INSTANCE_DUMP        = 0x21,\n-  HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,\n-  HPROF_GC_PRIM_ARRAY_DUMP      = 0x23\n-};\n-\n-\/\/ Default stack trace ID (used for dummy HPROF_TRACE record)\n-enum {\n-  STACK_TRACE_ID = 1,\n-  INITIAL_CLASS_COUNT = 200\n-};\n-\n-\n-\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":0,"deletions":322,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -145,234 +145,0 @@\n-\n-\n-void AbstractDumpWriter::write_fast(const void* s, size_t len) {\n-  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n-  assert(buffer_size() - position() >= len, \"Must fit\");\n-  debug_only(_sub_record_left -= len);\n-  memcpy(buffer() + position(), s, len);\n-  set_position(position() + len);\n-}\n-\n-bool AbstractDumpWriter::can_write_fast(size_t len) {\n-  return buffer_size() - position() >= len;\n-}\n-\n-\/\/ write raw bytes\n-void AbstractDumpWriter::write_raw(const void* s, size_t len) {\n-  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n-  debug_only(_sub_record_left -= len);\n-\n-  \/\/ flush buffer to make room.\n-  while (len > buffer_size() - position()) {\n-    assert(!_in_dump_segment || _is_huge_sub_record,\n-           \"Cannot overflow in non-huge sub-record.\");\n-    size_t to_write = buffer_size() - position();\n-    memcpy(buffer() + position(), s, to_write);\n-    s = (void*) ((char*) s + to_write);\n-    len -= to_write;\n-    set_position(position() + to_write);\n-    flush();\n-  }\n-\n-  memcpy(buffer() + position(), s, len);\n-  set_position(position() + len);\n-}\n-\n-\/\/ Makes sure we inline the fast write into the write_u* functions. This is a big speedup.\n-#define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \\\n-                                      else write_raw((p), (len)); } while (0)\n-\n-void AbstractDumpWriter::write_u1(u1 x) {\n-  WRITE_KNOWN_TYPE(&x, 1);\n-}\n-\n-void AbstractDumpWriter::write_u2(u2 x) {\n-  u2 v;\n-  Bytes::put_Java_u2((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 2);\n-}\n-\n-void AbstractDumpWriter::write_u4(u4 x) {\n-  u4 v;\n-  Bytes::put_Java_u4((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 4);\n-}\n-\n-void AbstractDumpWriter::write_u8(u8 x) {\n-  u8 v;\n-  Bytes::put_Java_u8((address)&v, x);\n-  WRITE_KNOWN_TYPE(&v, 8);\n-}\n-\n-void AbstractDumpWriter::write_address(address a) {\n-#ifdef _LP64\n-  write_u8((u8)a);\n-#else\n-  write_u4((u4)a);\n-#endif\n-}\n-\n-void AbstractDumpWriter::write_objectID(oop o) {\n-  write_address(cast_from_oop<address>(o));\n-}\n-\n-void AbstractDumpWriter::write_rootID(oop* p) {\n-  write_address((address)p);\n-}\n-\n-void AbstractDumpWriter::write_symbolID(Symbol* s) {\n-  write_address((address)((uintptr_t)s));\n-}\n-\n-void AbstractDumpWriter::write_id(u4 x) {\n-#ifdef _LP64\n-  write_u8((u8) x);\n-#else\n-  write_u4(x);\n-#endif\n-}\n-\n-\/\/ We use java mirror as the class ID\n-void AbstractDumpWriter::write_classID(Klass* k) {\n-  write_objectID(k->java_mirror());\n-}\n-\n-void AbstractDumpWriter::finish_dump_segment() {\n-  if (_in_dump_segment) {\n-    assert(_sub_record_left == 0, \"Last sub-record not written completely\");\n-    assert(_sub_record_ended, \"sub-record must have ended\");\n-\n-    \/\/ Fix up the dump segment length if we haven't written a huge sub-record last\n-    \/\/ (in which case the segment length was already set to the correct value initially).\n-    if (!_is_huge_sub_record) {\n-      assert(position() > dump_segment_header_size, \"Dump segment should have some content\");\n-      Bytes::put_Java_u4((address) (buffer() + 5),\n-                         (u4) (position() - dump_segment_header_size));\n-    } else {\n-      \/\/ Finish process huge sub record\n-      \/\/ Set _is_huge_sub_record to false so the parallel dump writer can flush data to file.\n-      _is_huge_sub_record = false;\n-    }\n-\n-    _in_dump_segment = false;\n-    flush();\n-  }\n-}\n-\n-void AbstractDumpWriter::start_sub_record(u1 tag, u4 len) {\n-  if (!_in_dump_segment) {\n-    if (position() > 0) {\n-      flush();\n-    }\n-\n-    assert(position() == 0 && buffer_size() > dump_segment_header_size, \"Must be at the start\");\n-\n-    write_u1(HPROF_HEAP_DUMP_SEGMENT);\n-    write_u4(0); \/\/ timestamp\n-    \/\/ Will be fixed up later if we add more sub-records.  If this is a huge sub-record,\n-    \/\/ this is already the correct length, since we don't add more sub-records.\n-    write_u4(len);\n-    assert(Bytes::get_Java_u4((address)(buffer() + 5)) == len, \"Inconsistent size!\");\n-    _in_dump_segment = true;\n-    _is_huge_sub_record = len > buffer_size() - dump_segment_header_size;\n-    ResourceMark rm;\n-  } else if (_is_huge_sub_record || (len > buffer_size() - position())) {\n-    \/\/ This object will not fit in completely or the last sub-record was huge.\n-    \/\/ Finish the current segment and try again.\n-    finish_dump_segment();\n-    start_sub_record(tag, len);\n-\n-    return;\n-  }\n-\n-  debug_only(_sub_record_left = len);\n-  debug_only(_sub_record_ended = false);\n-\n-  write_u1(tag);\n-}\n-\n-void AbstractDumpWriter::end_sub_record() {\n-  assert(_in_dump_segment, \"must be in dump segment\");\n-  assert(_sub_record_left == 0, \"sub-record not written completely\");\n-  assert(!_sub_record_ended, \"Must not have ended yet\");\n-  debug_only(_sub_record_ended = true);\n-}\n-\n-DumpWriter::DumpWriter(FileWriter* writer, AbstractCompressor* compressor) :\n-  AbstractDumpWriter(),\n-  _writer(writer),\n-  _compressor(compressor),\n-  _bytes_written(0),\n-  _error(nullptr),\n-  _out_buffer(nullptr),\n-  _out_size(0),\n-  _out_pos(0),\n-  _tmp_buffer(nullptr),\n-  _tmp_size(0) {\n-  _error = (char*)_writer->open_writer();\n-  if (_error == nullptr) {\n-    _buffer = (char*)os::malloc(io_buffer_max_size, mtInternal);\n-    if (compressor != nullptr) {\n-      _error = (char*)_compressor->init(io_buffer_max_size, &_out_size, &_tmp_size);\n-      if (_error == nullptr) {\n-        if (_out_size > 0) {\n-          _out_buffer = (char*)os::malloc(_out_size, mtInternal);\n-        }\n-        if (_tmp_size > 0) {\n-          _tmp_buffer = (char*)os::malloc(_tmp_size, mtInternal);\n-        }\n-      }\n-    }\n-  }\n-  \/\/ initialize internal buffer\n-  _pos = 0;\n-  _size = io_buffer_max_size;\n-}\n-\n-DumpWriter::~DumpWriter(){\n-  if (_buffer != nullptr) {\n-    os::free(_buffer);\n-  }\n-  if (_out_buffer != nullptr) {\n-    os::free(_out_buffer);\n-  }\n-  if (_tmp_buffer != nullptr) {\n-    os::free(_tmp_buffer);\n-  }\n-  _bytes_written = -1;\n-}\n-\n-\/\/ flush any buffered bytes to the file\n-void DumpWriter::flush() {\n-  if (_pos <= 0) {\n-    return;\n-  }\n-  if (has_error()) {\n-    _pos = 0;\n-    return;\n-  }\n-  char* result = nullptr;\n-  if (_compressor == nullptr) {\n-    result = (char*)_writer->write_buf(_buffer, _pos);\n-    _bytes_written += _pos;\n-  } else {\n-    do_compress();\n-    if (!has_error()) {\n-      result = (char*)_writer->write_buf(_out_buffer, _out_pos);\n-      _bytes_written += _out_pos;\n-    }\n-  }\n-  _pos = 0; \/\/ reset pos to make internal buffer available\n-\n-  if (result != nullptr) {\n-    set_error(result);\n-  }\n-}\n-\n-void DumpWriter::do_compress() {\n-  const char* msg = _compressor->compress(_buffer, _pos, _out_buffer, _out_size,\n-                                          _tmp_buffer, _tmp_size, &_out_pos);\n-\n-  if (msg != nullptr) {\n-    set_error(msg);\n-  }\n-}\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":0,"deletions":234,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -105,98 +105,0 @@\n-\/\/ Base class for dump and parallel dump\n-class AbstractDumpWriter : public ResourceObj {\n- protected:\n-  enum {\n-    io_buffer_max_size = 1*M,\n-    dump_segment_header_size = 9\n-  };\n-\n-  char* _buffer;    \/\/ internal buffer\n-  size_t _size;\n-  size_t _pos;\n-\n-  bool _in_dump_segment; \/\/ Are we currently in a dump segment?\n-  bool _is_huge_sub_record; \/\/ Are we writing a sub-record larger than the buffer size?\n-  DEBUG_ONLY(size_t _sub_record_left;) \/\/ The bytes not written for the current sub-record.\n-  DEBUG_ONLY(bool _sub_record_ended;) \/\/ True if we have called the end_sub_record().\n-\n-  char* buffer() const                          { return _buffer; }\n-  size_t buffer_size() const                    { return _size; }\n-  void set_position(size_t pos)                 { _pos = pos; }\n-\n-  \/\/ Can be called if we have enough room in the buffer.\n-  void write_fast(const void* s, size_t len);\n-\n-  \/\/ Returns true if we have enough room in the buffer for 'len' bytes.\n-  bool can_write_fast(size_t len);\n-\n-  void write_address(address a);\n-\n- public:\n-  AbstractDumpWriter() :\n-    _buffer(nullptr),\n-    _size(io_buffer_max_size),\n-    _pos(0),\n-    _in_dump_segment(false) { }\n-\n-  size_t position() const                       { return _pos; }\n-  \/\/ writer functions\n-  virtual void write_raw(const void* s, size_t len);\n-  void write_u1(u1 x);\n-  void write_u2(u2 x);\n-  void write_u4(u4 x);\n-  void write_u8(u8 x);\n-  void write_objectID(oop o);\n-  void write_rootID(oop* p);\n-  void write_symbolID(Symbol* o);\n-  void write_classID(Klass* k);\n-  void write_id(u4 x);\n-\n-  \/\/ Start a new sub-record. Starts a new heap dump segment if needed.\n-  void start_sub_record(u1 tag, u4 len);\n-  \/\/ Ends the current sub-record.\n-  void end_sub_record();\n-  \/\/ Finishes the current dump segment if not already finished.\n-  void finish_dump_segment();\n-  \/\/ Flush internal buffer to persistent storage\n-  virtual void flush() = 0;\n-  \/\/ Total number of bytes written to the disk\n-  virtual julong bytes_written() const = 0;\n-  \/\/ Return non-null if error occurred\n-  virtual char const* error() const = 0;\n-};\n-\n-\n-\/\/ Supports I\/O operations for a dump\n-\n-class DumpWriter : public AbstractDumpWriter {\n-private:\n- FileWriter* _writer;\n- AbstractCompressor* _compressor;\n- size_t _bytes_written;\n- char* _error;\n- \/\/ Compression support\n- char* _out_buffer;\n- size_t _out_size;\n- size_t _out_pos;\n- char* _tmp_buffer;\n- size_t _tmp_size;\n-\n-private:\n-  void do_compress();\n-\n-public:\n-  DumpWriter(FileWriter* writer, AbstractCompressor* compressor);\n-  ~DumpWriter();\n-  julong bytes_written() const override        { return (julong) _bytes_written; }\n-  void set_bytes_written(julong bytes_written) { _bytes_written = bytes_written; }\n-  char const* error() const override           { return _error; }\n-  void set_error(const char* error)            { _error = (char*)error; }\n-  bool has_error() const                       { return _error != nullptr; }\n-  const char* get_file_path() const            { return _writer->get_file_path(); }\n-  AbstractCompressor* compressor()             { return _compressor; }\n-  void set_compressor(AbstractCompressor* p)   { _compressor = p; }\n-  bool is_overwrite() const                    { return _writer->is_overwrite(); }\n-\n-  void flush() override;\n-};\n-\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.hpp","additions":0,"deletions":98,"binary":false,"changes":98,"status":"modified"}]}