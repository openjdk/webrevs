{"files":[{"patch":"@@ -510,1 +510,1 @@\n-    if (MetaspaceShared::is_shared_static(bottom)) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_shared_static(bottom)) {\n@@ -512,1 +512,0 @@\n-      assert(CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n@@ -524,1 +523,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(obj)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(obj)) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,3 @@\n+  template <typename T> static Array<T>* archive_non_ptr_array(GrowableArray<T>* tmp_array);\n+  template <typename T> static Array<T>* archive_ptr_array(GrowableArray<T>* tmp_array);\n+\n@@ -262,1 +265,10 @@\n-  template <typename T> static Array<T>* archive_array(GrowableArray<T>* tmp_array);\n+\n+  template <typename T, ENABLE_IF(!std::is_pointer<T>::value)>\n+  static Array<T>* archive_array(GrowableArray<T>* tmp_array) {\n+    return archive_non_ptr_array(tmp_array);\n+  }\n+\n+  template <typename T, ENABLE_IF(std::is_pointer<T>::value)>\n+  static Array<T>* archive_array(GrowableArray<T>* tmp_array) {\n+    return archive_ptr_array(tmp_array);\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -55,1 +57,3 @@\n-Array<T>* ArchiveUtils::archive_array(GrowableArray<T>* tmp_array) {\n+Array<T>* ArchiveUtils::archive_non_ptr_array(GrowableArray<T>* tmp_array) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+\n@@ -59,1 +63,27 @@\n-    if (std::is_pointer<T>::value) {\n+  }\n+\n+  return archived_array;\n+}\n+\n+\/\/ Returns the address of an Array<T> that's allocated in the ArchiveBuilder \"buffer\" space.\n+\/\/ All pointers in tmp_array must point to:\n+\/\/    - a buffered object; or\n+\/\/    - a source object that has been archived; or\n+\/\/    - (only when dumping dynamic archive) an object in the static archive.\n+template <typename T>\n+Array<T>* ArchiveUtils::archive_ptr_array(GrowableArray<T>* tmp_array) {\n+  ArchiveBuilder* builder = ArchiveBuilder::current();\n+  const bool is_dynamic_dump = CDSConfig::is_dumping_dynamic_archive();\n+\n+  Array<T>* archived_array = ArchiveBuilder::new_ro_array<T>(tmp_array->length());\n+  for (int i = 0; i < tmp_array->length(); i++) {\n+      T ptr = tmp_array->at(i);\n+      if (!builder->is_in_buffer_space(ptr)) {\n+        if (is_dynamic_dump && MetaspaceShared::is_in_shared_metaspace(ptr)) {\n+          \/\/ We have a pointer that lives in the dynamic archive but points into\n+          \/\/ the static archive.\n+        } else {\n+          ptr = builder->get_buffered_addr(ptr);\n+        }\n+      }\n+      archived_array->at_put(i, ptr);\n@@ -61,1 +91,0 @@\n-    }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+bool CDSConfig::_is_dumping_preimage_static_archive = false;\n+bool CDSConfig::_is_dumping_final_static_archive = false;\n@@ -49,0 +51,1 @@\n+bool CDSConfig::_new_aot_flags_used = false;\n@@ -66,1 +69,1 @@\n-  if (is_dumping_static_archive()) {\n+  if (is_dumping_static_archive() && !is_dumping_final_static_archive()) {\n@@ -212,0 +215,1 @@\n+            log_error(cds)(\"Not a valid %s (%s)\", new_aot_flags_used() ? \"AOT cache\" : \"archive\", SharedArchiveFile);\n@@ -335,1 +339,5 @@\n-      log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n+      if (new_aot_flags_used()) {\n+        log_warning(cds)(\"AOT cache is disabled when the %s option is specified.\", option);\n+      } else {\n+        log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n+      }\n@@ -345,1 +353,1 @@\n-  if (_old_cds_flags_used && !alias_is_default) {\n+  if (old_cds_flags_used() && !alias_is_default) {\n@@ -353,1 +361,1 @@\n-void CDSConfig::check_flag_aliases() {\n+void CDSConfig::check_aot_flags() {\n@@ -365,1 +373,1 @@\n-    \/\/ Aliases not used.\n+    \/\/ AOTCache\/AOTConfiguration\/AOTMode not used.\n@@ -367,0 +375,2 @@\n+  } else {\n+    _new_aot_flags_used = true;\n@@ -370,16 +380,1 @@\n-    if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n-      vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n-    }\n-\n-    if (!FLAG_IS_DEFAULT(AOTCache)) {\n-      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n-    }\n-\n-    UseSharedSpaces = true;\n-    if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n-      RequireSharedSpaces = false;\n-    } else {\n-      assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n-      RequireSharedSpaces = true;\n-    }\n+    check_aotmode_auto_or_on();\n@@ -387,2 +382,1 @@\n-    UseSharedSpaces = false;\n-    RequireSharedSpaces = false;\n+    check_aotmode_off();\n@@ -396,8 +390,1 @@\n-      if (!FLAG_IS_DEFAULT(AOTCache)) {\n-        vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n-      }\n-\n-      assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n-      FLAG_SET_ERGO(DumpLoadedClassList, AOTConfiguration);\n-      UseSharedSpaces = false;\n-      RequireSharedSpaces = false;\n+      check_aotmode_record();\n@@ -406,3 +393,4 @@\n-      if (FLAG_IS_DEFAULT(AOTCache)) {\n-        vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n-      }\n+      check_aotmode_create();\n+    }\n+  }\n+}\n@@ -410,4 +398,4 @@\n-      assert(FLAG_IS_DEFAULT(SharedClassListFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedClassListFile, AOTConfiguration);\n-      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n-      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+void CDSConfig::check_aotmode_off() {\n+  UseSharedSpaces = false;\n+  RequireSharedSpaces = false;\n+}\n@@ -415,2 +403,16 @@\n-      CDSConfig::enable_dumping_static_archive();\n-    }\n+void CDSConfig::check_aotmode_auto_or_on() {\n+  if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n+    vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+  }\n+\n+  if (!FLAG_IS_DEFAULT(AOTCache)) {\n+    assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+    FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+  }\n+\n+  UseSharedSpaces = true;\n+  if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n+    RequireSharedSpaces = false;\n+  } else {\n+    assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n+    RequireSharedSpaces = true;\n@@ -420,0 +422,38 @@\n+void CDSConfig::check_aotmode_record() {\n+  if (!FLAG_IS_DEFAULT(AOTCache)) {\n+    vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n+  }\n+\n+  assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n+  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n+  FLAG_SET_ERGO(DumpLoadedClassList, nullptr);\n+  UseSharedSpaces = false;\n+  RequireSharedSpaces = false;\n+  _is_dumping_static_archive = true;\n+  _is_dumping_preimage_static_archive = true;\n+\n+  \/\/ At VM exit, the module graph may be contaminated with program states.\n+  \/\/ We will rebuild the module graph when dumping the CDS final image.\n+  disable_heap_dumping();\n+}\n+\n+void CDSConfig::check_aotmode_create() {\n+  if (FLAG_IS_DEFAULT(AOTCache)) {\n+    vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+  }\n+\n+  assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+\n+  _is_dumping_final_static_archive = true;\n+  FLAG_SET_ERGO(SharedArchiveFile, AOTConfiguration);\n+  UseSharedSpaces = true;\n+  RequireSharedSpaces = true;\n+\n+  if (!FileMapInfo::is_preimage_static_archive(AOTConfiguration)) {\n+    vm_exit_during_initialization(\"Must be a valid AOT configuration generated by the current JVM\", AOTConfiguration);\n+  }\n+\n+  CDSConfig::enable_dumping_static_archive();\n+}\n+\n@@ -421,1 +461,1 @@\n-  check_flag_aliases();\n+  check_aot_flags();\n@@ -437,1 +477,3 @@\n-    if (!mode_flag_cmd_line) {\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode\n+    } else if (!mode_flag_cmd_line) {\n@@ -501,0 +543,14 @@\n+bool CDSConfig::is_dumping_classic_static_archive() {\n+  return _is_dumping_static_archive &&\n+    !is_dumping_preimage_static_archive() &&\n+    !is_dumping_final_static_archive();\n+}\n+\n+bool CDSConfig::is_dumping_preimage_static_archive() {\n+  return _is_dumping_preimage_static_archive;\n+}\n+\n+bool CDSConfig::is_dumping_final_static_archive() {\n+  return _is_dumping_final_static_archive;\n+}\n+\n@@ -536,0 +592,20 @@\n+const char* CDSConfig::type_of_archive_being_loaded() {\n+  if (is_dumping_final_static_archive()) {\n+    return \"AOT configuration file\";\n+  } else if (new_aot_flags_used()) {\n+    return \"AOT cache\";\n+  } else {\n+    return \"shared archive file\";\n+  }\n+}\n+\n+const char* CDSConfig::type_of_archive_being_written() {\n+  if (is_dumping_preimage_static_archive()) {\n+    return \"AOT configuration file\";\n+  } else if (new_aot_flags_used()) {\n+    return \"AOT cache\";\n+  } else {\n+    return \"shared archive file\";\n+  }\n+}\n+\n@@ -576,1 +652,1 @@\n-  if (!is_dumping_static_archive() \/\/ heap dump is not supported in dynamic dump\n+  if (!(is_dumping_classic_static_archive() || is_dumping_final_static_archive())\n@@ -581,1 +657,0 @@\n-\n@@ -629,1 +704,3 @@\n-  if (is_dumping_dynamic_archive()) {\n+  if (is_dumping_preimage_static_archive()) {\n+    return false;\n+  } else if (is_dumping_dynamic_archive()) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":122,"deletions":45,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+  static bool _is_dumping_preimage_static_archive;\n+  static bool _is_dumping_final_static_archive;\n@@ -49,0 +51,1 @@\n+  static bool  _new_aot_flags_used;\n@@ -60,1 +63,5 @@\n-  static void check_flag_aliases();\n+  static void check_aot_flags();\n+  static void check_aotmode_off();\n+  static void check_aotmode_auto_or_on();\n+  static void check_aotmode_record();\n+  static void check_aotmode_create();\n@@ -74,0 +81,1 @@\n+  static bool new_aot_flags_used()                           { return CDS_ONLY(_new_aot_flags_used) NOT_CDS(false); }\n@@ -79,0 +87,2 @@\n+  static const char* type_of_archive_being_loaded();\n+  static const char* type_of_archive_being_written();\n@@ -91,0 +101,24 @@\n+  \/\/ A static CDS archive can be dumped in three modes:\n+  \/\/\n+  \/\/ \"classic\"   - This is the traditional CDS workflow of\n+  \/\/               \"java -Xshare:dump -XX:SharedClassListFile=file.txt\".\n+  \/\/\n+  \/\/ \"preimage\"  - This happens when we execute the JEP 483 training run, e.g:\n+  \/\/               \"java -XX:AOTMode=record -XX:AOTConfiguration=app.aotconfig -cp app.jar App\"\n+  \/\/               The above command writes app.aotconfig as a \"CDS preimage\". This\n+  \/\/               is a binary file that contains all the classes loaded during the\n+  \/\/               training run, plus profiling data (e.g., the resolved constant pool entries).\n+  \/\/\n+  \/\/ \"final\"     - This happens when we execute the JEP 483 assembly phase, e.g:\n+  \/\/               \"java -XX:AOTMode=create -XX:AOTConfiguration=app.aotconfig -XX:AOTCache=app.aot -cp app.jar\"\n+  \/\/               The above command loads all classes from app.aotconfig, perform additional linking,\n+  \/\/               and writes app.aot as a \"CDS final image\" file.\n+  \/\/\n+  \/\/ The main structural difference between \"preimage\" and \"final\" is that the preimage\n+  \/\/ - has a different magic number (0xcafea07c)\n+  \/\/ - does not have any archived Java heap objects\n+  \/\/ - does not have aot-linked classes\n+  static bool is_dumping_classic_static_archive()            NOT_CDS_RETURN_(false);\n+  static bool is_dumping_preimage_static_archive()           NOT_CDS_RETURN_(false);\n+  static bool is_dumping_final_static_archive()              NOT_CDS_RETURN_(false);\n+\n@@ -138,1 +172,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,3 @@\n-          \"Configuration information used by CreateAOTCache\")               \\\n+          \"The configuration file written by -XX:AOTMode=record, and \"      \\\n+          \"loaded by -XX:AOTMode=create. This file contains profiling data \"\\\n+          \"for deciding what contents should be added to AOTCache. \")       \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,1 +192,4 @@\n-\/\/ This is a map of all the original vtptrs. E.g., for\n+\/\/ _orig_cpp_vtptrs and _archived_cpp_vtptrs are used for type checking in\n+\/\/ CppVtables::get_archived_vtable().\n+\/\/\n+\/\/ _orig_cpp_vtptrs is a map of all the original vtptrs. E.g., for\n@@ -195,2 +198,7 @@\n-\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] ==  ((intptr_t**)cp)[0]\n-static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+\/\/     _orig_cpp_vtptrs[ConstantPool_Kind] == ((intptr_t**)cp)[0]\n+\/\/\n+\/\/ _archived_cpp_vtptrs is a map of all the vptprs used by classes in a preimage. E.g., for\n+\/\/    InstanceKlass* k = a class loaded from the preimage;\n+\/\/    ConstantPool* cp = k->constants();\n+\/\/ the following holds true:\n+\/\/     _archived_cpp_vtptrs[ConstantPool_Kind] == ((intptr_t**)cp)[0]\n@@ -198,0 +206,2 @@\n+static intptr_t* _orig_cpp_vtptrs[_num_cloned_vtable_kinds];\n+static intptr_t* _archived_cpp_vtptrs[_num_cloned_vtable_kinds];\n@@ -226,0 +236,6 @@\n+  if (!CDSConfig::is_dumping_final_static_archive()) {\n+    for (int kind = 0; kind < _num_cloned_vtable_kinds; kind++) {\n+      _archived_cpp_vtptrs[kind] = _index[kind]->cloned_vtable();\n+    }\n+  }\n+\n@@ -240,0 +256,10 @@\n+\n+  if (soc->writing() && !CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ This table is written only when creating the preimage. It will be used\n+    \/\/ only when writing the final static archive.\n+    memset(_archived_cpp_vtptrs, 0, sizeof(_archived_cpp_vtptrs));\n+  }\n+\n+  for (int kind = 0; kind < _num_cloned_vtable_kinds; kind++) {\n+    soc->do_ptr(&_archived_cpp_vtptrs[kind]);\n+  }\n@@ -271,1 +297,2 @@\n-      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind]) {\n+      if (vtable_of((Metadata*)obj) == _orig_cpp_vtptrs[kind] ||\n+          vtable_of((Metadata*)obj) == _archived_cpp_vtptrs[kind]) {\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -69,3 +69,3 @@\n-  c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;\n-  c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;\n-  c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;\n+  c |= from_field_is_protected ? RunTimeClassInfo::FROM_FIELD_IS_PROTECTED : 0;\n+  c |= from_is_array           ? RunTimeClassInfo::FROM_IS_ARRAY           : 0;\n+  c |= from_is_object          ? RunTimeClassInfo::FROM_IS_OBJECT          : 0;\n@@ -145,1 +145,1 @@\n-  assert(!k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n@@ -154,1 +154,1 @@\n-  assert(!k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -389,2 +389,3 @@\n-      log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-              \"for testing purposes only and should not be used in a production environment\");\n+      log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+                       \"for testing purposes only and should not be used in a production environment\",\n+                       CDSConfig::type_of_archive_being_loaded());\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -153,0 +153,7 @@\n+void FileMapInfo::free_current_info() {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"only supported in this mode\");\n+  assert(_current_info != nullptr, \"sanity\");\n+  delete _current_info;\n+  assert(_current_info == nullptr, \"sanity\"); \/\/ Side effect expected from the above \"delete\" operator.\n+}\n+\n@@ -200,1 +207,7 @@\n-  set_magic(CDSConfig::is_dumping_dynamic_archive() ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n+  if (CDSConfig::is_dumping_dynamic_archive()) {\n+    set_magic(CDS_DYNAMIC_ARCHIVE_MAGIC);\n+  } else if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    set_magic(CDS_PREIMAGE_ARCHIVE_MAGIC);\n+  } else {\n+    set_magic(CDS_ARCHIVE_MAGIC);\n+  }\n@@ -1061,2 +1074,8 @@\n-        log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-        MetaspaceShared::unrecoverable_loading_error();\n+        if (CDSConfig::is_dumping_final_static_archive()) {\n+          log_error(cds)(\"class path and\/or module path are not compatible with the \"\n+                         \"ones specified when the AOTConfiguration file was recorded%s\", hint_msg);\n+          vm_exit_during_initialization(\"Unable to use create AOT cache.\", nullptr);\n+        } else {\n+          log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+          MetaspaceShared::unrecoverable_loading_error();\n+        }\n@@ -1153,1 +1172,1 @@\n-      log_info(cds)(\"Specified shared archive not found (%s)\", _archive_name);\n+      log_info(cds)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -1164,0 +1183,1 @@\n+    const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -1169,1 +1189,1 @@\n-      log_warning(cds)(\"Unable to read generic CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read generic CDS file map header from %s\", file_type);\n@@ -1174,2 +1194,3 @@\n-        gen_header._magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      log_warning(cds)(\"The shared archive file has a bad magic number: %#x\", gen_header._magic);\n+        gen_header._magic != CDS_DYNAMIC_ARCHIVE_MAGIC &&\n+        gen_header._magic != CDS_PREIMAGE_ARCHIVE_MAGIC) {\n+      log_warning(cds)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n@@ -1180,2 +1201,2 @@\n-      log_warning(cds)(\"Cannot handle shared archive file version 0x%x. Must be at least 0x%x.\",\n-                                 gen_header._version, CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION);\n+      log_warning(cds)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n+                       file_type, gen_header._version, CDS_GENERIC_HEADER_SUPPORTED_MIN_VERSION);\n@@ -1186,2 +1207,2 @@\n-      log_warning(cds)(\"The shared archive file version 0x%x does not match the required version 0x%x.\",\n-                                 gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+      log_warning(cds)(\"The %s version 0x%x does not match the required version 0x%x.\",\n+                       file_type, gen_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n@@ -1202,1 +1223,1 @@\n-      log_warning(cds)(\"Unable to read actual CDS file map header from shared archive\");\n+      log_warning(cds)(\"Unable to read file map header from %s\", file_type);\n@@ -1229,0 +1250,12 @@\n+  bool is_static_archive() const {\n+    return _header->_magic == CDS_ARCHIVE_MAGIC;\n+  }\n+\n+  bool is_dynamic_archive() const {\n+    return _header->_magic == CDS_DYNAMIC_ARCHIVE_MAGIC;\n+  }\n+\n+  bool is_preimage_static_archive() const {\n+    return _header->_magic == CDS_PREIMAGE_ARCHIVE_MAGIC;\n+  }\n+\n@@ -1254,1 +1287,2 @@\n-    if (_header->_magic == CDS_ARCHIVE_MAGIC) {\n+\n+    if (is_static_archive() || is_preimage_static_archive()) {\n@@ -1264,1 +1298,1 @@\n-      assert(_header->_magic == CDS_DYNAMIC_ARCHIVE_MAGIC, \"must be\");\n+      assert(is_dynamic_archive(), \"must be\");\n@@ -1312,1 +1346,6 @@\n-  if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+  switch (header->_magic) {\n+  case CDS_PREIMAGE_ARCHIVE_MAGIC:\n+    return false; \/\/ This is a binary config file, not a proper archive\n+  case CDS_DYNAMIC_ARCHIVE_MAGIC:\n+    break;\n+  default:\n@@ -1330,0 +1369,8 @@\n+bool FileMapInfo::is_preimage_static_archive(const char* file) {\n+  FileHeaderHelper file_helper(file, false);\n+  if (!file_helper.initialize()) {\n+    return false;\n+  }\n+  return file_helper.is_preimage_static_archive();\n+}\n+\n@@ -1340,0 +1387,1 @@\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -1341,2 +1389,9 @@\n-    if (gen_header->_magic != CDS_ARCHIVE_MAGIC) {\n-      log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+    if ((gen_header->_magic == CDS_ARCHIVE_MAGIC) ||\n+        (gen_header->_magic == CDS_PREIMAGE_ARCHIVE_MAGIC && CDSConfig::is_dumping_final_static_archive())) {\n+      \/\/ Good\n+    } else {\n+      if (CDSConfig::new_aot_flags_used()) {\n+        log_warning(cds)(\"Not a valid %s %s\", file_type, _full_path);\n+      } else {\n+        log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+      }\n@@ -1364,1 +1419,1 @@\n-    log_warning(cds)(\"The shared archive file has the wrong version.\");\n+    log_warning(cds)(\"The %s has the wrong version.\", file_type);\n@@ -1383,1 +1438,1 @@\n-      log_warning(cds)(\"The shared archive file has an incorrect header size.\");\n+      log_warning(cds)(\"The %s has an incorrect header size.\", file_type);\n@@ -1400,2 +1455,2 @@\n-    log_warning(cds)(\"The shared archive file was created by a different\"\n-                  \" version or build of HotSpot\");\n+    log_warning(cds)(\"The %s was created by a different\"\n+                  \" version or build of HotSpot\", file_type);\n@@ -1412,1 +1467,1 @@\n-      log_warning(cds)(\"The shared archive file has been truncated.\");\n+      log_warning(cds)(\"The %s has been truncated.\", file_type);\n@@ -1432,1 +1487,4 @@\n-  log_info(cds)(\"trying to map %s\", _full_path);\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n+  const char* info = CDSConfig::is_dumping_final_static_archive() ?\n+    \"AOTConfiguration file \" : \"\";\n+  log_info(cds)(\"trying to map %s%s\", info, _full_path);\n@@ -1436,1 +1494,1 @@\n-      log_info(cds)(\"Specified shared archive not found (%s)\", _full_path);\n+      log_info(cds)(\"Specified %s not found (%s)\", file_type, _full_path);\n@@ -1438,1 +1496,1 @@\n-      log_warning(cds)(\"Failed to open shared archive file (%s)\",\n+      log_warning(cds)(\"Failed to open %s (%s)\", file_type,\n@@ -1443,1 +1501,1 @@\n-    log_info(cds)(\"Opened archive %s.\", _full_path);\n+    log_info(cds)(\"Opened %s %s.\", file_type, _full_path);\n@@ -1456,1 +1514,5 @@\n-    msg.info(\"Dumping shared data to file: \");\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      msg.info(\"Writing binary AOTConfiguration file: \");\n+    } else {\n+      msg.info(\"Dumping shared data to file: \");\n+    }\n@@ -1461,1 +1523,1 @@\n-    chmod(_full_path, _S_IREAD | _S_IWRITE);\n+  chmod(_full_path, _S_IREAD | _S_IWRITE);\n@@ -1467,1 +1529,2 @@\n-  int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, 0444);\n+  int mode = CDSConfig::is_dumping_preimage_static_archive() ? 0666 : 0444;\n+  int fd = os::open(_full_path, O_RDWR | O_CREAT | O_TRUNC | O_BINARY, mode);\n@@ -1469,1 +1532,1 @@\n-    log_error(cds)(\"Unable to create shared archive file %s: (%s).\", _full_path,\n+    log_error(cds)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n@@ -1725,1 +1788,8 @@\n-    MetaspaceShared::writing_error(\"Unable to write to shared archive file.\");\n+\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      MetaspaceShared::writing_error(\"Unable to write to AOT configuration file.\");\n+    } else if (CDSConfig::new_aot_flags_used()) {\n+      MetaspaceShared::writing_error(\"Unable to write to AOT cache.\");\n+    } else {\n+      MetaspaceShared::writing_error(\"Unable to write to shared archive.\");\n+    }\n@@ -2570,0 +2640,1 @@\n+  const char* file_type = CDSConfig::type_of_archive_being_loaded();\n@@ -2571,1 +2642,1 @@\n-    log_info(cds)(\"The shared archive file's ObjectAlignmentInBytes of %d\"\n+    log_info(cds)(\"The %s's ObjectAlignmentInBytes of %d\"\n@@ -2573,1 +2644,1 @@\n-                  _obj_alignment, ObjectAlignmentInBytes);\n+                  file_type, _obj_alignment, ObjectAlignmentInBytes);\n@@ -2577,2 +2648,2 @@\n-    log_info(cds)(\"The shared archive file's CompactStrings setting (%s)\"\n-                  \" does not equal the current CompactStrings setting (%s).\",\n+    log_info(cds)(\"The %s's CompactStrings setting (%s)\"\n+                  \" does not equal the current CompactStrings setting (%s).\", file_type,\n@@ -2602,2 +2673,2 @@\n-    log_info(cds)(\"The shared archive file's BytecodeVerificationLocal setting (%s)\"\n-                               \" does not equal the current BytecodeVerificationLocal setting (%s).\",\n+    log_info(cds)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+                               \" does not equal the current BytecodeVerificationLocal setting (%s).\", file_type,\n@@ -2614,2 +2685,2 @@\n-    log_info(cds)(\"The shared archive file was created with less restrictive \"\n-                               \"verification setting than the current setting.\");\n+    log_info(cds)(\"The %s was created with less restrictive \"\n+                               \"verification setting than the current setting.\", file_type);\n@@ -2627,1 +2698,1 @@\n-                               \"from the setting in the shared archive.\");\n+                               \"from the setting in the %s.\", file_type);\n@@ -2632,2 +2703,2 @@\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n+    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\", file_type);\n@@ -2636,2 +2707,2 @@\n-  log_info(cds)(\"Archive was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n-                          compressed_oops(), compressed_class_pointers(), compact_headers());\n+  log_info(cds)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n+                          file_type, compressed_oops(), compressed_class_pointers(), compact_headers());\n@@ -2639,2 +2710,2 @@\n-    log_warning(cds)(\"Unable to use shared archive.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n-                               \"different from runtime, CDS will be disabled.\");\n+    log_warning(cds)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+                               \"different from runtime, CDS will be disabled.\", file_type);\n@@ -2645,2 +2716,2 @@\n-    log_warning(cds)(\"Unable to use shared archive.\\nThe shared archive file's UseCompactObjectHeaders setting (%s)\"\n-                     \" does not equal the current UseCompactObjectHeaders setting (%s).\",\n+    log_warning(cds)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n+                     \" does not equal the current UseCompactObjectHeaders setting (%s).\", file_type, file_type,\n@@ -2652,1 +2723,1 @@\n-  if (!_use_optimized_module_handling) {\n+  if (!_use_optimized_module_handling && !CDSConfig::is_dumping_final_static_archive()) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":120,"deletions":49,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -378,0 +378,1 @@\n+  static bool is_preimage_static_archive(const char* file);\n@@ -391,0 +392,1 @@\n+  static void free_current_info();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/finalImageRecipes.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+static FinalImageRecipes* _final_image_recipes = nullptr;\n+\n+void* FinalImageRecipes::operator new(size_t size) throw() {\n+  return ArchiveBuilder::current()->ro_region_alloc(size);\n+}\n+\n+void FinalImageRecipes::record_recipes_impl() {\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"must be\");\n+  ResourceMark rm;\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+\n+  \/\/ Record the indys that have been resolved in the training run. These indys will be\n+  \/\/ resolved during the final image assembly.\n+\n+  GrowableArray<InstanceKlass*> tmp_indy_klasses;\n+  GrowableArray<Array<int>*> tmp_indy_cp_indices;\n+  int total_indys_to_resolve = 0;\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* k = klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      GrowableArray<int> indices;\n+\n+      if (ik->constants()->cache() != nullptr) {\n+        Array<ResolvedIndyEntry>* tmp_indy_entries = ik->constants()->cache()->resolved_indy_entries();\n+        if (tmp_indy_entries != nullptr) {\n+          for (int i = 0; i < tmp_indy_entries->length(); i++) {\n+            ResolvedIndyEntry* rie = tmp_indy_entries->adr_at(i);\n+            int cp_index = rie->constant_pool_index();\n+            if (rie->is_resolved()) {\n+              indices.append(cp_index);\n+            }\n+          }\n+        }\n+      }\n+\n+      if (indices.length() > 0) {\n+        tmp_indy_klasses.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n+        tmp_indy_cp_indices.append(ArchiveUtils::archive_array(&indices));\n+        total_indys_to_resolve += indices.length();\n+      }\n+    }\n+  }\n+\n+  _all_klasses = ArchiveUtils::archive_array(klasses);\n+  ArchivePtrMarker::mark_pointer(&_all_klasses);\n+\n+  assert(tmp_indy_klasses.length() == tmp_indy_cp_indices.length(), \"must be\");\n+  if (tmp_indy_klasses.length() > 0) {\n+    _indy_klasses = ArchiveUtils::archive_array(&tmp_indy_klasses);\n+    _indy_cp_indices = ArchiveUtils::archive_array(&tmp_indy_cp_indices);\n+\n+    ArchivePtrMarker::mark_pointer(&_indy_klasses);\n+    ArchivePtrMarker::mark_pointer(&_indy_cp_indices);\n+  }\n+  log_info(cds)(\"%d indies in %d classes will be resolved in final CDS image\", total_indys_to_resolve, tmp_indy_klasses.length());\n+}\n+\n+void FinalImageRecipes::load_all_classes(TRAPS) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"sanity\");\n+  Handle class_loader(THREAD, SystemDictionary::java_system_loader());\n+  for (int i = 0; i < _all_klasses->length(); i++) {\n+    Klass* k = _all_klasses->at(i);\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      if (!ik->is_shared_unregistered_class() && !ik->is_hidden()) {\n+        Klass* actual = SystemDictionary::resolve_or_fail(ik->name(), class_loader, true, CHECK);\n+        if (actual != ik) {\n+          ResourceMark rm(THREAD);\n+          log_error(cds)(\"Unable to resolve class from CDS archive: %s\", ik->external_name());\n+          log_error(cds)(\"Expected: \" INTPTR_FORMAT \", actual: \" INTPTR_FORMAT, p2i(ik), p2i(actual));\n+          log_error(cds)(\"Please check if your VM command-line is the same as in the training run\");\n+          MetaspaceShared::unrecoverable_writing_error();\n+        }\n+        assert(ik->is_loaded(), \"must be\");\n+        ik->link_class(CHECK);\n+      }\n+    }\n+  }\n+}\n+\n+void FinalImageRecipes::apply_recipes_for_invokedynamic(TRAPS) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+\n+  if (CDSConfig::is_dumping_invokedynamic() && _indy_klasses != nullptr) {\n+    assert(_indy_cp_indices != nullptr, \"must be\");\n+    for (int i = 0; i < _indy_klasses->length(); i++) {\n+      InstanceKlass* ik = _indy_klasses->at(i);\n+      ConstantPool* cp = ik->constants();\n+      Array<int>* cp_indices = _indy_cp_indices->at(i);\n+      GrowableArray<bool> preresolve_list(cp->length(), cp->length(), false);\n+      for (int j = 0; j < cp_indices->length(); j++) {\n+        preresolve_list.at_put(cp_indices->at(j), true);\n+      }\n+      AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n+    }\n+  }\n+}\n+\n+void FinalImageRecipes::record_recipes() {\n+  _final_image_recipes = new FinalImageRecipes();\n+  _final_image_recipes->record_recipes_impl();\n+}\n+\n+void FinalImageRecipes::apply_recipes(TRAPS) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  if (_final_image_recipes != nullptr) {\n+    _final_image_recipes->apply_recipes_impl(THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+      log_error(cds)(\"Please check if your VM command-line is the same as in the training run\");\n+      MetaspaceShared::unrecoverable_writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n+    }\n+  }\n+\n+  \/\/ Set it to null as we don't need to write this table into the final image.\n+  _final_image_recipes = nullptr;\n+}\n+\n+void FinalImageRecipes::apply_recipes_impl(TRAPS) {\n+  load_all_classes(CHECK);\n+  apply_recipes_for_invokedynamic(CHECK);\n+}\n+\n+void FinalImageRecipes::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_final_image_recipes);\n+}\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_FINALIMAGERECIPES_HPP\n+#define SHARE_CDS_FINALIMAGERECIPES_HPP\n+\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class InstanceKlass;\n+class Klass;\n+\n+template <typename T> class GrowableArray;\n+template <typename T> class Array;\n+\n+\/\/ This class is used for transferring information from the AOTConfiguration file (aka the \"preimage\")\n+\/\/ to the JVM that creates the AOTCache (aka the \"final image\").\n+\/\/   - The recipes are recorded when CDSConfig::is_dumping_preimage_static_archive() is true.\n+\/\/   - The recipes are applied when CDSConfig::is_dumping_final_static_archive() is true.\n+\/\/ The following information are recorded:\n+\/\/   - The list of all classes that are stored in the AOTConfiguration file.\n+\/\/   - The list of all classes that require AOT resolution of invokedynamic call sites.\n+class FinalImageRecipes {\n+  \/\/ A list of all the archived classes from the preimage. We want to transfer all of these\n+  \/\/ into the final image.\n+  Array<Klass*>* _all_klasses;\n+\n+  \/\/ The classes who have resolved at least one indy CP entry during the training run.\n+  \/\/ _indy_cp_indices[i] is a list of all resolved CP entries for _indy_klasses[i].\n+  Array<InstanceKlass*>* _indy_klasses;\n+  Array<Array<int>*>*    _indy_cp_indices;\n+\n+  FinalImageRecipes() : _indy_klasses(nullptr), _indy_cp_indices(nullptr) {}\n+\n+  void* operator new(size_t size) throw();\n+\n+  \/\/ Called when dumping preimage\n+  void record_recipes_impl();\n+\n+  \/\/ Called when dumping final image\n+  void apply_recipes_impl(TRAPS);\n+  void load_all_classes(TRAPS);\n+  void apply_recipes_for_invokedynamic(TRAPS);\n+\n+public:\n+  static void serialize(SerializeClosure* soc);\n+\n+  \/\/ Called when dumping preimage\n+  static void record_recipes();\n+\n+  \/\/ Called when dumping final image\n+  static void apply_recipes(TRAPS);\n+};\n+\n+#endif \/\/ SHARE_CDS_FINALIMAGERECIPES_HPP\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -403,0 +403,5 @@\n+void HeapShared::init_dumping() {\n+  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n+}\n+\n@@ -411,2 +416,0 @@\n-  _scratch_java_mirror_table = new (mtClass)MetaspaceObjToOopHandleTable();\n-  _scratch_references_table = new (mtClass)MetaspaceObjToOopHandleTable();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -408,0 +408,1 @@\n+  static void init_dumping() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -266,0 +266,4 @@\n+  if (soc->reading() && CDSConfig::is_dumping_final_static_archive()) {\n+    LambdaFormInvokers::read_static_archive_invokers();\n+    _static_archive_invokers = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"cds\/finalImageRecipes.hpp\"\n@@ -502,0 +503,1 @@\n+  FinalImageRecipes::serialize(soc);\n@@ -622,0 +624,3 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    FinalImageRecipes::record_recipes();\n+  }\n@@ -637,1 +642,3 @@\n-  guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+  if (!CDSConfig::is_dumping_final_static_archive()) {\n+    guarantee(!CDSConfig::is_using_archive(), \"We should not be using an archive when we dump\");\n+  }\n@@ -691,1 +698,7 @@\n-  const char* static_archive = CDSConfig::static_archive_path();\n+  const char* static_archive;\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    static_archive = AOTCache;\n+    FileMapInfo::free_current_info();\n+  } else {\n+    static_archive = CDSConfig::static_archive_path();\n+  }\n@@ -754,1 +767,1 @@\n-  if (!jcmd_request) {\n+  if (!jcmd_request && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -789,0 +802,4 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    FinalImageRecipes::apply_recipes(CHECK);\n+  }\n@@ -816,7 +833,12 @@\n-  if (!CDSConfig::old_cds_flags_used()) {\n-    \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n-    \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n-    \/\/ to the JLI launcher, as the launcher will fail when trying to\n-    \/\/ run the main class, which is not what we want.\n-    tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n-    vm_exit(0);\n+  if (CDSConfig::new_aot_flags_used()) {\n+    if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      tty->print_cr(\"AOTConfiguration recorded: %s\", AOTConfiguration);\n+      vm_exit(0);\n+    } else {\n+      \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n+      \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n+      \/\/ to the JLI launcher, as the launcher will fail when trying to\n+      \/\/ run the main class, which is not what we want.\n+      tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n+      vm_exit(0);\n+    }\n@@ -922,1 +944,10 @@\n-  preload_classes(CHECK);\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ We are running with -Xshare:dump\n+    preload_classes(CHECK);\n+\n+    if (SharedArchiveConfigFile) {\n+      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+      read_extra_data(THREAD, SharedArchiveConfigFile);\n+      log_info(cds)(\"Reading extra data: done.\");\n+    }\n+  }\n@@ -924,4 +955,17 @@\n-  if (SharedArchiveConfigFile) {\n-    log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n-    read_extra_data(THREAD, SharedArchiveConfigFile);\n-    log_info(cds)(\"Reading extra data: done.\");\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    log_info(cds)(\"Reading lambda form invokers from JDK default classlist ...\");\n+    char default_classlist[JVM_MAXPATHLEN];\n+    get_default_classlist(default_classlist, sizeof(default_classlist));\n+    struct stat statbuf;\n+    if (os::stat(default_classlist, &statbuf) == 0) {\n+      ClassListParser::parse_classlist(default_classlist,\n+                                       ClassListParser::_parse_lambda_forms_invokers_only, CHECK);\n+    }\n+  }\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    if (ExtraSharedClassListFile) {\n+      log_info(cds)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n+      ClassListParser::parse_classlist(ExtraSharedClassListFile,\n+                                       ClassListParser::_parse_all, CHECK);\n+    }\n@@ -1004,2 +1048,2 @@\n-    log_warning(cds)(\"This archive was created with AllowArchivingWithJavaAgent. It should be used \"\n-            \"for testing purposes only and should not be used in a production environment\");\n+    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+            \"for testing purposes only and should not be used in a production environment\", CDSConfig::type_of_archive_being_loaded());\n@@ -1015,1 +1059,7 @@\n-  if (!ik->is_shared() && ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n+\n+  if (ik->is_shared() && !CDSConfig::is_dumping_final_static_archive()) {\n+    assert(CDSConfig::is_dumping_dynamic_archive(), \"must be\");\n+    return false;\n+  }\n+\n+  if (ik->is_loaded() && !ik->is_linked() && ik->can_be_verified_at_dumptime() &&\n@@ -1083,1 +1133,1 @@\n-  log_error(cds)(\"An error has occurred while processing the shared archive file.\");\n+  log_error(cds)(\"An error has occurred while processing the %s.\", CDSConfig::type_of_archive_being_loaded());\n@@ -1087,1 +1137,8 @@\n-  vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    vm_exit_during_initialization(\"Must be a valid AOT configuration generated by the current JVM\", AOTConfiguration);\n+  } else if (CDSConfig::new_aot_flags_used()) {\n+    vm_exit_during_initialization(\"Unable to use AOT cache.\", nullptr);\n+  } else {\n+    vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+  }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":77,"deletions":20,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,7 @@\n-public:\n+ public:\n+ enum : char {\n+    FROM_FIELD_IS_PROTECTED = 1 << 0,\n+    FROM_IS_ARRAY           = 1 << 1,\n+    FROM_IS_OBJECT          = 1 << 2\n+  };\n+\n@@ -205,0 +211,11 @@\n+  bool from_field_is_protected(int i) {\n+    return (verifier_constraint_flag(i) & FROM_FIELD_IS_PROTECTED) != 0;\n+  }\n+\n+  bool from_is_array(int i) {\n+    return (verifier_constraint_flag(i) & FROM_IS_ARRAY) != 0;\n+  }\n+  bool from_is_object(int i) {\n+    return (verifier_constraint_flag(i) & FROM_IS_OBJECT) != 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -416,1 +416,7 @@\n-  assert(archived_entry->shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    OopHandle null_handle;\n+    archived_entry->_shared_pd = null_handle;\n+  } else {\n+    assert(archived_entry->shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1179,0 +1179,4 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    SystemDictionaryShared::init_dumptime_info_from_preimage(ik);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-  assert(!k->is_shared(), \"sanity\");\n@@ -202,1 +201,0 @@\n-  assert(!k->is_shared(), \"sanity\");\n@@ -209,1 +207,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(k)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n@@ -212,1 +210,0 @@\n-    assert(CDSConfig::is_dumping_dynamic_archive(), \"must be\");\n@@ -280,0 +277,5 @@\n+  if (CDSConfig::is_dumping_final_static_archive() && k->is_shared_unregistered_class()\n+      && k->is_shared()) {\n+    return false; \/\/ Do not exclude: unregistered classes are passed from preimage to final image.\n+  }\n+\n@@ -332,0 +334,4 @@\n+    } else if (CDSConfig::is_dumping_preimage_static_archive()) {\n+      \/\/ When dumping the final static archive, we will unconditionally load and link all\n+      \/\/ classes from tje preimage. We don't want to get a VerifyError when linking this class.\n+      return warn_excluded(k, \"Unlinked class not supported by AOTConfiguration\");\n@@ -500,0 +506,3 @@\n+    if (CDSConfig::is_dumping_heap()) {\n+      HeapShared::init_dumping();\n+    }\n@@ -540,0 +549,12 @@\n+void SystemDictionaryShared::init_dumptime_info_from_preimage(InstanceKlass* k) {\n+  init_dumptime_info(k);\n+  copy_verification_constraints_from_preimage(k);\n+  copy_linking_constraints_from_preimage(k);\n+\n+  if (SystemDictionary::is_platform_class_loader(k->class_loader())) {\n+    ClassLoaderExt::set_has_platform_classes();\n+  } else if (SystemDictionary::is_system_class_loader(k->class_loader())) {\n+    ClassLoaderExt::set_has_app_classes();\n+  }\n+}\n+\n@@ -726,1 +747,4 @@\n-    if (k->is_loader_alive() && !info.is_excluded()) {\n+    if (CDSConfig::is_dumping_final_static_archive() && !k->is_loaded()) {\n+      assert(k->is_shared_unregistered_class(), \"must be\");\n+      info.metaspace_pointers_do(it);\n+    } else if (k->is_loader_alive() && !info.is_excluded()) {\n@@ -798,0 +822,4 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ Information about lambda proxies are recorded in FinalImageRecipes.\n+    return;\n+  }\n@@ -835,0 +863,4 @@\n+  if (CDSConfig::is_dumping_final_static_archive()) {\n+    return nullptr;\n+  }\n+\n@@ -959,1 +991,1 @@\n-  assert(!CDSConfig::is_dumping_static_archive() && CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n+  assert(CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n@@ -968,1 +1000,0 @@\n-      char c            = record->verifier_constraint_flag(i);\n@@ -974,1 +1005,1 @@\n-                                     name->as_klass_external_name(), c);\n+                                     name->as_klass_external_name(), record->verifier_constraint_flag(i));\n@@ -977,6 +1008,2 @@\n-      bool from_field_is_protected = (c & SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;\n-      bool from_is_array           = (c & SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;\n-      bool from_is_object          = (c & SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;\n-\n-      bool ok = VerificationType::resolve_and_check_assignability(klass, name,\n-         from_name, from_field_is_protected, from_is_array, from_is_object, CHECK);\n+      bool ok = VerificationType::resolve_and_check_assignability(klass, name, from_name,\n+         record->from_field_is_protected(i), record->from_is_array(i), record->from_is_object(i), CHECK);\n@@ -998,0 +1025,18 @@\n+void SystemDictionaryShared::copy_verification_constraints_from_preimage(InstanceKlass* klass) {\n+  assert(CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n+  DumpTimeClassInfo* dt_info = get_info(klass);\n+  RunTimeClassInfo* rt_info = RunTimeClassInfo::get_for(klass); \/\/ from preimage\n+\n+  int length = rt_info->num_verifier_constraints();\n+  if (length > 0) {\n+    for (int i = 0; i < length; i++) {\n+      RunTimeClassInfo::RTVerifierConstraint* vc = rt_info->verifier_constraint_at(i);\n+      Symbol* name      = vc->name();\n+      Symbol* from_name = vc->from_name();\n+\n+      dt_info->add_verification_constraint(klass, name, from_name,\n+         rt_info->from_field_is_protected(i), rt_info->from_is_array(i), rt_info->from_is_object(i));\n+    }\n+  }\n+}\n+\n@@ -1069,1 +1114,1 @@\n-  assert(!CDSConfig::is_dumping_static_archive() && CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n+  assert(CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n@@ -1115,0 +1160,18 @@\n+void SystemDictionaryShared::copy_linking_constraints_from_preimage(InstanceKlass* klass) {\n+  assert(CDSConfig::is_using_archive(), \"called at run time with CDS enabled only\");\n+  JavaThread* current = JavaThread::current();\n+  if (klass->is_shared_platform_class() || klass->is_shared_app_class()) {\n+    RunTimeClassInfo* rt_info = RunTimeClassInfo::get_for(klass); \/\/ from preimage\n+\n+    if (rt_info->num_loader_constraints() > 0) {\n+      for (int i = 0; i < rt_info->num_loader_constraints(); i++) {\n+        RunTimeClassInfo::RTLoaderConstraint* lc = rt_info->loader_constraint_at(i);\n+        Symbol* name = lc->constraint_name();\n+        Handle loader1(current, get_class_loader_by(lc->_loader_type1));\n+        Handle loader2(current, get_class_loader_by(lc->_loader_type2));\n+        record_linking_constraint(name, klass, loader1, loader2);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":78,"deletions":15,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -155,7 +155,0 @@\n-public:\n-  enum : char {\n-    FROM_FIELD_IS_PROTECTED = 1 << 0,\n-    FROM_IS_ARRAY           = 1 << 1,\n-    FROM_IS_OBJECT          = 1 << 2\n-  };\n-\n@@ -202,0 +195,3 @@\n+  static void copy_verification_constraints_from_preimage(InstanceKlass* klass);\n+  static void copy_linking_constraints_from_preimage(InstanceKlass* klass);\n+\n@@ -232,0 +228,1 @@\n+  static void init_dumptime_info_from_preimage(InstanceKlass* k) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#define CDS_PREIMAGE_ARCHIVE_MAGIC 0xcafea07c\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -719,1 +719,0 @@\n-    assert(!CDSConfig::is_using_archive(), \"sanity\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -457,0 +457,5 @@\n+\n+  if (CDSConfig::is_dumping_final_static_archive() && resolved_references() != nullptr) {\n+    objArrayOop scratch_references = oopFactory::new_objArray(vmClasses::Object_klass(), resolved_references()->length(), CHECK);\n+    HeapShared::add_scratch_resolved_references(this, scratch_references);\n+  }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2710,0 +2710,1 @@\n+  DEBUG_ONLY(_shared_class_load_count = 0);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1368,3 +1368,7 @@\n-    jio_fprintf(defaultStream::error_stream(),\n-      \"Class data sharing is inconsistent with other specified options.\\n\");\n-    vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    log_error(cds)(\"%s is incompatible with other specified options.\",\n+                   CDSConfig::new_aot_flags_used() ? \"AOT cache\" : \"CDS\");\n+    if (CDSConfig::new_aot_flags_used()) {\n+      vm_exit_during_initialization(\"Unable to use AOT cache\", message);\n+    } else {\n+      vm_exit_during_initialization(\"Unable to use shared archive\", message);\n+    }\n@@ -1372,1 +1376,5 @@\n-    log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    if (CDSConfig::new_aot_flags_used()) {\n+      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+    } else {\n+      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -443,0 +444,4 @@\n+\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    MetaspaceShared::preload_and_dump(thread);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -865,1 +865,5 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::is_dumping_classic_static_archive()) {\n+    \/\/ Classic -Xshare:dump, aka \"old workflow\"\n+    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+  } else if (CDSConfig::is_dumping_final_static_archive()) {\n+    tty->print_cr(\"Reading AOTConfiguration %s and writing AOTCache %s\", AOTConfiguration, AOTCache);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        out.shouldContain(\"Specified shared archive not found\")\n+        out.shouldContain(\"Specified shared archive file not found\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/ArchiveDoesNotExist.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-        \/\/ (1) Training Run\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Training Run\");\n@@ -56,0 +57,1 @@\n+            \"-Xlog:cds=debug\",\n@@ -60,0 +62,1 @@\n+        out.shouldContain(\"AOTConfiguration recorded: \" + aotConfigFile);\n@@ -62,1 +65,2 @@\n-        \/\/ (2) Assembly Phase (AOTClassLinking unspecified -> should be enabled by default)\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Assembly Phase (AOTClassLinking unspecified -> should be enabled by default)\");\n@@ -74,1 +78,2 @@\n-        \/\/ (3) Production Run with AOTCache\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Production Run with AOTCache\");\n@@ -81,1 +86,1 @@\n-        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Opened AOT cache hello.aot.\");\n@@ -85,1 +90,2 @@\n-        \/\/ (4) AOTMode=off\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTMode=off\");\n@@ -94,1 +100,1 @@\n-        out.shouldNotContain(\"Opened archive hello.aot.\");\n+        out.shouldNotContain(\"Opened AOT cache hello.aot.\");\n@@ -98,1 +104,2 @@\n-        \/\/ (5) AOTMode=auto\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTMode=auto\");\n@@ -107,1 +114,1 @@\n-        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Opened AOT cache hello.aot.\");\n@@ -111,1 +118,2 @@\n-        \/\/ (6) AOTMode=on\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTMode=on\");\n@@ -120,1 +128,1 @@\n-        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Opened AOT cache hello.aot.\");\n@@ -124,1 +132,2 @@\n-        \/\/ (7) Assembly Phase with -XX:-AOTClassLinking\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Assembly Phase with -XX:-AOTClassLinking\");\n@@ -137,1 +146,2 @@\n-        \/\/ (8) Production Run with AOTCache, which was created with -XX:-AOTClassLinking\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Production Run with AOTCache, which was created with -XX:-AOTClassLinking\");\n@@ -144,1 +154,1 @@\n-        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Opened AOT cache hello.aot.\");\n@@ -150,1 +160,2 @@\n-        \/\/ (1) Mixing old and new options\n+       \/\/----------------------------------------------------------------------\n+        printTestCase(\"Mixing old and new options\");\n@@ -172,1 +183,2 @@\n-        \/\/ (2) Use AOTConfiguration without AOTMode\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Use AOTConfiguration without AOTMode\");\n@@ -181,1 +193,2 @@\n-        \/\/ (3) Use AOTMode without AOTConfiguration\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Use AOTMode without AOTConfiguration\");\n@@ -197,1 +210,2 @@\n-        \/\/ (4) Bad AOTMode\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Bad AOTMode\");\n@@ -206,1 +220,2 @@\n-        \/\/ (5) AOTCache specified with -XX:AOTMode=record\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTCache specified with -XX:AOTMode=record\");\n@@ -217,1 +232,2 @@\n-        \/\/ (5) AOTCache not specified with -XX:AOTMode=create\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTCache not specified with -XX:AOTMode=create\");\n@@ -227,0 +243,64 @@\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"No such config file\");\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-XX:AOTConfiguration=no-such-file\",\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Must be a valid AOT configuration generated by the current JVM: no-such-file\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"AOTConfiguration file cannot be used as a CDS archive\");\n+\n+        \/\/ first make sure we have a valid aotConfigFile\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"train\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ Cannot use this config file as a AOT cache\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=on\",\n+            \"-XX:AOTCache=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Not a valid AOT cache (hello.aotconfig)\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ Cannot use this config file as a CDS archive\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-Xshare:on\",\n+            \"-XX:SharedArchiveFile=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Not a valid archive (hello.aotconfig)\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/----------------------------------------------------------------------\n+        printTestCase(\"Classpath mismatch when creating archive\");\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-cp\", \"noSuchJar.jar\");\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"class path and\/or module path are not compatible with the ones \" +\n+                          \"specified when the AOTConfiguration file was recorded\");\n+        out.shouldContain(\"Unable to use create AOT cache\");\n+        out.shouldHaveExitValue(1);\n+    }\n+\n+    static int testNum = 0;\n+    static void printTestCase(String s) {\n+        System.out.println(\"vvvvvvv TEST CASE \" + testNum + \": \" + s + \" starts here vvvvvvv\");\n+        testNum++;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/AOTFlags.java","additions":99,"deletions":19,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test Make sure loader constraints are passed from AOT preimage to final image.\n+ * @bug 8348426\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build AOTLoaderConstraintsTest BootClass\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar boot.jar BootClass\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar AOTLoaderConstraintsTestApp.jar AOTLoaderConstraintsTestApp AppClass\n+ * @run driver AOTLoaderConstraintsTest AOT\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTLoaderConstraintsTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"AOTLoaderConstraintsTestApp.jar\");\n+    static final String mainClass = \"AOTLoaderConstraintsTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        t.run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xbootclasspath\/a:boot.jar\",\n+                \"-Xlog:class+loader+constraints=debug\",\n+                \"-Xlog:class+path=debug\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY:   \/\/ JEP 485 + binary AOTConfiguration -- should load AppClass from preimage\n+            case RunMode.PRODUCTION:\n+                out.shouldContain(\"CDS add loader constraint for class AppClass symbol java\/lang\/String loader[0] 'app' loader[1] 'bootstrap'\");\n+            }\n+        }\n+    }\n+}\n+\n+class AOTLoaderConstraintsTestApp {\n+    public static void main(String args[]) throws Exception {\n+        AppClass obj = new AppClass();\n+        obj.func(\"Hello\");\n+    }\n+}\n+\n+class AppClass extends BootClass {\n+    @Override\n+    public void func(String s) {\n+        \/\/ This method overrides BootClass, which is loaded by the boot loader.\n+        \/\/ AppClass is loaded by the app loader. To make sure that you cannot use\n+        \/\/ type masquerade attacks, we need to add a loader constraint that says:\n+        \/\/  app and boot loaders must resolve the symbol \"java\/lang\/String\" to the same type.\n+        super.func(s + \" From AppClass\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTLoaderConstraintsTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This is a test class to be loaded by the boot loader.\n+public class BootClass {\n+    public void func(String s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BootClass.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -56,0 +56,13 @@\n+\/*\n+ * @test id=aot\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build InitiatingLoaderTester BadOldClassA BadOldClassB\n+ * @build BulkLoaderTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n+ *                 BadOldClassA BadOldClassB\n+ * @run driver BulkLoaderTest AOT\n+ *\/\n+\n@@ -125,0 +138,7 @@\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (isAOTWorkflow() && runMode == RunMode.TRAINING) {\n+                out.shouldContain(\"Skipping BadOldClassA: Unlinked class not supported by AOTConfiguration\");\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,9 @@\n+\/*\n+ * @test id=aot\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @summary Run JavacBenchApp with AOT cache (JEP 483)\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench AOT\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBench.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,1 @@\n-               \"Specified shared archive not found (\" + nonExistBase + \")\");\n+               \"Specified shared archive file not found (\" + nonExistBase + \")\");\n@@ -215,1 +215,1 @@\n-               \"Specified shared archive not found (\" + nonExistTop + \")\");\n+               \"Specified shared archive file not found (\" + nonExistTop + \")\");\n@@ -220,1 +220,1 @@\n-               \"Specified shared archive not found (\" + nonExistBase + \")\");\n+               \"Specified shared archive file not found (\" + nonExistBase + \")\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -666,1 +666,1 @@\n-                 output.shouldContain(\"Specified shared archive not found (\" + nonExistTop + \")\")\n+                 output.shouldContain(\"Specified shared archive file not found (\" + nonExistTop + \")\")\n@@ -691,1 +691,1 @@\n-                 output.shouldContain(\"Specified shared archive not found (\" + nonExistBase + \")\")\n+                 output.shouldContain(\"Specified shared archive file not found (\" + nonExistBase + \")\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchive.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-        output.shouldContain(\"Specified shared archive not found\");\n+        output.shouldContain(\"Specified shared archive file not found\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        \"This archive was created with AllowArchivingWithJavaAgent\",\n+        \"This shared archive file was created with AllowArchivingWithJavaAgent\",\n@@ -56,2 +56,1 @@\n-        \"The setting of the AllowArchivingWithJavaAgent is different from the setting in the shared archive.\";\n-\n+        \"The setting of the AllowArchivingWithJavaAgent is different from the setting in the shared archive file.\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/dumpingWithAgent\/DumpingWithJavaAgent.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+    private final String aotConfigurationFile;\n+    private final String aotConfigurationFileLog;\n@@ -45,0 +47,2 @@\n+    private final String aotCacheFile;\n+    private final String aotCacheFileLog;\n@@ -59,0 +63,2 @@\n+        aotConfigurationFile = name() + \".aotconfig\";\n+        aotConfigurationFileLog = aotConfigurationFile + \".log\";\n@@ -61,0 +67,2 @@\n+        aotCacheFile = name() + \".aot\";\n+        aotCacheFileLog = aotCacheFile + \".log\";\n@@ -77,0 +85,1 @@\n+        AOT,           \/\/ JEP 483 Ahead-of-Time Class Loading & Linking\n@@ -80,4 +89,5 @@\n-        CLASSLIST,\n-        DUMP_STATIC,\n-        DUMP_DYNAMIC,\n-        PRODUCTION;\n+        TRAINING,       \/\/ -XX:DumpLoadedClassList OR {-XX:AOTMode=create -XX:AOTConfiguration}\n+        DUMP_STATIC,    \/\/ -Xshare:dump\n+        DUMP_DYNAMIC,   \/\/ -XX:ArchiveClassesArExit\n+        ASSEMBLY,       \/\/ JEP 483\n+        PRODUCTION;     \/\/ Running with the CDS archive produced from the above steps\n@@ -129,0 +139,4 @@\n+    public final boolean isAOTWorkflow() {\n+        return workflow == Workflow.AOT;\n+    }\n+\n@@ -166,0 +180,12 @@\n+    private OutputAnalyzer recordAOTConfiguration() throws Exception {\n+        RunMode runMode = RunMode.TRAINING;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-XX:AOTMode=record\",\n+                                                   \"-XX:AOTConfiguration=\" + aotConfigurationFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(aotConfigurationFileLog,\n+                                                             \"class+load=debug\"));\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, aotConfigurationFile, aotConfigurationFileLog);\n+    }\n+\n@@ -167,1 +193,1 @@\n-        RunMode runMode = RunMode.CLASSLIST;\n+        RunMode runMode = RunMode.TRAINING;\n@@ -195,0 +221,17 @@\n+    private OutputAnalyzer createAOTCache() throws Exception {\n+        RunMode runMode = RunMode.ASSEMBLY;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-Xlog:cds\",\n+                                                   \"-Xlog:cds+heap=error\",\n+                                                   \"-XX:AOTMode=create\",\n+                                                   \"-XX:AOTConfiguration=\" + aotConfigurationFile,\n+                                                   \"-XX:AOTCache=\" + aotCacheFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(aotCacheFileLog,\n+                                                             \"cds=debug\",\n+                                                             \"cds+class=debug\",\n+                                                             \"cds+heap=warning\",\n+                                                             \"cds+resolve=debug\"));\n+        return executeAndCheck(cmdLine, runMode, aotCacheFile, aotCacheFileLog);\n+    }\n+\n@@ -267,0 +310,2 @@\n+       } else if (isAOTWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:AOTMode=on\", \"-XX:AOTCache=\" + aotCacheFile);\n@@ -299,0 +344,2 @@\n+            } else if (args[0].equals(\"AOT\")) {\n+                runAOTWorkflow();\n@@ -317,0 +364,8 @@\n+\n+    \/\/ See JEP 485\n+    private void runAOTWorkflow() throws Exception {\n+        this.workflow = Workflow.AOT;\n+        recordAOTConfiguration();\n+        createAOTCache();\n+        productionRun();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"}]}