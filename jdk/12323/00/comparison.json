{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-\/\/ interpreter_frame != NULL:\n+\/\/ interpreter_frame != nullptr:\n@@ -99,1 +99,1 @@\n-\/\/   The frame interpreter_frame, if not NULL, is guaranteed to be the\n+\/\/   The frame interpreter_frame, if not null, is guaranteed to be the\n","filename":"src\/hotspot\/cpu\/ppc\/abstractInterpreter_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  AddressLiteral() : _address(NULL), _rspec() {}\n+  AddressLiteral() : _address(nullptr), _rspec() {}\n@@ -1352,1 +1352,1 @@\n-  inline address emit_addr(const address addr = NULL);\n+  inline address emit_addr(const address addr = nullptr);\n@@ -1356,1 +1356,1 @@\n-  \/\/ and ENV. If the entry point is NULL, the descriptor will point\n+  \/\/ and ENV. If the entry point is null, the descriptor will point\n@@ -1359,1 +1359,1 @@\n-  inline address emit_fd(address entry = NULL,\n+  inline address emit_fd(address entry = nullptr,\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-\/\/ ENV. If the entry point is NULL, the descriptor will point just\n+\/\/ ENV. If the entry point is null, the descriptor will point just\n@@ -72,1 +72,1 @@\n-  fd->set_entry(entry == NULL ? pc() : entry);\n+  fd->set_entry(entry == nullptr ? pc() : entry);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+    assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -339,1 +339,1 @@\n-    AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(_index));\n+    AddressLiteral addrlit((address)nullptr, metadata_Relocation::spec(_index));\n@@ -344,1 +344,1 @@\n-    AddressLiteral addrlit((address)NULL, oop_Relocation::spec(_index));\n+    AddressLiteral addrlit((address)nullptr, oop_Relocation::spec(_index));\n@@ -403,1 +403,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -174,1 +174,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -214,1 +214,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -235,1 +235,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -247,1 +247,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -264,1 +264,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -275,1 +275,1 @@\n-  int oop_index = __ oop_recorder()->allocate_oop_index(NULL);\n+  int oop_index = __ oop_recorder()->allocate_oop_index(nullptr);\n@@ -278,1 +278,1 @@\n-  AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));\n+  AddressLiteral addrlit((address)nullptr, oop_Relocation::spec(oop_index));\n@@ -293,1 +293,1 @@\n-  int index = __ oop_recorder()->allocate_metadata_index(NULL);\n+  int index = __ oop_recorder()->allocate_metadata_index(nullptr);\n@@ -296,1 +296,1 @@\n-  AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));\n+  AddressLiteral addrlit((address)nullptr, metadata_Relocation::spec(index));\n@@ -449,4 +449,4 @@\n-  assert(op->block() == NULL || op->block()->label() == op->label(), \"wrong label\");\n-  if (op->block() != NULL)  _branch_target_blocks.append(op->block());\n-  if (op->ublock() != NULL) _branch_target_blocks.append(op->ublock());\n-  assert(op->info() == NULL, \"shouldn't have CodeEmitInfo\");\n+  assert(op->block() == nullptr || op->block()->label() == op->label(), \"wrong label\");\n+  if (op->block() != nullptr)  _branch_target_blocks.append(op->block());\n+  if (op->ublock() != nullptr) _branch_target_blocks.append(op->ublock());\n+  assert(op->info() == nullptr, \"shouldn't have CodeEmitInfo\");\n@@ -462,1 +462,1 @@\n-      assert(op->ublock() != NULL, \"must have unordered successor\");\n+      assert(op->ublock() != nullptr, \"must have unordered successor\");\n@@ -639,1 +639,1 @@\n-  if (entry_point_toc_addr == NULL) {\n+  if (entry_point_toc_addr == nullptr) {\n@@ -925,1 +925,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -945,1 +945,1 @@\n-      if (UseCompressedOops && !wide && c->as_jobject() != NULL) {\n+      if (UseCompressedOops && !wide && c->as_jobject() != nullptr) {\n@@ -969,1 +969,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1022,1 +1022,1 @@\n-          if (const_addr == NULL) {\n+          if (const_addr == nullptr) {\n@@ -1041,1 +1041,1 @@\n-          if (const_addr == NULL) {\n+          if (const_addr == nullptr) {\n@@ -1134,1 +1134,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -1142,1 +1142,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1176,1 +1176,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1179,1 +1179,1 @@\n-  if (info != NULL && !needs_explicit_null_check) {\n+  if (info != nullptr && !needs_explicit_null_check) {\n@@ -1256,1 +1256,1 @@\n-  if (info != NULL && needs_explicit_null_check) {\n+  if (info != nullptr && needs_explicit_null_check) {\n@@ -1264,1 +1264,1 @@\n-  PatchingStub* patch = NULL;\n+  PatchingStub* patch = nullptr;\n@@ -1307,1 +1307,1 @@\n-  if (patch != NULL) {\n+  if (patch != nullptr) {\n@@ -1311,1 +1311,1 @@\n-  if (info != NULL && !needs_explicit_null_check) {\n+  if (info != nullptr && !needs_explicit_null_check) {\n@@ -1354,1 +1354,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1368,1 +1368,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1390,1 +1390,1 @@\n-  AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);\n+  AddressLiteral ic = __ allocate_metadata_address((Metadata *)nullptr);\n@@ -1446,1 +1446,1 @@\n-            if (con == NULL) {\n+            if (con == nullptr) {\n@@ -1456,1 +1456,1 @@\n-          \/\/ We only need, for now, comparison with NULL for metadata.\n+          \/\/ We only need, for now, comparison with null for metadata.\n@@ -1460,1 +1460,1 @@\n-            if (p == NULL) {\n+            if (p == nullptr) {\n@@ -1542,1 +1542,1 @@\n-    lasm->const2reg(src, dst, lir_patch_none, NULL);\n+    lasm->const2reg(src, dst, lir_patch_none, nullptr);\n@@ -1612,1 +1612,1 @@\n-  assert(info == NULL, \"unused on this code path\");\n+  assert(info == nullptr, \"unused on this code path\");\n@@ -1840,1 +1840,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -1851,1 +1851,1 @@\n-  if (op->expected_type() == NULL) {\n+  if (op->expected_type() == nullptr) {\n@@ -1855,1 +1855,1 @@\n-    assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+    assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -1886,1 +1886,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass(), \"must be true at this point\");\n+  assert(default_type != nullptr && default_type->is_array_klass(), \"must be true at this point\");\n@@ -2009,1 +2009,1 @@\n-                                       &cont, copyfunc_addr != NULL ? &copyfunc : &slow, NULL);\n+                                       &cont, copyfunc_addr != nullptr ? &copyfunc : &slow, nullptr);\n@@ -2018,1 +2018,1 @@\n-      if (copyfunc_addr != NULL) { \/\/ Use stub if available.\n+      if (copyfunc_addr != nullptr) { \/\/ Use stub if available.\n@@ -2359,1 +2359,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2361,1 +2361,1 @@\n-  assert(data != NULL,       \"need data for checkcast\");\n+  assert(data != nullptr,       \"need data for checkcast\");\n@@ -2395,2 +2395,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2400,1 +2400,1 @@\n-    assert(method != NULL, \"Should have method\");\n+    assert(method != nullptr, \"Should have method\");\n@@ -2448,2 +2448,2 @@\n-      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),\n-                                       failure_target, NULL, RegisterOrConstant(k->super_check_offset()));\n+      __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : nullptr),\n+                                       failure_target, nullptr, RegisterOrConstant(k->super_check_offset()));\n@@ -2523,2 +2523,2 @@\n-    ciMethodData* md = NULL;\n-    ciProfileData* data = NULL;\n+    ciMethodData* md = nullptr;\n+    ciProfileData* data = nullptr;\n@@ -2528,1 +2528,1 @@\n-      assert(method != NULL, \"Should have method\");\n+      assert(method != nullptr, \"Should have method\");\n@@ -2561,1 +2561,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &failure, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &failure, nullptr);\n@@ -2650,1 +2650,1 @@\n-                noreg, NULL, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n@@ -2700,1 +2700,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2715,1 +2715,1 @@\n-      if (op->info() != NULL) {\n+      if (op->info() != nullptr) {\n@@ -2744,1 +2744,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -2767,1 +2767,1 @@\n-  assert(md != NULL, \"Sanity\");\n+  assert(md != nullptr, \"Sanity\");\n@@ -2769,1 +2769,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -2797,1 +2797,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -2823,1 +2823,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -2891,1 +2891,1 @@\n-    assert(info != NULL, \"sanity\");\n+    assert(info != nullptr, \"sanity\");\n@@ -2898,1 +2898,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -3083,1 +3083,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -3122,1 +3122,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -3135,1 +3135,1 @@\n-      if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n+      if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n@@ -3137,1 +3137,1 @@\n-        if (exact_klass != NULL) {\n+        if (exact_klass != nullptr) {\n@@ -3165,1 +3165,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -3178,1 +3178,1 @@\n-      assert(exact_klass != NULL, \"should be\");\n+      assert(exact_klass != nullptr, \"should be\");\n@@ -3203,1 +3203,1 @@\n-        assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+        assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -113,1 +113,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -115,1 +115,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -137,1 +137,1 @@\n-    return c->as_jobject() == NULL;\n+    return c->as_jobject() == nullptr;\n@@ -341,1 +341,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -398,1 +398,1 @@\n-    address entry = NULL;\n+    address entry = nullptr;\n@@ -409,1 +409,1 @@\n-    LIR_Opr result = call_runtime(x->x(), x->y(), entry, x->type(), NULL);\n+    LIR_Opr result = call_runtime(x->x(), x->y(), entry, x->type(), nullptr);\n@@ -460,1 +460,1 @@\n-    CodeEmitInfo* info = NULL; \/\/ Null check already done above.\n+    CodeEmitInfo* info = nullptr; \/\/ Null check already done above.\n@@ -468,1 +468,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -514,1 +514,1 @@\n-    CodeEmitInfo* info = NULL; \/\/ Null check already done above.\n+    CodeEmitInfo* info = nullptr; \/\/ Null check already done above.\n@@ -744,1 +744,1 @@\n-      address runtime_entry = NULL;\n+      address runtime_entry = nullptr;\n@@ -772,1 +772,1 @@\n-      LIR_Opr result = call_runtime(x->argument_at(0), runtime_entry, x->type(), NULL);\n+      LIR_Opr result = call_runtime(x->argument_at(0), runtime_entry, x->type(), nullptr);\n@@ -779,1 +779,1 @@\n-      LIR_Opr result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_entry, x->type(), NULL);\n+      LIR_Opr result = call_runtime(x->argument_at(0), x->argument_at(1), runtime_entry, x->type(), nullptr);\n@@ -832,1 +832,1 @@\n-          LIR_Opr result = call_runtime(x->value(), entry, x->type(), NULL);\n+          LIR_Opr result = call_runtime(x->value(), entry, x->type(), nullptr);\n@@ -972,1 +972,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1008,1 +1008,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -1015,1 +1015,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1072,1 +1072,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1087,1 +1087,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1091,1 +1091,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1110,1 +1110,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -1251,1 +1251,1 @@\n-      LIR_Address* a = NULL;\n+      LIR_Address* a = nullptr;\n@@ -1321,1 +1321,1 @@\n-      LIR_Address* a = NULL;\n+      LIR_Address* a = nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-    assert(Lnull != NULL, \"must have Label for explicit check\");\n+    assert(Lnull != nullptr, \"must have Label for explicit check\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  void null_check(Register r, Label *Lnull = NULL);\n+  void null_check(Register r, Label *Lnull = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -393,1 +393,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -651,1 +651,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -719,1 +719,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -757,1 +757,1 @@\n-  OopMap* oop_map = NULL;\n+  OopMap* oop_map = nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n","filename":"src\/hotspot\/cpu\/ppc\/c2_CodeStubs_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,1 +304,1 @@\n-    \/\/ Return false if one of them is NULL.\n+    \/\/ Return false if one of them is null.\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-address CompiledStaticCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = NULL*\/) {\n+address CompiledStaticCall::emit_to_interp_stub(CodeBuffer &cbuf, address mark\/* = nullptr*\/) {\n@@ -84,1 +84,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -95,2 +95,2 @@\n-  if (stub == NULL) {\n-    return NULL; \/\/ CodeCache is full\n+  if (stub == nullptr) {\n+    return nullptr; \/\/ CodeCache is full\n@@ -116,1 +116,1 @@\n-  AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);\n+  AddressLiteral ic = __ allocate_metadata_address((Metadata *)nullptr);\n@@ -120,1 +120,1 @@\n-    return NULL; \/\/ CodeCache is full\n+    return nullptr; \/\/ CodeCache is full\n@@ -129,1 +129,1 @@\n-      return NULL; \/\/ CodeCache is full\n+      return nullptr; \/\/ CodeCache is full\n@@ -148,1 +148,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -168,1 +168,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -194,1 +194,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -214,1 +214,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/ppc\/compiledIC_ppc.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL);\n+  static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/disassembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -114,1 +114,1 @@\n-    \/\/ In particular, (fp == NULL) might be true. So let's check and\n+    \/\/ In particular, fp might be null. So let's check and\n@@ -133,1 +133,1 @@\n-    if (sender_blob == NULL) {\n+    if (sender_blob == nullptr) {\n@@ -189,1 +189,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -198,1 +198,1 @@\n-  if (jfa->last_Java_pc() != NULL) {\n+  if (jfa->last_Java_pc() != nullptr) {\n@@ -265,1 +265,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-\/\/ can distinguish identity and younger\/older relationship. NULL\n+\/\/ can distinguish identity and younger\/older relationship. null\n@@ -138,1 +138,1 @@\n-   assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+   assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -321,1 +321,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n@@ -340,1 +340,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -346,1 +346,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -352,2 +352,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -355,1 +355,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -362,1 +362,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -371,1 +371,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-  \/\/ Crosses regions, storing NULL?\n+  \/\/ Crosses regions, storing null?\n@@ -260,1 +260,1 @@\n-  \/\/ Storing region crossing non-NULL, is card already dirty?\n+  \/\/ Storing region crossing non-null, is card already dirty?\n@@ -277,1 +277,1 @@\n-  \/\/ Storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ Storing a region crossing, non-null oop, card is clean.\n@@ -328,1 +328,1 @@\n-  \/\/ No need for post barrier if storing NULL\n+  \/\/ No need for post barrier if storing null\n@@ -353,1 +353,1 @@\n-  if (on_oop && on_reference && L_handle_null == NULL) { L_handle_null = &done; }\n+  if (on_oop && on_reference && L_handle_null == nullptr) { L_handle_null = &done; }\n@@ -378,1 +378,1 @@\n-  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+  __ beq(CCR0, done);         \/\/ Use null as-is.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-                       Label *L_handle_null = NULL);\n+                       Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-      if (L_handle_null != NULL) { \/\/ Label provided.\n+      if (L_handle_null != nullptr) { \/\/ Label provided.\n@@ -103,1 +103,1 @@\n-      if (L_handle_null != NULL) {\n+      if (L_handle_null != nullptr) {\n@@ -120,1 +120,1 @@\n-  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+  __ beq(CCR0, done);         \/\/ Use null as-is.\n@@ -154,1 +154,1 @@\n-  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+  __ beq(CCR0, done);         \/\/ Use null as-is.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-                       MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = NULL);\n+                       MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-  \/\/ No need for post barrier if storing NULL\n+  \/\/ No need for post barrier if storing null\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/cardTableBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+  __ beq(CCR0, done);         \/\/ Use null as-is.\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  address jrt_address = NULL;\n+  address jrt_address = nullptr;\n@@ -689,1 +689,1 @@\n-                false, success_flag, NULL, true);\n+                false, success_flag, nullptr, true);\n@@ -966,1 +966,1 @@\n-  address jrt_address = NULL;\n+  address jrt_address = nullptr;\n@@ -990,1 +990,1 @@\n-  assert(jrt_address != NULL, \"load reference barrier runtime routine cannot be found\");\n+  assert(jrt_address != nullptr, \"load reference barrier runtime routine cannot be found\");\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-                       MacroAssembler::PreservationLevel preservation_level, Label* L_handle_null = NULL);\n+                       MacroAssembler::PreservationLevel preservation_level, Label* L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-                       MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = NULL);\n+                       MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-define_pd_global(bool, UncommonNullCast,      true);  \/\/ Uncommon-trap NULLs passed to check cast.\n+define_pd_global(bool, UncommonNullCast,      true);  \/\/ Uncommon-trap nulls passed to check cast.\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-                                        Label *L_handle_null = NULL);\n+                                        Label *L_handle_null = nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -924,1 +924,1 @@\n-    \/\/   monitor->lock()->set_displaced_header(NULL);\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -985,1 +985,1 @@\n-    \/\/   monitor->lock()->set_displaced_header(NULL);\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1035,3 +1035,3 @@\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == NULL) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n+    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1040,1 +1040,1 @@\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1066,1 +1066,1 @@\n-    \/\/   monitor->set_obj(NULL);\n+    \/\/   monitor->set_obj(nullptr);\n@@ -1101,1 +1101,1 @@\n-    \/\/ Exchange worked, do monitor->set_obj(NULL);\n+    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n@@ -1693,1 +1693,1 @@\n-  \/\/ observed the receiver[start_row] is NULL.\n+  \/\/ observed the receiver[start_row] is null.\n@@ -2106,1 +2106,1 @@\n-  if (Interpreter::rethrow_exception_entry() != NULL) {\n+  if (Interpreter::rethrow_exception_entry() != nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-  bool do_NULL_check = offset() != 0 || is_static();\n+  bool do_null_check = offset() != 0 || is_static();\n@@ -105,1 +105,1 @@\n-  if (do_NULL_check) {\n+  if (do_null_check) {\n","filename":"src\/hotspot\/cpu\/ppc\/interpreterRT_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -41,1 +41,1 @@\n-    _last_Java_pc = NULL;\n+    _last_Java_pc = nullptr;\n@@ -55,1 +55,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -58,1 +58,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/javaFrameAnchor_ppc.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-      name = NULL;  \/\/ unreachable\n+      name = nullptr;  \/\/ unreachable\n@@ -152,1 +152,1 @@\n-      slow_case_addr = NULL;  \/\/ unreachable\n+      slow_case_addr = nullptr;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/ppc\/jniFastGetField_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/jvmciCodeInstaller_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-  if (const_address == NULL) { return false; } \/\/ allocation failure\n+  if (const_address == nullptr) { return false; } \/\/ allocation failure\n@@ -364,1 +364,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs a Recorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs a Recorder\");\n@@ -371,1 +371,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs a Recorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs a Recorder\");\n@@ -378,1 +378,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -384,1 +384,1 @@\n-  assert(oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert(oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -469,1 +469,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -709,1 +709,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1089,1 +1089,1 @@\n-        || fd == NULL   \/\/ support code-size estimation\n+        || fd == nullptr   \/\/ support code-size estimation\n@@ -1091,1 +1091,1 @@\n-        || fd->entry() == NULL) {\n+        || fd->entry() == nullptr) {\n@@ -1096,1 +1096,1 @@\n-      bool has_env = (fd != NULL && fd->env() != NULL);\n+      bool has_env = (fd != nullptr && fd->env() != nullptr);\n@@ -1153,1 +1153,1 @@\n-    assert(fd->entry() != NULL, \"function must be linked\");\n+    assert(fd->entry() != nullptr, \"function must be linked\");\n@@ -1158,1 +1158,1 @@\n-    if (fd->env() == NULL) {\n+    if (fd->env() == nullptr) {\n@@ -1170,1 +1170,1 @@\n-    if (!success) { return NULL; }\n+    if (!success) { return nullptr; }\n@@ -1309,2 +1309,2 @@\n-    if (polling_address_ptr != NULL) {\n-      *polling_address_ptr = NULL;\n+    if (polling_address_ptr != nullptr) {\n+      *polling_address_ptr = nullptr;\n@@ -1321,1 +1321,1 @@\n-  if (polling_address_ptr != NULL) {\n+  if (polling_address_ptr != nullptr) {\n@@ -1326,1 +1326,1 @@\n-  \/\/ Not on Linux, ucontext must be NULL.\n+  \/\/ Not on Linux, ucontext must be null.\n@@ -1388,1 +1388,1 @@\n-    return ra != 1 || rb_val >= 0 ? NULL         \/\/ not a stack bang\n+    return ra != 1 || rb_val >= 0 ? nullptr         \/\/ not a stack bang\n@@ -1391,1 +1391,1 @@\n-  return NULL; \/\/ not a stack bang\n+  return nullptr; \/\/ not a stack bang\n@@ -1395,1 +1395,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1704,1 +1704,1 @@\n-  Label& failed = (failed_ext != NULL) ? *failed_ext : failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1712,1 +1712,1 @@\n-  assert(int_flag_success == noreg || failed_ext == NULL, \"cannot have both\");\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1819,1 +1819,1 @@\n-  \/\/ for (scan = klass->itable(); scan->interface() != NULL; scan += scan_step) {\n+  \/\/ for (scan = klass->itable(); scan->interface() != nullptr; scan += scan_step) {\n@@ -1904,3 +1904,3 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n@@ -1909,1 +1909,1 @@\n-         \"at most one NULL in the batch, usually\");\n+         \"at most one null in the batch, usually\");\n@@ -2023,1 +2023,1 @@\n-  if (L_success != NULL) { b(*L_success); }\n+  if (L_success != nullptr) { b(*L_success); }\n@@ -2042,1 +2042,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -2045,1 +2045,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -2047,1 +2047,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -2136,1 +2136,1 @@\n-  if (stub == NULL) { return NULL; } \/\/ CodeCache full: bail out\n+  if (stub == nullptr) { return nullptr; } \/\/ CodeCache full: bail out\n@@ -2352,1 +2352,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -2373,1 +2373,1 @@\n-  if (method_data != NULL) {\n+  if (method_data != nullptr) {\n@@ -2389,1 +2389,1 @@\n-  assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+  assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -2396,1 +2396,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -2500,1 +2500,1 @@\n-    assert(stack_rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(stack_rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -2567,1 +2567,1 @@\n-    assert(rtm_counters != NULL, \"should not be NULL when profiling RTM\");\n+    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n@@ -2710,1 +2710,1 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ The object's monitor m is unlocked iff m->owner is null,\n@@ -2721,1 +2721,1 @@\n-  \/\/ Try to CAS m->owner from NULL to current thread.\n+  \/\/ Try to CAS m->owner from null to current thread.\n@@ -2914,1 +2914,1 @@\n-  \/\/ last_Java_pc will always be set to NULL. It is set here so that\n+  \/\/ last_Java_pc will always be set to null. It is set here so that\n@@ -4303,1 +4303,1 @@\n-  bool msg_present = (msg != NULL);\n+  bool msg_present = (msg != nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -430,2 +430,2 @@\n-  static bool is_load_from_polling_page(int instruction, void* ucontext\/*may be NULL*\/,\n-                                        address* polling_address_ptr = NULL);\n+  static bool is_load_from_polling_page(int instruction, void* ucontext\/*may be nullptr*\/,\n+                                        address* polling_address_ptr = nullptr);\n@@ -433,1 +433,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -435,1 +435,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -545,1 +545,1 @@\n-                Register int_flag_success = noreg, Label* failed = NULL, bool contention_hint = false, bool weak = false);\n+                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n@@ -564,1 +564,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -574,1 +574,1 @@\n-                                     Label* L_slow_path = NULL, \/\/ default fall through\n+                                     Label* L_slow_path = nullptr, \/\/ default fall through\n@@ -586,1 +586,1 @@\n-                                     Label* L_success = NULL,\n+                                     Label* L_success = nullptr,\n@@ -599,2 +599,2 @@\n-                      Label* L_fast_path = NULL,\n-                      Label* L_slow_path = NULL);\n+                      Label* L_fast_path = nullptr,\n+                      Label* L_slow_path = nullptr);\n@@ -634,1 +634,1 @@\n-                               Label& retryLabel, Label* checkRetry = NULL);\n+                               Label& retryLabel, Label* checkRetry = nullptr);\n@@ -650,3 +650,3 @@\n-                                 RTMLockingCounters* rtm_counters = NULL,\n-                                 RTMLockingCounters* stack_rtm_counters = NULL,\n-                                 Metadata* method_data = NULL,\n+                                 RTMLockingCounters* rtm_counters = nullptr,\n+                                 RTMLockingCounters* stack_rtm_counters = nullptr,\n+                                 Metadata* method_data = nullptr,\n@@ -710,1 +710,1 @@\n-                             MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = NULL);\n+                             MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null = nullptr);\n@@ -718,1 +718,1 @@\n-                            DecoratorSet decorators = 0, Label *L_handle_null = NULL);\n+                            DecoratorSet decorators = 0, Label *L_handle_null = nullptr);\n@@ -930,4 +930,4 @@\n-  void stop                 (const char* msg = NULL) { stop(stop_stop,               msg); }\n-  void untested             (const char* msg = NULL) { stop(stop_untested,           msg); }\n-  void unimplemented        (const char* msg = NULL) { stop(stop_unimplemented,      msg); }\n-  void should_not_reach_here(const char* msg = NULL) { stop(stop_shouldnotreachhere, msg); }\n+  void stop                 (const char* msg = nullptr) { stop(stop_stop,               msg); }\n+  void untested             (const char* msg = nullptr) { stop(stop_untested,           msg); }\n+  void unimplemented        (const char* msg = nullptr) { stop(stop_unimplemented,      msg); }\n+  void should_not_reach_here(const char* msg = nullptr) { stop(stop_shouldnotreachhere, msg); }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -422,1 +422,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -454,1 +454,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n@@ -464,1 +464,1 @@\n-  if (CompressedOops::base() != NULL) {\n+  if (CompressedOops::base() != nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    return CompressedOops::base() == NULL;\n+    return CompressedOops::base() == nullptr;\n@@ -101,1 +101,1 @@\n-    return CompressedKlassPointers::base() == NULL;\n+    return CompressedKlassPointers::base() == nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != NULL, \"not yet generated!\");\n+  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n@@ -227,1 +227,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -234,1 +234,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -498,2 +498,2 @@\n-  bool has_mh = (strstr(adaptername, \"\/static\") == NULL &&\n-                 strstr(adaptername, \"linkTo\") == NULL);    \/\/ static linkers don't have MH\n+  bool has_mh = (strstr(adaptername, \"\/static\") == nullptr &&\n+                 strstr(adaptername, \"linkTo\") == nullptr);    \/\/ static linkers don't have MH\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  if (cb == NULL || !cb->is_nmethod()) return false;\n+  if (cb == nullptr || !cb->is_nmethod()) return false;\n@@ -136,1 +136,1 @@\n-  assert(code != NULL, \"Could not find the containing code blob\");\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n@@ -141,1 +141,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -181,1 +181,1 @@\n-  assert(nm != NULL, \"Could not find code blob\");\n+  assert(nm != nullptr, \"Could not find code blob\");\n@@ -200,1 +200,1 @@\n-  assert(cb != NULL, \"Could not find code blob\");\n+  assert(cb != nullptr, \"Could not find code blob\");\n@@ -219,1 +219,1 @@\n-  address next_address = NULL;\n+  address next_address = nullptr;\n@@ -222,1 +222,1 @@\n-  if (cb != NULL && MacroAssembler::is_load_const_from_method_toc_at(addr)) {\n+  if (cb != nullptr && MacroAssembler::is_load_const_from_method_toc_at(addr)) {\n@@ -229,1 +229,1 @@\n-  } else if (cb != NULL &&\n+  } else if (cb != nullptr &&\n@@ -238,1 +238,1 @@\n-      assert(inst1_addr != NULL && inst1_addr < inst2_addr, \"first instruction must be found\");\n+      assert(inst1_addr != nullptr && inst1_addr < inst2_addr, \"first instruction must be found\");\n@@ -275,2 +275,2 @@\n-    oop* oop_addr = NULL;\n-    Metadata** metadata_addr = NULL;\n+    oop* oop_addr = nullptr;\n+    Metadata** metadata_addr = nullptr;\n@@ -280,1 +280,1 @@\n-        if (oop_addr == NULL) {\n+        if (oop_addr == nullptr) {\n@@ -289,1 +289,1 @@\n-        if (metadata_addr == NULL) {\n+        if (metadata_addr == nullptr) {\n@@ -300,1 +300,1 @@\n-void NativeMovConstReg::set_narrow_oop(narrowOop data, CodeBlob *code \/* = NULL *\/) {\n+void NativeMovConstReg::set_narrow_oop(narrowOop data, CodeBlob *code \/* = nullptr *\/) {\n@@ -303,1 +303,1 @@\n-  assert(cb != NULL, \"Could not find code blob\");\n+  assert(cb != nullptr, \"Could not find code blob\");\n@@ -309,1 +309,1 @@\n-  assert(inst1_addr != NULL && inst1_addr < inst2_addr, \"first instruction must be found\");\n+  assert(inst1_addr != nullptr && inst1_addr < inst2_addr, \"first instruction must be found\");\n@@ -322,2 +322,2 @@\n-    if (! (cb != NULL && MacroAssembler::is_calculate_address_from_global_toc_at(addr, cb->content_begin())) &&\n-        ! (cb != NULL && MacroAssembler::is_set_narrow_oop(addr, cb->content_begin())) &&\n+    if (! (cb != nullptr && MacroAssembler::is_calculate_address_from_global_toc_at(addr, cb->content_begin())) &&\n+        ! (cb != nullptr && MacroAssembler::is_set_narrow_oop(addr, cb->content_begin())) &&\n@@ -410,1 +410,1 @@\n-  assert(cb != NULL, \"Could not find code blob\");\n+  assert(cb != nullptr, \"Could not find code blob\");\n@@ -422,1 +422,1 @@\n-  assert(cb != NULL, \"Could not find code blob\");\n+  assert(cb != nullptr, \"Could not find code blob\");\n@@ -442,1 +442,1 @@\n-  if (cb == NULL || !cb->is_compiled()) return false;\n+  if (cb == nullptr || !cb->is_compiled()) return false;\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    return MacroAssembler::is_load_from_polling_page(long_at(0), NULL);\n+    return MacroAssembler::is_load_from_polling_page(long_at(0), nullptr);\n@@ -180,1 +180,1 @@\n-  NativeCall* call = NULL;\n+  NativeCall* call = nullptr;\n@@ -263,1 +263,1 @@\n-  void set_narrow_oop(narrowOop data, CodeBlob *code = NULL);\n+  void set_narrow_oop(narrowOop data, CodeBlob *code = nullptr);\n@@ -310,1 +310,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -380,1 +380,1 @@\n-  address destination(nmethod *nm = NULL) const;\n+  address destination(nmethod *nm = nullptr) const;\n@@ -521,1 +521,1 @@\n-  return NULL;\n+  return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  \/\/ Since there is none, we just return NULL.\n-  address pd_location(VMReg reg) const { return NULL; }\n+  \/\/ Since there is none, we just return null.\n+  address pd_location(VMReg reg) const { return nullptr; }\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n@@ -72,1 +72,1 @@\n-    if (orig_addr == NULL) {\n+    if (orig_addr == nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  __ asm_assert_ne(\"handle_exception_C must not return NULL\");\n+  __ asm_assert_ne(\"handle_exception_C must not return null\");\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                         const VMRegPair *regs, const VMRegPair *regs2 = NULL);\n+                         const VMRegPair *regs, const VMRegPair *regs2 = nullptr);\n@@ -104,1 +104,1 @@\n-                         const VMRegPair *regs, const VMRegPair *regs2 = NULL);\n+                         const VMRegPair *regs, const VMRegPair *regs2 = nullptr);\n@@ -282,1 +282,1 @@\n-  OopMap* map = generate_oop_map ? new OopMap(frame_size_in_slots, 0) : NULL;\n+  OopMap* map = generate_oop_map ? new OopMap(frame_size_in_slots, 0) : nullptr;\n@@ -475,1 +475,1 @@\n-  if (regs2 != NULL) {\n+  if (regs2 != nullptr) {\n@@ -513,1 +513,1 @@\n-  if (regs2 != NULL)\n+  if (regs2 != nullptr)\n@@ -806,1 +806,1 @@\n-  \/\/ register AND in a stack slot. If regs2 is NULL in such a\n+  \/\/ register AND in a stack slot. If regs2 is null in such a\n@@ -810,1 +810,1 @@\n-    if (regs2 != NULL) regs2[i].set_bad();\n+    if (regs2 != nullptr) regs2[i].set_bad();\n@@ -874,1 +874,1 @@\n-          guarantee(regs2 != NULL, \"must pass float in register and stack slot\");\n+          guarantee(regs2 != nullptr, \"must pass float in register and stack slot\");\n@@ -901,1 +901,1 @@\n-          guarantee(regs2 != NULL, \"must pass float in register and stack slot\");\n+          guarantee(regs2 != nullptr, \"must pass float in register and stack slot\");\n@@ -971,1 +971,1 @@\n-  \/\/ Patch caller's callsite, method_(code) was not NULL which means that\n+  \/\/ Patch caller's callsite, method_(code) was not null which means that\n@@ -1239,1 +1239,1 @@\n-  \/\/ Check for NULL argument if we don't have implicit null checks.\n+  \/\/ Check for null argument if we don't have implicit null checks.\n@@ -1253,1 +1253,1 @@\n-  \/\/ Assume argument is not NULL, load klass from receiver.\n+  \/\/ Assume argument is not null, load klass from receiver.\n@@ -1289,1 +1289,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -1346,1 +1346,1 @@\n-    \/\/ Use a NULL handle if oop is NULL.\n+    \/\/ Use a null handle if oop is null.\n@@ -1376,1 +1376,1 @@\n-    \/\/ Use a NULL handle if oop is NULL.\n+    \/\/ Use a null handle if oop is null.\n@@ -2117,1 +2117,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -2121,1 +2121,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -2144,1 +2144,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -2949,1 +2949,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2991,1 +2991,1 @@\n-  assert(map != NULL, \"OopMap must have been created\");\n+  assert(map != nullptr, \"OopMap must have been created\");\n@@ -3301,1 +3301,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL,\n+  assert(StubRoutines::forward_exception_entry() != nullptr,\n@@ -3431,1 +3431,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL, \"must have been generated before\");\n+    assert(StubRoutines::_call_stub_return_address != nullptr, \"must have been generated before\");\n@@ -2137,1 +2137,1 @@\n-    __ check_klass_subtype_fast_path(sub_klass, super_klass, temp, R0, &L_success, &L_miss, NULL,\n+    __ check_klass_subtype_fast_path(sub_klass, super_klass, temp, R0, &L_success, &L_miss, nullptr,\n@@ -2415,1 +2415,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -2421,1 +2421,1 @@\n-    __ cmpdi(CCR1, src, 0);      \/\/ if (src == NULL) return -1;\n+    __ cmpdi(CCR1, src, 0);      \/\/ if (src == nullptr) return -1;\n@@ -2423,1 +2423,1 @@\n-    __ cmpdi(CCR5, dst, 0);      \/\/ if (dst == NULL) return -1;\n+    __ cmpdi(CCR5, dst, 0);      \/\/ if (dst == nullptr) return -1;\n@@ -4712,1 +4712,1 @@\n-    if (bs_nm != NULL) {\n+    if (bs_nm != nullptr) {\n@@ -4782,1 +4782,1 @@\n-  if (UnsafeCopyMemory::_table == NULL) {\n+  if (UnsafeCopyMemory::_table == nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-  if (consts == NULL) {\n+  if (consts == nullptr) {\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-  \/\/ Check if receiver == NULL and go the slow path.\n+  \/\/ Check if receiver == nullptr and go the slow path.\n@@ -690,1 +690,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -763,1 +763,1 @@\n-  \/\/ which indicates if the counter overflow occurs at a backwards branch (NULL bcp)\n+  \/\/ which indicates if the counter overflow occurs at a backwards branch (null bcp)\n@@ -765,1 +765,1 @@\n-  \/\/ The call returns the address of the verified entry point for the method or NULL\n+  \/\/ The call returns the address of the verified entry point for the method or null\n@@ -775,1 +775,1 @@\n-  \/\/ Returns verified_entry_point or NULL.\n+  \/\/ Returns verified_entry_point or null.\n@@ -798,1 +798,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"generated in wrong order\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n@@ -1071,1 +1071,1 @@\n-  address runtime_entry = NULL;\n+  address runtime_entry = nullptr;\n@@ -1100,1 +1100,1 @@\n-  if (!use_instruction && runtime_entry == NULL) return NULL;\n+  if (!use_instruction && runtime_entry == nullptr) return nullptr;\n@@ -2064,1 +2064,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument, or null.\n@@ -2194,1 +2194,1 @@\n-  const char *bname = NULL;\n+  const char *bname = nullptr;\n@@ -2316,1 +2316,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL,\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr,\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-  \/\/ Convert null sentinel to NULL\n+  \/\/ Convert null sentinel to null\n@@ -997,1 +997,1 @@\n-  \/\/ Do array store check - check for NULL value first.\n+  \/\/ Do array store check - check for null value first.\n@@ -2242,1 +2242,1 @@\n-    __ clinit_barrier(klass, R16_thread, NULL \/*L_fast_path*\/, &L_clinit_barrier_slow);\n+    __ clinit_barrier(klass, R16_thread, nullptr \/*L_fast_path*\/, &L_clinit_barrier_slow);\n@@ -2391,1 +2391,1 @@\n-    \/\/ tos:   object pointer or NULL if static\n+    \/\/ tos:   object pointer or null if static\n@@ -3480,1 +3480,1 @@\n-  \/\/ Load receiver and receiver NULL check.\n+  \/\/ Load receiver and receiver null check.\n@@ -3504,1 +3504,1 @@\n-  \/\/ Receiver NULL check.\n+  \/\/ Receiver null check.\n@@ -3639,1 +3639,1 @@\n-  \/\/ Vtable entry was NULL => Throw abstract method error.\n+  \/\/ Vtable entry was null => Throw abstract method error.\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,1 +430,1 @@\n-  rc = perfstat_partition_total(NULL, &pinfo, sizeof(perfstat_partition_total_t), 1);\n+  rc = perfstat_partition_total(nullptr, &pinfo, sizeof(perfstat_partition_total_t), 1);\n@@ -440,1 +440,1 @@\n-  if (fp == NULL) {\n+  if (fp == nullptr) {\n@@ -447,1 +447,1 @@\n-  while (fgets(line, sizeof(line), fp) != NULL) {\n+  while (fgets(line, sizeof(line), fp) != nullptr) {\n@@ -475,1 +475,1 @@\n-  rc = perfstat_partition_total(NULL, &pinfo, sizeof(perfstat_partition_total_t), 1);\n+  rc = perfstat_partition_total(nullptr, &pinfo, sizeof(perfstat_partition_total_t), 1);\n@@ -484,1 +484,1 @@\n-  rc = perfstat_cpu_total(NULL, &cpuinfo, sizeof(perfstat_cpu_total_t), 1);\n+  rc = perfstat_cpu_total(nullptr, &cpuinfo, sizeof(perfstat_cpu_total_t), 1);\n@@ -535,1 +535,1 @@\n-                       NULL };\n+                       nullptr };\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,3 +52,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -123,1 +123,1 @@\n-  __ null_check(R19_method, in_bytes(Method::from_compiled_offset()), \/*implicit only*\/NULL);\n+  __ null_check(R19_method, in_bytes(Method::from_compiled_offset()), \/*implicit only*\/nullptr);\n@@ -138,3 +138,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}