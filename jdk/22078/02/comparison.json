{"files":[{"patch":"@@ -5758,4 +5758,0 @@\n-opclass memory_noindex(indirect,\n-                       indOffI1, indOffL1,indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-                       indirectN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n@@ -6698,1 +6694,1 @@\n-instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory_noindex mem)\n+instruct loadNKlassCompactHeaders(iRegNNoSp dst, memory4 mem)\n@@ -6704,1 +6700,4 @@\n-  format %{ \"load_narrow_klass_compact  $dst, $mem\\t# compressed class ptr\" %}\n+  format %{\n+    \"ldrw  $dst, $mem\\t# compressed class ptr, shifted\"\n+    \"lsrw  $dst, $dst, markWord::klass_shift_at_offset\"\n+  %}\n@@ -6706,2 +6705,4 @@\n-    assert($mem$$index$$Register == noreg, \"must not have indexed address\");\n-    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$base$$Register, $mem$$disp);\n+    \/\/ inlined aarch64_enc_ldrw\n+    loadStore(masm, &MacroAssembler::ldrw, $dst$$Register, $mem->opcode(),\n+              as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n+    __ lsrw($dst$$Register, $dst$$Register, markWord::klass_shift_at_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2693,9 +2693,0 @@\n-\n-void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Register obj, int disp) {\n-  \/\/ Note: Don't clobber obj anywhere in that method!\n-\n-  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n-  \/\/ obj-start, so that we can load from the object's mark-word instead.\n-  ldr(dst, Address(obj, disp - oopDesc::klass_offset_in_bytes()));\n-  lsr(dst, dst, markWord::klass_shift);\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -189,2 +189,0 @@\n-  void load_narrow_klass_compact_c2(Register dst, Register obj, int disp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7076,10 +7076,0 @@\n-\n-#ifdef _LP64\n-void C2_MacroAssembler::load_narrow_klass_compact_c2(Register dst, Address src) {\n-  \/\/ The incoming address is pointing into obj-start + klass_offset_in_bytes. We need to extract\n-  \/\/ obj-start, so that we can load from the object's mark-word instead. Usually the address\n-  \/\/ comes as obj-start in obj and klass_offset_in_bytes in disp.\n-  movq(dst, src.plus_disp(-oopDesc::klass_offset_in_bytes()));\n-  shrq(dst, markWord::klass_shift);\n-}\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -586,4 +586,0 @@\n-#ifdef _LP64\n-  void load_narrow_klass_compact_c2(Register dst, Address src);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4371,1 +4371,4 @@\n-  format %{ \"load_narrow_klass_compact    $dst, $mem\\t# compressed klass ptr\" %}\n+  format %{\n+    \"movl    $dst, $mem\\t# compressed klass ptr, shifted\"\n+    \"shrl    $dst, markWord::klass_shift_at_offset\"\n+  %}\n@@ -4373,1 +4376,2 @@\n-    __ load_narrow_klass_compact_c2($dst$$Register, $mem$$Address);\n+    __ movl($dst$$Register, $mem$$Address);\n+    __ shrl($dst$$Register, markWord::klass_shift_at_offset);\n@@ -4375,1 +4379,1 @@\n-  ins_pipe(pipe_slow); \/\/ XXX\n+  ins_pipe(ialu_reg_mem); \/\/ XXX\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  static constexpr int klass_offset_in_bytes      = 4;\n@@ -137,0 +138,1 @@\n+  static constexpr int klass_shift_at_offset      = klass_shift - klass_offset_in_bytes * BitsPerByte;\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,6 +335,2 @@\n-      \/\/ compiler and JVMCI, and even there we don't use it to access the (narrow)Klass*\n-      \/\/ directly. It is used only as a placeholder to identify the special memory slice\n-      \/\/ containing Klass* info. This value could be any value that is not a valid\n-      \/\/ field offset. Use an offset halfway into the markWord, as the markWord is never\n-      \/\/ partially loaded from C2 and JVMCI.\n-      return mark_offset_in_bytes() + 4;\n+      \/\/ compiler and JVMCI.\n+      return mark_offset_in_bytes() + markWord::klass_offset_in_bytes;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -544,0 +544,6 @@\n+\/\/ With compact headers, the input address (adr) does not point at the exact\n+\/\/ header position where the (narrow) class pointer is located, but into the\n+\/\/ middle of the mark word (see oopDesc::klass_offset_in_bytes()). This node\n+\/\/ implicitly shifts the loaded value (markWord::klass_shift_at_offset bits) to\n+\/\/ extract the actual class pointer. C2's type system is agnostic on whether the\n+\/\/ input address directly points into the class pointer.\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}