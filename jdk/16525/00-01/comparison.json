{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -44,1 +45,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -46,0 +46,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -61,1 +62,4 @@\n-    static Stream<Arguments> proxyInterfaces() {\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\", \".\");\n+    private static final ClassLoader LOADER = ClassRestrictions.class.getClassLoader();\n+\n+    static Stream<List<Class<?>>> badProxyInterfaces() {\n@@ -63,12 +67,5 @@\n-                \/*\n-                 * All of the Class objects in the interfaces array must represent\n-                 * interfaces, not classes or primitive types.\n-                 *\/\n-                Arguments.of(new Class<?>[] { Object.class }, \"proxy class created with java.lang.Object as interface\"),\n-                Arguments.of(new Class<?>[] { Integer.TYPE }, \"proxy class created with int.class as interface\"),\n-                Arguments.of(new Class<?>[] { Bar.class, Bar.class }, \"proxy class created with repeated interfaces\"),\n-                \/*\n-                 * No two interfaces may each have a method with the same name and\n-                 * parameter signature but different return type.\n-                 *\/\n-                Arguments.of(new Class<?>[] { Bar.class, Baz.class }, \"proxy class created with conflicting methods\")\n+                List.of(Object.class),          \/\/ proxy interface cannot be a class\n+                List.of(int.class),             \/\/ proxy interface can't be primitive type\n+                List.of(Bar.class, Bar.class),  \/\/ cannot have repeated interfaces\n+                \/\/ two proxy interfaces have the method of same method name but different return type\n+                List.of(Bar.class, Baz.class)\n@@ -79,1 +76,1 @@\n-     * Test valid interfaces\n+     * Test cases for illegal proxy interfaces\n@@ -82,10 +79,3 @@\n-    @MethodSource(\"proxyInterfaces\")\n-    void testForName(Class<?>[] interfaces, String message) {\n-        ClassLoader loader = ClassRestrictions.class.getClassLoader();\n-        try {\n-            var proxyClass = Proxy.getProxyClass(loader, interfaces);\n-            throw new Error(message);\n-        } catch (IllegalArgumentException e) {\n-            System.err.println(e.getMessage());\n-            \/\/ assume exception is for intended failure\n-        }\n+    @MethodSource(\"badProxyInterfaces\")\n+    void testForName(List<Class<?>> interfaces) {\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(LOADER, interfaces.toArray(Class[]::new)));\n@@ -101,15 +91,6 @@\n-        Class<?> nonPublic1 = Bashful.class;\n-        Class<?> nonPublic2 = Class.forName(nonPublicIntrfaceName);\n-        if (Modifier.isPublic(nonPublic2.getModifiers())) {\n-            throw new Error(\"Interface \" + nonPublicIntrfaceName +\n-                            \" is public and need to be changed!\");\n-        }\n-        try {\n-            ClassLoader loader = ClassRestrictions.class.getClassLoader();\n-            var interfaces = new Class<?>[] { nonPublic1, nonPublic2 };\n-            var proxyClass = Proxy.getProxyClass(loader, interfaces);\n-            throw new Error(\"proxy class created with two non-public interfaces \" +\n-                            \"in different packages\");\n-        } catch (IllegalArgumentException e) {\n-            System.err.println(e.getMessage());\n-        }\n+        var nonPublic1 = Bashful.class;\n+        var nonPublic2 = Class.forName(nonPublicIntrfaceName);\n+        assertFalse(Modifier.isPublic(nonPublic2.getModifiers()),\n+            \"Interface \" + nonPublicIntrfaceName + \" is public and need to be changed!\");\n+        var interfaces = new Class<?>[] { nonPublic1, nonPublic2 };\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(LOADER, interfaces));\n@@ -121,1 +102,2 @@\n-                         ClassLoader.getSystemClassLoader());\n+                         ClassLoader.getSystemClassLoader(),\n+                         LOADER);\n@@ -124,2 +106,0 @@\n-    private static final String[] CPATHS = System.getProperty(\"test.classes\", \".\")\n-                                                 .split(File.pathSeparator);\n@@ -133,12 +113,4 @@\n-        URL[] urls = new URL[CPATHS.length];\n-        for (int i = 0; i < CPATHS.length; i++) {\n-            urls[i] = Paths.get(CPATHS[i]).toUri().toURL();\n-        }\n-        ClassLoader altLoader = new URLClassLoader(urls, null);\n-        Class<?> altBarClass = Class.forName(Bar.class.getName(), false, altLoader);\n-        try {\n-            var interfaces = new Class<?>[]{ altBarClass };\n-            var proxyClass = Proxy.getProxyClass(loader, interfaces);\n-            throw new Error(\"proxy class created with interface not visible to class loader\");\n-        } catch (IllegalArgumentException e) {\n-            System.err.println(e.getMessage());\n+        String[] cpaths = TEST_CLASSES.split(File.pathSeparator);\n+        URL[] urls = new URL[cpaths.length];\n+        for (int i = 0; i < cpaths.length; i++) {\n+            urls[i] = Paths.get(cpaths[i]).toUri().toURL();\n@@ -146,0 +118,4 @@\n+        var altLoader = new URLClassLoader(urls, null);\n+        var altBarClass = Class.forName(Bar.class.getName(), false, altLoader);\n+        var interfaces = new Class<?>[]{ altBarClass };\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(loader, interfaces));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ClassRestrictions.java","additions":31,"deletions":55,"binary":false,"changes":86,"status":"modified"}]}