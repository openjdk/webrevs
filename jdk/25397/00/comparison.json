{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,5 +25,0 @@\n-import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n-\n-import jdk.vm.ci.meta.DeoptimizationReason;\n-import jdk.vm.ci.meta.JavaMethodProfile;\n-import jdk.vm.ci.meta.JavaTypeProfile;\n@@ -31,101 +26,0 @@\n-import jdk.vm.ci.meta.TriState;\n-\n-final class HotSpotProfilingInfo implements ProfilingInfo {\n-\n-    private final HotSpotMethodData methodData;\n-    private final HotSpotResolvedJavaMethod method;\n-\n-    private boolean isMature;\n-    private int position;\n-    private int hintPosition;\n-    private int hintBCI;\n-    private HotSpotMethodDataAccessor dataAccessor;\n-\n-    private boolean includeNormal;\n-    private boolean includeOSR;\n-\n-    HotSpotProfilingInfo(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n-        this.methodData = methodData;\n-        this.method = method;\n-        if (!method.getDeclaringClass().isLinked()) {\n-            throw new IllegalArgumentException(method.format(\"%H.%n(%p) must be linked\"));\n-        }\n-        this.includeNormal = includeNormal;\n-        this.includeOSR = includeOSR;\n-        this.isMature = methodData.isProfileMature();\n-        hintPosition = 0;\n-        hintBCI = -1;\n-    }\n-\n-    @Override\n-    public int getCodeSize() {\n-        return method.getCodeSize();\n-    }\n-\n-    public int getDecompileCount() {\n-        return methodData.getDecompileCount();\n-    }\n-\n-    public int getOverflowRecompileCount() {\n-        return methodData.getOverflowRecompileCount();\n-    }\n-\n-    public int getOverflowTrapCount() {\n-        return methodData.getOverflowTrapCount();\n-    }\n-\n-    @Override\n-    public JavaTypeProfile getTypeProfile(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getTypeProfile(methodData, position);\n-    }\n-\n-    @Override\n-    public JavaMethodProfile getMethodProfile(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getMethodProfile(methodData, position);\n-    }\n-\n-    @Override\n-    public double getBranchTakenProbability(int bci) {\n-        if (!isMature) {\n-            return -1;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getBranchTakenProbability(methodData, position);\n-    }\n-\n-    @Override\n-    public double[] getSwitchProbabilities(int bci) {\n-        if (!isMature) {\n-            return null;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getSwitchProbabilities(methodData, position);\n-    }\n-\n-    @Override\n-    public TriState getExceptionSeen(int bci) {\n-        if (!findBCI(bci)) {\n-            \/\/ There might data in the extra data section but all accesses to that memory must be\n-            \/\/ under a lock so go into VM to get the data.\n-            int exceptionSeen = compilerToVM().methodDataExceptionSeen(methodData.methodDataPointer, bci);\n-            if (exceptionSeen == -1) {\n-                return TriState.UNKNOWN;\n-            }\n-            return TriState.get(exceptionSeen != 0);\n-        }\n-        return dataAccessor.getExceptionSeen(methodData, position);\n-    }\n-\n-    @Override\n-    public TriState getNullSeen(int bci) {\n-        findBCI(bci);\n-        return dataAccessor.getNullSeen(methodData, position);\n-    }\n@@ -133,76 +27,4 @@\n-    @Override\n-    public int getExecutionCount(int bci) {\n-        if (!isMature) {\n-            return -1;\n-        }\n-        findBCI(bci);\n-        return dataAccessor.getExecutionCount(methodData, position);\n-    }\n-\n-    @Override\n-    public int getDeoptimizationCount(DeoptimizationReason reason) {\n-        int count = 0;\n-        if (includeNormal) {\n-            count += methodData.getDeoptimizationCount(reason);\n-        }\n-        if (includeOSR) {\n-            count += methodData.getOSRDeoptimizationCount(reason);\n-        }\n-        return count;\n-    }\n-\n-    private boolean findBCI(int targetBCI) {\n-        assert targetBCI >= 0 : \"invalid BCI\";\n-\n-        if (methodData.hasNormalData()) {\n-            int currentPosition = targetBCI < hintBCI ? 0 : hintPosition;\n-            HotSpotMethodDataAccessor currentAccessor;\n-            while ((currentAccessor = methodData.getNormalData(currentPosition)) != null) {\n-                int currentBCI = currentAccessor.getBCI(methodData, currentPosition);\n-                if (currentBCI == targetBCI) {\n-                    normalDataFound(currentAccessor, currentPosition, currentBCI);\n-                    return true;\n-                } else if (currentBCI > targetBCI) {\n-                    break;\n-                }\n-                currentPosition = currentPosition + currentAccessor.getSize(methodData, currentPosition);\n-            }\n-        }\n-        noDataFound(false);\n-        return false;\n-    }\n-\n-    private void normalDataFound(HotSpotMethodDataAccessor data, int pos, int bci) {\n-        setCurrentData(data, pos);\n-        this.hintPosition = position;\n-        this.hintBCI = bci;\n-    }\n-\n-    private void noDataFound(boolean exceptionPossiblyNotRecorded) {\n-        HotSpotMethodDataAccessor accessor = HotSpotMethodData.getNoDataAccessor(exceptionPossiblyNotRecorded);\n-        setCurrentData(accessor, -1);\n-    }\n-\n-    private void setCurrentData(HotSpotMethodDataAccessor dataAccessor, int position) {\n-        this.dataAccessor = dataAccessor;\n-        this.position = position;\n-    }\n-\n-    @Override\n-    public boolean isMature() {\n-        return isMature;\n-    }\n-\n-    public void ignoreMature() {\n-        isMature = true;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"HotSpotProfilingInfo<\" + this.toString(null, \"; \") + \">\";\n-    }\n-\n-    @Override\n-    public void setMature() {\n-        isMature = true;\n-    }\n+\/**\n+ * Extends {@link ProfilingInfo} with HotSpot specific profiling info.\n+ *\/\n+public interface HotSpotProfilingInfo extends ProfilingInfo {\n@@ -211,3 +33,1 @@\n-     * {@code MethodData::_jvmci_ir_size} (currently) supports at most one JVMCI compiler IR type\n-     * which will be determined by the first JVMCI compiler that calls\n-     * {@link #setCompilerIRSize(Class, int)}.\n+     * Returns {@code MethodData::_compiler_counters._nof_decompiles}.\n@@ -215,1 +35,1 @@\n-    private static volatile Class<?> supportedCompilerIRType;\n+    int getDecompileCount();\n@@ -217,15 +37,4 @@\n-    @Override\n-    public boolean setCompilerIRSize(Class<?> irType, int size) {\n-        if (supportedCompilerIRType == null) {\n-            synchronized (HotSpotProfilingInfo.class) {\n-                if (supportedCompilerIRType == null) {\n-                    supportedCompilerIRType = irType;\n-                }\n-            }\n-        }\n-        if (supportedCompilerIRType != irType) {\n-            return false;\n-        }\n-        methodData.setCompiledIRSize(size);\n-        return true;\n-    }\n+    \/**\n+     * Returns {@code MethodData::_compiler_counters._nof_overflow_recompiles}.\n+     *\/\n+    int getOverflowRecompileCount();\n@@ -233,7 +42,4 @@\n-    @Override\n-    public int getCompilerIRSize(Class<?> irType) {\n-        if (irType == supportedCompilerIRType) {\n-            return methodData.getCompiledIRSize();\n-        }\n-        return -1;\n-    }\n+    \/**\n+     * Returns {@code MethodData::_compiler_counters._nof_overflow_traps}.\n+     *\/\n+    int getOverflowTrapCount();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","additions":15,"deletions":209,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-final class HotSpotProfilingInfo implements ProfilingInfo {\n+final class HotSpotProfilingInfoImpl implements HotSpotProfilingInfo {\n@@ -47,1 +47,1 @@\n-    HotSpotProfilingInfo(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n+    HotSpotProfilingInfoImpl(HotSpotMethodData methodData, HotSpotResolvedJavaMethod method, boolean includeNormal, boolean includeOSR) {\n@@ -65,0 +65,1 @@\n+    @Override\n@@ -69,0 +70,1 @@\n+    @Override\n@@ -73,0 +75,1 @@\n+    @Override\n@@ -220,1 +223,1 @@\n-            synchronized (HotSpotProfilingInfo.class) {\n+            synchronized (HotSpotProfilingInfoImpl.class) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfoImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"previous_filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","status":"copied"},{"patch":"@@ -492,1 +492,1 @@\n-            info = new HotSpotProfilingInfo(methodData, this, includeNormal, includeOSR);\n+            info = new HotSpotProfilingInfoImpl(methodData, this, includeNormal, includeOSR);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,5 @@\n-    private static final ProfilingInfo[] NO_PROFILING_INFO = new ProfilingInfo[]{new DefaultProfilingInfo(TriState.TRUE), new DefaultProfilingInfo(TriState.FALSE),\n-                    new DefaultProfilingInfo(TriState.UNKNOWN)};\n+    private static final ProfilingInfo[] NO_PROFILING_INFO = {\n+        new DefaultProfilingInfo(TriState.TRUE),\n+        new DefaultProfilingInfo(TriState.FALSE),\n+        new DefaultProfilingInfo(TriState.UNKNOWN)\n+    };\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/DefaultProfilingInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n@@ -50,0 +51,1 @@\n+import jdk.vm.ci.hotspot.HotSpotProfilingInfo;\n@@ -206,0 +208,9 @@\n+\n+        \/\/ Basic test that the counters are non-negative\n+        HotSpotProfilingInfo hsInfo = (HotSpotProfilingInfo) info;\n+        int count = hsInfo.getDecompileCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n+        count = hsInfo.getOverflowRecompileCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n+        count = hsInfo.getOverflowTrapCount();\n+        Assert.assertTrue(\"count = \" + count, count >= 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/meta\/ProfilingInfoTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}