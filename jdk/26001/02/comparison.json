{"files":[{"patch":"@@ -882,11 +882,0 @@\n-double os::elapsedVTime() {\n-  struct rusage usage;\n-  int retval = getrusage(RUSAGE_THREAD, &usage);\n-  if (retval == 0) {\n-    return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec + (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000.0 * 1000);\n-  } else {\n-    \/\/ better than nothing, but not much\n-    return elapsedTime();\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -785,4 +785,0 @@\n-double os::elapsedVTime() {\n-  \/\/ better than nothing, but not much\n-  return elapsedTime();\n-}\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1490,10 +1490,0 @@\n-double os::elapsedVTime() {\n-  struct rusage usage;\n-  int retval = getrusage(RUSAGE_THREAD, &usage);\n-  if (retval == 0) {\n-    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000 * 1000);\n-  } else {\n-    \/\/ better than nothing, but not much\n-    return elapsedTime();\n-  }\n-}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1602,2 +1602,0 @@\n-bool os::supports_vtime() { return true; }\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1197,15 +1197,0 @@\n-bool os::supports_vtime() { return true; }\n-\n-double os::elapsedVTime() {\n-  FILETIME created;\n-  FILETIME exited;\n-  FILETIME kernel;\n-  FILETIME user;\n-  if (GetThreadTimes(GetCurrentThread(), &created, &exited, &kernel, &user) != 0) {\n-    \/\/ the resolution of windows_to_java_time() should be sufficient (ms)\n-    return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) \/ MILLIUNITS;\n-  } else {\n-    return elapsedTime();\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1272,0 +1272,3 @@\n+  if (!os::is_thread_cpu_time_supported()) {\n+    vm_exit_during_initialization(\"G1 requires cpu time gathering support\");\n+  }\n@@ -2237,1 +2240,1 @@\n-  update_parallel_gc_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -2321,1 +2324,1 @@\n-void G1CollectedHeap::update_parallel_gc_threads_cpu_time() {\n+void G1CollectedHeap::update_perf_counter_cpu_time() {\n@@ -2324,1 +2327,1 @@\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+  if (!UsePerfData) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  void update_parallel_gc_threads_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -510,2 +511,0 @@\n-  _accum_task_vtime(nullptr),\n-\n@@ -545,1 +544,0 @@\n-  _accum_task_vtime = NEW_C_HEAP_ARRAY(double, _max_num_tasks, mtGC);\n@@ -555,2 +553,0 @@\n-\n-    _accum_task_vtime[i] = 0.0;\n@@ -983,1 +979,1 @@\n-    double start_vtime = os::elapsedVTime();\n+    SuspendibleThreadSetJoiner sts_join;\n@@ -985,2 +981,1 @@\n-    {\n-      SuspendibleThreadSetJoiner sts_join;\n+    assert(worker_id < _cm->active_tasks(), \"invariant\");\n@@ -988,9 +983,7 @@\n-      assert(worker_id < _cm->active_tasks(), \"invariant\");\n-\n-      G1CMTask* task = _cm->task(worker_id);\n-      task->record_start_time();\n-      if (!_cm->has_aborted()) {\n-        do {\n-          task->do_marking_step(G1ConcMarkStepDurationMillis,\n-                                true  \/* do_termination *\/,\n-                                false \/* is_serial*\/);\n+    G1CMTask* task = _cm->task(worker_id);\n+    task->record_start_time();\n+    if (!_cm->has_aborted()) {\n+      do {\n+        task->do_marking_step(G1ConcMarkStepDurationMillis,\n+                              true  \/* do_termination *\/,\n+                              false \/* is_serial*\/);\n@@ -998,5 +991,2 @@\n-          _cm->do_yield_check();\n-        } while (!_cm->has_aborted() && task->has_aborted());\n-      }\n-      task->record_end_time();\n-      guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n+        _cm->do_yield_check();\n+      } while (!_cm->has_aborted() && task->has_aborted());\n@@ -1004,3 +994,2 @@\n-\n-    double end_vtime = os::elapsedVTime();\n-    _cm->update_accum_task_vtime(worker_id, end_vtime - start_vtime);\n+    task->record_end_time();\n+    guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n@@ -1499,1 +1488,1 @@\n-  _g1h->update_parallel_gc_threads_cpu_time();\n+  _g1h->update_perf_counter_cpu_time();\n@@ -2093,0 +2082,17 @@\n+double G1ConcurrentMark::worker_threads_cpu_time_s() {\n+  class CountCpuTimeThreadClosure : public ThreadClosure {\n+  public:\n+    jlong _total_cpu_time;\n+\n+    CountCpuTimeThreadClosure() : ThreadClosure(), _total_cpu_time(0) { }\n+\n+    void do_thread(Thread* t) {\n+      _total_cpu_time += os::thread_cpu_time(t);\n+    }\n+  } cl;\n+\n+  threads_do(&cl);\n+\n+  return (double)cl._total_cpu_time \/ NANOSECS_PER_SEC;\n+}\n+\n@@ -2122,1 +2128,1 @@\n-            cm_thread()->vtime_accum(), cm_thread()->vtime_mark_accum());\n+            cm_thread()->total_mark_cpu_time_s(), cm_thread()->worker_threads_cpu_time_s());\n@@ -2266,2 +2272,0 @@\n-  double curr_time_ms = os::elapsedVTime() * 1000.0;\n-\n@@ -2277,1 +2281,1 @@\n-  double elapsed_time_ms = curr_time_ms - _start_time_ms;\n+  double elapsed_time_ms = (double)(os::current_thread_cpu_time() - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2792,3 +2796,3 @@\n-    vtime too regularly, as it is quite expensive. So, once it was in\n-    place, it was natural to piggy-back all the other conditions on it\n-    too and not constantly check them throughout the code.\n+    cpu time gathering too regularly, as it is quite expensive. So,\n+    once it was in place, it was natural to piggy-back all the other\n+    conditions on it too and not constantly check them throughout the code.\n@@ -2817,1 +2821,1 @@\n-  _start_time_ms = os::elapsedVTime() * 1000.0;\n+  _start_cpu_time_ns = os::current_thread_cpu_time();\n@@ -2911,2 +2915,2 @@\n-  double end_time_ms = os::elapsedVTime() * 1000.0;\n-  double elapsed_time_ms = end_time_ms - _start_time_ms;\n+  jlong end_cpu_time_ns = os::current_thread_cpu_time();\n+  double elapsed_time_ms = (double)(end_cpu_time_ns - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2935,1 +2939,1 @@\n-  _start_time_ms(0.0),\n+  _start_cpu_time_ns(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":41,"deletions":37,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -449,2 +449,0 @@\n-  double*   _accum_task_vtime;   \/\/ Accumulated task vtime\n-\n@@ -615,10 +613,2 @@\n-  void update_accum_task_vtime(uint i, double vtime) {\n-    _accum_task_vtime[i] += vtime;\n-  }\n-\n-  double all_task_accum_vtime() {\n-    double ret = 0.0;\n-    for (uint i = 0; i < _max_num_tasks; ++i)\n-      ret += _accum_task_vtime[i];\n-    return ret;\n-  }\n+  \/\/ Total cpu time spent in mark worker threads in seconds.\n+  double worker_threads_cpu_time_s();\n@@ -756,2 +746,2 @@\n-  \/\/ Start time of the current marking step\n-  double                      _start_time_ms;\n+  \/\/ Start cpu time of the current marking step\n+  jlong                       _start_cpu_time_ns;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-  _vtime_start(0.0),\n-  _vtime_accum(0.0),\n@@ -116,2 +114,0 @@\n-  _vtime_start = os::elapsedVTime();\n-\n@@ -136,3 +132,1 @@\n-    _vtime_accum = (os::elapsedVTime() - _vtime_start);\n-\n-    update_threads_cpu_time();\n+    update_perf_counter_cpu_time();\n@@ -174,1 +168,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -234,1 +228,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -244,1 +238,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -345,2 +339,2 @@\n-void G1ConcurrentMarkThread::update_threads_cpu_time() {\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+void G1ConcurrentMarkThread::update_perf_counter_cpu_time() {\n+  if (!UsePerfData) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n-  double _vtime_start;  \/\/ Initial virtual time.\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n@@ -91,4 +88,5 @@\n-  \/\/ Total virtual time so far for this thread and concurrent marking tasks.\n-  double vtime_accum();\n-  \/\/ Marking virtual time so far this thread and concurrent marking tasks.\n-  double vtime_mark_accum();\n+  \/\/ Total cpu time used by all marking related threads (i.e. this thread and the\n+  \/\/ marking worker threads) in seconds.\n+  double total_mark_cpu_time_s();\n+  \/\/ Cpu time used by all marking worker threads in seconds.\n+  double worker_threads_cpu_time_s();\n@@ -113,1 +111,1 @@\n-  void update_threads_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -33,2 +34,2 @@\n-inline double G1ConcurrentMarkThread::vtime_accum() {\n-  return _vtime_accum + _cm->all_task_accum_vtime();\n+inline double G1ConcurrentMarkThread::total_mark_cpu_time_s() {\n+  return os::thread_cpu_time(this) + worker_threads_cpu_time_s();\n@@ -38,2 +39,2 @@\n-inline double G1ConcurrentMarkThread::vtime_mark_accum() {\n-  return _cm->all_task_accum_vtime();\n+inline double G1ConcurrentMarkThread::worker_threads_cpu_time_s() {\n+  return _cm->worker_threads_cpu_time_s();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-  _vtime_start(0.0),\n-  _vtime_accum(0.0),\n@@ -56,2 +54,0 @@\n-  _vtime_start = os::elapsedVTime();\n-\n@@ -77,1 +73,1 @@\n-    track_usage();\n+    update_perf_counter_cpu_time();\n@@ -131,0 +127,4 @@\n+jlong G1ConcurrentRefineThread::cpu_time() {\n+  return os::thread_cpu_time(this);\n+}\n+\n@@ -136,1 +136,2 @@\n-  void track_usage() override;\n+  \/\/ Updates jstat cpu usage for all refinement threads.\n+  void update_perf_counter_cpu_time() override;\n@@ -182,4 +183,2 @@\n-void G1PrimaryConcurrentRefineThread::track_usage() {\n-  G1ConcurrentRefineThread::track_usage();\n-  \/\/ The primary thread is responsible for updating the CPU time for all workers.\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n+void G1PrimaryConcurrentRefineThread::update_perf_counter_cpu_time() {\n+  if (UsePerfData) {\n@@ -194,0 +193,1 @@\n+  void update_perf_counter_cpu_time() override { \/* Nothing to do. The primary thread does all the work. *\/ }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n-  double _vtime_start;  \/\/ Initial virtual time.\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n@@ -74,9 +71,2 @@\n-  \/\/ Update concurrent refine threads stats.\n-  \/\/ If we are in Primary thread, we additionally update CPU time tracking.\n-  virtual void track_usage() {\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - _vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-  };\n+  \/\/ Update concurrent refine threads cpu time stats.\n+  virtual void update_perf_counter_cpu_time() = 0;\n@@ -116,2 +106,2 @@\n-  \/\/ Total virtual time so far.\n-  double vtime_accum() { return _vtime_accum; }\n+  \/\/ Total cpu time spent in this thread so far.\n+  jlong cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-      _summary->set_rs_thread_vtime(_counter, crt->vtime_accum());\n+      _summary->set_refine_thread_cpu_time(_counter, crt->cpu_time());\n@@ -56,4 +56,4 @@\n-void G1RemSetSummary::set_rs_thread_vtime(uint thread, double value) {\n-  assert(_rs_threads_vtimes != nullptr, \"just checking\");\n-  assert(thread < _num_vtimes, \"just checking\");\n-  _rs_threads_vtimes[thread] = value;\n+void G1RemSetSummary::set_refine_thread_cpu_time(uint thread, jlong value) {\n+  assert(_refine_threads_cpu_times != nullptr, \"just checking\");\n+  assert(thread < _num_refine_threads, \"just checking\");\n+  _refine_threads_cpu_times[thread] = value;\n@@ -62,4 +62,4 @@\n-double G1RemSetSummary::rs_thread_vtime(uint thread) const {\n-  assert(_rs_threads_vtimes != nullptr, \"just checking\");\n-  assert(thread < _num_vtimes, \"just checking\");\n-  return _rs_threads_vtimes[thread];\n+jlong G1RemSetSummary::refine_thread_cpu_time(uint thread) const {\n+  assert(_refine_threads_cpu_times != nullptr, \"just checking\");\n+  assert(thread < _num_refine_threads, \"just checking\");\n+  return _refine_threads_cpu_times[thread];\n@@ -69,2 +69,2 @@\n-  _num_vtimes(G1ConcRefinementThreads),\n-  _rs_threads_vtimes(NEW_C_HEAP_ARRAY(double, _num_vtimes, mtGC)) {\n+  _num_refine_threads(G1ConcRefinementThreads),\n+  _refine_threads_cpu_times(NEW_C_HEAP_ARRAY(jlong, _num_refine_threads, mtGC)) {\n@@ -72,1 +72,1 @@\n-  memset(_rs_threads_vtimes, 0, sizeof(double) * _num_vtimes);\n+  memset(_refine_threads_cpu_times, 0, sizeof(jlong) * _num_refine_threads);\n@@ -80,1 +80,1 @@\n-  FREE_C_HEAP_ARRAY(double, _rs_threads_vtimes);\n+  FREE_C_HEAP_ARRAY(jlong, _refine_threads_cpu_times);\n@@ -85,1 +85,1 @@\n-  assert(_num_vtimes == other->_num_vtimes, \"just checking\");\n+  assert(_num_refine_threads == other->_num_refine_threads, \"just checking\");\n@@ -87,1 +87,1 @@\n-  memcpy(_rs_threads_vtimes, other->_rs_threads_vtimes, sizeof(double) * _num_vtimes);\n+  memcpy(_refine_threads_cpu_times, other->_refine_threads_cpu_times, sizeof(jlong) * _num_refine_threads);\n@@ -92,1 +92,1 @@\n-  assert(_num_vtimes == other->_num_vtimes, \"just checking\");\n+  assert(_num_refine_threads == other->_num_refine_threads, \"just checking\");\n@@ -94,2 +94,2 @@\n-  for (uint i = 0; i < _num_vtimes; i++) {\n-    set_rs_thread_vtime(i, other->rs_thread_vtime(i) - rs_thread_vtime(i));\n+  for (uint i = 0; i < _num_refine_threads; i++) {\n+    set_refine_thread_cpu_time(i, other->refine_thread_cpu_time(i) - refine_thread_cpu_time(i));\n@@ -386,2 +386,2 @@\n-    for (uint i = 0; i < _num_vtimes; i++) {\n-      out->print(\"    %5.2f\", rs_thread_vtime(i));\n+    for (uint i = 0; i < _num_refine_threads; i++) {\n+      out->print(\"    %5.2f\", (double)refine_thread_cpu_time(i) \/ NANOSECS_PER_SEC);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,1 @@\n-\/\/ A G1RemSetSummary manages statistical information about the G1RemSet\n-\n+\/\/ A G1RemSetSummary manages statistical information about the remembered set.\n@@ -37,2 +36,2 @@\n-  size_t _num_vtimes;\n-  double* _rs_threads_vtimes;\n+  size_t _num_refine_threads;\n+  jlong* _refine_threads_cpu_times;\n@@ -40,1 +39,1 @@\n-  void set_rs_thread_vtime(uint thread, double value);\n+  void set_refine_thread_cpu_time(uint thread, jlong value);\n@@ -42,1 +41,1 @@\n-  \/\/ update this summary with current data from various places\n+  \/\/ Update this summary with current data from various places.\n@@ -50,1 +49,1 @@\n-  \/\/ set the counters in this summary to the values of the others\n+  \/\/ Set the counters in this summary to the values of the others.\n@@ -52,1 +51,1 @@\n-  \/\/ subtract all counters from the other summary, and set them in the current\n+  \/\/ Subtract all counters from the other summary, and set them in the current.\n@@ -57,1 +56,1 @@\n-  double rs_thread_vtime(uint thread) const;\n+  jlong refine_thread_cpu_time(uint thread) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  double vstart = os::elapsedVTime();\n+  jlong start_cpu_time_ns = os::thread_cpu_time(this);\n@@ -133,1 +133,1 @@\n-  update_thread_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -138,1 +138,1 @@\n-                      (os::elapsedVTime() - vstart) * MILLIUNITS);\n+                      (double)(os::thread_cpu_time(this) - start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC);\n@@ -156,2 +156,2 @@\n-void G1ServiceThread::update_thread_cpu_time() {\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n+void G1ServiceThread::update_perf_counter_cpu_time() {\n+  if (UsePerfData) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  void update_thread_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,7 +296,0 @@\n-  \/\/ The \"virtual time\" of a thread is the amount of time a thread has\n-  \/\/ actually run.  The first function indicates whether the OS supports\n-  \/\/ this functionality for the current thread, and if so the second\n-  \/\/ returns the elapsed virtual time for the current thread.\n-  static bool supports_vtime();\n-  static double elapsedVTime();\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}