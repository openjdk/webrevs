{"files":[{"patch":"@@ -882,11 +882,0 @@\n-double os::elapsedVTime() {\n-  struct rusage usage;\n-  int retval = getrusage(RUSAGE_THREAD, &usage);\n-  if (retval == 0) {\n-    return usage.ru_utime.tv_sec + usage.ru_stime.tv_sec + (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000.0 * 1000);\n-  } else {\n-    \/\/ better than nothing, but not much\n-    return elapsedTime();\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -785,4 +785,0 @@\n-double os::elapsedVTime() {\n-  \/\/ better than nothing, but not much\n-  return elapsedTime();\n-}\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1490,10 +1490,0 @@\n-double os::elapsedVTime() {\n-  struct rusage usage;\n-  int retval = getrusage(RUSAGE_THREAD, &usage);\n-  if (retval == 0) {\n-    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) \/ (1000 * 1000);\n-  } else {\n-    \/\/ better than nothing, but not much\n-    return elapsedTime();\n-  }\n-}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1602,2 +1602,0 @@\n-bool os::supports_vtime() { return true; }\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1197,15 +1197,0 @@\n-bool os::supports_vtime() { return true; }\n-\n-double os::elapsedVTime() {\n-  FILETIME created;\n-  FILETIME exited;\n-  FILETIME kernel;\n-  FILETIME user;\n-  if (GetThreadTimes(GetCurrentThread(), &created, &exited, &kernel, &user) != 0) {\n-    \/\/ the resolution of windows_to_java_time() should be sufficient (ms)\n-    return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) \/ MILLIUNITS;\n-  } else {\n-    return elapsedTime();\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1272,0 +1272,3 @@\n+  if (!os::is_thread_cpu_time_supported()) {\n+    vm_exit_during_initialization(\"G1 requires cpu time gathering support\");\n+  }\n@@ -2237,1 +2240,1 @@\n-  update_parallel_gc_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -2321,1 +2324,1 @@\n-void G1CollectedHeap::update_parallel_gc_threads_cpu_time() {\n+void G1CollectedHeap::update_perf_counter_cpu_time() {\n@@ -2324,1 +2327,1 @@\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+  if (!UsePerfData) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  void update_parallel_gc_threads_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -510,2 +511,0 @@\n-  _accum_task_vtime(nullptr),\n-\n@@ -545,1 +544,0 @@\n-  _accum_task_vtime = NEW_C_HEAP_ARRAY(double, _max_num_tasks, mtGC);\n@@ -555,2 +553,0 @@\n-\n-    _accum_task_vtime[i] = 0.0;\n@@ -983,1 +979,1 @@\n-    double start_vtime = os::elapsedVTime();\n+    SuspendibleThreadSetJoiner sts_join;\n@@ -985,2 +981,1 @@\n-    {\n-      SuspendibleThreadSetJoiner sts_join;\n+    assert(worker_id < _cm->active_tasks(), \"invariant\");\n@@ -988,9 +983,7 @@\n-      assert(worker_id < _cm->active_tasks(), \"invariant\");\n-\n-      G1CMTask* task = _cm->task(worker_id);\n-      task->record_start_time();\n-      if (!_cm->has_aborted()) {\n-        do {\n-          task->do_marking_step(G1ConcMarkStepDurationMillis,\n-                                true  \/* do_termination *\/,\n-                                false \/* is_serial*\/);\n+    G1CMTask* task = _cm->task(worker_id);\n+    task->record_start_time();\n+    if (!_cm->has_aborted()) {\n+      do {\n+        task->do_marking_step(G1ConcMarkStepDurationMillis,\n+                              true  \/* do_termination *\/,\n+                              false \/* is_serial*\/);\n@@ -998,5 +991,2 @@\n-          _cm->do_yield_check();\n-        } while (!_cm->has_aborted() && task->has_aborted());\n-      }\n-      task->record_end_time();\n-      guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n+        _cm->do_yield_check();\n+      } while (!_cm->has_aborted() && task->has_aborted());\n@@ -1004,3 +994,2 @@\n-\n-    double end_vtime = os::elapsedVTime();\n-    _cm->update_accum_task_vtime(worker_id, end_vtime - start_vtime);\n+    task->record_end_time();\n+    guarantee(!task->has_aborted() || _cm->has_aborted(), \"invariant\");\n@@ -1499,1 +1488,1 @@\n-  _g1h->update_parallel_gc_threads_cpu_time();\n+  _g1h->update_perf_counter_cpu_time();\n@@ -2093,0 +2082,17 @@\n+double G1ConcurrentMark::worker_threads_cpu_time_s() {\n+  class CountCpuTimeThreadClosure : public ThreadClosure {\n+  public:\n+    jlong _total_cpu_time;\n+\n+    CountCpuTimeThreadClosure() : ThreadClosure(), _total_cpu_time(0) { }\n+\n+    void do_thread(Thread* t) {\n+      _total_cpu_time = os::thread_cpu_time(t);\n+    }\n+  } cl;\n+\n+  threads_do(&cl);\n+\n+  return (double)cl._total_cpu_time \/ NANOSECS_PER_SEC;\n+}\n+\n@@ -2122,1 +2128,1 @@\n-            cm_thread()->vtime_accum(), cm_thread()->vtime_mark_accum());\n+            cm_thread()->total_mark_cpu_time_s(), cm_thread()->worker_threads_cpu_time_s());\n@@ -2266,1 +2272,1 @@\n-  double curr_time_ms = os::elapsedVTime() * 1000.0;\n+  jlong curr_time_ns = os::current_thread_cpu_time();\n@@ -2277,1 +2283,1 @@\n-  double elapsed_time_ms = curr_time_ms - _start_time_ms;\n+  double elapsed_time_ms = (double)(curr_time_ns - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2817,1 +2823,1 @@\n-  _start_time_ms = os::elapsedVTime() * 1000.0;\n+  _start_cpu_time_ns = os::current_thread_cpu_time();\n@@ -2911,2 +2917,2 @@\n-  double end_time_ms = os::elapsedVTime() * 1000.0;\n-  double elapsed_time_ms = end_time_ms - _start_time_ms;\n+  jlong end_cpu_time_ns = os::current_thread_cpu_time();\n+  double elapsed_time_ms = (double)(end_cpu_time_ns - _start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC;\n@@ -2935,1 +2941,1 @@\n-  _start_time_ms(0.0),\n+  _start_cpu_time_ns(0),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -449,2 +449,0 @@\n-  double*   _accum_task_vtime;   \/\/ Accumulated task vtime\n-\n@@ -615,10 +613,2 @@\n-  void update_accum_task_vtime(uint i, double vtime) {\n-    _accum_task_vtime[i] += vtime;\n-  }\n-\n-  double all_task_accum_vtime() {\n-    double ret = 0.0;\n-    for (uint i = 0; i < _max_num_tasks; ++i)\n-      ret += _accum_task_vtime[i];\n-    return ret;\n-  }\n+  \/\/ Total cpu time spent in mark worker threads in seconds.\n+  double worker_threads_cpu_time_s();\n@@ -756,2 +746,2 @@\n-  \/\/ Start time of the current marking step\n-  double                      _start_time_ms;\n+  \/\/ Start cpu time of the current marking step\n+  jlong                       _start_cpu_time_ns;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-  _vtime_start(0.0),\n-  _vtime_accum(0.0),\n@@ -116,2 +114,0 @@\n-  _vtime_start = os::elapsedVTime();\n-\n@@ -136,3 +132,1 @@\n-    _vtime_accum = (os::elapsedVTime() - _vtime_start);\n-\n-    update_threads_cpu_time();\n+    update_perf_counter_cpu_time();\n@@ -174,1 +168,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -234,1 +228,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -244,1 +238,1 @@\n-  update_threads_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -345,2 +339,2 @@\n-void G1ConcurrentMarkThread::update_threads_cpu_time() {\n-  if (!UsePerfData || !os::is_thread_cpu_time_supported()) {\n+void G1ConcurrentMarkThread::update_perf_counter_cpu_time() {\n+  if (!UsePerfData) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,0 @@\n-  double _vtime_start;  \/\/ Initial virtual time.\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n@@ -91,4 +88,5 @@\n-  \/\/ Total virtual time so far for this thread and concurrent marking tasks.\n-  double vtime_accum();\n-  \/\/ Marking virtual time so far this thread and concurrent marking tasks.\n-  double vtime_mark_accum();\n+  \/\/ Total cpu time used by all marking related threads (i.e. this thread and the\n+  \/\/ marking worker threads) in seconds.\n+  double total_mark_cpu_time_s();\n+  \/\/ Cpu time used by all marking worker threads in seconds.\n+  double worker_threads_cpu_time_s();\n@@ -113,1 +111,1 @@\n-  void update_threads_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -33,2 +34,2 @@\n-inline double G1ConcurrentMarkThread::vtime_accum() {\n-  return _vtime_accum + _cm->all_task_accum_vtime();\n+inline double G1ConcurrentMarkThread::total_mark_cpu_time_s() {\n+  return os::thread_cpu_time(this) + worker_threads_cpu_time_s();\n@@ -38,2 +39,2 @@\n-inline double G1ConcurrentMarkThread::vtime_mark_accum() {\n-  return _cm->all_task_accum_vtime();\n+inline double G1ConcurrentMarkThread::worker_threads_cpu_time_s() {\n+  return _cm->worker_threads_cpu_time_s();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkThread.inline.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-  _vtime_start(0.0),\n-  _vtime_accum(0.0),\n@@ -56,2 +54,0 @@\n-  _vtime_start = os::elapsedVTime();\n-\n@@ -77,1 +73,1 @@\n-    track_usage();\n+    update_perf_counter_cpu_time();\n@@ -131,0 +127,4 @@\n+double G1ConcurrentRefineThread::cpu_time_s() {\n+  return (double)os::thread_cpu_time(this) \/ NANOSECS_PER_SEC;\n+}\n+\n@@ -136,1 +136,2 @@\n-  void track_usage() override;\n+  \/\/ Updates jstat cpu usage for all refinement threads.\n+  void update_perf_counter_cpu_time() override;\n@@ -182,4 +183,2 @@\n-void G1PrimaryConcurrentRefineThread::track_usage() {\n-  G1ConcurrentRefineThread::track_usage();\n-  \/\/ The primary thread is responsible for updating the CPU time for all workers.\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n+void G1PrimaryConcurrentRefineThread::update_perf_counter_cpu_time() {\n+  if (UsePerfData) {\n@@ -194,0 +193,1 @@\n+  void update_perf_counter_cpu_time() override { \/* Nothing to do. The primary thread does all the work. *\/ }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n-  double _vtime_start;  \/\/ Initial virtual time.\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n@@ -74,9 +71,2 @@\n-  \/\/ Update concurrent refine threads stats.\n-  \/\/ If we are in Primary thread, we additionally update CPU time tracking.\n-  virtual void track_usage() {\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - _vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-  };\n+  \/\/ Update concurrent refine threads cpu time stats.\n+  virtual void update_perf_counter_cpu_time() = 0;\n@@ -116,2 +106,2 @@\n-  \/\/ Total virtual time so far.\n-  double vtime_accum() { return _vtime_accum; }\n+  \/\/ Total cpu time spent in this thread in seconds so far.\n+  double cpu_time_s();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-      _summary->set_rs_thread_vtime(_counter, crt->vtime_accum());\n+      _summary->set_rs_thread_vtime(_counter, crt->cpu_time_s());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  double vstart = os::elapsedVTime();\n+  jlong start_cpu_time_ns = os::thread_cpu_time(this);\n@@ -133,1 +133,1 @@\n-  update_thread_cpu_time();\n+  update_perf_counter_cpu_time();\n@@ -138,1 +138,1 @@\n-                      (os::elapsedVTime() - vstart) * MILLIUNITS);\n+                      (double)(os::thread_cpu_time(this) - start_cpu_time_ns) \/ NANOSECS_PER_MILLISEC);\n@@ -156,2 +156,2 @@\n-void G1ServiceThread::update_thread_cpu_time() {\n-  if (UsePerfData && os::is_thread_cpu_time_supported()) {\n+void G1ServiceThread::update_perf_counter_cpu_time() {\n+  if (UsePerfData ) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  void update_thread_cpu_time();\n+  void update_perf_counter_cpu_time();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,7 +296,0 @@\n-  \/\/ The \"virtual time\" of a thread is the amount of time a thread has\n-  \/\/ actually run.  The first function indicates whether the OS supports\n-  \/\/ this functionality for the current thread, and if so the second\n-  \/\/ returns the elapsed virtual time for the current thread.\n-  static bool supports_vtime();\n-  static double elapsedVTime();\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}