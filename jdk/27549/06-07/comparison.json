{"files":[{"patch":"@@ -792,1 +792,2 @@\n-     * Returns a copy of this instant with the specified duration added.\n+     * Returns a copy of this instant with the specified duration added, with\n+     * saturated semantics.\n@@ -794,6 +795,8 @@\n-     * This method behaves the same as {@link #plus(TemporalAmount)} passed\n-     * with the specified duration as its argument, if no numeric overflow\n-     * occurs. If it does, then instead of throwing {@link ArithmeticException}\n-     * or {@link DateTimeException} like {@code plus} does, this method returns\n-     * {@link Instant#MIN} or {@link Instant#MAX} if the result exceeds minimum\n-     * or maximum instant respectively.\n+     * If the result is \"earlier\" than {@link Instant#MIN}, this method returns\n+     * {@code MIN}. If the result is \"later\" than {@link Instant#MAX}, it\n+     * returns {@code MAX}. Otherwise it returns {@code this.}{@link #plus plus(duration)}.\n+     *\n+     * @apiNote This method can be used to calculate a deadline from\n+     * this instant and a timeout. Unlike {@code plus(TemporalAmount)},\n+     * this method never throws {@link ArithmeticException} or {@link DateTimeException}\n+     * due to numeric overflow or {@code Instant} range violation.\n@@ -808,2 +811,1 @@\n-            return Duration.between(this, Instant.MIN).compareTo(duration) >= 0\n-                    ? Instant.MIN : this.plus(duration);\n+            return until(Instant.MIN).compareTo(duration) >= 0 ? Instant.MIN : plus(duration);\n@@ -811,2 +813,1 @@\n-            return Duration.between(this, Instant.MAX).compareTo(duration) > 0\n-                    ? this.plus(duration) : Instant.MAX;\n+            return until(Instant.MAX).compareTo(duration) <= 0 ? Instant.MAX : plus(duration);\n@@ -987,25 +988,0 @@\n-    \/**\n-     * Returns a copy of this instant with the specified duration subtracted.\n-     * <p>\n-     * This method behaves the same as {@link #minus(TemporalAmount)} passed\n-     * with the specified duration as its argument, if no numeric overflow\n-     * occurs. If it does, then instead of throwing {@link ArithmeticException}\n-     * or {@link DateTimeException} like {@code minus} does, this method returns\n-     * {@link Instant#MIN} or {@link Instant#MAX} if the result exceeds minimum\n-     * or maximum instant respectively.\n-     *\n-     * @param duration the duration to subtract, not null\n-     * @return an {@code Instant} based on this instant with the subtraction made, not null\n-     *\n-     * @since 26\n-     *\/\n-    public Instant minusSaturating(Duration duration) {\n-        if (duration.isNegative()) {\n-            return Duration.between(Instant.MAX, this).compareTo(duration) >= 0\n-                    ? Instant.MAX : minus(duration);\n-        } else {\n-            return Duration.between(Instant.MIN, this).compareTo(duration) > 0\n-                    ? minus(duration) : Instant.MIN;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":12,"deletions":36,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1266,1 +1266,1 @@\n-                {Instant.MAX, Duration.between(Instant.MAX, Instant.MIN), Optional.of(Instant.MIN)} \/\/ interesting case\n+                {Instant.MAX, Duration.between(Instant.MAX, Instant.MIN), Optional.of(Instant.MIN)}\n@@ -1290,0 +1290,16 @@\n+    @DataProvider(name = \"PlusSaturating_null\")\n+    Object[][] provider_plusSaturating_null() {\n+        return new Object[][]{\n+                {Instant.MIN},\n+                {Instant.EPOCH},\n+                {Instant.MAX},\n+                \/\/ any non-random but also non-special instant\n+                {Instant.parse(\"2025-10-13T20:47:50.369955Z\")},\n+        };\n+    }\n+\n+    @Test(expectedExceptions = NullPointerException.class, dataProvider = \"PlusSaturating_null\")\n+    public void test_plusSaturating_null(Instant i) {\n+        i.plusSaturating(null);\n+    }\n+\n@@ -1792,61 +1808,0 @@\n-    @DataProvider(name = \"MinusSaturating\")\n-    Object[][] provider_minusSaturating() {\n-        return new Object[][]{\n-                \/\/ 1. {edge or constant instants} x {edge or constant durations}\n-                {Instant.MIN, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MAX)},\n-                {Instant.MIN, Duration.ZERO, Optional.empty()},\n-                {Instant.MIN, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MIN)},\n-                {Instant.EPOCH, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MAX)},\n-                {Instant.EPOCH, Duration.ZERO, Optional.empty()},\n-                {Instant.EPOCH, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MIN)},\n-                {Instant.MAX, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MAX)},\n-                {Instant.MAX, Duration.ZERO, Optional.empty()},\n-                {Instant.MAX, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MIN)},\n-                \/\/ 2. {edge or constant instants} x {normal durations}\n-                {Instant.MIN, Duration.ofDays(-32), Optional.empty()},\n-                {Instant.MIN, Duration.ofDays(32), Optional.of(Instant.MIN)},\n-                {Instant.EPOCH, Duration.ofDays(-32), Optional.empty()},\n-                {Instant.EPOCH, Duration.ofDays(32), Optional.empty()},\n-                {Instant.MAX, Duration.ofDays(-32), Optional.of(Instant.MAX)},\n-                {Instant.MAX, Duration.ofDays(32), Optional.empty()},\n-                \/\/ 3. {normal instants with both positive and negative epoch seconds} x {edge or constant durations}\n-                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MAX)},\n-                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ZERO, Optional.empty()},\n-                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MIN)},\n-                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MAX)},\n-                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ZERO, Optional.empty()},\n-                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MIN)},\n-                \/\/ 4. {normal instants with both positive and negative epoch seconds} x {normal durations}\n-                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(-32), Optional.empty()},\n-                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(32), Optional.empty()},\n-                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(-32), Optional.empty()},\n-                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(32), Optional.empty()},\n-                \/\/ 5. instant boundary\n-                {Instant.MIN, Duration.between(Instant.MAX, Instant.MIN), Optional.of(Instant.MAX)},\n-                {Instant.EPOCH, Duration.between(Instant.MIN, Instant.EPOCH), Optional.of(Instant.MIN)},\n-                {Instant.MAX, Duration.between(Instant.EPOCH, Instant.MAX), Optional.of(Instant.EPOCH)},\n-                {Instant.MAX, Duration.between(Instant.MIN, Instant.MAX), Optional.of(Instant.MIN)},\n-                {Instant.EPOCH, Duration.between(Instant.MAX, Instant.EPOCH), Optional.of(Instant.MAX)} \/\/ interesting case\n-        };\n-    }\n-\n-    @Test(dataProvider = \"MinusSaturating\")\n-    public void minusSaturating(Instant i, Duration d, Optional<Instant> value) {\n-        var actual = i.minusSaturating(d);\n-        try {\n-            assertEquals(actual, i.minus(d));\n-            \/\/ If `value` is present, perform an additional check. It may be\n-            \/\/ important to ensure that not only does the result of `minusSaturating`\n-            \/\/ match that of `minus`, but that it also matches our expectation.\n-            \/\/ Because if it doesn’t, then the test isn’t testing what we think\n-            \/\/ it is, and needs to be fixed.\n-            value.ifPresent(instant -> assertEquals(actual, instant));\n-        } catch (DateTimeException \/* instant overflow *\/\n-                 | ArithmeticException \/* long overflow *\/ e) {\n-            if (value.isEmpty()) {\n-                throw new AssertionError();\n-            }\n-            assertEquals(actual, value.get());\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKInstant.java","additions":17,"deletions":62,"binary":false,"changes":79,"status":"modified"}]}