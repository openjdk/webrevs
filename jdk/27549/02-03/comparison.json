{"files":[{"patch":"@@ -109,0 +109,1 @@\n+import java.util.Optional;\n@@ -1228,36 +1229,43 @@\n-    @Test\n-    void saturating_plus() {\n-        \/\/ This test verifies a subset of the following cartesian product:\n-        \/\/ {edge or constant instants, normal instants} x {edge or constant durations, normal durations)\n-        \/\/ 1. {edge or constant instants} x {edge or constant durations}\n-        verifySaturating(Instant.MIN, Duration.ofSeconds(Long.MIN_VALUE, 0), Instant.MIN);\n-        verifySaturating(Instant.MIN, Duration.ZERO);\n-        verifySaturating(Instant.MIN, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Instant.MAX);\n-        verifySaturating(Instant.EPOCH, Duration.ofSeconds(Long.MIN_VALUE, 0), Instant.MIN);\n-        verifySaturating(Instant.EPOCH, Duration.ZERO);\n-        verifySaturating(Instant.EPOCH, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Instant.MAX);\n-        verifySaturating(Instant.MAX, Duration.ofSeconds(Long.MIN_VALUE, 0), Instant.MIN);\n-        verifySaturating(Instant.MAX, Duration.ZERO);\n-        verifySaturating(Instant.MAX, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Instant.MAX);\n-        \/\/ 2. {edge or constant instants} x {normal durations}\n-        verifySaturating(Instant.MIN, Duration.ofDays(-32), Instant.MIN);\n-        verifySaturating(Instant.MIN, Duration.ofDays(32));\n-        verifySaturating(Instant.EPOCH, Duration.ofDays(-32));\n-        verifySaturating(Instant.EPOCH, Duration.ofDays(32));\n-        verifySaturating(Instant.MAX, Duration.ofDays(-32));\n-        verifySaturating(Instant.MAX, Duration.ofDays(32), Instant.MAX);\n-        \/\/ 3. {normal instants with both positive and negative epoch seconds} x {edge or constant durations}\n-        verifySaturating(Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Instant.MIN);\n-        verifySaturating(Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ZERO);\n-        verifySaturating(Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Instant.MAX);\n-        verifySaturating(Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Instant.MIN);\n-        verifySaturating(Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ZERO);\n-        verifySaturating(Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Instant.MAX);\n-        \/\/ 4. {normal instants with both positive and negative epoch seconds} x {normal durations}\n-        verifySaturating(Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(-32));\n-        verifySaturating(Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(32));\n-        verifySaturating(Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(-32));\n-        verifySaturating(Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(32));\n-    }\n-\n-    private static void verifySaturating(Instant i, Duration d, Instant... optionalInstant) {\n+    @DataProvider(name = \"PlusSaturating\")\n+    Object[][] provider_plusSaturating() {\n+        return new Object[][]{\n+                \/\/ 1. {edge or constant instants} x {edge or constant durations}\n+                {Instant.MIN, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.MIN, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.MIN, Duration.ZERO, Optional.empty()},\n+                {Instant.MIN, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MAX)},\n+                {Instant.EPOCH, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.EPOCH, Duration.ZERO, Optional.empty()},\n+                {Instant.EPOCH, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MAX)},\n+                {Instant.MAX, Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.MAX, Duration.ZERO, Optional.empty()},\n+                {Instant.MAX, Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MAX)},\n+                \/\/ 2. {edge or constant instants} x {normal durations}\n+                {Instant.MIN, Duration.ofDays(-32), Optional.of(Instant.MIN)},\n+                {Instant.MIN, Duration.ofDays(32), Optional.empty()},\n+                {Instant.EPOCH, Duration.ofDays(-32), Optional.empty()},\n+                {Instant.EPOCH, Duration.ofDays(32), Optional.empty()},\n+                {Instant.MAX, Duration.ofDays(-32), Optional.empty()},\n+                {Instant.MAX, Duration.ofDays(32), Optional.of(Instant.MAX)},\n+                \/\/ 3. {normal instants with both positive and negative epoch seconds} x {edge or constant durations}\n+                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ZERO, Optional.empty()},\n+                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MAX)},\n+                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MIN_VALUE, 0), Optional.of(Instant.MIN)},\n+                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ZERO, Optional.empty()},\n+                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofSeconds(Long.MAX_VALUE, 999_999_999), Optional.of(Instant.MAX)},\n+                \/\/ 4. {normal instants with both positive and negative epoch seconds} x {normal durations}\n+                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(-32), Optional.empty()},\n+                {Instant.parse(\"1950-01-01T00:00:00Z\"), Duration.ofDays(32), Optional.empty()},\n+                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(-32), Optional.empty()},\n+                {Instant.parse(\"1990-01-01T00:00:00Z\"), Duration.ofDays(32), Optional.empty()},\n+                \/\/ 5. instant boundary\n+                {Instant.MIN, Duration.between(Instant.MIN, Instant.MAX), Optional.of(Instant.MAX)},\n+                {Instant.EPOCH, Duration.between(Instant.EPOCH, Instant.MAX), Optional.of(Instant.MAX)},\n+                {Instant.EPOCH, Duration.between(Instant.EPOCH, Instant.MIN), Optional.of(Instant.MIN)},\n+                {Instant.MAX, Duration.between(Instant.MAX, Instant.MIN), Optional.of(Instant.MIN)}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"PlusSaturating\")\n+    public void plusSaturating(Instant i, Duration d, Optional<Instant> value) {\n@@ -1267,0 +1275,6 @@\n+            \/\/ If `value` is present, perform an additional check. It may be\n+            \/\/ important to ensure that not only does the result of `plusSaturating`\n+            \/\/ match that of `plus`, but that it also matches our expectation.\n+            \/\/ Because if it doesn’t, then the test isn’t testing what we think\n+            \/\/ it is, and needs to be fixed.\n+            value.ifPresent(instant -> assertEquals(actual, instant));\n@@ -1269,1 +1283,4 @@\n-            assertEquals(actual, optionalInstant[0]);\n+            if (value.isEmpty()) {\n+                throw new AssertionError();\n+            }\n+            assertEquals(actual, value.get());\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/TCKInstant.java","additions":54,"deletions":37,"binary":false,"changes":91,"status":"modified"}]}