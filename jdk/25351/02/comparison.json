{"files":[{"patch":"@@ -81,9 +81,42 @@\n-    __ push(rax);\n-    __ push(rcx);\n-    __ push(rdx);\n-    __ push(rdi);\n-    __ push(rsi);\n-    __ push(r8);\n-    __ push(r9);\n-    __ push(r10);\n-    __ push(r11);\n+    if (VM_Version::supports_apx_f()) {\n+      if (_result != rax) {\n+        __ pushp(rax);\n+      }\n+      __ pushp(rcx);\n+      \/\/ Save current stack pointer into rcx\n+      __ movptr(rcx, rsp);\n+      \/\/ Align stack pointer to 16 byte boundary. This is hard constraint\n+      \/\/ for push2\/pop2 with PPX hints.\n+      __ andptr(rsp, -StackAlignmentInBytes);\n+      \/\/ Push original stack pointer.\n+      __ push(rcx);\n+      \/\/ Restore the original contents of RCX register.\n+      __ movptr(rcx, Address(rcx));\n+      \/\/ Now push remaining caller save GPRs and EGPRs on 16B aligned stack.\n+      \/\/ Note: For PPX to work properly, a PPX-marked PUSH2 (respectively, POP2) should always\n+      \/\/ be matched with a PPX-marked POP2 (PUSH2), not with two PPX-marked POPs (PUSHs).\n+      __ pushp(rdx);\n+      __ push2p(rdi, rsi);\n+      __ push2p(r8, r9);\n+      __ push2p(r10, r11);\n+      __ push2p(r16, r17);\n+      __ push2p(r18, r19);\n+      __ push2p(r20, r21);\n+      __ push2p(r22, r23);\n+      __ push2p(r24, r25);\n+      __ push2p(r26, r27);\n+      __ push2p(r28, r29);\n+      __ push2p(r30, r31);\n+    } else {\n+      if (_result != rax) {\n+        __ push(rax);\n+      }\n+      __ push(rcx);\n+      __ push(rdx);\n+      __ push(rdi);\n+      __ push(rsi);\n+      __ push(r8);\n+      __ push(r9);\n+      __ push(r10);\n+      __ push(r11);\n+    }\n@@ -142,12 +175,22 @@\n-    __ pop(r11);\n-    __ pop(r10);\n-    __ pop(r9);\n-    __ pop(r8);\n-    __ pop(rsi);\n-    __ pop(rdi);\n-    __ pop(rdx);\n-    __ pop(rcx);\n-    if (_result == noreg) {\n-      __ pop(rax);\n-    } else if (_result == rax) {\n-      __ addptr(rsp, wordSize);\n+    if (VM_Version::supports_apx_f()) {\n+      __ pop2p(r31, r30);\n+      __ pop2p(r29, r28);\n+      __ pop2p(r27, r26);\n+      __ pop2p(r25, r24);\n+      __ pop2p(r23, r22);\n+      __ pop2p(r21, r20);\n+      __ pop2p(r19, r18);\n+      __ pop2p(r17, r16);\n+      __ pop2p(r11, r10);\n+      __ pop2p(r9, r8);\n+      __ pop2p(rsi, rdi);\n+      __ popp(rdx);\n+      \/\/ Re-instantiate original stack pointer.\n+      __ movptr(rsp, Address(rsp));\n+      __ popp(rcx);\n+      if (_result == noreg) {\n+        __ popp(rax);\n+      } else if (_result != rax) {\n+        __ movptr(_result, rax);\n+        __ popp(rax);\n+      }\n@@ -155,2 +198,14 @@\n-      __ movptr(_result, rax);\n-      __ pop(rax);\n+      __ pop(r11);\n+      __ pop(r10);\n+      __ pop(r9);\n+      __ pop(r8);\n+      __ pop(rsi);\n+      __ pop(rdi);\n+      __ pop(rdx);\n+      __ pop(rcx);\n+      if (_result == noreg) {\n+        __ pop(rax);\n+      } else if (_result != rax) {\n+        __ movptr(_result, rax);\n+        __ pop(rax);\n+      }\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":78,"deletions":23,"binary":false,"changes":101,"status":"modified"}]}