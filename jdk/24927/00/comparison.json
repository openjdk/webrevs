{"files":[{"patch":"@@ -1512,0 +1512,29 @@\n+    \/\/ If there is a successor we should release the lock as soon as\n+    \/\/ posible, so that the successor can aquire the look. If there is\n+    \/\/ no successor, we might need to wake up a waiting thread.\n+    if (!has_successor()) {\n+      ObjectWaiter* w = Atomic::load(&_entry_list);\n+      if (w != nullptr) {\n+        \/\/ Other threads are blocked trying to acquire the lock and\n+        \/\/ there is no successor, so it appears that an heir-\n+        \/\/ presumptive (successor) must be made ready. Since threads\n+        \/\/ are woken up in FIFO order, we need to find the tail of the\n+        \/\/ entry_list.\n+        w = entry_list_tail(current);\n+        \/\/ I'd like to write: guarantee (w->_thread != current).\n+        \/\/ But in practice an exiting thread may find itself on the entry_list.\n+        \/\/ Let's say thread T1 calls O.wait().  Wait() enqueues T1 on O's waitset and\n+        \/\/ then calls exit().  Exit release the lock by setting O._owner to null.\n+        \/\/ Let's say T1 then stalls.  T2 acquires O and calls O.notify().  The\n+        \/\/ notify() operation moves T1 from O's waitset to O's entry_list. T2 then\n+        \/\/ release the lock \"O\".  T1 resumes immediately after the ST of null into\n+        \/\/ _owner, above.  T1 notices that the entry_list is populated, so it\n+        \/\/ reacquires the lock and then finds itself on the entry_list.\n+        \/\/ Given all that, we have to tolerate the circumstance where \"w\" is\n+        \/\/ associated with current.\n+        assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+        exit_epilog(current, w);\n+        return;\n+      }\n+    }\n+\n@@ -1550,5 +1579,3 @@\n-    \/\/ Other threads are blocked trying to acquire the lock and there\n-    \/\/ is no successor, so it appears that an heir-presumptive\n-    \/\/ (successor) must be made ready. Only the current lock owner can\n-    \/\/ detach threads from the entry_list, therefore we need to\n-    \/\/ reacquire the lock. If we fail to reacquire the lock the\n+    \/\/ Only the current lock owner can manipulate the entry_list\n+    \/\/ (except for pushing new threads to the head), therefore we need\n+    \/\/ to reacquire the lock. If we fail to reacquire the lock the\n@@ -1564,21 +1591,0 @@\n-\n-    ObjectWaiter* w = nullptr;\n-\n-    w = Atomic::load(&_entry_list);\n-    if (w != nullptr) {\n-      w = entry_list_tail(current);\n-      \/\/ I'd like to write: guarantee (w->_thread != current).\n-      \/\/ But in practice an exiting thread may find itself on the entry_list.\n-      \/\/ Let's say thread T1 calls O.wait().  Wait() enqueues T1 on O's waitset and\n-      \/\/ then calls exit().  Exit release the lock by setting O._owner to null.\n-      \/\/ Let's say T1 then stalls.  T2 acquires O and calls O.notify().  The\n-      \/\/ notify() operation moves T1 from O's waitset to O's entry_list. T2 then\n-      \/\/ release the lock \"O\".  T1 resumes immediately after the ST of null into\n-      \/\/ _owner, above.  T1 notices that the entry_list is populated, so it\n-      \/\/ reacquires the lock and then finds itself on the entry_list.\n-      \/\/ Given all that, we have to tolerate the circumstance where \"w\" is\n-      \/\/ associated with current.\n-      assert(w->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n-      exit_epilog(current, w);\n-      return;\n-    }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"}]}