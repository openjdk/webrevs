{"files":[{"patch":"@@ -76,153 +76,0 @@\n-\n-    @SuppressWarnings(\"divzero\")\n-    public void cornercaseFloatJava_divzero(Blackhole bh) {\n-            assert Float.isNaN(10 \/ 0);\n-            assert Float.isNaN(10 \/ 0);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n-    public void cornercaseFloatJava(Blackhole bh) {\n-        for (int i = 0; i < DEFAULT_X_RANGE * DEFAULT_Y_RANGE; i++) {\n-            \/\/ Generate some NaNs.\n-            float nan            = Float.NaN;\n-            float zero_div_zero  = 0.0f \/ 0.0f;\n-            float sqrt_negative  = (float)Math.sqrt(-1.0);\n-            float log_negative   = (float)Math.log(-1.0);\n-            float inf_minus_inf  = Float.POSITIVE_INFINITY - Float.POSITIVE_INFINITY;\n-            float inf_times_zero = Float.POSITIVE_INFINITY * 0.0f;\n-            float quiet_nan1     = Float.intBitsToFloat(0x7fc00001);\n-            float quiet_nan2     = Float.intBitsToFloat(0x7fc00002);\n-            float signaling_nan1 = Float.intBitsToFloat(0x7fa00001);\n-            float signaling_nan2 = Float.intBitsToFloat(0x7fa00002);\n-            float nan_minus      = -nan;\n-\n-            \/\/ Generate some infinities.\n-            float positive_inf   = Float.POSITIVE_INFINITY;\n-            float negative_inf   = Float.NEGATIVE_INFINITY;\n-            float one_div_zero   = 1.0f \/ 0.0f;\n-            float log_zero       = (float)Math.log(0.0);\n-\n-            \/\/ Double check that they are actually NaNs.\n-            assert  Float.isNaN(nan);\n-            assert  Float.isNaN(zero_div_zero);\n-            assert  Float.isNaN(sqrt_negative);\n-            assert  Float.isNaN(inf_minus_inf);\n-            assert  Float.isNaN(inf_times_zero);\n-            assert  Float.isNaN(quiet_nan1);\n-            assert  Float.isNaN(quiet_nan2);\n-            assert  Float.isNaN(signaling_nan1);\n-            assert  Float.isNaN(signaling_nan2);\n-            assert  Float.isNaN(nan_minus);\n-            assert  Float.isNaN(log_negative);\n-\n-            \/\/ Double check that they are infinities.\n-            assert  Float.isInfinite(positive_inf);\n-            assert  Float.isInfinite(negative_inf);\n-            assert !Float.isNaN(positive_inf);\n-            assert !Float.isNaN(negative_inf);\n-            assert one_div_zero == positive_inf;\n-            assert log_zero == negative_inf;\n-                \/\/ Double check infinities.\n-\n-            assert Float.isNaN(positive_inf \/ 10);\n-            assert Float.isNaN(negative_inf \/ 10);\n-            cornercaseFloatJava_divzero(bh);\n-            assert (+10 \/ positive_inf) == +10;\n-            assert (+10 \/ negative_inf) == +10;\n-            assert (-10 \/ positive_inf) == -10;\n-            assert (-10 \/ negative_inf) == -10;\n-\n-            \/\/ NaN comparisons always fail.\n-            \/\/ Therefore, all tests that we will do afterwards will be just isNaN.\n-            assert !(1.0f < nan);\n-            assert !(1.0f == nan);\n-            assert !(1.0f > nan);\n-            assert !(nan == nan);\n-\n-            \/\/ NaN propagate through most operations.\n-            assert Float.isNaN(nan + 1.0f);\n-            assert Float.isNaN(1.0f + nan);\n-            assert Float.isNaN(nan + nan);\n-            assert Float.isNaN(nan \/ 1.0f);\n-            assert Float.isNaN(1.0f \/ nan);\n-            assert Float.isNaN((float)Math.sqrt((double)nan));\n-        }\n-    }\n-\n-    @SuppressWarnings(\"divzero\")\n-    public void cornercaseDoubleJava_divzero(Blackhole bh) {\n-            assert Double.isNaN(10 \/ 0);\n-            assert Double.isNaN(10 \/ 0);\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(DEFAULT_X_RANGE * DEFAULT_Y_RANGE)\n-    public void cornercaseDoubleJava(Blackhole bh) {\n-        for (int i = 0; i < DEFAULT_X_RANGE * DEFAULT_Y_RANGE; i++) {\n-            \/\/ Generate some NaNs.\n-            double nan            = Double.NaN;\n-            double zero_div_zero  = 0.0f \/ 0.0f;\n-            double sqrt_negative  = (double)Math.sqrt(-1.0);\n-            double log_negative   = (double)Math.log(-1.0);\n-            double inf_minus_inf  = Double.POSITIVE_INFINITY - Double.POSITIVE_INFINITY;\n-            double inf_times_zero = Double.POSITIVE_INFINITY * 0.0f;\n-            double quiet_nan1     = Double.longBitsToDouble(0x7ffc000000000001L);\n-            double quiet_nan2     = Double.longBitsToDouble(0x7ffc000000000002L);\n-            double signaling_nan1 = Double.longBitsToDouble(0x7ffa000000000001L);\n-            double signaling_nan2 = Double.longBitsToDouble(0x7ffa000000000002L);\n-            double nan_minus      = -nan;\n-\n-            \/\/ Generate some infinities.\n-            double positive_inf   = Double.POSITIVE_INFINITY;\n-            double negative_inf   = Double.NEGATIVE_INFINITY;\n-            double one_div_zero   = 1.0d \/ 0.0f;\n-            double log_zero       = (double)Math.log(0.0);\n-\n-            \/\/ Double check that they are actually NaNs.\n-            assert  Double.isNaN(nan);\n-            assert  Double.isNaN(zero_div_zero);\n-            assert  Double.isNaN(sqrt_negative);\n-            assert  Double.isNaN(inf_minus_inf);\n-            assert  Double.isNaN(inf_times_zero);\n-            assert  Double.isNaN(quiet_nan1);\n-            assert  Double.isNaN(quiet_nan2);\n-            assert  Double.isNaN(signaling_nan1);\n-            assert  Double.isNaN(signaling_nan2);\n-            assert  Double.isNaN(nan_minus);\n-            assert  Double.isNaN(log_negative);\n-\n-            \/\/ Double check that they are infinities.\n-            assert  Double.isInfinite(positive_inf);\n-            assert  Double.isInfinite(negative_inf);\n-            assert !Double.isNaN(positive_inf);\n-            assert !Double.isNaN(negative_inf);\n-            assert one_div_zero == positive_inf;\n-            assert log_zero == negative_inf;\n-                \/\/ Double check infinities.\n-\n-            assert Double.isNaN(positive_inf \/ 10);\n-            assert Double.isNaN(negative_inf \/ 10);\n-            cornercaseDoubleJava_divzero(bh);\n-            assert (+10 \/ positive_inf) == +10;\n-            assert (+10 \/ negative_inf) == +10;\n-            assert (-10 \/ positive_inf) == -10;\n-            assert (-10 \/ negative_inf) == -10;\n-\n-            \/\/ NaN comparisons always fail.\n-            \/\/ Therefore, all tests that we will do afterwards will be just isNaN.\n-            assert !(1.0d < nan);\n-            assert !(1.0d == nan);\n-            assert !(1.0d > nan);\n-            assert !(nan == nan);\n-\n-            \/\/ NaN propagate through most operations.\n-            assert Double.isNaN(nan + 1.0d);\n-            assert Double.isNaN(1.0d + nan);\n-            assert Double.isNaN(nan + nan);\n-            assert Double.isNaN(nan \/ 1.0d);\n-            assert Double.isNaN(1.0d \/ nan);\n-            assert Double.isNaN((double)Math.sqrt((double)nan));\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/floatingpoint\/DremFrem.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"modified"}]}