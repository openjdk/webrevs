{"files":[{"patch":"@@ -970,0 +970,14 @@\n+    protected JCExpression parseIntersectionType(int pos, JCExpression firstType) {\n+        JCExpression t = firstType;\n+        int pos1 = pos;\n+        List<JCExpression> targets = List.of(t);\n+        while (token.kind == AMP) {\n+            accept(AMP);\n+            targets = targets.prepend(parseType());\n+        }\n+        if (targets.length() > 1) {\n+            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));\n+        }\n+        return t;\n+    }\n+\n@@ -1340,9 +1354,1 @@\n-                       int pos1 = pos;\n-                       List<JCExpression> targets = List.of(t = parseType());\n-                       while (token.kind == AMP) {\n-                           accept(AMP);\n-                           targets = targets.prepend(parseType());\n-                       }\n-                       if (targets.length() > 1) {\n-                           t = toP(F.at(pos1).TypeIntersection(targets.reverse()));\n-                       }\n+                       t = parseIntersectionType(pos, parseType());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+import com.sun.tools.javac.parser.JavacParser;\n+import com.sun.tools.javac.parser.Lexer;\n@@ -85,0 +87,3 @@\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.AMP;\n+import com.sun.tools.javac.tree.JCTree;\n@@ -366,1 +371,1 @@\n-            super(sh, task, diagnostics);\n+            super(sh, task, diagnostics, false);\n@@ -405,1 +410,1 @@\n-            super(sh, task, diagnostics);\n+            super(sh, task, diagnostics, true);\n@@ -443,1 +448,1 @@\n-            super(sh, jti, diagnostics);\n+            super(sh, jti, diagnostics, true);\n@@ -507,1 +512,2 @@\n-                            DiagnosticCollector<JavaFileObject> diagnostics) {\n+                            DiagnosticCollector<JavaFileObject> diagnostics,\n+                            boolean analyzeParserFactory) {\n@@ -512,0 +518,3 @@\n+            if (analyzeParserFactory) {\n+                JShellAnalyzeParserFactory.preRegister(context);\n+            }\n@@ -696,1 +705,1 @@\n-            ParserFactory parserFactory = ParserFactory.instance(context);\n+            JShellAnalyzeParserFactory parserFactory = (JShellAnalyzeParserFactory) ParserFactory.instance(context);\n@@ -712,15 +721,20 @@\n-                try {\n-                    \/\/parse the type as a cast, i.e. \"(<typeName>) x\". This is to support\n-                    \/\/intersection types:\n-                    CharBuffer buf = CharBuffer.wrap((\"(\" + typeName +\")x\\u0000\").toCharArray(), 0, typeName.length() + 3);\n-                    Parser parser = parserFactory.newParser(buf, false, false, false);\n-                    JCExpression expr = parser.parseExpression();\n-                    if (expr.hasTag(Tag.TYPECAST)) {\n-                        \/\/if parsed OK, attribute and set the type:\n-                        var2OriginalType.put(field, field.type);\n-\n-                        JCTypeCast tree = (JCTypeCast) expr;\n-                        rs.runWithoutAccessChecks(() -> {\n-                            field.type = attr.attribType(tree.clazz,\n-                                                         enter.getEnvs().iterator().next().enclClass.sym);\n-                        });\n+                parserFactory.runPermitIntersectionTypes(() -> {\n+                    try {\n+                        \/\/parse the type as a cast, i.e. \"(<typeName>) x\". This is to support\n+                        \/\/intersection types:\n+                        CharBuffer buf = CharBuffer.wrap((\"(\" + typeName +\")x\\u0000\").toCharArray(), 0, typeName.length() + 3);\n+                        Parser parser = parserFactory.newParser(buf, false, false, false);\n+                        JCExpression expr = parser.parseExpression();\n+                        if (expr.hasTag(Tag.TYPECAST)) {\n+                            \/\/if parsed OK, attribute and set the type:\n+                            var2OriginalType.put(field, field.type);\n+\n+                            JCTypeCast tree = (JCTypeCast) expr;\n+                            rs.runWithoutAccessChecks(() -> {\n+                                field.type = attr.attribType(tree.clazz,\n+                                                             enter.getEnvs().iterator().next().enclClass.sym);\n+                            });\n+                        }\n+                    } finally {\n+                        log.popDiagnosticHandler(h);\n+                        log.useSource(prev);\n@@ -728,4 +742,1 @@\n-                } finally {\n-                    log.popDiagnosticHandler(h);\n-                    log.useSource(prev);\n-                }\n+                });\n@@ -780,0 +791,48 @@\n+    private static final class JShellAnalyzeParserFactory extends ParserFactory {\n+        public static void preRegister(Context context) {\n+            if (context.get(Marker.class) == null) {\n+                context.put(parserFactoryKey, ((Factory<ParserFactory>) c -> new JShellAnalyzeParserFactory(c)));\n+                context.put(Marker.class, new Marker());\n+            }\n+        }\n+\n+        private final ScannerFactory scannerFactory;\n+        private boolean permitIntersectionTypes;\n+\n+        public JShellAnalyzeParserFactory(Context context) {\n+            super(context);\n+            this.scannerFactory = ScannerFactory.instance(context);\n+        }\n+\n+        \/**Run the given Runnable with intersection type permitted.\n+         *\n+         * @param r Runnnable to run\n+         *\/\n+        public void runPermitIntersectionTypes(Runnable r) {\n+            boolean prevPermitIntersectionTypes = permitIntersectionTypes;\n+            try {\n+                permitIntersectionTypes = true;\n+                r.run();\n+            } finally {\n+                permitIntersectionTypes = prevPermitIntersectionTypes;\n+            }\n+        }\n+\n+        @Override\n+        public JavacParser newParser(CharSequence input, boolean keepDocComments, boolean keepEndPos, boolean keepLineMap, boolean parseModuleInfo) {\n+            com.sun.tools.javac.parser.Lexer lexer = scannerFactory.newScanner(input, keepDocComments);\n+            return new JavacParser(this, lexer, keepDocComments, keepLineMap, keepEndPos, parseModuleInfo) {\n+                @Override\n+                public JCExpression parseType(boolean allowVar, com.sun.tools.javac.util.List<JCTree.JCAnnotation> annotations) {\n+                    int pos = token.pos;\n+                    JCExpression t = super.parseType(allowVar, annotations);\n+                    if (permitIntersectionTypes) {\n+                        t = parseIntersectionType(pos, t);\n+                    }\n+                    return t;\n+                }\n+            };\n+        }\n+\n+        private static final class Marker {}\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":83,"deletions":24,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8144903 8177466 8191842 8211694 8213725 8239536 8257236 8252409 8294431 8322532\n+ * @bug 8144903 8177466 8191842 8211694 8213725 8239536 8257236 8252409 8294431 8322003 8322532\n@@ -630,0 +630,11 @@\n+    public void intersectionTypeAsTypeArgument() { \/\/JDK-8322003\n+        assertEval(\"interface Shape {}\");\n+        assertEval(\"record Square(int edge) implements Shape {}\");\n+        assertEval(\"record Circle(int radius) implements Shape {}\");\n+        assertEval(\"java.util.function.Consumer<Shape> printShape = System.out::println;\");\n+        assertEval(\"Square square = new Square(1);\");\n+        assertEval(\"Circle circle = new Circle(1);\");\n+        assertEval(\"var shapes = java.util.List.of(square, circle);\");\n+        assertEval(\"shapes.forEach(printShape);\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}