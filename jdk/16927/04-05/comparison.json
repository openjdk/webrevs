{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import sun.jvm.hotspot.gc.serial.*;\n@@ -1079,2 +1080,2 @@\n-                        if (collHeap instanceof GenCollectedHeap) {\n-                          GenCollectedHeap heap = (GenCollectedHeap) collHeap;\n+                        if (collHeap instanceof SerialHeap) {\n+                          SerialHeap heap = (SerialHeap) collHeap;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,3 +27,4 @@\n-import sun.jvm.hotspot.debugger.Address;\n-import sun.jvm.hotspot.gc.shared.GenCollectedHeap;\n-import sun.jvm.hotspot.gc.shared.CollectedHeapName;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.gc.shared.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n@@ -31,1 +32,1 @@\n-public class SerialHeap extends GenCollectedHeap {\n+public class SerialHeap extends CollectedHeap {\n@@ -40,0 +41,87 @@\n+\n+  private static AddressField youngGenField;\n+  private static AddressField oldGenField;\n+\n+  private static GenerationFactory genFactory;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"SerialHeap\");\n+\n+    youngGenField = type.getAddressField(\"_young_gen\");\n+    oldGenField = type.getAddressField(\"_old_gen\");\n+\n+    genFactory = new GenerationFactory();\n+  }\n+\n+  public int nGens() {\n+    return 2; \/\/ Young + Old\n+  }\n+\n+  public Generation getGen(int i) {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that((i == 0) || (i == 1), \"Index \" + i +\n+                  \" out of range (should be 0 or 1)\");\n+    }\n+\n+    switch (i) {\n+    case 0:\n+      return genFactory.newObject(youngGenField.getValue(addr));\n+    case 1:\n+      return genFactory.newObject(oldGenField.getValue(addr));\n+    default:\n+      \/\/ no generation for i, and assertions disabled.\n+      return null;\n+    }\n+  }\n+\n+  public boolean isIn(Address a) {\n+    for (int i = 0; i < nGens(); i++) {\n+      Generation gen = getGen(i);\n+      if (gen.isIn(a)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  public long capacity() {\n+    long capacity = 0;\n+    for (int i = 0; i < nGens(); i++) {\n+      capacity += getGen(i).capacity();\n+    }\n+    return capacity;\n+  }\n+\n+  public long used() {\n+    long used = 0;\n+    for (int i = 0; i < nGens(); i++) {\n+      used += getGen(i).used();\n+    }\n+    return used;\n+  }\n+\n+  public void liveRegionsIterate(LiveRegionsClosure closure) {\n+    \/\/ Run through all generations, obtaining bottom-top pairs.\n+    for (int i = 0; i < nGens(); i++) {\n+      Generation gen = getGen(i);\n+      gen.liveRegionsIterate(closure);\n+    }\n+  }\n+\n+  public void printOn(PrintStream tty) {\n+    for (int i = 0; i < nGens(); i++) {\n+      tty.print(\"Gen \" + i + \": \");\n+      getGen(i).printOn(tty);\n+      tty.println(\"Invocations: \" + getGen(i).invocations());\n+      tty.println();\n+    }\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":92,"deletions":4,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.io.*;\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.gc.shared.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public abstract class GenCollectedHeap extends CollectedHeap {\n-  private static AddressField youngGenField;\n-  private static AddressField oldGenField;\n-\n-  private static GenerationFactory genFactory;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"GenCollectedHeap\");\n-\n-    youngGenField = type.getAddressField(\"_young_gen\");\n-    oldGenField = type.getAddressField(\"_old_gen\");\n-\n-    genFactory = new GenerationFactory();\n-  }\n-\n-  public GenCollectedHeap(Address addr) {\n-    super(addr);\n-  }\n-\n-  public int nGens() {\n-    return 2; \/\/ Young + Old\n-  }\n-\n-  public Generation getGen(int i) {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that((i == 0) || (i == 1), \"Index \" + i +\n-                  \" out of range (should be 0 or 1)\");\n-    }\n-\n-    switch (i) {\n-    case 0:\n-      return genFactory.newObject(youngGenField.getValue(addr));\n-    case 1:\n-      return genFactory.newObject(oldGenField.getValue(addr));\n-    default:\n-      \/\/ no generation for i, and assertions disabled.\n-      return null;\n-    }\n-  }\n-\n-  public boolean isIn(Address a) {\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      if (gen.isIn(a)) {\n-        return true;\n-      }\n-    }\n-\n-    return false;\n-  }\n-\n-  public long capacity() {\n-    long capacity = 0;\n-    for (int i = 0; i < nGens(); i++) {\n-      capacity += getGen(i).capacity();\n-    }\n-    return capacity;\n-  }\n-\n-  public long used() {\n-    long used = 0;\n-    for (int i = 0; i < nGens(); i++) {\n-      used += getGen(i).used();\n-    }\n-    return used;\n-  }\n-\n-  public void liveRegionsIterate(LiveRegionsClosure closure) {\n-    \/\/ Run through all generations, obtaining bottom-top pairs.\n-    for (int i = 0; i < nGens(); i++) {\n-      Generation gen = getGen(i);\n-      gen.liveRegionsIterate(closure);\n-    }\n-  }\n-\n-  public void printOn(PrintStream tty) {\n-    for (int i = 0; i < nGens(); i++) {\n-      tty.print(\"Gen \" + i + \": \");\n-      getGen(i).printOn(tty);\n-      tty.println(\"Invocations: \" + getGen(i).invocations());\n-      tty.println();\n-    }\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenCollectedHeap.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -96,4 +96,4 @@\n-      if (heap instanceof GenCollectedHeap) {\n-         GenCollectedHeap genHeap = (GenCollectedHeap) heap;\n-         for (int n = 0; n < genHeap.nGens(); n++) {\n-            Generation gen = genHeap.getGen(n);\n+      if (heap instanceof SerialHeap) {\n+         SerialHeap sh = (SerialHeap) heap;\n+         for (int n = 0; n < sh.nGens(); n++) {\n+            Generation gen = sh.getGen(n);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/HeapSummary.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,37 +87,3 @@\n-    if (heap instanceof GenCollectedHeap) {\n-      GenCollectedHeap genheap = (GenCollectedHeap) heap;\n-      if (genheap.isIn(a)) {\n-        loc.heap = heap;\n-        for (int i = 0; i < genheap.nGens(); i++) {\n-          Generation g = genheap.getGen(i);\n-          if (g.isIn(a)) {\n-            loc.gen = g;\n-            break;\n-          }\n-        }\n-\n-        if (Assert.ASSERTS_ENABLED) {\n-          Assert.that(loc.gen != null, \"Should have found this in a generation\");\n-        }\n-\n-        if (VM.getVM().getUseTLAB()) {\n-          \/\/ Try to find thread containing it\n-          for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n-            JavaThread t = threads.getJavaThreadAt(i);\n-            ThreadLocalAllocBuffer tlab = t.tlab();\n-            if (tlab.contains(a)) {\n-              loc.inTLAB = true;\n-              loc.tlabThread = t;\n-              loc.tlab = tlab;\n-              break;\n-            }\n-          }\n-        }\n-\n-        return loc;\n-      }\n-    } else {\n-      if (heap.isIn(a)) {\n-        loc.heap = heap;\n-        return loc;\n-      }\n+    if (heap.isIn(a)) {\n+      loc.heap = heap;\n+      return loc;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerFinder.java","additions":3,"deletions":37,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -113,12 +113,0 @@\n-  public boolean isInNewGen() {\n-    return ((gen != null) && (gen.equals(((GenCollectedHeap)heap).getGen(0))));\n-  }\n-\n-  public boolean isInOldGen() {\n-    return ((gen != null) && (gen.equals(((GenCollectedHeap)heap).getGen(1))));\n-  }\n-\n-  public boolean inOtherGen() {\n-    return (!isInNewGen() && !isInOldGen());\n-  }\n-\n@@ -129,1 +117,0 @@\n-  \/** This may be true if isInNewGen is also true *\/\n@@ -269,2 +256,1 @@\n-    } else if (isInHeap()) {\n-      if (isInTLAB()) {\n+    } else if (isInHeap() && isInTLAB()) {\n@@ -275,13 +261,0 @@\n-      } else {\n-        if (isInNewGen()) {\n-          tty.print(\"In new generation \");\n-        } else if (isInOldGen()) {\n-          tty.print(\"In old generation \");\n-        } else {\n-          tty.print(\"In unknown section of Java heap\");\n-        }\n-        if (getGeneration() != null) {\n-          getGeneration().printOn(tty); \/\/ does not include \"\\n\"\n-        }\n-        tty.println();\n-      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerLocation.java","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"}]}