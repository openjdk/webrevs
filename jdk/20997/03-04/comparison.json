{"files":[{"patch":"@@ -63,1 +63,2 @@\n- * Following is the high level flow of the launcher code residing in the common java.c and this\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n@@ -66,29 +67,51 @@\n- *  - JLI_Launch function, which is the entry point to the launcher, calls CreateExecutionEnvironment.\n- *\n- *  - CreateExecutionEnvironment does the following (not necessarily in this order):\n- *      - determines the relevant JVM type that needs to be ultimately created\n- *      - determines the path and asserts the presence of libjava and relevant libjvm library\n- *      - removes any JVM selection options from the arguments that were passed to the launcher\n- *\n- *  - CreateExecutionEnvironment then creates a new thread, within the same process, to launch the application's main()\n- *    Java method and parks the current thread, on which CreateExecutionEnvironment was invoked, in Apple's Cocoa event\n- *    loop. Before doing so, CreateExecutionEnvironment maintains a state flag to keep note that a new thread\n- *    has been spawned.\n- *\n- *  - The newly created thread (in which the application's main() method will ultimately run) starts right from the\n- *    beginning of the current process' main function, which effectively means that JLI_Launch is re-invoked on this\n- *    new thread and the same above sequence of code flow repeats again. During this \"recursive\" call, when at the\n- *    point of creating a new thread in CreateExecutionEnvironment, the CreateExecutionEnvironment will check for\n- *    the state flag to see if a new thread has already been spawned and upon noticing that it has, it will skip\n- *    spawning any more threads and will return back from CreateExecutionEnvironment.\n- *\n- *  - The control returns back from CreateExecutionEnvironment to JLI_Launch, and the thread on which the control\n- *    returns is the thread on which the application's main() Java method will be invoked.\n- *\n- *  - JLI_Launch then invokes LoadJavaVM which dlopen()s the JVM library and asserts the presence of\n- *    JNI Invocation Functions \"JNI_CreateJavaVM\", \"JNI_GetDefaultJavaVMInitArgs\" and \"JNI_GetCreatedJavaVMs\" in that\n- *    library. It then sets internal function pointers in the launcher to point to those functions.\n- *\n- *  - JLI_Launch then translates any -J options by invoking TranslateApplicationArgs.\n- *\n- *  - JLI_Launch then invokes ParseArguments to parse\/process the launcher arguments.\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n+ *\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that needs\n+ *        to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n+ *\n+ *  - CreateExecutionEnvironment then creates a new\n+ *    thread, within the same process, to launch the\n+ *    application's main() Java method and parks the\n+ *    current thread, on which CreateExecutionEnvironment\n+ *    was invoked, in Apple's Cocoa event loop. Before\n+ *    doing so, CreateExecutionEnvironment maintains a\n+ *    state flag to keep note that a new thread has\n+ *    been spawned.\n+ *\n+ *  - The newly created thread (in which the application's\n+ *    main() method will ultimately run) starts right from\n+ *    the beginning of the current process' main function,\n+ *    which effectively means that JLI_Launch is re-invoked\n+ *    on this new thread and the same above sequence of code\n+ *    flow repeats again. During this \"recursive\" call, when\n+ *    at the point of creating a new thread in\n+ *    CreateExecutionEnvironment, the CreateExecutionEnvironment\n+ *    will check for the state flag to see if a new thread\n+ *    has already been spawned and upon noticing that it\n+ *    has, it will skip spawning any more threads and will\n+ *    return back from CreateExecutionEnvironment.\n+ *\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch, and the thread on which the control\n+ *    returns is the thread on which the application's main()\n+ *    Java method will be invoked.\n+ *\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s the\n+ *    JVM library and asserts the presence of JNI Invocation\n+ *    Functions \"JNI_CreateJavaVM\", \"JNI_GetDefaultJavaVMInitArgs\"\n+ *    and \"JNI_GetCreatedJavaVMs\" in that library. It then sets\n+ *    internal function pointers in the launcher to point to\n+ *    those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by invoking\n+ *    TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to parse\/process\n+ *    the launcher arguments.\n@@ -100,1 +123,2 @@\n- *  - JavaMain, before launching the application, invokes PostJVMInit.\n+ *  - JavaMain, before launching the application, invokes\n+ *    PostJVMInit.\n@@ -102,1 +126,2 @@\n- *  - PostJVMInit invokes ShowSplashScreen which displays a splash screen for the application, if applicable.\n+ *  - PostJVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n@@ -104,2 +129,3 @@\n- *  - Control then returns back from PostJVMInit into JavaMain, which then loads the application's main class\n- *    and invokes the relevant main() Java method.\n+ *  - Control then returns back from PostJVMInit into\n+ *    JavaMain, which then loads the application's main\n+ *    class and invokes the relevant main() Java method.\n@@ -107,2 +133,3 @@\n- *  - JavaMain then returns back an integer result which then gets propagated as a return value all the way out\n- *    of the JLI_Launch function.\n+ *  - JavaMain then returns back an integer result which\n+ *    then gets propagated as a return value all the way\n+ *    out of the JLI_Launch function.\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":63,"deletions":36,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n- * Following is the high level flow of the launcher code residing in the common java.c and this\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n@@ -58,1 +59,2 @@\n- *  - JLI_Launch function, which is the entry point to the launcher, calls CreateExecutionEnvironment.\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n@@ -60,4 +62,8 @@\n- *  - CreateExecutionEnvironment does the following (not necessarily in this order):\n- *      - determines the relevant JVM type that needs to be ultimately created\n- *      - determines the path and asserts the presence of libjava and relevant libjvm library\n- *      - removes any JVM selection options from the arguments that were passed to the launcher\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that\n+ *        needs to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n@@ -65,1 +71,2 @@\n- *  - CreateExecutionEnvironment then determines if LD_LIBRARY_PATH environment variable needs\n+ *  - CreateExecutionEnvironment then determines if\n+ *    LD_LIBRARY_PATH environment variable needs\n@@ -67,3 +74,6 @@\n- *      - If LD_LIBRARY_PATH needs to be set\/updated, then CreateExecutionEnvironment exec()s\n- *        the current process with the appropriate value for LD_LIBRARY_PATH.\n- *      - Else if LD_LIBRARY_PATH need not be set or updated, then CreateExecutionEnvironment\n+ *      - If LD_LIBRARY_PATH needs to be set\/updated,\n+ *        then CreateExecutionEnvironment exec()s\n+ *        the current process with the appropriate value\n+ *        for LD_LIBRARY_PATH.\n+ *      - Else if LD_LIBRARY_PATH need not be set or\n+ *        updated, then CreateExecutionEnvironment\n@@ -72,17 +82,26 @@\n- *  - If CreateExecutionEnvironment exec()ed the process in the previous step, then the code control\n- *    for the process will again start from the process' entry point and JLI_Launch is thus\n- *    re-invoked and the same above sequence of code flow repeats again. During this \"recursive\"\n- *    call into CreateExecutionEnvironment, the implementation of the check for LD_LIBRARY_PATH\n- *    will realize that no further exec() is required and the control will return back from\n- *    CreateExecutionEnvironment.\n- *\n- *  - The control returns back from CreateExecutionEnvironment to JLI_Launch.\n- *\n- *  - JLI_Launch then invokes LoadJavaVM which dlopen()s the JVM library and asserts the presence of\n- *    JNI Invocation Functions \"JNI_CreateJavaVM\", \"JNI_GetDefaultJavaVMInitArgs\" and\n- *    \"JNI_GetCreatedJavaVMs\" in that library. It then sets internal function pointers in the\n- *    launcher to point to those functions.\n- *\n- *  - JLI_Launch then translates any -J options by invoking TranslateApplicationArgs.\n- *\n- *  - JLI_Launch then invokes ParseArguments to parse\/process the launcher arguments.\n+ *  - If CreateExecutionEnvironment exec()ed the process\n+ *    in the previous step, then the code control for the\n+ *    process will again start from the process' entry\n+ *    point and JLI_Launch is thus re-invoked and the\n+ *    same above sequence of code flow repeats again.\n+ *    During this \"recursive\" call into CreateExecutionEnvironment,\n+ *    the implementation of the check for LD_LIBRARY_PATH\n+ *    will realize that no further exec() is required and\n+ *    the control will return back from CreateExecutionEnvironment.\n+ *\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch.\n+ *\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s\n+ *    the JVM library and asserts the presence of\n+ *    JNI Invocation Functions \"JNI_CreateJavaVM\",\n+ *    \"JNI_GetDefaultJavaVMInitArgs\" and\n+ *    \"JNI_GetCreatedJavaVMs\" in that library. It then\n+ *    sets internal function pointers in the launcher to\n+ *    point to those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by\n+ *    invoking TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to\n+ *    parse\/process the launcher arguments.\n@@ -92,2 +111,2 @@\n- *  - JVMInit invokes ShowSplashScreen which displays a splash screen for the application,\n- *    if applicable.\n+ *  - JVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n@@ -95,3 +114,4 @@\n- *  - JVMInit then creates a new thread (T2), in the current process, and invokes JavaMain function\n- *    in that new thread. The current thread (T1) then waits for the newly launched thread (T2) to\n- *    complete.\n+ *  - JVMInit then creates a new thread (T2), in the\n+ *    current process, and invokes JavaMain function\n+ *    in that new thread. The current thread (T1) then\n+ *    waits for the newly launched thread (T2) to complete.\n@@ -99,1 +119,2 @@\n- *  - JavaMain function, in thread T2, before launching the application, invokes PostJVMInit.\n+ *  - JavaMain function, in thread T2, before launching\n+ *    the application, invokes PostJVMInit.\n@@ -103,2 +124,3 @@\n- *  - Control then returns back from PostJVMInit into JavaMain, which then loads the application's\n- *    main class and invokes the relevant main() Java method.\n+ *  - Control then returns back from PostJVMInit into JavaMain,\n+ *    which then loads the application's main class and invokes\n+ *    the relevant main() Java method.\n@@ -106,1 +128,2 @@\n- *  - JavaMain, in thread T2, then returns back an integer result and thread T2 execution ends here.\n+ *  - JavaMain, in thread T2, then returns back an integer\n+ *    result and thread T2 execution ends here.\n@@ -108,2 +131,4 @@\n- *  - The thread T1 in JVMInit, which is waiting on T2 to complete, receives the integer result and\n- *    then propagates it as a return value all the way out of the JLI_Launch function.\n+ *  - The thread T1 in JVMInit, which is waiting on T2 to\n+ *    complete, receives the integer result and then propagates\n+ *    it as a return value all the way out of the\n+ *    JLI_Launch function.\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":63,"deletions":38,"binary":false,"changes":101,"status":"modified"}]}