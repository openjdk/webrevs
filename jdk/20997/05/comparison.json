{"files":[{"patch":"@@ -63,109 +63,73 @@\n- * If a processor \/ os combination has the ability to run binaries of\n- * two data models and cohabitation of jre\/jdk bits with both data\n- * models is supported, then DUAL_MODE is defined. MacOSX is a hybrid\n- * system in that, the universal library can contain all types of libraries\n- * 32\/64 and client\/server, thus the spawn is capable of linking with the\n- * appropriate library as requested.\n- *\n- * Notes:\n- * 1. VM. DUAL_MODE is disabled, and not supported, however, it is left here in\n- *    for experimentation and perhaps enable it in the future.\n- * 2. At the time of this writing, the universal library contains only\n- *    a server 64-bit server JVM.\n- * 3. \"-client\" command line option is supported merely as a command line flag,\n- *    for, compatibility reasons, however, a server VM will be launched.\n- *\/\n-\n-\/*\n- * Flowchart of launcher execs and options processing on unix\n- *\n- * The selection of the proper vm shared library to open depends on\n- * several classes of command line options, including vm \"flavor\"\n- * options (-client, -server) and the data model options, -d32  and\n- * -d64, as well as a version specification which may have come from\n- * the command line or from the manifest of an executable jar file.\n- * The vm selection options are not passed to the running\n- * virtual machine; they must be screened out by the launcher.\n- *\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n- *\n- * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n- * required libraries are loaded by the runtime linker, using the known paths\n- * baked into the shared libraries at compile time. Therefore,\n- * in most cases, the launcher will only exec, if the data models are\n- * mismatched, and will not set any environment variables, regardless of the\n- * data models.\n- *\n- *\n- *\n- *  Main\n- *  (incoming argv)\n- *  |\n- * \\|\/\n- * CreateExecutionEnvironment\n- * (determines desired data model)\n- *  |\n- *  |\n- * \\|\/\n- *  Have Desired Model ? --> NO --> Is Dual-Mode ? --> NO --> Exit(with error)\n- *  |                                          |\n- *  |                                          |\n- *  |                                         \\|\/\n- *  |                                         YES\n- *  |                                          |\n- *  |                                          |\n- *  |                                         \\|\/\n- *  |                                CheckJvmType\n- *  |                               (removes -client, -server etc.)\n- *  |                                          |\n- *  |                                          |\n- * \\|\/                                        \\|\/\n- * YES                             Find the desired executable\/library\n- *  |                                          |\n- *  |                                          |\n- * \\|\/                                        \\|\/\n- * CheckJvmType                             POINT A\n- * (removes -client, -server, etc.)\n- *  |\n- *  |\n- * \\|\/\n- * TranslateDashJArgs...\n- * (Prepare to pass args to vm)\n- *  |\n- *  |\n- * \\|\/\n- * ParseArguments\n- * (processes version options,\n- *  creates argument list for vm,\n- *  etc.)\n- *   |\n- *   |\n- *  \\|\/\n- * POINT A\n- *   |\n- *   |\n- *  \\|\/\n- * Path is desired JRE ? YES --> Continue\n- *  NO\n- *   |\n- *   |\n- *  \\|\/\n- * Paths have well known\n- * jvm paths ?       --> NO --> Continue\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Does libjvm.so exist\n- *  in any of them ? --> NO --> Continue\n- *   YES\n- *   |\n- *   |\n- *  \\|\/\n- * Re-exec \/ Spawn\n- *   |\n- *   |\n- *  \\|\/\n- * Main\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n+ * macosx specific java_md_macosx file:\n+ *\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n+ *\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that needs\n+ *        to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n+ *\n+ *  - CreateExecutionEnvironment then creates a new\n+ *    thread, within the same process, to launch the\n+ *    application's main() Java method and parks the\n+ *    current thread, on which CreateExecutionEnvironment\n+ *    was invoked, in Apple's Cocoa event loop. Before\n+ *    doing so, CreateExecutionEnvironment maintains a\n+ *    state flag to keep note that a new thread has\n+ *    been spawned.\n+ *\n+ *  - The newly created thread (in which the application's\n+ *    main() method will ultimately run) starts right from\n+ *    the beginning of the current process' main function,\n+ *    which effectively means that JLI_Launch is re-invoked\n+ *    on this new thread and the same above sequence of code\n+ *    flow repeats again. During this \"recursive\" call, when\n+ *    at the point of creating a new thread in\n+ *    CreateExecutionEnvironment, the CreateExecutionEnvironment\n+ *    will check for the state flag to see if a new thread\n+ *    has already been spawned and upon noticing that it\n+ *    has, it will skip spawning any more threads and will\n+ *    return back from CreateExecutionEnvironment.\n+ *\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch, and the thread on which the control\n+ *    returns is the thread on which the application's main()\n+ *    Java method will be invoked.\n+ *\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s the\n+ *    JVM library and asserts the presence of JNI Invocation\n+ *    Functions \"JNI_CreateJavaVM\", \"JNI_GetDefaultJavaVMInitArgs\"\n+ *    and \"JNI_GetCreatedJavaVMs\" in that library. It then sets\n+ *    internal function pointers in the launcher to point to\n+ *    those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by invoking\n+ *    TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to parse\/process\n+ *    the launcher arguments.\n+ *\n+ *  - JLI_Launch then ultimately calls JVMInit.\n+ *\n+ *  - JVMInit then invokes JavaMain.\n+ *\n+ *  - JavaMain, before launching the application, invokes\n+ *    PostJVMInit.\n+ *\n+ *  - PostJVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n+ *\n+ *  - Control then returns back from PostJVMInit into\n+ *    JavaMain, which then loads the application's main\n+ *    class and invokes the relevant main() Java method.\n+ *\n+ *  - JavaMain then returns back an integer result which\n+ *    then gets propagated as a return value all the way\n+ *    out of the JLI_Launch function.\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":73,"deletions":109,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * vm does not understand and will not process.  These options include\n+ * vm does not understand and will not process. These options include\n@@ -39,1 +39,1 @@\n- * -server) as well as options which select the data model to use.\n+ * -server).\n@@ -45,6 +45,1 @@\n- * removes \"-J\" prefixes.  The CreateExecutionEnvironment function processes\n- * and removes -d<n> options. On unix, there is a possibility that the running\n- * data model may not match to the desired data model, in this case an exec is\n- * required to start the desired model. If the data models match, then\n- * ParseArguments will remove the -d<n> flags. If the data models do not match\n- * the CreateExecutionEnviroment will remove the -d<n> flags.\n+ * removes \"-J\" prefixes.\n@@ -58,0 +53,1 @@\n+#include \"stdbool.h\"\n@@ -61,2 +57,2 @@\n- * the program image remain relatively small until after SelectVersion\n- * CreateExecutionEnvironment have finished their possibly recursive\n+ * the program image remain relatively small until after\n+ * CreateExecutionEnvironment has finished its possibly recursive\n@@ -91,4 +87,4 @@\n- * Entries for splash screen environment variables.\n- * putenv is performed in SelectVersion. We need\n- * them in memory until UnsetEnv, so they are made static\n- * global instead of auto local.\n+ * Values that will be stored into splash screen environment variables.\n+ * putenv is performed to set _JAVA_SPLASH_FILE and _JAVA_SPLASH_JAR\n+ * with these values. We need them in memory until UnsetEnv in\n+ * ShowSplashScreen, so they are made static global instead of auto local.\n@@ -113,1 +109,0 @@\n-static void SelectVersion(int argc, char **argv, char **main_class);\n@@ -116,1 +111,1 @@\n-                               int *pret, const char *jrepath);\n+                               int *pret);\n@@ -121,0 +116,1 @@\n+static void SetupSplashScreenEnvVars(const char *splash_file_name, char *jar_path);\n@@ -243,1 +239,0 @@\n-    char *main_class = NULL;\n@@ -260,0 +255,4 @@\n+        char *env_in;\n+        if ((env_in = getenv(MAIN_CLASS_ENV_ENTRY)) != NULL) {\n+            printf(\"Launched through Multiple JRE (mJRE) support\\n\");\n+        }\n@@ -272,12 +271,0 @@\n-    \/*\n-     * SelectVersion() has several responsibilities:\n-     *\n-     *  1) Disallow specification of another JRE.  With 1.9, another\n-     *     version of the JRE cannot be invoked.\n-     *  2) Allow for a JRE version to invoke JDK 1.9 or later.  Since\n-     *     all mJRE directives have been stripped from the request but\n-     *     the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been\n-     *     invoked from the command line.\n-     *\/\n-    SelectVersion(argc, argv, &main_class);\n-\n@@ -326,1 +313,1 @@\n-    if (!ParseArguments(&argc, &argv, &mode, &what, &ret, jrepath)) {\n+    if (!ParseArguments(&argc, &argv, &mode, &what, &ret)) {\n@@ -1081,161 +1068,0 @@\n-\/*\n- * The SelectVersion() routine ensures that an appropriate version of\n- * the JRE is running.  The specification for the appropriate version\n- * is obtained from either the manifest of a jar file (preferred) or\n- * from command line options.\n- * The routine also parses splash screen command line options and\n- * passes on their values in private environment variables.\n- *\/\n-static void\n-SelectVersion(int argc, char **argv, char **main_class)\n-{\n-    char    *arg;\n-    char    *operand;\n-    int     jarflag = 0;\n-    int     headlessflag = 0;\n-    manifest_info info;\n-    char    *splash_file_name = NULL;\n-    char    *splash_jar_name = NULL;\n-    char    *env_in;\n-    int     res;\n-    jboolean has_arg;\n-\n-    \/*\n-     * If the version has already been selected, set *main_class\n-     * with the value passed through the environment (if any) and\n-     * simply return.\n-     *\/\n-\n-    \/*\n-     * This environmental variable can be set by mJRE capable JREs\n-     * [ 1.5 thru 1.8 ].  All other aspects of mJRE processing have been\n-     * stripped by those JREs.  This environmental variable allows 1.9+\n-     * JREs to be started by these mJRE capable JREs.\n-     * Note that mJRE directives in the jar manifest file would have been\n-     * ignored for a JRE started by another JRE...\n-     * .. skipped for JRE 1.5 and beyond.\n-     * .. not even checked for pre 1.5.\n-     *\/\n-    if ((env_in = getenv(ENV_ENTRY)) != NULL) {\n-        if (*env_in != '\\0')\n-            *main_class = JLI_StringDup(env_in);\n-        return;\n-    }\n-\n-    \/*\n-     * Scan through the arguments for options relevant to multiple JRE\n-     * support.  Multiple JRE support existed in JRE versions 1.5 thru 1.8.\n-     *\n-     * This capability is no longer available with JRE versions 1.9 and later.\n-     * These command line options are reported as errors.\n-     *\/\n-\n-    argc--;\n-    argv++;\n-    while (argc > 0 && *(arg = *argv) == '-') {\n-        has_arg = IsOptionWithArgument(argc, argv);\n-        if (JLI_StrCCmp(arg, \"-version:\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR1);\n-        } else if (JLI_StrCmp(arg, \"-jre-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else if (JLI_StrCmp(arg, \"-jre-no-restrict-search\") == 0) {\n-            JLI_ReportErrorMessage(SPC_ERROR2);\n-        } else {\n-            if (JLI_StrCmp(arg, \"-jar\") == 0)\n-                jarflag = 1;\n-            if (IsWhiteSpaceOption(arg)) {\n-                if (has_arg) {\n-                    argc--;\n-                    argv++;\n-                    arg = *argv;\n-                }\n-            }\n-\n-            \/*\n-             * Checking for headless toolkit option in the some way as AWT does:\n-             * \"true\" means true and any other value means false\n-             *\/\n-            if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n-                headlessflag = 1;\n-            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n-                headlessflag = 0;\n-            } else if (JLI_StrCCmp(arg, \"-splash:\") == 0) {\n-                splash_file_name = arg+8;\n-            }\n-        }\n-        argc--;\n-        argv++;\n-    }\n-    if (argc <= 0) {    \/* No operand? Possibly legit with -[full]version *\/\n-        operand = NULL;\n-    } else {\n-        argc--;\n-        operand = *argv++;\n-    }\n-\n-    \/*\n-     * If there is a jar file, read the manifest. If the jarfile can't be\n-     * read, the manifest can't be read from the jar file, or the manifest\n-     * is corrupt, issue the appropriate error messages and exit.\n-     *\n-     * Even if there isn't a jar file, construct a manifest_info structure\n-     * containing the command line information.  It's a convenient way to carry\n-     * this data around.\n-     *\/\n-    if (jarflag && operand) {\n-        if ((res = JLI_ParseManifest(operand, &info)) != 0) {\n-            if (res == -1)\n-                JLI_ReportErrorMessage(JAR_ERROR2, operand);\n-            else\n-                JLI_ReportErrorMessage(JAR_ERROR3, operand);\n-            exit(1);\n-        }\n-\n-        \/*\n-         * Command line splash screen option should have precedence\n-         * over the manifest, so the manifest data is used only if\n-         * splash_file_name has not been initialized above during command\n-         * line parsing\n-         *\/\n-        if (!headlessflag && !splash_file_name && info.splashscreen_image_file_name) {\n-            splash_file_name = info.splashscreen_image_file_name;\n-            splash_jar_name = operand;\n-        }\n-    } else {\n-        info.manifest_version = NULL;\n-        info.main_class = NULL;\n-        info.jre_version = NULL;\n-        info.jre_restrict_search = 0;\n-    }\n-\n-    \/*\n-     * Passing on splash screen info in environment variables\n-     *\/\n-    if (splash_file_name && !headlessflag) {\n-        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")+JLI_StrLen(splash_file_name)+1);\n-        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_file_entry, splash_file_name);\n-        putenv(splash_file_entry);\n-    }\n-    if (splash_jar_name && !headlessflag) {\n-        splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\")+JLI_StrLen(splash_jar_name)+1);\n-        JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n-        JLI_StrCat(splash_jar_entry, splash_jar_name);\n-        putenv(splash_jar_entry);\n-    }\n-\n-\n-    \/*\n-     * \"Valid\" returns (other than unrecoverable errors) follow.  Set\n-     * main_class as a side-effect of this routine.\n-     *\/\n-    if (info.main_class != NULL)\n-        *main_class = JLI_StringDup(info.main_class);\n-\n-    if (info.jre_version == NULL) {\n-        JLI_FreeManifest();\n-        return;\n-    }\n-\n-}\n-\n@@ -1328,1 +1154,1 @@\n-               int *pret, const char *jrepath)\n+               int *pret)\n@@ -1334,0 +1160,2 @@\n+    bool headless = false;\n+    char *splash_file_path = NULL; \/\/ value of \"-splash:\" option\n@@ -1392,0 +1220,6 @@\n+        } else if (JLI_StrCCmp(arg, \"-version:\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR1, arg);\n+        } else if (JLI_StrCmp(arg, \"-jre-restrict-search\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR2, arg);\n+        } else if (JLI_StrCmp(arg, \"-jre-no-restrict-search\") == 0) {\n+            REPORT_ERROR(NULL, SPC_ERROR2, arg);\n@@ -1490,1 +1324,1 @@\n-            ; \/* Ignore machine independent options already handled *\/\n+            splash_file_path = arg + 8;\n@@ -1499,0 +1333,8 @@\n+            } else if (JLI_StrCmp(arg, \"-Djava.awt.headless=true\") == 0) {\n+                \/*\n+                 * Checking for headless toolkit option in the same way as AWT does:\n+                 * \"true\" means true and any other value means false\n+                 *\/\n+                headless = true;\n+            } else if (JLI_StrCCmp(arg, \"-Djava.awt.headless=\") == 0) {\n+                headless = false;\n@@ -1549,0 +1391,10 @@\n+    if (!headless) {\n+        char *jar_path = NULL;\n+        if (mode == LM_JAR) {\n+            jar_path = *pwhat;\n+        }\n+        \/\/ Not in headless mode. We now set a couple of env variables that\n+        \/\/ will be used later by ShowSplashScreen().\n+        SetupSplashScreenEnvVars(splash_file_path, jar_path);\n+    }\n+\n@@ -1552,0 +1404,57 @@\n+static void\n+SetupSplashScreenEnvVars(const char *splash_file_path, \/\/ \"-splash:\" option value (may be NULL)\n+                         char *jar_path \/\/ the jar file being launched (may be NULL)\n+) {\n+\n+    \/\/ Command line specified \"-splash:\" takes priority over manifest one.\n+    if (splash_file_path) {\n+        \/\/ We set up the splash file name as a env variable which then gets\n+        \/\/ used when showing the splash screen in ShowSplashScreen().\n+\n+        \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+        splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                         + JLI_StrLen(splash_file_path) + 1);\n+        JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+        JLI_StrCat(splash_file_entry, splash_file_path);\n+        putenv(splash_file_entry);\n+        return;\n+    }\n+    if (!jar_path) {\n+        \/\/ no jar to look into for \"SplashScreen-Image\" manifest attribute\n+        return;\n+    }\n+    \/\/ parse the jar's manifest to find any \"SplashScreen-Image\"\n+    int res = 0;\n+    manifest_info  info;\n+    if ((res = JLI_ParseManifest(jar_path, &info)) != 0) {\n+        JLI_FreeManifest(); \/\/ cleanup any manifest structure\n+        if (res == -1) {\n+            JLI_ReportErrorMessage(JAR_ERROR2, jar_path);\n+        } else {\n+            JLI_ReportErrorMessage(JAR_ERROR3, jar_path);\n+        }\n+        exit(1);\n+    }\n+    if (!info.splashscreen_image_file_name) {\n+        JLI_FreeManifest(); \/\/ cleanup the manifest structure\n+        \/\/ no \"SplashScreen-Image\" in jar's manifest\n+        return;\n+    }\n+    \/\/ The jar's manifest had a \"Splashscreen-Image\" specified. We set up the jar entry name\n+    \/\/ and the jar file name as env variables which then get used when showing the splash screen\n+    \/\/ in ShowSplashScreen().\n+\n+    \/\/ create the string of the form _JAVA_SPLASH_FILE=<val>\n+    splash_file_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_FILE_ENV_ENTRY \"=\")\n+                                     + JLI_StrLen(info.splashscreen_image_file_name) + 1);\n+    JLI_StrCpy(splash_file_entry, SPLASH_FILE_ENV_ENTRY \"=\");\n+    JLI_StrCat(splash_file_entry, info.splashscreen_image_file_name);\n+    putenv(splash_file_entry);\n+    \/\/ create the string of the form _JAVA_SPLASH_JAR=<val>\n+    splash_jar_entry = JLI_MemAlloc(JLI_StrLen(SPLASH_JAR_ENV_ENTRY \"=\") + JLI_StrLen(jar_path) + 1);\n+    JLI_StrCpy(splash_jar_entry, SPLASH_JAR_ENV_ENTRY \"=\");\n+    JLI_StrCat(splash_jar_entry, jar_path);\n+    putenv(splash_jar_entry);\n+    JLI_FreeManifest(); \/\/ cleanup the manifest structure\n+}\n+\n@@ -2338,1 +2247,1 @@\n-    (void)UnsetEnv(ENV_ENTRY);\n+    (void)UnsetEnv(MAIN_CLASS_ENV_ENTRY);\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":103,"deletions":194,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,15 +54,11 @@\n- * The following environment variable is used to influence the behavior\n- * of the jre exec'd through the SelectVersion routine.  The command line\n- * options which specify the version are not passed to the exec'd version,\n- * because that jre may be an older version which wouldn't recognize them.\n- * This environment variable is known to this (and later) version and serves\n- * to suppress the version selection code.  This is not only for efficiency,\n- * but also for correctness, since any command line options have been\n- * removed which would cause any value found in the manifest to be used.\n- * This would be incorrect because the command line options are defined\n- * to take precedence.\n- *\n- * The value associated with this environment variable is the MainClass\n- * name from within the executable jar file (if any). This is strictly a\n- * performance enhancement to avoid re-reading the jar file manifest.\n- *\n+ * Older versions of java launcher used to support JRE version selection - specifically,\n+ * the java launcher in JDK 1.8 can be used to launch a java application using a different\n+ * java runtime (older, newer or same version JRE installed at a different location) than\n+ * the one the launcher belongs to.\n+ * That support was discontinued starting Java 9. However, java launcher in JDK 1.8 can still\n+ * be launched with JRE version selection options to launch higher versioned java runtimes,\n+ * including the current JDK version. When it does that, the _JAVA_VERSION_SET environment variable\n+ * is set by the Java 1.8 launcher. The value of this environment variable is the Main-Class name from\n+ * within the executable jar file (if any).\n+ * The java launcher in the current version of the JDK doesn't use this environment variable\n+ * in any way other than merely using it in debug logging.\n@@ -70,1 +66,1 @@\n-#define ENV_ENTRY \"_JAVA_VERSION_SET\"\n+#define MAIN_CLASS_ENV_ENTRY \"_JAVA_VERSION_SET\"\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,4 +170,0 @@\n-    char        *manifest_version;      \/* Manifest-Version string *\/\n-    char        *main_class;            \/* Main-Class entry *\/\n-    char        *jre_version;           \/* Appropriate J2SE release spec *\/\n-    char        jre_restrict_search;    \/* Restricted JRE search *\/\n","filename":"src\/java.base\/share\/native\/libjli\/manifest_info.h","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -597,4 +597,0 @@\n-    info->manifest_version = NULL;\n-    info->main_class = NULL;\n-    info->jre_version = NULL;\n-    info->jre_restrict_search = 0;\n@@ -613,11 +609,1 @@\n-        if (JLI_StrCaseCmp(name, \"Manifest-Version\") == 0) {\n-            info->manifest_version = value;\n-        } else if (JLI_StrCaseCmp(name, \"Main-Class\") == 0) {\n-            info->main_class = value;\n-        } else if (JLI_StrCaseCmp(name, \"JRE-Version\") == 0) {\n-            \/*\n-             * Manifest specification overridden by command line option\n-             * so we will silently override there with no specification.\n-             *\/\n-            info->jre_version = 0;\n-        } else if (JLI_StrCaseCmp(name, \"Splashscreen-Image\") == 0) {\n+        if (JLI_StrCaseCmp(name, \"Splashscreen-Image\") == 0) {\n","filename":"src\/java.base\/share\/native\/libjli\/parse_manifest.c","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,96 +55,80 @@\n- * Flowchart of launcher execs and options processing on unix\n- *\n- * The selection of the proper vm shared library to open depends on\n- * several classes of command line options, including vm \"flavor\"\n- * options (-client, -server).\n- * The vm selection options are not passed to the running\n- * virtual machine; they must be screened out by the launcher.\n- *\n- * The version specification (if any) is processed first by the\n- * platform independent routine SelectVersion.  This may result in\n- * the exec of the specified launcher version.\n- *\n- * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the\n- * desired data model path, regardless if data models matched or not. The\n- * launcher subsequently exec'ed the desired executable, in order to make the\n- * LD_LIBRARY_PATH path available, for the runtime linker.\n- *\n- * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n- * required libraries are loaded by the runtime linker, using the\n- * $RPATH\/$ORIGIN baked into the shared libraries at compile time. Therefore,\n- * in most cases, the launcher will only exec, if the data models are\n- * mismatched, and will not set any environment variables, regardless of the\n- * data models.\n- *\n- * However, if the environment contains a LD_LIBRARY_PATH, this will cause the\n- * launcher to inspect the LD_LIBRARY_PATH. The launcher will check\n- *  a. if the LD_LIBRARY_PATH's first component is the path to the desired\n- *     libjvm.so\n- *  b. if any other libjvm.so is found in any of the paths.\n- * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the\n- * desired JRE and reexec, in order to propagate the environment.\n- *\n- *  Main\n- *  (incoming argv)\n- *  |\n- * \\|\/\n- * CreateExecutionEnvironment\n- * (determines desired data model)\n- *  |\n- *  |\n- * \\|\/\n- *  Have Desired Model ? --> NO --> Exit(with error)\n- *  |\n- *  |\n- * \\|\/\n- * YES\n- *  |\n- *  |\n- * \\|\/\n- * CheckJvmType\n- * (removes -client, -server, etc.)\n- *  |\n- *  |\n- * \\|\/\n- * TranslateDashJArgs...\n- * (Prepare to pass args to vm)\n- *  |\n- *  |\n- * \\|\/\n- * ParseArguments\n- *   |\n- *   |\n- *  \\|\/\n- * RequiresSetenv\n- * Is LD_LIBRARY_PATH\n- * and friends set ? --> NO --> Continue\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- * Path is desired JRE ? YES --> Continue\n- *  NO\n- *   |\n- *   |\n- *  \\|\/\n- * Paths have well known\n- * jvm paths ?       --> NO --> Error\/Exit\n- *  YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Does libjvm.so exist\n- *  in any of them ? --> NO  --> Continue\n- *   YES\n- *   |\n- *   |\n- *  \\|\/\n- *  Set the LD_LIBRARY_PATH\n- *   |\n- *   |\n- *  \\|\/\n- * Re-exec\n- *   |\n- *   |\n- *  \\|\/\n- * Main\n+ * Following is the high level flow of the launcher\n+ * code residing in the common java.c and this\n+ * unix specific java_md file:\n+ *\n+ *  - JLI_Launch function, which is the entry point\n+ *    to the launcher, calls CreateExecutionEnvironment.\n+ *\n+ *  - CreateExecutionEnvironment does the following\n+ *    (not necessarily in this order):\n+ *      - determines the relevant JVM type that\n+ *        needs to be ultimately created\n+ *      - determines the path and asserts the presence\n+ *        of libjava and relevant libjvm library\n+ *      - removes any JVM selection options from the\n+ *        arguments that were passed to the launcher\n+ *\n+ *  - CreateExecutionEnvironment then determines (by calling\n+ *    RequiresSetenv function) if LD_LIBRARY_PATH environment\n+ *    variable needs to be set\/updated.\n+ *      - If LD_LIBRARY_PATH needs to be set\/updated,\n+ *        then CreateExecutionEnvironment exec()s\n+ *        the current process with the appropriate value\n+ *        for LD_LIBRARY_PATH.\n+ *      - Else if LD_LIBRARY_PATH need not be set or\n+ *        updated, then CreateExecutionEnvironment\n+ *        returns back.\n+ *\n+ *  - If CreateExecutionEnvironment exec()ed the process\n+ *    in the previous step, then the code control for the\n+ *    process will again start from the process' entry\n+ *    point and JLI_Launch is thus re-invoked and the\n+ *    same above sequence of code flow repeats again.\n+ *    During this \"recursive\" call into CreateExecutionEnvironment,\n+ *    the implementation of the check for LD_LIBRARY_PATH\n+ *    will realize that no further exec() is required and\n+ *    the control will return back from CreateExecutionEnvironment.\n+ *\n+ *  - The control returns back from CreateExecutionEnvironment\n+ *    to JLI_Launch.\n+ *\n+ *  - JLI_Launch then invokes LoadJavaVM which dlopen()s\n+ *    the JVM library and asserts the presence of\n+ *    JNI Invocation Functions \"JNI_CreateJavaVM\",\n+ *    \"JNI_GetDefaultJavaVMInitArgs\" and\n+ *    \"JNI_GetCreatedJavaVMs\" in that library. It then\n+ *    sets internal function pointers in the launcher to\n+ *    point to those functions.\n+ *\n+ *  - JLI_Launch then translates any -J options by\n+ *    invoking TranslateApplicationArgs.\n+ *\n+ *  - JLI_Launch then invokes ParseArguments to\n+ *    parse\/process the launcher arguments.\n+ *\n+ *  - JLI_Launch then ultimately calls JVMInit.\n+ *\n+ *  - JVMInit invokes ShowSplashScreen which displays\n+ *    a splash screen for the application, if applicable.\n+ *\n+ *  - JVMInit then creates a new thread (T2), in the\n+ *    current process, and invokes JavaMain function\n+ *    in that new thread. The current thread (T1) then\n+ *    waits for the newly launched thread (T2) to complete.\n+ *\n+ *  - JavaMain function, in thread T2, before launching\n+ *    the application, invokes PostJVMInit.\n+ *\n+ *  - PostJVMInit is a no-op and returns back.\n+ *\n+ *  - Control then returns back from PostJVMInit into JavaMain,\n+ *    which then loads the application's main class and invokes\n+ *    the relevant main() Java method.\n+ *\n+ *  - JavaMain, in thread T2, then returns back an integer\n+ *    result and thread T2 execution ends here.\n+ *\n+ *  - The thread T1 in JVMInit, which is waiting on T2 to\n+ *    complete, receives the integer result and then propagates\n+ *    it as a return value all the way out of the\n+ *    JLI_Launch function.\n@@ -224,1 +208,1 @@\n- * Test whether the environment variable needs to be set, see flowchart.\n+ * Test whether the LD_LIBRARY_PATH environment variable needs to be set.\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":81,"deletions":97,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,2 +115,12 @@\n-        errorMessages.forEach(tr::contains);\n-\n+        boolean foundAnyExpectedErrMsgs = false;\n+        for (String errMsg : errorMessages) {\n+            if (tr.contains(errMsg)) {\n+                foundAnyExpectedErrMsgs = true;\n+                break;\n+            }\n+        }\n+        if (!foundAnyExpectedErrMsgs) {\n+            errorMessages.forEach((errMsg) -> {\n+                tr.appendError(\"string <\" + errMsg + \"> not found\");\n+            });\n+        }\n","filename":"test\/jdk\/tools\/launcher\/MultipleJRERemoved.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"}]}