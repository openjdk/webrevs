{"files":[{"patch":"@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -41,0 +43,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -45,2 +48,1 @@\n-ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = nullptr;\n-ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = nullptr;\n+ParCompactionManager::PSMarkTasksQueueSet*  ParCompactionManager::_marking_stacks = nullptr;\n@@ -48,0 +50,1 @@\n+PartialArrayStateManager* ParCompactionManager::_partial_array_state_manager = nullptr;\n@@ -58,1 +61,2 @@\n-  : _mark_and_push_closure(this, ref_processor) {\n+  :_partial_array_splitter(_partial_array_state_manager, ParallelScavengeHeap::heap()->workers().max_workers()),\n+   _mark_and_push_closure(this, ref_processor) {\n@@ -81,2 +85,4 @@\n-  _oop_task_queues = new OopTaskQueueSet(parallel_gc_threads);\n-  _objarray_task_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);\n+  assert(_partial_array_state_manager == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_manager\n+    = new PartialArrayStateManager(parallel_gc_threads);\n+  _marking_stacks = new PSMarkTasksQueueSet(parallel_gc_threads);\n@@ -92,2 +98,1 @@\n-    oop_task_queues()->register_queue(i, _manager_array[i]->oop_stack());\n-    _objarray_task_queues->register_queue(i, &_manager_array[i]->_objarray_stack);\n+    marking_stacks()->register_queue(i, _manager_array[i]->marking_stack());\n@@ -100,1 +105,0 @@\n-\n@@ -117,10 +121,10 @@\n-inline void ParCompactionManager::publish_and_drain_oop_tasks() {\n-  oop obj;\n-  while (oop_stack()->pop_overflow(obj)) {\n-    if (!oop_stack()->try_push_to_taskqueue(obj)) {\n-      follow_contents(obj);\n-    }\n-  }\n-  while (oop_stack()->pop_local(obj)) {\n-    follow_contents(obj);\n-  }\n+void ParCompactionManager::push_objArray(oop obj) {\n+  assert(obj->is_objArray(), \"precondition\");\n+  _mark_and_push_closure.do_klass(obj->klass());\n+\n+  objArrayOop obj_array = objArrayOop(obj);\n+  size_t array_length = obj_array->length();\n+  size_t initial_chunk_size =\n+    \/\/ The destination array is unused when processing states.\n+    _partial_array_splitter.start(&_marking_stack, obj_array, nullptr, array_length);\n+  follow_array(obj_array, 0, initial_chunk_size);\n@@ -129,7 +133,6 @@\n-bool ParCompactionManager::publish_or_pop_objarray_tasks(ObjArrayTask& task) {\n-  while (_objarray_stack.pop_overflow(task)) {\n-    if (!_objarray_stack.try_push_to_taskqueue(task)) {\n-      return true;\n-    }\n-  }\n-  return false;\n+void ParCompactionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop obj = state->source();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_marking_stack, stolen);\n+  follow_array(objArrayOop(obj), claim._start, claim._end);\n@@ -139,0 +142,1 @@\n+  ScannerTask task;\n@@ -142,7 +146,7 @@\n-    publish_and_drain_oop_tasks();\n-\n-    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n-    ObjArrayTask task;\n-    if (publish_or_pop_objarray_tasks(task) ||\n-        _objarray_stack.pop_local(task)) {\n-      follow_array((objArrayOop)task.obj(), task.index());\n+    while (marking_stack()->pop_overflow(task)) {\n+      if (!marking_stack()->try_push_to_taskqueue(task)) {\n+        follow_contents(task, false);\n+      }\n+    }\n+    while (marking_stack()->pop_local(task)) {\n+      follow_contents(task, false);\n@@ -150,1 +154,1 @@\n-  } while (!marking_stacks_empty());\n+  } while (!marking_stack_empty());\n@@ -152,1 +156,1 @@\n-  assert(marking_stacks_empty(), \"Sanity\");\n+  assert(marking_stack_empty(), \"Sanity\");\n@@ -199,0 +203,21 @@\n+\n+#if TASKQUEUE_STATS\n+void ParCompactionManager::print_and_reset_taskqueue_stats() {\n+  marking_stacks()->print_and_reset_taskqueue_stats(\"Marking Stacks\");\n+\n+  auto get_pa_stats = [&](uint i) {\n+    return _manager_array[i]->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n+  uint parallel_gc_threads = ParallelScavengeHeap::heap()->workers().max_workers();\n+  for (uint i = 0; i < parallel_gc_threads; ++i) {\n+    get_pa_stats(i)->reset();\n+  }\n+}\n+\n+PartialArrayTaskStats* ParCompactionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -203,1 +228,1 @@\n-    assert(_manager_array[i]->marking_stacks_empty(), \"Marking stack should be empty\");\n+    assert(_manager_array[i]->marking_stack_empty(), \"Marking stack should be empty\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":60,"deletions":35,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -67,10 +70,4 @@\n-  typedef OverflowTaskQueue<oop, mtGC>            OopTaskQueue;\n-  typedef GenericTaskQueueSet<OopTaskQueue, mtGC> OopTaskQueueSet;\n-\n-  \/\/ 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB\n-  #define QUEUE_SIZE (1 << NOT_LP64(12) LP64_ONLY(13))\n-  typedef OverflowTaskQueue<ObjArrayTask, mtGC, QUEUE_SIZE> ObjArrayTaskQueue;\n-  typedef GenericTaskQueueSet<ObjArrayTaskQueue, mtGC>      ObjArrayTaskQueueSet;\n-  #undef QUEUE_SIZE\n-  typedef OverflowTaskQueue<size_t, mtGC>             RegionTaskQueue;\n-  typedef GenericTaskQueueSet<RegionTaskQueue, mtGC>  RegionTaskQueueSet;\n+  typedef OverflowTaskQueue<ScannerTask, mtGC>           PSMarkTaskQueue;\n+  typedef GenericTaskQueueSet<PSMarkTaskQueue, mtGC>     PSMarkTasksQueueSet;\n+  typedef OverflowTaskQueue<size_t, mtGC>                RegionTaskQueue;\n+  typedef GenericTaskQueueSet<RegionTaskQueue, mtGC>     RegionTaskQueueSet;\n@@ -79,2 +76,1 @@\n-  static OopTaskQueueSet*       _oop_task_queues;\n-  static ObjArrayTaskQueueSet*  _objarray_task_queues;\n+  static PSMarkTasksQueueSet*   _marking_stacks;\n@@ -85,2 +81,5 @@\n-  OopTaskQueue                  _oop_stack;\n-  ObjArrayTaskQueue             _objarray_stack;\n+  static PartialArrayStateManager*  _partial_array_state_manager;\n+  PartialArraySplitter              _partial_array_splitter;\n+\n+  PSMarkTaskQueue               _marking_stack;\n+\n@@ -112,1 +111,1 @@\n-  static OopTaskQueueSet* oop_task_queues()  { return _oop_task_queues; }\n+  static PSMarkTasksQueueSet* marking_stacks()  { return _marking_stacks; }\n@@ -116,7 +115,0 @@\n-  void publish_and_drain_oop_tasks();\n-  \/\/ Try to publish all contents from the objArray task queue overflow stack to\n-  \/\/ the shared objArray stack.\n-  \/\/ Returns true and a valid task if there has not been enough space in the shared\n-  \/\/ objArray stack, otherwise returns false and the task is invalid.\n-  bool publish_or_pop_objarray_tasks(ObjArrayTask& task);\n-\n@@ -128,1 +120,4 @@\n-  OopTaskQueue*  oop_stack()       { return &_oop_stack; }\n+\n+  inline PSMarkTaskQueue*  marking_stack() { return &_marking_stack; }\n+  inline void push(PartialArrayState* stat);\n+  void push_objArray(oop obj);\n@@ -158,0 +153,5 @@\n+#if TASKQUEUE_STATS\n+  static void print_and_reset_taskqueue_stats();\n+  PartialArrayTaskStats* partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -192,1 +192,0 @@\n-  inline void push_objarray(oop objarray, size_t index);\n@@ -201,2 +200,1 @@\n-  static bool steal(int queue_num, oop& t);\n-  static bool steal_objarray(int queue_num, ObjArrayTask& t);\n+  static bool steal(int queue_num, ScannerTask& t);\n@@ -205,1 +203,1 @@\n-  \/\/ Process tasks remaining on any marking stack\n+  \/\/ Process tasks remaining on marking stack\n@@ -207,1 +205,1 @@\n-  inline bool marking_stacks_empty() const;\n+  inline bool marking_stack_empty() const;\n@@ -212,2 +210,3 @@\n-  void follow_contents(oop obj);\n-  void follow_array(objArrayOop array, int index);\n+  inline void follow_contents(const ScannerTask& task, bool stolen);\n+  inline void follow_array(objArrayOop array, size_t start, size_t end);\n+  void process_array_chunk(PartialArrayState* state, bool stolen);\n@@ -237,2 +236,2 @@\n-bool ParCompactionManager::marking_stacks_empty() const {\n-  return _oop_stack.is_empty() && _objarray_stack.is_empty();\n+bool ParCompactionManager::marking_stack_empty() const {\n+  return _marking_stack.is_empty();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":31,"deletions":32,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -49,6 +51,2 @@\n-inline bool ParCompactionManager::steal(int queue_num, oop& t) {\n-  return oop_task_queues()->steal(queue_num, t);\n-}\n-\n-inline bool ParCompactionManager::steal_objarray(int queue_num, ObjArrayTask& t) {\n-  return _objarray_task_queues->steal(queue_num, t);\n+inline bool ParCompactionManager::steal(int queue_num, ScannerTask& t) {\n+  return marking_stacks()->steal(queue_num, t);\n@@ -62,1 +60,1 @@\n-  _oop_stack.push(obj);\n+  marking_stack()->push(ScannerTask(obj));\n@@ -65,5 +63,2 @@\n-void ParCompactionManager::push_objarray(oop obj, size_t index)\n-{\n-  ObjArrayTask task(obj, index);\n-  assert(task.is_valid(), \"bad ObjArrayTask\");\n-  _objarray_stack.push(task);\n+inline void ParCompactionManager::push(PartialArrayState* stat) {\n+  marking_stack()->push(ScannerTask(stat));\n@@ -114,7 +109,2 @@\n-inline void follow_array_specialized(objArrayOop obj, int index, ParCompactionManager* cm) {\n-  const size_t len = size_t(obj->length());\n-  const size_t beg_index = size_t(index);\n-  assert(beg_index < len || len == 0, \"index too large\");\n-\n-  const size_t stride = MIN2(len - beg_index, (size_t)ObjArrayMarkingStride);\n-  const size_t end_index = beg_index + stride;\n+inline void follow_array_specialized(objArrayOop obj, size_t start, size_t end, ParCompactionManager* cm) {\n+  assert(start <= end, \"invariant\");\n@@ -122,6 +112,2 @@\n-  T* const beg = base + beg_index;\n-  T* const end = base + end_index;\n-\n-  if (end_index < len) {\n-    cm->push_objarray(obj, end_index); \/\/ Push the continuation.\n-  }\n+  T* const beg = base + start;\n+  T* const chunk_end = base + end;\n@@ -130,1 +116,1 @@\n-  for (T* e = beg; e < end; e++) {\n+  for (T* e = beg; e < chunk_end; e++) {\n@@ -135,1 +121,1 @@\n-inline void ParCompactionManager::follow_array(objArrayOop obj, int index) {\n+inline void ParCompactionManager::follow_array(objArrayOop obj, size_t start, size_t end) {\n@@ -137,1 +123,1 @@\n-    follow_array_specialized<narrowOop>(obj, index, this);\n+    follow_array_specialized<narrowOop>(obj, start, end, this);\n@@ -139,1 +125,1 @@\n-    follow_array_specialized<oop>(obj, index, this);\n+    follow_array_specialized<oop>(obj, start, end, this);\n@@ -143,6 +129,4 @@\n-inline void ParCompactionManager::follow_contents(oop obj) {\n-  assert(PSParallelCompact::mark_bitmap()->is_marked(obj), \"should be marked\");\n-\n-  if (obj->is_objArray()) {\n-    _mark_and_push_closure.do_klass(obj->klass());\n-    follow_array(objArrayOop(obj), 0);\n+inline void ParCompactionManager::follow_contents(const ScannerTask& task, bool stolen) {\n+  if (task.is_partial_array_state()) {\n+    assert(PSParallelCompact::mark_bitmap()->is_marked(task.to_partial_array_state()->source()), \"should be marked\");\n+    process_array_chunk(task.to_partial_array_state(), stolen);\n@@ -150,1 +134,7 @@\n-    obj->oop_iterate(&_mark_and_push_closure);\n+    oop obj = task.to_oop();\n+    assert(PSParallelCompact::mark_bitmap()->is_marked(obj), \"should be marked\");\n+    if (obj->is_objArray()) {\n+      push_objArray(obj);\n+    } else {\n+      obj->oop_iterate(&_mark_and_push_closure);\n+    }\n@@ -222,1 +212,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1212,6 +1212,3 @@\n-    oop obj = nullptr;\n-    ObjArrayTask task;\n-    if (ParCompactionManager::steal_objarray(worker_id,  task)) {\n-      cm->follow_array((objArrayOop)task.obj(), task.index());\n-    } else if (ParCompactionManager::steal(worker_id, obj)) {\n-      cm->follow_contents(obj);\n+    ScannerTask task;\n+    if (ParCompactionManager::steal(worker_id, task)) {\n+      cm->follow_contents(task, true);\n@@ -1233,1 +1230,1 @@\n-      _terminator(active_workers, ParCompactionManager::oop_task_queues()),\n+      _terminator(active_workers, ParCompactionManager::marking_stacks()),\n@@ -1271,1 +1268,1 @@\n-      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n+      _terminator(_max_workers, ParCompactionManager::marking_stacks()) {}\n@@ -1381,2 +1378,1 @@\n-  ParCompactionManager::oop_task_queues()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n-  ParCompactionManager::_objarray_task_queues->print_and_reset_taskqueue_stats(\"ObjArrayOop Queue\");\n+  ParCompactionManager::print_and_reset_taskqueue_stats();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-      _terminator(max_workers, ParCompactionManager::oop_task_queues()) {}\n+      _terminator(max_workers, ParCompactionManager::marking_stacks()) {}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayState.\n+\/\/ Discriminated union over oop\/oop*, narrowOop*, and PartialArrayState.\n@@ -566,0 +566,2 @@\n+\/\/ Oop\/oop* are overloaded using the same tag because they can not appear at the\n+\/\/ same time.\n@@ -598,0 +600,2 @@\n+  explicit ScannerTask(oop p) : _p(encode(p, OopTag)) {}\n+\n@@ -625,0 +629,4 @@\n+  oop to_oop() const {\n+    return cast_to_oop(decode(OopTag));\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}