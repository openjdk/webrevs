{"files":[{"patch":"@@ -32,0 +32,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+\n@@ -42,0 +44,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -46,2 +49,1 @@\n-ParCompactionManager::OopTaskQueueSet*      ParCompactionManager::_oop_task_queues = nullptr;\n-ParCompactionManager::ObjArrayTaskQueueSet* ParCompactionManager::_objarray_task_queues = nullptr;\n+ParCompactionManager::PSMarkTasksQueueSet*  ParCompactionManager::_marking_stacks = nullptr;\n@@ -49,0 +51,1 @@\n+PartialArrayStateAllocator* ParCompactionManager::_partial_array_state_allocator = nullptr;\n@@ -59,1 +62,2 @@\n-  : _mark_and_push_closure(this, ref_processor) {\n+  : _partial_array_stepper(ParallelGCThreads, ObjArrayMarkingStride),\n+    _mark_and_push_closure(this, ref_processor) {\n@@ -68,0 +72,5 @@\n+\n+ \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n+  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -82,2 +91,3 @@\n-  _oop_task_queues = new OopTaskQueueSet(parallel_gc_threads);\n-  _objarray_task_queues = new ObjArrayTaskQueueSet(parallel_gc_threads);\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator = new PartialArrayStateAllocator(ParallelGCThreads);\n+  _marking_stacks = new PSMarkTasksQueueSet(parallel_gc_threads);\n@@ -93,2 +103,1 @@\n-    oop_task_queues()->register_queue(i, _manager_array[i]->oop_stack());\n-    _objarray_task_queues->register_queue(i, &_manager_array[i]->_objarray_stack);\n+    marking_stacks()->register_queue(i, _manager_array[i]->marking_stack());\n@@ -96,0 +105,1 @@\n+    _manager_array[i]->_partial_array_state_allocator_index = i;\n@@ -101,1 +111,0 @@\n-\n@@ -118,5 +127,16 @@\n-inline void ParCompactionManager::publish_and_drain_oop_tasks() {\n-  oop obj;\n-  while (oop_stack()->pop_overflow(obj)) {\n-    if (!oop_stack()->try_push_to_taskqueue(obj)) {\n-      follow_contents(obj);\n+void ParCompactionManager::push_objArray(oop obj) {\n+  assert(obj->is_objArray(), \"precondition\");\n+  _mark_and_push_closure.do_klass(obj->klass());\n+\n+  size_t array_length = objArrayOop(obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+    _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                             obj, nullptr,\n+                                             step._index,\n+                                             array_length,\n+                                             step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      marking_stack()->push(PSMarkTask(state));\n@@ -124,0 +144,1 @@\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n@@ -125,3 +146,1 @@\n-  while (oop_stack()->pop_local(obj)) {\n-    follow_contents(obj);\n-  }\n+  follow_array(objArrayOop(obj), 0, checked_cast<int>(step._index));\n@@ -130,4 +149,10 @@\n-bool ParCompactionManager::publish_or_pop_objarray_tasks(ObjArrayTask& task) {\n-  while (_objarray_stack.pop_overflow(task)) {\n-    if (!_objarray_stack.try_push_to_taskqueue(task)) {\n-      return true;\n+void ParCompactionManager::process_array_chunk(PartialArrayState* state) {\n+  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n+\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push(state);\n@@ -135,0 +160,1 @@\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n@@ -136,1 +162,7 @@\n-  return false;\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  follow_array(objArrayOop(state->source()), start, end);\n+\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n@@ -140,0 +172,1 @@\n+  PSMarkTask task;\n@@ -143,7 +176,7 @@\n-    publish_and_drain_oop_tasks();\n-\n-    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n-    ObjArrayTask task;\n-    if (publish_or_pop_objarray_tasks(task) ||\n-        _objarray_stack.pop_local(task)) {\n-      follow_array((objArrayOop)task.obj(), task.index());\n+    while (marking_stack()->pop_overflow(task)) {\n+      if (!marking_stack()->try_push_to_taskqueue(task)) {\n+        follow_contents(task);\n+      }\n+    }\n+    while (marking_stack()->pop_local(task)) {\n+      follow_contents(task);\n@@ -151,1 +184,1 @@\n-  } while (!marking_stacks_empty());\n+  } while (!marking_stack_empty());\n@@ -153,1 +186,1 @@\n-  assert(marking_stacks_empty(), \"Sanity\");\n+  assert(marking_stack_empty(), \"Sanity\");\n@@ -200,0 +233,40 @@\n+\n+#if TASKQUEUE_STATS\n+void ParCompactionManager::print_local_stats(outputStream* const out, uint i) const {\n+  #define FMT \" \" SIZE_FORMAT_W(10)\n+  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n+                i, _array_chunk_pushes, _array_chunk_steals,\n+                _arrays_chunked, _array_chunks_processed);\n+  #undef FMT\n+}\n+\n+static const char* const pm_stats_hdr[] = {\n+  \"    ----partial array----     arrays      array\",\n+  \"thr       push      steal    chunked     chunks\",\n+  \"--- ---------- ---------- ---------- ----------\"\n+};\n+\n+void ParCompactionManager::print_and_reset_taskqueue_stats() {\n+  if (!log_is_enabled(Trace, gc, task, stats)) {\n+    return;\n+  }\n+  Log(gc, task, stats) log;\n+  ResourceMark rm;\n+  LogStream ls(log.trace());\n+\n+  marking_stacks()->print_and_reset_taskqueue_stats(\"Marking Stacks\");\n+\n+  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n+  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n+  for (uint i = 0; i < ParallelGCThreads; ++i) {\n+    _manager_array[i]->print_local_stats(&ls, i);\n+    _manager_array[i]->reset_stats();\n+  }\n+}\n+\n+void ParCompactionManager::reset_stats() {\n+  _array_chunk_pushes = _array_chunk_steals = 0;\n+  _arrays_chunked = _array_chunks_processed = 0;\n+}\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -204,1 +277,1 @@\n-    assert(_manager_array[i]->marking_stacks_empty(), \"Marking stack should be empty\");\n+    assert(_manager_array[i]->marking_stack_empty(), \"Marking stack should be empty\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":104,"deletions":31,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -43,0 +44,2 @@\n+class PartialArrayState;\n+class PartialArrayStateAllocator;\n@@ -57,0 +60,31 @@\n+class PSMarkTask {\n+private:\n+  void* _holder;\n+\n+  static const uintptr_t PartialArrayStateBit = 1;\n+public:\n+  PSMarkTask() : _holder(nullptr) { }\n+\n+  explicit PSMarkTask(oop obj) : _holder(obj) {\n+    assert(_holder != nullptr, \"Not allowed to set null task queue element\");\n+    assert(is_aligned(_holder, 1), \"Misaligned\");\n+  }\n+\n+  explicit PSMarkTask(PartialArrayState* p) : _holder((void*)((uintptr_t)p | PartialArrayStateBit)) {\n+    assert(is_aligned(p, 1), \"Misaligned\");\n+  }\n+\n+  oop obj() const {\n+    assert(is_oop(), \"Trying to read partial array state \" PTR_FORMAT \" as oop\", p2i(_holder));\n+    return cast_to_oop(_holder);\n+  }\n+\n+  PartialArrayState* to_partial_array_state() const {\n+    assert(is_partial_array_state(), \"Trying to read oop \" PTR_FORMAT \" as partial array state\", p2i(_holder));\n+    return static_cast<PartialArrayState*>(static_cast<void*>(static_cast<char*>(_holder) - PartialArrayStateBit));\n+  }\n+\n+  bool is_oop() const { return !is_partial_array_state(); }\n+  bool is_partial_array_state() const { return ((uintptr_t)_holder & PartialArrayStateBit) != 0; }\n+};\n+\n@@ -67,10 +101,4 @@\n-  typedef OverflowTaskQueue<oop, mtGC>            OopTaskQueue;\n-  typedef GenericTaskQueueSet<OopTaskQueue, mtGC> OopTaskQueueSet;\n-\n-  \/\/ 32-bit:  4K * 8 = 32KiB; 64-bit:  8K * 16 = 128KiB\n-  #define QUEUE_SIZE (1 << NOT_LP64(12) LP64_ONLY(13))\n-  typedef OverflowTaskQueue<ObjArrayTask, mtGC, QUEUE_SIZE> ObjArrayTaskQueue;\n-  typedef GenericTaskQueueSet<ObjArrayTaskQueue, mtGC>      ObjArrayTaskQueueSet;\n-  #undef QUEUE_SIZE\n-  typedef OverflowTaskQueue<size_t, mtGC>             RegionTaskQueue;\n-  typedef GenericTaskQueueSet<RegionTaskQueue, mtGC>  RegionTaskQueueSet;\n+  typedef OverflowTaskQueue<PSMarkTask, mtGC>            PSMarkTaskQueue;\n+  typedef GenericTaskQueueSet<PSMarkTaskQueue, mtGC>     PSMarkTasksQueueSet;\n+  typedef OverflowTaskQueue<size_t, mtGC>                RegionTaskQueue;\n+  typedef GenericTaskQueueSet<RegionTaskQueue, mtGC>     RegionTaskQueueSet;\n@@ -79,2 +107,1 @@\n-  static OopTaskQueueSet*       _oop_task_queues;\n-  static ObjArrayTaskQueueSet*  _objarray_task_queues;\n+  static PSMarkTasksQueueSet*   _marking_stacks;\n@@ -84,0 +111,12 @@\n+  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+\n+  PartialArrayTaskStepper       _partial_array_stepper;\n+  uint                          _partial_array_state_allocator_index;\n+  PSMarkTaskQueue               _marking_stack;\n+\n+#if TASKQUEUE_STATS\n+  size_t                        _array_chunk_pushes;\n+  size_t                        _array_chunk_steals;\n+  size_t                        _arrays_chunked;\n+  size_t                        _array_chunks_processed;\n+#endif \/\/ TASKQUEUE_STATS\n@@ -85,2 +124,0 @@\n-  OopTaskQueue                  _oop_stack;\n-  ObjArrayTaskQueue             _objarray_stack;\n@@ -112,1 +149,1 @@\n-  static OopTaskQueueSet* oop_task_queues()  { return _oop_task_queues; }\n+  static PSMarkTasksQueueSet* marking_stacks()  { return _marking_stacks; }\n@@ -116,7 +153,0 @@\n-  void publish_and_drain_oop_tasks();\n-  \/\/ Try to publish all contents from the objArray task queue overflow stack to\n-  \/\/ the shared objArray stack.\n-  \/\/ Returns true and a valid task if there has not been enough space in the shared\n-  \/\/ objArray stack, otherwise returns false and the task is invalid.\n-  bool publish_or_pop_objarray_tasks(ObjArrayTask& task);\n-\n@@ -128,1 +158,4 @@\n-  OopTaskQueue*  oop_stack()       { return &_oop_stack; }\n+\n+  inline PSMarkTaskQueue*  marking_stack() { return &_marking_stack; }\n+  inline void push(PartialArrayState* stat);\n+  void push_objArray(oop obj);\n@@ -158,0 +191,6 @@\n+#if TASKQUEUE_STATS\n+  static void print_and_reset_taskqueue_stats();\n+  void print_local_stats(outputStream* const out, uint i) const;\n+  void reset_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -192,1 +231,0 @@\n-  inline void push_objarray(oop objarray, size_t index);\n@@ -201,2 +239,1 @@\n-  static bool steal(int queue_num, oop& t);\n-  static bool steal_objarray(int queue_num, ObjArrayTask& t);\n+  static bool steal(int queue_num, PSMarkTask& t);\n@@ -205,1 +242,1 @@\n-  \/\/ Process tasks remaining on any marking stack\n+  \/\/ Process tasks remaining on marking stack\n@@ -207,1 +244,1 @@\n-  inline bool marking_stacks_empty() const;\n+  inline bool marking_stack_empty() const;\n@@ -212,2 +249,5 @@\n-  void follow_contents(oop obj);\n-  void follow_array(objArrayOop array, int index);\n+  inline void follow_contents(const PSMarkTask& task);\n+  inline void follow_array(objArrayOop array, int start, int end);\n+  void process_array_chunk(PartialArrayState* state);\n+\n+  TASKQUEUE_STATS_ONLY(inline void record_steal(PSMarkTask task);)\n@@ -237,2 +277,2 @@\n-bool ParCompactionManager::marking_stacks_empty() const {\n-  return _oop_stack.is_empty() && _objarray_stack.is_empty();\n+bool ParCompactionManager::marking_stack_empty() const {\n+  return _marking_stack.is_empty();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":72,"deletions":32,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -49,6 +51,2 @@\n-inline bool ParCompactionManager::steal(int queue_num, oop& t) {\n-  return oop_task_queues()->steal(queue_num, t);\n-}\n-\n-inline bool ParCompactionManager::steal_objarray(int queue_num, ObjArrayTask& t) {\n-  return _objarray_task_queues->steal(queue_num, t);\n+inline bool ParCompactionManager::steal(int queue_num, PSMarkTask& t) {\n+  return marking_stacks()->steal(queue_num, t);\n@@ -62,1 +60,1 @@\n-  _oop_stack.push(obj);\n+  marking_stack()->push(PSMarkTask(obj));\n@@ -65,5 +63,2 @@\n-void ParCompactionManager::push_objarray(oop obj, size_t index)\n-{\n-  ObjArrayTask task(obj, index);\n-  assert(task.is_valid(), \"bad ObjArrayTask\");\n-  _objarray_stack.push(task);\n+inline void ParCompactionManager::push(PartialArrayState* stat) {\n+  marking_stack()->push(PSMarkTask(stat));\n@@ -114,7 +109,2 @@\n-inline void follow_array_specialized(objArrayOop obj, int index, ParCompactionManager* cm) {\n-  const size_t len = size_t(obj->length());\n-  const size_t beg_index = size_t(index);\n-  assert(beg_index < len || len == 0, \"index too large\");\n-\n-  const size_t stride = MIN2(len - beg_index, (size_t)ObjArrayMarkingStride);\n-  const size_t end_index = beg_index + stride;\n+inline void follow_array_specialized(objArrayOop obj, int start, int end, ParCompactionManager* cm) {\n+  assert(start <= end, \"invariant\");\n@@ -122,6 +112,2 @@\n-  T* const beg = base + beg_index;\n-  T* const end = base + end_index;\n-\n-  if (end_index < len) {\n-    cm->push_objarray(obj, end_index); \/\/ Push the continuation.\n-  }\n+  T* const beg = base + start;\n+  T* const chunk_end = base + end;\n@@ -130,1 +116,1 @@\n-  for (T* e = beg; e < end; e++) {\n+  for (T* e = beg; e < chunk_end; e++) {\n@@ -135,1 +121,1 @@\n-inline void ParCompactionManager::follow_array(objArrayOop obj, int index) {\n+inline void ParCompactionManager::follow_array(objArrayOop obj, int start, int end) {\n@@ -137,1 +123,1 @@\n-    follow_array_specialized<narrowOop>(obj, index, this);\n+    follow_array_specialized<narrowOop>(obj, start, end, this);\n@@ -139,1 +125,1 @@\n-    follow_array_specialized<oop>(obj, index, this);\n+    follow_array_specialized<oop>(obj, start, end, this);\n@@ -143,6 +129,4 @@\n-inline void ParCompactionManager::follow_contents(oop obj) {\n-  assert(PSParallelCompact::mark_bitmap()->is_marked(obj), \"should be marked\");\n-\n-  if (obj->is_objArray()) {\n-    _mark_and_push_closure.do_klass(obj->klass());\n-    follow_array(objArrayOop(obj), 0);\n+inline void ParCompactionManager::follow_contents(const PSMarkTask& task) {\n+  if (task.is_partial_array_state()) {\n+    assert(PSParallelCompact::mark_bitmap()->is_marked(task.to_partial_array_state()->source()), \"should be marked\");\n+    process_array_chunk(task.to_partial_array_state());\n@@ -150,1 +134,7 @@\n-    obj->oop_iterate(&_mark_and_push_closure);\n+    oop obj = task.obj();\n+    assert(PSParallelCompact::mark_bitmap()->is_marked(obj), \"should be marked\");\n+    if (obj->is_objArray()) {\n+      push_objArray(obj);\n+    } else {\n+      obj->oop_iterate(&_mark_and_push_closure);\n+    }\n@@ -223,0 +213,8 @@\n+#if TASKQUEUE_STATS\n+void ParCompactionManager::record_steal(PSMarkTask task) {\n+  if (task.is_partial_array_state()) {\n+    ++_array_chunk_steals;\n+  }\n+}\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":34,"deletions":36,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1204,6 +1204,4 @@\n-    oop obj = nullptr;\n-    ObjArrayTask task;\n-    if (ParCompactionManager::steal_objarray(worker_id,  task)) {\n-      cm->follow_array((objArrayOop)task.obj(), task.index());\n-    } else if (ParCompactionManager::steal(worker_id, obj)) {\n-      cm->follow_contents(obj);\n+    PSMarkTask task;\n+    if (ParCompactionManager::steal(worker_id, task)) {\n+      TASKQUEUE_STATS_ONLY(cm->record_steal(task));\n+      cm->follow_contents(task);\n@@ -1225,1 +1223,1 @@\n-      _terminator(active_workers, ParCompactionManager::oop_task_queues()),\n+      _terminator(active_workers, ParCompactionManager::marking_stacks()),\n@@ -1263,1 +1261,1 @@\n-      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n+      _terminator(_max_workers, ParCompactionManager::marking_stacks()) {}\n@@ -1373,2 +1371,1 @@\n-  ParCompactionManager::oop_task_queues()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n-  ParCompactionManager::_objarray_task_queues->print_and_reset_taskqueue_stats(\"ObjArrayOop Queue\");\n+  ParCompactionManager::print_and_reset_taskqueue_stats();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-      _terminator(max_workers, ParCompactionManager::oop_task_queues()) {}\n+      _terminator(max_workers, ParCompactionManager::marking_stacks()) {}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}