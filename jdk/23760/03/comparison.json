{"files":[{"patch":"@@ -34,2 +34,1 @@\n-    _stop_lock(Mutex::safepoint - 2, \"ShenandoahUncommitStop_lock\", true),\n-    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommitCancel_lock\", true) {\n+    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommit_lock\", true) {\n@@ -71,5 +70,4 @@\n-    {\n-      MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n-      if (!_stop_requested.is_set()) {\n-        timed_out = locker.wait(poll_interval);\n-      }\n+\n+    if (!should_terminate()) {\n+      MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+      timed_out = locker.wait(poll_interval);\n@@ -107,1 +105,1 @@\n-    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n@@ -115,1 +113,1 @@\n-    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n@@ -128,1 +126,10 @@\n-  if (!is_uncommit_allowed()) {\n+  {\n+    \/\/ Final check, under the lock, if uncommit is allowed.\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    if (is_uncommit_allowed()) {\n+      _uncommit_in_progress.set();\n+    }\n+  }\n+\n+  \/\/ If not allowed to start, do nothing.\n+  if (!_uncommit_in_progress.is_set()) {\n@@ -132,0 +139,2 @@\n+  \/\/ From here on, uncommit is in progress. Attempts to stop the uncommit must wait\n+  \/\/ until the cancellation request is acknowledged and uncommit is no longer in progress.\n@@ -133,0 +142,1 @@\n+  const double start = os::elapsedTime();\n@@ -134,1 +144,0 @@\n-  double start = os::elapsedTime();\n@@ -137,1 +146,8 @@\n-  _uncommit_in_progress.set();\n+  \/\/ This is the number of regions uncommitted during this increment of uncommit work.\n+  const size_t uncommitted_region_count = do_uncommit_work(shrink_before, shrink_until);\n+\n+  {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    _uncommit_in_progress.unset();\n+    locker.notify_all();\n+  }\n@@ -139,0 +155,12 @@\n+  if (uncommitted_region_count > 0) {\n+    _heap->notify_heap_changed();\n+  }\n+\n+  const double elapsed = os::elapsedTime() - start;\n+  log_info(gc)(\"%s \" PROPERFMT \" (\" PROPERFMT \") %.3fms\",\n+               msg, PROPERFMTARGS(uncommitted_region_count * ShenandoahHeapRegion::region_size_bytes()), PROPERFMTARGS(_heap->capacity()),\n+               elapsed * MILLIUNITS);\n+}\n+\n+size_t ShenandoahUncommitThread::do_uncommit_work(double shrink_before, size_t shrink_until) const {\n+  size_t count = 0;\n@@ -143,1 +171,0 @@\n-  size_t count = 0;\n@@ -146,0 +173,1 @@\n+      \/\/ GC wants to start, so the uncommit operation must stop\n@@ -152,1 +180,1 @@\n-      ShenandoahHeapLocker locker(_heap->lock());\n+      ShenandoahHeapLocker heap_locker(_heap->lock());\n@@ -155,0 +183,1 @@\n+          \/\/ We have uncommitted enough regions to hit the target heap committed size\n@@ -164,15 +193,1 @@\n-\n-  {\n-    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n-    _uncommit_in_progress.unset();\n-    locker.notify_all();\n-  }\n-\n-  if (count > 0) {\n-    _heap->notify_heap_changed();\n-  }\n-\n-  double elapsed = os::elapsedTime() - start;\n-  log_info(gc)(\"%s \" PROPERFMT \" (\" PROPERFMT \") %.3fms\",\n-               msg, PROPERFMTARGS(count * ShenandoahHeapRegion::region_size_bytes()), PROPERFMTARGS(_heap->capacity()),\n-               elapsed * MILLIUNITS);\n+  return count;\n@@ -181,0 +196,1 @@\n+\n@@ -182,2 +198,2 @@\n-  MonitorLocker locker(&_stop_lock, Mutex::_safepoint_check_flag);\n-  _stop_requested.set();\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n@@ -196,0 +212,1 @@\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":48,"deletions":31,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-  \/\/ Indicates that the thread should stop and terminate\n-  ShenandoahSharedFlag _stop_requested;\n-\n@@ -50,3 +47,0 @@\n-  \/\/ This lock is used to coordinate stopping and terminating this thread\n-  Monitor _stop_lock;\n-\n@@ -69,0 +63,6 @@\n+  \/\/ Iterate over and uncommit eligible regions until committed heap falls below\n+  \/\/ `shrink_until` bytes. A region is eligible for uncommit if the timestamp at which\n+  \/\/ it was last made empty is before `shrink_before` seconds since jvm start.\n+  \/\/ Returns the number of regions uncommitted. May be interrupted by `forbid_uncommit`.\n+  size_t do_uncommit_work(double shrink_before, size_t shrink_until) const;\n+\n@@ -88,1 +88,1 @@\n-  bool is_uncommit_in_progress() {\n+  bool is_uncommit_in_progress() const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}