{"files":[{"patch":"@@ -90,3 +90,4 @@\n-    \/\/ Yield if enough has been processed; returns if the concurrent marking cycle\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ Yield if enough has been processed. Return whether we should stop\n+    \/\/ processing this region because either the concurrent marking cycle has been\n+    \/\/ aborted or the region has been reclaimed.\n+    bool yield_if_necessary(G1HeapRegion* hr) {\n@@ -95,1 +96,5 @@\n-        _cm->do_yield_check();\n+        \/\/ If a yield occurs (potential young-gc pause), must recheck for\n+        \/\/ potential regions reclamation.\n+        if (_cm->do_yield_check() && !should_rebuild_or_scrub(hr)) {\n+          return true;\n+        }\n@@ -97,1 +102,1 @@\n-      return _cm->has_aborted();\n+      return _cm->has_aborted() || !should_rebuild_or_scrub(hr);\n@@ -114,2 +119,1 @@\n-    \/\/ Returns true if marking has been aborted or false if completed.\n-    bool scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    void scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -125,8 +129,3 @@\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n+\n+        if (yield_if_necessary(hr)) {\n+          return;\n@@ -138,1 +137,0 @@\n-      return false;\n@@ -168,54 +166,11 @@\n-    \/\/ Scrub a range of dead objects starting at scrub_start. Will never scrub past limit.\n-    HeapWord* scrub_to_next_live(G1HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n-      assert(!_bitmap->is_marked(scrub_start), \"Should not scrub live object\");\n-\n-      HeapWord* scrub_end = _bitmap->get_next_marked_addr(scrub_start, limit);\n-      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-\n-      \/\/ Return the next object to handle.\n-      return scrub_end;\n-    }\n-\n-    \/\/ Scan the given region from bottom to parsable_bottom. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_to_pb(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        if (_bitmap->is_marked(start)) {\n-          \/\/  Live object, need to scan to rebuild remembered sets for this object.\n-          start += scan_object(hr, start);\n-        } else {\n-          \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n-          \/\/ marked object and continue.\n-          start = scrub_to_next_live(hr, start, limit);\n-        }\n-\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n-      }\n-      return false;\n-    }\n-\n-    \/\/ Scan the given region from parsable_bottom to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_from_pb_to_tars(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        start += scan_object(hr, start);\n-        \/\/ Avoid stalling safepoints and stop iteration if mark cycle has been aborted.\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n+    \/\/ Scan or scrub depending on if addr is marked.\n+    HeapWord* scan_or_scrub(G1HeapRegion* hr, HeapWord* addr, HeapWord* limit) {\n+      if (_bitmap->is_marked(addr)) {\n+        \/\/  Live object, need to scan to rebuild remembered sets for this object.\n+        return addr + scan_object(hr, addr);\n+      } else {\n+        \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next marked object.\n+        HeapWord* scrub_end = _bitmap->get_next_marked_addr(addr, limit);\n+        hr->fill_range_with_dead_objects(addr, scrub_end);\n+        \/\/ Return the next object to handle.\n+        return scrub_end;\n@@ -223,1 +178,0 @@\n-      return false;\n@@ -226,3 +180,2 @@\n-    \/\/ Scan and scrub the given region to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ Scan and scrub the given region to tars.\n+    void scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -234,4 +187,6 @@\n-      if (scan_and_scrub_to_pb(hr, hr->bottom(), pb)) {\n-        log_trace(gc, marking)(\"Scan and scrub aborted for region: %u\", hr->hrm_index());\n-        return true;\n-      }\n+      {\n+        \/\/ Step 1: Scan the given region from bottom to parsable_bottom.\n+        HeapWord* start = hr->bottom();\n+        HeapWord* limit = pb;\n+        while (start < limit) {\n+          start = scan_or_scrub(hr, start, limit);\n@@ -239,4 +194,4 @@\n-      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n-      \/\/ re-check after above.\n-      if (!should_rebuild_or_scrub(hr)) {\n-        return false;\n+          if (yield_if_necessary(hr)) {\n+            return;\n+          }\n+        }\n@@ -244,0 +199,1 @@\n+\n@@ -248,4 +204,11 @@\n-      \/\/ Rebuild from TAMS (= parsable_bottom) to TARS.\n-      if (scan_from_pb_to_tars(hr, pb, _cm->top_at_rebuild_start(hr))) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n+      {\n+        \/\/ Step 2: Rebuild from TAMS (= parsable_bottom) to TARS.\n+        HeapWord* start = pb;\n+        HeapWord* limit = _cm->top_at_rebuild_start(hr);\n+        while (start < limit) {\n+          start += scan_object(hr, start);\n+\n+          if (yield_if_necessary(hr)) {\n+            return;\n+          }\n+        }\n@@ -253,1 +216,0 @@\n-      return false;\n@@ -257,2 +219,2 @@\n-    \/\/ stalling safepoints. Returns whether the concurrent marking phase has been aborted.\n-    bool scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ stalling safepoints.\n+    void scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -263,1 +225,1 @@\n-        return false;\n+        return;\n@@ -281,6 +243,1 @@\n-      bool mark_aborted = scan_large_object(hr, humongous, mr);\n-      if (mark_aborted) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n-      }\n-      return false;\n+      scan_large_object(hr, humongous, mr);\n@@ -315,1 +272,0 @@\n-      bool mark_aborted;\n@@ -318,1 +274,1 @@\n-        mark_aborted = scan_and_scrub_region(hr, pb);\n+        scan_and_scrub_region(hr, pb);\n@@ -322,1 +278,1 @@\n-        mark_aborted = scan_humongous_region(hr, pb);\n+        scan_humongous_region(hr, pb);\n@@ -325,1 +281,1 @@\n-      return mark_aborted;\n+      return _cm->has_aborted();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":56,"deletions":100,"binary":false,"changes":156,"status":"modified"}]}