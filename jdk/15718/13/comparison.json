{"files":[{"patch":"@@ -81,0 +81,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1534,2 +1534,34 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  str(super_klass, super_cache_addr);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip_same, L_skip_different;\n+\n+    \/\/ Are we trying to store the same value in the global cache?\n+    ldr(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_value_offset()));\n+    cmp(rscratch1, super_klass);\n+    br(Assembler::NE, L_skip_different);\n+\n+    \/\/ Trying to store the same value, have we tried enough times?\n+    ldrw(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+    subw(rscratch1, rscratch1, 1);\n+    tbz(rscratch1, 31, L_skip_same);\n+\n+    \/\/ Store!\n+    str(super_klass, super_cache_addr);\n+\n+    \/\/ Store the current attempted value and reset the backoff count.\n+    bind(L_skip_different);\n+    movw(rscratch1, super_cache_backoff);\n+    str(super_klass, Address(rthread, JavaThread::backoff_secondary_super_value_offset()));\n+\n+    \/\/ Store the new value for backoff count: either decremented\n+    \/\/ for the same class, or re-initialized for the different class.\n+    bind(L_skip_same);\n+    strw(rscratch1, Address(rthread, JavaThread::backoff_secondary_super_miss_offset()));\n+\n+    \/\/ The operations above destroy condition codes set by scan.\n+    \/\/ This is the success path, restore them ourselves.\n+    cmp(zr, zr); \/\/ Set Z flag\n+  } else {\n+    str(super_klass, super_cache_addr);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+\/\/ Not implemented yet, see JDK-8318414\n+define_pd_global(uint, SecondarySuperMissBackoff, 0);\n+\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,1 +2024,22 @@\n-  std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    lwz(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+    addic_(temp, temp, -1);\n+    stw(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+    bgt(CCR0, L_skip);\n+\n+    load_const_optimized(temp, super_cache_backoff);\n+    stw(temp, in_bytes(JavaThread::backoff_secondary_super_miss_offset()), R16_thread);\n+\n+    std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+\n+    bind(L_skip);\n+    if (L_success == nullptr && result_reg == noreg) {\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ Restore CCR0 EQ\n+    }\n+  } else {\n+    std(super_klass, target_offset, sub_klass); \/\/ save result to cache\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3363,2 +3363,17 @@\n-  \/\/ Success. Cache the super we found an proceed in triumph.\n-  sd(super_klass, super_cache_addr);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    lwu(t0, Address(xthread, JavaThread::backoff_secondary_super_miss_offset()));\n+    subw(t0, t0, 1);\n+    bgez(t0, L_skip);\n+\n+    sd(super_klass, super_cache_addr);\n+    mv(t0, super_cache_backoff);\n+\n+    bind(L_skip);\n+    sw(t0, Address(xthread, JavaThread::backoff_secondary_super_miss_offset()));\n+  } else {\n+    sd(super_klass, super_cache_addr);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3030,1 +3030,2 @@\n-  assert_different_registers(Z_R1, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);\n+  const Register temp = Z_R1_scratch;\n+  assert_different_registers(temp, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);\n@@ -3039,0 +3040,1 @@\n+  const int sm_offset = in_bytes(JavaThread::backoff_secondary_super_miss_offset());\n@@ -3063,1 +3065,1 @@\n-  z_llill(Z_R1, BytesPerWord);               \/\/ Set increment\/end index.\n+  z_llill(temp, BytesPerWord);               \/\/ Set increment\/end index.\n@@ -3072,1 +3074,1 @@\n-  z_brxlg(Rlength, Z_R1, loop_iterate);\n+  z_brxlg(Rlength, temp, loop_iterate);\n@@ -3082,1 +3084,16 @@\n-  z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0 && VM_Version::has_MemWithImmALUOps()) {\n+    NearLabel L_skip;\n+    z_asi(Address(Z_thread, sm_offset), -1);\n+    branch_optimized(Assembler::bcondNotLow, L_skip);\n+\n+    load_const_optimized(temp, super_cache_backoff);\n+    z_st(temp, sm_offset, Z_thread);\n+\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+\n+    bind(L_skip);\n+  } else {\n+    z_stg(Rsuperklass, sc_offset, Rsubklass); \/\/ Save result to cache.\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+define_pd_global(uint, SecondarySuperMissBackoff, 1000);\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4681,2 +4681,22 @@\n-  \/\/ Success.  Cache the super we found and proceed in triumph.\n-  movptr(super_cache_addr, super_klass);\n+  \/\/ Success. Try to cache the super we found and proceed in triumph.\n+#ifdef _LP64\n+  uint32_t super_cache_backoff = checked_cast<uint32_t>(SecondarySuperMissBackoff);\n+  if (super_cache_backoff > 0) {\n+    Label L_skip;\n+\n+    subl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), 1);\n+    jccb(Assembler::greaterEqual, L_skip);\n+\n+    movptr(super_cache_addr, super_klass);\n+    movl(Address(r15_thread, JavaThread::backoff_secondary_super_miss_offset()), super_cache_backoff);\n+\n+    bind(L_skip);\n+\n+    \/\/ The operations above destroy condition codes set by scan.\n+    \/\/ This is the success path, restore them ourselves.\n+    cmpptr(rax, rax); \/\/ set ZF=1\n+  } else\n+#endif\n+  {\n+    movptr(super_cache_addr, super_klass);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+\/\/ not used\n+define_pd_global(uint, SecondarySuperMissBackoff, 0);\n+\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2012,0 +2012,7 @@\n+                                                                            \\\n+  product_pd(uint, SecondarySuperMissBackoff, DIAGNOSTIC,                   \\\n+          \"How many misses to accept before updating the secondary super \"  \\\n+          \"cache slot. This mitigates cache slot contention in \"            \\\n+          \"pathological cases. Use 0 to disable.\")                          \\\n+          range(0, UINT32_MAX)                                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -417,0 +417,3 @@\n+  _backoff_secondary_super_value(nullptr),\n+  _backoff_secondary_super_miss(SecondarySuperMissBackoff),\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,0 +145,4 @@\n+  \/\/ Used to back off on secondary super cache updates to mitigate contention on it.\n+  void*         _backoff_secondary_super_value;\n+  uint32_t      _backoff_secondary_super_miss;\n+\n@@ -747,0 +751,4 @@\n+  \/\/ Backoff counters support\n+  static ByteSize backoff_secondary_super_miss_offset() { return byte_offset_of(JavaThread, _backoff_secondary_super_miss); }\n+  static ByteSize backoff_secondary_super_value_offset() { return byte_offset_of(JavaThread, _backoff_secondary_super_value); }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(1)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheHits {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on a happy path, when we can actually cache\n+    \/\/ the last super and use it effectively.\n+\n+    interface I01 {}\n+    interface I02 {}\n+    interface I03 {}\n+    interface I04 {}\n+    interface I05 {}\n+    interface I06 {}\n+    interface I07 {}\n+    interface I08 {}\n+    interface I09 {}\n+    interface I10 {}\n+    interface I11 {}\n+    interface I12 {}\n+    interface I13 {}\n+    interface I14 {}\n+    interface I15 {}\n+    interface I16 {}\n+    interface I17 {}\n+    interface I18 {}\n+    interface I19 {}\n+    interface I20 {}\n+\n+    class B {}\n+    class C1 extends B implements I01, I02, I03, I04, I05, I06, I07, I08, I09, I10, I11, I12, I13, I14, I15, I16, I17, I18, I19, I20 {}\n+\n+    volatile B o;\n+\n+    @Setup\n+    public void setup() {\n+        o = new C1();\n+    }\n+\n+    static final int ITERS = 10000;\n+\n+    @Benchmark\n+    @OperationsPerInvocation(20*ITERS)\n+    public void test(Blackhole bh) {\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I01);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I02);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I03);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I04);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I05);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I06);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I07);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I08);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I09);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I10);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I11);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I12);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I13);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I14);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I15);\n+\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I16);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I17);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I18);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I19);\n+        for (int c = 0; c < ITERS; c++) bh.consume(o instanceof I20);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheHits.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheInterContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In tihs test, every thread comes with its own stable\n+    \/\/ cached value. Meaning, this tests the INTER-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t1(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(2)\n+    @Group(\"test\")\n+    @GroupThreads(1)\n+    public void t2(Blackhole bh) {\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheInterContention.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 300, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"})\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Threads(Threads.MAX)\n+@State(Scope.Benchmark)\n+public class SecondarySuperCacheIntraContention {\n+\n+    \/\/ This test targets C1 specifically, to enter the interesting code path\n+    \/\/ without heavily optimizing compiler like C2 optimizing based on profiles,\n+    \/\/ or folding the instanceof checks.\n+\n+    \/\/ The test verifies what happens on unhappy path, when we contend a lot over\n+    \/\/ the secondary super cache, where different threads want to update the cache\n+    \/\/ with different value. In this test, every thread comes with its own contending\n+    \/\/ value. Meaning, this tests the INTRA-thread contention.\n+\n+    interface IA {}\n+    interface IB {}\n+    class B {}\n+    class C1 extends B implements IA, IB {}\n+    class C2 extends B implements IA, IB {}\n+\n+    volatile B o1, o2;\n+\n+    @Setup\n+    public void setup() {\n+        o1 = new C1();\n+        o2 = new C2();\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(4)\n+    public void test(Blackhole bh) {\n+        bh.consume(o1 instanceof IA);\n+        bh.consume(o2 instanceof IA);\n+        bh.consume(o1 instanceof IB);\n+        bh.consume(o2 instanceof IB);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SecondarySuperCacheIntraContention.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}