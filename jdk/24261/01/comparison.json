{"files":[{"patch":"@@ -254,1 +254,1 @@\n-    abstract static class Sync extends AbstractQueuedSynchronizer {\n+    abstract static class Sync extends AbstractQueuedLongSynchronizer {\n@@ -259,1 +259,1 @@\n-         * Lock state is logically divided into two unsigned shorts:\n+         * Lock state is logically divided into two ints:\n@@ -264,4 +264,4 @@\n-        static final int SHARED_SHIFT   = 16;\n-        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);\n-        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\n-        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n+        static final int SHARED_SHIFT   = 32;\n+        static final long SHARED_UNIT    = (1L << SHARED_SHIFT);\n+        static final long MAX_COUNT      = Integer.MAX_VALUE;\n+        static final long EXCLUSIVE_MASK = (1L << SHARED_SHIFT) - 1;\n@@ -270,1 +270,1 @@\n-        static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }\n+        static int sharedCount(long c)    { return (int)(c >>> SHARED_SHIFT); }\n@@ -272,1 +272,1 @@\n-        static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\n+        static int exclusiveCount(long c) { return (int)(c & EXCLUSIVE_MASK); }\n@@ -370,0 +370,1 @@\n+        @Override\n@@ -371,1 +372,1 @@\n-        protected final boolean tryRelease(int releases) {\n+        protected final boolean tryRelease(long releases) {\n@@ -374,1 +375,1 @@\n-            int nextc = getState() - releases;\n+            long nextc = getState() - releases;\n@@ -382,0 +383,1 @@\n+        @Override\n@@ -383,1 +385,1 @@\n-        protected final boolean tryAcquire(int acquires) {\n+        protected final boolean tryAcquire(long acquires) {\n@@ -396,2 +398,2 @@\n-            int c = getState();\n-            int w = exclusiveCount(c);\n+            long c = getState();\n+            long w = exclusiveCount(c);\n@@ -415,0 +417,1 @@\n+        @Override\n@@ -416,1 +419,1 @@\n-        protected final boolean tryReleaseShared(int unused) {\n+        protected final boolean tryReleaseShared(long unused) {\n@@ -438,2 +441,2 @@\n-                int c = getState();\n-                int nextc = c - SHARED_UNIT;\n+                long c = getState();\n+                long nextc = c - SHARED_UNIT;\n@@ -453,0 +456,1 @@\n+        @Override\n@@ -454,1 +458,1 @@\n-        protected final int tryAcquireShared(int unused) {\n+        protected final long tryAcquireShared(long unused) {\n@@ -471,1 +475,1 @@\n-            int c = getState();\n+            long c = getState();\n@@ -474,1 +478,1 @@\n-                return -1;\n+                return -1L;\n@@ -493,1 +497,1 @@\n-                return 1;\n+                return 1L;\n@@ -502,1 +506,1 @@\n-        final int fullTryAcquireShared(Thread current) {\n+        final long fullTryAcquireShared(Thread current) {\n@@ -511,1 +515,1 @@\n-                int c = getState();\n+                long c = getState();\n@@ -532,1 +536,1 @@\n-                            return -1;\n+                            return -1L;\n@@ -554,1 +558,1 @@\n-                    return 1;\n+                    return 1L;\n@@ -567,1 +571,1 @@\n-            int c = getState();\n+            long c = getState();\n@@ -590,1 +594,1 @@\n-                int c = getState();\n+                long c = getState();\n@@ -675,1 +679,1 @@\n-        final int getCount() { return getState(); }\n+        final long getCount() { return getState(); }\n@@ -1434,1 +1438,1 @@\n-        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n+        if (!(condition instanceof AbstractQueuedLongSynchronizer.ConditionObject))\n@@ -1436,1 +1440,1 @@\n-        return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);\n+        return sync.hasWaiters((AbstractQueuedLongSynchronizer.ConditionObject)condition);\n@@ -1457,1 +1461,1 @@\n-        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n+        if (!(condition instanceof AbstractQueuedLongSynchronizer.ConditionObject))\n@@ -1459,1 +1463,1 @@\n-        return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);\n+        return sync.getWaitQueueLength((AbstractQueuedLongSynchronizer.ConditionObject)condition);\n@@ -1482,1 +1486,1 @@\n-        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n+        if (!(condition instanceof AbstractQueuedLongSynchronizer.ConditionObject))\n@@ -1484,1 +1488,1 @@\n-        return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);\n+        return sync.getWaitingThreads((AbstractQueuedLongSynchronizer.ConditionObject)condition);\n@@ -1497,1 +1501,1 @@\n-        int c = sync.getCount();\n+        long c = sync.getCount();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.java","additions":38,"deletions":34,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -625,0 +625,1 @@\n+                \"ReentrantReadWriteLock20Test\"\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ * Other contributors include Andrew Wright, Jeffrey Hayes,\n+ * Pat Fisher, Mike Judd.\n+ *\/\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import java.util.ArrayDeque;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class ReentrantReadWriteLock20Test extends JSR166TestCase {\n+    public static void main(String[] args) {\n+        main(suite(), args);\n+    }\n+    public static Test suite() {\n+        return new TestSuite(ReentrantReadWriteLock20Test.class);\n+    }\n+    public void test66kReadersFair() throws InterruptedException   { test66kReaders(true); }\n+    public void test66kReadersUnfair() throws InterruptedException { test66kReaders(false); }\n+\n+    private void test66kReaders(boolean fairness) throws InterruptedException {\n+        final var failure = new AtomicReference<Throwable>();\n+        final var lock = new ReentrantReadWriteLock(fairness);\n+        final var numThreads = 0x10000;\n+        final var threads = new ArrayDeque<Thread>(numThreads);\n+        final var latch = new CountDownLatch(1);\n+        try {\n+            for(int i = 0; i < numThreads && failure.get() == null;++i) {\n+                var t = Thread.ofVirtual().unstarted(() -> {\n+\n+                    try {\n+                        lock.readLock().lock();\n+                    } catch (Throwable ex) {\n+                        failure.compareAndSet(null, ex);\n+                        return;\n+                    }\n+\n+                    try {\n+                        while (latch.getCount() > 0) {\n+                            try {\n+                                latch.await();\n+                            } catch (InterruptedException ie) {\n+                                failure.compareAndSet(null, ie);\n+                            }\n+                        }\n+                    }\n+                    finally {\n+                        lock.readLock().unlock();\n+                    }\n+                });\n+\n+                threads.addLast(t);\n+                t.start();\n+            }\n+        } finally {\n+            latch.countDown(); \/\/ Make sure waiters are signalled\n+            Thread next;\n+            while ((next = threads.pollFirst()) != null) {\n+                while (next.isAlive()) {\n+                    next.join();\n+                }\n+            }\n+        }\n+\n+        assertEquals(null, failure.get());\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ReentrantReadWriteLock20Test.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -1723,1 +1723,1 @@\n-            = \"AbstractQueuedSynchronizer$ConditionObject\";\n+            = \"AbstractQueuedLongSynchronizer$ConditionObject\";\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ReentrantReadWriteLockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}