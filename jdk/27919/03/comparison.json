{"files":[{"patch":"@@ -87,0 +87,1 @@\n+  static bool has_agents() { return head() != nullptr; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -39,1 +41,1 @@\n-static bool for_scoped_method(JavaThread* jt, const Func& func) {\n+static void for_scoped_methods(JavaThread* jt, const Func& func) {\n@@ -47,0 +49,2 @@\n+\n+  bool would_have_bailed = false;\n@@ -49,2 +53,1 @@\n-  const int max_critical_stack_depth = 10;\n-  int depth = 0;\n+  bool agents_loaded = JvmtiAgentList::has_agents();\n@@ -53,0 +56,14 @@\n+\n+    if (!agents_loaded &&\n+      (m->method_holder()->module()->name() != vmSymbols::java_base())) {\n+      \/\/ Stop walking if we see a frame outside of java.base.\n+\n+      \/\/ If any JVMTI agents are loaded, we also have to keep walking, since\n+      \/\/ agents can add arbitrary Java frames to the stack inside a @Scoped method.\n+#ifndef ASSERT\n+      return;\n+#else\n+      would_have_bailed = true;\n+#endif\n+    }\n+\n@@ -63,10 +80,9 @@\n-      assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-      return func(stream);\n-    }\n-    depth++;\n-\n-#ifndef ASSERT\n-    \/\/ On debug builds, just keep searching the stack\n-    \/\/ in case we missed an @Scoped method further up\n-    if (depth >= max_critical_stack_depth) {\n-      break;\n+      assert(!would_have_bailed, \"would have missed scoped method on release build\");\n+      bool done = func(stream);\n+      if (done || !agents_loaded) {\n+        \/\/ We may also have to keep walking after finding a @Scoped method,\n+        \/\/ since there may be multiple @Scoped methods active on the stack\n+        \/\/ if a JVMTI agent callback runs during a scoped access and calls\n+        \/\/ back into Java code that then itself does a scoped access.\n+        return;\n+      }\n@@ -74,1 +90,0 @@\n-#endif\n@@ -76,1 +91,0 @@\n-  return false;\n@@ -80,1 +94,8 @@\n-  return for_scoped_method(jt, [&](vframeStream& stream){\n+  if (jt->is_throwing_unsafe_access_error()) {\n+    \/\/ Ignore this thread. It is in the process of throwing another exception\n+    \/\/ already.\n+    return false;\n+  }\n+\n+  bool is_accessing_session = false;\n+  for_scoped_methods(jt, [&](vframeStream& stream){\n@@ -87,0 +108,1 @@\n+          is_accessing_session = true;\n@@ -93,0 +115,1 @@\n+  return is_accessing_session;\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -725,0 +725,2 @@\n+  \/\/ Tell code inspecting handshakee's stack what we are doing\n+  ThrowingUnsafeAccessError tuae(_handshakee);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,0 +447,1 @@\n+  _throwing_unsafe_access_error(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -320,0 +320,1 @@\n+  volatile bool         _throwing_unsafe_access_error;   \/\/ Thread has faulted and is throwing an exception\n@@ -625,0 +626,3 @@\n+  bool is_throwing_unsafe_access_error()          { return _throwing_unsafe_access_error; }\n+  void set_throwing_unsafe_access_error(bool val) { _throwing_unsafe_access_error = val; }\n+\n@@ -1357,0 +1361,11 @@\n+class ThrowingUnsafeAccessError : public StackObj {\n+  JavaThread* _thread;\n+public:\n+  ThrowingUnsafeAccessError(JavaThread* thread) : _thread(thread) {\n+    _thread->set_throwing_unsafe_access_error(true);\n+  }\n+  ~ThrowingUnsafeAccessError() {\n+    _thread->set_throwing_unsafe_access_error(false);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351032\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flavor != \"zero\"\n+ * @requires vm.hasJFR\n+ * @summary Test closing a shared scope during faulting access\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main jdk.test.lib.FileInstaller sharedCloseJfr.jfc sharedCloseJfr.jfc\n+ * @run main\/othervm\n+ *   -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *   -XX:StartFlightRecording:filename=recording.jfr,dumponexit=true,settings=sharedCloseJfr.jfc\n+ *   TestSharedCloseJFR\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.RandomAccessFile;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/\/ We are interested in the following scenario:\n+\/\/ When accessing a memory-mapped file that is truncated\n+\/\/ a segmentation fault will occur (see also test\/hotspot\/jtreg\/runtime\/Unsafe\/InternalErrorTest.java)\n+\/\/\n+\/\/ This segmentation fault will be caught in the VM's signal handler\n+\/\/ and get turned into an InternalError by a VM handshake operation.\n+\/\/ This handshake operation calls back into Java to the constructor\n+\/\/ of InternalError. This constructor calls super constructors until\n+\/\/ it ends up in the constructor of Throwable, where JFR starts logging\n+\/\/ the Throwable being created. This logging code adds a bunch\n+\/\/ of extra Java frames to the stack.\n+\/\/\n+\/\/ All of this occurs during the original memory access, i.e.\n+\/\/ while we are inside a @Scoped method call (jdk.internal.misc.ScopedMemoryAccess).\n+\/\/ If at this point a shared arena is closed in another thread,\n+\/\/ the shared scope closure handshake (src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp)\n+\/\/ will see all the extra frames added by JFR and the InternalError constructor,\n+\/\/ while walking the stack of the thread doing the faulting access.\n+\/\/\n+\/\/ This test is here to make sure that the shared scope closure handshake can\n+\/\/ deal with that situation.\n+public class TestSharedCloseJFR {\n+\n+    private static final int PAGE_SIZE = WhiteBox.getWhiteBox().getVMPageSize();\n+\n+    public static void main(String[] args) throws Throwable {\n+        String fileName = \"tmp.txt\";\n+        Path path = Path.of(fileName);\n+        AtomicBoolean stop = new AtomicBoolean();\n+\n+        Files.write(path, \"1\".repeat(PAGE_SIZE + 1000).getBytes());\n+        try (RandomAccessFile file = new RandomAccessFile(fileName, \"rw\")) {\n+            FileChannel fileChannel = file.getChannel();\n+            MemorySegment segment =\n+                    fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size(), Arena.ofAuto());\n+            \/\/ truncate file\n+            \/\/ this will make the access fault\n+            Files.write(path, \"2\".getBytes());\n+\n+            \/\/ start worker thread\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread.ofPlatform().start(() -> {\n+                latch.countDown();\n+                while (!stop.get()) {\n+                    Arena.ofShared().close(); \/\/ hammer VM with handshakes\n+                }\n+            });\n+\n+            \/\/ wait util the worker thread has started\n+            latch.await();\n+\n+            \/\/ access (should fault)\n+            \/\/ try it a few times until we get a handshake during JFR reporting\n+            for (int i = 0; i < 50_000; i++) {\n+                try {\n+                    segment.get(ValueLayout.JAVA_INT, PAGE_SIZE);\n+                    throw new RuntimeException(\"InternalError was expected\");\n+                } catch (InternalError e) {\n+                    \/\/ InternalError as expected\n+                    if (!e.getMessage().contains(\"a fault occurred in an unsafe memory access\")) {\n+                        throw new RuntimeException(\"Unexpected exception\", e);\n+                    }\n+                }\n+            }\n+        } finally {\n+            \/\/ stop worker\n+            stop.set(true);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejfr\/TestSharedCloseJFR.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<configuration label=\"Custom\" version=\"2.0\">\n+  <event name=\"jdk.JavaErrorThrow\">\n+    <setting name=\"enabled\" control=\"enable-errors\">true<\/setting>\n+    <setting name=\"stackTrace\">true<\/setting>\n+  <\/event>\n+<\/configuration>\n","filename":"test\/jdk\/java\/foreign\/sharedclosejfr\/sharedCloseJfr.jfc","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8351032\n+ * @library \/test\/lib\n+ * @run junit\/native TestSharedCloseJvmti\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class TestSharedCloseJvmti {\n+\n+    private static final String JVMTI_AGENT_LIB = Path.of(Utils.TEST_NATIVE_PATH, System.mapLibraryName(\"SharedCloseAgent\"))\n+            .toAbsolutePath().toString();\n+\n+    @Test\n+    void eventDuringScopedAccess() throws Throwable {\n+        List<String> command = new ArrayList<>(List.of(\n+                \"-agentpath:\" + JVMTI_AGENT_LIB,\n+                \"-Xcheck:jni\",\n+                EventDuringScopedAccessRunner.class.getName()\n+        ));\n+\n+        try {\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(command);\n+            Process process = ProcessTools.startProcess(\"fork\", pb, null, null, 1L, TimeUnit.MINUTES);\n+            OutputAnalyzer output = new OutputAnalyzer(process);\n+            output.shouldHaveExitValue(0);\n+            output.stderrShouldContain(\"Exception in thread \\\"Trigger\\\" jdk.internal.misc.ScopedMemoryAccess$ScopedAccessError: Invalid memory access\");\n+        } catch (TimeoutException e) {\n+            throw new RuntimeException(\"Timeout while waiting for forked process\");\n+        }\n+    }\n+\n+    public static class EventDuringScopedAccessRunner {\n+        static final int ADDED_FRAMES = 10;\n+\n+        static final CountDownLatch MAIN_LATCH = new CountDownLatch(1);\n+        static final CountDownLatch TARGET_LATCH = new CountDownLatch(1);\n+        static final MemorySegment OTHER_SEGMENT = Arena.global().allocate(4);\n+\n+        static volatile int SINK;\n+\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.ofShared()) {\n+                MemorySegment segment = arena.allocate(4);\n+                \/\/ run in separate thread so that waiting on\n+                \/\/ latch doesn't block main thread\n+                Thread.ofPlatform().name(\"Trigger\").start(() -> {\n+                    SINK = segment.get(ValueLayout.JAVA_INT, 0);\n+                });\n+                \/\/ wait until trigger thread is in JVMTI event callback\n+                MAIN_LATCH.await();\n+            }\n+            \/\/ Notify trigger thread that arena was closed\n+            TARGET_LATCH.countDown();\n+        }\n+\n+        static boolean reentrant = false;\n+\n+        \/\/ called by jvmti agent\n+        \/\/ we get here after checking arena liveness\n+        private static void target() {\n+            String callerName = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).walk(frames ->\n+                    frames.skip(2).findFirst().orElseThrow().getClassName());\n+            if (!callerName.equals(\"jdk.internal.misc.ScopedMemoryAccess\")) {\n+                return;\n+            }\n+\n+            if (reentrant) {\n+                \/\/ put some frames on the stack, so stack walk does not see @Scoped method\n+                addFrames(0);\n+            } else {\n+                reentrant = true;\n+                SINK = OTHER_SEGMENT.get(ValueLayout.JAVA_INT, 0);\n+                reentrant = false;\n+            }\n+        }\n+\n+        private static void addFrames(int depth) {\n+            if (depth >= ADDED_FRAMES) {\n+                \/\/ notify main thread to close the arena\n+                MAIN_LATCH.countDown();\n+                try {\n+                    \/\/ wait here until main thread has closed arena\n+                    TARGET_LATCH.await();\n+                } catch (InterruptedException ex) {\n+                    throw new RuntimeException(\"Unexpected interruption\");\n+                }\n+                return;\n+            }\n+            addFrames(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/TestSharedCloseJvmti.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+\n+#include <string.h>\n+\n+static jclass MAIN_CLS;\n+static jmethodID TARGET_ID;\n+\n+static const char* TARGET_CLASS_NAME = \"TestSharedCloseJvmti$EventDuringScopedAccessRunner\";\n+static const char* TARGET_METHOD_NAME = \"target\";\n+static const char* TARGET_METHOD_SIG = \"()V\";\n+\n+static const char* INTERCEPT_CLASS_NAME = \"Ljdk\/internal\/foreign\/MemorySessionImpl;\";\n+static const char* INTERCEPT_METHOD_NAME = \"checkValidStateRaw\";\n+\n+void start(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n+\n+  jclass cls = jni_env->FindClass(TARGET_CLASS_NAME);\n+  if (cls == nullptr) {\n+    jni_env->ExceptionDescribe();\n+    return;\n+  }\n+\n+  MAIN_CLS = (jclass) jni_env->NewGlobalRef(cls);\n+\n+  TARGET_ID = jni_env->GetStaticMethodID(cls, TARGET_METHOD_NAME, TARGET_METHOD_SIG);\n+  if (TARGET_ID == nullptr) {\n+    jni_env->ExceptionDescribe();\n+    return;\n+  }\n+}\n+\n+void method_exit(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread, jmethodID method,\n+                 jboolean was_popped_by_exception, jvalue return_value) {\n+  char* method_name = nullptr;\n+  jvmtiError err = jvmti_env->GetMethodName(method, &method_name, nullptr, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return;\n+  }\n+\n+  if (strcmp(method_name, INTERCEPT_METHOD_NAME) != 0) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  jclass cls;\n+  err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  char* class_sig = nullptr;\n+  err = jvmti_env->GetClassSignature(cls, &class_sig, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    return;\n+  }\n+\n+  if (strcmp(class_sig, INTERCEPT_CLASS_NAME) != 0) {\n+    jvmti_env->Deallocate((unsigned char*) method_name);\n+    jvmti_env->Deallocate((unsigned char*) class_sig);\n+    return;\n+  }\n+\n+  jni_env->CallStaticVoidMethod(MAIN_CLS, TARGET_ID);\n+  if (jni_env->ExceptionOccurred()) {\n+    jni_env->ExceptionDescribe();\n+  }\n+\n+  jvmti_env->Deallocate((unsigned char*) method_name);\n+  jvmti_env->Deallocate((unsigned char*) class_sig);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv* env;\n+  jint jni_err = vm->GetEnv((void**) &env, JVMTI_VERSION);\n+  if (jni_err != JNI_OK) {\n+    return jni_err;\n+  }\n+\n+  jvmtiCapabilities capabilities{};\n+  capabilities.can_generate_method_exit_events = 1;\n+\n+  jvmtiError err = env->AddCapabilities(&capabilities);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  jvmtiEventCallbacks callbacks;\n+  callbacks.VMStart = start;\n+  callbacks.MethodExit = method_exit;\n+\n+  err = env->SetEventCallbacks(&callbacks, (jint) sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  err = env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  err = env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  return 0;\n+}\n","filename":"test\/jdk\/java\/foreign\/sharedclosejvmti\/libSharedCloseAgent.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 10, time = 10, timeUnit = TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 1, jvmArgs = { \"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\" })\n+public class SharedCloseStackWalk {\n+\n+    @Param({\"1\", \"10\", \"100\"})\n+    int numOtherThread;\n+\n+    @Param({\"10\", \"100\", \"1000\"})\n+    int extraFrames;\n+\n+    @Param({\"false\", \"true\"})\n+    boolean virtualThreads;\n+\n+    private CountDownLatch stop;\n+\n+    @Setup\n+    public void setup() {\n+        stop = new CountDownLatch(1);\n+        for (int i = 0; i < numOtherThread; i++) {\n+            (virtualThreads\n+                    ? Thread.ofVirtual()\n+                    : Thread.ofPlatform()).start(() -> recurse(0));\n+        }\n+    }\n+\n+    @TearDown\n+    public void teardown() {\n+        stop.countDown();\n+    }\n+\n+    @Benchmark\n+    public void sharedOpenClose() {\n+        Arena.ofShared().close();\n+    }\n+\n+    private void recurse(int depth) {\n+        if (depth == extraFrames) {\n+            try {\n+                stop.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Don't interrupt me!\", e);\n+            }\n+        } else {\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SharedCloseStackWalk.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}