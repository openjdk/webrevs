{"files":[{"patch":"@@ -783,0 +783,7 @@\n+\n+#ifdef ASSERT\n+  uint region_idx = card_region >> config()->log2_card_regions_per_heap_region();\n+  G1HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+  assert(r->rem_set()->card_set() != this, \"must be\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3057,0 +3057,2 @@\n+\n+  collection_set()->prepare_groups_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  assert(!r->has_pinned_objects(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -57,0 +57,3 @@\n+  _collection_set_groups(),\n+  _selected_groups_cur_length(0),\n+  _selected_groups_inc_part_start(0),\n@@ -60,1 +63,1 @@\n-  _optional_old_regions(),\n+  _optional_groups(),\n@@ -81,1 +84,1 @@\n-  _optional_old_regions.clear();\n+  _optional_groups.clear();\n@@ -95,1 +98,4 @@\n-  _optional_old_regions.clear();\n+}\n+\n+void G1CollectionSet::prepare_groups_for_scan () {\n+  collection_set_groups()->prepare_for_scan();\n@@ -105,0 +111,2 @@\n+  assert(!hr->rem_set()->has_group_cardset(), \"Must not have a group remset\");\n+\n@@ -130,0 +138,1 @@\n+  _collection_set_groups.clear();\n@@ -155,1 +164,1 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n+  _optional_groups.iterate([&] (G1HeapRegion* r) {\n@@ -158,1 +167,1 @@\n-  }\n+  });\n@@ -287,1 +296,1 @@\n-  log_trace(gc, ergo, cset)(\"Start choosing CSet. Pending cards: \" SIZE_FORMAT \" target pause time: %1.2fms\",\n+  log_trace(gc, ergo, cset)(\"Start choosing CSet. Pending cards: %zu target pause time: %1.2fms\",\n@@ -303,0 +312,1 @@\n+  size_t bytes_to_copy = 0;\n@@ -304,1 +314,1 @@\n-                               _policy->predict_eden_copy_time_ms(eden_region_length);\n+                               _policy->predict_eden_copy_time_ms(eden_region_length, &bytes_to_copy);\n@@ -340,0 +350,3 @@\n+  _selected_groups_cur_length = 0;\n+  _selected_groups_inc_part_start = 0;\n+\n@@ -343,5 +356,0 @@\n-    G1CollectionCandidateRegionList initial_old_regions;\n-    assert(_optional_old_regions.length() == 0, \"must be\");\n-    G1CollectionCandidateRegionList pinned_marking_regions;\n-    G1CollectionCandidateRegionList pinned_retained_regions;\n-\n@@ -349,3 +357,1 @@\n-      time_remaining_ms = select_candidates_from_marking(time_remaining_ms,\n-                                                         &initial_old_regions,\n-                                                         &pinned_marking_regions);\n+      time_remaining_ms = select_candidates_from_marking(time_remaining_ms);\n@@ -356,15 +362,1 @@\n-    select_candidates_from_retained(time_remaining_ms,\n-                                    &initial_old_regions,\n-                                    &pinned_retained_regions);\n-\n-    \/\/ Move initially selected old regions to collection set directly.\n-    move_candidates_to_collection_set(&initial_old_regions);\n-    \/\/ Only prepare selected optional regions for now.\n-    prepare_optional_regions(&_optional_old_regions);\n-    \/\/ Move pinned marking regions we came across to retained candidates so that\n-    \/\/ there is progress in the mixed gc phase.\n-    move_pinned_marking_to_retained(&pinned_marking_regions);\n-    \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n-    \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n-    \/\/ GCs and hence are considered \"long lived\".\n-    drop_pinned_retained_regions(&pinned_retained_regions);\n+    uint num_optional_regions = _optional_groups.num_regions();\n@@ -372,0 +364,3 @@\n+    if (candidates()->retained_groups().num_regions() > 0) {\n+      select_candidates_from_retained(time_remaining_ms);\n+    }\n@@ -377,0 +372,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -385,8 +381,0 @@\n-void G1CollectionSet::move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions) {\n-  for (G1HeapRegion* r : *regions) {\n-    _g1h->clear_region_attr(r);\n-    add_old_region(r);\n-  }\n-  candidates()->remove(regions);\n-}\n-\n@@ -398,3 +386,1 @@\n-double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms,\n-                                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                                       G1CollectionCandidateRegionList* pinned_old_regions) {\n+double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms) {\n@@ -402,4 +388,3 @@\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n+  uint num_inital_regions = 0;\n+  uint num_initial_groups = 0;\n+  uint num_optional_regions = 0;\n@@ -412,3 +397,3 @@\n-  const uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n-  const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n-  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n+  uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n+  uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n+  uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n@@ -417,2 +402,1 @@\n-  G1CollectionCandidateList* marking_list = &candidates()->marking_regions();\n-  assert(marking_list != nullptr, \"must be\");\n+  G1CSetCandidateGroupList* from_marking_groups = &candidates()->from_marking_groups();\n@@ -423,1 +407,3 @@\n-                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n+                            min_old_cset_length, max_old_cset_length, from_marking_groups->num_regions(), time_remaining_ms, optional_threshold_ms);\n+\n+  G1CSetCandidateGroupList selected_groups;\n@@ -425,3 +411,2 @@\n-  G1CollectionCandidateListIterator iter = marking_list->begin();\n-  for (; iter != marking_list->end(); ++iter) {\n-    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n+  for (G1CSetCandidateGroup* group : *from_marking_groups) {\n+    if (num_inital_regions + num_optional_regions >= max_old_cset_length) {\n@@ -432,13 +417,3 @@\n-    G1HeapRegion* hr = (*iter)->_r;\n-    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n-    \/\/ space from them (and we expect to get free space from marking candidates).\n-    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n-    \/\/ to not impact the mixed phase too much.\n-    if (hr->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      (*iter)->update_num_unreclaimed();\n-      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n-      pinned_old_regions->append(hr);\n-      continue;\n-    }\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(hr, false);\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n+\n@@ -447,3 +422,9 @@\n-    if (initial_old_regions->length() < min_old_cset_length) {\n-      initial_old_regions->append(hr);\n-      num_initial_regions_selected++;\n+    if (num_inital_regions < min_old_cset_length) {\n+\n+      num_initial_groups++;\n+\n+      add_group_to_collection_set(group);\n+      selected_groups.append(group);\n+\n+      num_inital_regions += group->length();\n+\n@@ -453,1 +434,1 @@\n-        num_expensive_regions++;\n+        num_expensive_regions += group->length();\n@@ -463,0 +444,7 @@\n+        num_initial_groups++;\n+\n+        add_group_to_collection_set(group);\n+        selected_groups.append(group);\n+\n+        num_inital_regions += group->length();\n+\n@@ -464,2 +452,1 @@\n-        initial_old_regions->append(hr);\n-        num_initial_regions_selected++;\n+\n@@ -468,1 +455,3 @@\n-        assert(_optional_old_regions.length() < max_optional_regions, \"Should not be possible.\");\n+        _optional_groups.append(group);\n+        prepare_optional_group(group, num_optional_regions);\n+        num_optional_regions += group->length();\n@@ -470,2 +459,0 @@\n-        _optional_old_regions.append(hr);\n-        num_optional_regions_selected++;\n@@ -478,1 +465,7 @@\n-  if (iter == marking_list->end()) {\n+\n+  \/\/ Remove selected groups from list of candidate groups.\n+  if (num_initial_groups > 0) {\n+    candidates()->remove(&selected_groups);\n+  }\n+\n+  if (from_marking_groups->length() == 0) {\n@@ -487,1 +480,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, \"\n@@ -489,1 +482,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            num_inital_regions, num_optional_regions,\n@@ -492,2 +485,2 @@\n-  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n-  assert(_optional_old_regions.length() == num_optional_regions_selected, \"must be\");\n+  assert(selected_groups.num_regions() == num_inital_regions, \"must be\");\n+  assert(_optional_groups.num_regions() == num_optional_regions, \"must be\");\n@@ -497,6 +490,4 @@\n-void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms,\n-                                                      G1CollectionCandidateRegionList* initial_old_regions,\n-                                                      G1CollectionCandidateRegionList* pinned_old_regions) {\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_expensive_regions_selected = 0;\n+void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms) {\n+  uint num_initial_regions = 0;\n+  uint num_optional_regions = 0;\n+  uint num_expensive_regions = 0;\n@@ -517,1 +508,1 @@\n-  G1CollectionCandidateList* retained_list = &candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -522,1 +513,9 @@\n-                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n+                            min_regions, retained_groups->num_regions(), time_remaining_ms, optional_time_remaining_ms);\n+\n+  G1CSetCandidateGroupList remove_from_retained;\n+  G1CSetCandidateGroupList groups_to_abandon;\n+\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"Retained groups should have only 1 region\");\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -524,3 +523,0 @@\n-  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n-    G1HeapRegion* r = ci->_r;\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n@@ -528,0 +524,4 @@\n+\n+    G1CollectionSetCandidateInfo* ci = group->at(0); \/\/ we only have one region in the group\n+    G1HeapRegion* r = ci->_r;\n+\n@@ -535,1 +535,6 @@\n-        pinned_old_regions->append(r);\n+        \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n+        \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n+        \/\/ GCs and hence are considered \"long lived\".\n+        _g1h->clear_region_attr(r);\n+        groups_to_abandon.append(group);\n+        remove_from_retained.append(group);\n@@ -540,1 +545,1 @@\n-    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+    if (fits_in_remaining_time || (num_expensive_regions < min_regions)) {\n@@ -543,1 +548,1 @@\n-        num_expensive_regions_selected++;\n+        num_expensive_regions++;\n@@ -545,2 +550,5 @@\n-      initial_old_regions->append(r);\n-      num_initial_regions_selected++;\n+\n+      add_group_to_collection_set(group);\n+      remove_from_retained.append(group);\n+\n+      num_initial_regions += group->length();\n@@ -548,0 +556,4 @@\n+      \/\/ Prepare optional collection region.\n+      _optional_groups.append(group);\n+      prepare_optional_group(group, num_optional_regions);\n+      num_optional_regions += group->length();\n@@ -549,2 +561,0 @@\n-      _optional_old_regions.append(r);\n-      num_optional_regions_selected++;\n@@ -559,2 +569,1 @@\n-  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n-  if (num_regions_selected == retained_list->length()) {\n+  if (num_initial_regions == retained_groups->num_regions()) {\n@@ -563,1 +572,2 @@\n-  if (num_expensive_regions_selected > 0) {\n+\n+  if (num_expensive_regions > 0) {\n@@ -565,1 +575,1 @@\n-                              num_expensive_regions_selected);\n+                              num_expensive_regions);\n@@ -568,0 +578,6 @@\n+  \/\/ Remove groups from retained and also do some bookkeeping on CandidateOrigin\n+  \/\/ for the regions in these groups.\n+  candidates()->remove(&remove_from_retained);\n+\n+  groups_to_abandon.abandon();\n+\n@@ -571,1 +587,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            num_initial_regions, num_optional_regions, num_pinned_regions,\n@@ -575,3 +591,3 @@\n-void G1CollectionSet::select_candidates_from_optional_regions(double time_remaining_ms,\n-                                                              G1CollectionCandidateRegionList* selected_regions) {\n-  assert(optional_region_length() > 0,\n+double G1CollectionSet::select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected) {\n+\n+  assert(_optional_groups.num_regions() > 0,\n@@ -580,0 +596,1 @@\n+  uint num_groups_selected = 0;\n@@ -581,0 +598,3 @@\n+  G1CSetCandidateGroupList selected;\n+  for (G1CSetCandidateGroup* group : _optional_groups) {\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -582,6 +602,3 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    double prediction_ms = _policy->predict_region_total_time_ms(r, false);\n-\n-    if (prediction_ms > time_remaining_ms) {\n-      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n-                                prediction_ms, r->hrm_index(), time_remaining_ms);\n+    if (predicted_time_ms > time_remaining_ms) {\n+      log_debug(gc, ergo, cset)(\"Prediction %.3fms for group with %u regions does not fit remaining time: %.3fms.\",\n+                                predicted_time_ms, group->length(), time_remaining_ms);\n@@ -590,1 +607,0 @@\n-    \/\/ This region will be included in the next optional evacuation.\n@@ -592,2 +608,5 @@\n-    total_prediction_ms += prediction_ms;\n-    time_remaining_ms -= prediction_ms;\n+    total_prediction_ms += predicted_time_ms;\n+    time_remaining_ms -= predicted_time_ms;\n+\n+    num_regions_selected += group->length();\n+    num_groups_selected++;\n@@ -595,1 +614,2 @@\n-    selected_regions->append(r);\n+    add_group_to_collection_set(group);\n+    selected.append(group);\n@@ -598,0 +618,20 @@\n+  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  \/\/ Remove selected groups from candidate list.\n+  if (num_groups_selected > 0) {\n+    _optional_groups.remove(&selected);\n+    candidates()->remove(&selected);\n+  }\n+  return total_prediction_ms;\n+}\n+\n+uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+  uint optional_regions_count = num_optional_regions();\n+  assert(optional_regions_count > 0,\n+         \"Should only be called when there are optional regions\");\n+\n+  uint num_regions_selected = 0;\n+\n+  double total_prediction_ms = select_candidates_from_optional_groups(time_remaining_ms, num_regions_selected);\n+\n+  time_remaining_ms -= total_prediction_ms;\n+\n@@ -599,1 +639,2 @@\n-                            selected_regions->length(), _optional_old_regions.length(), total_prediction_ms);\n+                            num_regions_selected, optional_regions_count, total_prediction_ms);\n+  return num_regions_selected;\n@@ -602,3 +643,4 @@\n-void G1CollectionSet::prepare_optional_regions(G1CollectionCandidateRegionList* regions){\n-  uint cur_index = 0;\n-  for (G1HeapRegion* r : *regions) {\n+void G1CollectionSet::prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n+\n@@ -609,1 +651,0 @@\n-\n@@ -614,5 +655,3 @@\n-void G1CollectionSet::move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n+void G1CollectionSet::add_group_to_collection_set(G1CSetCandidateGroup* gr) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n@@ -620,4 +659,3 @@\n-  for (G1HeapRegion* r : *regions) {\n-    assert(r->has_pinned_objects(), \"must be pinned\");\n-    assert(r->rem_set()->is_complete(), \"must be complete\");\n-    candidates()->add_retained_region_unsorted(r);\n+    r->uninstall_group_cardset();\n+    r->rem_set()->set_state_complete();\n+    add_region_to_collection_set(r);\n@@ -625,1 +663,1 @@\n-  candidates()->sort_by_efficiency();\n+  _collection_set_groups.append(gr);\n@@ -628,10 +666,4 @@\n-void G1CollectionSet::drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n-\n-  \/\/ We can now drop these region's remembered sets.\n-  for (G1HeapRegion* r : *regions) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n+void G1CollectionSet::add_region_to_collection_set(G1HeapRegion* r) {\n+  _g1h->clear_region_attr(r);\n+  assert(r->rem_set()->is_complete(), \"Remset for region %u complete\", r->hrm_index());\n+  add_old_region(r);\n@@ -648,7 +680,1 @@\n-  G1CollectionCandidateRegionList selected_regions;\n-  select_candidates_from_optional_regions(remaining_pause_time,\n-                                          &selected_regions);\n-\n-  move_candidates_to_collection_set(&selected_regions);\n-\n-  _optional_old_regions.remove_prefix(&selected_regions);\n+  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n@@ -656,0 +682,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -660,1 +687,1 @@\n-  return selected_regions.length() > 0;\n+  return num_regions_selected > 0;\n@@ -664,7 +691,13 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    pss->record_unused_optional_region(r);\n-    \/\/ Clear collection set marker and make sure that the remembered set information\n-    \/\/ is correct as we still need it later.\n-    _g1h->clear_region_attr(r);\n-    _g1h->register_region_with_region_attr(r);\n-    r->clear_index_in_opt_cset();\n+  if (_optional_groups.length() > 0) {\n+    auto reset = [&] (G1HeapRegion* r) {\n+      pss->record_unused_optional_region(r);\n+      \/\/ Clear collection set marker and make sure that the remembered set information\n+      \/\/ is correct as we still need it later.\n+      _g1h->clear_region_attr(r);\n+      _g1h->register_region_with_region_attr(r);\n+      r->clear_index_in_opt_cset();\n+    };\n+\n+    _optional_groups.iterate(reset);\n+    \/\/ Remove groups from list without deleting the groups or clearing the associated cardsets.\n+    _optional_groups.remove_selected(_optional_groups.length(), _optional_groups.num_regions());\n@@ -672,1 +705,0 @@\n-  _optional_old_regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":191,"deletions":159,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -149,0 +149,8 @@\n+  \/\/ Old gen groups selected for evacuation.\n+  G1CSetCandidateGroupList _collection_set_groups;\n+\n+  \/\/ Groups are added to the collection set in increments when performing optional evacuations.\n+  \/\/ We use the value below to track these increments.\n+  uint _selected_groups_cur_length;\n+  uint _selected_groups_inc_part_start;\n+\n@@ -155,1 +163,1 @@\n-  G1CollectionCandidateRegionList _optional_old_regions;\n+  G1CSetCandidateGroupList _optional_groups;\n@@ -176,10 +184,14 @@\n-  void move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions);\n-  \/\/ Prepares old regions in the given set for optional collection later. Does not\n-  \/\/ add the region to collection set yet.\n-  void prepare_optional_regions(G1CollectionCandidateRegionList* regions);\n-  \/\/ Moves given old regions from the marking candidates to the retained candidates.\n-  \/\/ This makes sure that marking candidates will not remain there to unnecessarily\n-  \/\/ prolong the mixed phase.\n-  void move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions);\n-  \/\/ Removes the given list of regions from the retained candidates.\n-  void drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions);\n+  void prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index);\n+\n+  void add_group_to_collection_set(G1CSetCandidateGroup* gr);\n+\n+  void add_region_to_collection_set(G1HeapRegion* r);\n+\n+  double select_candidates_from_marking(double time_remaining_ms);\n+\n+  void select_candidates_from_retained(double time_remaining_ms);\n+\n+  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number  of actually selected regions.\n+  uint select_optional_collection_set_regions(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n@@ -199,16 +211,0 @@\n-  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n-  \/\/ the given candidate list and the remaining time.\n-  \/\/ Returns the remaining time.\n-  double select_candidates_from_marking(double time_remaining_ms,\n-                                        G1CollectionCandidateRegionList* initial_old_regions,\n-                                        G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  void select_candidates_from_retained(double time_remaining_ms,\n-                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                       G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  \/\/ Calculate the number of optional regions from the given collection set candidates,\n-  \/\/ the remaining time and the maximum number of these regions.\n-  void select_candidates_from_optional_regions(double time_remaining_ms,\n-                                               G1CollectionCandidateRegionList* selected);\n-\n@@ -235,0 +231,5 @@\n+  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n+  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n+\n+  void prepare_groups_for_scan();\n+\n@@ -246,1 +247,3 @@\n-  uint optional_region_length() const { return _optional_old_regions.length(); }\n+  uint num_optional_regions() const { return _optional_groups.num_regions(); }\n+\n+  bool only_contains_young_regions() const { return (initial_old_region_length() + num_optional_regions()) == 0; }\n@@ -248,1 +251,2 @@\n-  bool only_contains_young_regions() const { return (initial_old_region_length() + optional_region_length()) == 0; }\n+  template <class CardOrRangeVisitor>\n+  inline void merge_cardsets_for_collection_groups(G1CollectedHeap* g1h, CardOrRangeVisitor& cl, uint worker_id, uint num_workers);\n@@ -258,1 +262,5 @@\n-  void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }\n+  void update_incremental_marker() {\n+    _inc_build_state = Active;\n+    _inc_part_start = _collection_set_cur_length;\n+    _selected_groups_inc_part_start = _selected_groups_cur_length;\n+  }\n@@ -271,0 +279,2 @@\n+  uint collection_groups_increment_length() const { return _selected_groups_cur_length - _selected_groups_inc_part_start; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+#define SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1HeapRegionRemSet.hpp\"\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CollectionSet::merge_cardsets_for_collection_groups(G1CollectedHeap* g1h, CardOrRangeVisitor& cl, uint worker_id, uint num_workers) {\n+  uint length = collection_groups_increment_length();\n+  uint offset =  _selected_groups_inc_part_start;\n+  if (length == 0) {\n+    return;\n+  }\n+\n+  uint start_pos = (worker_id * length) \/ num_workers;\n+  uint cur_pos = start_pos;\n+  uint count = 0;\n+  do {\n+    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    cur_pos++;\n+    count++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n+}\n+#endif \/* SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n@@ -32,4 +31,6 @@\n-G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2, mtGC) { }\n-\n-void G1CollectionCandidateList::set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos) {\n-  assert(_candidates.is_empty(), \"must be\");\n+G1CSetCandidateGroup::G1CSetCandidateGroup(G1CardSetConfiguration* config) :\n+  _candidates(4, mtGCCardSet),\n+  _card_set_mm(config, G1CollectedHeap::heap()->card_set_freelist_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _gc_efficiency(0.0)\n+{ }\n@@ -37,2 +38,3 @@\n-  GrowableArrayFromArray<G1CollectionSetCandidateInfo> a(candidate_infos, (int)num_infos);\n-  _candidates.appendAll(&a);\n+void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+  G1CollectionSetCandidateInfo c(hr, hr->calc_gc_efficiency());\n+  add(c);\n@@ -41,3 +43,6 @@\n-void G1CollectionCandidateList::append_unsorted(G1HeapRegion* r) {\n-  G1CollectionSetCandidateInfo c(r, r->calc_gc_efficiency());\n-  _candidates.append(c);\n+void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n+  G1HeapRegion* hr = hr_info._r;\n+  assert(!hr->is_young(), \"should be flagged as survivor region\");\n+\n+  _candidates.append(hr_info);\n+  hr->install_group_cardset(&_card_set);\n@@ -46,2 +51,10 @@\n-void G1CollectionCandidateList::sort_by_efficiency() {\n-  _candidates.sort(compare_gc_efficiency);\n+void G1CSetCandidateGroup::calculate_efficiency() {\n+  size_t reclaimable_bytes = 0;\n+  uint num_candidates = _candidates.length();\n+  for (uint i = 0; i < num_candidates; i++) {\n+    G1HeapRegion* hr = region_at(i);\n+    reclaimable_bytes += hr->reclaimable_bytes();\n+  }\n+\n+  double group_total_time_ms = predict_group_total_time_ms();\n+  _gc_efficiency = reclaimable_bytes \/ group_total_time_ms;\n@@ -50,2 +63,4 @@\n-void G1CollectionCandidateList::remove(G1CollectionCandidateRegionList* other) {\n-  guarantee((uint)_candidates.length() >= other->length(), \"must be\");\n+void G1CSetCandidateGroup::clear() {\n+  _card_set.clear();\n+  _candidates.clear();\n+}\n@@ -53,3 +68,5 @@\n-  if (other->length() == 0) {\n-    \/\/ Nothing to remove or nothing in the original set.\n-    return;\n+void G1CSetCandidateGroup::abandon() {\n+  for (G1CollectionSetCandidateInfo ci : _candidates) {\n+    G1HeapRegion* r = ci._r;\n+    r->uninstall_group_cardset();\n+    r->rem_set()->clear(true \/* only_cardset *\/);\n@@ -57,0 +74,2 @@\n+  clear();\n+}\n@@ -58,4 +77,2 @@\n-  \/\/ Create a list from scratch, copying over the elements from the candidate\n-  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n-  int new_length = _candidates.length() - other->length();\n-  GrowableArray<G1CollectionSetCandidateInfo> new_list(new_length, mtGC);\n+double G1CSetCandidateGroup::predict_group_total_time_ms() const {\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n@@ -63,1 +80,3 @@\n-  uint other_idx = 0;\n+  double predicted_copy_time_ms = 0.0;\n+  double predict_code_root_scan_time_ms = 0.0;\n+  size_t predict_bytes_to_copy = 0.0;\n@@ -65,6 +84,7 @@\n-  for (uint candidate_idx = 0; candidate_idx < (uint)_candidates.length(); candidate_idx++) {\n-    if ((other_idx == other->length()) || _candidates.at(candidate_idx)._r != other->at(other_idx)) {\n-      new_list.append(_candidates.at(candidate_idx));\n-    } else {\n-      other_idx++;\n-    }\n+  for (G1CollectionSetCandidateInfo ci : _candidates) {\n+    G1HeapRegion* r = ci._r;\n+    assert(r->rem_set()->card_set() == &_card_set, \"Must be!\");\n+\n+    predict_bytes_to_copy += p->predict_bytes_to_copy(r);\n+    predicted_copy_time_ms += p->predict_region_copy_time_ms(r, false \/* for_young_only_phase *\/);\n+    predict_code_root_scan_time_ms += p->predict_region_code_root_scan_time(r, false \/* for_young_only_phase *\/);\n@@ -72,1 +92,0 @@\n-  _candidates.swap(&new_list);\n@@ -74,3 +93,1 @@\n-  verify();\n-  assert(_candidates.length() == new_length, \"must be %u %u\", _candidates.length(), new_length);\n-}\n+  size_t card_rs_length = _card_set.occupied();\n@@ -78,3 +95,2 @@\n-void G1CollectionCandidateList::clear() {\n-  _candidates.clear();\n-}\n+  double merge_scan_time_ms = p->predict_merge_scan_time(card_rs_length);\n+  double non_young_other_time_ms = p->predict_non_young_other_time_ms(length());\n@@ -82,14 +98,8 @@\n-#ifndef PRODUCT\n-void G1CollectionCandidateList::verify() {\n-  G1CollectionSetCandidateInfo* prev = nullptr;\n-\n-  for (uint i = 0; i < (uint)_candidates.length(); i++) {\n-    G1CollectionSetCandidateInfo& ci = _candidates.at(i);\n-    assert(prev == nullptr || prev->_gc_efficiency >= ci._gc_efficiency,\n-           \"Stored gc efficiency must be descending from region %u to %u\",\n-           prev->_r->hrm_index(), ci._r->hrm_index());\n-    prev = &ci;\n-    assert(ci._r->rem_set()->is_tracked(), \"remset for region %u must be tracked\", ci._r->hrm_index());\n-  }\n-}\n-#endif\n+  log_trace(gc, ergo, cset) (\"Prediction for group with %u regions, card_rs_length %zu, merge_scan_time %.2fms, code_root_scan_time_ms %.2fms, evac_time_ms %.2fms, other_time %.2fms, bytes_to_cop %zu\",\n+                             length(),\n+                             card_rs_length,\n+                             merge_scan_time_ms,\n+                             predict_code_root_scan_time_ms,\n+                             predicted_copy_time_ms,\n+                             non_young_other_time_ms,\n+                             predict_bytes_to_copy);\n@@ -97,2 +107,5 @@\n-int G1CollectionCandidateList::compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n-  assert(ci1->_r != nullptr && ci2->_r != nullptr, \"Should not be!\");\n+  return merge_scan_time_ms +\n+         predict_code_root_scan_time_ms +\n+         predicted_copy_time_ms +\n+         non_young_other_time_ms;\n+}\n@@ -100,2 +113,3 @@\n-  double gc_eff1 = ci1->_gc_efficiency;\n-  double gc_eff2 = ci2->_gc_efficiency;\n+int G1CSetCandidateGroup::compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2) {\n+  double gc_eff1 = (*gr1)->gc_efficiency();\n+  double gc_eff2 = (*gr2)->gc_efficiency();\n@@ -112,1 +126,1 @@\n-int G1CollectionCandidateList::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CSetCandidateGroup::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -136,1 +150,8 @@\n-G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2, mtGC) { }\n+G1CSetCandidateGroupList::G1CSetCandidateGroupList() : _groups(8, mtGC), _num_regions(0) { }\n+\n+void G1CSetCandidateGroupList::append(G1CSetCandidateGroup* group) {\n+  assert(group->length() > 0, \"Do not add empty groups\");\n+  assert(!_groups.contains(group), \"Already added to list\");\n+  _groups.append(group);\n+  _num_regions += group->length();\n+}\n@@ -138,3 +159,2 @@\n-void G1CollectionCandidateRegionList::append(G1HeapRegion* r) {\n-  assert(!_regions.contains(r), \"must be\");\n-  _regions.append(r);\n+G1CSetCandidateGroup* G1CSetCandidateGroupList::at(uint index) {\n+  return _groups.at(index);\n@@ -143,7 +163,4 @@\n-void G1CollectionCandidateRegionList::remove_prefix(G1CollectionCandidateRegionList* other) {\n-#ifdef ASSERT\n-  \/\/ Check that the given list is a prefix of this list.\n-  int i = 0;\n-  for (G1HeapRegion* r : *other) {\n-    assert(_regions.at(i) == r, \"must be in order, but element %d is not\", i);\n-    i++;\n+void G1CSetCandidateGroupList::clear() {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->clear();\n+    delete gr;\n@@ -151,1 +168,26 @@\n-#endif\n+  _groups.clear();\n+  _num_regions = 0;\n+}\n+\n+void G1CSetCandidateGroupList::abandon() {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->abandon();\n+    delete gr;\n+  }\n+  _groups.clear();\n+  _num_regions = 0;\n+}\n+\n+void G1CSetCandidateGroupList::prepare_for_scan() {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->card_set()->reset_table_scanner();\n+  }\n+}\n+\n+void G1CSetCandidateGroupList::remove_selected(uint count, uint num_regions) {\n+  _groups.remove_till(count);\n+  _num_regions -= num_regions;\n+}\n+\n+void G1CSetCandidateGroupList::remove(G1CSetCandidateGroupList* other) {\n+  guarantee((uint)_groups.length() >= other->length(), \"Other should be a subset of this list\");\n@@ -154,0 +196,1 @@\n+    \/\/ Nothing to remove or nothing in the original set.\n@@ -156,1 +199,19 @@\n-  _regions.remove_till(other->length());\n+\n+  \/\/ Create a list from scratch, copying over the elements from the candidate\n+  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n+  int new_length = _groups.length() - other->length();\n+  _num_regions = num_regions() - other->num_regions();\n+  GrowableArray<G1CSetCandidateGroup*> new_list(new_length, mtGC);\n+\n+  uint other_idx = 0;\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    if (other_idx == other->length() || gr != other->at(other_idx)) {\n+      new_list.append(gr);\n+    } else {\n+      other_idx++;\n+    }\n+  }\n+  _groups.swap(&new_list);\n+\n+  verify();\n+  assert(_groups.length() == new_length, \"Must be\");\n@@ -159,2 +220,2 @@\n-G1HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n-  return _regions.at(index);\n+void G1CSetCandidateGroupList::sort_by_efficiency() {\n+  _groups.sort(G1CSetCandidateGroup::compare_gc_efficiency);\n@@ -163,2 +224,9 @@\n-void G1CollectionCandidateRegionList::clear() {\n-  _regions.clear();\n+#ifndef PRODUCT\n+void G1CSetCandidateGroupList::verify() const {\n+  G1CSetCandidateGroup* prev = nullptr;\n+\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    assert(prev == nullptr || prev->gc_efficiency() >= gr->gc_efficiency(),\n+           \"Stored gc efficiency must be descending\");\n+    prev = gr;\n+  }\n@@ -166,0 +234,1 @@\n+#endif\n@@ -168,2 +237,0 @@\n-  _marking_regions(),\n-  _retained_regions(),\n@@ -171,0 +238,2 @@\n+  _from_marking_groups(),\n+  _retained_groups(),\n@@ -177,0 +246,1 @@\n+  _from_marking_groups.clear();\n@@ -192,2 +262,2 @@\n-  _marking_regions.clear();\n-  _retained_regions.clear();\n+  _retained_groups.abandon();\n+  _from_marking_groups.abandon();\n@@ -201,4 +271,2 @@\n-  G1CollectionCandidateListIterator iter = _marking_regions.begin();\n-  for (; iter != _marking_regions.end(); ++iter) {\n-    G1HeapRegion* hr = (*iter)->_r;\n-    (*iter)->_gc_efficiency = hr->calc_gc_efficiency();\n+  for(G1CSetCandidateGroup* gr : _from_marking_groups){\n+    gr->calculate_efficiency();\n@@ -206,1 +274,1 @@\n-  _marking_regions.sort_by_efficiency();\n+  _from_marking_groups.sort_by_efficiency();\n@@ -208,1 +276,1 @@\n-  _marking_regions.verify();\n+  _from_marking_groups.verify();\n@@ -213,1 +281,4 @@\n-  assert(_marking_regions.length() == 0, \"must be empty before adding new ones\");\n+  if(num_infos == 0) {\n+    log_debug(gc, ergo, cset) (\"No regions selected from marking.\");\n+    return;\n+  }\n@@ -215,0 +286,1 @@\n+  assert(_from_marking_groups.length() == 0, \"must be empty at the start of a cycle\");\n@@ -217,1 +289,12 @@\n-  _marking_regions.set(candidate_infos, num_infos);\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  \/\/ During each Mixed GC, we must collect at least G1Policy::calc_min_old_cset_length regions to meet\n+  \/\/ the G1MixedGCCountTarget. For the first collection in a Mixed GC cycle, we can add all regions\n+  \/\/ required to meet this threshold to the same remset group. We are certain these will be collected in\n+  \/\/ the same MixedGC.\n+  uint group_limit = p->calc_min_old_cset_length(num_infos);\n+\n+  uint num_added_to_group = 0;\n+  G1CSetCandidateGroup* current = nullptr;\n+\n+  current = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+\n@@ -222,0 +305,13 @@\n+\n+    if (num_added_to_group == group_limit) {\n+      if (group_limit != G1CSetCandidateGroup::GROUP_SIZE) {\n+        group_limit = G1CSetCandidateGroup::GROUP_SIZE;\n+      }\n+\n+      _from_marking_groups.append(current);\n+\n+      current = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+      num_added_to_group = 0;\n+    }\n+    current->add(candidate_infos[i]);\n+    num_added_to_group++;\n@@ -223,0 +319,6 @@\n+\n+  _from_marking_groups.append(current);\n+\n+  assert(_from_marking_groups.num_regions() == num_infos, \"Must be!\");\n+\n+  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_infos);\n@@ -231,3 +333,3 @@\n-  _marking_regions.verify();\n-  _retained_regions.sort_by_efficiency();\n-  _retained_regions.verify();\n+  _from_marking_groups.verify();\n+  _retained_groups.sort_by_efficiency();\n+  _retained_groups.verify();\n@@ -236,7 +338,1 @@\n-void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n-  assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n-  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n-  _retained_regions.append_unsorted(r);\n-}\n-\n-void G1CollectionSetCandidates::remove(G1CollectionCandidateRegionList* other) {\n+void G1CollectionSetCandidates::remove(G1CSetCandidateGroupList* other) {\n@@ -249,2 +345,3 @@\n-  G1CollectionCandidateRegionList other_marking_regions;\n-  G1CollectionCandidateRegionList other_retained_regions;\n+  G1CSetCandidateGroupList other_marking_groups;\n+  G1CSetCandidateGroupList other_retained_groups;\n+\n@@ -252,1 +349,4 @@\n-  for (G1HeapRegion* r : *other) {\n+  for (G1CSetCandidateGroup* group : *other) {\n+    assert(group->length() > 0, \"Should not have empty groups\");\n+    \/\/ Regions in the same group have the same source (i.e from_marking or retained).\n+    G1HeapRegion* r = group->region_at(0);\n@@ -254,1 +354,1 @@\n-      other_marking_regions.append(r);\n+      other_marking_groups.append(group);\n@@ -256,1 +356,1 @@\n-      other_retained_regions.append(r);\n+      other_retained_groups.append(group);\n@@ -260,2 +360,2 @@\n-  _marking_regions.remove(&other_marking_regions);\n-  _retained_regions.remove(&other_retained_regions);\n+  _from_marking_groups.remove(&other_marking_groups);\n+  _retained_groups.remove(&other_retained_groups);\n@@ -263,2 +363,2 @@\n-  for (G1HeapRegion* r : *other) {\n-    assert(contains(r), \"must contain region %u\", r->hrm_index());\n+  other->iterate([&] (G1HeapRegion* r) {\n+    assert(contains(r), \"Must contain region %u\", r->hrm_index());\n@@ -266,1 +366,1 @@\n-  }\n+  });\n@@ -271,0 +371,10 @@\n+void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n+  assert(!contains(r), \"Must not already contain region %u\", r->hrm_index());\n+  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n+\n+  G1CSetCandidateGroup* gr = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+  gr->add(r);\n+\n+  _retained_groups.append(gr);\n+}\n+\n@@ -280,1 +390,1 @@\n-  return _marking_regions.length();\n+  return _from_marking_groups.num_regions();\n@@ -284,1 +394,1 @@\n-  return _retained_regions.length();\n+  return _retained_groups.num_regions();\n@@ -288,1 +398,1 @@\n-void G1CollectionSetCandidates::verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) {\n+void G1CollectionSetCandidates::verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) {\n@@ -291,2 +401,3 @@\n-  for (uint i = 0; i < (uint)list->length(); i++) {\n-    G1HeapRegion* r = list->at(i)._r;\n+  for (G1CSetCandidateGroup* gr : *list) {\n+    for (G1CollectionSetCandidateInfo ci : *gr) {\n+      G1HeapRegion* r = ci._r;\n@@ -294,7 +405,7 @@\n-    if (is_from_marking(r)) {\n-      from_marking++;\n-    }\n-    const uint hrm_index = r->hrm_index();\n-    assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n-           \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n-    assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n+      if (is_from_marking(r)) {\n+        from_marking++;\n+      }\n+      const uint hrm_index = r->hrm_index();\n+      assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n+            \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n+      assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n@@ -302,1 +413,2 @@\n-    verify_map[hrm_index] = CandidateOrigin::Verify;\n+      verify_map[hrm_index] = CandidateOrigin::Verify;\n+    }\n@@ -314,1 +426,1 @@\n-  verify_helper(&_marking_regions, from_marking, verify_map);\n+  verify_helper(&_from_marking_groups, from_marking, verify_map);\n@@ -318,1 +430,1 @@\n-  verify_helper(&_retained_regions, from_marking_retained, verify_map);\n+  verify_helper(&_retained_groups, from_marking_retained, verify_map);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":230,"deletions":118,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"utilities\/bitMap.hpp\"\n@@ -36,1 +35,0 @@\n-class G1CollectionCandidateList;\n@@ -38,0 +36,1 @@\n+class G1CSetCandidateGroupList;\n@@ -41,27 +40,0 @@\n-using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<G1HeapRegion*>;\n-\n-\/\/ A set of G1HeapRegion*, a thin wrapper around GrowableArray.\n-class G1CollectionCandidateRegionList {\n-  GrowableArray<G1HeapRegion*> _regions;\n-\n-public:\n-  G1CollectionCandidateRegionList();\n-\n-  \/\/ Append a G1HeapRegion to the end of this list. The region must not be in the list\n-  \/\/ already.\n-  void append(G1HeapRegion* r);\n-  \/\/ Remove the given list of G1HeapRegion* from this list. The given list must be a prefix\n-  \/\/ of this list.\n-  void remove_prefix(G1CollectionCandidateRegionList* list);\n-\n-  \/\/ Empty contents of the list.\n-  void clear();\n-\n-  G1HeapRegion* at(uint index);\n-\n-  uint length() const { return (uint)_regions.length(); }\n-\n-  G1CollectionCandidateRegionListIterator begin() const { return _regions.begin(); }\n-  G1CollectionCandidateRegionListIterator end() const { return _regions.end(); }\n-};\n-\n@@ -82,3 +54,1 @@\n-class G1CollectionCandidateListIterator : public StackObj {\n-  G1CollectionCandidateList* _which;\n-  uint _position;\n+using G1CSetCandidateGroupIterator = GrowableArrayIterator<G1CollectionSetCandidateInfo>;\n@@ -86,5 +56,2 @@\n-public:\n-  G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position);\n-\n-  G1CollectionCandidateListIterator& operator++();\n-  G1CollectionSetCandidateInfo* operator*();\n+class G1CSetCandidateGroup : public CHeapObj<mtGCCardSet>{\n+  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n@@ -92,3 +59,1 @@\n-  bool operator==(const G1CollectionCandidateListIterator& rhs);\n-  bool operator!=(const G1CollectionCandidateListIterator& rhs);\n-};\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -96,4 +61,2 @@\n-\/\/ List of collection set candidates (regions with their efficiency) ordered by\n-\/\/ decreasing gc efficiency.\n-class G1CollectionCandidateList : public CHeapObj<mtGC> {\n-  friend class G1CollectionCandidateListIterator;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -101,1 +64,2 @@\n-  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n+  \/\/\n+  double _gc_efficiency;\n@@ -104,17 +68,4 @@\n-  G1CollectionCandidateList();\n-\n-  \/\/ Put the given set of candidates into this list, preserving the efficiency ordering.\n-  void set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos);\n-  \/\/ Add the given G1HeapRegion to this list at the end, (potentially) making the list unsorted.\n-  void append_unsorted(G1HeapRegion* r);\n-  \/\/ Restore sorting order by decreasing gc efficiency, using the existing efficiency\n-  \/\/ values.\n-  void sort_by_efficiency();\n-  \/\/ Removes any heap regions stored in this list also in the other list. The other\n-  \/\/ list may only contain regions in this list, sorted by gc efficiency. It need\n-  \/\/ not be a prefix of this list. Returns the number of regions removed.\n-  \/\/ E.g. if this list is \"A B G H\", the other list may be \"A G H\", but not \"F\" (not in\n-  \/\/ this list) or \"A H G\" (wrong order).\n-  void remove(G1CollectionCandidateRegionList* other);\n-\n-  void clear();\n+  G1CSetCandidateGroup(G1CardSetConfiguration* config);\n+  ~G1CSetCandidateGroup() {\n+    assert(length() == 0, \"post condition!\");\n+  }\n@@ -122,1 +73,2 @@\n-  G1CollectionSetCandidateInfo& at(uint position) { return _candidates.at(position); }\n+  void add(G1HeapRegion* hr);\n+  void add(G1CollectionSetCandidateInfo& hr_info);\n@@ -126,1 +78,3 @@\n-  void verify() PRODUCT_RETURN;\n+  G1CardSet* card_set() { return &_card_set; }\n+\n+  void calculate_efficiency();\n@@ -131,1 +85,1 @@\n-  static int compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+  static int compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2);\n@@ -135,2 +89,10 @@\n-  G1CollectionCandidateListIterator begin() {\n-    return G1CollectionCandidateListIterator(this, 0);\n+  double gc_efficiency() { return _gc_efficiency; }\n+\n+  G1HeapRegion* region_at(uint i) const { return _candidates.at(i)._r; }\n+\n+  G1CollectionSetCandidateInfo* at(uint i) { return &_candidates.at(i); }\n+\n+  double predict_group_total_time_ms() const;\n+\n+  G1MonotonicArenaMemoryStats card_set_memory_stats() const {\n+    return _card_set_mm.memory_stats();\n@@ -139,2 +101,10 @@\n-  G1CollectionCandidateListIterator end() {\n-    return G1CollectionCandidateListIterator(this, length());\n+  void clear();\n+\n+  void abandon();\n+\n+  G1CSetCandidateGroupIterator begin() const {\n+    return _candidates.begin();\n+  }\n+\n+  G1CSetCandidateGroupIterator end() const {\n+    return _candidates.end();\n@@ -142,0 +112,5 @@\n+\n+  \/\/ Limit to the number regions in a collection group. We make an exception\n+  \/\/ for the first collection group to be as large as G1Policy::calc_min_old_cset_length\n+  \/\/ because we are certain that these regions have to be collected together.\n+  static const int GROUP_SIZE = 5;\n@@ -144,5 +119,0 @@\n-\/\/ Iterator for G1CollectionSetCandidates. There are no guarantees on the order\n-\/\/ of the regions returned.\n-class G1CollectionSetCandidatesIterator : public StackObj {\n-  G1CollectionSetCandidates* _which;\n-    uint _position;\n@@ -150,2 +120,22 @@\n-  public:\n-  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position);\n+using G1CSetCandidateGroupListIterator = GrowableArrayIterator<G1CSetCandidateGroup*>;\n+\n+class G1CSetCandidateGroupList {\n+  GrowableArray<G1CSetCandidateGroup*> _groups;\n+  volatile uint _num_regions;\n+\n+public:\n+  G1CSetCandidateGroupList();\n+  void append(G1CSetCandidateGroup* group);\n+\n+  \/\/ Empty contents of the list.\n+  void clear();\n+\n+  void abandon();\n+\n+  G1CSetCandidateGroup* at(uint index);\n+\n+  uint length() const { return (uint)_groups.length(); }\n+\n+  uint num_regions() const { return _num_regions; }\n+\n+  void remove_selected(uint count, uint num_regions);\n@@ -153,2 +143,1 @@\n-  G1CollectionSetCandidatesIterator& operator++();\n-  G1HeapRegion* operator*();\n+  void remove(G1CSetCandidateGroupList* other);\n@@ -156,2 +145,20 @@\n-  bool operator==(const G1CollectionSetCandidatesIterator& rhs);\n-  bool operator!=(const G1CollectionSetCandidatesIterator& rhs);\n+  void prepare_for_scan();\n+\n+  void sort_by_efficiency();\n+\n+  GrowableArray<G1CSetCandidateGroup*>*  groups() {\n+    return &_groups;\n+  }\n+\n+  void verify() const PRODUCT_RETURN;\n+\n+  G1CSetCandidateGroupListIterator begin() const {\n+    return _groups.begin();\n+  }\n+\n+  G1CSetCandidateGroupListIterator end() const {\n+    return _groups.end();\n+  }\n+\n+  template<typename Func>\n+  void iterate(Func&& f) const;\n@@ -175,1 +182,0 @@\n-  friend class G1CollectionSetCandidatesIterator;\n@@ -184,3 +190,0 @@\n-  G1CollectionCandidateList _marking_regions;  \/\/ Set of regions selected by concurrent marking.\n-  G1CollectionCandidateList _retained_regions; \/\/ Set of regions selected from evacuation failed regions.\n-\n@@ -188,0 +191,2 @@\n+  G1CSetCandidateGroupList _from_marking_groups; \/\/ Set of regions selected by concurrent marking.\n+  G1CSetCandidateGroupList _retained_groups; \/\/ Set of regions retained due to evacuation failure.\n@@ -199,2 +204,2 @@\n-  G1CollectionCandidateList& marking_regions() { return _marking_regions; }\n-  G1CollectionCandidateList& retained_regions() { return _retained_regions; }\n+  G1CSetCandidateGroupList& from_marking_groups() { return _from_marking_groups; }\n+  G1CSetCandidateGroupList& retained_groups() { return _retained_groups; }\n@@ -222,1 +227,1 @@\n-  \/\/ Remove the given regions from the candidates. All given regions must be part\n+  \/\/ Remove the given groups from the candidates. All given regions must be part\n@@ -224,1 +229,1 @@\n-  void remove(G1CollectionCandidateRegionList* other);\n+  void remove(G1CSetCandidateGroupList* other);\n@@ -237,1 +242,1 @@\n-  void verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n+  void verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n@@ -244,8 +249,2 @@\n-  \/\/ Iteration\n-  G1CollectionSetCandidatesIterator begin() {\n-    return G1CollectionSetCandidatesIterator(this, 0);\n-  }\n-\n-  G1CollectionSetCandidatesIterator end() {\n-    return G1CollectionSetCandidatesIterator(this, length());\n-  }\n+  template<typename Func>\n+  void iterate_regions(Func&& f) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":97,"deletions":98,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -32,38 +32,7 @@\n-inline G1CollectionCandidateListIterator::G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position) :\n-  _which(which), _position(position) { }\n-\n-inline G1CollectionCandidateListIterator& G1CollectionCandidateListIterator::operator++() {\n-  assert(_position < _which->length(), \"must be\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1CollectionSetCandidateInfo* G1CollectionCandidateListIterator::operator*() {\n-  return &_which->_candidates.at(_position);\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator==(const G1CollectionCandidateListIterator& rhs) {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator!=(const G1CollectionCandidateListIterator& rhs) {\n-  return !(*this == rhs);\n-}\n-\n-inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position) :\n-  _which(which), _position(position) {\n-}\n-\n-inline G1CollectionSetCandidatesIterator& G1CollectionSetCandidatesIterator::operator++() {\n-  assert(_position < _which->length(), \"must not be at end already\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n-  uint length = _which->marking_regions_length();\n-  if (_position < length) {\n-    return _which->_marking_regions.at(_position)._r;\n-  } else {\n-    return _which->_retained_regions.at(_position - length)._r;\n+template<typename Func>\n+void G1CSetCandidateGroupList::iterate(Func&& f) const {\n+  for (G1CSetCandidateGroup* group : _groups) {\n+    for (G1CollectionSetCandidateInfo ci : *group) {\n+      G1HeapRegion* r = ci._r;\n+      f(r);\n+    }\n@@ -73,4 +42,3 @@\n-inline bool G1CollectionSetCandidatesIterator::operator==(const G1CollectionSetCandidatesIterator& rhs)  {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n+template<typename Func>\n+void G1CollectionSetCandidates::iterate_regions(Func&& f) const {\n+  _from_marking_groups.iterate(f);\n@@ -78,2 +46,1 @@\n-inline bool G1CollectionSetCandidatesIterator::operator!=(const G1CollectionSetCandidatesIterator& rhs)  {\n-  return !(*this == rhs);\n+  _retained_groups.iterate(f);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":11,"deletions":44,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare_reclaimble_bytes);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CSetCandidateGroup::compare_reclaimble_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  if (is_young() || is_free()) {\n+    return -1.0;\n+  }\n@@ -604,1 +607,3 @@\n-      if (_from != _to && !_from->is_young() && _to->rem_set()->is_complete()) {\n+      if (_from != _to && !_from->is_young() &&\n+          _to->rem_set()->is_complete() &&\n+          _from->rem_set()->card_set() != _to->rem_set()->card_set()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -153,1 +153,5 @@\n-    to_rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->card_set() != to_rem_set->card_set()) {\n+      to_rem_set->add_reference(p, _worker_id);\n+    }\n@@ -271,1 +275,5 @@\n-    rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->card_set() != rem_set->card_set()) {\n+      rem_set->add_reference(p, _worker_id);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    _max_num_optional_regions(collection_set->optional_region_length()),\n+    _max_num_optional_regions(collection_set->num_optional_regions()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-                                     candidates()->marking_regions_length());\n+                                     candidates()->from_marking_groups().num_regions());\n@@ -494,3 +494,1 @@\n-  for (G1CollectionSetCandidateInfo* ci : candidates()->marking_regions()) {\n-    \/\/ We optimistically assume that any of these marking candidate regions will\n-    \/\/ not be pinned, so just consider them as normal.\n+  for (G1CSetCandidateGroup* gr : candidates()->from_marking_groups()) {\n@@ -500,2 +498,2 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(ci->_r, false \/* for_young_only_phase *\/);\n-    min_marking_candidates--;\n+    predicted_region_evac_time_ms += gr->predict_group_total_time_ms();\n+    min_marking_candidates = min_marking_candidates > gr->length() ? (min_marking_candidates - gr->length()) : 0;\n@@ -527,1 +525,1 @@\n-  G1CollectionCandidateList& list = candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -529,1 +527,1 @@\n-                               list.length());\n+                               retained_groups->num_regions());\n@@ -531,2 +529,3 @@\n-  for (G1CollectionSetCandidateInfo* ci : list) {\n-    G1HeapRegion* r = ci->_r;\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"We should only have one region in a retained group\");\n+    G1HeapRegion* r = group->region_at(0); \/\/ We only have one region per group.\n@@ -548,1 +547,1 @@\n-                            num_regions, list.length(), num_pinned_regions, result);\n+                            num_regions, retained_groups->num_regions(), num_pinned_regions, result);\n@@ -1115,0 +1114,4 @@\n+double G1Policy::predict_non_young_other_time_ms(uint count) const {\n+  return _analytics->predict_non_young_other_time_ms(count);\n+}\n+\n@@ -1132,0 +1135,1 @@\n+  assert(!hr->is_young(), \"Sanity Check!\");\n@@ -1140,0 +1144,8 @@\n+double G1Policy::predict_merge_scan_time(size_t card_rs_length)  const {\n+  size_t scan_card_num = _analytics->predict_scan_card_num(card_rs_length, false);\n+\n+  return\n+    _analytics->predict_card_merge_time_ms(card_rs_length, false) +\n+    _analytics->predict_card_scan_time_ms(scan_card_num, false);\n+}\n+\n@@ -1343,5 +1355,0 @@\n-  \/\/ Clear remembered sets of remaining candidate regions and the actual candidate\n-  \/\/ set.\n-  for (G1HeapRegion* r : *candidates()) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class G1CollectionCandidateList;\n@@ -52,1 +51,0 @@\n-class G1CollectionCandidateRegionList;\n@@ -143,1 +141,0 @@\n-private:\n@@ -159,2 +156,1 @@\n-public:\n-\n+  double predict_merge_scan_time(size_t card_rs_length) const;\n@@ -163,0 +159,1 @@\n+  double predict_non_young_other_time_ms(uint count) const;\n@@ -250,1 +247,0 @@\n-  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n@@ -255,0 +251,1 @@\n+  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -1395,0 +1396,2 @@\n+        g1h->collection_set()->merge_cardsets_for_collection_groups(g1h, merge, worker_id, _num_workers);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                                              collection_set()->optional_region_length());\n+                                              collection_set()->num_optional_regions());\n@@ -300,0 +300,1 @@\n+        guarantee(!hr->rem_set()->has_group_cardset(), \"double adding\");\n@@ -776,1 +777,1 @@\n-  while (!evacuation_alloc_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_alloc_failed() && collection_set()->num_optional_regions() > 0) {\n@@ -784,1 +785,1 @@\n-                                collection_set()->optional_region_length(), time_left_ms);\n+                                collection_set()->num_optional_regions(), time_left_ms);\n@@ -975,1 +976,1 @@\n-  for (G1HeapRegion* r : *candidates) {\n+  candidates->iterate_regions([&] (G1HeapRegion* r) {\n@@ -977,1 +978,1 @@\n-  }\n+  });\n@@ -1091,1 +1092,1 @@\n-    bool may_do_optional_evacuation = collection_set()->optional_region_length() != 0;\n+    bool may_do_optional_evacuation = collection_set()->num_optional_regions() != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -109,2 +109,6 @@\n-    for (G1HeapRegion* r : *candidates) {\n-      _total.add(r->rem_set()->card_set_memory_stats());\n+    for (G1CSetCandidateGroup* gr : candidates->from_marking_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n+    }\n+\n+    for (G1CSetCandidateGroup* gr : candidates->retained_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n@@ -620,1 +624,0 @@\n-  size_t _card_rs_length;      \/\/ (Card Set) Remembered set size\n@@ -630,1 +633,0 @@\n-      _card_rs_length(0),\n@@ -640,1 +642,0 @@\n-    _card_rs_length += other->_card_rs_length;\n@@ -656,1 +657,1 @@\n-    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n@@ -658,1 +659,2 @@\n-    policy->record_card_rs_length(_card_rs_length);\n+    \/\/ We only use young_rs_length statistics to estimate young regions length.\n+    policy->record_card_rs_length(young_rs_length);\n@@ -684,4 +686,0 @@\n-\n-  void account_card_rs_length(G1HeapRegion* r) {\n-    _card_rs_length += r->rem_set()->occupied();\n-  }\n@@ -809,2 +807,0 @@\n-      \/\/ We only use card_rs_length statistics to estimate young regions length.\n-      stats()->account_card_rs_length(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-    private int expectedMarkingSkipEvents;      \/\/ How many times has the region from the \"marking\" collection set candidate set been \"skipped\".\n@@ -53,1 +52,1 @@\n-    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"marking\" collection set candidate set been put into the collection set.\n+    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"retained\" collection set candidate set been put into the collection set.\n@@ -56,1 +55,0 @@\n-                      int expectedMarkingSkipEvents,\n@@ -62,1 +60,0 @@\n-        this.expectedMarkingSkipEvents = expectedMarkingSkipEvents;\n@@ -119,1 +116,1 @@\n-        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Marking|Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n+        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n@@ -125,22 +122,0 @@\n-        for (int i = 0; i < expectedMarkingSkipEvents; i++) {\n-            expectMoreMatches(skipDropMatcher, \"expectedMarkingSkipEvents\");\n-            curGC = expectIncreasingGC(skipDropMatcher);\n-\n-            Asserts.assertEQ(\"Marking\", skipDropMatcher.group(2), \"Expected \\\"Marking\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n-            updateOrCompareCurRegion(\"MarkingSkip\", Integer.parseInt(skipDropMatcher.group(3)));\n-            Asserts.assertEQ(\"Skipping\", skipDropMatcher.group(4), \"Expected \\\"Skipping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n-\n-            while (true) {\n-                if (!reclaimMatcher.find()) {\n-                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n-                }\n-                if (reclaimMatcher.group(2).equals(\"retained\")) {\n-                    continue;\n-                }\n-                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n-                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n-                    Asserts.assertEQ(actual, 1, \"Expected number of pinned to be 1 after marking skip but is \" + actual);\n-                    break;\n-                }\n-            }\n-        }\n@@ -235,5 +210,5 @@\n-        \/\/ younGCsBeforeUnpin, expectedMarkingSkipEvents, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n-        testPinnedEvacuation(1, 1, 0, 0, 0, 1);\n-        testPinnedEvacuation(2, 1, 1, 0, 0, 1);\n-        testPinnedEvacuation(3, 1, 2, 0, 0, 1);\n-        testPinnedEvacuation(4, 1, 2, 1, 0, 0);\n+        \/\/ younGCsBeforeUnpin, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n+        testPinnedEvacuation(1, 0, 0, 0, 1);\n+        testPinnedEvacuation(2, 1, 0, 0, 1);\n+        testPinnedEvacuation(3, 2, 0, 0, 1);\n+        testPinnedEvacuation(4, 2, 1, 0, 0);\n@@ -255,1 +230,0 @@\n-                                             int expectedMarkingSkipEvents,\n@@ -281,1 +255,0 @@\n-                                                    expectedMarkingSkipEvents,\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"}]}