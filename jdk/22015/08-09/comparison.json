{"files":[{"patch":"@@ -788,1 +788,2 @@\n-    assert(r->rem_set()->card_set() != this, \"must be\");\n+    assert(!r->rem_set()->is_added_to_cset_group() ||\n+           r->rem_set()->cset_group()->card_set() != this, \"Should not be sharing a cardset\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  G1CollectionSetCandidateInfo c(hr, hr->calc_gc_efficiency());\n+  G1CollectionSetCandidateInfo c(hr);\n@@ -92,1 +92,1 @@\n-    assert(r->rem_set()->card_set() == &_card_set, \"Must be!\");\n+    assert(r->rem_set()->cset_group() == this, \"Must be!\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  double _gc_efficiency;\n@@ -45,2 +44,2 @@\n-  G1CollectionSetCandidateInfo() : G1CollectionSetCandidateInfo(nullptr, 0.0) { }\n-  G1CollectionSetCandidateInfo(G1HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency), _num_unreclaimed(0) { }\n+  G1CollectionSetCandidateInfo() : G1CollectionSetCandidateInfo(nullptr) { }\n+  G1CollectionSetCandidateInfo(G1HeapRegion* r) : _r(r), _num_unreclaimed(0) { }\n@@ -97,0 +96,1 @@\n+  const G1CardSet* card_set() const { return &_card_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-      _data[idx] = CandidateInfo(hr, 0.0);\n+      _data[idx] = CandidateInfo(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3001,1 +3001,0 @@\n-  _young_cardset_bytes_per_region(0),\n@@ -3012,7 +3011,0 @@\n-  uint num_young_regions = g1h->young_regions_count();\n-  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n-\n-  if (num_young_regions > 0) {\n-    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n-  }\n-\n@@ -3067,1 +3059,0 @@\n-  double gc_eff          = r->calc_gc_efficiency();\n@@ -3071,2 +3062,2 @@\n-  uint cset_groud_gid     = r->rem_set()->cset_group()->group_id();\n-  FormatBuffer<16> gc_efficiency(\"\");\n+  double gc_eff           = -1.0;\n+  uint cset_groud_gid     = 0;\n@@ -3074,2 +3065,5 @@\n-  if (r->is_young()) {\n-    remset_bytes = _young_cardset_bytes_per_region;\n+  if (r->rem_set()->is_added_to_cset_group()) {\n+    if (r->rem_set()->cset_group()->length() == 1) {\n+      gc_eff = r->rem_set()->cset_group()->gc_efficiency();\n+    }\n+    cset_groud_gid = r->rem_set()->cset_group_id();\n@@ -3078,0 +3072,2 @@\n+  FormatBuffer<16> gc_efficiency(\"\");\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -976,2 +976,0 @@\n-  size_t _young_cardset_bytes_per_region;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,4 @@\n-  hr->uninstall_cset_group();\n+  if (!hr->is_humongous()) {\n+    hr->uninstall_cset_group();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,21 +141,0 @@\n-double G1HeapRegion::calc_gc_efficiency() {\n-  if (is_young() || is_free()) {\n-    return -1.0;\n-  }\n-  \/\/ GC efficiency is the ratio of how much space would be\n-  \/\/ reclaimed over how long we predict it would take to reclaim it.\n-  G1Policy* policy = G1CollectedHeap::heap()->policy();\n-\n-  \/\/ Retrieve a prediction of the elapsed time for this region for\n-  \/\/ a mixed gc because the region will only be evacuated during a\n-  \/\/ mixed gc.\n-  \/\/ If the region will be collected as part of a group, then we cannot\n-  \/\/ rely on the predition for this region.\n-  if (_rem_set->is_added_to_cset_group() && _rem_set->cset_group()->length() > 1) {\n-    return -1.0;\n-  } else {\n-    double region_elapsed_time_ms = policy->predict_region_total_time_ms(this, false \/* for_young_only_phase *\/);\n-    return (double)reclaimable_bytes() \/ region_elapsed_time_ms;\n-  }\n-}\n-\n@@ -204,0 +183,3 @@\n+  G1CSetCandidateGroup* cset_group = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+  cset_group->add(this);\n+\n@@ -224,0 +206,7 @@\n+  if (is_starts_humongous()) {\n+    G1CSetCandidateGroup* cset_group = _rem_set->cset_group();\n+    assert(cset_group != nullptr, \"pre-condition %u missing cardset\", hrm_index());\n+    uninstall_cset_group();\n+    cset_group->clear();\n+    delete cset_group;\n+  }\n@@ -263,1 +252,1 @@\n-  _rem_set = new G1HeapRegionRemSet(this, config);\n+  _rem_set = new G1HeapRegionRemSet(this);\n@@ -615,1 +604,1 @@\n-          _from->rem_set()->card_set() != _to->rem_set()->card_set()) {\n+          _from->rem_set()->cset_group() != _to->rem_set()->cset_group()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -492,2 +492,0 @@\n-  double calc_gc_efficiency();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  _cset_group = _default_cset_group;\n+  _cset_group = nullptr;\n@@ -60,2 +60,1 @@\n-G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr,\n-                                   G1CardSetConfiguration* config) :\n+G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr) :\n@@ -63,3 +62,1 @@\n-  _card_set_mm(config, G1CollectedHeap::heap()->card_set_freelist_pool()),\n-  _default_cset_group(new G1CSetCandidateGroup(config)),\n-  _cset_group(_default_cset_group),\n+  _cset_group(nullptr),\n@@ -71,1 +68,0 @@\n-  delete _default_cset_group;\n@@ -79,1 +75,0 @@\n-  assert(!is_added_to_cset_group(), \"pre-condition\");\n@@ -84,1 +79,6 @@\n-  card_set()->clear();\n+\n+  if (is_added_to_cset_group()) {\n+    card_set()->clear();\n+    assert(card_set()->occupied() == 0, \"Should be clear.\");\n+  }\n+\n@@ -90,1 +90,0 @@\n-  assert(occupied() == 0, \"Should be clear.\");\n@@ -95,1 +94,3 @@\n-  card_set()->reset_table_scanner();\n+  if (is_added_to_cset_group()) {\n+    card_set()->reset_table_scanner();\n+  }\n@@ -99,1 +100,2 @@\n-  return _card_set_mm.memory_stats();\n+  assert(is_added_to_cset_group(), \"pre-condition\");\n+  return cset_group()->card_set_memory_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-  G1CardSetMemoryManager _card_set_mm;\n-\n@@ -52,4 +50,0 @@\n-  \/\/ We maintain a _default_cset_group to handle special cases, such as humongous regions,\n-  \/\/ which are never added to collection set groups. This approach allows us to avoid using\n-  \/\/ nullptr guards before every use of _cset_group.\n-  G1CSetCandidateGroup* _default_cset_group;\n@@ -65,0 +59,10 @@\n+  G1CardSet* card_set() {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->card_set();\n+  }\n+\n+  const G1CardSet* card_set() const {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->card_set();\n+  }\n+\n@@ -66,1 +70,1 @@\n-  G1HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n+  G1HeapRegionRemSet(G1HeapRegion* hr);\n@@ -70,1 +74,1 @@\n-    return card_set()->is_empty();\n+    return !is_added_to_cset_group() || card_set()->is_empty();\n@@ -75,1 +79,1 @@\n-    assert(_cset_group == _default_cset_group, \"pre-condition\");\n+    assert(_cset_group == nullptr, \"pre-condition\");\n@@ -83,1 +87,1 @@\n-    return _cset_group != _default_cset_group;\n+    return _cset_group != nullptr;\n@@ -90,0 +94,9 @@\n+  const G1CSetCandidateGroup* cset_group() const {\n+    return _cset_group;\n+  }\n+\n+  uint cset_group_id() const {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->group_id();\n+  }\n+\n@@ -108,0 +121,1 @@\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n@@ -111,1 +125,0 @@\n-  G1CardSet* card_set() const { return _cset_group->card_set(); }\n@@ -157,10 +170,1 @@\n-    if (is_added_to_cset_group()) {\n-      return sizeof(G1HeapRegionRemSet) + code_roots_mem_size();\n-    }\n-    return card_set()->mem_size()\n-           + (sizeof(G1HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n-           + code_roots_mem_size();\n-  }\n-\n-  size_t unused_mem_size() {\n-    return card_set()->unused_mem_size();\n+    return sizeof(G1HeapRegionRemSet) + code_roots_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+  assert(is_added_to_cset_group(), \"pre-condition\");\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    if (from->rem_set()->card_set() != to_rem_set->card_set()) {\n+    if (from->rem_set()->cset_group() != to_rem_set->cset_group()) {\n@@ -277,1 +277,1 @@\n-    if (from->rem_set()->card_set() != rem_set->card_set()) {\n+    if (from->rem_set()->cset_group() != rem_set->cset_group()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -543,1 +543,1 @@\n-    result += predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    result += group->predict_group_total_time_ms();\n@@ -1135,10 +1135,1 @@\n-double G1Policy::predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const {\n-  size_t card_rs_length = hr->rem_set()->occupied();\n-  size_t scan_card_num = _analytics->predict_scan_card_num(card_rs_length, for_young_only_phase);\n-\n-  return\n-    _analytics->predict_card_merge_time_ms(card_rs_length, for_young_only_phase) +\n-    _analytics->predict_card_scan_time_ms(scan_card_num, for_young_only_phase);\n-}\n-\n-double G1Policy::predict_merge_scan_time(size_t card_rs_length)  const {\n+double G1Policy::predict_merge_scan_time(size_t card_rs_length) const {\n@@ -1159,21 +1150,0 @@\n-double G1Policy::predict_region_non_copy_time_ms(G1HeapRegion* hr,\n-                                                 bool for_young_only_phase) const {\n-\n-  double region_elapsed_time_ms = predict_region_merge_scan_time(hr, for_young_only_phase) +\n-                                  predict_region_code_root_scan_time(hr, for_young_only_phase);\n-  \/\/ The prediction of the \"other\" time for this region is based\n-  \/\/ upon the region type and NOT the GC type.\n-  if (hr->is_young()) {\n-    region_elapsed_time_ms += _analytics->predict_young_other_time_ms(1);\n-  } else {\n-    region_elapsed_time_ms += _analytics->predict_non_young_other_time_ms(1);\n-  }\n-  return region_elapsed_time_ms;\n-}\n-\n-double G1Policy::predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const {\n-  return\n-    predict_region_non_copy_time_ms(hr, for_young_only_phase) +\n-    predict_region_copy_time_ms(hr, for_young_only_phase);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":32,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -148,3 +148,0 @@\n-  \/\/ Merge-scan time for a region is handling card-based remembered sets of that region\n-  \/\/ (as a single unit).\n-  double predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -153,2 +150,0 @@\n-  \/\/ Non-copy time for a region is handling remembered sets and other time.\n-  double predict_region_non_copy_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -163,3 +158,0 @@\n-  \/\/ Total time for a region is handling remembered sets (as a single unit), copying its live data\n-  \/\/ and other time.\n-  double predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -195,0 +195,6 @@\n+  size_t _max_code_root_mem_sz;\n+  G1HeapRegion* _max_code_root_mem_sz_region;\n+\n+  size_t _max_group_cardset_mem_sz;\n+  G1CSetCandidateGroup* _max_cardset_mem_sz_group;\n+\n@@ -202,2 +208,2 @@\n-  size_t _max_code_root_mem_sz;\n-  G1HeapRegion* _max_code_root_mem_sz_region;\n+  size_t max_group_cardset_mem_sz() const                 { return _max_group_cardset_mem_sz; }\n+  G1CSetCandidateGroup* max_cardset_mem_sz_group() const  { return _max_cardset_mem_sz_group; }\n@@ -215,1 +221,2 @@\n-    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(nullptr)\n+    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(nullptr),\n+    _max_group_cardset_mem_sz(0), _max_cardset_mem_sz_group(nullptr)\n@@ -220,17 +227,17 @@\n-\n-    size_t occupied_cards = hrrs->occupied();\n-    \/\/ G1HeapRegionRemSet::mem_size() includes the\n-    \/\/ size of the code roots\n-    size_t rs_unused_mem_sz = hrrs->unused_mem_size();\n-    size_t rs_mem_sz = hrrs->mem_size();\n-\n-    if (r->is_young()) {\n-      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n-      occupied_cards \/= num_young;\n-      rs_unused_mem_sz \/= num_young;\n-      rs_mem_sz \/= num_young;\n-    }\n-\n-    if (rs_mem_sz > _max_rs_mem_sz) {\n-      _max_rs_mem_sz = rs_mem_sz;\n-      _max_rs_mem_sz_region = r;\n+    size_t rs_mem_sz = 0;\n+    size_t rs_unused_mem_sz = 0;\n+    size_t occupied_cards = 0;\n+\n+    \/\/ Accumulate card set details for regions that are assigned to single region\n+    \/\/ groups. G1HeapRegionRemSet::mem_size() includes the size of the code roots\n+    if (hrrs->is_added_to_cset_group() && hrrs->cset_group()->length() == 1) {\n+      G1CardSet* card_set = hrrs->cset_group()->card_set();\n+\n+      rs_mem_sz = hrrs->mem_size() + card_set->mem_size();\n+      rs_unused_mem_sz = card_set->unused_mem_size();\n+      occupied_cards = hrrs->occupied();\n+\n+      if (rs_mem_sz > _max_rs_mem_sz) {\n+        _max_rs_mem_sz = rs_mem_sz;\n+        _max_rs_mem_sz_region = r;\n+      }\n@@ -266,0 +273,41 @@\n+  void do_cset_groups() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n+\n+    \/\/ If the group has only a single region, then stats were accumulated\n+    \/\/ during region iteration.\n+    if (young_only_cset_group->length() > 1) {\n+      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n+      size_t rs_mem_sz = young_only_card_set->mem_size();\n+      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n+      size_t occupied_cards = young_only_card_set->occupied();\n+\n+      _max_group_cardset_mem_sz = rs_mem_sz;\n+      _max_cardset_mem_sz_group = young_only_cset_group;\n+\n+      \/\/ Only update cardset details\n+      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+    }\n+\n+\n+    RegionTypeCounter* current = &_old;\n+    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n+      if (group->length() > 1) {\n+        G1CardSet* group_card_set = group->card_set();\n+        size_t rs_mem_sz = group_card_set->mem_size();\n+        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n+        size_t occupied_cards = group_card_set->occupied();\n+\n+        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n+          _max_group_cardset_mem_sz = rs_mem_sz;\n+          _max_cardset_mem_sz_group = group;\n+        }\n+\n+        \/\/ Only update cardset details\n+        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+      }\n+    }\n+  }\n+\n@@ -285,7 +333,19 @@\n-    \/\/ Largest sized rem set region statistics\n-    G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n-    out->print_cr(\"    Region with largest rem set = \" HR_FORMAT \", \"\n-                  \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n-                  HR_FORMAT_PARAMS(max_rs_mem_sz_region()),\n-                  rem_set->mem_size(),\n-                  rem_set->occupied());\n+    \/\/ Largest sized single region rem set statistics\n+    if (max_rs_mem_sz_region() != nullptr) {\n+      G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+      out->print_cr(\"    Region with largest rem set = \" HR_FORMAT \", \"\n+                    \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n+                    HR_FORMAT_PARAMS(max_rs_mem_sz_region()),\n+                    rem_set->mem_size(),\n+                    rem_set->occupied());\n+    }\n+\n+    if (max_cardset_mem_sz_group() != nullptr) {\n+      G1CSetCandidateGroup* cset_group = max_cardset_mem_sz_group();\n+      G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+      out->print_cr(\"    Collectionset Candidate Group with largest cardset = %u:(%u regions), \"\n+                    \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n+                    cset_group->group_id(), cset_group->length(),\n+                    cset_group->card_set()->mem_size(),\n+                    cset_group->card_set()->occupied());\n+    }\n@@ -336,0 +396,1 @@\n+  blk.do_cset_groups();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":88,"deletions":27,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -108,0 +108,11 @@\n+\n+    size_t remset_bytes = r->rem_set()->mem_size();\n+    size_t occupied = 0;\n+    \/\/ per region cardset details only valid if group contains a single region.\n+    if (r->rem_set()->is_added_to_cset_group() &&\n+        r->rem_set()->cset_group()->length() == 1 ) {\n+        G1CardSet *card_set = r->rem_set()->cset_group()->card_set();\n+        remset_bytes += card_set->mem_size();\n+        occupied = card_set->occupied();\n+    }\n+\n@@ -117,2 +128,2 @@\n-                                    r->rem_set()->occupied(),\n-                                    r->rem_set()->mem_size());\n+                                    occupied,\n+                                    remset_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-        guarantee(!hr->rem_set()->is_added_to_cset_group(), \"Humongous regions should not have group card sets\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}