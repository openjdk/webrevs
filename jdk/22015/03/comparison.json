{"files":[{"patch":"@@ -783,0 +783,7 @@\n+\n+#ifdef ASSERT\n+  uint region_idx = card_region >> config()->log2_card_regions_per_heap_region();\n+  G1HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+  assert(r->rem_set()->card_set() != this, \"must be\");\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3057,0 +3057,2 @@\n+\n+  collection_set()->prepare_groups_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  assert(!r->has_pinned_objects(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -57,0 +57,3 @@\n+  _collection_set_groups(),\n+  _selected_groups_cur_length(0),\n+  _selected_groups_inc_part_start(0),\n@@ -60,1 +63,1 @@\n-  _optional_old_regions(),\n+  _optional_groups(),\n@@ -81,1 +84,2 @@\n-  _optional_old_regions.clear();\n+  assert(_optional_groups.length() == 0, \"Should not have any optional groups yet\");\n+  _optional_groups.clear();\n@@ -95,1 +99,4 @@\n-  _optional_old_regions.clear();\n+}\n+\n+void G1CollectionSet::prepare_groups_for_scan () {\n+  collection_set_groups()->prepare_for_scan();\n@@ -105,0 +112,2 @@\n+  assert(!hr->rem_set()->has_group_cardset(), \"Must not have a group remset\");\n+\n@@ -130,0 +139,1 @@\n+  _collection_set_groups.clear();\n@@ -155,1 +165,1 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n+  _optional_groups.iterate([&] (G1HeapRegion* r) {\n@@ -158,1 +168,1 @@\n-  }\n+  });\n@@ -287,1 +297,1 @@\n-  log_trace(gc, ergo, cset)(\"Start choosing CSet. Pending cards: \" SIZE_FORMAT \" target pause time: %1.2fms\",\n+  log_trace(gc, ergo, cset)(\"Start choosing CSet. Pending cards: %zu target pause time: %1.2fms\",\n@@ -324,13 +334,10 @@\n-\/\/ The current mechanism skips evacuation of pinned old regions like g1 does for\n-\/\/ young regions:\n-\/\/ * evacuating pinned marking collection set candidate regions (available during mixed\n-\/\/   gc) like young regions would not result in any memory gain but only take additional\n-\/\/   time away from processing regions that would actually result in memory being freed.\n-\/\/   To advance mixed gc progress (we committed to evacuate all marking collection set\n-\/\/   candidate regions within the maximum number of mixed gcs in the phase), move them\n-\/\/   to the optional collection set candidates to reclaim them asap as time permits.\n-\/\/ * evacuating out retained collection set candidates would also just take up time with\n-\/\/   no actual space freed in old gen. Better to concentrate on others.\n-\/\/   Retained collection set candidates are aged out, ie. made to regular old regions\n-\/\/   without remembered sets after a few attempts to save computation costs of keeping\n-\/\/   them candidates for very long living pinned regions.\n+\/\/ The current mechanism for evacuating pinned old regions is as below:\n+\/\/ * pinned regions in the marking collection set candidate list (available during mixed gc) are evacuated like\n+\/\/   pinned young regions to avoid the complexity of dealing with pinned regions that are part of a\n+\/\/   collection group sharing a single cardset. These regions will be partially evacuated and added to the\n+\/\/   retained collection set by the evacuation failure handling mechanism.\n+\/\/ * evacuating pinned regions out of retained collection set candidates would also just take up time\n+\/\/   with no actual space freed in old gen. Better to concentrate on others. So we skip over pinned\n+\/\/   regions in retained collection set candidates. Retained collection set candidates are aged out, ie.\n+\/\/   made to regular old regions without remembered sets after a few attempts to save computation costs\n+\/\/   of keeping them candidates for very long living pinned regions.\n@@ -340,0 +347,3 @@\n+  _selected_groups_cur_length = 0;\n+  _selected_groups_inc_part_start = 0;\n+\n@@ -343,5 +353,0 @@\n-    G1CollectionCandidateRegionList initial_old_regions;\n-    assert(_optional_old_regions.length() == 0, \"must be\");\n-    G1CollectionCandidateRegionList pinned_marking_regions;\n-    G1CollectionCandidateRegionList pinned_retained_regions;\n-\n@@ -349,3 +354,1 @@\n-      time_remaining_ms = select_candidates_from_marking(time_remaining_ms,\n-                                                         &initial_old_regions,\n-                                                         &pinned_marking_regions);\n+      time_remaining_ms = select_candidates_from_marking(time_remaining_ms);\n@@ -356,16 +359,3 @@\n-    select_candidates_from_retained(time_remaining_ms,\n-                                    &initial_old_regions,\n-                                    &pinned_retained_regions);\n-\n-    \/\/ Move initially selected old regions to collection set directly.\n-    move_candidates_to_collection_set(&initial_old_regions);\n-    \/\/ Only prepare selected optional regions for now.\n-    prepare_optional_regions(&_optional_old_regions);\n-    \/\/ Move pinned marking regions we came across to retained candidates so that\n-    \/\/ there is progress in the mixed gc phase.\n-    move_pinned_marking_to_retained(&pinned_marking_regions);\n-    \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n-    \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n-    \/\/ GCs and hence are considered \"long lived\".\n-    drop_pinned_retained_regions(&pinned_retained_regions);\n-\n+    if (candidates()->retained_groups().num_regions() > 0) {\n+      select_candidates_from_retained(time_remaining_ms);\n+    }\n@@ -377,0 +367,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -385,8 +376,0 @@\n-void G1CollectionSet::move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions) {\n-  for (G1HeapRegion* r : *regions) {\n-    _g1h->clear_region_attr(r);\n-    add_old_region(r);\n-  }\n-  candidates()->remove(regions);\n-}\n-\n@@ -398,3 +381,1 @@\n-double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms,\n-                                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                                       G1CollectionCandidateRegionList* pinned_old_regions) {\n+double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms) {\n@@ -402,4 +383,3 @@\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n+  uint num_inital_regions = 0;\n+  uint num_initial_groups = 0;\n+  uint num_optional_regions = 0;\n@@ -412,3 +392,2 @@\n-  const uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n-  const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n-  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n+  uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n+  uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n@@ -417,2 +396,1 @@\n-  G1CollectionCandidateList* marking_list = &candidates()->marking_regions();\n-  assert(marking_list != nullptr, \"must be\");\n+  G1CSetCandidateGroupList* from_marking_groups = &candidates()->from_marking_groups();\n@@ -421,1 +399,1 @@\n-                            \"Min %u regions, max %u regions, available %u regions\"\n+                            \"Min %u regions, max %u regions, available %u regions (%u groups), \"\n@@ -423,1 +401,2 @@\n-                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n+                            min_old_cset_length, max_old_cset_length, from_marking_groups->num_regions(), from_marking_groups->length(),\n+                            time_remaining_ms, optional_threshold_ms);\n@@ -425,3 +404,4 @@\n-  G1CollectionCandidateListIterator iter = marking_list->begin();\n-  for (; iter != marking_list->end(); ++iter) {\n-    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n+  G1CSetCandidateGroupList selected_groups;\n+\n+  for (G1CSetCandidateGroup* group : *from_marking_groups) {\n+    if (num_inital_regions + num_optional_regions >= max_old_cset_length) {\n@@ -432,13 +412,3 @@\n-    G1HeapRegion* hr = (*iter)->_r;\n-    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n-    \/\/ space from them (and we expect to get free space from marking candidates).\n-    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n-    \/\/ to not impact the mixed phase too much.\n-    if (hr->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      (*iter)->update_num_unreclaimed();\n-      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n-      pinned_old_regions->append(hr);\n-      continue;\n-    }\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(hr, false);\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n+\n@@ -447,3 +417,9 @@\n-    if (initial_old_regions->length() < min_old_cset_length) {\n-      initial_old_regions->append(hr);\n-      num_initial_regions_selected++;\n+    if (num_inital_regions < min_old_cset_length) {\n+\n+      num_initial_groups++;\n+\n+      add_group_to_collection_set(group);\n+      selected_groups.append(group);\n+\n+      num_inital_regions += group->length();\n+\n@@ -453,1 +429,1 @@\n-        num_expensive_regions++;\n+        num_expensive_regions += group->length();\n@@ -463,0 +439,7 @@\n+        num_initial_groups++;\n+\n+        add_group_to_collection_set(group);\n+        selected_groups.append(group);\n+\n+        num_inital_regions += group->length();\n+\n@@ -464,2 +447,1 @@\n-        initial_old_regions->append(hr);\n-        num_initial_regions_selected++;\n+\n@@ -468,1 +450,3 @@\n-        assert(_optional_old_regions.length() < max_optional_regions, \"Should not be possible.\");\n+        _optional_groups.append(group);\n+        prepare_optional_group(group, num_optional_regions);\n+        num_optional_regions += group->length();\n@@ -470,2 +454,0 @@\n-        _optional_old_regions.append(hr);\n-        num_optional_regions_selected++;\n@@ -478,1 +460,7 @@\n-  if (iter == marking_list->end()) {\n+\n+  \/\/ Remove selected groups from list of candidate groups.\n+  if (num_initial_groups > 0) {\n+    candidates()->remove(&selected_groups);\n+  }\n+\n+  if (from_marking_groups->length() == 0) {\n@@ -487,1 +475,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u regions (%u groups), optional: %u regions (%u groups), \"\n@@ -489,1 +477,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            selected_groups.num_regions(), selected_groups.length(), _optional_groups.num_regions(), _optional_groups.length(),\n@@ -492,2 +480,2 @@\n-  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n-  assert(_optional_old_regions.length() == num_optional_regions_selected, \"must be\");\n+  assert(selected_groups.num_regions() == num_inital_regions, \"must be\");\n+  assert(_optional_groups.num_regions() == num_optional_regions, \"must be\");\n@@ -497,6 +485,4 @@\n-void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms,\n-                                                      G1CollectionCandidateRegionList* initial_old_regions,\n-                                                      G1CollectionCandidateRegionList* pinned_old_regions) {\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_expensive_regions_selected = 0;\n+void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms) {\n+  uint num_initial_regions = 0;\n+  uint num_optional_regions = 0;\n+  uint num_expensive_regions = 0;\n@@ -517,1 +503,1 @@\n-  G1CollectionCandidateList* retained_list = &candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -520,1 +506,1 @@\n-                            \"Min %u regions, available %u, \"\n+                            \"Min %u regions, available %u regions (%u groups), \"\n@@ -522,1 +508,10 @@\n-                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n+                            min_regions, retained_groups->num_regions(), retained_groups->length(),\n+                            time_remaining_ms, optional_time_remaining_ms);\n+\n+  G1CSetCandidateGroupList remove_from_retained;\n+  G1CSetCandidateGroupList groups_to_abandon;\n+\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"Retained groups should have only 1 region\");\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -524,3 +519,0 @@\n-  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n-    G1HeapRegion* r = ci->_r;\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n@@ -528,0 +520,4 @@\n+\n+    G1CollectionSetCandidateInfo* ci = group->at(0); \/\/ We only have one region in the group.\n+    G1HeapRegion* r = ci->_r;\n+\n@@ -535,1 +531,6 @@\n-        pinned_old_regions->append(r);\n+        \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n+        \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n+        \/\/ GCs and hence are considered \"long lived\".\n+        _g1h->clear_region_attr(r);\n+        groups_to_abandon.append(group);\n+        remove_from_retained.append(group);\n@@ -540,1 +541,1 @@\n-    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+    if (fits_in_remaining_time || (num_expensive_regions < min_regions)) {\n@@ -543,1 +544,1 @@\n-        num_expensive_regions_selected++;\n+        num_expensive_regions++;\n@@ -545,2 +546,5 @@\n-      initial_old_regions->append(r);\n-      num_initial_regions_selected++;\n+\n+      add_group_to_collection_set(group);\n+      remove_from_retained.append(group);\n+\n+      num_initial_regions += group->length();\n@@ -548,0 +552,4 @@\n+      \/\/ Prepare optional collection region.\n+      _optional_groups.append(group);\n+      prepare_optional_group(group, num_optional_regions);\n+      num_optional_regions += group->length();\n@@ -549,2 +557,0 @@\n-      _optional_old_regions.append(r);\n-      num_optional_regions_selected++;\n@@ -559,2 +565,1 @@\n-  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n-  if (num_regions_selected == retained_list->length()) {\n+  if (num_initial_regions == retained_groups->num_regions()) {\n@@ -563,1 +568,2 @@\n-  if (num_expensive_regions_selected > 0) {\n+\n+  if (num_expensive_regions > 0) {\n@@ -565,1 +571,1 @@\n-                              num_expensive_regions_selected);\n+                              num_expensive_regions);\n@@ -568,0 +574,6 @@\n+  \/\/ Remove groups from retained and also do some bookkeeping on CandidateOrigin\n+  \/\/ for the regions in these groups.\n+  candidates()->remove(&remove_from_retained);\n+\n+  groups_to_abandon.clear(true \/* uninstall_group_cardset *\/);\n+\n@@ -571,1 +583,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            num_initial_regions, num_optional_regions, num_pinned_regions,\n@@ -575,3 +587,3 @@\n-void G1CollectionSet::select_candidates_from_optional_regions(double time_remaining_ms,\n-                                                              G1CollectionCandidateRegionList* selected_regions) {\n-  assert(optional_region_length() > 0,\n+double G1CollectionSet::select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected) {\n+\n+  assert(_optional_groups.num_regions() > 0,\n@@ -580,0 +592,1 @@\n+  uint num_groups_selected = 0;\n@@ -581,0 +594,3 @@\n+  G1CSetCandidateGroupList selected;\n+  for (G1CSetCandidateGroup* group : _optional_groups) {\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -582,6 +598,3 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    double prediction_ms = _policy->predict_region_total_time_ms(r, false);\n-\n-    if (prediction_ms > time_remaining_ms) {\n-      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n-                                prediction_ms, r->hrm_index(), time_remaining_ms);\n+    if (predicted_time_ms > time_remaining_ms) {\n+      log_debug(gc, ergo, cset)(\"Prediction %.3fms for group with %u regions does not fit remaining time: %.3fms.\",\n+                                predicted_time_ms, group->length(), time_remaining_ms);\n@@ -590,1 +603,0 @@\n-    \/\/ This region will be included in the next optional evacuation.\n@@ -592,2 +604,2 @@\n-    total_prediction_ms += prediction_ms;\n-    time_remaining_ms -= prediction_ms;\n+    total_prediction_ms += predicted_time_ms;\n+    time_remaining_ms -= predicted_time_ms;\n@@ -595,1 +607,5 @@\n-    selected_regions->append(r);\n+    num_regions_selected += group->length();\n+    num_groups_selected++;\n+\n+    add_group_to_collection_set(group);\n+    selected.append(group);\n@@ -598,0 +614,20 @@\n+  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  \/\/ Remove selected groups from candidate list.\n+  if (num_groups_selected > 0) {\n+    _optional_groups.remove(&selected);\n+    candidates()->remove(&selected);\n+  }\n+  return total_prediction_ms;\n+}\n+\n+uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+  uint optional_regions_count = num_optional_regions();\n+  assert(optional_regions_count > 0,\n+         \"Should only be called when there are optional regions\");\n+\n+  uint num_regions_selected = 0;\n+\n+  double total_prediction_ms = select_candidates_from_optional_groups(time_remaining_ms, num_regions_selected);\n+\n+  time_remaining_ms -= total_prediction_ms;\n+\n@@ -599,1 +635,2 @@\n-                            selected_regions->length(), _optional_old_regions.length(), total_prediction_ms);\n+                            num_regions_selected, optional_regions_count, total_prediction_ms);\n+  return num_regions_selected;\n@@ -602,3 +639,4 @@\n-void G1CollectionSet::prepare_optional_regions(G1CollectionCandidateRegionList* regions){\n-  uint cur_index = 0;\n-  for (G1HeapRegion* r : *regions) {\n+void G1CollectionSet::prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n+\n@@ -609,1 +647,0 @@\n-\n@@ -614,10 +651,6 @@\n-void G1CollectionSet::move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n-\n-  for (G1HeapRegion* r : *regions) {\n-    assert(r->has_pinned_objects(), \"must be pinned\");\n-    assert(r->rem_set()->is_complete(), \"must be complete\");\n-    candidates()->add_retained_region_unsorted(r);\n+void G1CollectionSet::add_group_to_collection_set(G1CSetCandidateGroup* gr) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n+    r->uninstall_group_cardset();\n+    r->rem_set()->set_state_complete();\n+    add_region_to_collection_set(r);\n@@ -625,1 +658,1 @@\n-  candidates()->sort_by_efficiency();\n+  _collection_set_groups.append(gr);\n@@ -628,10 +661,4 @@\n-void G1CollectionSet::drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n-\n-  \/\/ We can now drop these region's remembered sets.\n-  for (G1HeapRegion* r : *regions) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n+void G1CollectionSet::add_region_to_collection_set(G1HeapRegion* r) {\n+  _g1h->clear_region_attr(r);\n+  assert(r->rem_set()->is_complete(), \"Remset for region %u complete\", r->hrm_index());\n+  add_old_region(r);\n@@ -648,7 +675,1 @@\n-  G1CollectionCandidateRegionList selected_regions;\n-  select_candidates_from_optional_regions(remaining_pause_time,\n-                                          &selected_regions);\n-\n-  move_candidates_to_collection_set(&selected_regions);\n-\n-  _optional_old_regions.remove_prefix(&selected_regions);\n+  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n@@ -656,0 +677,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -660,1 +682,1 @@\n-  return selected_regions.length() > 0;\n+  return num_regions_selected > 0;\n@@ -664,7 +686,13 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    pss->record_unused_optional_region(r);\n-    \/\/ Clear collection set marker and make sure that the remembered set information\n-    \/\/ is correct as we still need it later.\n-    _g1h->clear_region_attr(r);\n-    _g1h->register_region_with_region_attr(r);\n-    r->clear_index_in_opt_cset();\n+  if (_optional_groups.length() > 0) {\n+    auto reset = [&] (G1HeapRegion* r) {\n+      pss->record_unused_optional_region(r);\n+      \/\/ Clear collection set marker and make sure that the remembered set information\n+      \/\/ is correct as we still need it later.\n+      _g1h->clear_region_attr(r);\n+      _g1h->register_region_with_region_attr(r);\n+      r->clear_index_in_opt_cset();\n+    };\n+\n+    _optional_groups.iterate(reset);\n+    \/\/ Remove groups from list without deleting the groups or clearing the associated cardsets.\n+    _optional_groups.remove_selected(_optional_groups.length(), _optional_groups.num_regions());\n@@ -672,1 +700,0 @@\n-  _optional_old_regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":202,"deletions":175,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -149,0 +149,8 @@\n+  \/\/ Old gen groups selected for evacuation.\n+  G1CSetCandidateGroupList _collection_set_groups;\n+\n+  \/\/ Groups are added to the collection set in increments when performing optional evacuations.\n+  \/\/ We use the value below to track these increments.\n+  uint _selected_groups_cur_length;\n+  uint _selected_groups_inc_part_start;\n+\n@@ -155,1 +163,1 @@\n-  G1CollectionCandidateRegionList _optional_old_regions;\n+  G1CSetCandidateGroupList _optional_groups;\n@@ -176,10 +184,14 @@\n-  void move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions);\n-  \/\/ Prepares old regions in the given set for optional collection later. Does not\n-  \/\/ add the region to collection set yet.\n-  void prepare_optional_regions(G1CollectionCandidateRegionList* regions);\n-  \/\/ Moves given old regions from the marking candidates to the retained candidates.\n-  \/\/ This makes sure that marking candidates will not remain there to unnecessarily\n-  \/\/ prolong the mixed phase.\n-  void move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions);\n-  \/\/ Removes the given list of regions from the retained candidates.\n-  void drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions);\n+  void prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index);\n+\n+  void add_group_to_collection_set(G1CSetCandidateGroup* gr);\n+\n+  void add_region_to_collection_set(G1HeapRegion* r);\n+\n+  double select_candidates_from_marking(double time_remaining_ms);\n+\n+  void select_candidates_from_retained(double time_remaining_ms);\n+\n+  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number  of actually selected regions.\n+  uint select_optional_collection_set_regions(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n@@ -199,16 +211,0 @@\n-  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n-  \/\/ the given candidate list and the remaining time.\n-  \/\/ Returns the remaining time.\n-  double select_candidates_from_marking(double time_remaining_ms,\n-                                        G1CollectionCandidateRegionList* initial_old_regions,\n-                                        G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  void select_candidates_from_retained(double time_remaining_ms,\n-                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                       G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  \/\/ Calculate the number of optional regions from the given collection set candidates,\n-  \/\/ the remaining time and the maximum number of these regions.\n-  void select_candidates_from_optional_regions(double time_remaining_ms,\n-                                               G1CollectionCandidateRegionList* selected);\n-\n@@ -235,0 +231,5 @@\n+  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n+  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n+\n+  void prepare_groups_for_scan();\n+\n@@ -246,1 +247,3 @@\n-  uint optional_region_length() const { return _optional_old_regions.length(); }\n+  uint num_optional_regions() const { return _optional_groups.num_regions(); }\n+\n+  bool only_contains_young_regions() const { return (initial_old_region_length() + num_optional_regions()) == 0; }\n@@ -248,1 +251,2 @@\n-  bool only_contains_young_regions() const { return (initial_old_region_length() + optional_region_length()) == 0; }\n+  template <class CardOrRangeVisitor>\n+  inline void merge_cardsets_for_collection_groups(G1CollectedHeap* g1h, CardOrRangeVisitor& cl, uint worker_id, uint num_workers);\n@@ -258,1 +262,5 @@\n-  void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }\n+  void update_incremental_marker() {\n+    _inc_build_state = Active;\n+    _inc_part_start = _collection_set_cur_length;\n+    _selected_groups_inc_part_start = _selected_groups_cur_length;\n+  }\n@@ -271,0 +279,2 @@\n+  uint collection_groups_increment_length() const { return _selected_groups_cur_length - _selected_groups_inc_part_start; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+#define SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1HeapRegionRemSet.hpp\"\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CollectionSet::merge_cardsets_for_collection_groups(G1CollectedHeap* g1h, CardOrRangeVisitor& cl, uint worker_id, uint num_workers) {\n+  uint length = collection_groups_increment_length();\n+  uint offset =  _selected_groups_inc_part_start;\n+  if (length == 0) {\n+    return;\n+  }\n+\n+  uint start_pos = (worker_id * length) \/ num_workers;\n+  uint cur_pos = start_pos;\n+  uint count = 0;\n+  do {\n+    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    cur_pos++;\n+    count++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n+}\n+#endif \/* SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n@@ -32,4 +31,6 @@\n-G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2, mtGC) { }\n-\n-void G1CollectionCandidateList::set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos) {\n-  assert(_candidates.is_empty(), \"must be\");\n+G1CSetCandidateGroup::G1CSetCandidateGroup(G1CardSetConfiguration* config) :\n+  _candidates(4, mtGCCardSet),\n+  _card_set_mm(config, G1CollectedHeap::heap()->card_set_freelist_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _gc_efficiency(0.0)\n+{ }\n@@ -37,2 +38,3 @@\n-  GrowableArrayFromArray<G1CollectionSetCandidateInfo> a(candidate_infos, (int)num_infos);\n-  _candidates.appendAll(&a);\n+void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+  G1CollectionSetCandidateInfo c(hr, hr->calc_gc_efficiency());\n+  add(c);\n@@ -41,4 +43,3 @@\n-void G1CollectionCandidateList::append_unsorted(G1HeapRegion* r) {\n-  G1CollectionSetCandidateInfo c(r, r->calc_gc_efficiency());\n-  _candidates.append(c);\n-}\n+void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n+  G1HeapRegion* hr = hr_info._r;\n+  assert(!hr->is_young(), \"should be flagged as survivor region\");\n@@ -46,2 +47,2 @@\n-void G1CollectionCandidateList::sort_by_efficiency() {\n-  _candidates.sort(compare_gc_efficiency);\n+  _candidates.append(hr_info);\n+  hr->install_group_cardset(&_card_set);\n@@ -50,6 +51,6 @@\n-void G1CollectionCandidateList::remove(G1CollectionCandidateRegionList* other) {\n-  guarantee((uint)_candidates.length() >= other->length(), \"must be\");\n-\n-  if (other->length() == 0) {\n-    \/\/ Nothing to remove or nothing in the original set.\n-    return;\n+void G1CSetCandidateGroup::calculate_efficiency() {\n+  size_t reclaimable_bytes = 0;\n+  uint num_candidates = _candidates.length();\n+  for (uint i = 0; i < num_candidates; i++) {\n+    G1HeapRegion* hr = region_at(i);\n+    reclaimable_bytes += hr->reclaimable_bytes();\n@@ -58,6 +59,3 @@\n-  \/\/ Create a list from scratch, copying over the elements from the candidate\n-  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n-  int new_length = _candidates.length() - other->length();\n-  GrowableArray<G1CollectionSetCandidateInfo> new_list(new_length, mtGC);\n-\n-  uint other_idx = 0;\n+  double group_total_time_ms = predict_group_total_time_ms();\n+  _gc_efficiency = reclaimable_bytes \/ group_total_time_ms;\n+}\n@@ -65,5 +63,6 @@\n-  for (uint candidate_idx = 0; candidate_idx < (uint)_candidates.length(); candidate_idx++) {\n-    if ((other_idx == other->length()) || _candidates.at(candidate_idx)._r != other->at(other_idx)) {\n-      new_list.append(_candidates.at(candidate_idx));\n-    } else {\n-      other_idx++;\n+void G1CSetCandidateGroup::clear(bool uninstall_group_cardset) {\n+  if (uninstall_group_cardset) {\n+    for (G1CollectionSetCandidateInfo ci : _candidates) {\n+      G1HeapRegion* r = ci._r;\n+      r->uninstall_group_cardset();\n+      r->rem_set()->clear(true \/* only_cardset *\/);\n@@ -72,7 +71,9 @@\n-  _candidates.swap(&new_list);\n-\n-  verify();\n-  assert(_candidates.length() == new_length, \"must be %u %u\", _candidates.length(), new_length);\n-}\n-\n-void G1CollectionCandidateList::clear() {\n+#ifdef ASSERT\n+  else {\n+    for (G1CollectionSetCandidateInfo ci : _candidates) {\n+      G1HeapRegion* r = ci._r;\n+      assert(r->rem_set()->card_set() != &_card_set , \"Pre-condition!\");\n+    }\n+  }\n+#endif\n+  _card_set.clear();\n@@ -82,11 +83,14 @@\n-#ifndef PRODUCT\n-void G1CollectionCandidateList::verify() {\n-  G1CollectionSetCandidateInfo* prev = nullptr;\n-\n-  for (uint i = 0; i < (uint)_candidates.length(); i++) {\n-    G1CollectionSetCandidateInfo& ci = _candidates.at(i);\n-    assert(prev == nullptr || prev->_gc_efficiency >= ci._gc_efficiency,\n-           \"Stored gc efficiency must be descending from region %u to %u\",\n-           prev->_r->hrm_index(), ci._r->hrm_index());\n-    prev = &ci;\n-    assert(ci._r->rem_set()->is_tracked(), \"remset for region %u must be tracked\", ci._r->hrm_index());\n+double G1CSetCandidateGroup::predict_group_total_time_ms() const {\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+  double predicted_copy_time_ms = 0.0;\n+  double predict_code_root_scan_time_ms = 0.0;\n+  size_t predict_bytes_to_copy = 0.0;\n+\n+  for (G1CollectionSetCandidateInfo ci : _candidates) {\n+    G1HeapRegion* r = ci._r;\n+    assert(r->rem_set()->card_set() == &_card_set, \"Must be!\");\n+\n+    predict_bytes_to_copy += p->predict_bytes_to_copy(r);\n+    predicted_copy_time_ms += p->predict_region_copy_time_ms(r, false \/* for_young_only_phase *\/);\n+    predict_code_root_scan_time_ms += p->predict_region_code_root_scan_time(r, false \/* for_young_only_phase *\/);\n@@ -94,2 +98,0 @@\n-}\n-#endif\n@@ -97,2 +99,1 @@\n-int G1CollectionCandidateList::compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n-  assert(ci1->_r != nullptr && ci2->_r != nullptr, \"Should not be!\");\n+  size_t card_rs_length = _card_set.occupied();\n@@ -100,2 +101,21 @@\n-  double gc_eff1 = ci1->_gc_efficiency;\n-  double gc_eff2 = ci2->_gc_efficiency;\n+  double merge_scan_time_ms = p->predict_merge_scan_time(card_rs_length);\n+  double non_young_other_time_ms = p->predict_non_young_other_time_ms(length());\n+\n+  log_trace(gc, ergo, cset) (\"Prediction for group with %u regions, card_rs_length %zu, merge_scan_time %.2fms, code_root_scan_time_ms %.2fms, evac_time_ms %.2fms, other_time %.2fms, bytes_to_cop %zu\",\n+                             length(),\n+                             card_rs_length,\n+                             merge_scan_time_ms,\n+                             predict_code_root_scan_time_ms,\n+                             predicted_copy_time_ms,\n+                             non_young_other_time_ms,\n+                             predict_bytes_to_copy);\n+\n+  return merge_scan_time_ms +\n+         predict_code_root_scan_time_ms +\n+         predicted_copy_time_ms +\n+         non_young_other_time_ms;\n+}\n+\n+int G1CSetCandidateGroup::compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2) {\n+  double gc_eff1 = (*gr1)->gc_efficiency();\n+  double gc_eff2 = (*gr2)->gc_efficiency();\n@@ -112,1 +132,1 @@\n-int G1CollectionCandidateList::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CSetCandidateGroup::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -136,1 +156,1 @@\n-G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2, mtGC) { }\n+G1CSetCandidateGroupList::G1CSetCandidateGroupList() : _groups(8, mtGC), _num_regions(0) { }\n@@ -138,3 +158,5 @@\n-void G1CollectionCandidateRegionList::append(G1HeapRegion* r) {\n-  assert(!_regions.contains(r), \"must be\");\n-  _regions.append(r);\n+void G1CSetCandidateGroupList::append(G1CSetCandidateGroup* group) {\n+  assert(group->length() > 0, \"Do not add empty groups\");\n+  assert(!_groups.contains(group), \"Already added to list\");\n+  _groups.append(group);\n+  _num_regions += group->length();\n@@ -143,7 +165,8 @@\n-void G1CollectionCandidateRegionList::remove_prefix(G1CollectionCandidateRegionList* other) {\n-#ifdef ASSERT\n-  \/\/ Check that the given list is a prefix of this list.\n-  int i = 0;\n-  for (G1HeapRegion* r : *other) {\n-    assert(_regions.at(i) == r, \"must be in order, but element %d is not\", i);\n-    i++;\n+G1CSetCandidateGroup* G1CSetCandidateGroupList::at(uint index) {\n+  return _groups.at(index);\n+}\n+\n+void G1CSetCandidateGroupList::clear(bool uninstall_group_cardset) {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->clear(uninstall_group_cardset);\n+    delete gr;\n@@ -151,1 +174,17 @@\n-#endif\n+  _groups.clear();\n+  _num_regions = 0;\n+}\n+\n+void G1CSetCandidateGroupList::prepare_for_scan() {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->card_set()->reset_table_scanner();\n+  }\n+}\n+\n+void G1CSetCandidateGroupList::remove_selected(uint count, uint num_regions) {\n+  _groups.remove_till(count);\n+  _num_regions -= num_regions;\n+}\n+\n+void G1CSetCandidateGroupList::remove(G1CSetCandidateGroupList* other) {\n+  guarantee((uint)_groups.length() >= other->length(), \"Other should be a subset of this list\");\n@@ -154,0 +193,1 @@\n+    \/\/ Nothing to remove or nothing in the original set.\n@@ -156,1 +196,19 @@\n-  _regions.remove_till(other->length());\n+\n+  \/\/ Create a list from scratch, copying over the elements from the candidate\n+  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n+  int new_length = _groups.length() - other->length();\n+  _num_regions = num_regions() - other->num_regions();\n+  GrowableArray<G1CSetCandidateGroup*> new_list(new_length, mtGC);\n+\n+  uint other_idx = 0;\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    if (other_idx == other->length() || gr != other->at(other_idx)) {\n+      new_list.append(gr);\n+    } else {\n+      other_idx++;\n+    }\n+  }\n+  _groups.swap(&new_list);\n+\n+  verify();\n+  assert(_groups.length() == new_length, \"Must be\");\n@@ -159,2 +217,2 @@\n-G1HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n-  return _regions.at(index);\n+void G1CSetCandidateGroupList::sort_by_efficiency() {\n+  _groups.sort(G1CSetCandidateGroup::compare_gc_efficiency);\n@@ -163,2 +221,9 @@\n-void G1CollectionCandidateRegionList::clear() {\n-  _regions.clear();\n+#ifndef PRODUCT\n+void G1CSetCandidateGroupList::verify() const {\n+  G1CSetCandidateGroup* prev = nullptr;\n+\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    assert(prev == nullptr || prev->gc_efficiency() >= gr->gc_efficiency(),\n+           \"Stored gc efficiency must be descending\");\n+    prev = gr;\n+  }\n@@ -166,0 +231,1 @@\n+#endif\n@@ -168,2 +234,0 @@\n-  _marking_regions(),\n-  _retained_regions(),\n@@ -171,0 +235,2 @@\n+  _from_marking_groups(),\n+  _retained_groups(),\n@@ -177,0 +243,2 @@\n+  _from_marking_groups.clear();\n+  _retained_groups.clear();\n@@ -192,2 +260,2 @@\n-  _marking_regions.clear();\n-  _retained_regions.clear();\n+  _retained_groups.clear(true \/* uninstall_group_cardset *\/);\n+  _from_marking_groups.clear(true \/* uninstall_group_cardset *\/);\n@@ -201,4 +269,2 @@\n-  G1CollectionCandidateListIterator iter = _marking_regions.begin();\n-  for (; iter != _marking_regions.end(); ++iter) {\n-    G1HeapRegion* hr = (*iter)->_r;\n-    (*iter)->_gc_efficiency = hr->calc_gc_efficiency();\n+  for(G1CSetCandidateGroup* gr : _from_marking_groups){\n+    gr->calculate_efficiency();\n@@ -206,1 +272,1 @@\n-  _marking_regions.sort_by_efficiency();\n+  _from_marking_groups.sort_by_efficiency();\n@@ -208,1 +274,1 @@\n-  _marking_regions.verify();\n+  _from_marking_groups.verify();\n@@ -213,1 +279,4 @@\n-  assert(_marking_regions.length() == 0, \"must be empty before adding new ones\");\n+  if(num_infos == 0) {\n+    log_debug(gc, ergo, cset) (\"No regions selected from marking.\");\n+    return;\n+  }\n@@ -215,0 +284,1 @@\n+  assert(_from_marking_groups.length() == 0, \"must be empty at the start of a cycle\");\n@@ -217,1 +287,12 @@\n-  _marking_regions.set(candidate_infos, num_infos);\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  \/\/ During each Mixed GC, we must collect at least G1Policy::calc_min_old_cset_length regions to meet\n+  \/\/ the G1MixedGCCountTarget. For the first collection in a Mixed GC cycle, we can add all regions\n+  \/\/ required to meet this threshold to the same remset group. We are certain these will be collected in\n+  \/\/ the same MixedGC.\n+  uint group_limit = p->calc_min_old_cset_length(num_infos);\n+\n+  uint num_added_to_group = 0;\n+  G1CSetCandidateGroup* current = nullptr;\n+\n+  current = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+\n@@ -222,0 +303,13 @@\n+\n+    if (num_added_to_group == group_limit) {\n+      if (group_limit != G1OldCSetGroupSize) {\n+        group_limit = G1OldCSetGroupSize;\n+      }\n+\n+      _from_marking_groups.append(current);\n+\n+      current = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+      num_added_to_group = 0;\n+    }\n+    current->add(candidate_infos[i]);\n+    num_added_to_group++;\n@@ -223,0 +317,6 @@\n+\n+  _from_marking_groups.append(current);\n+\n+  assert(_from_marking_groups.num_regions() == num_infos, \"Must be!\");\n+\n+  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_infos);\n@@ -231,3 +331,3 @@\n-  _marking_regions.verify();\n-  _retained_regions.sort_by_efficiency();\n-  _retained_regions.verify();\n+  _from_marking_groups.verify();\n+  _retained_groups.sort_by_efficiency();\n+  _retained_groups.verify();\n@@ -236,7 +336,1 @@\n-void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n-  assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n-  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n-  _retained_regions.append_unsorted(r);\n-}\n-\n-void G1CollectionSetCandidates::remove(G1CollectionCandidateRegionList* other) {\n+void G1CollectionSetCandidates::remove(G1CSetCandidateGroupList* other) {\n@@ -249,2 +343,3 @@\n-  G1CollectionCandidateRegionList other_marking_regions;\n-  G1CollectionCandidateRegionList other_retained_regions;\n+  G1CSetCandidateGroupList other_marking_groups;\n+  G1CSetCandidateGroupList other_retained_groups;\n+\n@@ -252,1 +347,4 @@\n-  for (G1HeapRegion* r : *other) {\n+  for (G1CSetCandidateGroup* group : *other) {\n+    assert(group->length() > 0, \"Should not have empty groups\");\n+    \/\/ Regions in the same group have the same source (i.e from_marking or retained).\n+    G1HeapRegion* r = group->region_at(0);\n@@ -254,1 +352,1 @@\n-      other_marking_regions.append(r);\n+      other_marking_groups.append(group);\n@@ -256,1 +354,1 @@\n-      other_retained_regions.append(r);\n+      other_retained_groups.append(group);\n@@ -260,2 +358,2 @@\n-  _marking_regions.remove(&other_marking_regions);\n-  _retained_regions.remove(&other_retained_regions);\n+  _from_marking_groups.remove(&other_marking_groups);\n+  _retained_groups.remove(&other_retained_groups);\n@@ -263,2 +361,2 @@\n-  for (G1HeapRegion* r : *other) {\n-    assert(contains(r), \"must contain region %u\", r->hrm_index());\n+  other->iterate([&] (G1HeapRegion* r) {\n+    assert(contains(r), \"Must contain region %u\", r->hrm_index());\n@@ -266,1 +364,1 @@\n-  }\n+  });\n@@ -271,0 +369,10 @@\n+void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n+  assert(!contains(r), \"Must not already contain region %u\", r->hrm_index());\n+  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n+\n+  G1CSetCandidateGroup* gr = new G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config());\n+  gr->add(r);\n+\n+  _retained_groups.append(gr);\n+}\n+\n@@ -280,1 +388,1 @@\n-  return _marking_regions.length();\n+  return _from_marking_groups.num_regions();\n@@ -284,1 +392,1 @@\n-  return _retained_regions.length();\n+  return _retained_groups.num_regions();\n@@ -288,1 +396,1 @@\n-void G1CollectionSetCandidates::verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) {\n+void G1CollectionSetCandidates::verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) {\n@@ -291,2 +399,3 @@\n-  for (uint i = 0; i < (uint)list->length(); i++) {\n-    G1HeapRegion* r = list->at(i)._r;\n+  for (G1CSetCandidateGroup* gr : *list) {\n+    for (G1CollectionSetCandidateInfo ci : *gr) {\n+      G1HeapRegion* r = ci._r;\n@@ -294,7 +403,7 @@\n-    if (is_from_marking(r)) {\n-      from_marking++;\n-    }\n-    const uint hrm_index = r->hrm_index();\n-    assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n-           \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n-    assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n+      if (is_from_marking(r)) {\n+        from_marking++;\n+      }\n+      const uint hrm_index = r->hrm_index();\n+      assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n+            \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n+      assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n@@ -302,1 +411,2 @@\n-    verify_map[hrm_index] = CandidateOrigin::Verify;\n+      verify_map[hrm_index] = CandidateOrigin::Verify;\n+    }\n@@ -314,1 +424,1 @@\n-  verify_helper(&_marking_regions, from_marking, verify_map);\n+  verify_helper(&_from_marking_groups, from_marking, verify_map);\n@@ -318,1 +428,1 @@\n-  verify_helper(&_retained_regions, from_marking_retained, verify_map);\n+  verify_helper(&_retained_groups, from_marking_retained, verify_map);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":229,"deletions":119,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"utilities\/bitMap.hpp\"\n@@ -36,1 +35,0 @@\n-class G1CollectionCandidateList;\n@@ -38,0 +36,1 @@\n+class G1CSetCandidateGroupList;\n@@ -41,27 +40,0 @@\n-using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<G1HeapRegion*>;\n-\n-\/\/ A set of G1HeapRegion*, a thin wrapper around GrowableArray.\n-class G1CollectionCandidateRegionList {\n-  GrowableArray<G1HeapRegion*> _regions;\n-\n-public:\n-  G1CollectionCandidateRegionList();\n-\n-  \/\/ Append a G1HeapRegion to the end of this list. The region must not be in the list\n-  \/\/ already.\n-  void append(G1HeapRegion* r);\n-  \/\/ Remove the given list of G1HeapRegion* from this list. The given list must be a prefix\n-  \/\/ of this list.\n-  void remove_prefix(G1CollectionCandidateRegionList* list);\n-\n-  \/\/ Empty contents of the list.\n-  void clear();\n-\n-  G1HeapRegion* at(uint index);\n-\n-  uint length() const { return (uint)_regions.length(); }\n-\n-  G1CollectionCandidateRegionListIterator begin() const { return _regions.begin(); }\n-  G1CollectionCandidateRegionListIterator end() const { return _regions.end(); }\n-};\n-\n@@ -82,3 +54,1 @@\n-class G1CollectionCandidateListIterator : public StackObj {\n-  G1CollectionCandidateList* _which;\n-  uint _position;\n+using G1CSetCandidateGroupIterator = GrowableArrayIterator<G1CollectionSetCandidateInfo>;\n@@ -86,5 +56,12 @@\n-public:\n-  G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position);\n-\n-  G1CollectionCandidateListIterator& operator++();\n-  G1CollectionSetCandidateInfo* operator*();\n+\/\/ G1CSetCandidateGroup groups candidate regions that will be selected for evacuation at the same time.\n+\/\/ Grouping occurs both for candidates from marking or regions retained during evacuation failure, but a group\n+\/\/ can not contain regions from both types of regions.\n+\/\/\n+\/\/ Humongous objects are excluded from the candidate groups because regions associated with these\n+\/\/ objects are never selected for evacuation.\n+\/\/\n+\/\/ All regions in the group share a G1CardSet instance, which tracks remembered set entries for the\n+\/\/ regions in the group. We do not have track to cross-region references for regions that are in the\n+\/\/ same group saving memory.\n+class G1CSetCandidateGroup : public CHeapObj<mtGCCardSet>{\n+  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n@@ -92,3 +69,1 @@\n-  bool operator==(const G1CollectionCandidateListIterator& rhs);\n-  bool operator!=(const G1CollectionCandidateListIterator& rhs);\n-};\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -96,4 +71,2 @@\n-\/\/ List of collection set candidates (regions with their efficiency) ordered by\n-\/\/ decreasing gc efficiency.\n-class G1CollectionCandidateList : public CHeapObj<mtGC> {\n-  friend class G1CollectionCandidateListIterator;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -101,1 +74,1 @@\n-  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n+  double _gc_efficiency;\n@@ -104,17 +77,4 @@\n-  G1CollectionCandidateList();\n-\n-  \/\/ Put the given set of candidates into this list, preserving the efficiency ordering.\n-  void set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos);\n-  \/\/ Add the given G1HeapRegion to this list at the end, (potentially) making the list unsorted.\n-  void append_unsorted(G1HeapRegion* r);\n-  \/\/ Restore sorting order by decreasing gc efficiency, using the existing efficiency\n-  \/\/ values.\n-  void sort_by_efficiency();\n-  \/\/ Removes any heap regions stored in this list also in the other list. The other\n-  \/\/ list may only contain regions in this list, sorted by gc efficiency. It need\n-  \/\/ not be a prefix of this list. Returns the number of regions removed.\n-  \/\/ E.g. if this list is \"A B G H\", the other list may be \"A G H\", but not \"F\" (not in\n-  \/\/ this list) or \"A H G\" (wrong order).\n-  void remove(G1CollectionCandidateRegionList* other);\n-\n-  void clear();\n+  G1CSetCandidateGroup(G1CardSetConfiguration* config);\n+  ~G1CSetCandidateGroup() {\n+    assert(length() == 0, \"post condition!\");\n+  }\n@@ -122,1 +82,2 @@\n-  G1CollectionSetCandidateInfo& at(uint position) { return _candidates.at(position); }\n+  void add(G1HeapRegion* hr);\n+  void add(G1CollectionSetCandidateInfo& hr_info);\n@@ -126,1 +87,3 @@\n-  void verify() PRODUCT_RETURN;\n+  G1CardSet* card_set() { return &_card_set; }\n+\n+  void calculate_efficiency();\n@@ -131,1 +94,1 @@\n-  static int compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+  static int compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2);\n@@ -135,2 +98,10 @@\n-  G1CollectionCandidateListIterator begin() {\n-    return G1CollectionCandidateListIterator(this, 0);\n+  double gc_efficiency() { return _gc_efficiency; }\n+\n+  G1HeapRegion* region_at(uint i) const { return _candidates.at(i)._r; }\n+\n+  G1CollectionSetCandidateInfo* at(uint i) { return &_candidates.at(i); }\n+\n+  double predict_group_total_time_ms() const;\n+\n+  G1MonotonicArenaMemoryStats card_set_memory_stats() const {\n+    return _card_set_mm.memory_stats();\n@@ -139,2 +110,8 @@\n-  G1CollectionCandidateListIterator end() {\n-    return G1CollectionCandidateListIterator(this, length());\n+  void clear(bool uninstall_group_cardset = false);\n+\n+  G1CSetCandidateGroupIterator begin() const {\n+    return _candidates.begin();\n+  }\n+\n+  G1CSetCandidateGroupIterator end() const {\n+    return _candidates.end();\n@@ -144,5 +121,0 @@\n-\/\/ Iterator for G1CollectionSetCandidates. There are no guarantees on the order\n-\/\/ of the regions returned.\n-class G1CollectionSetCandidatesIterator : public StackObj {\n-  G1CollectionSetCandidates* _which;\n-    uint _position;\n@@ -150,2 +122,25 @@\n-  public:\n-  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position);\n+using G1CSetCandidateGroupListIterator = GrowableArrayIterator<G1CSetCandidateGroup*>;\n+\n+class G1CSetCandidateGroupList {\n+  GrowableArray<G1CSetCandidateGroup*> _groups;\n+  volatile uint _num_regions;\n+\n+public:\n+  G1CSetCandidateGroupList();\n+  void append(G1CSetCandidateGroup* group);\n+\n+  \/\/ Delete all groups from the list. The cardset cleanup for regions within the\n+  \/\/ groups could have been done elsewhere  (e.g. when adding groups to the\n+  \/\/ collection set or to retained regions). The uninstall_group_cardset is set to\n+  \/\/ true if cleanup needs to happen as we clear the groups from the list.\n+  void clear(bool uninstall_group_cardset = false);\n+\n+  G1CSetCandidateGroup* at(uint index);\n+\n+  uint length() const { return (uint)_groups.length(); }\n+\n+  uint num_regions() const { return _num_regions; }\n+\n+  void remove_selected(uint count, uint num_regions);\n+\n+  void remove(G1CSetCandidateGroupList* other);\n@@ -153,2 +148,1 @@\n-  G1CollectionSetCandidatesIterator& operator++();\n-  G1HeapRegion* operator*();\n+  void prepare_for_scan();\n@@ -156,2 +150,18 @@\n-  bool operator==(const G1CollectionSetCandidatesIterator& rhs);\n-  bool operator!=(const G1CollectionSetCandidatesIterator& rhs);\n+  void sort_by_efficiency();\n+\n+  GrowableArray<G1CSetCandidateGroup*>*  groups() {\n+    return &_groups;\n+  }\n+\n+  void verify() const PRODUCT_RETURN;\n+\n+  G1CSetCandidateGroupListIterator begin() const {\n+    return _groups.begin();\n+  }\n+\n+  G1CSetCandidateGroupListIterator end() const {\n+    return _groups.end();\n+  }\n+\n+  template<typename Func>\n+  void iterate(Func&& f) const;\n@@ -160,1 +170,1 @@\n-\/\/ Tracks all collection set candidates, i.e. regions that could\/should be evacuated soon.\n+\/\/ Tracks all collection set candidates, i.e. region groups that could\/should be evacuated soon.\n@@ -162,1 +172,1 @@\n-\/\/ These candidate regions are tracked in two list of regions, sorted by decreasing\n+\/\/ These candidate groups are tracked in two list of region groups, sorted by decreasing\n@@ -165,4 +175,4 @@\n-\/\/ * marking_regions: the set of regions selected by concurrent marking to be\n-\/\/                    evacuated to keep overall heap occupancy stable.\n-\/\/                    They are guaranteed to be evacuated and cleared out during\n-\/\/                    the mixed phase.\n+\/\/ * from_marking_groups: the set of region groups selected by concurrent marking to be\n+\/\/                        evacuated to keep overall heap occupancy stable.\n+\/\/                        They are guaranteed to be evacuated and cleared out during\n+\/\/                        the mixed phase.\n@@ -170,3 +180,3 @@\n-\/\/ * retained_regions: set of regions selected for evacuation during evacuation\n-\/\/                     failure.\n-\/\/                     Any young collection will try to evacuate them.\n+\/\/ * retained_groups: set of region groups selected for evacuation during evacuation\n+\/\/                    failure.\n+\/\/                    Any young collection will try to evacuate them.\n@@ -175,1 +185,0 @@\n-  friend class G1CollectionSetCandidatesIterator;\n@@ -184,3 +193,0 @@\n-  G1CollectionCandidateList _marking_regions;  \/\/ Set of regions selected by concurrent marking.\n-  G1CollectionCandidateList _retained_regions; \/\/ Set of regions selected from evacuation failed regions.\n-\n@@ -188,0 +194,5 @@\n+  G1CSetCandidateGroupList _from_marking_groups; \/\/ Set of regions selected by concurrent marking.\n+  \/\/ Set of regions retained due to evacuation failure. Groups added to this list\n+  \/\/ should contain only one region, making it easier to evacuate retained regions\n+  \/\/ in any young collection.\n+  G1CSetCandidateGroupList _retained_groups;\n@@ -199,2 +210,2 @@\n-  G1CollectionCandidateList& marking_regions() { return _marking_regions; }\n-  G1CollectionCandidateList& retained_regions() { return _retained_regions; }\n+  G1CSetCandidateGroupList& from_marking_groups() { return _from_marking_groups; }\n+  G1CSetCandidateGroupList& retained_groups() { return _retained_groups; }\n@@ -222,1 +233,1 @@\n-  \/\/ Remove the given regions from the candidates. All given regions must be part\n+  \/\/ Remove the given groups from the candidates. All given regions must be part\n@@ -224,1 +235,1 @@\n-  void remove(G1CollectionCandidateRegionList* other);\n+  void remove(G1CSetCandidateGroupList* other);\n@@ -237,1 +248,1 @@\n-  void verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n+  void verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n@@ -244,8 +255,2 @@\n-  \/\/ Iteration\n-  G1CollectionSetCandidatesIterator begin() {\n-    return G1CollectionSetCandidatesIterator(this, 0);\n-  }\n-\n-  G1CollectionSetCandidatesIterator end() {\n-    return G1CollectionSetCandidatesIterator(this, length());\n-  }\n+  template<typename Func>\n+  void iterate_regions(Func&& f) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":112,"deletions":107,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -32,38 +32,7 @@\n-inline G1CollectionCandidateListIterator::G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position) :\n-  _which(which), _position(position) { }\n-\n-inline G1CollectionCandidateListIterator& G1CollectionCandidateListIterator::operator++() {\n-  assert(_position < _which->length(), \"must be\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1CollectionSetCandidateInfo* G1CollectionCandidateListIterator::operator*() {\n-  return &_which->_candidates.at(_position);\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator==(const G1CollectionCandidateListIterator& rhs) {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator!=(const G1CollectionCandidateListIterator& rhs) {\n-  return !(*this == rhs);\n-}\n-\n-inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position) :\n-  _which(which), _position(position) {\n-}\n-\n-inline G1CollectionSetCandidatesIterator& G1CollectionSetCandidatesIterator::operator++() {\n-  assert(_position < _which->length(), \"must not be at end already\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n-  uint length = _which->marking_regions_length();\n-  if (_position < length) {\n-    return _which->_marking_regions.at(_position)._r;\n-  } else {\n-    return _which->_retained_regions.at(_position - length)._r;\n+template<typename Func>\n+void G1CSetCandidateGroupList::iterate(Func&& f) const {\n+  for (G1CSetCandidateGroup* group : _groups) {\n+    for (G1CollectionSetCandidateInfo ci : *group) {\n+      G1HeapRegion* r = ci._r;\n+      f(r);\n+    }\n@@ -73,4 +42,3 @@\n-inline bool G1CollectionSetCandidatesIterator::operator==(const G1CollectionSetCandidatesIterator& rhs)  {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n+template<typename Func>\n+void G1CollectionSetCandidates::iterate_regions(Func&& f) const {\n+  _from_marking_groups.iterate(f);\n@@ -78,2 +46,1 @@\n-inline bool G1CollectionSetCandidatesIterator::operator!=(const G1CollectionSetCandidatesIterator& rhs)  {\n-  return !(*this == rhs);\n+  _retained_groups.iterate(f);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":11,"deletions":44,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare_reclaimble_bytes);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CSetCandidateGroup::compare_reclaimble_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+  if (is_young() || is_free()) {\n+    return -1.0;\n+  }\n@@ -604,1 +607,3 @@\n-      if (_from != _to && !_from->is_young() && _to->rem_set()->is_complete()) {\n+      if (_from != _to && !_from->is_young() &&\n+          _to->rem_set()->is_complete() &&\n+          _from->rem_set()->card_set() != _to->rem_set()->card_set()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -153,1 +153,5 @@\n-    to_rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->card_set() != to_rem_set->card_set()) {\n+      to_rem_set->add_reference(p, _worker_id);\n+    }\n@@ -271,1 +275,5 @@\n-    rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->card_set() != rem_set->card_set()) {\n+      rem_set->add_reference(p, _worker_id);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    _max_num_optional_regions(collection_set->optional_region_length()),\n+    _max_num_optional_regions(collection_set->num_optional_regions()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-                                     candidates()->marking_regions_length());\n+                                     candidates()->from_marking_groups().num_regions());\n@@ -494,4 +494,3 @@\n-  for (G1CollectionSetCandidateInfo* ci : candidates()->marking_regions()) {\n-    \/\/ We optimistically assume that any of these marking candidate regions will\n-    \/\/ not be pinned, so just consider them as normal.\n-    if (min_marking_candidates == 0) {\n+  uint selected_candidates = 0;\n+  for (G1CSetCandidateGroup* gr : candidates()->from_marking_groups()) {\n+    if (selected_candidates >= min_marking_candidates) {\n@@ -500,2 +499,2 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(ci->_r, false \/* for_young_only_phase *\/);\n-    min_marking_candidates--;\n+    predicted_region_evac_time_ms += gr->predict_group_total_time_ms();\n+    selected_candidates += gr->length();\n@@ -527,1 +526,1 @@\n-  G1CollectionCandidateList& list = candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -529,1 +528,1 @@\n-                               list.length());\n+                               retained_groups->num_regions());\n@@ -531,2 +530,3 @@\n-  for (G1CollectionSetCandidateInfo* ci : list) {\n-    G1HeapRegion* r = ci->_r;\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"We should only have one region in a retained group\");\n+    G1HeapRegion* r = group->region_at(0); \/\/ We only have one region per group.\n@@ -548,1 +548,1 @@\n-                            num_regions, list.length(), num_pinned_regions, result);\n+                            num_regions, retained_groups->num_regions(), num_pinned_regions, result);\n@@ -1115,0 +1115,4 @@\n+double G1Policy::predict_non_young_other_time_ms(uint count) const {\n+  return _analytics->predict_non_young_other_time_ms(count);\n+}\n+\n@@ -1140,0 +1144,8 @@\n+double G1Policy::predict_merge_scan_time(size_t card_rs_length)  const {\n+  size_t scan_card_num = _analytics->predict_scan_card_num(card_rs_length, false);\n+\n+  return\n+    _analytics->predict_card_merge_time_ms(card_rs_length, false) +\n+    _analytics->predict_card_scan_time_ms(scan_card_num, false);\n+}\n+\n@@ -1343,5 +1355,0 @@\n-  \/\/ Clear remembered sets of remaining candidate regions and the actual candidate\n-  \/\/ set.\n-  for (G1HeapRegion* r : *candidates()) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class G1CollectionCandidateList;\n@@ -52,1 +51,0 @@\n-class G1CollectionCandidateRegionList;\n@@ -143,1 +141,0 @@\n-private:\n@@ -159,2 +156,1 @@\n-public:\n-\n+  double predict_merge_scan_time(size_t card_rs_length) const;\n@@ -163,0 +159,1 @@\n+  double predict_non_young_other_time_ms(uint count) const;\n@@ -250,1 +247,0 @@\n-  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n@@ -255,0 +251,1 @@\n+  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -1112,0 +1113,1 @@\n+    G1RemSetScanState* _scan_state;\n@@ -1136,1 +1138,4 @@\n-    G1ClearBitmapClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+    G1ClearBitmapClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :\n+      _g1h(g1h),\n+      _scan_state(scan_state)\n+    { }\n@@ -1150,0 +1155,1 @@\n+      _scan_state->add_all_dirty_region(hr->hrm_index());\n@@ -1154,16 +1160,0 @@\n-  \/\/ Helper to allow two closure to be applied when\n-  \/\/ iterating through the collection set.\n-  class G1CombinedClosure : public G1HeapRegionClosure {\n-    G1HeapRegionClosure* _closure1;\n-    G1HeapRegionClosure* _closure2;\n-  public:\n-    G1CombinedClosure(G1HeapRegionClosure* cl1, G1HeapRegionClosure* cl2) :\n-      _closure1(cl1),\n-      _closure2(cl2) { }\n-\n-    bool do_heap_region(G1HeapRegion* hr) {\n-      return _closure1->do_heap_region(hr) ||\n-             _closure2->do_heap_region(hr);\n-    }\n-  };\n-\n@@ -1388,2 +1378,1 @@\n-        G1ClearBitmapClosure clear(g1h);\n-        G1CombinedClosure combined(&merge, &clear);\n+        G1ClearBitmapClosure clear_bitmap(g1h, _scan_state);\n@@ -1395,1 +1384,3 @@\n-        g1h->collection_set_iterate_increment_from(&combined, nullptr, worker_id);\n+        g1h->collection_set()->merge_cardsets_for_collection_groups(g1h, merge, worker_id, _num_workers);\n+\n+        g1h->collection_set_iterate_increment_from(&clear_bitmap, nullptr, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                                              collection_set()->optional_region_length());\n+                                              collection_set()->num_optional_regions());\n@@ -300,0 +300,1 @@\n+        guarantee(!hr->rem_set()->has_group_cardset(), \"Humongous regions should not have group card sets\");\n@@ -776,1 +777,1 @@\n-  while (!evacuation_alloc_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_alloc_failed() && collection_set()->num_optional_regions() > 0) {\n@@ -784,1 +785,1 @@\n-                                collection_set()->optional_region_length(), time_left_ms);\n+                                collection_set()->num_optional_regions(), time_left_ms);\n@@ -975,1 +976,1 @@\n-  for (G1HeapRegion* r : *candidates) {\n+  candidates->iterate_regions([&] (G1HeapRegion* r) {\n@@ -977,1 +978,1 @@\n-  }\n+  });\n@@ -1091,1 +1092,1 @@\n-    bool may_do_optional_evacuation = collection_set()->optional_region_length() != 0;\n+    bool may_do_optional_evacuation = collection_set()->num_optional_regions() != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -109,2 +109,6 @@\n-    for (G1HeapRegion* r : *candidates) {\n-      _total.add(r->rem_set()->card_set_memory_stats());\n+    for (G1CSetCandidateGroup* gr : candidates->from_marking_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n+    }\n+\n+    for (G1CSetCandidateGroup* gr : candidates->retained_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n@@ -620,1 +624,0 @@\n-  size_t _card_rs_length;      \/\/ (Card Set) Remembered set size\n@@ -630,1 +633,0 @@\n-      _card_rs_length(0),\n@@ -640,1 +642,0 @@\n-    _card_rs_length += other->_card_rs_length;\n@@ -656,1 +657,1 @@\n-    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n@@ -658,1 +659,2 @@\n-    policy->record_card_rs_length(_card_rs_length);\n+    \/\/ We only use young_rs_length statistics to estimate young regions length.\n+    policy->record_card_rs_length(young_rs_length);\n@@ -684,4 +686,0 @@\n-\n-  void account_card_rs_length(G1HeapRegion* r) {\n-    _card_rs_length += r->rem_set()->occupied();\n-  }\n@@ -809,2 +807,0 @@\n-      \/\/ We only use card_rs_length statistics to estimate young regions length.\n-      stats()->account_card_rs_length(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -279,0 +279,8 @@\n+                                                                            \\\n+  product(uint, G1OldCSetGroupSize, 5, EXPERIMENTAL,                        \\\n+          \"The maximum number of old CSet regions in a collection group. \"  \\\n+          \"All regions in a group will be evacuated in the same GC pause.\"  \\\n+          \"The first group calculated after marking from marking \"          \\\n+          \"candidates may exceed this limit as it is calculated based on \"  \\\n+          \"G1MixedGCCountTarget.\")                                          \\\n+          range(1, 256)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-    private int expectedMarkingSkipEvents;      \/\/ How many times has the region from the \"marking\" collection set candidate set been \"skipped\".\n@@ -53,1 +52,1 @@\n-    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"marking\" collection set candidate set been put into the collection set.\n+    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"retained\" collection set candidate set been put into the collection set.\n@@ -56,1 +55,0 @@\n-                      int expectedMarkingSkipEvents,\n@@ -62,1 +60,0 @@\n-        this.expectedMarkingSkipEvents = expectedMarkingSkipEvents;\n@@ -119,1 +116,1 @@\n-        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Marking|Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n+        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n@@ -125,22 +122,0 @@\n-        for (int i = 0; i < expectedMarkingSkipEvents; i++) {\n-            expectMoreMatches(skipDropMatcher, \"expectedMarkingSkipEvents\");\n-            curGC = expectIncreasingGC(skipDropMatcher);\n-\n-            Asserts.assertEQ(\"Marking\", skipDropMatcher.group(2), \"Expected \\\"Marking\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n-            updateOrCompareCurRegion(\"MarkingSkip\", Integer.parseInt(skipDropMatcher.group(3)));\n-            Asserts.assertEQ(\"Skipping\", skipDropMatcher.group(4), \"Expected \\\"Skipping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n-\n-            while (true) {\n-                if (!reclaimMatcher.find()) {\n-                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n-                }\n-                if (reclaimMatcher.group(2).equals(\"retained\")) {\n-                    continue;\n-                }\n-                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n-                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n-                    Asserts.assertEQ(actual, 1, \"Expected number of pinned to be 1 after marking skip but is \" + actual);\n-                    break;\n-                }\n-            }\n-        }\n@@ -235,5 +210,5 @@\n-        \/\/ younGCsBeforeUnpin, expectedMarkingSkipEvents, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n-        testPinnedEvacuation(1, 1, 0, 0, 0, 1);\n-        testPinnedEvacuation(2, 1, 1, 0, 0, 1);\n-        testPinnedEvacuation(3, 1, 2, 0, 0, 1);\n-        testPinnedEvacuation(4, 1, 2, 1, 0, 0);\n+        \/\/ younGCsBeforeUnpin, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n+        testPinnedEvacuation(1, 0, 0, 0, 1);\n+        testPinnedEvacuation(2, 1, 0, 0, 1);\n+        testPinnedEvacuation(3, 2, 0, 0, 1);\n+        testPinnedEvacuation(4, 2, 1, 0, 0);\n@@ -255,1 +230,0 @@\n-                                             int expectedMarkingSkipEvents,\n@@ -281,1 +255,0 @@\n-                                                    expectedMarkingSkipEvents,\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"}]}