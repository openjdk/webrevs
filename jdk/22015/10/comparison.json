{"files":[{"patch":"@@ -782,0 +782,10 @@\n+\n+#ifdef ASSERT\n+  {\n+    uint region_idx = card_region >> config()->log2_card_regions_per_heap_region();\n+    G1HeapRegion* r = G1CollectedHeap::heap()->region_at(region_idx);\n+    assert(!r->rem_set()->is_added_to_cset_group() ||\n+           r->rem_set()->cset_group()->card_set() != this, \"Should not be sharing a cardset\");\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1162,2 +1162,1 @@\n-  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n-  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n+  _young_regions_cset_group(card_set_config(), &_card_set_freelist_pool, 1u \/* group_id *\/),\n@@ -2719,1 +2718,1 @@\n-  hr->install_group_cardset(young_regions_cardset());\n+  young_regions_cset_group()->add(hr);\n@@ -2930,1 +2929,1 @@\n-      new_alloc_region->install_group_cardset(young_regions_cardset());\n+      young_regions_cset_group()->add(new_alloc_region);\n@@ -3073,2 +3072,4 @@\n-void G1CollectedHeap::prepare_group_cardsets_for_scan () {\n-  _young_regions_cardset.reset_table_scanner_for_groups();\n+void G1CollectedHeap::prepare_group_cardsets_for_scan() {\n+  young_regions_cardset()->reset_table_scanner_for_groups();\n+\n+  collection_set()->prepare_groups_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -784,2 +784,1 @@\n-  G1CardSetMemoryManager _young_regions_cardset_mm;\n-  G1CardSet _young_regions_cardset;\n+  G1CSetCandidateGroup _young_regions_cset_group;\n@@ -790,1 +789,2 @@\n-  G1CardSet* young_regions_cardset() { return &_young_regions_cardset; };\n+  G1CSetCandidateGroup* young_regions_cset_group() { return &_young_regions_cset_group; }\n+  G1CardSet* young_regions_cardset() { return _young_regions_cset_group.card_set(); };\n@@ -792,1 +792,1 @@\n-  G1CardSetMemoryManager* young_regions_card_set_mm() { return &_young_regions_cardset_mm; }\n+  G1MonotonicArenaMemoryStats young_regions_card_set_memory_stats() { return _young_regions_cset_group.card_set_memory_stats(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  assert(!r->has_pinned_objects(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -56,0 +56,3 @@\n+  _collection_set_groups(),\n+  _selected_groups_cur_length(0),\n+  _selected_groups_inc_part_start(0),\n@@ -59,1 +62,1 @@\n-  _optional_old_regions(),\n+  _optional_groups(),\n@@ -80,1 +83,2 @@\n-  _optional_old_regions.clear();\n+  assert(_optional_groups.length() == 0, \"Should not have any optional groups yet\");\n+  _optional_groups.clear();\n@@ -94,1 +98,4 @@\n-  _optional_old_regions.clear();\n+}\n+\n+void G1CollectionSet::prepare_groups_for_scan () {\n+  collection_set_groups()->prepare_for_scan();\n@@ -104,0 +111,2 @@\n+  assert(!hr->rem_set()->is_added_to_cset_group(), \"Should have already uninstalled group remset\");\n+\n@@ -129,0 +138,1 @@\n+  _collection_set_groups.clear();\n@@ -154,1 +164,1 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n+  _optional_groups.iterate([&] (G1HeapRegion* r) {\n@@ -157,1 +167,1 @@\n-  }\n+  });\n@@ -323,13 +333,10 @@\n-\/\/ The current mechanism skips evacuation of pinned old regions like g1 does for\n-\/\/ young regions:\n-\/\/ * evacuating pinned marking collection set candidate regions (available during mixed\n-\/\/   gc) like young regions would not result in any memory gain but only take additional\n-\/\/   time away from processing regions that would actually result in memory being freed.\n-\/\/   To advance mixed gc progress (we committed to evacuate all marking collection set\n-\/\/   candidate regions within the maximum number of mixed gcs in the phase), move them\n-\/\/   to the optional collection set candidates to reclaim them asap as time permits.\n-\/\/ * evacuating out retained collection set candidates would also just take up time with\n-\/\/   no actual space freed in old gen. Better to concentrate on others.\n-\/\/   Retained collection set candidates are aged out, ie. made to regular old regions\n-\/\/   without remembered sets after a few attempts to save computation costs of keeping\n-\/\/   them candidates for very long living pinned regions.\n+\/\/ The current mechanism for evacuating pinned old regions is as below:\n+\/\/ * pinned regions in the marking collection set candidate list (available during mixed gc) are evacuated like\n+\/\/   pinned young regions to avoid the complexity of dealing with pinned regions that are part of a\n+\/\/   collection group sharing a single cardset. These regions will be partially evacuated and added to the\n+\/\/   retained collection set by the evacuation failure handling mechanism.\n+\/\/ * evacuating pinned regions out of retained collection set candidates would also just take up time\n+\/\/   with no actual space freed in old gen. Better to concentrate on others. So we skip over pinned\n+\/\/   regions in retained collection set candidates. Retained collection set candidates are aged out, ie.\n+\/\/   made to regular old regions without remembered sets after a few attempts to save computation costs\n+\/\/   of keeping them candidates for very long living pinned regions.\n@@ -339,0 +346,3 @@\n+  _selected_groups_cur_length = 0;\n+  _selected_groups_inc_part_start = 0;\n+\n@@ -342,5 +352,0 @@\n-    G1CollectionCandidateRegionList initial_old_regions;\n-    assert(_optional_old_regions.length() == 0, \"must be\");\n-    G1CollectionCandidateRegionList pinned_marking_regions;\n-    G1CollectionCandidateRegionList pinned_retained_regions;\n-\n@@ -348,3 +353,1 @@\n-      time_remaining_ms = select_candidates_from_marking(time_remaining_ms,\n-                                                         &initial_old_regions,\n-                                                         &pinned_marking_regions);\n+      time_remaining_ms = select_candidates_from_marking(time_remaining_ms);\n@@ -355,16 +358,3 @@\n-    select_candidates_from_retained(time_remaining_ms,\n-                                    &initial_old_regions,\n-                                    &pinned_retained_regions);\n-\n-    \/\/ Move initially selected old regions to collection set directly.\n-    move_candidates_to_collection_set(&initial_old_regions);\n-    \/\/ Only prepare selected optional regions for now.\n-    prepare_optional_regions(&_optional_old_regions);\n-    \/\/ Move pinned marking regions we came across to retained candidates so that\n-    \/\/ there is progress in the mixed gc phase.\n-    move_pinned_marking_to_retained(&pinned_marking_regions);\n-    \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n-    \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n-    \/\/ GCs and hence are considered \"long lived\".\n-    drop_pinned_retained_regions(&pinned_retained_regions);\n-\n+    if (candidates()->retained_groups().num_regions() > 0) {\n+      select_candidates_from_retained(time_remaining_ms);\n+    }\n@@ -376,0 +366,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -384,8 +375,0 @@\n-void G1CollectionSet::move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions) {\n-  for (G1HeapRegion* r : *regions) {\n-    _g1h->clear_region_attr(r);\n-    add_old_region(r);\n-  }\n-  candidates()->remove(regions);\n-}\n-\n@@ -397,3 +380,1 @@\n-double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms,\n-                                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                                       G1CollectionCandidateRegionList* pinned_old_regions) {\n+double G1CollectionSet::select_candidates_from_marking(double time_remaining_ms) {\n@@ -401,4 +382,3 @@\n-\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_pinned_regions = 0;\n+  uint num_inital_regions = 0;\n+  uint num_initial_groups = 0;\n+  uint num_optional_regions = 0;\n@@ -411,3 +391,2 @@\n-  const uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n-  const uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n-  const uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n+  uint min_old_cset_length = _policy->calc_min_old_cset_length(candidates()->last_marking_candidates_length());\n+  uint max_old_cset_length = MAX2(min_old_cset_length, _policy->calc_max_old_cset_length());\n@@ -416,2 +395,1 @@\n-  G1CollectionCandidateList* marking_list = &candidates()->marking_regions();\n-  assert(marking_list != nullptr, \"must be\");\n+  G1CSetCandidateGroupList* from_marking_groups = &candidates()->from_marking_groups();\n@@ -420,1 +398,1 @@\n-                            \"Min %u regions, max %u regions, available %u regions\"\n+                            \"Min %u regions, max %u regions, available %u regions (%u groups), \"\n@@ -422,1 +400,2 @@\n-                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n+                            min_old_cset_length, max_old_cset_length, from_marking_groups->num_regions(), from_marking_groups->length(),\n+                            time_remaining_ms, optional_threshold_ms);\n@@ -424,3 +403,4 @@\n-  G1CollectionCandidateListIterator iter = marking_list->begin();\n-  for (; iter != marking_list->end(); ++iter) {\n-    if (num_initial_regions_selected + num_optional_regions_selected >= max_old_cset_length) {\n+  G1CSetCandidateGroupList selected_groups;\n+\n+  for (G1CSetCandidateGroup* group : *from_marking_groups) {\n+    if (num_inital_regions + num_optional_regions >= max_old_cset_length) {\n@@ -431,13 +411,3 @@\n-    G1HeapRegion* hr = (*iter)->_r;\n-    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n-    \/\/ space from them (and we expect to get free space from marking candidates).\n-    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n-    \/\/ to not impact the mixed phase too much.\n-    if (hr->has_pinned_objects()) {\n-      num_pinned_regions++;\n-      (*iter)->update_num_unreclaimed();\n-      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n-      pinned_old_regions->append(hr);\n-      continue;\n-    }\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(hr, false);\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n+\n@@ -446,3 +416,9 @@\n-    if (initial_old_regions->length() < min_old_cset_length) {\n-      initial_old_regions->append(hr);\n-      num_initial_regions_selected++;\n+    if (num_inital_regions < min_old_cset_length) {\n+\n+      num_initial_groups++;\n+\n+      add_group_to_collection_set(group);\n+      selected_groups.append(group);\n+\n+      num_inital_regions += group->length();\n+\n@@ -452,1 +428,1 @@\n-        num_expensive_regions++;\n+        num_expensive_regions += group->length();\n@@ -462,0 +438,7 @@\n+        num_initial_groups++;\n+\n+        add_group_to_collection_set(group);\n+        selected_groups.append(group);\n+\n+        num_inital_regions += group->length();\n+\n@@ -463,2 +446,1 @@\n-        initial_old_regions->append(hr);\n-        num_initial_regions_selected++;\n+\n@@ -467,1 +449,3 @@\n-        assert(_optional_old_regions.length() < max_optional_regions, \"Should not be possible.\");\n+        _optional_groups.append(group);\n+        prepare_optional_group(group, num_optional_regions);\n+        num_optional_regions += group->length();\n@@ -469,2 +453,0 @@\n-        _optional_old_regions.append(hr);\n-        num_optional_regions_selected++;\n@@ -477,1 +459,7 @@\n-  if (iter == marking_list->end()) {\n+\n+  \/\/ Remove selected groups from list of candidate groups.\n+  if (num_initial_groups > 0) {\n+    candidates()->remove(&selected_groups);\n+  }\n+\n+  if (from_marking_groups->length() == 0) {\n@@ -486,1 +474,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u regions (%u groups), optional: %u regions (%u groups), \"\n@@ -488,1 +476,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            selected_groups.num_regions(), selected_groups.length(), _optional_groups.num_regions(), _optional_groups.length(),\n@@ -491,2 +479,2 @@\n-  assert(initial_old_regions->length() == num_initial_regions_selected, \"must be\");\n-  assert(_optional_old_regions.length() == num_optional_regions_selected, \"must be\");\n+  assert(selected_groups.num_regions() == num_inital_regions, \"must be\");\n+  assert(_optional_groups.num_regions() == num_optional_regions, \"must be\");\n@@ -496,6 +484,4 @@\n-void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms,\n-                                                      G1CollectionCandidateRegionList* initial_old_regions,\n-                                                      G1CollectionCandidateRegionList* pinned_old_regions) {\n-  uint num_initial_regions_selected = 0;\n-  uint num_optional_regions_selected = 0;\n-  uint num_expensive_regions_selected = 0;\n+void G1CollectionSet::select_candidates_from_retained(double time_remaining_ms) {\n+  uint num_initial_regions = 0;\n+  uint num_optional_regions = 0;\n+  uint num_expensive_regions = 0;\n@@ -516,1 +502,1 @@\n-  G1CollectionCandidateList* retained_list = &candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -519,1 +505,1 @@\n-                            \"Min %u regions, available %u, \"\n+                            \"Min %u regions, available %u regions (%u groups), \"\n@@ -521,1 +507,10 @@\n-                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n+                            min_regions, retained_groups->num_regions(), retained_groups->length(),\n+                            time_remaining_ms, optional_time_remaining_ms);\n+\n+  G1CSetCandidateGroupList remove_from_retained;\n+  G1CSetCandidateGroupList groups_to_abandon;\n+\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"Retained groups should have only 1 region\");\n+\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -523,3 +518,0 @@\n-  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n-    G1HeapRegion* r = ci->_r;\n-    double predicted_time_ms = _policy->predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n@@ -527,0 +519,4 @@\n+\n+    G1CollectionSetCandidateInfo* ci = group->at(0); \/\/ We only have one region in the group.\n+    G1HeapRegion* r = ci->_r;\n+\n@@ -534,1 +530,6 @@\n-        pinned_old_regions->append(r);\n+        \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n+        \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n+        \/\/ GCs and hence are considered \"long lived\".\n+        _g1h->clear_region_attr(r);\n+        groups_to_abandon.append(group);\n+        remove_from_retained.append(group);\n@@ -539,1 +540,1 @@\n-    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+    if (fits_in_remaining_time || (num_expensive_regions < min_regions)) {\n@@ -542,1 +543,1 @@\n-        num_expensive_regions_selected++;\n+        num_expensive_regions++;\n@@ -544,2 +545,5 @@\n-      initial_old_regions->append(r);\n-      num_initial_regions_selected++;\n+\n+      add_group_to_collection_set(group);\n+      remove_from_retained.append(group);\n+\n+      num_initial_regions += group->length();\n@@ -547,0 +551,4 @@\n+      \/\/ Prepare optional collection region.\n+      _optional_groups.append(group);\n+      prepare_optional_group(group, num_optional_regions);\n+      num_optional_regions += group->length();\n@@ -548,2 +556,0 @@\n-      _optional_old_regions.append(r);\n-      num_optional_regions_selected++;\n@@ -558,2 +564,1 @@\n-  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n-  if (num_regions_selected == retained_list->length()) {\n+  if (num_initial_regions == retained_groups->num_regions()) {\n@@ -562,1 +567,2 @@\n-  if (num_expensive_regions_selected > 0) {\n+\n+  if (num_expensive_regions > 0) {\n@@ -564,1 +570,1 @@\n-                              num_expensive_regions_selected);\n+                              num_expensive_regions);\n@@ -567,0 +573,6 @@\n+  \/\/ Remove groups from retained and also do some bookkeeping on CandidateOrigin\n+  \/\/ for the regions in these groups.\n+  candidates()->remove(&remove_from_retained);\n+\n+  groups_to_abandon.clear(true \/* uninstall_group_cardset *\/);\n+\n@@ -570,1 +582,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n+                            num_initial_regions, num_optional_regions, num_pinned_regions,\n@@ -574,3 +586,3 @@\n-void G1CollectionSet::select_candidates_from_optional_regions(double time_remaining_ms,\n-                                                              G1CollectionCandidateRegionList* selected_regions) {\n-  assert(optional_region_length() > 0,\n+double G1CollectionSet::select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected) {\n+\n+  assert(_optional_groups.num_regions() > 0,\n@@ -579,0 +591,1 @@\n+  uint num_groups_selected = 0;\n@@ -580,0 +593,3 @@\n+  G1CSetCandidateGroupList selected;\n+  for (G1CSetCandidateGroup* group : _optional_groups) {\n+    double predicted_time_ms = group->predict_group_total_time_ms();\n@@ -581,6 +597,3 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    double prediction_ms = _policy->predict_region_total_time_ms(r, false);\n-\n-    if (prediction_ms > time_remaining_ms) {\n-      log_debug(gc, ergo, cset)(\"Prediction %.3fms for region %u does not fit remaining time: %.3fms.\",\n-                                prediction_ms, r->hrm_index(), time_remaining_ms);\n+    if (predicted_time_ms > time_remaining_ms) {\n+      log_debug(gc, ergo, cset)(\"Prediction %.3fms for group with %u regions does not fit remaining time: %.3fms.\",\n+                                predicted_time_ms, group->length(), time_remaining_ms);\n@@ -589,1 +602,0 @@\n-    \/\/ This region will be included in the next optional evacuation.\n@@ -591,2 +603,2 @@\n-    total_prediction_ms += prediction_ms;\n-    time_remaining_ms -= prediction_ms;\n+    total_prediction_ms += predicted_time_ms;\n+    time_remaining_ms -= predicted_time_ms;\n@@ -594,1 +606,5 @@\n-    selected_regions->append(r);\n+    num_regions_selected += group->length();\n+    num_groups_selected++;\n+\n+    add_group_to_collection_set(group);\n+    selected.append(group);\n@@ -597,0 +613,20 @@\n+  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  \/\/ Remove selected groups from candidate list.\n+  if (num_groups_selected > 0) {\n+    _optional_groups.remove(&selected);\n+    candidates()->remove(&selected);\n+  }\n+  return total_prediction_ms;\n+}\n+\n+uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+  uint optional_regions_count = num_optional_regions();\n+  assert(optional_regions_count > 0,\n+         \"Should only be called when there are optional regions\");\n+\n+  uint num_regions_selected = 0;\n+\n+  double total_prediction_ms = select_candidates_from_optional_groups(time_remaining_ms, num_regions_selected);\n+\n+  time_remaining_ms -= total_prediction_ms;\n+\n@@ -598,1 +634,2 @@\n-                            selected_regions->length(), _optional_old_regions.length(), total_prediction_ms);\n+                            num_regions_selected, optional_regions_count, total_prediction_ms);\n+  return num_regions_selected;\n@@ -601,3 +638,4 @@\n-void G1CollectionSet::prepare_optional_regions(G1CollectionCandidateRegionList* regions){\n-  uint cur_index = 0;\n-  for (G1HeapRegion* r : *regions) {\n+void G1CollectionSet::prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n+\n@@ -608,1 +646,0 @@\n-\n@@ -613,10 +650,6 @@\n-void G1CollectionSet::move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n-\n-  for (G1HeapRegion* r : *regions) {\n-    assert(r->has_pinned_objects(), \"must be pinned\");\n-    assert(r->rem_set()->is_complete(), \"must be complete\");\n-    candidates()->add_retained_region_unsorted(r);\n+void G1CollectionSet::add_group_to_collection_set(G1CSetCandidateGroup* gr) {\n+  for (G1CollectionSetCandidateInfo ci : *gr) {\n+    G1HeapRegion* r = ci._r;\n+    r->uninstall_cset_group();\n+    assert(r->rem_set()->is_complete(), \"must be\");\n+    add_region_to_collection_set(r);\n@@ -624,1 +657,1 @@\n-  candidates()->sort_by_efficiency();\n+  _collection_set_groups.append(gr);\n@@ -627,10 +660,4 @@\n-void G1CollectionSet::drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions) {\n-  if (regions->length() == 0) {\n-    return;\n-  }\n-  candidates()->remove(regions);\n-\n-  \/\/ We can now drop these region's remembered sets.\n-  for (G1HeapRegion* r : *regions) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n+void G1CollectionSet::add_region_to_collection_set(G1HeapRegion* r) {\n+  _g1h->clear_region_attr(r);\n+  assert(r->rem_set()->is_complete(), \"Remset for region %u complete\", r->hrm_index());\n+  add_old_region(r);\n@@ -647,7 +674,1 @@\n-  G1CollectionCandidateRegionList selected_regions;\n-  select_candidates_from_optional_regions(remaining_pause_time,\n-                                          &selected_regions);\n-\n-  move_candidates_to_collection_set(&selected_regions);\n-\n-  _optional_old_regions.remove_prefix(&selected_regions);\n+  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n@@ -655,0 +676,1 @@\n+  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -659,1 +681,1 @@\n-  return selected_regions.length() > 0;\n+  return num_regions_selected > 0;\n@@ -663,7 +685,13 @@\n-  for (G1HeapRegion* r : _optional_old_regions) {\n-    pss->record_unused_optional_region(r);\n-    \/\/ Clear collection set marker and make sure that the remembered set information\n-    \/\/ is correct as we still need it later.\n-    _g1h->clear_region_attr(r);\n-    _g1h->register_region_with_region_attr(r);\n-    r->clear_index_in_opt_cset();\n+  if (_optional_groups.length() > 0) {\n+    auto reset = [&] (G1HeapRegion* r) {\n+      pss->record_unused_optional_region(r);\n+      \/\/ Clear collection set marker and make sure that the remembered set information\n+      \/\/ is correct as we still need it later.\n+      _g1h->clear_region_attr(r);\n+      _g1h->register_region_with_region_attr(r);\n+      r->clear_index_in_opt_cset();\n+    };\n+\n+    _optional_groups.iterate(reset);\n+    \/\/ Remove groups from list without deleting the groups or clearing the associated cardsets.\n+    _optional_groups.remove_selected(_optional_groups.length(), _optional_groups.num_regions());\n@@ -671,1 +699,0 @@\n-  _optional_old_regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":201,"deletions":174,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -149,0 +149,8 @@\n+  \/\/ Old gen groups selected for evacuation.\n+  G1CSetCandidateGroupList _collection_set_groups;\n+\n+  \/\/ Groups are added to the collection set in increments when performing optional evacuations.\n+  \/\/ We use the value below to track these increments.\n+  uint _selected_groups_cur_length;\n+  uint _selected_groups_inc_part_start;\n+\n@@ -155,1 +163,1 @@\n-  G1CollectionCandidateRegionList _optional_old_regions;\n+  G1CSetCandidateGroupList _optional_groups;\n@@ -176,10 +184,14 @@\n-  void move_candidates_to_collection_set(G1CollectionCandidateRegionList* regions);\n-  \/\/ Prepares old regions in the given set for optional collection later. Does not\n-  \/\/ add the region to collection set yet.\n-  void prepare_optional_regions(G1CollectionCandidateRegionList* regions);\n-  \/\/ Moves given old regions from the marking candidates to the retained candidates.\n-  \/\/ This makes sure that marking candidates will not remain there to unnecessarily\n-  \/\/ prolong the mixed phase.\n-  void move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions);\n-  \/\/ Removes the given list of regions from the retained candidates.\n-  void drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions);\n+  void prepare_optional_group(G1CSetCandidateGroup* gr, uint cur_index);\n+\n+  void add_group_to_collection_set(G1CSetCandidateGroup* gr);\n+\n+  void add_region_to_collection_set(G1HeapRegion* r);\n+\n+  double select_candidates_from_marking(double time_remaining_ms);\n+\n+  void select_candidates_from_retained(double time_remaining_ms);\n+\n+  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number  of actually selected regions.\n+  uint select_optional_collection_set_regions(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n@@ -199,16 +211,0 @@\n-  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n-  \/\/ the given candidate list and the remaining time.\n-  \/\/ Returns the remaining time.\n-  double select_candidates_from_marking(double time_remaining_ms,\n-                                        G1CollectionCandidateRegionList* initial_old_regions,\n-                                        G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  void select_candidates_from_retained(double time_remaining_ms,\n-                                       G1CollectionCandidateRegionList* initial_old_regions,\n-                                       G1CollectionCandidateRegionList* pinned_old_regions);\n-\n-  \/\/ Calculate the number of optional regions from the given collection set candidates,\n-  \/\/ the remaining time and the maximum number of these regions.\n-  void select_candidates_from_optional_regions(double time_remaining_ms,\n-                                               G1CollectionCandidateRegionList* selected);\n-\n@@ -235,0 +231,5 @@\n+  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n+  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n+\n+  void prepare_groups_for_scan();\n+\n@@ -246,1 +247,3 @@\n-  uint optional_region_length() const { return _optional_old_regions.length(); }\n+  uint num_optional_regions() const { return _optional_groups.num_regions(); }\n+\n+  bool only_contains_young_regions() const { return (initial_old_region_length() + num_optional_regions()) == 0; }\n@@ -248,1 +251,2 @@\n-  bool only_contains_young_regions() const { return (initial_old_region_length() + optional_region_length()) == 0; }\n+  template <class CardOrRangeVisitor>\n+  inline void merge_cardsets_for_collection_groups(CardOrRangeVisitor& cl, uint worker_id, uint num_workers);\n@@ -258,1 +262,5 @@\n-  void update_incremental_marker() { _inc_build_state = Active; _inc_part_start = _collection_set_cur_length; }\n+  void update_incremental_marker() {\n+    _inc_build_state = Active;\n+    _inc_part_start = _collection_set_cur_length;\n+    _selected_groups_inc_part_start = _selected_groups_cur_length;\n+  }\n@@ -271,0 +279,2 @@\n+  uint collection_groups_increment_length() const { return _selected_groups_cur_length - _selected_groups_inc_part_start; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+#define SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1HeapRegionRemSet.hpp\"\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CollectionSet::merge_cardsets_for_collection_groups(CardOrRangeVisitor& cl, uint worker_id, uint num_workers) {\n+  uint length = collection_groups_increment_length();\n+  uint offset =  _selected_groups_inc_part_start;\n+  if (length == 0) {\n+    return;\n+  }\n+\n+  uint start_pos = (worker_id * length) \/ num_workers;\n+  uint cur_pos = start_pos;\n+  uint count = 0;\n+  do {\n+    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    cur_pos++;\n+    count++;\n+    if (cur_pos == length) {\n+      cur_pos = 0;\n+    }\n+  } while (cur_pos != start_pos);\n+}\n+#endif \/* SHARE_GC_G1_G1COLLECTIONSET_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/bitMap.inline.hpp\"\n@@ -31,1 +30,1 @@\n-G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2, mtGC) { }\n+uint G1CSetCandidateGroup::_next_group_id = 2;\n@@ -33,2 +32,8 @@\n-void G1CollectionCandidateList::set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos) {\n-  assert(_candidates.is_empty(), \"must be\");\n+G1CSetCandidateGroup::G1CSetCandidateGroup(G1CardSetConfiguration* config, G1MonotonicArenaFreePool* card_set_freelist_pool, uint group_id) :\n+  _candidates(4, mtGCCardSet),\n+  _card_set_mm(config, card_set_freelist_pool),\n+  _card_set(config, &_card_set_mm),\n+  _reclaimable_bytes(size_t(0)),\n+  _gc_efficiency(0.0),\n+  _group_id(group_id)\n+{ }\n@@ -36,3 +41,3 @@\n-  GrowableArrayFromArray<G1CollectionSetCandidateInfo> a(candidate_infos, (int)num_infos);\n-  _candidates.appendAll(&a);\n-}\n+G1CSetCandidateGroup::G1CSetCandidateGroup() :\n+  G1CSetCandidateGroup(G1CollectedHeap::heap()->card_set_config(), G1CollectedHeap::heap()->card_set_freelist_pool(), _next_group_id++)\n+{ }\n@@ -40,3 +45,3 @@\n-void G1CollectionCandidateList::append_unsorted(G1HeapRegion* r) {\n-  G1CollectionSetCandidateInfo c(r, r->calc_gc_efficiency());\n-  _candidates.append(c);\n+void G1CSetCandidateGroup::add(G1HeapRegion* hr) {\n+  G1CollectionSetCandidateInfo c(hr);\n+  add(c);\n@@ -45,2 +50,4 @@\n-void G1CollectionCandidateList::sort_by_efficiency() {\n-  _candidates.sort(compare_gc_efficiency);\n+void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n+  G1HeapRegion* hr = hr_info._r;\n+  _candidates.append(hr_info);\n+  hr->install_cset_group(this);\n@@ -49,6 +56,6 @@\n-void G1CollectionCandidateList::remove(G1CollectionCandidateRegionList* other) {\n-  guarantee((uint)_candidates.length() >= other->length(), \"must be\");\n-\n-  if (other->length() == 0) {\n-    \/\/ Nothing to remove or nothing in the original set.\n-    return;\n+void G1CSetCandidateGroup::calculate_efficiency() {\n+  _reclaimable_bytes = 0;\n+  uint num_candidates = _candidates.length();\n+  for (uint i = 0; i < num_candidates; i++) {\n+    G1HeapRegion* hr = region_at(i);\n+    _reclaimable_bytes += hr->reclaimable_bytes();\n@@ -56,0 +63,2 @@\n+  _gc_efficiency = _reclaimable_bytes \/ predict_group_total_time_ms();\n+}\n@@ -57,4 +66,2 @@\n-  \/\/ Create a list from scratch, copying over the elements from the candidate\n-  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n-  int new_length = _candidates.length() - other->length();\n-  GrowableArray<G1CollectionSetCandidateInfo> new_list(new_length, mtGC);\n+size_t G1CSetCandidateGroup::liveness() const {\n+  size_t capacity = length() * G1HeapRegion::GrainBytes;\n@@ -62,1 +69,2 @@\n-  uint other_idx = 0;\n+  return (size_t) ceil(((capacity - _reclaimable_bytes) * 100.0) \/ capacity);\n+}\n@@ -64,5 +72,6 @@\n-  for (uint candidate_idx = 0; candidate_idx < (uint)_candidates.length(); candidate_idx++) {\n-    if ((other_idx == other->length()) || _candidates.at(candidate_idx)._r != other->at(other_idx)) {\n-      new_list.append(_candidates.at(candidate_idx));\n-    } else {\n-      other_idx++;\n+void G1CSetCandidateGroup::clear(bool uninstall_group_cardset) {\n+  if (uninstall_group_cardset) {\n+    for (G1CollectionSetCandidateInfo ci : _candidates) {\n+      G1HeapRegion* r = ci._r;\n+      r->uninstall_cset_group();\n+      r->rem_set()->clear(true \/* only_cardset *\/);\n@@ -71,7 +80,1 @@\n-  _candidates.swap(&new_list);\n-\n-  verify();\n-  assert(_candidates.length() == new_length, \"must be %u %u\", _candidates.length(), new_length);\n-}\n-\n-void G1CollectionCandidateList::clear() {\n+  _card_set.clear();\n@@ -81,11 +84,14 @@\n-#ifndef PRODUCT\n-void G1CollectionCandidateList::verify() {\n-  G1CollectionSetCandidateInfo* prev = nullptr;\n-\n-  for (uint i = 0; i < (uint)_candidates.length(); i++) {\n-    G1CollectionSetCandidateInfo& ci = _candidates.at(i);\n-    assert(prev == nullptr || prev->_gc_efficiency >= ci._gc_efficiency,\n-           \"Stored gc efficiency must be descending from region %u to %u\",\n-           prev->_r->hrm_index(), ci._r->hrm_index());\n-    prev = &ci;\n-    assert(ci._r->rem_set()->is_tracked(), \"remset for region %u must be tracked\", ci._r->hrm_index());\n+double G1CSetCandidateGroup::predict_group_total_time_ms() const {\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+  double predicted_copy_time_ms = 0.0;\n+  double predict_code_root_scan_time_ms = 0.0;\n+  size_t predict_bytes_to_copy = 0.0;\n+\n+  for (G1CollectionSetCandidateInfo ci : _candidates) {\n+    G1HeapRegion* r = ci._r;\n+    assert(r->rem_set()->cset_group() == this, \"Must be!\");\n+\n+    predict_bytes_to_copy += p->predict_bytes_to_copy(r);\n+    predicted_copy_time_ms += p->predict_region_copy_time_ms(r, false \/* for_young_only_phase *\/);\n+    predict_code_root_scan_time_ms += p->predict_region_code_root_scan_time(r, false \/* for_young_only_phase *\/);\n@@ -93,2 +99,0 @@\n-}\n-#endif\n@@ -96,2 +100,13 @@\n-int G1CollectionCandidateList::compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n-  assert(ci1->_r != nullptr && ci2->_r != nullptr, \"Should not be!\");\n+  size_t card_rs_length = _card_set.occupied();\n+\n+  double merge_scan_time_ms = p->predict_merge_scan_time(card_rs_length);\n+  double non_young_other_time_ms = p->predict_non_young_other_time_ms(length());\n+\n+  log_trace(gc, ergo, cset) (\"Prediction for group with %u regions, card_rs_length %zu, merge_scan_time %.2fms, code_root_scan_time_ms %.2fms, evac_time_ms %.2fms, other_time %.2fms, bytes_to_cop %zu\",\n+                             length(),\n+                             card_rs_length,\n+                             merge_scan_time_ms,\n+                             predict_code_root_scan_time_ms,\n+                             predicted_copy_time_ms,\n+                             non_young_other_time_ms,\n+                             predict_bytes_to_copy);\n@@ -99,2 +114,9 @@\n-  double gc_eff1 = ci1->_gc_efficiency;\n-  double gc_eff2 = ci2->_gc_efficiency;\n+  return merge_scan_time_ms +\n+         predict_code_root_scan_time_ms +\n+         predicted_copy_time_ms +\n+         non_young_other_time_ms;\n+}\n+\n+int G1CSetCandidateGroup::compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2) {\n+  double gc_eff1 = (*gr1)->gc_efficiency();\n+  double gc_eff2 = (*gr2)->gc_efficiency();\n@@ -111,1 +133,1 @@\n-int G1CollectionCandidateList::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n+int G1CSetCandidateGroup::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -135,1 +157,1 @@\n-G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2, mtGC) { }\n+G1CSetCandidateGroupList::G1CSetCandidateGroupList() : _groups(8, mtGC), _num_regions(0) { }\n@@ -137,3 +159,5 @@\n-void G1CollectionCandidateRegionList::append(G1HeapRegion* r) {\n-  assert(!_regions.contains(r), \"must be\");\n-  _regions.append(r);\n+void G1CSetCandidateGroupList::append(G1CSetCandidateGroup* group) {\n+  assert(group->length() > 0, \"Do not add empty groups\");\n+  assert(!_groups.contains(group), \"Already added to list\");\n+  _groups.append(group);\n+  _num_regions += group->length();\n@@ -142,7 +166,8 @@\n-void G1CollectionCandidateRegionList::remove_prefix(G1CollectionCandidateRegionList* other) {\n-#ifdef ASSERT\n-  \/\/ Check that the given list is a prefix of this list.\n-  int i = 0;\n-  for (G1HeapRegion* r : *other) {\n-    assert(_regions.at(i) == r, \"must be in order, but element %d is not\", i);\n-    i++;\n+G1CSetCandidateGroup* G1CSetCandidateGroupList::at(uint index) {\n+  return _groups.at(index);\n+}\n+\n+void G1CSetCandidateGroupList::clear(bool uninstall_group_cardset) {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->clear(uninstall_group_cardset);\n+    delete gr;\n@@ -150,1 +175,17 @@\n-#endif\n+  _groups.clear();\n+  _num_regions = 0;\n+}\n+\n+void G1CSetCandidateGroupList::prepare_for_scan() {\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    gr->card_set()->reset_table_scanner_for_groups();\n+  }\n+}\n+\n+void G1CSetCandidateGroupList::remove_selected(uint count, uint num_regions) {\n+  _groups.remove_till(count);\n+  _num_regions -= num_regions;\n+}\n+\n+void G1CSetCandidateGroupList::remove(G1CSetCandidateGroupList* other) {\n+  guarantee((uint)_groups.length() >= other->length(), \"Other should be a subset of this list\");\n@@ -153,0 +194,1 @@\n+    \/\/ Nothing to remove or nothing in the original set.\n@@ -155,1 +197,19 @@\n-  _regions.remove_till(other->length());\n+\n+  \/\/ Create a list from scratch, copying over the elements from the candidate\n+  \/\/ list not in the other list. Finally deallocate and overwrite the old list.\n+  int new_length = _groups.length() - other->length();\n+  _num_regions = num_regions() - other->num_regions();\n+  GrowableArray<G1CSetCandidateGroup*> new_list(new_length, mtGC);\n+\n+  uint other_idx = 0;\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    if (other_idx == other->length() || gr != other->at(other_idx)) {\n+      new_list.append(gr);\n+    } else {\n+      other_idx++;\n+    }\n+  }\n+  _groups.swap(&new_list);\n+\n+  verify();\n+  assert(_groups.length() == new_length, \"Must be\");\n@@ -158,2 +218,2 @@\n-G1HeapRegion* G1CollectionCandidateRegionList::at(uint index) {\n-  return _regions.at(index);\n+void G1CSetCandidateGroupList::sort_by_efficiency() {\n+  _groups.sort(G1CSetCandidateGroup::compare_gc_efficiency);\n@@ -162,2 +222,9 @@\n-void G1CollectionCandidateRegionList::clear() {\n-  _regions.clear();\n+#ifndef PRODUCT\n+void G1CSetCandidateGroupList::verify() const {\n+  G1CSetCandidateGroup* prev = nullptr;\n+\n+  for (G1CSetCandidateGroup* gr : _groups) {\n+    assert(prev == nullptr || prev->gc_efficiency() >= gr->gc_efficiency(),\n+           \"Stored gc efficiency must be descending\");\n+    prev = gr;\n+  }\n@@ -165,0 +232,1 @@\n+#endif\n@@ -167,2 +235,0 @@\n-  _marking_regions(),\n-  _retained_regions(),\n@@ -170,0 +236,2 @@\n+  _from_marking_groups(),\n+  _retained_groups(),\n@@ -176,0 +244,2 @@\n+  _from_marking_groups.clear();\n+  _retained_groups.clear();\n@@ -191,2 +261,2 @@\n-  _marking_regions.clear();\n-  _retained_regions.clear();\n+  _retained_groups.clear(true \/* uninstall_group_cardset *\/);\n+  _from_marking_groups.clear(true \/* uninstall_group_cardset *\/);\n@@ -200,4 +270,2 @@\n-  G1CollectionCandidateListIterator iter = _marking_regions.begin();\n-  for (; iter != _marking_regions.end(); ++iter) {\n-    G1HeapRegion* hr = (*iter)->_r;\n-    (*iter)->_gc_efficiency = hr->calc_gc_efficiency();\n+  for (G1CSetCandidateGroup* gr : _from_marking_groups) {\n+    gr->calculate_efficiency();\n@@ -205,1 +273,1 @@\n-  _marking_regions.sort_by_efficiency();\n+  _from_marking_groups.sort_by_efficiency();\n@@ -207,1 +275,1 @@\n-  _marking_regions.verify();\n+  _from_marking_groups.verify();\n@@ -212,1 +280,4 @@\n-  assert(_marking_regions.length() == 0, \"must be empty before adding new ones\");\n+  if (num_infos == 0) {\n+    log_debug(gc, ergo, cset) (\"No regions selected from marking.\");\n+    return;\n+  }\n@@ -214,0 +285,1 @@\n+  assert(_from_marking_groups.length() == 0, \"must be empty at the start of a cycle\");\n@@ -216,1 +288,14 @@\n-  _marking_regions.set(candidate_infos, num_infos);\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  \/\/ During each Mixed GC, we must collect at least G1Policy::calc_min_old_cset_length regions to meet\n+  \/\/ the G1MixedGCCountTarget. For the first collection in a Mixed GC cycle, we can add all regions\n+  \/\/ required to meet this threshold to the same remset group. We are certain these will be collected in\n+  \/\/ the same MixedGC.\n+  uint group_limit = p->calc_min_old_cset_length(num_infos);\n+\n+  uint num_added_to_group = 0;\n+\n+  G1CSetCandidateGroup::reset_next_group_id();\n+  G1CSetCandidateGroup* current = nullptr;\n+\n+  current = new G1CSetCandidateGroup();\n+\n@@ -221,0 +306,13 @@\n+\n+    if (num_added_to_group == group_limit) {\n+      if (group_limit != G1OldCSetGroupSize) {\n+        group_limit = G1OldCSetGroupSize;\n+      }\n+\n+      _from_marking_groups.append(current);\n+\n+      current = new G1CSetCandidateGroup();\n+      num_added_to_group = 0;\n+    }\n+    current->add(candidate_infos[i]);\n+    num_added_to_group++;\n@@ -222,0 +320,6 @@\n+\n+  _from_marking_groups.append(current);\n+\n+  assert(_from_marking_groups.num_regions() == num_infos, \"Must be!\");\n+\n+  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_infos);\n@@ -230,9 +334,3 @@\n-  _marking_regions.verify();\n-  _retained_regions.sort_by_efficiency();\n-  _retained_regions.verify();\n-}\n-\n-void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n-  assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n-  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n-  _retained_regions.append_unsorted(r);\n+  _from_marking_groups.verify();\n+  _retained_groups.sort_by_efficiency();\n+  _retained_groups.verify();\n@@ -241,1 +339,1 @@\n-void G1CollectionSetCandidates::remove(G1CollectionCandidateRegionList* other) {\n+void G1CollectionSetCandidates::remove(G1CSetCandidateGroupList* other) {\n@@ -248,2 +346,2 @@\n-  G1CollectionCandidateRegionList other_marking_regions;\n-  G1CollectionCandidateRegionList other_retained_regions;\n+  G1CSetCandidateGroupList other_marking_groups;\n+  G1CSetCandidateGroupList other_retained_groups;\n@@ -251,1 +349,4 @@\n-  for (G1HeapRegion* r : *other) {\n+  for (G1CSetCandidateGroup* group : *other) {\n+    assert(group->length() > 0, \"Should not have empty groups\");\n+    \/\/ Regions in the same group have the same source (i.e from_marking or retained).\n+    G1HeapRegion* r = group->region_at(0);\n@@ -253,1 +354,1 @@\n-      other_marking_regions.append(r);\n+      other_marking_groups.append(group);\n@@ -255,1 +356,1 @@\n-      other_retained_regions.append(r);\n+      other_retained_groups.append(group);\n@@ -259,2 +360,2 @@\n-  _marking_regions.remove(&other_marking_regions);\n-  _retained_regions.remove(&other_retained_regions);\n+  _from_marking_groups.remove(&other_marking_groups);\n+  _retained_groups.remove(&other_retained_groups);\n@@ -262,2 +363,2 @@\n-  for (G1HeapRegion* r : *other) {\n-    assert(contains(r), \"must contain region %u\", r->hrm_index());\n+  other->iterate([&] (G1HeapRegion* r) {\n+    assert(contains(r), \"Must contain region %u\", r->hrm_index());\n@@ -265,1 +366,1 @@\n-  }\n+  });\n@@ -270,0 +371,10 @@\n+void G1CollectionSetCandidates::add_retained_region_unsorted(G1HeapRegion* r) {\n+  assert(!contains(r), \"Must not already contain region %u\", r->hrm_index());\n+  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n+\n+  G1CSetCandidateGroup* gr = new G1CSetCandidateGroup();\n+  gr->add(r);\n+\n+  _retained_groups.append(gr);\n+}\n+\n@@ -279,1 +390,1 @@\n-  return _marking_regions.length();\n+  return _from_marking_groups.num_regions();\n@@ -283,1 +394,1 @@\n-  return _retained_regions.length();\n+  return _retained_groups.num_regions();\n@@ -287,1 +398,1 @@\n-void G1CollectionSetCandidates::verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) {\n+void G1CollectionSetCandidates::verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) {\n@@ -290,2 +401,3 @@\n-  for (uint i = 0; i < (uint)list->length(); i++) {\n-    G1HeapRegion* r = list->at(i)._r;\n+  for (G1CSetCandidateGroup* gr : *list) {\n+    for (G1CollectionSetCandidateInfo ci : *gr) {\n+      G1HeapRegion* r = ci._r;\n@@ -293,7 +405,7 @@\n-    if (is_from_marking(r)) {\n-      from_marking++;\n-    }\n-    const uint hrm_index = r->hrm_index();\n-    assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n-           \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n-    assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n+      if (is_from_marking(r)) {\n+        from_marking++;\n+      }\n+      const uint hrm_index = r->hrm_index();\n+      assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n+             \"must be %u is %u\", hrm_index, (uint)_contains_map[hrm_index]);\n+      assert(verify_map[hrm_index] == CandidateOrigin::Invalid, \"already added\");\n@@ -301,1 +413,2 @@\n-    verify_map[hrm_index] = CandidateOrigin::Verify;\n+      verify_map[hrm_index] = CandidateOrigin::Verify;\n+    }\n@@ -313,1 +426,1 @@\n-  verify_helper(&_marking_regions, from_marking, verify_map);\n+  verify_helper(&_from_marking_groups, from_marking, verify_map);\n@@ -317,1 +430,1 @@\n-  verify_helper(&_retained_regions, from_marking_retained, verify_map);\n+  verify_helper(&_retained_groups, from_marking_retained, verify_map);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":230,"deletions":117,"binary":false,"changes":347,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"gc\/shared\/workerThread.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"utilities\/bitMap.hpp\"\n@@ -36,1 +35,0 @@\n-class G1CollectionCandidateList;\n@@ -38,0 +36,1 @@\n+class G1CSetCandidateGroupList;\n@@ -41,27 +40,0 @@\n-using G1CollectionCandidateRegionListIterator = GrowableArrayIterator<G1HeapRegion*>;\n-\n-\/\/ A set of G1HeapRegion*, a thin wrapper around GrowableArray.\n-class G1CollectionCandidateRegionList {\n-  GrowableArray<G1HeapRegion*> _regions;\n-\n-public:\n-  G1CollectionCandidateRegionList();\n-\n-  \/\/ Append a G1HeapRegion to the end of this list. The region must not be in the list\n-  \/\/ already.\n-  void append(G1HeapRegion* r);\n-  \/\/ Remove the given list of G1HeapRegion* from this list. The given list must be a prefix\n-  \/\/ of this list.\n-  void remove_prefix(G1CollectionCandidateRegionList* list);\n-\n-  \/\/ Empty contents of the list.\n-  void clear();\n-\n-  G1HeapRegion* at(uint index);\n-\n-  uint length() const { return (uint)_regions.length(); }\n-\n-  G1CollectionCandidateRegionListIterator begin() const { return _regions.begin(); }\n-  G1CollectionCandidateRegionListIterator end() const { return _regions.end(); }\n-};\n-\n@@ -70,1 +42,0 @@\n-  double _gc_efficiency;\n@@ -73,2 +44,2 @@\n-  G1CollectionSetCandidateInfo() : G1CollectionSetCandidateInfo(nullptr, 0.0) { }\n-  G1CollectionSetCandidateInfo(G1HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency), _num_unreclaimed(0) { }\n+  G1CollectionSetCandidateInfo() : G1CollectionSetCandidateInfo(nullptr) { }\n+  G1CollectionSetCandidateInfo(G1HeapRegion* r) : _r(r), _num_unreclaimed(0) { }\n@@ -82,3 +53,1 @@\n-class G1CollectionCandidateListIterator : public StackObj {\n-  G1CollectionCandidateList* _which;\n-  uint _position;\n+using G1CSetCandidateGroupIterator = GrowableArrayIterator<G1CollectionSetCandidateInfo>;\n@@ -86,5 +55,12 @@\n-public:\n-  G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position);\n-\n-  G1CollectionCandidateListIterator& operator++();\n-  G1CollectionSetCandidateInfo* operator*();\n+\/\/ G1CSetCandidateGroup groups candidate regions that will be selected for evacuation at the same time.\n+\/\/ Grouping occurs both for candidates from marking or regions retained during evacuation failure, but a group\n+\/\/ can not contain regions from both types of regions.\n+\/\/\n+\/\/ Humongous objects are excluded from the candidate groups because regions associated with these\n+\/\/ objects are never selected for evacuation.\n+\/\/\n+\/\/ All regions in the group share a G1CardSet instance, which tracks remembered set entries for the\n+\/\/ regions in the group. We do not have track to cross-region references for regions that are in the\n+\/\/ same group saving memory.\n+class G1CSetCandidateGroup : public CHeapObj<mtGCCardSet>{\n+  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n@@ -92,3 +68,1 @@\n-  bool operator==(const G1CollectionCandidateListIterator& rhs);\n-  bool operator!=(const G1CollectionCandidateListIterator& rhs);\n-};\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -96,4 +70,2 @@\n-\/\/ List of collection set candidates (regions with their efficiency) ordered by\n-\/\/ decreasing gc efficiency.\n-class G1CollectionCandidateList : public CHeapObj<mtGC> {\n-  friend class G1CollectionCandidateListIterator;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -101,1 +73,2 @@\n-  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n+  size_t _reclaimable_bytes;\n+  double _gc_efficiency;\n@@ -103,0 +76,8 @@\n+  \/\/ The _group_id is primarily used when printing out per-region liveness information,\n+  \/\/ making it easier to associate regions with their assigned G1CSetCandidateGroup, if any.\n+  \/\/ Note:\n+  \/\/ * _group_id 0 is reserved for special G1CSetCandidateGroups that hold only a single region,\n+  \/\/    such as G1CSetCandidateGroups for retained regions.\n+  \/\/ * _group_id 1 is reserved for the G1CSetCandidateGroup that contains all young regions.\n+  const uint _group_id;\n+  static uint _next_group_id;\n@@ -104,17 +85,5 @@\n-  G1CollectionCandidateList();\n-\n-  \/\/ Put the given set of candidates into this list, preserving the efficiency ordering.\n-  void set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos);\n-  \/\/ Add the given G1HeapRegion to this list at the end, (potentially) making the list unsorted.\n-  void append_unsorted(G1HeapRegion* r);\n-  \/\/ Restore sorting order by decreasing gc efficiency, using the existing efficiency\n-  \/\/ values.\n-  void sort_by_efficiency();\n-  \/\/ Removes any heap regions stored in this list also in the other list. The other\n-  \/\/ list may only contain regions in this list, sorted by gc efficiency. It need\n-  \/\/ not be a prefix of this list. Returns the number of regions removed.\n-  \/\/ E.g. if this list is \"A B G H\", the other list may be \"A G H\", but not \"F\" (not in\n-  \/\/ this list) or \"A H G\" (wrong order).\n-  void remove(G1CollectionCandidateRegionList* other);\n-\n-  void clear();\n+  G1CSetCandidateGroup();\n+  G1CSetCandidateGroup(G1CardSetConfiguration* config, G1MonotonicArenaFreePool* card_set_freelist_pool, uint group_id);\n+  ~G1CSetCandidateGroup() {\n+    assert(length() == 0, \"post condition!\");\n+  }\n@@ -122,1 +91,2 @@\n-  G1CollectionSetCandidateInfo& at(uint position) { return _candidates.at(position); }\n+  void add(G1HeapRegion* hr);\n+  void add(G1CollectionSetCandidateInfo& hr_info);\n@@ -126,1 +96,4 @@\n-  void verify() PRODUCT_RETURN;\n+  G1CardSet* card_set() { return &_card_set; }\n+  const G1CardSet* card_set() const { return &_card_set; }\n+\n+  uint group_id() const { return _group_id; }\n@@ -128,0 +101,3 @@\n+  void calculate_efficiency();\n+\n+  size_t liveness() const;\n@@ -131,1 +107,1 @@\n-  static int compare_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+  static int compare_gc_efficiency(G1CSetCandidateGroup** gr1, G1CSetCandidateGroup** gr2);\n@@ -135,2 +111,20 @@\n-  G1CollectionCandidateListIterator begin() {\n-    return G1CollectionCandidateListIterator(this, 0);\n+  double gc_efficiency() const { return _gc_efficiency; }\n+\n+  G1HeapRegion* region_at(uint i) const { return _candidates.at(i)._r; }\n+\n+  G1CollectionSetCandidateInfo* at(uint i) { return &_candidates.at(i); }\n+\n+  double predict_group_total_time_ms() const;\n+\n+  G1MonotonicArenaMemoryStats card_set_memory_stats() const {\n+    return _card_set_mm.memory_stats();\n+  }\n+\n+  void clear(bool uninstall_group_cardset = false);\n+\n+  G1CSetCandidateGroupIterator begin() const {\n+    return _candidates.begin();\n+  }\n+\n+  G1CSetCandidateGroupIterator end() const {\n+    return _candidates.end();\n@@ -139,2 +133,2 @@\n-  G1CollectionCandidateListIterator end() {\n-    return G1CollectionCandidateListIterator(this, length());\n+  static void reset_next_group_id() {\n+    _next_group_id = 2;\n@@ -144,5 +138,23 @@\n-\/\/ Iterator for G1CollectionSetCandidates. There are no guarantees on the order\n-\/\/ of the regions returned.\n-class G1CollectionSetCandidatesIterator : public StackObj {\n-  G1CollectionSetCandidates* _which;\n-    uint _position;\n+using G1CSetCandidateGroupListIterator = GrowableArrayIterator<G1CSetCandidateGroup*>;\n+\n+class G1CSetCandidateGroupList {\n+  GrowableArray<G1CSetCandidateGroup*> _groups;\n+  volatile uint _num_regions;\n+\n+public:\n+  G1CSetCandidateGroupList();\n+  void append(G1CSetCandidateGroup* group);\n+\n+  \/\/ Delete all groups from the list. The cardset cleanup for regions within the\n+  \/\/ groups could have been done elsewhere (e.g. when adding groups to the\n+  \/\/ collection set or to retained regions). The uninstall_group_cardset is set to\n+  \/\/ true if cleanup needs to happen as we clear the groups from the list.\n+  void clear(bool uninstall_group_cardset = false);\n+\n+  G1CSetCandidateGroup* at(uint index);\n+\n+  uint length() const { return (uint)_groups.length(); }\n+\n+  uint num_regions() const { return _num_regions; }\n+\n+  void remove_selected(uint count, uint num_regions);\n@@ -150,2 +162,14 @@\n-  public:\n-  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position);\n+  \/\/ Removes any candidate groups stored in this list and also in the other list. The other\n+  \/\/ list may only contain candidate groups in this list, sorted by gc efficiency. It need\n+  \/\/ not be a prefix of this list.\n+  \/\/ E.g. if this list is \"A B G H\", the other list may be \"A G H\", but not \"F\" (not in\n+  \/\/ this list) or \"A H G\" (wrong order).\n+  void remove(G1CSetCandidateGroupList* other);\n+\n+  void prepare_for_scan();\n+\n+  void sort_by_efficiency();\n+\n+  GrowableArray<G1CSetCandidateGroup*>*  groups() {\n+    return &_groups;\n+  }\n@@ -153,2 +177,1 @@\n-  G1CollectionSetCandidatesIterator& operator++();\n-  G1HeapRegion* operator*();\n+  void verify() const PRODUCT_RETURN;\n@@ -156,2 +179,10 @@\n-  bool operator==(const G1CollectionSetCandidatesIterator& rhs);\n-  bool operator!=(const G1CollectionSetCandidatesIterator& rhs);\n+  G1CSetCandidateGroupListIterator begin() const {\n+    return _groups.begin();\n+  }\n+\n+  G1CSetCandidateGroupListIterator end() const {\n+    return _groups.end();\n+  }\n+\n+  template<typename Func>\n+  void iterate(Func&& f) const;\n@@ -160,1 +191,1 @@\n-\/\/ Tracks all collection set candidates, i.e. regions that could\/should be evacuated soon.\n+\/\/ Tracks all collection set candidates, i.e. region groups that could\/should be evacuated soon.\n@@ -162,1 +193,1 @@\n-\/\/ These candidate regions are tracked in two list of regions, sorted by decreasing\n+\/\/ These candidate groups are tracked in two list of region groups, sorted by decreasing\n@@ -165,4 +196,4 @@\n-\/\/ * marking_regions: the set of regions selected by concurrent marking to be\n-\/\/                    evacuated to keep overall heap occupancy stable.\n-\/\/                    They are guaranteed to be evacuated and cleared out during\n-\/\/                    the mixed phase.\n+\/\/ * from_marking_groups: the set of region groups selected by concurrent marking to be\n+\/\/                        evacuated to keep overall heap occupancy stable.\n+\/\/                        They are guaranteed to be evacuated and cleared out during\n+\/\/                        the mixed phase.\n@@ -170,3 +201,3 @@\n-\/\/ * retained_regions: set of regions selected for evacuation during evacuation\n-\/\/                     failure.\n-\/\/                     Any young collection will try to evacuate them.\n+\/\/ * retained_groups: set of region groups selected for evacuation during evacuation\n+\/\/                    failure.\n+\/\/                    Any young collection will try to evacuate them.\n@@ -175,1 +206,0 @@\n-  friend class G1CollectionSetCandidatesIterator;\n@@ -184,3 +214,0 @@\n-  G1CollectionCandidateList _marking_regions;  \/\/ Set of regions selected by concurrent marking.\n-  G1CollectionCandidateList _retained_regions; \/\/ Set of regions selected from evacuation failed regions.\n-\n@@ -188,0 +215,5 @@\n+  G1CSetCandidateGroupList _from_marking_groups; \/\/ Set of regions selected by concurrent marking.\n+  \/\/ Set of regions retained due to evacuation failure. Groups added to this list\n+  \/\/ should contain only one region each, making it easier to evacuate retained regions\n+  \/\/ in any young collection.\n+  G1CSetCandidateGroupList _retained_groups;\n@@ -199,2 +231,2 @@\n-  G1CollectionCandidateList& marking_regions() { return _marking_regions; }\n-  G1CollectionCandidateList& retained_regions() { return _retained_regions; }\n+  G1CSetCandidateGroupList& from_marking_groups() { return _from_marking_groups; }\n+  G1CSetCandidateGroupList& retained_groups() { return _retained_groups; }\n@@ -222,1 +254,1 @@\n-  \/\/ Remove the given regions from the candidates. All given regions must be part\n+  \/\/ Remove the given groups from the candidates. All given regions must be part\n@@ -224,1 +256,1 @@\n-  void remove(G1CollectionCandidateRegionList* other);\n+  void remove(G1CSetCandidateGroupList* other);\n@@ -237,1 +269,1 @@\n-  void verify_helper(G1CollectionCandidateList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n+  void verify_helper(G1CSetCandidateGroupList* list, uint& from_marking, CandidateOrigin* verify_map) PRODUCT_RETURN;\n@@ -244,8 +276,2 @@\n-  \/\/ Iteration\n-  G1CollectionSetCandidatesIterator begin() {\n-    return G1CollectionSetCandidatesIterator(this, 0);\n-  }\n-\n-  G1CollectionSetCandidatesIterator end() {\n-    return G1CollectionSetCandidatesIterator(this, length());\n-  }\n+  template<typename Func>\n+  void iterate_regions(Func&& f) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":136,"deletions":110,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -32,38 +32,7 @@\n-inline G1CollectionCandidateListIterator::G1CollectionCandidateListIterator(G1CollectionCandidateList* which, uint position) :\n-  _which(which), _position(position) { }\n-\n-inline G1CollectionCandidateListIterator& G1CollectionCandidateListIterator::operator++() {\n-  assert(_position < _which->length(), \"must be\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1CollectionSetCandidateInfo* G1CollectionCandidateListIterator::operator*() {\n-  return &_which->_candidates.at(_position);\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator==(const G1CollectionCandidateListIterator& rhs) {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n-\n-inline bool G1CollectionCandidateListIterator::operator!=(const G1CollectionCandidateListIterator& rhs) {\n-  return !(*this == rhs);\n-}\n-\n-inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position) :\n-  _which(which), _position(position) {\n-}\n-\n-inline G1CollectionSetCandidatesIterator& G1CollectionSetCandidatesIterator::operator++() {\n-  assert(_position < _which->length(), \"must not be at end already\");\n-  _position++;\n-  return *this;\n-}\n-\n-inline G1HeapRegion* G1CollectionSetCandidatesIterator::operator*() {\n-  uint length = _which->marking_regions_length();\n-  if (_position < length) {\n-    return _which->_marking_regions.at(_position)._r;\n-  } else {\n-    return _which->_retained_regions.at(_position - length)._r;\n+template<typename Func>\n+void G1CSetCandidateGroupList::iterate(Func&& f) const {\n+  for (G1CSetCandidateGroup* group : _groups) {\n+    for (G1CollectionSetCandidateInfo ci : *group) {\n+      G1HeapRegion* r = ci._r;\n+      f(r);\n+    }\n@@ -73,4 +42,3 @@\n-inline bool G1CollectionSetCandidatesIterator::operator==(const G1CollectionSetCandidatesIterator& rhs)  {\n-  assert(_which == rhs._which, \"iterator belongs to different array\");\n-  return _position == rhs._position;\n-}\n+template<typename Func>\n+void G1CollectionSetCandidates::iterate_regions(Func&& f) const {\n+  _from_marking_groups.iterate(f);\n@@ -78,2 +46,1 @@\n-inline bool G1CollectionSetCandidatesIterator::operator!=(const G1CollectionSetCandidatesIterator& rhs)  {\n-  return !(*this == rhs);\n+  _retained_groups.iterate(f);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":11,"deletions":44,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-      _data[idx] = CandidateInfo(hr, 0.0);\n+      _data[idx] = CandidateInfo(hr);\n@@ -106,1 +106,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare_reclaimble_bytes);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CSetCandidateGroup::compare_reclaimble_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2983,0 +2983,5 @@\n+#define G1PPRL_GID_H_FORMAT           \"  %9s\"\n+#define G1PPRL_GID_FORMAT             \"  \" UINT32_FORMAT_W(9)\n+#define G1PPRL_LEN_FORMAT             \"  \" UINT32_FORMAT_W(14)\n+#define G1PPRL_LEN_H_FORMAT           \"  %14s\"\n+#define G1PPRL_GID_GCEFF_FORMAT       \"  %14.1f\"\n@@ -2995,1 +3000,0 @@\n-  _young_cardset_bytes_per_region(0),\n@@ -3006,7 +3010,0 @@\n-  uint num_young_regions = g1h->young_regions_count();\n-  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n-\n-  if (num_young_regions > 0) {\n-    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n-  }\n-\n@@ -3026,2 +3023,0 @@\n-                          G1PPRL_GCEFF_H_FORMAT\n-                          G1PPRL_BYTE_H_FORMAT\n@@ -3029,1 +3024,2 @@\n-                          G1PPRL_BYTE_H_FORMAT,\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_GID_H_FORMAT,\n@@ -3031,2 +3027,3 @@\n-                          \"used\", \"live\", \"gc-eff\",\n-                          \"remset\", \"state\", \"code-roots\");\n+                          \"used\", \"live\",\n+                          \"state\", \"code-roots\",\n+                          \"group-id\");\n@@ -3038,2 +3035,0 @@\n-                          G1PPRL_GCEFF_H_FORMAT\n-                          G1PPRL_BYTE_H_FORMAT\n@@ -3041,1 +3036,2 @@\n-                          G1PPRL_BYTE_H_FORMAT,\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_GID_H_FORMAT,\n@@ -3043,2 +3039,2 @@\n-                          \"(bytes)\", \"(bytes)\", \"(bytes\/ms)\",\n-                          \"(bytes)\", \"\", \"(bytes)\");\n+                          \"(bytes)\", \"(bytes)\",\n+                          \"\", \"(bytes)\", \"\");\n@@ -3058,1 +3054,0 @@\n-  double gc_eff          = r->calc_gc_efficiency();\n@@ -3062,1 +3057,1 @@\n-  FormatBuffer<16> gc_efficiency(\"\");\n+  uint cset_groud_gid     = 0;\n@@ -3064,2 +3059,2 @@\n-  if (r->is_young()) {\n-    remset_bytes = _young_cardset_bytes_per_region;\n+  if (r->rem_set()->is_added_to_cset_group()) {\n+    cset_groud_gid = r->rem_set()->cset_group_id();\n@@ -3074,6 +3069,0 @@\n-  if(gc_eff < 0) {\n-    gc_efficiency.append(\"-\");\n-  } else {\n-    gc_efficiency.append(G1PPRL_DOUBLE_FORMAT, gc_eff);\n-  }\n-\n@@ -3086,2 +3075,0 @@\n-                        G1PPRL_GCEFF_FORMAT\n-                        G1PPRL_BYTE_FORMAT\n@@ -3089,1 +3076,2 @@\n-                        G1PPRL_BYTE_FORMAT,\n+                        G1PPRL_BYTE_FORMAT\n+                        G1PPRL_GID_FORMAT,\n@@ -3091,2 +3079,3 @@\n-                        used_bytes, live_bytes, gc_efficiency.buffer(),\n-                        remset_bytes, remset_type, code_roots_bytes);\n+                        used_bytes, live_bytes,\n+                        remset_type, code_roots_bytes,\n+                        cset_groud_gid);\n@@ -3106,0 +3095,3 @@\n+\n+  do_cset_groups();\n+\n@@ -3123,0 +3115,74 @@\n+\n+void G1PrintRegionLivenessInfoClosure::do_cset_groups() {\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX);\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\" Collectionset Candidate Groups\");\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX \" Types: Y=Young Regions, M=From Marking Regions, R=Retained Regions\");\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\n+                          G1PPRL_GID_H_FORMAT\n+                          G1PPRL_LEN_H_FORMAT\n+                          G1PPRL_GCEFF_H_FORMAT\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_TYPE_H_FORMAT,\n+                          \"groud-id\", \"num-regions\",\n+                          \"gc-eff\", \"liveness\",\n+                          \"remset\", \"type\");\n+\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\n+                          G1PPRL_GID_H_FORMAT\n+                          G1PPRL_LEN_H_FORMAT\n+                          G1PPRL_GCEFF_H_FORMAT\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_BYTE_H_FORMAT\n+                          G1PPRL_TYPE_H_FORMAT,\n+                          \"\", \"\",\n+                          \"(bytes\/ms)\", \"%\",\n+                          \"(bytes)\", \"\");\n+\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  G1CSetCandidateGroup* young_only_cset_group =g1h->young_regions_cset_group();\n+\n+  _total_remset_bytes += young_only_cset_group->card_set()->mem_size();\n+\n+  log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\n+                          G1PPRL_GID_FORMAT\n+                          G1PPRL_LEN_FORMAT\n+                          G1PPRL_GCEFF_FORMAT\n+                          G1PPRL_BYTE_FORMAT\n+                          G1PPRL_BYTE_FORMAT\n+                          G1PPRL_TYPE_H_FORMAT,\n+                          young_only_cset_group->group_id(), young_only_cset_group->length(),\n+                          \"-\",\n+                          size_t(0), young_only_cset_group->card_set()->mem_size(),\n+                          \"Y\");\n+\n+  for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n+    _total_remset_bytes += group->card_set()->mem_size();\n+    log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\n+                            G1PPRL_GID_FORMAT\n+                            G1PPRL_LEN_FORMAT\n+                            G1PPRL_GID_GCEFF_FORMAT\n+                            G1PPRL_BYTE_FORMAT\n+                            G1PPRL_BYTE_FORMAT\n+                            G1PPRL_TYPE_H_FORMAT,\n+                            group->group_id(), group->length(),\n+                            group->gc_efficiency(),\n+                            group->liveness(), group->card_set()->mem_size(),\n+                            \"M\");\n+  }\n+\n+  for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->retained_groups()) {\n+    _total_remset_bytes += group->card_set()->mem_size();\n+    log_trace(gc, liveness)(G1PPRL_LINE_PREFIX\n+                            G1PPRL_GID_FORMAT\n+                            G1PPRL_LEN_FORMAT\n+                            G1PPRL_GID_GCEFF_FORMAT\n+                            G1PPRL_BYTE_FORMAT\n+                            G1PPRL_BYTE_FORMAT\n+                            G1PPRL_TYPE_H_FORMAT,\n+                            group->group_id(), group->length(),\n+                            group->gc_efficiency(),\n+                            group->liveness(), group->card_set()->mem_size(),\n+                            \"R\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":99,"deletions":33,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -976,2 +976,0 @@\n-  size_t _young_cardset_bytes_per_region;\n-\n@@ -985,0 +983,2 @@\n+  void do_cset_groups();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-  _heap->young_regions_cardset()->clear();\n+  _heap->young_regions_cset_group()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,4 @@\n-  hr->uninstall_group_cardset();\n+  if (!hr->is_humongous()) {\n+    hr->uninstall_cset_group();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  uninstall_group_cardset();\n+  uninstall_cset_group();\n@@ -140,12 +140,0 @@\n-double G1HeapRegion::calc_gc_efficiency() {\n-  \/\/ GC efficiency is the ratio of how much space would be\n-  \/\/ reclaimed over how long we predict it would take to reclaim it.\n-  G1Policy* policy = G1CollectedHeap::heap()->policy();\n-\n-  \/\/ Retrieve a prediction of the elapsed time for this region for\n-  \/\/ a mixed gc because the region will only be evacuated during a\n-  \/\/ mixed gc.\n-  double region_elapsed_time_ms = policy->predict_region_total_time_ms(this, false \/* for_young_only_phase *\/);\n-  return (double)reclaimable_bytes() \/ region_elapsed_time_ms;\n-}\n-\n@@ -194,0 +182,3 @@\n+  G1CSetCandidateGroup* cset_group = new G1CSetCandidateGroup();\n+  cset_group->add(this);\n+\n@@ -214,0 +205,7 @@\n+  if (is_starts_humongous()) {\n+    G1CSetCandidateGroup* cset_group = _rem_set->cset_group();\n+    assert(cset_group != nullptr, \"pre-condition %u missing cardset\", hrm_index());\n+    uninstall_cset_group();\n+    cset_group->clear();\n+    delete cset_group;\n+  }\n@@ -219,1 +217,1 @@\n-    uninstall_group_cardset();\n+    uninstall_cset_group();\n@@ -253,1 +251,1 @@\n-  _rem_set = new G1HeapRegionRemSet(this, config);\n+  _rem_set = new G1HeapRegionRemSet(this);\n@@ -603,1 +601,3 @@\n-      if (_from != _to && !_from->is_young() && _to->rem_set()->is_complete()) {\n+      if (_from != _to && !_from->is_young() &&\n+          _to->rem_set()->is_complete() &&\n+          _from->rem_set()->cset_group() != _to->rem_set()->cset_group()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class G1CSetCandidateGroup;\n@@ -491,2 +492,0 @@\n-  double calc_gc_efficiency();\n-\n@@ -512,2 +511,2 @@\n-  void install_group_cardset(G1CardSet* group_cardset);\n-  void uninstall_group_cardset();\n+  void install_cset_group(G1CSetCandidateGroup* cset_group);\n+  void uninstall_cset_group();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -514,2 +514,2 @@\n-inline void G1HeapRegion::install_group_cardset(G1CardSet* group_cardset) {\n-  _rem_set->install_group_cardset(group_cardset);\n+inline void G1HeapRegion::install_cset_group(G1CSetCandidateGroup* cset_group) {\n+  _rem_set->install_cset_group(cset_group);\n@@ -518,2 +518,2 @@\n-inline void G1HeapRegion::uninstall_group_cardset() {\n-  _rem_set->uninstall_group_cardset();\n+inline void G1HeapRegion::uninstall_cset_group() {\n+  _rem_set->uninstall_cset_group();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,5 +55,2 @@\n-void G1HeapRegionRemSet::uninstall_group_cardset() {\n-  if (_saved_card_set != nullptr) {\n-    _card_set = _saved_card_set;\n-    _saved_card_set = nullptr;\n-  }\n+void G1HeapRegionRemSet::uninstall_cset_group() {\n+  _cset_group = nullptr;\n@@ -62,2 +59,1 @@\n-G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr,\n-                                   G1CardSetConfiguration* config) :\n+G1HeapRegionRemSet::G1HeapRegionRemSet(G1HeapRegion* hr) :\n@@ -65,3 +61,1 @@\n-  _card_set_mm(config, G1CollectedHeap::heap()->card_set_freelist_pool()),\n-  _card_set(new G1CardSet(config, &_card_set_mm)),\n-  _saved_card_set(nullptr),\n+  _cset_group(nullptr),\n@@ -71,0 +65,4 @@\n+G1HeapRegionRemSet::~G1HeapRegionRemSet() {\n+  assert(!is_added_to_cset_group(), \"Still assigned to a CSet group\");\n+}\n+\n@@ -76,1 +74,0 @@\n-  assert(_saved_card_set == nullptr, \"pre-condition\");\n@@ -81,1 +78,6 @@\n-  _card_set->clear();\n+\n+  if (is_added_to_cset_group()) {\n+    card_set()->clear();\n+    assert(card_set()->occupied() == 0, \"Should be clear.\");\n+  }\n+\n@@ -87,1 +89,0 @@\n-  assert(occupied() == 0, \"Should be clear.\");\n@@ -92,1 +93,3 @@\n-  _card_set->reset_table_scanner();\n+  if (is_added_to_cset_group()) {\n+    card_set()->reset_table_scanner();\n+  }\n@@ -96,1 +99,2 @@\n-  return _card_set_mm.memory_stats();\n+  assert(is_added_to_cset_group(), \"pre-condition\");\n+  return cset_group()->card_set_memory_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -38,0 +39,1 @@\n+class G1CSetCandidateGroup;\n@@ -47,5 +49,2 @@\n-  G1CardSetMemoryManager _card_set_mm;\n-\n-  \/\/ The set of cards in the Java heap\n-  G1CardSet* _card_set;\n-  G1CardSet* _saved_card_set;\n+  \/\/ The collection set groups to which the region owning this RSet is assigned.\n+  G1CSetCandidateGroup* _cset_group;\n@@ -60,0 +59,10 @@\n+  G1CardSet* card_set() {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->card_set();\n+  }\n+\n+  const G1CardSet* card_set() const {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->card_set();\n+  }\n+\n@@ -61,2 +70,2 @@\n-  G1HeapRegionRemSet(G1HeapRegion* hr, G1CardSetConfiguration* config);\n-  ~G1HeapRegionRemSet() { delete _card_set; }\n+  G1HeapRegionRemSet(G1HeapRegion* hr);\n+  ~G1HeapRegionRemSet();\n@@ -65,1 +74,1 @@\n-    return _card_set->is_empty();\n+    return !is_added_to_cset_group() || card_set()->is_empty();\n@@ -68,3 +77,3 @@\n-  void install_group_cardset(G1CardSet* group_cardset) {\n-    assert(group_cardset != nullptr, \"pre-condition\");\n-    assert(_saved_card_set == nullptr, \"pre-condition\");\n+  void install_cset_group(G1CSetCandidateGroup* cset_group) {\n+    assert(cset_group != nullptr, \"pre-condition\");\n+    assert(_cset_group == nullptr, \"pre-condition\");\n@@ -72,2 +81,1 @@\n-    _saved_card_set = _card_set;\n-    _card_set = group_cardset;\n+    _cset_group = cset_group;\n@@ -76,1 +84,5 @@\n-  void uninstall_group_cardset();\n+  void uninstall_cset_group();\n+\n+  bool is_added_to_cset_group() const {\n+    return _cset_group != nullptr;\n+  }\n@@ -78,2 +90,11 @@\n-  bool has_group_cardset() {\n-    return _saved_card_set != nullptr;\n+  G1CSetCandidateGroup* cset_group() {\n+    return _cset_group;\n+  }\n+\n+  const G1CSetCandidateGroup* cset_group() const {\n+    return _cset_group;\n+  }\n+\n+  uint cset_group_id() const {\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return cset_group()->group_id();\n@@ -87,1 +108,1 @@\n-    return (code_roots_list_length() == 0) && _card_set->occupancy_less_or_equal_to(occ);\n+    return (code_roots_list_length() == 0) && card_set()->occupancy_less_or_equal_to(occ);\n@@ -100,1 +121,2 @@\n-    return _card_set->occupied();\n+    assert(is_added_to_cset_group(), \"pre-condition\");\n+    return card_set()->occupied();\n@@ -103,1 +125,0 @@\n-  G1CardSet* card_set() { return _card_set; }\n@@ -149,7 +170,1 @@\n-    return _card_set->mem_size()\n-           + (sizeof(G1HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n-           + code_roots_mem_size();\n-  }\n-\n-  size_t unused_mem_size() {\n-    return _card_set->unused_mem_size();\n+    return sizeof(G1HeapRegionRemSet) + code_roots_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":41,"deletions":26,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  iterate_for_merge(_card_set, cl);\n+  iterate_for_merge(card_set(), cl);\n@@ -128,0 +128,2 @@\n+  assert(is_added_to_cset_group(), \"pre-condition\");\n+\n@@ -140,1 +142,1 @@\n-  _card_set->add_card(to_card(from));\n+  card_set()->add_card(to_card(from));\n@@ -144,1 +146,1 @@\n-  return _card_set->contains_card(to_card(from));\n+  return card_set()->contains_card(to_card(from));\n@@ -148,1 +150,1 @@\n-  _card_set->print_info(st, to_card(from));\n+  card_set()->print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -153,1 +153,5 @@\n-    to_rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->cset_group() != to_rem_set->cset_group()) {\n+      to_rem_set->add_reference(p, _worker_id);\n+    }\n@@ -271,1 +275,5 @@\n-    rem_set->add_reference(p, _worker_id);\n+    G1HeapRegion* from = _g1h->heap_region_containing(p);\n+\n+    if (from->rem_set()->cset_group() != rem_set->cset_group()) {\n+      rem_set->add_reference(p, _worker_id);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    _max_num_optional_regions(collection_set->optional_region_length()),\n+    _max_num_optional_regions(collection_set->num_optional_regions()),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-                                     candidates()->marking_regions_length());\n+                                     candidates()->from_marking_groups().num_regions());\n@@ -493,4 +493,3 @@\n-  for (G1CollectionSetCandidateInfo* ci : candidates()->marking_regions()) {\n-    \/\/ We optimistically assume that any of these marking candidate regions will\n-    \/\/ not be pinned, so just consider them as normal.\n-    if (min_marking_candidates == 0) {\n+  uint selected_candidates = 0;\n+  for (G1CSetCandidateGroup* gr : candidates()->from_marking_groups()) {\n+    if (selected_candidates >= min_marking_candidates) {\n@@ -499,2 +498,2 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(ci->_r, false \/* for_young_only_phase *\/);\n-    min_marking_candidates--;\n+    predicted_region_evac_time_ms += gr->predict_group_total_time_ms();\n+    selected_candidates += gr->length();\n@@ -526,1 +525,1 @@\n-  G1CollectionCandidateList& list = candidates()->retained_regions();\n+  G1CSetCandidateGroupList* retained_groups = &candidates()->retained_groups();\n@@ -528,1 +527,1 @@\n-                               list.length());\n+                               retained_groups->num_regions());\n@@ -530,2 +529,3 @@\n-  for (G1CollectionSetCandidateInfo* ci : list) {\n-    G1HeapRegion* r = ci->_r;\n+  for (G1CSetCandidateGroup* group : *retained_groups) {\n+    assert(group->length() == 1, \"We should only have one region in a retained group\");\n+    G1HeapRegion* r = group->region_at(0); \/\/ We only have one region per group.\n@@ -542,1 +542,1 @@\n-    result += predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    result += group->predict_group_total_time_ms();\n@@ -547,1 +547,1 @@\n-                            num_regions, list.length(), num_pinned_regions, result);\n+                            num_regions, retained_groups->num_regions(), num_pinned_regions, result);\n@@ -1114,0 +1114,4 @@\n+double G1Policy::predict_non_young_other_time_ms(uint count) const {\n+  return _analytics->predict_non_young_other_time_ms(count);\n+}\n+\n@@ -1130,3 +1134,2 @@\n-double G1Policy::predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const {\n-  size_t card_rs_length = hr->rem_set()->occupied();\n-  size_t scan_card_num = _analytics->predict_scan_card_num(card_rs_length, for_young_only_phase);\n+double G1Policy::predict_merge_scan_time(size_t card_rs_length) const {\n+  size_t scan_card_num = _analytics->predict_scan_card_num(card_rs_length, false);\n@@ -1135,2 +1138,2 @@\n-    _analytics->predict_card_merge_time_ms(card_rs_length, for_young_only_phase) +\n-    _analytics->predict_card_scan_time_ms(scan_card_num, for_young_only_phase);\n+    _analytics->predict_card_merge_time_ms(card_rs_length, false) +\n+    _analytics->predict_card_scan_time_ms(scan_card_num, false);\n@@ -1146,21 +1149,0 @@\n-double G1Policy::predict_region_non_copy_time_ms(G1HeapRegion* hr,\n-                                                 bool for_young_only_phase) const {\n-\n-  double region_elapsed_time_ms = predict_region_merge_scan_time(hr, for_young_only_phase) +\n-                                  predict_region_code_root_scan_time(hr, for_young_only_phase);\n-  \/\/ The prediction of the \"other\" time for this region is based\n-  \/\/ upon the region type and NOT the GC type.\n-  if (hr->is_young()) {\n-    region_elapsed_time_ms += _analytics->predict_young_other_time_ms(1);\n-  } else {\n-    region_elapsed_time_ms += _analytics->predict_non_young_other_time_ms(1);\n-  }\n-  return region_elapsed_time_ms;\n-}\n-\n-double G1Policy::predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const {\n-  return\n-    predict_region_non_copy_time_ms(hr, for_young_only_phase) +\n-    predict_region_copy_time_ms(hr, for_young_only_phase);\n-}\n-\n@@ -1342,5 +1324,0 @@\n-  \/\/ Clear remembered sets of remaining candidate regions and the actual candidate\n-  \/\/ set.\n-  for (G1HeapRegion* r : *candidates()) {\n-    r->rem_set()->clear(true \/* only_cardset *\/);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":21,"deletions":44,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-class G1CollectionCandidateList;\n@@ -52,1 +51,0 @@\n-class G1CollectionCandidateRegionList;\n@@ -143,1 +141,0 @@\n-private:\n@@ -151,3 +148,0 @@\n-  \/\/ Merge-scan time for a region is handling card-based remembered sets of that region\n-  \/\/ (as a single unit).\n-  double predict_region_merge_scan_time(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -156,4 +150,0 @@\n-  \/\/ Non-copy time for a region is handling remembered sets and other time.\n-  double predict_region_non_copy_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n-\n-public:\n@@ -161,0 +151,1 @@\n+  double predict_merge_scan_time(size_t card_rs_length) const;\n@@ -163,0 +154,1 @@\n+  double predict_non_young_other_time_ms(uint count) const;\n@@ -166,3 +158,0 @@\n-  \/\/ Total time for a region is handling remembered sets (as a single unit), copying its live data\n-  \/\/ and other time.\n-  double predict_region_total_time_ms(G1HeapRegion* hr, bool for_young_only_phase) const;\n@@ -250,1 +239,0 @@\n-  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n@@ -255,0 +243,1 @@\n+  size_t predict_bytes_to_copy(G1HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1CollectionSet.inline.hpp\"\n@@ -1121,0 +1122,1 @@\n+    G1RemSetScanState* _scan_state;\n@@ -1145,1 +1147,4 @@\n-    G1ClearBitmapClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+    G1ClearBitmapClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :\n+      _g1h(g1h),\n+      _scan_state(scan_state)\n+    { }\n@@ -1159,0 +1164,1 @@\n+      _scan_state->add_all_dirty_region(hr->hrm_index());\n@@ -1163,16 +1169,0 @@\n-  \/\/ Helper to allow two closure to be applied when\n-  \/\/ iterating through the collection set.\n-  class G1CombinedClosure : public G1HeapRegionClosure {\n-    G1HeapRegionClosure* _closure1;\n-    G1HeapRegionClosure* _closure2;\n-  public:\n-    G1CombinedClosure(G1HeapRegionClosure* cl1, G1HeapRegionClosure* cl2) :\n-      _closure1(cl1),\n-      _closure2(cl2) { }\n-\n-    bool do_heap_region(G1HeapRegion* hr) {\n-      return _closure1->do_heap_region(hr) ||\n-             _closure2->do_heap_region(hr);\n-    }\n-  };\n-\n@@ -1397,2 +1387,1 @@\n-        G1ClearBitmapClosure clear(g1h);\n-        G1CombinedClosure combined(&merge, &clear);\n+        G1ClearBitmapClosure clear_bitmap(g1h, _scan_state);\n@@ -1404,1 +1393,3 @@\n-        g1h->collection_set_iterate_increment_from(&combined, nullptr, worker_id);\n+        g1h->collection_set()->merge_cardsets_for_collection_groups(merge, worker_id, _num_workers);\n+\n+        g1h->collection_set_iterate_increment_from(&clear_bitmap, nullptr, worker_id);\n@@ -1478,0 +1469,10 @@\n+  {\n+    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n+    \/\/ We only use young_rs_length statistics to estimate young regions length.\n+    g1h->policy()->record_card_rs_length(young_rs_length);\n+\n+    \/\/ Clear current young only collection set. Survivor regions will be added\n+    \/\/ to the set during evacuation.\n+    g1h->young_regions_cset_group()->clear();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -194,0 +194,6 @@\n+  size_t _max_code_root_mem_sz;\n+  G1HeapRegion* _max_code_root_mem_sz_region;\n+\n+  size_t _max_group_cardset_mem_sz;\n+  G1CSetCandidateGroup* _max_cardset_mem_sz_group;\n+\n@@ -201,2 +207,2 @@\n-  size_t _max_code_root_mem_sz;\n-  G1HeapRegion* _max_code_root_mem_sz_region;\n+  size_t max_group_cardset_mem_sz() const                 { return _max_group_cardset_mem_sz; }\n+  G1CSetCandidateGroup* max_cardset_mem_sz_group() const  { return _max_cardset_mem_sz_group; }\n@@ -214,1 +220,2 @@\n-    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(nullptr)\n+    _max_code_root_mem_sz(0), _max_code_root_mem_sz_region(nullptr),\n+    _max_group_cardset_mem_sz(0), _max_cardset_mem_sz_group(nullptr)\n@@ -219,17 +226,17 @@\n-\n-    size_t occupied_cards = hrrs->occupied();\n-    \/\/ G1HeapRegionRemSet::mem_size() includes the\n-    \/\/ size of the code roots\n-    size_t rs_unused_mem_sz = hrrs->unused_mem_size();\n-    size_t rs_mem_sz = hrrs->mem_size();\n-\n-    if (r->is_young()) {\n-      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n-      occupied_cards \/= num_young;\n-      rs_unused_mem_sz \/= num_young;\n-      rs_mem_sz \/= num_young;\n-    }\n-\n-    if (rs_mem_sz > _max_rs_mem_sz) {\n-      _max_rs_mem_sz = rs_mem_sz;\n-      _max_rs_mem_sz_region = r;\n+    size_t rs_mem_sz = 0;\n+    size_t rs_unused_mem_sz = 0;\n+    size_t occupied_cards = 0;\n+\n+    \/\/ Accumulate card set details for regions that are assigned to single region\n+    \/\/ groups. G1HeapRegionRemSet::mem_size() includes the size of the code roots\n+    if (hrrs->is_added_to_cset_group() && hrrs->cset_group()->length() == 1) {\n+      G1CardSet* card_set = hrrs->cset_group()->card_set();\n+\n+      rs_mem_sz = hrrs->mem_size() + card_set->mem_size();\n+      rs_unused_mem_sz = card_set->unused_mem_size();\n+      occupied_cards = hrrs->occupied();\n+\n+      if (rs_mem_sz > _max_rs_mem_sz) {\n+        _max_rs_mem_sz = rs_mem_sz;\n+        _max_rs_mem_sz_region = r;\n+      }\n@@ -265,0 +272,41 @@\n+  void do_cset_groups() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n+\n+    \/\/ If the group has only a single region, then stats were accumulated\n+    \/\/ during region iteration.\n+    if (young_only_cset_group->length() > 1) {\n+      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n+      size_t rs_mem_sz = young_only_card_set->mem_size();\n+      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n+      size_t occupied_cards = young_only_card_set->occupied();\n+\n+      _max_group_cardset_mem_sz = rs_mem_sz;\n+      _max_cardset_mem_sz_group = young_only_cset_group;\n+\n+      \/\/ Only update cardset details\n+      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+      _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+    }\n+\n+\n+    RegionTypeCounter* current = &_old;\n+    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n+      if (group->length() > 1) {\n+        G1CardSet* group_card_set = group->card_set();\n+        size_t rs_mem_sz = group_card_set->mem_size();\n+        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n+        size_t occupied_cards = group_card_set->occupied();\n+\n+        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n+          _max_group_cardset_mem_sz = rs_mem_sz;\n+          _max_cardset_mem_sz_group = group;\n+        }\n+\n+        \/\/ Only update cardset details\n+        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+      }\n+    }\n+  }\n+\n@@ -284,7 +332,19 @@\n-    \/\/ Largest sized rem set region statistics\n-    G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n-    out->print_cr(\"    Region with largest rem set = \" HR_FORMAT \", \"\n-                  \"size = %zu occupied = %zu\",\n-                  HR_FORMAT_PARAMS(max_rs_mem_sz_region()),\n-                  rem_set->mem_size(),\n-                  rem_set->occupied());\n+    \/\/ Largest sized single region rem set statistics\n+    if (max_rs_mem_sz_region() != nullptr) {\n+      G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+      out->print_cr(\"    Region with largest rem set = \" HR_FORMAT \", \"\n+                    \"size = %zu occupied = %zu\",\n+                    HR_FORMAT_PARAMS(max_rs_mem_sz_region()),\n+                    rem_set->mem_size(),\n+                    rem_set->occupied());\n+    }\n+\n+    if (max_cardset_mem_sz_group() != nullptr) {\n+      G1CSetCandidateGroup* cset_group = max_cardset_mem_sz_group();\n+      G1HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();\n+      out->print_cr(\"    Collectionset Candidate Group with largest cardset = %u:(%u regions), \"\n+                    \"size = %zu occupied = %zu\",\n+                    cset_group->group_id(), cset_group->length(),\n+                    cset_group->card_set()->mem_size(),\n+                    cset_group->card_set()->occupied());\n+    }\n@@ -335,0 +395,1 @@\n+  blk.do_cset_groups();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":88,"deletions":27,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -107,0 +107,11 @@\n+\n+    size_t remset_bytes = r->rem_set()->mem_size();\n+    size_t occupied = 0;\n+    \/\/ per region cardset details only valid if group contains a single region.\n+    if (r->rem_set()->is_added_to_cset_group() &&\n+        r->rem_set()->cset_group()->length() == 1 ) {\n+        G1CardSet *card_set = r->rem_set()->cset_group()->card_set();\n+        remset_bytes += card_set->mem_size();\n+        occupied = card_set->occupied();\n+    }\n+\n@@ -116,2 +127,2 @@\n-                                    r->rem_set()->occupied(),\n-                                    r->rem_set()->mem_size());\n+                                    occupied,\n+                                    remset_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-                                              collection_set()->optional_region_length());\n+                                              collection_set()->num_optional_regions());\n@@ -518,1 +518,1 @@\n-    sampled_card_set_stats.add(_g1h->young_regions_card_set_mm()->memory_stats());\n+    sampled_card_set_stats.add(_g1h->young_regions_card_set_memory_stats());\n@@ -793,1 +793,1 @@\n-  while (!evacuation_alloc_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_alloc_failed() && collection_set()->num_optional_regions() > 0) {\n@@ -801,1 +801,1 @@\n-                                collection_set()->optional_region_length(), time_left_ms);\n+                                collection_set()->num_optional_regions(), time_left_ms);\n@@ -992,1 +992,1 @@\n-  for (G1HeapRegion* r : *candidates) {\n+  candidates->iterate_regions([&] (G1HeapRegion* r) {\n@@ -994,1 +994,1 @@\n-  }\n+  });\n@@ -1114,1 +1114,1 @@\n-    bool may_do_optional_evacuation = collection_set()->optional_region_length() != 0;\n+    bool may_do_optional_evacuation = collection_set()->num_optional_regions() != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -109,2 +109,6 @@\n-    for (G1HeapRegion* r : *candidates) {\n-      _total.add(r->rem_set()->card_set_memory_stats());\n+    for (G1CSetCandidateGroup* gr : candidates->from_marking_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n+    }\n+\n+    for (G1CSetCandidateGroup* gr : candidates->retained_groups()) {\n+      _total.add(gr->card_set_memory_stats());\n@@ -620,1 +624,0 @@\n-  size_t _card_rs_length;      \/\/ (Card Set) Remembered set size\n@@ -630,1 +633,0 @@\n-      _card_rs_length(0),\n@@ -640,1 +642,0 @@\n-    _card_rs_length += other->_card_rs_length;\n@@ -655,4 +656,0 @@\n-    \/\/ Add the cards from the group cardsets.\n-    _card_rs_length += g1h->young_regions_cardset()->occupied();\n-\n-    policy->record_card_rs_length(_card_rs_length);\n@@ -684,4 +681,0 @@\n-\n-  void account_card_rs_length(G1HeapRegion* r) {\n-    _card_rs_length += r->rem_set()->occupied();\n-  }\n@@ -809,2 +802,0 @@\n-      \/\/ We only use card_rs_length statistics to estimate young regions length.\n-      stats()->account_card_rs_length(r);\n@@ -897,2 +888,0 @@\n-\n-    _g1h->young_regions_cardset()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -279,0 +279,8 @@\n+                                                                            \\\n+  product(uint, G1OldCSetGroupSize, 5, EXPERIMENTAL,                        \\\n+          \"The maximum number of old CSet regions in a collection group. \"  \\\n+          \"All regions in a group will be evacuated in the same GC pause.\"  \\\n+          \"The first group calculated after marking from marking \"          \\\n+          \"candidates may exceed this limit as it is calculated based on \"  \\\n+          \"G1MixedGCCountTarget.\")                                          \\\n+          range(1, 256)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-    private int expectedMarkingSkipEvents;      \/\/ How many times has the region from the \"marking\" collection set candidate set been \"skipped\".\n@@ -53,1 +52,1 @@\n-    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"marking\" collection set candidate set been put into the collection set.\n+    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"retained\" collection set candidate set been put into the collection set.\n@@ -56,1 +55,0 @@\n-                      int expectedMarkingSkipEvents,\n@@ -62,1 +60,0 @@\n-        this.expectedMarkingSkipEvents = expectedMarkingSkipEvents;\n@@ -119,1 +116,1 @@\n-        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Marking|Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n+        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n@@ -125,22 +122,0 @@\n-        for (int i = 0; i < expectedMarkingSkipEvents; i++) {\n-            expectMoreMatches(skipDropMatcher, \"expectedMarkingSkipEvents\");\n-            curGC = expectIncreasingGC(skipDropMatcher);\n-\n-            Asserts.assertEQ(\"Marking\", skipDropMatcher.group(2), \"Expected \\\"Marking\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n-            updateOrCompareCurRegion(\"MarkingSkip\", Integer.parseInt(skipDropMatcher.group(3)));\n-            Asserts.assertEQ(\"Skipping\", skipDropMatcher.group(4), \"Expected \\\"Skipping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n-\n-            while (true) {\n-                if (!reclaimMatcher.find()) {\n-                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n-                }\n-                if (reclaimMatcher.group(2).equals(\"retained\")) {\n-                    continue;\n-                }\n-                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n-                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n-                    Asserts.assertEQ(actual, 1, \"Expected number of pinned to be 1 after marking skip but is \" + actual);\n-                    break;\n-                }\n-            }\n-        }\n@@ -235,5 +210,5 @@\n-        \/\/ younGCsBeforeUnpin, expectedMarkingSkipEvents, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n-        testPinnedEvacuation(1, 1, 0, 0, 0, 1);\n-        testPinnedEvacuation(2, 1, 1, 0, 0, 1);\n-        testPinnedEvacuation(3, 1, 2, 0, 0, 1);\n-        testPinnedEvacuation(4, 1, 2, 1, 0, 0);\n+        \/\/ younGCsBeforeUnpin, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n+        testPinnedEvacuation(1, 0, 0, 0, 1);\n+        testPinnedEvacuation(2, 1, 0, 0, 1);\n+        testPinnedEvacuation(3, 2, 0, 0, 1);\n+        testPinnedEvacuation(4, 2, 1, 0, 0);\n@@ -255,1 +230,0 @@\n-                                             int expectedMarkingSkipEvents,\n@@ -281,1 +255,0 @@\n-                                                    expectedMarkingSkipEvents,\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":7,"deletions":34,"binary":false,"changes":41,"status":"modified"}]}