{"files":[{"patch":"@@ -312,1 +312,0 @@\n-  size_t bytes_to_copy = 0;\n@@ -314,1 +313,1 @@\n-                               _policy->predict_eden_copy_time_ms(eden_region_length, &bytes_to_copy);\n+                               _policy->predict_eden_copy_time_ms(eden_region_length);\n@@ -334,13 +333,10 @@\n-\/\/ The current mechanism skips evacuation of pinned old regions like g1 does for\n-\/\/ young regions:\n-\/\/ * evacuating pinned marking collection set candidate regions (available during mixed\n-\/\/   gc) like young regions would not result in any memory gain but only take additional\n-\/\/   time away from processing regions that would actually result in memory being freed.\n-\/\/   To advance mixed gc progress (we committed to evacuate all marking collection set\n-\/\/   candidate regions within the maximum number of mixed gcs in the phase), move them\n-\/\/   to the optional collection set candidates to reclaim them asap as time permits.\n-\/\/ * evacuating out retained collection set candidates would also just take up time with\n-\/\/   no actual space freed in old gen. Better to concentrate on others.\n-\/\/   Retained collection set candidates are aged out, ie. made to regular old regions\n-\/\/   without remembered sets after a few attempts to save computation costs of keeping\n-\/\/   them candidates for very long living pinned regions.\n+\/\/ The current mechanism for evacuting pinned old regions is a below:\n+\/\/ * pinned regions in marking collection set candidate (available during mixed gc) are evacuated like\n+\/\/   pinned young regions to avoid complexity of dealing with pinned regions that are part of a\n+\/\/   collection group sharing a single cardset. These regions will partially evacuated and added to the\n+\/\/   retained collection set by the handle evacuation failure mechanism.\n+\/\/ * evacuating pinned regions out of retained collection set candidates would also just take up time\n+\/\/   with no actual space freed in old gen. Better to concentrate on others. So we skipped over pinned\n+\/\/   regions in retained collection set candidates Retained collection set candidates are aged out, ie.\n+\/\/   made to regular old regions without remembered sets after a few attempts to save computation costs\n+\/\/   of keeping them candidates for very long living pinned regions.\n@@ -399,1 +395,0 @@\n-  uint max_optional_regions = max_old_cset_length - min_old_cset_length;\n@@ -405,1 +400,1 @@\n-                            \"Min %u regions, max %u regions, available %u regions\"\n+                            \"Min %u regions, max %u regions, available %u regions (%u groups), \"\n@@ -407,1 +402,2 @@\n-                            min_old_cset_length, max_old_cset_length, from_marking_groups->num_regions(), time_remaining_ms, optional_threshold_ms);\n+                            min_old_cset_length, max_old_cset_length, from_marking_groups->num_regions(), from_marking_groups->length(),\n+                            time_remaining_ms, optional_threshold_ms);\n@@ -480,1 +476,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u regions (%u groups), optional: %u regions (%u groups), \"\n@@ -482,1 +478,1 @@\n-                            num_inital_regions, num_optional_regions,\n+                            selected_groups.num_regions(), selected_groups.length(), _optional_groups.num_regions(), _optional_groups.length(),\n@@ -511,1 +507,1 @@\n-                            \"Min %u regions, available %u, \"\n+                            \"Min %u regions, available %u regions (%u groups), \"\n@@ -513,1 +509,2 @@\n-                            min_regions, retained_groups->num_regions(), time_remaining_ms, optional_time_remaining_ms);\n+                            min_regions, retained_groups->num_regions(), retained_groups->length(),\n+                            time_remaining_ms, optional_time_remaining_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -307,2 +307,2 @@\n-      if (group_limit != G1CSetCandidateGroup::GROUP_SIZE) {\n-        group_limit = G1CSetCandidateGroup::GROUP_SIZE;\n+      if (group_limit != G1OldCSetGroupSize) {\n+        group_limit = G1OldCSetGroupSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+\/\/ G1CSetCandidateGroup groups candidate regions that will be selected for evacuation at the same time.\n+\/\/ Regions that are added to groups are either candidates from marking or regions retained during\n+\/\/ evacuation failure.\n+\/\/\n+\/\/ Humongous objects are excluded from the candidate groups because regions associated with these\n+\/\/ objects are never selected for evacuation.\n+\/\/\n+\/\/ All regions in the group share a G1CardSet instance, which tracks remembered set entries for the\n+\/\/ regions in the group. We do not have track to cross-region references for regions that are in the\n+\/\/ same group.\n@@ -112,5 +122,0 @@\n-\n-  \/\/ Limit to the number regions in a collection group. We make an exception\n-  \/\/ for the first collection group to be as large as G1Policy::calc_min_old_cset_length\n-  \/\/ because we are certain that these regions have to be collected together.\n-  static const int GROUP_SIZE = 5;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -494,0 +494,1 @@\n+  uint selected_candidates = 0;\n@@ -495,1 +496,1 @@\n-    if (min_marking_candidates == 0) {\n+    if (selected_candidates >= min_marking_candidates) {\n@@ -499,1 +500,1 @@\n-    min_marking_candidates = min_marking_candidates > gr->length() ? (min_marking_candidates - gr->length()) : 0;\n+    selected_candidates += gr->length();\n@@ -1135,1 +1136,0 @@\n-  assert(!hr->is_young(), \"Sanity Check!\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1113,0 +1113,1 @@\n+    G1RemSetScanState* _scan_state;\n@@ -1137,1 +1138,4 @@\n-    G1ClearBitmapClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+    G1ClearBitmapClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state) :\n+      _g1h(g1h),\n+      _scan_state(scan_state)\n+    { }\n@@ -1151,0 +1155,1 @@\n+      _scan_state->add_all_dirty_region(hr->hrm_index());\n@@ -1155,16 +1160,0 @@\n-  \/\/ Helper to allow two closure to be applied when\n-  \/\/ iterating through the collection set.\n-  class G1CombinedClosure : public G1HeapRegionClosure {\n-    G1HeapRegionClosure* _closure1;\n-    G1HeapRegionClosure* _closure2;\n-  public:\n-    G1CombinedClosure(G1HeapRegionClosure* cl1, G1HeapRegionClosure* cl2) :\n-      _closure1(cl1),\n-      _closure2(cl2) { }\n-\n-    bool do_heap_region(G1HeapRegion* hr) {\n-      return _closure1->do_heap_region(hr) ||\n-             _closure2->do_heap_region(hr);\n-    }\n-  };\n-\n@@ -1389,2 +1378,1 @@\n-        G1ClearBitmapClosure clear(g1h);\n-        G1CombinedClosure combined(&merge, &clear);\n+        G1ClearBitmapClosure clear_bitmap(g1h, _scan_state);\n@@ -1398,1 +1386,1 @@\n-        g1h->collection_set_iterate_increment_from(&combined, nullptr, worker_id);\n+        g1h->collection_set_iterate_increment_from(&clear_bitmap, nullptr, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-        guarantee(!hr->rem_set()->has_group_cardset(), \"double adding\");\n+        guarantee(!hr->rem_set()->has_group_cardset(), \"Humongous regions should not have group card sets\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -279,0 +279,6 @@\n+                                                                            \\\n+  product(uint, G1OldCSetGroupSize, 5, EXPERIMENTAL,         \\\n+          \"The maximum number of old CSet regions in a collection group. \"  \\\n+          \"These will be evacuated in the same GC pause. The first group \"  \\\n+          \"may exceed this limit depending on G1MixedGCCountTarget.\")       \\\n+          range(1, 256)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}