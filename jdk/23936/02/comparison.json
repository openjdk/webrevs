{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,2 +169,1 @@\n-                    throw new PackagerException(\n-                           \"ERR_MissingArgument\", \"--input\");\n+                    throw new PackagerException(\"error.no-input-parameter\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,1 @@\n-                                throw new IllegalArgumentException(MessageFormat.format(I18N.\n-                                        getString(\"error.version-string-zero-length-component\"),\n-                                        version));\n+                                ds.throwException();\n@@ -80,2 +78,1 @@\n-                throw new IllegalArgumentException(MessageFormat.format(I18N.getString(\n-                        \"error.version-string-invalid-component\"), version, suffix));\n+                ds.throwException();\n@@ -92,1 +89,1 @@\n-        public String getNextDigits() {\n+        String getNextDigits() {\n@@ -133,1 +130,1 @@\n-        public String getUnprocessedString() {\n+        String getUnprocessedString() {\n@@ -137,0 +134,19 @@\n+        void throwException() {\n+            final String tail;\n+            if (lastDotPos >= 0) {\n+                tail = input.substring(lastDotPos + 1);\n+            } else {\n+                tail = getUnprocessedString();\n+            }\n+\n+            final String errMessage;\n+            if (tail.isEmpty()) {\n+                errMessage = MessageFormat.format(I18N.getString(\n+                        \"error.version-string-zero-length-component\"), input);\n+            } else {\n+                errMessage = MessageFormat.format(I18N.getString(\n+                        \"error.version-string-invalid-component\"), input, tail);\n+            }\n+            throw new IllegalArgumentException(errMessage);\n+        }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DottedVersion.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,4 +188,0 @@\n-        if (mainJarDir == null && launcherData.qualifiedClassName == null) {\n-            throw new ConfigException(I18N.getString(\"error.no-input-parameter\"),\n-                    null);\n-        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public final class TokenReplace {\n+\n+    private record TokenCut(String[] main, String[] sub) {\n+        static String[] orderTokens(String... tokens) {\n+            if (tokens.length == 0) {\n+                throw new IllegalArgumentException(\"Empty token list\");\n+            }\n+\n+            final var orderedTokens = Stream.of(tokens)\n+                    .sorted(Comparator.<String>naturalOrder().thenComparing(Comparator.comparingInt(String::length)))\n+                    .distinct()\n+                    .toArray(String[]::new);\n+\n+            if (orderedTokens[0].isEmpty()) {\n+                throw new IllegalArgumentException(\"Empty token in the list of tokens\");\n+            }\n+\n+            return orderedTokens;\n+        }\n+\n+        static TokenCut createFromOrderedTokens(String... tokens) {\n+            final List<Integer> subTokens = new ArrayList<>();\n+\n+            for (var i = 0; i < tokens.length - 1; ++i) {\n+                final var x = tokens[i];\n+                for (var j = i + 1; j < tokens.length; ++j) {\n+                    final var y = tokens[j];\n+                    if (y.contains(x)) {\n+                        subTokens.add(i);\n+                    }\n+                }\n+            }\n+\n+            if (subTokens.isEmpty()) {\n+                return new TokenCut(tokens, null);\n+            } else {\n+                final var main = IntStream.range(0, tokens.length)\n+                        .mapToObj(Integer::valueOf)\n+                        .filter(Predicate.not(subTokens::contains))\n+                        .map(i -> {\n+                            return tokens[i];\n+                        }).toArray(String[]::new);\n+                final var sub = subTokens.stream().map(i -> {\n+                    return tokens[i];\n+                }).toArray(String[]::new);\n+                return new TokenCut(main, sub);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"TokenCut(main=%s, sub=%s)\", Arrays.toString(main), Arrays.toString(sub));\n+        }\n+    }\n+\n+    public TokenReplace(String... tokens) {\n+        tokens = TokenCut.orderTokens(tokens);\n+\n+        this.tokens = tokens;\n+        regexps = new ArrayList<>();\n+\n+        for(;;) {\n+            final var tokenCut = TokenCut.createFromOrderedTokens(tokens);\n+            regexps.add(Pattern.compile(Stream.of(tokenCut.main()).map(Pattern::quote).collect(joining(\"|\", \"(\", \")\"))));\n+\n+            if (tokenCut.sub() == null) {\n+                break;\n+            }\n+\n+            tokens = tokenCut.sub();\n+        }\n+    }\n+\n+    public String applyTo(String str, Function<String, Object> tokenValueSupplier) {\n+        Objects.requireNonNull(str);\n+        Objects.requireNonNull(tokenValueSupplier);\n+        for (final var regexp : regexps) {\n+            str = regexp.matcher(str).replaceAll(mr -> {\n+                final var token = mr.group();\n+                return Matcher.quoteReplacement(Objects.requireNonNull(tokenValueSupplier.apply(token), () -> {\n+                    return String.format(\"Null value for token [%s]\", token);\n+                }).toString());\n+            });\n+        }\n+        return str;\n+    }\n+\n+    public String recursiveApplyTo(String str, Function<String, Object> tokenValueSupplier) {\n+        String newStr;\n+        int counter = tokens.length + 1;\n+        while (!(newStr = applyTo(str, tokenValueSupplier)).equals(str)) {\n+            str = newStr;\n+            if (counter-- == 0) {\n+                throw new IllegalStateException(\"Infinite recursion\");\n+            }\n+        }\n+        return newStr;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ Auto generated code\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + Arrays.hashCode(tokens);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        \/\/ Auto generated code\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        TokenReplace other = (TokenReplace) obj;\n+        return Arrays.equals(tokens, other.tokens);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TokenReplace(\" + String.join(\"|\", tokens) + \")\";\n+    }\n+\n+    public static TokenReplace combine(TokenReplace x, TokenReplace y) {\n+        return new TokenReplace(Stream.of(x.tokens, y.tokens).flatMap(Stream::of).toArray(String[]::new));\n+    }\n+\n+    public static Function<String, Object> createCachingTokenValueSupplier(Map<String, Supplier<Object>> tokenValueSuppliers) {\n+        Objects.requireNonNull(tokenValueSuppliers);\n+        final Map<String, Object> cache = new HashMap<>();\n+        return token -> {\n+            final var value = cache.computeIfAbsent(token, k -> {\n+                final var tokenValueSupplier = Objects.requireNonNull(tokenValueSuppliers.get(token), () -> {\n+                    return String.format(\"No token value supplier for token [%s]\", token);\n+                });\n+                return Optional.ofNullable(tokenValueSupplier.get()).orElse(NULL_SUPPLIED);\n+            });\n+\n+            if (value == NULL_SUPPLIED) {\n+                throw new NullPointerException(String.format(\"Null value for token [%s]\", token));\n+            }\n+\n+            return value;\n+        };\n+    }\n+\n+    private final String[] tokens;\n+    private final transient List<Pattern> regexps;\n+    private final static Object NULL_SUPPLIED = new Object();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/TokenReplace.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,0 @@\n-import jdk.internal.opt.CommandLine;\n-import jdk.jpackage.internal.Arguments;\n-import jdk.jpackage.internal.Log;\n-import jdk.jpackage.internal.CLIHelp;\n-import java.io.PrintWriter;\n-import java.util.ResourceBundle;\n@@ -36,0 +30,2 @@\n+import java.io.PrintWriter;\n+import java.nio.file.NoSuchFileException;\n@@ -37,0 +33,5 @@\n+import java.util.ResourceBundle;\n+import jdk.internal.opt.CommandLine;\n+import jdk.jpackage.internal.Arguments;\n+import jdk.jpackage.internal.CLIHelp;\n+import jdk.jpackage.internal.Log;\n@@ -72,1 +73,1 @@\n-            } catch (FileNotFoundException fnfe) {\n+            } catch (FileNotFoundException|NoSuchFileException fnfe) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-    private final static int ERROR_EXIT_CODE_JPACKAGE = 35;\n-    private final static int ERROR_EXIT_CODE_INSTALL = 27;\n+    private static final int ERROR_EXIT_CODE_JPACKAGE = 35;\n+    private static final int ERROR_EXIT_CODE_INSTALL = 27;\n@@ -103,3 +103,3 @@\n-    private final static CallbackFactory NEVER = new CallbackFactory(0);\n-    private final static CallbackFactory ONCE = new CallbackFactory(1);\n-    private final static CallbackFactory TWICE = new CallbackFactory(2);\n+    private static final CallbackFactory NEVER = new CallbackFactory(0);\n+    private static final CallbackFactory ONCE = new CallbackFactory(1);\n+    private static final CallbackFactory TWICE = new CallbackFactory(2);\n@@ -241,1 +241,1 @@\n-    private final static class CountingInstaller extends TickCounter implements Function<JPackageCommand, Integer> {\n+    private static final class CountingInstaller extends TickCounter implements Function<JPackageCommand, Integer> {\n@@ -379,1 +379,1 @@\n-                    .isPackageTypeSupported(type -> true)\n+                    .isPackageTypeEnabled(type -> true)\n@@ -442,1 +442,1 @@\n-    private final static class TestSpecBuilder {\n+    private static final class TestSpecBuilder {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.nio.file.Path;\n@@ -26,0 +27,1 @@\n+import java.util.Objects;\n@@ -27,0 +29,2 @@\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n@@ -28,1 +32,1 @@\n-public final class CannedFormattedString {\n+public record CannedFormattedString(BiFunction<String, Object[], String> formatter, String key, Object[] args) {\n@@ -30,5 +34,35 @@\n-    CannedFormattedString(BiFunction<String, Object[], String> formatter,\n-            String key, Object[] args) {\n-        this.formatter = formatter;\n-        this.key = key;\n-        this.args = args;\n+    @FunctionalInterface\n+    public interface CannedArgument {\n+        public String value();\n+    }\n+\n+    public static Object cannedArgument(Supplier<Object> supplier, String label) {\n+        Objects.requireNonNull(supplier);\n+        Objects.requireNonNull(label);\n+        return new CannedArgument() {\n+\n+            @Override\n+            public String value() {\n+                return supplier.get().toString();\n+            }\n+\n+            @Override\n+            public String toString( ) {\n+                return label;\n+            }\n+        };\n+    }\n+\n+    public static Object cannedAbsolutePath(Path v) {\n+        return cannedArgument(() -> v.toAbsolutePath(), String.format(\"AbsolutePath(%s)\", v));\n+    }\n+\n+    public static Object cannedAbsolutePath(String v) {\n+        return cannedAbsolutePath(Path.of(v));\n+    }\n+\n+    public CannedFormattedString {\n+        Objects.requireNonNull(formatter);\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(args);\n+        List.of(args).forEach(Objects::requireNonNull);\n@@ -38,1 +72,7 @@\n-        return formatter.apply(key, args);\n+        return formatter.apply(key, Stream.of(args).map(arg -> {\n+            if (arg instanceof CannedArgument cannedArg) {\n+                return cannedArg.value();\n+            } else {\n+                return arg;\n+            }\n+        }).toArray());\n@@ -49,4 +89,0 @@\n-\n-    private final BiFunction<String, Object[], String> formatter;\n-    private final String key;\n-    private final Object[] args;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CannedFormattedString.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.HashMap;\n@@ -38,0 +39,1 @@\n+import java.util.Map;\n@@ -95,0 +97,7 @@\n+        setEnvVars.remove(envVarName);\n+        return this;\n+    }\n+\n+    public Executor setEnvVar(String envVarName, String envVarValue) {\n+        setEnvVars.put(Objects.requireNonNull(envVarName), Objects.requireNonNull(envVarValue));\n+        removeEnvVars.remove(envVarName);\n@@ -373,0 +382,15 @@\n+        if (!setEnvVars.isEmpty()) {\n+            final var defaultEnv = builder.environment();\n+            final var envComm = Comm.compare(defaultEnv.keySet(), setEnvVars.keySet());\n+            envComm.unique2().forEach(envVar -> {\n+                trace(String.format(\"Adding %s=[%s] to environment\", envVar, setEnvVars.get(envVar)));\n+            });\n+            envComm.common().forEach(envVar -> {\n+                final var curValue = defaultEnv.get(envVar);\n+                final var newValue = setEnvVars.get(envVar);\n+                if (!curValue.equals(newValue)) {\n+                    trace(String.format(\"Setting %s=[%s] in environment\", envVar, setEnvVars.get(envVar)));\n+                }\n+            });\n+            defaultEnv.putAll(setEnvVars);\n+        }\n@@ -374,2 +398,3 @@\n-            final var envComm = Comm.compare(builder.environment().keySet(), removeEnvVars);\n-            builder.environment().keySet().removeAll(envComm.common());\n+            final var defaultEnv = builder.environment().keySet();\n+            final var envComm = Comm.compare(defaultEnv, removeEnvVars);\n+            defaultEnv.removeAll(envComm.common());\n@@ -377,1 +402,1 @@\n-                TKit.trace(String.format(\"Clearing %s in environment\", envVar));\n+                trace(String.format(\"Clearing %s in environment\", envVar));\n@@ -518,0 +543,1 @@\n+    private Map<String, String> setEnvVars = new HashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -353,0 +354,1 @@\n+            this.env = new HashMap<>();\n@@ -366,0 +368,10 @@\n+        public AppOutputVerifier addEnvironment(Map<String, String> v) {\n+            env.putAll(v);\n+            return this;\n+        }\n+\n+        public AppOutputVerifier addEnvironmentVar(String name, String value) {\n+            env.put(Objects.requireNonNull(name), Objects.requireNonNull(name));\n+            return this;\n+        }\n+\n@@ -469,0 +481,4 @@\n+            env.forEach((envVarName, envVarValue) -> {\n+                executor.setEnvVar(envVarName, envVarValue);\n+            });\n+\n@@ -479,0 +495,1 @@\n+        private final Map<String, String> env;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        outputValidator = cmd.outputValidator;\n+        outputValidators = cmd.outputValidators;\n@@ -221,7 +221,1 @@\n-        String appImage = getArgumentValue(\"--app-image\");\n-        if (appImage != null) {\n-            String name = AppImageFile.load(Path.of(appImage)).mainLauncherName();\n-            \/\/ can be null if using foreign app-image\n-            return ((name != null) ? name : getArgumentValue(\"--name\"));\n-        }\n-        return getArgumentValue(\"--name\", () -> getArgumentValue(\"--main-class\"));\n+        return nameFromAppImage().or(this::nameFromBasicArgs).or(this::nameFromRuntimeImage).orElseThrow();\n@@ -232,9 +226,16 @@\n-        String installerName = getArgumentValue(\"--name\",\n-                () -> getArgumentValue(\"--main-class\", () -> null));\n-        if (installerName == null) {\n-            String appImage = getArgumentValue(\"--app-image\");\n-            if (appImage != null) {\n-                installerName = AppImageFile.load(Path.of(appImage)).mainLauncherName();\n-            }\n-        }\n-        return installerName;\n+        return nameFromBasicArgs().or(this::nameFromAppImage).or(this::nameFromRuntimeImage).orElseThrow();\n+    }\n+\n+    private Optional<String> nameFromAppImage() {\n+        return Optional.ofNullable(getArgumentValue(\"--app-image\"))\n+                .map(Path::of).map(AppImageFile::load).map(AppImageFile::mainLauncherName);\n+    }\n+\n+    private Optional<String> nameFromRuntimeImage() {\n+        return Optional.ofNullable(getArgumentValue(\"--runtime-image\"))\n+                .map(Path::of).map(Path::getFileName).map(Path::toString);\n+    }\n+\n+    private Optional<String> nameFromBasicArgs() {\n+        return Optional.ofNullable(getArgumentValue(\"--name\")).or(\n+                () -> Optional.ofNullable(getArgumentValue(\"--main-class\")));\n@@ -276,1 +277,1 @@\n-            Path fakeRuntimeDir = TKit.workDir().resolve(\"fake_runtime\");\n+            Path fakeRuntimeDir = TKit.createTempDirectory(\"fake_runtime\");\n@@ -706,1 +707,1 @@\n-        return JPackageCommand.this.validateOutput(validator::apply);\n+        return validateOutput(validator::apply);\n@@ -710,6 +711,3 @@\n-        if (validator != null) {\n-            saveConsoleOutput(true);\n-            outputValidator = validator;\n-        } else {\n-            outputValidator = null;\n-        }\n+        Objects.requireNonNull(validator);\n+        saveConsoleOutput(true);\n+        outputValidators.add(validator);\n@@ -719,2 +717,37 @@\n-    public JPackageCommand validateOutput(CannedFormattedString str) {\n-        return JPackageCommand.this.validateOutput(TKit.assertTextStream(str.getValue()));\n+    @FunctionalInterface\n+    public interface CannedArgument {\n+        public String value(JPackageCommand cmd);\n+    }\n+\n+    public static Object cannedArgument(Function<JPackageCommand, Object> supplier, String label) {\n+        Objects.requireNonNull(supplier);\n+        Objects.requireNonNull(label);\n+        return new CannedArgument() {\n+            @Override\n+            public String value(JPackageCommand cmd) {\n+                return supplier.apply(cmd).toString();\n+            }\n+\n+            @Override\n+            public String toString( ) {\n+                return label;\n+            }\n+        };\n+    }\n+\n+    public String getValue(CannedFormattedString str) {\n+        return new CannedFormattedString(str.formatter(), str.key(), Stream.of(str.args()).map(arg -> {\n+            if (arg instanceof CannedArgument cannedArg) {\n+                return cannedArg.value(this);\n+            } else {\n+                return arg;\n+            }\n+        }).toArray()).getValue();\n+    }\n+\n+    public JPackageCommand validateOutput(CannedFormattedString... str) {\n+        \/\/ Will look up the given errors in the order they are specified.\n+        return validateOutput(Stream.of(str)\n+                .map(this::getValue)\n+                .map(TKit::assertTextStream)\n+                .reduce(TKit.TextStreamVerifier::andThen).get());\n@@ -801,1 +834,1 @@\n-        if (outputValidator != null) {\n+        for (final var outputValidator: outputValidators) {\n@@ -879,0 +912,3 @@\n+            if (!copy.hasArgument(\"--name\")) {\n+                copy.addArguments(\"--name\", cmd.nameFromRuntimeImage().orElseThrow());\n+            }\n@@ -1025,1 +1061,1 @@\n-        if (!hasArgument(\"--runtime-image\") && !hasArgument(\"--app-image\") && DEFAULT_RUNTIME_IMAGE != null && !ignoreDefaultRuntime) {\n+        if (!hasArgument(\"--runtime-image\") && !hasArgument(\"--jlink-options\") && !hasArgument(\"--app-image\") && DEFAULT_RUNTIME_IMAGE != null && !ignoreDefaultRuntime) {\n@@ -1198,1 +1234,1 @@\n-    private Consumer<Stream<String>> outputValidator;\n+    private List<Consumer<Stream<String>>> outputValidators = new ArrayList<>();\n@@ -1205,1 +1241,1 @@\n-                    reply.put(type.getName(), type);\n+                    reply.put(type.getType(), type);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":67,"deletions":31,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-    public CannedFormattedString cannedFormattedString(String key, String ... args) {\n+    public CannedFormattedString cannedFormattedString(String key, Object ... args) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageStringBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,4 @@\n+import static java.util.stream.Collectors.toCollection;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.test.TestBuilder.CMDLINE_ARG_PREFIX;\n+\n@@ -35,1 +39,0 @@\n-import static java.util.stream.Collectors.toCollection;\n@@ -37,1 +40,0 @@\n-import static jdk.jpackage.test.TestBuilder.CMDLINE_ARG_PREFIX;\n@@ -91,3 +93,1 @@\n-                        TKit.log(\n-                                String.format(\"Error processing parameter=[%s]\",\n-                                        arg));\n+                        TKit.log(String.format(\"Error processing parameter=[%s]\", arg));\n@@ -107,0 +107,7 @@\n+        }\n+\n+        orderedTests.stream().collect(toMap(TestInstance::fullName, x -> x, (x, y) -> {\n+            throw new IllegalArgumentException(String.format(\"Multiple tests with the same description: [%s]\", x.fullName()));\n+        }));\n+\n+        if (listTests) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        isPackageTypeSupported = PackageType::isSupported;\n+        isPackageTypeEnabled = PackageType::isEnabled;\n@@ -105,1 +105,1 @@\n-                .filter(isPackageTypeSupported)\n+                .filter(isPackageTypeEnabled)\n@@ -397,1 +397,1 @@\n-    PackageTest isPackageTypeSupported(Predicate<PackageType> v) {\n+    PackageTest isPackageTypeEnabled(Predicate<PackageType> v) {\n@@ -399,1 +399,1 @@\n-        isPackageTypeSupported = v;\n+        isPackageTypeEnabled = v;\n@@ -508,1 +508,1 @@\n-                            String.format(\"unpacked-%s\", type.getName()));\n+                            String.format(\"unpacked-%s\", type.getType()));\n@@ -621,1 +621,1 @@\n-        private final static class State {\n+        private static final class State {\n@@ -921,1 +921,1 @@\n-    private Predicate<PackageType> isPackageTypeSupported;\n+    private Predicate<PackageType> isPackageTypeEnabled;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -51,1 +52,8 @@\n-    IMAGE(\"app-image\", null, null);\n+    IMAGE;\n+\n+    PackageType() {\n+        type  = \"app-image\";\n+        suffix = null;\n+        supported = true;\n+        enabled = true;\n+    }\n@@ -54,7 +62,4 @@\n-        name  = packageName;\n-        suffix = bundleSuffix;\n-        if (bundlerClass != null && !Inner.DISABLED_PACKAGERS.contains(getName())) {\n-            supported = isBundlerSupported(bundlerClass);\n-        } else {\n-            supported = false;\n-        }\n+        type  = Objects.requireNonNull(packageName);\n+        suffix = Objects.requireNonNull(bundleSuffix);\n+        supported = Optional.ofNullable(bundlerClass).map(PackageType::isBundlerSupported).orElse(false);\n+        enabled = supported && !Inner.DISABLED_PACKAGERS.contains(getType());\n@@ -62,2 +67,2 @@\n-        if (suffix != null && supported) {\n-            TKit.trace(String.format(\"Bundler %s supported\", getName()));\n+        if (suffix != null && enabled) {\n+            TKit.trace(String.format(\"Bundler %s enabled\", getType()));\n@@ -72,1 +77,1 @@\n-        cmd.setArgumentValue(\"--type\", getName());\n+        cmd.setArgumentValue(\"--type\", getType());\n@@ -76,1 +81,1 @@\n-        return suffix;\n+        return Optional.ofNullable(suffix).orElseThrow(UnsupportedOperationException::new);\n@@ -79,1 +84,1 @@\n-    boolean isSupported() {\n+    public boolean isSupported() {\n@@ -83,2 +88,2 @@\n-    String getName() {\n-        return name;\n+    public boolean isEnabled() {\n+        return supported;\n@@ -87,9 +92,2 @@\n-    static PackageType fromSuffix(String packageFilename) {\n-        if (packageFilename != null) {\n-            for (PackageType v : values()) {\n-                if (packageFilename.endsWith(v.getSuffix())) {\n-                    return v;\n-                }\n-            }\n-        }\n-        return null;\n+    public String getType() {\n+        return type;\n@@ -136,1 +134,1 @@\n-    private final String name;\n+    private final String type;\n@@ -138,0 +136,1 @@\n+    private final boolean enabled;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageType.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.HexFormat;\n@@ -122,1 +123,11 @@\n-                }).collect(Collectors.joining(\", \"));\n+                }).collect(Collectors.joining(\", \")).transform(str -> {\n+                    final var sb = new StringBuilder();\n+                    for (var chr : str.toCharArray()) {\n+                        if (chr != ' ' && (Character.isWhitespace(chr) || Character.isISOControl(chr))) {\n+                            sb.append(\"\\\\u\").append(ARGS_CHAR_FORMATTER.toHexDigits(chr));\n+                        } else {\n+                            sb.append(chr);\n+                        }\n+                    }\n+                    return sb.toString();\n+                });\n@@ -128,0 +139,2 @@\n+\n+            private static final HexFormat ARGS_CHAR_FORMATTER = HexFormat.of().withUpperCase();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestInstance.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-                    cmd.packageType().getName())));\n+                    cmd.packageType().getType())));\n@@ -178,2 +178,1 @@\n-                TKit.trace(String.format(\"Convert [%s] into [%s] in [%s] directory\", from, to,\n-                        unpackDir));\n+\n@@ -182,2 +181,0 @@\n-                    Files.move(unpackDir.resolve(from), unpackDir.resolve(to));\n-                    TKit.deleteDirectoryRecursive(unpackDir.resolve(extraPathComponent));\n@@ -185,0 +182,9 @@\n+\n+                \/\/ Files.move() occasionally results into java.nio.file.AccessDeniedException\n+                Executor.tryRunMultipleTimes(ThrowingRunnable.toRunnable(() -> {\n+                    TKit.trace(String.format(\"Convert [%s] into [%s] in [%s] directory\", from, to, unpackDir));\n+                    final var dstDir = unpackDir.resolve(to);\n+                    TKit.deleteDirectoryRecursive(dstDir);\n+                    Files.move(unpackDir.resolve(from), dstDir);\n+                    TKit.deleteDirectoryRecursive(unpackDir.resolve(extraPathComponent));\n+                }), 3, 5);\n@@ -659,1 +665,1 @@\n-        private final static Map<SpecialFolder, Path> CACHE = new ConcurrentHashMap<>();\n+        private static final Map<SpecialFolder, Path> CACHE = new ConcurrentHashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.text.MessageFormat;\n@@ -27,0 +28,1 @@\n+import java.util.Objects;\n@@ -115,0 +117,24 @@\n+    record InvalidVersionTestSpec(String version, String invalidComponent) {\n+        public InvalidVersionTestSpec {\n+            Objects.requireNonNull(version);\n+            Objects.requireNonNull(invalidComponent);\n+        }\n+\n+        InvalidVersionTestSpec(String version) {\n+            this(version, \"\");\n+        }\n+\n+        void run() {\n+            final String expectedErrorMsg;\n+            if (invalidComponent.isEmpty()) {\n+                expectedErrorMsg = MessageFormat.format(I18N.getString(\"error.version-string-zero-length-component\"), version);\n+            } else {\n+                expectedErrorMsg = MessageFormat.format(I18N.getString(\"error.version-string-invalid-component\"), version, invalidComponent);\n+            }\n+\n+            final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> new DottedVersion(version));\n+\n+            assertEquals(expectedErrorMsg, ex.getMessage());\n+        }\n+    }\n+\n@@ -117,2 +143,2 @@\n-    public void testInvalid(String str) {\n-        assertThrowsExactly(IllegalArgumentException.class, () -> new DottedVersion(str));\n+    public void testInvalid(InvalidVersionTestSpec testSpec) {\n+        testSpec.run();\n@@ -121,1 +147,1 @@\n-    private static Stream<String> testInvalid() {\n+    private static Stream<InvalidVersionTestSpec> testInvalid() {\n@@ -123,14 +149,19 @@\n-                \"1.-1\",\n-                \"5.\",\n-                \"4.2.\",\n-                \"3..2\",\n-                \"2.a\",\n-                \"0a\",\n-                \".\",\n-                \" \",\n-                \" 1\",\n-                \"1. 2\",\n-                \"+1\",\n-                \"-1\",\n-                \"-0\",\n-                \"+0\"\n+                new InvalidVersionTestSpec(\"1.-1\", \"-1\"),\n+                new InvalidVersionTestSpec(\"5.\"),\n+                new InvalidVersionTestSpec(\"4.2.\"),\n+                new InvalidVersionTestSpec(\"3..2\", \".2\"),\n+                new InvalidVersionTestSpec(\"3...2\", \"..2\"),\n+                new InvalidVersionTestSpec(\"2.a\", \"a\"),\n+                new InvalidVersionTestSpec(\"0a\", \"a\"),\n+                new InvalidVersionTestSpec(\"1.0a\", \"0a\"),\n+                new InvalidVersionTestSpec(\".\", \".\"),\n+                new InvalidVersionTestSpec(\"..\", \"..\"),\n+                new InvalidVersionTestSpec(\".a.b\", \".a.b\"),\n+                new InvalidVersionTestSpec(\".1.2\", \".1.2\"),\n+                new InvalidVersionTestSpec(\" \", \" \"),\n+                new InvalidVersionTestSpec(\" 1\", \" 1\"),\n+                new InvalidVersionTestSpec(\"1. 2\", \" 2\"),\n+                new InvalidVersionTestSpec(\"+1\", \"+1\"),\n+                new InvalidVersionTestSpec(\"-1\", \"-1\"),\n+                new InvalidVersionTestSpec(\"-0\", \"-0\"),\n+                new InvalidVersionTestSpec(\"+0\", \"+0\")\n@@ -148,1 +179,2 @@\n-        assertThrowsExactly(IllegalArgumentException.class, () -> DottedVersion.greedy(\"\"), \"Version may not be empty string\");\n+        final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> DottedVersion.greedy(\"\"));\n+        assertEquals(I18N.getString(\"error.version-string-empty\"), ex.getMessage());\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DottedVersionTest.java","additions":51,"deletions":19,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class TokenReplaceTest {\n+\n+    public record TestSpec(String str, Optional<String> expectedStr, Optional<Exception> expectedCtorException,\n+            Optional<Exception> expectedApplyToException, Map<String, String> tokenWithValues, boolean recursive) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(expectedStr);\n+            Objects.requireNonNull(expectedCtorException);\n+            Objects.requireNonNull(expectedApplyToException);\n+            Objects.requireNonNull(tokenWithValues);\n+            tokenWithValues.values().forEach(Objects::requireNonNull);\n+\n+            if (expectedStr.isPresent()) {\n+                if (!(expectedCtorException.isEmpty() && expectedApplyToException.isEmpty())) {\n+                    throw new IllegalArgumentException();\n+                }\n+            } else if (expectedCtorException.isEmpty() == expectedApplyToException.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            Builder str(String v) {\n+                str = v;\n+                return this;\n+            }\n+\n+            Builder recursive(boolean v) {\n+                recursive = v;\n+                return this;\n+            }\n+\n+            Builder recursive() {\n+                return recursive(true);\n+            }\n+\n+            Builder expect(String v) {\n+                expectedStr = v;\n+                return this;\n+            }\n+\n+            Builder expectCtorThrow(String v) {\n+                expectedCtorException = new IllegalArgumentException(v);\n+                return this;\n+            }\n+\n+            Builder expectApplyToNPE() {\n+                expectedApplyToException = new NullPointerException();\n+                return this;\n+            }\n+\n+            Builder expectInfiniteRecursion() {\n+                expectedApplyToException = new IllegalStateException(\"Infinite recursion\");\n+                return this;\n+            }\n+\n+            Builder token(String token, String value) {\n+                tokenWithValues.put(token, value);\n+                return this;\n+            }\n+\n+            TestSpec create() {\n+                return new TestSpec(str, expectedStr(), Optional.ofNullable(expectedCtorException),\n+                        Optional.ofNullable(expectedApplyToException), tokenWithValues, recursive);\n+            }\n+\n+            private Optional<String> expectedStr() {\n+                if (expectedCtorException == null && expectedApplyToException == null) {\n+                    return Optional.ofNullable(expectedStr).or(() -> Optional.of(str));\n+                } else {\n+                    return Optional.empty();\n+                }\n+            }\n+\n+            private boolean recursive;\n+            private String str;\n+            private String expectedStr;\n+            private Exception expectedCtorException;\n+            private Exception expectedApplyToException;\n+            private final Map<String, String> tokenWithValues = new HashMap<>();\n+        }\n+\n+        void test() {\n+            final var tokens = tokenWithValues.keySet().toArray(String[]::new);\n+            expectedStr.ifPresent(expected -> {\n+                final var tokenReplace = new TokenReplace(tokens);\n+                final String actual;\n+                if (recursive) {\n+                    actual = tokenReplace.recursiveApplyTo(str, tokenWithValues::get);\n+                } else {\n+                    actual = tokenReplace.applyTo(str, tokenWithValues::get);\n+                }\n+                assertEquals(expected, actual);\n+            });\n+\n+            expectedCtorException.ifPresent(expected -> {\n+                final var ex = assertThrows(expected.getClass(), () -> {\n+                    new TokenReplace(tokens);\n+                });\n+                assertEquals(expected.getMessage(), ex.getMessage());\n+            });\n+\n+            expectedApplyToException.ifPresent(expected -> {\n+                final var tokenReplace = new TokenReplace(tokens);\n+                final var ex = assertThrows(expected.getClass(), () -> {\n+                    if (recursive) {\n+                        tokenReplace.recursiveApplyTo(str, tokenWithValues::get);\n+                    } else {\n+                        tokenReplace.applyTo(str, tokenWithValues::get);\n+                    }\n+                });\n+                assertEquals(expected.getMessage(), ex.getMessage());\n+            });\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec spec) {\n+        spec.test();\n+    }\n+\n+    public static Stream<TestSpec> test() {\n+        return Stream.of(\n+                testSpec(\"foo\").token(\"\", \"B\").expectCtorThrow(\"Empty token in the list of tokens\"),\n+                testSpec(\"foo\").expectCtorThrow(\"Empty token list\"),\n+                testSpec(\"a\").expect(\"a\").token(\"b\", \"B\"),\n+                testSpec(\"a\").expect(\"A\").token(\"a\", \"A\"),\n+                testSpec(\"aaa\").expect(\"AAA\").token(\"a\", \"A\"),\n+                testSpec(\"aaa\").recursive().expect(\"{B}{B}{B}\").token(\"a\", \"b\").token(\"b\", \"{B}\"),\n+                testSpec(\"aaa\").token(\"a\", \"aa\").token(\"aa\", \"C\").expect(\"Caa\"),\n+                testSpec(\"aaa\").token(\"a\", \"aa\").token(\"aa\", \"C\").expect(\"CC\").recursive(),\n+                testSpec(\"aaa\").expect(\"A2A\").token(\"a\", \"A\").token(\"aa\", \"A2\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"c\").token(\"c\", \"a\").expect(\"bbb\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"\").recursive().expect(\"\"),\n+                testSpec(\"aaa\").token(\"a\", \"\").recursive().expect(\"\"),\n+                testSpec(\"aaa\").token(\"a\", \"b\").token(\"b\", \"c\").token(\"c\", \"a\").expectInfiniteRecursion().recursive(),\n+                testSpec(null).token(\"a\", \"b\").expectApplyToNPE(),\n+                testSpec(\"abc\").expect(\"abc\").token(\".\", \"A\"),\n+                testSpec(\"abc.\").expect(\"abcD\").token(\".\", \"D\")\n+        ).map(TestSpec.Builder::create);\n+    }\n+\n+    private static final class CountingSupplier implements Supplier<Object> {\n+\n+        CountingSupplier(Object value, int expectedCount) {\n+            this.value = value;\n+            this.expectedCount = expectedCount;\n+        }\n+\n+        @Override\n+        public Object get() {\n+            counter++;\n+            return value;\n+        }\n+\n+        public Object value() {\n+            return value;\n+        }\n+\n+        void verifyCount() {\n+            assertEquals(expectedCount, counter);\n+        }\n+\n+        private final Object value;\n+        private int counter;\n+        private final int expectedCount;\n+    }\n+\n+    @Test\n+    public void testCombine() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"aa\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"aa\", \"a\"));\n+        assertEquals(xy, new TokenReplace(\"a\", \"aa\"));\n+    }\n+\n+    @Test\n+    public void testCombine2() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"a\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"a\", \"a\"));\n+        assertEquals(xy, new TokenReplace(\"a\"));\n+        assertEquals(xy, x);\n+        assertEquals(xy, y);\n+    }\n+\n+    @Test\n+    public void testCombine3() {\n+        final var x = new TokenReplace(\"a\");\n+        final var y = new TokenReplace(\"b\");\n+\n+        final var xy = TokenReplace.combine(x, y);\n+\n+        assertEquals(xy, new TokenReplace(\"a\", \"b\"));\n+        assertEquals(xy, new TokenReplace(\"b\", \"a\"));\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        final var x = new TokenReplace(\"x\");\n+        final var y = new TokenReplace(\"y\");\n+        final var y2 = new TokenReplace(\"y\");\n+\n+        assertNotEquals(x, y);\n+        assertNotEquals(x, null);\n+        assertNotEquals(null, x);\n+        assertNotEquals(x, \"x\");\n+\n+        assertEquals(y, y2);\n+        assertEquals(y, y);\n+    }\n+\n+    @Test\n+    public void testCreateCachingTokenValueSupplier() {\n+        final var neverCalledSupplier = new CountingSupplier(\"\", 0);\n+        final var calledOnceSupplier = new CountingSupplier(\"foo\", 1);\n+        final var calledOnceNullSupplier = new CountingSupplier(null, 1);\n+\n+        final var supplier = TokenReplace.createCachingTokenValueSupplier(Map.of(\n+                \"never\", neverCalledSupplier,\n+                \"once\", calledOnceSupplier,\n+                \"onceNull\", calledOnceNullSupplier\n+        ));\n+\n+        for (int i = 0; i != 2; i++) {\n+            assertEquals(calledOnceSupplier.value(), supplier.apply(\"once\"));\n+\n+            final var ex = assertThrows(NullPointerException.class, () -> supplier.apply(\"onceNull\"));\n+            assertEquals(\"Null value for token [onceNull]\", ex.getMessage());\n+        }\n+\n+        final var ex = assertThrows(NullPointerException.class, () -> supplier.apply(\"foo\"));\n+        assertEquals(\"No token value supplier for token [foo]\", ex.getMessage());\n+\n+        neverCalledSupplier.verifyCount();\n+        calledOnceSupplier.verifyCount();\n+        calledOnceNullSupplier.verifyCount();\n+    }\n+\n+    private static TestSpec.Builder testSpec(String str) {\n+        return new TestSpec.Builder().str(str);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/TokenReplaceTest.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.JPackageStringBundle.MAIN;\n+\n@@ -26,1 +28,5 @@\n-import jdk.jpackage.test.TKit;\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.LinuxHelper;\n@@ -29,3 +35,2 @@\n-import jdk.jpackage.test.LinuxHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import java.util.List;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n@@ -58,2 +63,6 @@\n-            Path controlFile = Path.of(cmd.getArgumentValue(\"--resource-dir\"),\n-                    \"control\");\n+            Path controlFile = Path.of(cmd.getArgumentValue(\"--resource-dir\"), \"control\");\n+\n+            final var packageProp = property(\"Package\", \"dont-install-me\");\n+            final var verProp = property(\"Version\", \"1.2.3-R2\");\n+            final var arhProp = property(\"Architecture\", \"bar\");\n+\n@@ -61,2 +70,2 @@\n-                \"Package: dont-install-me\",\n-                \"Version: 1.2.3-R2\",\n+                packageProp.format(),\n+                verProp.format(),\n@@ -66,1 +75,1 @@\n-                \"Architecture: bar\",\n+                arhProp.format(),\n@@ -72,19 +81,9 @@\n-        })\n-        .addBundleVerifier((cmd, result) -> {\n-            TKit.assertTextStream(\"Using custom package resource [DEB control file]\")\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(String.format(\n-                    \"Expected value of \\\"Package\\\" property is [%s]. Actual value in output package is [dont-install-me]\",\n-                    LinuxHelper.getPackageName(cmd)))\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(\n-                    \"Expected value of \\\"Version\\\" property is [1.0]. Actual value in output package is [1.2.3-R2]\")\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(String.format(\n-                    \"Expected value of \\\"Architecture\\\" property is [%s]. Actual value in output package is [bar]\",\n-                    LinuxHelper.getDefaultPackageArch(cmd.packageType())))\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n+\n+            cmd.validateOutput(MAIN.cannedFormattedString(\n+                    \"message.using-custom-resource\",\n+                    String.format(\"[%s]\", MAIN.cannedFormattedString(\"resource.deb-control-file\").getValue()),\n+                    controlFile.getFileName()));\n+\n+            packageProp.expectedValue(LinuxHelper.getPackageName(cmd)).token(\"APPLICATION_PACKAGE\").resourceDirFile(controlFile).validateOutput(cmd);\n+            verProp.expectedValue(cmd.version()).token(\"APPLICATION_VERSION_WITH_RELEASE\").resourceDirFile(controlFile).validateOutput(cmd);\n+            arhProp.expectedValue(LinuxHelper.getDefaultPackageArch(cmd.packageType())).token(\"APPLICATION_ARCH\").resourceDirFile(controlFile).validateOutput(cmd);\n@@ -96,0 +95,5 @@\n+\n+            final var packageProp = property(\"Name\", \"dont-install-me\");\n+            final var verProp = property(\"Version\", \"1.2.3\");\n+            final var releaseProp = property(\"Release\", \"R2\");\n+\n@@ -97,3 +101,3 @@\n-                \"Name: dont-install-me\",\n-                \"Version: 1.2.3\",\n-                \"Release: R2\",\n+                packageProp.format(),\n+                verProp.format(),\n+                releaseProp.format(),\n@@ -116,0 +120,9 @@\n+\n+            cmd.validateOutput(MAIN.cannedFormattedString(\n+                    \"message.using-custom-resource\",\n+                    String.format(\"[%s]\", MAIN.cannedFormattedString(\"resource.rpm-spec-file\").getValue()),\n+                    specFile.getFileName()));\n+\n+            packageProp.expectedValue(LinuxHelper.getPackageName(cmd)).token(\"APPLICATION_PACKAGE\").resourceDirFile(specFile).validateOutput(cmd);\n+            verProp.expectedValue(cmd.version()).token(\"APPLICATION_VERSION\").resourceDirFile(specFile).validateOutput(cmd);\n+            releaseProp.expectedValue(\"1\").token(\"APPLICATION_RELEASE\").resourceDirFile(specFile).validateOutput(cmd);\n@@ -117,19 +130,62 @@\n-        .addBundleVerifier((cmd, result) -> {\n-            TKit.assertTextStream(\"Using custom package resource [RPM spec file]\")\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(String.format(\n-                    \"Expected value of \\\"Name\\\" property is [%s]. Actual value in output package is [dont-install-me]\",\n-                    LinuxHelper.getPackageName(cmd)))\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(\n-                    \"Expected value of \\\"Version\\\" property is [1.0]. Actual value in output package is [1.2.3]\")\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-            TKit.assertTextStream(\n-                    \"Expected value of \\\"Release\\\" property is [1]. Actual value in output package is [R2]\")\n-                    .predicate(String::contains)\n-                    .apply(result.getOutput().stream());\n-        })\n-        .run();\n+        .run(Action.CREATE);\n+    }\n+\n+    private static final class PropertyValidator {\n+\n+        PropertyValidator name(String v) {\n+            name = v;\n+            return this;\n+        }\n+\n+        PropertyValidator customValue(String v) {\n+            customValue = v;\n+            return this;\n+        }\n+\n+        PropertyValidator expectedValue(String v) {\n+            expectedValue = v;\n+            return this;\n+        }\n+\n+        PropertyValidator token(String v) {\n+            token = v;\n+            return this;\n+        }\n+\n+        PropertyValidator resourceDirFile(Path v) {\n+            resourceDirFile = v;\n+            return this;\n+        }\n+\n+        String format() {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(customValue);\n+            return String.format(\"%s: %s\", name, customValue);\n+        }\n+\n+        void validateOutput(JPackageCommand cmd) {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(customValue);\n+            Objects.requireNonNull(expectedValue);\n+            Objects.requireNonNull(token);\n+            Objects.requireNonNull(resourceDirFile);\n+\n+            final var customResourcePath = customResourcePath();\n+            cmd.validateOutput(\n+                    MAIN.cannedFormattedString(\"error.unexpected-package-property\", name, expectedValue, customValue, customResourcePath),\n+                    MAIN.cannedFormattedString(\"error.unexpected-package-property.advice\", token, customValue, name, customResourcePath));\n+        }\n+\n+        private Path customResourcePath() {\n+            return resourceDirFile.getFileName();\n+        }\n+\n+        private String name;\n+        private String customValue;\n+        private String expectedValue;\n+        private String token;\n+        private Path resourceDirFile;\n+    }\n+\n+    private static PropertyValidator property(String name, String customValue) {\n+        return new PropertyValidator().name(name).customValue(customValue);\n","filename":"test\/jdk\/tools\/jpackage\/linux\/LinuxResourceTest.java","additions":106,"deletions":50,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n- * Tests generation of app image with --mac-app-store and --jlink-options. jpackage should able\n- * to generate app image if \"--strip-native-commands\" is specified for --jlink-options and should\n- * fail if it is not specified.\n+ * Tests generation of app image with --mac-app-store and --jlink-options.\n@@ -53,9 +51,0 @@\n-\n-    @Test\n-    public static void testWithoutStripNativeCommands() throws Exception {\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        cmd.addArguments(\"--mac-app-store\", \"--jlink-options\",\n-                \"--strip-debug --no-man-pages --no-header-files\");\n-\n-        cmd.execute(1);\n-    }\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacAppStoreJlinkOptionsTest.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.Executor;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.JavaTool;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-\n-\n-\/**\n- * Tests generation of app image with --mac-app-store and --runtime-image. jpackage should able\n- * to generate app image if runtime image does not have \"bin\" folder and fail otherwise.\n- *\/\n-\n-\/*\n- * @test\n- * @summary jpackage with --mac-app-store and --runtime-image\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @build MacAppStoreRuntimeTest\n- * @requires (os.family == \"mac\")\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=MacAppStoreRuntimeTest\n- *\/\n-public class MacAppStoreRuntimeTest {\n-\n-    private static String getRuntimeImage(boolean stripNativeCommands) throws IOException {\n-        final Path workDir = TKit.createTempDirectory(\"runtime\").resolve(\"data\");\n-        final Path jlinkOutputDir = workDir.resolve(\"temp.runtime\");\n-        Files.createDirectories(jlinkOutputDir.getParent());\n-\n-        \/\/ List of modules required for test app.\n-        final var modules = new String[] {\n-            \"java.base\",\n-            \"java.desktop\"\n-        };\n-\n-        List<String> jlinkArgs = new ArrayList<>();\n-        jlinkArgs.add(\"--output\");\n-        jlinkArgs.add(jlinkOutputDir.toString());\n-        jlinkArgs.add(\"--add-modules\");\n-        jlinkArgs.add(String.join(\",\", modules));\n-        jlinkArgs.add(\"--strip-debug\");\n-        jlinkArgs.add(\"--no-header-files\");\n-        jlinkArgs.add(\"--no-man-pages\");\n-        if (stripNativeCommands) {\n-            jlinkArgs.add(\"--strip-native-commands\");\n-        }\n-\n-        new Executor()\n-                .setToolProvider(JavaTool.JLINK)\n-                .dumpOutput()\n-                .addArguments(jlinkArgs)\n-                .execute();\n-\n-        return jlinkOutputDir.toString();\n-    }\n-\n-    @Test\n-    @Parameter(\"true\")\n-    @Parameter(\"false\")\n-    public static void test(boolean stripNativeCommands) throws Exception {\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        cmd.addArguments(\"--mac-app-store\", \"--runtime-image\", getRuntimeImage(stripNativeCommands));\n-\n-        if (stripNativeCommands) {\n-            cmd.executeAndAssertHelloAppImageCreated();\n-        } else {\n-            cmd.execute(1);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacAppStoreRuntimeTest.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    @Parameter({\"true\", \"true\", SigningBase.ASCII_INDEX})\n+    @Parameter({\"true\", \"true\", \"ASCII_INDEX\"})\n@@ -67,1 +67,1 @@\n-    @Parameter({\"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    @Parameter({\"true\", \"true\", \"UNICODE_INDEX\"})\n@@ -69,1 +69,1 @@\n-    @Parameter({\"true\", \"false\", SigningBase.UNICODE_INDEX})\n+    @Parameter({\"true\", \"false\", \"UNICODE_INDEX\"})\n@@ -71,5 +71,3 @@\n-    @Parameter({\"false\", \"true\", \"-1\"})\n-    public void test(String... testArgs) throws Exception {\n-        boolean doSign = Boolean.parseBoolean(testArgs[0]);\n-        boolean signingKey = Boolean.parseBoolean(testArgs[1]);\n-        int certIndex = Integer.parseInt(testArgs[2]);\n+    @Parameter({\"false\", \"true\", \"INVALID_INDEX\"})\n+    public void test(boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n+        final var certIndex = certEnum.value();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-            return Integer.valueOf(SigningBase.UNICODE_INDEX);\n+            return SigningBase.CertIndex.UNICODE_INDEX.value();\n@@ -120,1 +120,1 @@\n-    @Parameter({\"true\", \"true\", \"true\", SigningBase.ASCII_INDEX})\n+    @Parameter({\"true\", \"true\", \"true\", \"ASCII_INDEX\"})\n@@ -122,1 +122,1 @@\n-    @Parameter({\"true\", \"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    @Parameter({\"true\", \"true\", \"true\", \"UNICODE_INDEX\"})\n@@ -124,1 +124,1 @@\n-    @Parameter({\"false\", \"true\", \"true\", SigningBase.UNICODE_INDEX})\n+    @Parameter({\"false\", \"true\", \"true\", \"UNICODE_INDEX\"})\n@@ -126,1 +126,1 @@\n-    @Parameter({\"false\", \"true\", \"false\", SigningBase.UNICODE_INDEX})\n+    @Parameter({\"false\", \"true\", \"false\", \"UNICODE_INDEX\"})\n@@ -128,6 +128,3 @@\n-    @Parameter({\"false\", \"false\", \"true\", SigningBase.UNICODE_INDEX})\n-    public static void test(String... testArgs) throws Exception {\n-        boolean signingKey = Boolean.parseBoolean(testArgs[0]);\n-        boolean signAppImage = Boolean.parseBoolean(testArgs[1]);\n-        boolean signPKG = Boolean.parseBoolean(testArgs[2]);\n-        int certIndex = Integer.parseInt(testArgs[3]);\n+    @Parameter({\"false\", \"false\", \"true\", \"UNICODE_INDEX\"})\n+    public static void test(boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n+        final var certIndex = certEnum.value();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,16 @@\n+    enum CertIndex {\n+        ASCII_INDEX(0),\n+        UNICODE_INDEX(1),\n+        INVALID_INDEX(-1);\n+\n+        CertIndex(int value) {\n+            this.value = value;\n+        }\n+\n+        int value() {\n+            return value;\n+        }\n+\n+        private final int value;\n+    }\n+\n@@ -36,2 +52,0 @@\n-    public static final String ASCII_INDEX = \"0\";\n-    public static final String UNICODE_INDEX = \"0\";\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -30,0 +31,1 @@\n+import jdk.jpackage.test.CannedFormattedString;\n@@ -32,0 +34,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -109,4 +112,3 @@\n-        configureAppImageWithoutJPackageXMLFile(appImageDir).addInitializer(\n-                cmd -> {\n-                    cmd.removeArgumentWithValue(\"--name\");\n-                }).run(Action.CREATE);\n+        configureBadAppImage(appImageDir).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--name\");\n+        }).run(Action.CREATE);\n@@ -119,1 +121,1 @@\n-        configureAppImageWithoutJPackageXMLFile(appImageDir).run(Action.CREATE);\n+        configureBadAppImage(appImageDir).run(Action.CREATE);\n@@ -129,6 +131,4 @@\n-        configureAppImageWithoutJPackageXMLFile(appImageCmd.outputBundle()).\n-                addRunOnceInitializer(() -> {\n-                    appImageCmd.execute();\n-                    Files.delete(AppImageFile.getPathInAppImage(appImageCmd.\n-                            outputBundle()));\n-                }).run(Action.CREATE);\n+        configureBadAppImage(appImageCmd.outputBundle()).addRunOnceInitializer(() -> {\n+            appImageCmd.execute();\n+            Files.delete(AppImageFile.getPathInAppImage(appImageCmd.outputBundle()));\n+        }).run(Action.CREATE);\n@@ -137,15 +137,33 @@\n-    private static PackageTest configureAppImageWithoutJPackageXMLFile(\n-            Path appImageDir) {\n-        return new PackageTest()\n-                .addInitializer(cmd -> {\n-                    cmd.saveConsoleOutput(true);\n-                    cmd.addArguments(\"--app-image\", appImageDir);\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    cmd.ignoreDefaultVerbose(true); \/\/ no \"--verbose\" option\n-                })\n-                .addBundleVerifier((cmd, result) -> {\n-                    TKit.assertTextStream(\n-                    \"Error: Missing .jpackage.xml file in app-image dir\").apply(\n-                            result.getOutput().stream());\n-                })\n-                .setExpectedExitCode(1);\n+    @Test\n+    public static void testBadAppImageFile() throws IOException {\n+        final var appImageRoot = TKit.createTempDirectory(\"appimage\");\n+\n+        final var appImageCmd = JPackageCommand.helloAppImage().\n+                setFakeRuntime().setArgumentValue(\"--dest\", appImageRoot);\n+\n+        final var appImageDir = appImageCmd.outputBundle();\n+\n+        final var expectedError = JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.invalid-app-image\", appImageDir, AppImageFile.getPathInAppImage(appImageDir));\n+\n+        configureBadAppImage(appImageDir, expectedError).addRunOnceInitializer(() -> {\n+            appImageCmd.execute();\n+            XmlUtils.createXml(AppImageFile.getPathInAppImage(appImageDir), xml -> {\n+                xml.writeStartElement(\"jpackage-state\");\n+                xml.writeEndElement();\n+            });\n+        }).run(Action.CREATE);\n+    }\n+\n+    private static PackageTest configureBadAppImage(Path appImageDir) {\n+        return configureBadAppImage(appImageDir,\n+                JPackageStringBundle.MAIN.cannedFormattedString(\"error.foreign-app-image\", appImageDir));\n+    }\n+\n+    private static PackageTest configureBadAppImage(Path appImageDir, CannedFormattedString expectedError) {\n+        return new PackageTest().addInitializer(cmd -> {\n+            cmd.addArguments(\"--app-image\", appImageDir);\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.ignoreDefaultVerbose(true); \/\/ no \"--verbose\" option\n+            cmd.validateOutput(expectedError);\n+        }).setExpectedExitCode(1);\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":44,"deletions":26,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.jpackage.test.PackageTest;\n@@ -73,13 +72,0 @@\n-        \/\/ These are invalid version strings.\n-        \/\/ Don't need to test all invalid input as this is handled in\n-        \/\/ PlatformVersionTest unit test\n-        if (TKit.isWindows()) {\n-            data.addAll(List.of(new Object[][]{\n-                {null, \"Hello\", new String[]{\"--app-version\", \"256\"}}\n-            }));\n-        } else if (TKit.isOSX()) {\n-            data.addAll(List.of(new Object[][]{\n-                {null, \"Hello\", new String[]{\"--app-version\", \"0.2\"}}\n-            }));\n-        }\n-\n@@ -98,11 +84,0 @@\n-        if (expectedVersion == null) {\n-            new PackageTest()\n-            .setExpectedExitCode(1)\n-            .configureHelloApp(javaAppDesc)\n-            .addInitializer(cmd -> {\n-                cmd.addArguments(jpackageArgs);\n-            })\n-            .run();\n-            return;\n-        }\n-\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppVersionTest.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -384,1 +385,4 @@\n-            pkgTest.setExpectedExitCode(1).addBundleVerifier(cmd -> {\n+            pkgTest.setExpectedExitCode(1).addInitializer(cmd -> {\n+                cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"ERR_BuildRootInvalid\", cmd.getArgumentValue(\"--temp\")));\n+            }).addBundleVerifier(cmd -> {\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,8 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.util.OperatingSystem.LINUX;\n+import static jdk.internal.util.OperatingSystem.MACOS;\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n+import static jdk.jpackage.test.CannedFormattedString.cannedAbsolutePath;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n@@ -27,0 +35,2 @@\n+import java.util.Map;\n+import java.util.Objects;\n@@ -28,0 +38,3 @@\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -29,0 +42,2 @@\n+import jdk.jpackage.internal.util.TokenReplace;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -34,2 +49,1 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.RunnablePackageTest;\n+import jdk.jpackage.test.PackageType;\n@@ -37,1 +51,0 @@\n-import static jdk.internal.util.OperatingSystem.WINDOWS;\n@@ -45,1 +58,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -56,1 +69,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n@@ -63,2 +76,227 @@\n-    public static Collection<?> input() {\n-        return List.of(new Object[][]{\n+    enum Token {\n+        JAVA_HOME(cmd -> {\n+            return System.getProperty(\"java.home\");\n+        }),\n+        APP_IMAGE(cmd -> {\n+            final var appImageRoot = TKit.createTempDirectory(\"appimage\");\n+\n+            final var appImageCmd = JPackageCommand.helloAppImage()\n+                    .setFakeRuntime().setArgumentValue(\"--dest\", appImageRoot);\n+\n+            appImageCmd.execute();\n+\n+            return appImageCmd.outputBundle().toString();\n+        }),\n+        ADD_LAUNCHER_PROPERTY_FILE;\n+\n+        private Token() {\n+            this.valueSupplier = Optional.empty();\n+        }\n+\n+        private Token(Function<JPackageCommand, Object> valueSupplier) {\n+            this.valueSupplier = Optional.of(valueSupplier);\n+        }\n+\n+        String token() {\n+            return makeToken(name());\n+        }\n+\n+        TokenReplace asTokenReplace() {\n+            return tokenReplace;\n+        }\n+\n+        Optional<Object> expand(JPackageCommand cmd) {\n+            return valueSupplier.map(func -> func.apply(cmd));\n+        }\n+\n+        private static String makeToken(String v) {\n+            Objects.requireNonNull(v);\n+            return String.format(\"@@%s@@\", v);\n+        }\n+\n+        private final Optional<Function<JPackageCommand, Object>> valueSupplier;\n+        private final TokenReplace tokenReplace = new TokenReplace(token());\n+    }\n+\n+    public record TestSpec(Optional<PackageType> type, Optional<String> appDesc, List<String> addArgs,\n+            List<String> removeArgs, List<CannedFormattedString> expectedErrors) {\n+\n+        static final class Builder {\n+\n+            Builder type(PackageType v) {\n+                type = v;\n+                return this;\n+            }\n+\n+            Builder notype() {\n+                return type(null);\n+            }\n+\n+            Builder nativeType() {\n+                return type(NATIVE_TYPE);\n+            }\n+\n+            Builder appDesc(String v) {\n+                appDesc = v;\n+                return this;\n+            }\n+\n+            Builder noAppDesc() {\n+                return appDesc(null);\n+            }\n+\n+            Builder setAddArgs(List<String> v) {\n+                addArgs.clear();\n+                addArgs.addAll(v);\n+                return this;\n+            }\n+\n+            Builder setAddArgs(String... v) {\n+                return setAddArgs(List.of(v));\n+            }\n+\n+            Builder addArgs(List<String> v) {\n+                addArgs.addAll(v);\n+                return this;\n+            }\n+\n+            Builder addArgs(String... v) {\n+                return addArgs(List.of(v));\n+            }\n+\n+            Builder setRemoveArgs(List<String> v) {\n+                removeArgs.clear();\n+                removeArgs.addAll(v);\n+                return this;\n+            }\n+\n+            Builder setRemoveArgs(String... v) {\n+                return setRemoveArgs(List.of(v));\n+            }\n+\n+            Builder removeArgs(List<String> v) {\n+                removeArgs.addAll(v);\n+                return this;\n+            }\n+\n+            Builder removeArgs(String... v) {\n+                return removeArgs(List.of(v));\n+            }\n+\n+            Builder setErrors(List<CannedFormattedString> v) {\n+                expectedErrors = v;\n+                return this;\n+            }\n+\n+            Builder setErrors(CannedFormattedString... v) {\n+                return setErrors(List.of(v));\n+            }\n+\n+            Builder errors(List<CannedFormattedString> v) {\n+                expectedErrors.addAll(v);\n+                return this;\n+            }\n+\n+            Builder errors(CannedFormattedString... v) {\n+                return errors(List.of(v));\n+            }\n+\n+            Builder error(String key, Object ... args) {\n+                return errors(JPackageStringBundle.MAIN.cannedFormattedString(key, args));\n+            }\n+\n+            Builder invalidTypeArg(String arg, String... otherArgs) {\n+                return addArgs(arg).addArgs(otherArgs).error(\"ERR_InvalidTypeOption\", arg, type.getType());\n+            }\n+\n+            Builder unsupportedPlatformOption(String arg, String ... otherArgs) {\n+                return addArgs(arg).addArgs(otherArgs).error(\"ERR_UnsupportedOption\", arg);\n+            }\n+\n+            TestSpec create() {\n+                return new TestSpec(Optional.ofNullable(type), Optional.ofNullable(appDesc),\n+                        List.copyOf(addArgs), List.copyOf(removeArgs), List.copyOf(expectedErrors));\n+            }\n+\n+            private PackageType type = PackageType.IMAGE;\n+            private String appDesc = DEFAULT_APP_DESC;\n+            private List<String> addArgs = new ArrayList<>();\n+            private List<String> removeArgs = new ArrayList<>();\n+            private List<CannedFormattedString> expectedErrors = new ArrayList<>();\n+        }\n+\n+        public TestSpec {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(appDesc);\n+            Objects.requireNonNull(addArgs);\n+            addArgs.forEach(Objects::requireNonNull);\n+            Objects.requireNonNull(removeArgs);\n+            removeArgs.forEach(Objects::requireNonNull);\n+            if (expectedErrors.isEmpty()) {\n+                throw new IllegalArgumentException(\"The list of expected errors must be non-empty\");\n+            }\n+        }\n+\n+        void test() {\n+            test(Map.of());\n+        }\n+\n+        void test(Map<Token, Function<JPackageCommand, Object>> tokenValueSuppliers) {\n+            final var cmd = appDesc.map(JPackageCommand::helloAppImage).orElseGet(JPackageCommand::new);\n+            type.ifPresent(cmd::setPackageType);\n+\n+            removeArgs.forEach(cmd::removeArgumentWithValue);\n+            cmd.addArguments(addArgs);\n+\n+            final var tokenValueSupplier = TokenReplace.createCachingTokenValueSupplier(Stream.of(Token.values()).collect(toMap(Token::token, token -> {\n+                return () -> {\n+                    return token.expand(cmd).orElseGet(() -> {\n+                        final var tvs = Objects.requireNonNull(tokenValueSuppliers.get(token), () -> {\n+                            return String.format(\"No token value supplier for token [%s]\", token);\n+                        });\n+                        return tvs.apply(cmd);\n+                    });\n+                };\n+            })));\n+\n+            for (final var token : Token.values()) {\n+                final var newArgs = cmd.getAllArguments().stream().map(arg -> {\n+                    return token.asTokenReplace().applyTo(arg, tokenValueSupplier);\n+                }).toList();\n+                cmd.clearArguments().addArguments(newArgs);\n+            }\n+\n+            defaultInit(cmd, expectedErrors);\n+            cmd.execute(1);\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            final var sb = new StringBuilder();\n+            type.ifPresent(v -> {\n+                sb.append(v).append(\"; \");\n+            });\n+            appDesc.ifPresent(v -> {\n+                sb.append(\"app-desc=\").append(v).append(\"; \");\n+            });\n+            if (!addArgs.isEmpty()) {\n+                sb.append(\"args-add=\").append(addArgs).append(\"; \");\n+            }\n+            if (!removeArgs.isEmpty()) {\n+                sb.append(\"args-del=\").append(removeArgs).append(\"; \");\n+            }\n+            sb.append(\"errors=\").append(expectedErrors);\n+            return sb.toString();\n+        }\n+\n+        private static final String DEFAULT_APP_DESC = \"Hello\";\n+    }\n+\n+    private static TestSpec.Builder testSpec() {\n+        return new TestSpec.Builder();\n+    }\n+\n+    public static Collection<Object[]> basic() {\n+        final List<TestSpec> testCases = new ArrayList<>();\n+\n+        testCases.addAll(Stream.of(\n@@ -66,4 +304,2 @@\n-            {\"Hello\",\n-                    new String[]{\"--no-such-argument\"},\n-                    null,\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_InvalidOption\", \"--no-such-argument\")},\n+            testSpec().addArgs(\"--no-such-argument\")\n+                    .error(\"ERR_InvalidOption\", \"--no-such-argument\"),\n@@ -71,4 +307,1 @@\n-            {\"Hello\",\n-                    null,\n-                    new String[]{\"--main-jar\"},\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_NoEntryPoint\")},\n+            testSpec().removeArgs(\"--main-jar\").error(\"ERR_NoEntryPoint\"),\n@@ -76,5 +309,3 @@\n-            {\"Hello\",\n-                    null,\n-                    new String[]{\"--main-class\"},\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.no-main-class-with-main-jar\", \"hello.jar\"),\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.no-main-class-with-main-jar.advice\", \"hello.jar\")},\n+            testSpec().removeArgs(\"--main-class\")\n+                    .error(\"error.no-main-class-with-main-jar\", \"hello.jar\")\n+                    .error(\"error.no-main-class-with-main-jar.advice\", \"hello.jar\"),\n@@ -82,4 +313,2 @@\n-            {\"Hello\",\n-                    new String[]{\"--main-jar\", \"non-existent.jar\"},\n-                    null,\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"error.main-jar-does-not-exist\", \"non-existent.jar\")},\n+            testSpec().addArgs(\"--main-jar\", \"non-existent.jar\")\n+                    .error(\"error.main-jar-does-not-exist\", \"non-existent.jar\"),\n@@ -87,4 +316,5 @@\n-            {\"Hello\",\n-                    new String[]{\"--runtime-image\", \"non-existent.runtime\"},\n-                    null,\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"message.runtime-image-dir-does-not-exist\", \"runtime-image\", \"non-existent.runtime\")},\n+            testSpec().addArgs(\"--runtime-image\", \"non-existent.runtime\")\n+                    .error(\"message.runtime-image-dir-does-not-exist\", \"runtime-image\", \"non-existent.runtime\"),\n+            \/\/ non-existent app image\n+            testSpec().noAppDesc().nativeType().addArgs(\"--name\", \"foo\", \"--app-image\", \"non-existent.appimage\")\n+                    .error(\"ERR_AppImageNotExist\", \"non-existent.appimage\"),\n@@ -92,4 +322,8 @@\n-            {\"Hello\",\n-                    new String[]{\"--resource-dir\", \"non-existent.dir\"},\n-                    null,\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"message.resource-dir-does-not-exist\", \"resource-dir\", \"non-existent.dir\")},\n+            testSpec().addArgs(\"--resource-dir\", \"non-existent.dir\")\n+                    .error(\"message.resource-dir-does-not-exist\", \"resource-dir\", \"non-existent.dir\"),\n+            \/\/ non-existent icon\n+            testSpec().addArgs(\"--icon\", \"non-existent.icon\")\n+                    .error(\"ERR_IconFileNotExit\", cannedAbsolutePath(\"non-existent.icon\")),\n+            \/\/ non-existent license file\n+            testSpec().nativeType().addArgs(\"--license-file\", \"non-existent.license\")\n+                    .error(\"ERR_LicenseFileNotExit\"),\n@@ -97,9 +331,4 @@\n-            {\"Hello\",\n-                    new String[]{\"--type\", \"invalid-type\"},\n-                    null,\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_InvalidInstallerType\", \"invalid-type\")},\n-            \/\/ no --input\n-            {\"Hello\",\n-                    null,\n-                    new String[]{\"--input\"},\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_MissingArgument\", \"--input\")},\n+            testSpec().addArgs(\"--type\", \"invalid-type\")\n+                    .error(\"ERR_InvalidInstallerType\", \"invalid-type\"),\n+            \/\/ no --input for non-mudular app\n+            testSpec().removeArgs(\"--input\").error(\"error.no-input-parameter\"),\n@@ -107,5 +336,69 @@\n-            {\"com.other\/com.other.Hello\",\n-                    null,\n-                    new String[]{\"--module-path\"},\n-                    JPackageStringBundle.MAIN.cannedFormattedString(\"ERR_MissingArgument\", \"--runtime-image or --module-path\")},\n-        });\n+            testSpec().appDesc(\"com.other\/com.other.Hello\").removeArgs(\"--module-path\")\n+                    .error(\"ERR_MissingArgument\", \"--runtime-image or --module-path\"),\n+            \/\/ no main class in module path\n+            testSpec().noAppDesc().addArgs(\"--module\", \"java.base\", \"--runtime-image\", Token.JAVA_HOME.token())\n+                    .error(\"ERR_NoMainClass\"),\n+            \/\/ no module in module path\n+            testSpec().noAppDesc().addArgs(\"--module\", \"com.foo.bar\", \"--runtime-image\", Token.JAVA_HOME.token())\n+                    .error(\"error.no-module-in-path\", \"com.foo.bar\"),\n+            \/\/ --main-jar and --module-name\n+            testSpec().noAppDesc().addArgs(\"--main-jar\", \"foo.jar\", \"--module\", \"foo.bar\")\n+                    .error(\"ERR_BothMainJarAndModule\"),\n+            \/\/ non-existing argument file\n+            testSpec().noAppDesc().notype().addArgs(\"@foo\")\n+                    .error(\"ERR_CannotParseOptions\", \"foo\"),\n+            \/\/ invalid jlink option\n+            testSpec().addArgs(\"--jlink-options\", \"--foo\")\n+                    .error(\"error.jlink.failed\", \"Error: unknown option: --foo\")\n+        ).map(TestSpec.Builder::create).toList());\n+\n+        \/\/ forbidden jlink options\n+        testCases.addAll(Stream.of(\"--output\", \"--add-modules\", \"--module-path\").map(opt -> {\n+            return testSpec().addArgs(\"--jlink-options\", opt).error(\"error.blocked.option\", opt);\n+        }).map(TestSpec.Builder::create).toList());\n+\n+        \/\/ --runtime-image and --app-image are mutually-exclusive\n+        testCases.addAll(createRuntimeMutuallyExclusive(\"--app-image\", \"app-image\"));\n+        \/\/ --runtime-image and --app-modules are mutually-exclusive\n+        testCases.addAll(createRuntimeMutuallyExclusive(\"--add-modules\", \"foo.bar\", \"--module\", \"foo.bar\"));\n+        \/\/ --runtime-image and --jlink-options are mutually-exclusive\n+        testCases.addAll(createRuntimeMutuallyExclusive(\"--jlink-options\", \"--bind-services\", \"--module\", \"foo.bar\"));\n+\n+        return toTestArgs(testCases.stream());\n+    }\n+\n+    record ArgumentGroup(String arg, String... otherArgs) {\n+        ArgumentGroup {\n+            Objects.requireNonNull(arg);\n+            List.of(otherArgs).forEach(Objects::requireNonNull);\n+        }\n+\n+        String[] asArray() {\n+            return Stream.concat(Stream.of(arg), Stream.of(otherArgs)).toArray(String[]::new);\n+        }\n+    }\n+\n+    private static List<TestSpec> createRuntimeMutuallyExclusive(String arg, String... otherArgs) {\n+        return createMutuallyExclusive(\n+                new ArgumentGroup(\"--runtime-image\", Token.JAVA_HOME.token()),\n+                new ArgumentGroup(arg, otherArgs)\n+        ).map(TestSpec.Builder::noAppDesc).map(TestSpec.Builder::nativeType).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static Stream<TestSpec.Builder> createMutuallyExclusive(ArgumentGroup firstGroup, ArgumentGroup secondGroup) {\n+        final Supplier<TestSpec.Builder> createBuilder = () -> {\n+            return testSpec().error(\"ERR_MutuallyExclusiveOptions\", firstGroup.arg(), secondGroup.arg());\n+        };\n+        return Stream.of(\n+                createBuilder.get().addArgs(firstGroup.asArray()).addArgs(secondGroup.asArray()),\n+                createBuilder.get().addArgs(secondGroup.asArray()).addArgs(firstGroup.asArray()));\n+    }\n+\n+    public static Collection<Object[]> invalidAppVersion() {\n+        return fromTestSpecBuilders(Stream.of(\n+                \/\/ Invalid app version. Just cover all different error messages.\n+                \/\/ Extensive testing of invalid version strings is done in DottedVersionTest unit test.\n+                testSpec().addArgs(\"--app-version\", \"\").error(\"error.version-string-empty\"),\n+                testSpec().addArgs(\"--app-version\", \"1.\").error(\"error.version-string-zero-length-component\", \"1.\"),\n+                testSpec().addArgs(\"--app-version\", \"1.b.3\").error(\"error.version-string-invalid-component\", \"1.b.3\", \"b.3\")\n+        ));\n@@ -115,5 +408,10 @@\n-    @ParameterSupplier(\"input\")\n-    public static void test(String javaAppDesc, String[] jpackageArgs,\n-            String[] removeArgs, CannedFormattedString... expectedErrors) {\n-        \/\/ Init default jpackage test command line.\n-        var cmd = JPackageCommand.helloAppImage(javaAppDesc);\n+    @ParameterSupplier(\"basic\")\n+    @ParameterSupplier(value=\"testWindows\", ifOS = WINDOWS)\n+    @ParameterSupplier(value=\"testMac\", ifOS = MACOS)\n+    @ParameterSupplier(value=\"winOption\", ifNotOS = WINDOWS)\n+    @ParameterSupplier(value=\"linuxOption\", ifNotOS = LINUX)\n+    @ParameterSupplier(value=\"macOption\", ifNotOS = MACOS)\n+    @ParameterSupplier(value=\"invalidAppVersion\", ifOS = {WINDOWS,MACOS})\n+    public static void test(TestSpec spec) {\n+        spec.test();\n+    }\n@@ -121,1 +419,14 @@\n-        defaultInit(cmd, expectedErrors);\n+    @Test\n+    @Parameter({\"--input\", \"foo\"})\n+    @Parameter({\"--module-path\", \"dir\"})\n+    @Parameter({\"--add-modules\", \"java.base\"})\n+    @Parameter({\"--main-class\", \"Hello\"})\n+    @Parameter({\"--arguments\", \"foo\"})\n+    @Parameter({\"--java-options\", \"-Dfoo.bar=10\"})\n+    @Parameter({\"--add-launcher\", \"foo=foo.properties\"})\n+    @Parameter({\"--app-content\", \"dir\"})\n+    @Parameter(value=\"--win-console\", ifOS = WINDOWS)\n+    public static void testRuntimeInstallerInvalidOptions(String... args) {\n+        testSpec().noAppDesc().nativeType().addArgs(\"--runtime-image\", Token.JAVA_HOME.token()).addArgs(args)\n+                .error(\"ERR_NoInstallerEntryPoint\", args[0]).create().test();\n+    }\n@@ -123,2 +434,7 @@\n-        \/\/ Add arguments if requested.\n-        Optional.ofNullable(jpackageArgs).ifPresent(cmd::addArguments);\n+    @Test\n+    @ParameterSupplier\n+    public static void testAdditionLaunchers(TestSpec spec) {\n+        final Path propsFile = TKit.createTempFile(\"add-launcher.properties\");\n+        TKit.createPropertiesFile(propsFile, Map.of());\n+        spec.test(Map.of(Token.ADD_LAUNCHER_PROPERTY_FILE, cmd -> propsFile));\n+    }\n@@ -126,3 +442,8 @@\n-        \/\/ Remove arguments if requested.\n-        Optional.ofNullable(removeArgs).map(List::of).ifPresent(\n-                args -> args.forEach(cmd::removeArgumentWithValue));\n+    public static Collection<Object[]> testAdditionLaunchers() {\n+        return fromTestSpecBuilders(Stream.of(\n+            testSpec().addArgs(\"--add-launcher\", Token.ADD_LAUNCHER_PROPERTY_FILE.token())\n+                    .error(\"ERR_NoAddLauncherName\"),\n+            testSpec().removeArgs(\"--name\").addArgs(\"--name\", \"foo\", \"--add-launcher\", \"foo=\" + Token.ADD_LAUNCHER_PROPERTY_FILE.token())\n+                    .error(\"ERR_NoUniqueName\")\n+        ));\n+    }\n@@ -130,1 +451,5 @@\n-        cmd.execute(1);\n+    @Test\n+    @ParameterSupplier(\"invalidNames\")\n+    public static void testInvalidAppName(String name) {\n+        testSpec().removeArgs(\"--name\").addArgs(\"--name\", name)\n+                .error(\"ERR_InvalidAppName\", adjustTextStreamVerifierArg(name)).create().test();\n@@ -133,2 +458,8 @@\n-    @Test(ifOS = WINDOWS)\n-    public static void testWinService() {\n+    @Test\n+    @ParameterSupplier(\"invalidNames\")\n+    public static void testInvalidAddLauncherName(String name) {\n+        testAdditionLaunchers(testSpec()\n+                .addArgs(\"--add-launcher\", name + \"=\" + Token.ADD_LAUNCHER_PROPERTY_FILE.token())\n+                .error(\"ERR_InvalidSLName\", adjustTextStreamVerifierArg(name))\n+                .create());\n+    }\n@@ -136,4 +467,36 @@\n-        CannedFormattedString[] expectedErrors = new CannedFormattedString[] {\n-            JPackageStringBundle.MAIN.cannedFormattedString(\"error.missing-service-installer\"),\n-            JPackageStringBundle.MAIN.cannedFormattedString(\"error.missing-service-installer.advice\")\n-        };\n+    public static Collection<Object[]> invalidNames() {\n+        final List<String> data = new ArrayList<>();\n+        data.addAll(List.of(\"\", \"foo\/bar\", \"foo\\tbar\", \"foo\\rbar\", \"foo\\nbar\"));\n+        if (TKit.isWindows()) {\n+            data.add(\"foo\\\\bar\");\n+        }\n+        return toTestArgs(data.stream());\n+    }\n+\n+    public static Collection<Object[]> testWindows() {\n+        final List<TestSpec> testCases = new ArrayList<>();\n+\n+        testCases.addAll(PackageType.WINDOWS.stream().map(type -> {\n+            return Stream.of(\n+                    testSpec().type(type).addArgs(\"--launcher-as-service\")\n+                            .error(\"error.missing-service-installer\")\n+                            .error(\"error.missing-service-installer.advice\"),\n+                    \/\/ The below version strings are invalid for msi and exe packaging.\n+                    \/\/ They are valid for app image packaging.\n+                    testSpec().type(type).addArgs(\"--app-version\", \"1234\")\n+                            .error(\"error.msi-product-version-components\", \"1234\")\n+                            .error(\"error.version-string-wrong-format.advice\"),\n+                    testSpec().type(type).addArgs(\"--app-version\", \"1.2.3.4.5\")\n+                            .error(\"error.msi-product-version-components\", \"1.2.3.4.5\")\n+                            .error(\"error.version-string-wrong-format.advice\"),\n+                    testSpec().type(type).addArgs(\"--app-version\", \"256.1\")\n+                            .error(\"error.msi-product-version-major-out-of-range\", \"256.1\")\n+                            .error(\"error.version-string-wrong-format.advice\"),\n+                    testSpec().type(type).addArgs(\"--app-version\", \"1.256\")\n+                            .error(\"error.msi-product-version-minor-out-of-range\", \"1.256\")\n+                            .error(\"error.version-string-wrong-format.advice\"),\n+                    testSpec().type(type).addArgs(\"--app-version\", \"1.2.65536\")\n+                            .error(\"error.msi-product-version-build-out-of-range\", \"1.2.65536\")\n+                            .error(\"error.version-string-wrong-format.advice\")\n+            );\n+        }).flatMap(x -> x).map(TestSpec.Builder::create).toList());\n@@ -141,7 +504,1 @@\n-        new PackageTest().configureHelloApp()\n-                .addInitializer(cmd -> {\n-                    defaultInit(cmd, expectedErrors);\n-                    cmd.addArgument(\"--launcher-as-service\");\n-                })\n-                .setExpectedExitCode(1)\n-                .run(RunnablePackageTest.Action.CREATE);\n+        return toTestArgs(testCases.stream());\n@@ -150,1 +507,122 @@\n-    private static void defaultInit(JPackageCommand cmd, CannedFormattedString... expectedErrors) {\n+    public static Collection<Object[]> testMac() {\n+        final List<TestSpec> testCases = new ArrayList<>();\n+\n+        testCases.addAll(Stream.of(\n+                testSpec().addArgs(\"--app-version\", \"0.2\")\n+                        .error(\"message.version-string-first-number-not-zero\")\n+                        .error(\"error.invalid-cfbundle-version.advice\"),\n+                testSpec().addArgs(\"--app-version\", \"1.2.3.4\")\n+                        .error(\"message.version-string-too-many-components\")\n+                        .error(\"error.invalid-cfbundle-version.advice\"),\n+                testSpec().invalidTypeArg(\"--mac-installer-sign-identity\", \"foo\"),\n+                testSpec().type(PackageType.MAC_DMG).invalidTypeArg(\"--mac-installer-sign-identity\", \"foo\"),\n+                testSpec().invalidTypeArg(\"--mac-dmg-content\", \"foo\"),\n+                testSpec().type(PackageType.MAC_PKG).invalidTypeArg(\"--mac-dmg-content\", \"foo\"),\n+                testSpec().noAppDesc().addArgs(\"--app-image\", Token.APP_IMAGE.token())\n+                        .error(\"error.app-image.mac-sign.required\"),\n+                testSpec().type(PackageType.MAC_PKG).addArgs(\"--mac-package-identifier\", \"#1\")\n+                        .error(\"message.invalid-identifier\", \"#1\"),\n+                \/\/ Bundle for mac app store should not have runtime commands\n+                testSpec().nativeType().addArgs(\"--mac-app-store\", \"--jlink-options\", \"--bind-services\")\n+                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n+                testSpec().nativeType().addArgs(\"--mac-app-store\", \"--runtime-image\", Token.JAVA_HOME.token())\n+                        .error(\"ERR_MacAppStoreRuntimeBinExists\", JPackageCommand.cannedArgument(cmd -> {\n+                            return Path.of(cmd.getArgumentValue(\"--runtime-image\")).toAbsolutePath();\n+                        }, Token.JAVA_HOME.token()))\n+        ).map(TestSpec.Builder::create).toList());\n+\n+        \/\/ Test a few app-image options that should not be used when signing external app image\n+        testCases.addAll(Stream.of(\n+                new ArgumentGroup(\"--app-version\", \"2.0\"),\n+                new ArgumentGroup(\"--name\", \"foo\"),\n+                new ArgumentGroup(\"--mac-app-store\")\n+        ).map(argGroup -> {\n+            return testSpec().noAppDesc().addArgs(argGroup.asArray()).addArgs(\"--app-image\", Token.APP_IMAGE.token())\n+                    .error(\"ERR_InvalidOptionWithAppImageSigning\", argGroup.arg());\n+        }).<TestSpec>mapMulti((builder, acc) -> {\n+            \/\/ It should bail out with the same error message regardless of `--mac-sign` option.\n+            acc.accept(builder.create());\n+            acc.accept(builder.addArgs(\"--mac-sign\").create());\n+        }).toList());\n+\n+        testCases.addAll(createMutuallyExclusive(\n+                new ArgumentGroup(\"--mac-signing-key-user-name\", \"foo\"),\n+                new ArgumentGroup(\"--mac-app-image-sign-identity\", \"bar\")\n+        ).map(TestSpec.Builder::create).toList());\n+\n+        testCases.addAll(createMutuallyExclusive(\n+                new ArgumentGroup(\"--mac-signing-key-user-name\", \"foo\"),\n+                new ArgumentGroup(\"--mac-installer-sign-identity\", \"bar\")\n+        ).map(TestSpec.Builder::nativeType).map(TestSpec.Builder::create).toList());\n+\n+        return toTestArgs(testCases.stream());\n+    }\n+\n+    private record UnsupportedPlatformOption(String name, Optional<String> value) {\n+        UnsupportedPlatformOption {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(value);\n+        }\n+\n+        UnsupportedPlatformOption(String name) {\n+            this(name, Optional.empty());\n+        }\n+\n+        UnsupportedPlatformOption(String name, String value) {\n+            this(name, Optional.of(value));\n+        }\n+\n+        TestSpec toTestSpec() {\n+            return value.map(v -> testSpec().unsupportedPlatformOption(name, v)).orElseGet(\n+                    () -> testSpec().unsupportedPlatformOption(name)).create();\n+        }\n+\n+        static Collection<Object[]> createTestArgs(UnsupportedPlatformOption... options) {\n+            return toTestArgs(Stream.of(options).map(UnsupportedPlatformOption::toTestSpec));\n+        }\n+    }\n+\n+    public static Collection<Object[]> winOption() {\n+        return UnsupportedPlatformOption.createTestArgs(\n+                new UnsupportedPlatformOption(\"--win-console\"),\n+                new UnsupportedPlatformOption(\"--win-dir-chooser\"),\n+                new UnsupportedPlatformOption(\"--win-help-url\", \"url\"),\n+                new UnsupportedPlatformOption(\"--win-menu\"),\n+                new UnsupportedPlatformOption(\"--win-menu-group\", \"name\"),\n+                new UnsupportedPlatformOption(\"--win-per-user-install\"),\n+                new UnsupportedPlatformOption(\"--win-shortcut\"),\n+                new UnsupportedPlatformOption(\"--win-shortcut-prompt\"),\n+                new UnsupportedPlatformOption(\"--win-update-url\", \"url\"),\n+                new UnsupportedPlatformOption(\"--win-upgrade-uuid\", \"uuid\")\n+        );\n+    }\n+\n+    public static Collection<Object[]> linuxOption() {\n+        return UnsupportedPlatformOption.createTestArgs(\n+                new UnsupportedPlatformOption(\"--linux-package-name\", \"name\"),\n+                new UnsupportedPlatformOption(\"--linux-deb-maintainer\", \"email-address\"),\n+                new UnsupportedPlatformOption(\"--linux-menu-group\", \"menu-group-name\"),\n+                new UnsupportedPlatformOption(\"--linux-package-deps\", \"deps\"),\n+                new UnsupportedPlatformOption(\"--linux-rpm-license-type\", \"type\"),\n+                new UnsupportedPlatformOption(\"--linux-app-release\", \"release\"),\n+                new UnsupportedPlatformOption(\"--linux-app-category\", \"category-value\"),\n+                new UnsupportedPlatformOption(\"--linux-shortcut\")\n+        );\n+    }\n+\n+    public static Collection<Object[]> macOption() {\n+        return UnsupportedPlatformOption.createTestArgs(\n+                new UnsupportedPlatformOption(\"--mac-package-identifier\", \"identifier\"),\n+                new UnsupportedPlatformOption(\"--mac-package-name\", \"name\"),\n+                new UnsupportedPlatformOption(\"--mac-package-signing-prefix\", \"prefix\"),\n+                new UnsupportedPlatformOption(\"--mac-sign\"),\n+                new UnsupportedPlatformOption(\"--mac-signing-keychain\", \"keychain-name\"),\n+                new UnsupportedPlatformOption(\"--mac-signing-key-user-name\", \"name\"),\n+                new UnsupportedPlatformOption(\"--mac-app-store\"),\n+                new UnsupportedPlatformOption(\"--mac-entitlements\", \"path\"),\n+                new UnsupportedPlatformOption(\"--mac-app-category\", \"category\"),\n+                new UnsupportedPlatformOption(\"--mac-dmg-content\", \"additional-content\")\n+        );\n+    }\n+\n+    private static void defaultInit(JPackageCommand cmd, List<CannedFormattedString> expectedErrors) {\n@@ -161,6 +639,19 @@\n-        \/\/ Configure jpackage output verifier to look up the list of provided\n-        \/\/ errors in the order they are specified.\n-        cmd.validateOutput(Stream.of(expectedErrors)\n-                .map(CannedFormattedString::getValue)\n-                .map(TKit::assertTextStream)\n-                .reduce(TKit.TextStreamVerifier::andThen).get());\n+        cmd.validateOutput(expectedErrors.toArray(CannedFormattedString[]::new));\n+    }\n+\n+    private static PackageType defaultNativeType() {\n+        if (TKit.isLinux()) {\n+            return PackageType.LINUX.stream().filter(PackageType::isSupported).findFirst().orElseThrow();\n+        } else if (TKit.isOSX()) {\n+            return PackageType.MAC_DMG;\n+        } else if (TKit.isWindows()) {\n+            return PackageType.WIN_MSI;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    private static <T> Collection<Object[]> toTestArgs(Stream<T> stream) {\n+        return stream.map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n@@ -168,0 +659,12 @@\n+\n+    private static Collection<Object[]> fromTestSpecBuilders(Stream<TestSpec.Builder> stream) {\n+        return toTestArgs(stream.map(TestSpec.Builder::create));\n+    }\n+\n+    private static String adjustTextStreamVerifierArg(String str) {\n+        return LINE_SEP_REGEXP.split(str)[0];\n+    }\n+\n+    private static final Pattern LINE_SEP_REGEXP = Pattern.compile(\"\\\\R\");\n+\n+    private static final PackageType NATIVE_TYPE = defaultNativeType();\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":581,"deletions":78,"binary":false,"changes":659,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.JPackageStringBundle.MAIN;\n+\n@@ -26,1 +28,0 @@\n-\n@@ -30,0 +31,1 @@\n+import jdk.jpackage.test.JPackageCommand;\n@@ -114,3 +116,1 @@\n-        PackageTest packageTest = new PackageTest().excludeTypes(PackageType.MAC);\n-\n-        packageTest.configureHelloApp().addRunOnceInitializer(() -> {\n+        initPackageTest().addRunOnceInitializer(() -> {\n@@ -122,8 +122,4 @@\n-            cmd.addArguments(\"--file-associations\", propFile).saveConsoleOutput(true);\n-        }).setExpectedExitCode(1).addBundleVerifier((cmd, result) -> {\n-           TKit.assertTextStream(\n-                   \"No MIME types were specified for File Association number 1\")\n-                   .apply(result.getOutput().stream());\n-           TKit.assertTextStream(\n-                   \"Advice to fix: Specify MIME type for File Association number 1\")\n-                   .apply(result.getOutput().stream());\n+            cmd.addArguments(\"--file-associations\", propFile);\n+            cmd.validateOutput(\n+                    MAIN.cannedFormattedString(\"error.no-content-types-for-file-association\", 1),\n+                    MAIN.cannedFormattedString(\"error.no-content-types-for-file-association.advice\", 1));\n@@ -137,3 +133,1 @@\n-        PackageTest packageTest = new PackageTest().excludeTypes(PackageType.MAC);\n-\n-        packageTest.configureHelloApp().addRunOnceInitializer(() -> {\n+        initPackageTest().addRunOnceInitializer(() -> {\n@@ -146,8 +140,4 @@\n-            cmd.addArguments(\"--file-associations\", propFile).saveConsoleOutput(true);\n-        }).setExpectedExitCode(1).addBundleVerifier((cmd, result) -> {\n-           TKit.assertTextStream(\n-                   \"More than one MIME types was specified for File Association number 1\")\n-                   .apply(result.getOutput().stream());\n-           TKit.assertTextStream(\n-                   \"Advice to fix: Specify only one MIME type for File Association number 1\")\n-                   .apply(result.getOutput().stream());\n+            cmd.addArguments(\"--file-associations\", propFile);\n+            cmd.validateOutput(\n+                    MAIN.cannedFormattedString(\"error.too-many-content-types-for-file-association\", 1),\n+                    MAIN.cannedFormattedString(\"error.too-many-content-types-for-file-association.advice\", 1));\n@@ -156,0 +146,8 @@\n+\n+    private static PackageTest initPackageTest() {\n+        return new PackageTest()\n+                .excludeTypes(PackageType.MAC)\n+                .configureHelloApp()\n+                .addInitializer(JPackageCommand::setFakeRuntime)\n+                .setExpectedExitCode(1);\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/share\/FileAssociationsTest.java","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-        return JPackageCommand.helloAppImage(javaAppDesc).ignoreDefaultRuntime(true);\n+        return JPackageCommand.helloAppImage(javaAppDesc);\n","filename":"test\/jdk\/tools\/jpackage\/share\/JLinkOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    private final static String OPTION1 =\n+    private static final String OPTION1 =\n@@ -59,1 +59,1 @@\n-    private final static String OPTION2 =\n+    private static final String OPTION2 =\n@@ -61,1 +61,1 @@\n-    private final static String WARNING1 =\n+    private static final String WARNING1 =\n@@ -63,1 +63,1 @@\n-    private final static String WARNING2 =\n+    private static final String WARNING2 =\n@@ -78,4 +78,1 @@\n-        cmd = JPackageCommand.helloAppImage(javaAppDesc);\n-        if (jpackageArgs != null) {\n-            cmd.addArguments(jpackageArgs);\n-        }\n+        cmd = JPackageCommand.helloAppImage(javaAppDesc).addArguments(jpackageArgs).ignoreFakeRuntime();\n@@ -88,1 +85,0 @@\n-        TKit.assertNotNull(output, \"output is null\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/JavaOptionsEqualsTest.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        cmd = JPackageCommand.helloAppImage(javaAppDesc);\n+        cmd = JPackageCommand.helloAppImage(javaAppDesc).ignoreFakeRuntime();\n@@ -93,1 +93,0 @@\n-        TKit.assertNotNull(output, \"output is null\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/JavaOptionsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.jpackage.test.CannedFormattedString;\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -46,0 +48,1 @@\n+import static jdk.jpackage.test.JPackageCommand.cannedArgument;\n@@ -90,2 +93,2 @@\n-        Script expectedErrorMessage(String v) {\n-            expectedErrorMessage = v;\n+        Script expectedErrorMessage(String key, Object... args) {\n+            expectedErrorMessage = JPackageStringBundle.MAIN.cannedFormattedString(key, args);\n@@ -134,1 +137,1 @@\n-        private String expectedErrorMessage;\n+        private CannedFormattedString expectedErrorMessage;\n@@ -197,2 +200,1 @@\n-                            script.expectedErrorMessage(\n-                                    \"Error: Main application class is missing\");\n+                            script.expectedErrorMessage(\"ERR_NoMainClass\");\n@@ -201,1 +203,3 @@\n-                                    \"A main class was not specified nor was one found in the jar\");\n+                                    \"error.no-main-class-with-main-jar\", cannedArgument(cmd -> {\n+                                        return cmd.getArgumentValue(\"--main-jar\");\n+                                    }, \"MAIN-JAR\"));\n@@ -221,5 +225,1 @@\n-            List<String> output = cmd\n-                    .saveConsoleOutput(true)\n-                    .execute(1)\n-                    .getOutput();\n-            TKit.assertTextStream(script.expectedErrorMessage).apply(output.stream());\n+            cmd.validateOutput(script.expectedErrorMessage).execute(1);\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jpackage.test.CannedFormattedString;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -124,1 +126,1 @@\n-            final String expectedErrorMessage;\n+            final CannedFormattedString expectedErrorMessage;\n@@ -126,1 +128,2 @@\n-                expectedErrorMessage = \"Error: Missing argument: --runtime-image or --module-path\";\n+                expectedErrorMessage = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"ERR_MissingArgument\", \"--runtime-image or --module-path\");\n@@ -128,2 +131,2 @@\n-                expectedErrorMessage = String.format(\n-                        \"Failed to find %s module in module path\", appDesc.moduleName());\n+                expectedErrorMessage = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"error.no-module-in-path\", appDesc.moduleName());\n@@ -132,5 +135,1 @@\n-            List<String> output = cmd\n-                    .saveConsoleOutput(true)\n-                    .execute(1)\n-                    .getOutput();\n-            TKit.assertTextStream(expectedErrorMessage).apply(output.stream());\n+            cmd.validateOutput(expectedErrorMessage).execute(1);\n@@ -142,3 +141,3 @@\n-    private final static String GOOD_PATH = \"@GoodPath@\";\n-    private final static String EMPTY_DIR = \"@EmptyDir@\";\n-    private final static String NON_EXISTING_DIR = \"@NonExistingDir@\";\n+    private static final String GOOD_PATH = \"@GoodPath@\";\n+    private static final String EMPTY_DIR = \"@EmptyDir@\";\n+    private static final String NON_EXISTING_DIR = \"@NonExistingDir@\";\n","filename":"test\/jdk\/tools\/jpackage\/share\/ModulePathTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import java.util.Collection;\n-import java.util.List;\n-import jdk.jpackage.test.Annotations.Parameters;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-\n-\/*\n- * @test\n- * @summary jpackage application version testing\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @compile -Xlint:all -Werror NonExistentTest.java\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=NonExistentTest\n- *\/\n-\n-public final class NonExistentTest {\n-\n-    private final String expectedError;\n-    private final JPackageCommand cmd;\n-\n-    @Parameters\n-    public static Collection<?> input() {\n-        return List.of(new Object[][]{\n-            \/\/ non-existent icon\n-            {\"Hello\",\n-                    new String[]{\"--icon\", \"non-existent\"},\n-                    \"Error:\"},\n-            {\"com.other\/com.other.Hello\",\n-                    new String[]{\"--icon\", \"non-existent\"},\n-                    \"Error:\"},\n-            \/\/ non-existent input\n-            {\"Hello\",\n-                    new String[]{\"--input\", \"non-existent\"},\n-                    \"Exception:\"},\n-            {\"com.other\/com.other.Hello\",\n-                    new String[]{\"--input\", \"non-existent\"},\n-                    \"Exception:\"},\n-            \/\/ non-existent resource-dir\n-            {\"Hello\",\n-                    new String[]{\"--resource-dir\", \"non-existent\"},\n-                    \"Specified resource directory\"},\n-            {\"com.other\/com.other.Hello\",\n-                    new String[]{\"--resource-dir\", \"non-existent\"},\n-                    \"Specified resource directory\"},\n-        });\n-    }\n-\n-    public NonExistentTest(String javaAppDesc, String[] jpackageArgs,\n-                String expectedError) {\n-        this.expectedError = expectedError;\n-\n-        cmd = JPackageCommand.helloAppImage(javaAppDesc)\n-                .saveConsoleOutput(true).dumpOutput(true);\n-        if (jpackageArgs != null) {\n-            cmd.addArguments(jpackageArgs);\n-        }\n-    }\n-\n-    @Test\n-    public void test() {\n-        List<String> output = cmd.execute(1).getOutput();\n-        TKit.assertNotNull(output, \"output is null\");\n-        TKit.assertTextStream(expectedError).apply(output.stream());\n-    }\n-}\n","filename":"test\/jdk\/tools\/jpackage\/share\/NonExistentTest.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Files;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import jdk.jpackage.test.AppImageFile;\n-import jdk.jpackage.test.Annotations.Parameters;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-\n-\/*\n- * @test\n- * @summary Test jpackage output for erroneous input with --type \"app-image\" and --app-image\n- * @library \/test\/jdk\/tools\/jpackage\/helpers\n- * @build jdk.jpackage.test.*\n- * @compile -Xlint:all -Werror PredefinedAppImageErrorTest.java\n- *\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=PredefinedAppImageErrorTest\n- *  --jpt-before-run=jdk.jpackage.test.JPackageCommand.useExecutableByDefault\n- *\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=PredefinedAppImageErrorTest\n- *  --jpt-before-run=jdk.jpackage.test.JPackageCommand.useToolProviderByDefault\n- *\/\n-\n-public final class PredefinedAppImageErrorTest {\n-\n-    private final String expectedError;\n-    private final JPackageCommand cmd;\n-\n-    @Parameters\n-    public static Collection<?> input() throws IOException {\n-        return List.of(new Object[][]{\n-            \/\/ --mac-sign is required\n-            {\"Hello\",\n-                    null,\n-                    new String[]{\"--input\", \"--dest\", \"--name\", \"--main-jar\", \"--main-class\"},\n-                    TKit.isOSX() ?\n-                            \"--mac-sign option is required\" :\n-                            \"Option [--app-image] is not valid with type [app-image]\"\n-                            },\n-            \/\/ --mac-app-store is required\n-            {\"Hello\",\n-                    new String[]{\"--mac-sign\", \"--mac-app-store\", \"--mac-app-image-sign-identity\", \"test\"},\n-                    new String[]{\"--input\", \"--dest\", \"--name\", \"--main-jar\", \"--main-class\"},\n-                    TKit.isOSX() ?\n-                            \"Option [--mac-app-store] is not valid\" :\n-                            \"Option [--mac-sign] is not valid on this platform\"\n-                            },\n-        });\n-    }\n-\n-    public PredefinedAppImageErrorTest(String javaAppDesc, String[] jpackageArgs,\n-                String[] removeArgs,\n-                String expectedError) {\n-        this.expectedError = expectedError;\n-\n-        cmd = JPackageCommand.helloAppImage(javaAppDesc)\n-                .saveConsoleOutput(true).dumpOutput(true);\n-        if (jpackageArgs != null) {\n-            cmd.addArguments(jpackageArgs);\n-        }\n-        if (removeArgs != null) {\n-            for (String arg : removeArgs) {\n-                cmd.removeArgumentWithValue(arg);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void test() throws IOException {\n-        getDummyAppImage(cmd);\n-\n-        List<String> output = cmd.execute(1).getOutput();\n-        TKit.assertNotNull(output, \"output is null\");\n-        TKit.assertTextStream(expectedError).apply(output.stream());\n-    }\n-\n-    private void getDummyAppImage(JPackageCommand cmd) throws IOException {\n-        Path dummyAppFolder\n-            = TKit.createTempDirectory(\"DummyAppImage\").toAbsolutePath();\n-\n-        Path dummyAppFile\n-            = dummyAppFolder.resolve(\"DummyAppFile\").toAbsolutePath();\n-        Files.createFile(dummyAppFile);\n-\n-        cmd.addArguments(\"--app-image\", dummyAppFolder.toString());\n-        new AppImageFile(\"PredefinedAppImageErrorTest\", \"Hello\").save(dummyAppFolder);\n-    }\n-\n-}\n","filename":"test\/jdk\/tools\/jpackage\/share\/PredefinedAppImageErrorTest.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n@@ -36,0 +37,1 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -86,1 +88,3 @@\n-    public static void testUsrInstallDir() {\n+    @Parameter(\"\/usr\")\n+    @Parameter(\"\/usr\/lib\/Java\")\n+    public static void testUsrInstallDir(String installDir) {\n@@ -93,4 +97,9 @@\n-    public static void testUsrInstallDir2() {\n-        init(PackageType.LINUX)\n-        .addInitializer(cmd -> cmd.addArguments(\"--install-dir\", \"\/usr\/lib\/Java\"))\n-        .run();\n+    public static void testName() {\n+        \/\/ Test that jpackage can derive package name from the path to runtime image.\n+        init(PackageType.NATIVE)\n+        .addInitializer(cmd -> cmd.removeArgumentWithValue(\"--name\"))\n+        \/\/ Don't attempt to install this package as it may have an odd name derived from\n+        \/\/ the runtime image path. Say, on Linux for `--runtime-image foo\/bar\/sed`\n+        \/\/ command line jpackage will create a package named 'sed' that will conflict\n+        \/\/ with the default 'sed' package.\n+        .run(Action.CREATE_AND_UNPACK);\n@@ -160,1 +169,2 @@\n-        });\n+        })\n+        .forTypes(types);\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"}]}