{"files":[{"patch":"@@ -225,0 +225,4 @@\n+# Fallback linker\n+# This needs to go before 'LIB_DETERMINE_DEPENDENCIES'\n+JDKOPT_SETUP_FALLBACK_LINKER\n+\n","filename":"make\/autoconf\/configure.ac","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -906,0 +906,19 @@\n+\n+################################################################################\n+#\n+# fallback linker\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_FALLBACK_LINKER],\n+[\n+  FALLBACK_LINKER_DEFAULT=false\n+\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+    FALLBACK_LINKER_DEFAULT=true\n+  fi\n+\n+  UTIL_ARG_ENABLE(NAME: fallback-linker, DEFAULT: $FALLBACK_LINKER_DEFAULT,\n+      RESULT: ENABLE_FALLBACK_LINKER,\n+      DESC: [enable libffi-based fallback implementation of java.lang.foreign.Linker],\n+      CHECKING_MSG: [if fallback linker enabled])\n+  AC_SUBST(ENABLE_FALLBACK_LINKER)\n+])\n","filename":"make\/autoconf\/jdk-options.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  if HOTSPOT_CHECK_JVM_VARIANT(zero); then\n+  if HOTSPOT_CHECK_JVM_VARIANT(zero) || test \"x$ENABLE_FALLBACK_LINKER\" = \"xtrue\"; then\n","filename":"make\/autoconf\/libraries.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,0 +410,3 @@\n+# Fallback linker\n+ENABLE_FALLBACK_LINKER:=@ENABLE_FALLBACK_LINKER@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -590,1 +590,1 @@\n-            dependencies: [\"devkit\", \"gtest\"],\n+            dependencies: [\"devkit\", \"gtest\", \"libffi\"],\n@@ -594,1 +594,2 @@\n-                \"--enable-libffi-bundling\"\n+                \"--with-libffi=\" + input.get(\"libffi\", \"home_path\"),\n+                \"--enable-libffi-bundling\",\n@@ -747,0 +748,34 @@\n+    \/\/ Define artifact just for linux-x64-zero, which is the only one we test on\n+    [\"linux-x64\"].forEach(function (name) {\n+        var o = artifactData[name]\n+        var pf = o.platform\n+        var jdk_subdir = (o.jdk_subdir != null ? o.jdk_subdir : \"jdk-\" + data.version);\n+        var jdk_suffix = (o.jdk_suffix != null ? o.jdk_suffix : \"tar.gz\");\n+        var zeroName = name + \"-zero\";\n+        profiles[zeroName].artifacts = {\n+            jdk: {\n+                local: \"bundles\/\\\\(jdk.*bin.\" + jdk_suffix + \"\\\\)\",\n+                remote: [\n+                    \"bundles\/\" + pf + \"\/jdk-\" + data.version + \"_\" + pf + \"_bin-zero.\" + jdk_suffix,\n+                ],\n+                subdir: jdk_subdir,\n+                exploded: \"images\/jdk\",\n+            },\n+            test: {\n+                    local: \"bundles\/\\\\(jdk.*bin-tests.tar.gz\\\\)\",\n+                    remote: [\n+                        \"bundles\/\" + pf + \"\/jdk-\" + data.version + \"_\" + pf + \"_bin-zero-tests.tar.gz\",\n+                    ],\n+                    exploded: \"images\/test\"\n+            },\n+            jdk_symbols: {\n+                    local: \"bundles\/\\\\(jdk.*bin-symbols.tar.gz\\\\)\",\n+                    remote: [\n+                        \"bundles\/\" + pf + \"\/jdk-\" + data.version + \"_\" + pf + \"_bin-zero-symbols.tar.gz\",\n+                    ],\n+                    subdir: jdk_subdir,\n+                    exploded: \"images\/jdk\"\n+                },\n+            };\n+    });\n+\n@@ -1237,0 +1272,7 @@\n+\n+        libffi: {\n+            organization: common.organization,\n+            module: \"libffi-\" + input.build_platform,\n+            ext: \"tar.gz\",\n+            revision: \"3.4.2+1.0\"\n+        },\n","filename":"make\/conf\/jib-profiles.js","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+JVM_IsForeignLinkerSupported\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This script generates a libffi bundle. On linux by building it from source\n+# using a devkit, which should match the devkit used to build the JDK.\n+#\n+# Set MAKE_ARGS to add parameters to make. Ex:\n+#\n+# $ MAKE_ARGS=-j32 bash createLibffiBundle.sh\n+#\n+# The script tries to behave well on multiple invocations, only performing steps\n+# not already done. To redo a step, manually delete the target files from that\n+# step.\n+#\n+# Note that the libtool and texinfo packages are needed to build libffi\n+# $ sudo apt install libtool texinfo\n+\n+LIBFFI_VERSION=3.4.2\n+\n+BUNDLE_NAME=libffi-$LIBFFI_VERSION.tar.gz\n+\n+SCRIPT_FILE=\"$(basename $0)\"\n+SCRIPT_DIR=\"$(cd \"$(dirname $0)\" > \/dev\/null && pwd)\"\n+OUTPUT_DIR=\"${SCRIPT_DIR}\/..\/..\/build\/libffi\"\n+SRC_DIR=\"$OUTPUT_DIR\/src\"\n+DOWNLOAD_DIR=\"$OUTPUT_DIR\/download\"\n+INSTALL_DIR=\"$OUTPUT_DIR\/install\"\n+IMAGE_DIR=\"$OUTPUT_DIR\/image\"\n+\n+USAGE=\"$0 <devkit dir>\"\n+\n+if [ \"$1\" = \"\" ]; then\n+    echo $USAGE\n+    exit 1\n+fi\n+DEVKIT_DIR=\"$1\"\n+\n+# Download source distros\n+mkdir -p $DOWNLOAD_DIR\n+cd $DOWNLOAD_DIR\n+SOURCE_TAR=v$LIBFFI_VERSION.tar.gz\n+if [ ! -f $SOURCE_TAR ]; then\n+    wget https:\/\/github.com\/libffi\/libffi\/archive\/refs\/tags\/v$LIBFFI_VERSION.tar.gz\n+fi\n+\n+# Unpack src\n+mkdir -p $SRC_DIR\n+cd $SRC_DIR\n+LIBFFI_DIRNAME=libffi-$LIBFFI_VERSION\n+LIBFFI_DIR=$SRC_DIR\/$LIBFFI_DIRNAME\n+if [ ! -d $LIBFFI_DIRNAME ]; then\n+    echo \"Unpacking $SOURCE_TAR\"\n+    tar xf $DOWNLOAD_DIR\/$SOURCE_TAR\n+fi\n+\n+# Build\n+cd $LIBFFI_DIR\n+if [ ! -e $LIBFFI_DIR\/configure ]; then\n+  bash .\/autogen.sh\n+fi\n+bash .\/configure --prefix=$INSTALL_DIR CC=$DEVKIT_DIR\/bin\/gcc CXX=$DEVKIT_DIR\/bin\/g++\n+\n+# Run with nice to keep system usable during build.\n+nice make $MAKE_ARGS install\n+\n+mkdir -p $IMAGE_DIR\n+# Extract what we need into an image\n+if [ ! -e $IMAGE_DIR\/lib\/libffi.so ]; then\n+  echo \"Copying libffi.so* to image\"\n+  mkdir -p $IMAGE_DIR\/lib\n+  cp -a $INSTALL_DIR\/lib64\/libffi.so* $IMAGE_DIR\/lib\/\n+fi\n+if [ ! -e $IMAGE_DIR\/include\/ ]; then\n+  echo \"Copying include to image\"\n+  mkdir -p $IMAGE_DIR\/include\n+  cp -a $INSTALL_DIR\/include\/. $IMAGE_DIR\/include\/\n+fi\n+if [ ! -e $IMAGE_DIR\/$SCRIPT_FILE ]; then\n+  echo \"Copying this script to image\"\n+  cp -a $SCRIPT_DIR\/$SCRIPT_FILE $IMAGE_DIR\/\n+fi\n+\n+# Create bundle\n+if [ ! -e $OUTPUT_DIR\/$BUNDLE_NAME ]; then\n+  echo \"Creating $OUTPUT_DIR\/$BUNDLE_NAME\"\n+  cd $IMAGE_DIR\n+  tar zcf $OUTPUT_DIR\/$BUNDLE_NAME *\n+fi\n","filename":"make\/devkit\/createLibffiBundle.sh","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -218,0 +218,15 @@\n+\n+################################################################################\n+# Create fallback linker lib\n+\n+ifeq ($(ENABLE_FALLBACK_LINKER), true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBFALLBACKLINKER, \\\n+      NAME := fallbackLinker, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) $(LIBFFI_CFLAGS), \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+                 $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := $(LIBFFI_LIBS), \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBFALLBACKLINKER)\n+endif\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  bool _needs_transition;\n@@ -63,1 +64,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -73,0 +75,1 @@\n+     _needs_transition(needs_transition),\n@@ -103,1 +106,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n@@ -109,1 +113,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -166,1 +171,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -194,1 +199,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -204,4 +209,5 @@\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n+  if (_needs_transition) {\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, rfp, the_pc, tmp1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -209,4 +215,5 @@\n-  \/\/ State transition\n-  __ mov(tmp1, _thread_in_native);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    \/\/ State transition\n+    __ mov(tmp1, _thread_in_native);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+  }\n@@ -260,11 +267,0 @@\n-  __ mov(tmp1, _thread_in_native_trans);\n-  __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n-              Assembler::StoreLoad | Assembler::StoreStore);\n-  }\n-\n-  __ verify_sve_vector_length(tmp1);\n-\n@@ -273,0 +269,11 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ mov(tmp1, _thread_in_native_trans);\n+    __ strw(tmp1, Address(rthread, JavaThread::thread_state_offset()));\n+\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n+                Assembler::StoreLoad | Assembler::StoreStore);\n+    }\n@@ -274,1 +281,1 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n+    __ verify_sve_vector_length(tmp1);\n@@ -276,2 +283,1 @@\n-  __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n-  __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/, tmp1);\n@@ -279,1 +285,2 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ ldrw(tmp1, Address(rthread, JavaThread::suspend_flags_offset()));\n+    __ cbnzw(tmp1, L_safepoint_poll_slow_path);\n@@ -281,4 +288,1 @@\n-  \/\/ change thread state\n-  __ mov(tmp1, _thread_in_Java);\n-  __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n-  __ stlrw(tmp1, tmp2);\n+    __ bind(L_after_safepoint_poll);\n@@ -286,7 +290,10 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n-  __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ br(Assembler::EQ, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ mov(tmp1, _thread_in_Java);\n+    __ lea(tmp2, Address(rthread, JavaThread::thread_state_offset()));\n+    __ stlrw(tmp1, tmp2);\n+\n+    __ block_comment(\"reguard stack check\");\n+    __ ldrb(tmp1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+    __ cmpw(tmp1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ br(Assembler::EQ, L_reguard);\n+    __ bind(L_after_reguard);\n@@ -294,1 +301,2 @@\n-  __ reset_last_Java_frame(true);\n+    __ reset_last_Java_frame(true);\n+  }\n@@ -301,2 +309,3 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n@@ -304,4 +313,4 @@\n-  if (should_save_return_value) {\n-    \/\/ Need to save the native result registers around any runtime calls.\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      \/\/ Need to save the native result registers around any runtime calls.\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -309,4 +318,4 @@\n-  __ mov(c_rarg0, rthread);\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-  __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ blr(tmp1);\n+    __ mov(c_rarg0, rthread);\n+    assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+    __ lea(tmp1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ blr(tmp1);\n@@ -314,3 +323,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -318,2 +327,2 @@\n-  __ b(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ b(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -323,2 +332,2 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n@@ -326,3 +335,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -330,1 +339,1 @@\n-  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), tmp1);\n@@ -332,3 +341,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -336,1 +345,1 @@\n-  __ b(L_after_reguard);\n+    __ b(L_after_reguard);\n@@ -338,1 +347,2 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":76,"deletions":66,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+bool ForeignGlobals::has_port() {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  bool _needs_transition;\n@@ -64,1 +65,2 @@\n-                        int captured_state_mask)\n+                        int captured_state_mask,\n+                        bool needs_transition)\n@@ -74,0 +76,1 @@\n+     _needs_transition(needs_transition),\n@@ -104,1 +107,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n@@ -110,1 +114,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -163,1 +168,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -193,1 +198,1 @@\n-  _oop_maps = new OopMapSet();\n+  _oop_maps = _needs_transition ? new OopMapSet() : nullptr;\n@@ -203,11 +208,13 @@\n-  __ block_comment(\"{ thread java2native\");\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(sp, fp, the_pc, t0);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n-\n-  \/\/ State transition\n-  __ mv(t0, _thread_in_native);\n-  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n-  __ block_comment(\"} thread java2native\");\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread java2native\");\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(sp, fp, the_pc, t0);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n+\n+    \/\/ State transition\n+    __ mv(t0, _thread_in_native);\n+    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+    __ block_comment(\"} thread java2native\");\n+  }\n@@ -263,7 +270,0 @@\n-  __ block_comment(\"{ thread native2java\");\n-  __ mv(t0, _thread_in_native_trans);\n-  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n-\n-  \/\/ Force this write out before the read below\n-  __ membar(MacroAssembler::AnyAny);\n-\n@@ -272,3 +272,6 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n-  __ lwu(t0, Address(xthread, JavaThread::suspend_flags_offset()));\n-  __ bnez(t0, L_safepoint_poll_slow_path);\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread native2java\");\n+    __ mv(t0, _thread_in_native_trans);\n+    __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n@@ -276,1 +279,2 @@\n-  __ bind(L_after_safepoint_poll);\n+    \/\/ Force this write out before the read below\n+    __ membar(MacroAssembler::AnyAny);\n@@ -278,3 +282,3 @@\n-  __ mv(t0, _thread_in_Java);\n-  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-  __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+    __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    __ lwu(t0, Address(xthread, JavaThread::suspend_flags_offset()));\n+    __ bnez(t0, L_safepoint_poll_slow_path);\n@@ -282,7 +286,1 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ lbu(t0, Address(xthread, JavaThread::stack_guard_state_offset()));\n-  __ mv(t1, StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ beq(t0, t1, L_reguard);\n-  __ bind(L_after_reguard);\n+    __ bind(L_after_safepoint_poll);\n@@ -290,2 +288,14 @@\n-  __ reset_last_Java_frame(true);\n-  __ block_comment(\"} thread native2java\");\n+    \/\/ change thread state\n+    __ mv(t0, _thread_in_Java);\n+    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+    __ sw(t0, Address(xthread, JavaThread::thread_state_offset()));\n+\n+    __ block_comment(\"reguard stack check\");\n+    __ lbu(t0, Address(xthread, JavaThread::stack_guard_state_offset()));\n+    __ mv(t1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ beq(t0, t1, L_reguard);\n+    __ bind(L_after_reguard);\n+\n+    __ reset_last_Java_frame(true);\n+    __ block_comment(\"} thread native2java\");\n+  }\n@@ -298,2 +308,3 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n@@ -301,4 +312,4 @@\n-  if (should_save_return_value) {\n-    \/\/ Need to save the native result registers around any runtime calls.\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      \/\/ Need to save the native result registers around any runtime calls.\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -306,3 +317,3 @@\n-  __ mv(c_rarg0, xthread);\n-  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n-  __ rt_call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n+    __ mv(c_rarg0, xthread);\n+    assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+    __ rt_call(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n@@ -310,5 +321,5 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n-  __ j(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n+    __ j(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -318,2 +329,2 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n@@ -321,4 +332,4 @@\n-  if (should_save_return_value) {\n-    \/\/ Need to save the native result registers around any runtime calls.\n-    out_reg_spiller.generate_spill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      \/\/ Need to save the native result registers around any runtime calls.\n+      out_reg_spiller.generate_spill(_masm, spill_offset);\n+    }\n@@ -326,1 +337,1 @@\n-  __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n@@ -328,3 +339,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_offset);\n+    }\n@@ -332,2 +343,3 @@\n-  __ j(L_after_reguard);\n-  __ block_comment(\"} L_reguard\");\n+    __ j(L_after_reguard);\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":77,"deletions":65,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+bool ForeignGlobals::has_port() {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool _needs_transition;\n@@ -62,1 +63,2 @@\n-                         int captured_state_mask)\n+                         int captured_state_mask,\n+                         bool needs_transition)\n@@ -72,0 +74,1 @@\n+     _needs_transition(needs_transition),\n@@ -102,1 +105,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n@@ -108,1 +112,2 @@\n-                          needs_return_buffer, captured_state_mask);\n+                          needs_return_buffer, captured_state_mask,\n+                          needs_transition);\n@@ -164,1 +169,1 @@\n-  bool should_save_return_value = !_needs_return_buffer;\n+  bool should_save_return_value = !_needs_return_buffer && _needs_transition;\n@@ -193,1 +198,1 @@\n-  _oop_maps  = new OopMapSet();\n+  _oop_maps  = _needs_transition ? new OopMapSet() : nullptr;\n@@ -203,1 +208,6 @@\n-  address the_pc = __ pc();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread java2native\");\n+    address the_pc = __ pc();\n+    __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n+    OopMap* map = new OopMap(_frame_size_slots, 0);\n+    _oop_maps->add_gc_map(the_pc - start, map);\n@@ -205,8 +215,4 @@\n-  __ block_comment(\"{ thread java2native\");\n-  __ set_last_Java_frame(rsp, rbp, (address)the_pc, rscratch1);\n-  OopMap* map = new OopMap(_frame_size_slots, 0);\n-  _oop_maps->add_gc_map(the_pc - start, map);\n-\n-  \/\/ State transition\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-  __ block_comment(\"} thread java2native\");\n+    \/\/ State transition\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+    __ block_comment(\"} thread java2native\");\n+  }\n@@ -266,12 +272,0 @@\n-  __ block_comment(\"{ thread native2java\");\n-  __ restore_cpu_control_state_after_jni(rscratch1);\n-\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n-\n-  \/\/ Force this write out before the read below\n-  if (!UseSystemMemoryBarrier) {\n-    __ membar(Assembler::Membar_mask_bits(\n-            Assembler::LoadLoad | Assembler::LoadStore |\n-            Assembler::StoreLoad | Assembler::StoreStore));\n-  }\n-\n@@ -280,0 +274,7 @@\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  if (_needs_transition) {\n+    __ block_comment(\"{ thread native2java\");\n+    __ restore_cpu_control_state_after_jni(rscratch1);\n+\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n@@ -281,3 +282,6 @@\n-  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n-  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+    \/\/ Force this write out before the read below\n+    if (!UseSystemMemoryBarrier) {\n+      __ membar(Assembler::Membar_mask_bits(\n+              Assembler::LoadLoad | Assembler::LoadStore |\n+              Assembler::StoreLoad | Assembler::StoreStore));\n+    }\n@@ -285,1 +289,3 @@\n-  __ bind(L_after_safepoint_poll);\n+    __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, true \/* at_return *\/, false \/* in_nmethod *\/);\n+    __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+    __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n@@ -287,2 +293,1 @@\n-  \/\/ change thread state\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+    __ bind(L_after_safepoint_poll);\n@@ -290,6 +295,2 @@\n-  __ block_comment(\"reguard stack check\");\n-  Label L_reguard;\n-  Label L_after_reguard;\n-  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n-  __ jcc(Assembler::equal, L_reguard);\n-  __ bind(L_after_reguard);\n+    \/\/ change thread state\n+    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n@@ -297,2 +298,8 @@\n-  __ reset_last_Java_frame(r15_thread, true);\n-  __ block_comment(\"} thread native2java\");\n+    __ block_comment(\"reguard stack check\");\n+    __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+    __ jcc(Assembler::equal, L_reguard);\n+    __ bind(L_after_reguard);\n+\n+    __ reset_last_Java_frame(r15_thread, true);\n+    __ block_comment(\"} thread native2java\");\n+  }\n@@ -305,3 +312,4 @@\n-  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n-  __ bind(L_safepoint_poll_slow_path);\n-  __ vzeroupper();\n+  if (_needs_transition) {\n+    __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+    __ bind(L_safepoint_poll_slow_path);\n+    __ vzeroupper();\n@@ -309,3 +317,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -313,7 +321,7 @@\n-  __ mov(c_rarg0, r15_thread);\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    __ mov(c_rarg0, r15_thread);\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -321,3 +329,3 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -325,2 +333,2 @@\n-  __ jmp(L_after_safepoint_poll);\n-  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+    __ jmp(L_after_safepoint_poll);\n+    __ block_comment(\"} L_safepoint_poll_slow_path\");\n@@ -330,7 +338,3 @@\n-  __ block_comment(\"{ L_reguard\");\n-  __ bind(L_reguard);\n-  __ vzeroupper();\n-\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n-  }\n+    __ block_comment(\"{ L_reguard\");\n+    __ bind(L_reguard);\n+    __ vzeroupper();\n@@ -338,6 +342,3 @@\n-  __ mov(r12, rsp); \/\/ remember sp\n-  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n-  __ andptr(rsp, -16); \/\/ align stack as required by ABI\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-  __ mov(rsp, r12); \/\/ restore sp\n-  __ reinit_heapbase();\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_spill(_masm, spill_rsp_offset);\n+    }\n@@ -345,3 +346,6 @@\n-  if (should_save_return_value) {\n-    out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n-  }\n+    __ mov(r12, rsp); \/\/ remember sp\n+    __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows\n+    __ andptr(rsp, -16); \/\/ align stack as required by ABI\n+    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+    __ mov(rsp, r12); \/\/ restore sp\n+    __ reinit_heapbase();\n@@ -349,1 +353,3 @@\n-  __ jmp(L_after_reguard);\n+    if (should_save_return_value) {\n+      out_reg_spiller.generate_fill(_masm, spill_rsp_offset);\n+    }\n@@ -351,1 +357,1 @@\n-  __ block_comment(\"} L_reguard\");\n+    __ jmp(L_after_reguard);\n@@ -353,0 +359,2 @@\n+    __ block_comment(\"} L_reguard\");\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":84,"deletions":76,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+bool ForeignGlobals::has_port() {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-                                                int captured_state_mask) {\n+                                                int captured_state_mask,\n+                                                bool needs_transition) {\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+bool ForeignGlobals::has_port() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#ifndef FFI_GO_CLOSURES\n+#ifdef __APPLE__\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,0 +177,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsForeignLinkerSupported(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-    value_ptr++;\n@@ -46,0 +45,1 @@\n+  value_ptr++;\n@@ -48,1 +48,0 @@\n-    value_ptr++;\n@@ -50,0 +49,1 @@\n+  value_ptr++;\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-                                         int captured_state_mask);\n+                                         int captured_state_mask,\n+                                         bool needs_transition);\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  static bool has_port();\n+\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"prims\/foreignGlobals.hpp\"\n@@ -3477,0 +3478,4 @@\n+JVM_LEAF(jboolean, JVM_IsForeignLinkerSupported(void))\n+  return ForeignGlobals::has_port() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-                                      jboolean needs_return_buffer, jint captured_state_mask))\n+                                      jboolean needs_return_buffer, jint captured_state_mask,\n+                                      jboolean needs_transition))\n@@ -80,1 +81,2 @@\n-                                                    needs_return_buffer, captured_state_mask)->code_begin();\n+                                                    needs_return_buffer, captured_state_mask,\n+                                                    needs_transition)->code_begin();\n@@ -100,1 +102,1 @@\n-  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZI)J\", FN_PTR(NEP_makeDowncallStub)},\n+  {CC \"makeDowncallStub\", CC \"(\" METHOD_TYPE ABI_DESC VM_STORAGE_ARR VM_STORAGE_ARR \"ZIZ)J\", FN_PTR(NEP_makeDowncallStub)},\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  guarantee(thread->thread_state() == _thread_in_native, \"wrong thread state for upcall\");\n","filename":"src\/hotspot\/share\/prims\/upcallLinker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package java.lang.foreign;\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.reflect.CallerSensitive;\n+\n+import java.lang.foreign.Linker.Option;\n+import java.lang.invoke.MethodHandle;\n+import java.nio.ByteOrder;\n+import java.util.Optional;\n+\n+\/**\n+ * A value layout used to model the address of some region of memory. The carrier associated with an address layout is\n+ * {@code MemorySegment.class}. The size and alignment of an address layout are platform dependent\n+ * (e.g. on a 64-bit platform, the size and alignment of an address layout are set to 64 bits).\n+ * <p>\n+ * An address layout may optionally feature a {@linkplain #targetLayout() target layout}. An address layout with\n+ * target layout {@code T} can be used to model the address of a region of memory whose layout is {@code T}.\n+ * For instance, an address layout with target layout {@link ValueLayout#JAVA_INT} can be used to model the address\n+ * of a region of memory that is 4 bytes long. Specifying a target layout can be useful in the following situations:\n+ * <ul>\n+ *     <li>When accessing a memory segment that has been obtained by reading an address from another\n+ *     memory segment, e.g. using {@link MemorySegment#getAtIndex(AddressLayout, long)};<\/li>\n+ *     <li>When creating a downcall method handle, using {@link Linker#downcallHandle(FunctionDescriptor, Option...)};\n+ *     <li>When creating an upcall stub, using {@link Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...)}.\n+ * <\/ul>\n+ *\n+ * @see #ADDRESS\n+ * @see #ADDRESS_UNALIGNED\n+ * @since 19\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n+public sealed interface AddressLayout extends ValueLayout permits ValueLayouts.OfAddressImpl {\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withName(String name);\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withoutName();\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withBitAlignment(long bitAlignment);\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    AddressLayout withOrder(ByteOrder order);\n+\n+    \/**\n+     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n+     * but associated with the specified target layout. The returned address layout allows raw addresses to be accessed\n+     * as {@linkplain MemorySegment memory segments} whose size is set to the size of the specified layout. Moreover,\n+     * if the accessed raw address is not compatible with the alignment constraint in the provided layout,\n+     * {@linkplain IllegalArgumentException} will be thrown.\n+     * @apiNote\n+     * This method can also be used to create an address layout which, when used, creates native memory\n+     * segments with maximal size (e.g. {@linkplain Long#MAX_VALUE}). This can be done by using a target sequence\n+     * layout with unspecified size, as follows:\n+     * {@snippet lang = java:\n+     * AddressLayout addressLayout   = ...\n+     * AddressLayout unboundedLayout = addressLayout.withTargetLayout(\n+     *         MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n+     *}\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the target layout.\n+     * @return an address layout with same characteristics as this layout, but with the provided target layout.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     * @see #targetLayout()\n+     *\/\n+    @CallerSensitive\n+    AddressLayout withTargetLayout(MemoryLayout layout);\n+\n+    \/**\n+     * Returns an address layout with the same carrier, alignment constraint, name and order as this address layout,\n+     * but without any specified target layout.\n+     * <p>\n+     * This can be useful to compare two address layouts that have different target layouts, but are otherwise equal.\n+     *\n+     * @return an address layout with same characteristics as this layout, but with no target layout.\n+     * @see #targetLayout()\n+     *\/\n+    AddressLayout withoutTargetLayout();\n+\n+    \/**\n+     * {@return the target layout associated with this address layout (if any)}.\n+     *\/\n+    Optional<MemoryLayout> targetLayout();\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import jdk.internal.ref.CleanerFactory;\n+\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -32,1 +35,1 @@\n- * An arena controls the lifecycle of memory segments, providing both flexible allocation and timely deallocation.\n+ * An arena controls the lifecycle of native memory segments, providing both flexible allocation and timely deallocation.\n@@ -34,5 +37,13 @@\n- * An arena has a {@linkplain #scope() scope}, called the arena scope. When the arena is {@linkplain #close() closed},\n- * the arena scope is no longer {@linkplain SegmentScope#isAlive() alive}. As a result, all the\n- * segments associated with the arena scope are invalidated, safely and atomically, their backing memory regions are\n- * deallocated (where applicable) and can no longer be accessed after the arena is closed:\n- *\n+ * An arena has a {@linkplain MemorySegment.Scope scope} - the <em>arena scope<\/em>. All the segments allocated\n+ * by the arena are associated with the arena scope. As such, the arena determines the temporal bounds\n+ * of all the memory segments allocated by it.\n+ * <p>\n+ * Moreover, an arena also determines whether access to memory segments allocated by it should be\n+ * {@linkplain MemorySegment#isAccessibleBy(Thread) restricted} to specific threads.\n+ * An arena is a {@link SegmentAllocator} and features several allocation methods that can be used by clients\n+ * to obtain native segments.\n+ * <p>\n+ * The simplest arena is the {@linkplain Arena#global() global arena}. The global arena\n+ * features an <em>unbounded lifetime<\/em>. As such, native segments allocated with the global arena are always\n+ * accessible and their backing regions of memory are never deallocated. Moreover, memory segments allocated with the\n+ * global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n@@ -40,4 +51,3 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n- *     ...\n- * } \/\/ memory released here\n+ * MemorySegment segment = Arena.global().allocate(100, 1);\n+ * ...\n+ * \/\/ segment is never deallocated!\n@@ -45,0 +55,6 @@\n+ * <p>\n+ * Alternatively, clients can obtain an {@linkplain Arena#ofAuto() automatic arena}, that is an arena\n+ * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. As such, the regions\n+ * of memory backing memory segments allocated with the automatic arena are deallocated at some unspecified time\n+ * <em>after<\/em> the automatic arena (and all the segments allocated by it) become\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n@@ -46,2 +62,15 @@\n- * Furthermore, an arena is a {@link SegmentAllocator}. All the segments {@linkplain #allocate(long, long) allocated} by the\n- * arena are associated with the arena scope. This makes arenas extremely useful when interacting with foreign code, as shown below:\n+ * {@snippet lang = java:\n+ * MemorySegment segment = Arena.ofAuto().allocate(100, 1);\n+ * ...\n+ * segment = null; \/\/ the segment region becomes available for deallocation after this point\n+ *}\n+ * Memory segments allocated with an automatic arena can also be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * <p>\n+ * Rather than leaving deallocation in the hands of the Java runtime, clients will often wish to exercise control over\n+ * the timing of deallocation for regions of memory that back memory segments. Two kinds of arenas support this,\n+ * namely {@linkplain #ofConfined() confined} and {@linkplain #ofShared() shared} arenas. They both feature\n+ * bounded lifetimes that are managed manually. For instance, the lifetime of a confined arena starts when the confined\n+ * arena is created, and ends when the confined arena is {@linkplain #close() closed}. As a result, the regions of memory\n+ * backing memory segments allocated with a confined arena are deallocated when the confined arena is closed.\n+ * When this happens, all the segments allocated with the confined arena are invalidated, and subsequent access\n+ * operations on these segments will fail {@link IllegalStateException}:\n@@ -50,4 +79,3 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     MemorySegment nativeArray = arena.allocateArray(ValueLayout.JAVA_INT, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n- *     MemorySegment nativeString = arena.allocateUtf8String(\"Hello!\");\n- *     MemorySegment upcallStub = linker.upcallStub(handle, desc, arena.scope());\n+ * MemorySegment segment = null;\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     segment = arena.allocate(100);\n@@ -55,1 +83,2 @@\n- * } \/\/ memory released here\n+ * } \/\/ segment region deallocated here\n+ * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n@@ -58,0 +87,36 @@\n+ * Memory segments allocated with a {@linkplain #ofConfined() confined arena} can only be accessed (and closed) by the\n+ * thread that created the arena. If access to a memory segment from multiple threads is required, clients can allocate\n+ * segments in a {@linkplain #ofShared() shared arena} instead.\n+ * <p>\n+ * The characteristics of the various arenas are summarized in the following table:\n+ *\n+ * <blockquote><table class=\"plain\">\n+ * <caption style=\"display:none\">Arenas characteristics<\/caption>\n+ * <thead>\n+ * <tr>\n+ *     <th scope=\"col\">Kind<\/th>\n+ *     <th scope=\"col\">Bounded lifetime<\/th>\n+ *     <th scope=\"col\">Explicitly closeable<\/th>\n+ *     <th scope=\"col\">Accessible from multiple threads<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Global<\/th>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Automatic<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Confined<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">No<\/td><\/tr>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">Shared<\/th>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td>\n+ *     <td style=\"text-align:center;\">Yes<\/td><\/tr>\n+ * <\/tbody>\n+ * <\/table><\/blockquote>\n+ *\n@@ -63,1 +128,1 @@\n- * is always created and closed by one thread, and the memory segments associated with the arena's scope are always\n+ * is always created and closed by one thread, and the memory segments allocated by the arena are always\n@@ -73,2 +138,2 @@\n- * {@linkplain #isCloseableBy(Thread) owner thread}, typically the thread which initiated the creation operation.\n- * The segments created by a confined arena can only be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed}\n+ * <em>owner thread<\/em>, typically the thread which initiated the creation operation.\n+ * The segments created by a confined arena can only be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed}\n@@ -79,1 +144,1 @@\n- * can be {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n+ * can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread. This might be useful when\n@@ -81,1 +146,51 @@\n- * Moreover, a shared arena {@linkplain #isCloseableBy(Thread) can be closed} by any thread.\n+ * Moreover, a shared arena can be closed by any thread.\n+ *\n+ * <h2 id = \"custom-arenas\">Custom arenas<\/h2>\n+ *\n+ * Clients can define custom arenas to implement more efficient allocation strategies, or to have better control over\n+ * when (and by whom) an arena can be closed. As an example, the following code defines a <em>slicing arena<\/em> that behaves\n+ * like a confined arena (i.e., single-threaded access), but internally uses a\n+ * {@linkplain SegmentAllocator#slicingAllocator(MemorySegment) slicing allocator} to respond to allocation requests.\n+ * When the slicing arena is closed, the underlying confined arena is also closed; this will invalidate all segments\n+ * allocated with the slicing arena (since the scope of the slicing arena is the same as that of the underlying\n+ * confined arena):\n+ *\n+ * {@snippet lang = java:\n+ * class SlicingArena implements Arena {\n+ *      final Arena arena = Arena.ofConfined();\n+ *      final SegmentAllocator slicingAllocator;\n+ *\n+ *      SlicingArena(long size) {\n+ *          slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+ *      }\n+ *\n+ *      public void allocate(long byteSize, long byteAlignment) {\n+ *          return slicingAllocator.allocate(byteSize, byteAlignment);\n+ *      }\n+ *\n+ *      public MemorySegment.Scope scope() {\n+ *          return arena.scope();\n+ *      }\n+ *\n+ *      public void close() {\n+ *          return arena.close();\n+ *      }\n+ * }\n+ * }\n+ *\n+ * In other words, a slicing arena provides a vastly more efficient and scalable allocation strategy, while still retaining\n+ * the timely deallocation guarantee provided by the underlying confined arena:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena slicingArena = new SlicingArena(1000)) {\n+ *      for (int i = 0 ; i < 10 ; i++) {\n+ *          MemorySegment s = slicingArena.allocateArray(JAVA_INT, 1, 2, 3, 4, 5);\n+ *          ...\n+ *      }\n+ * } \/\/ all memory allocated is released here\n+ * }\n+ *\n+ * @implSpec\n+ * Implementations of this interface are thread-safe.\n+ *\n+ * @see MemorySegment\n@@ -88,0 +203,40 @@\n+    \/**\n+     * Creates a new arena that is managed, automatically, by the garbage collector.\n+     * Segments obtained with the returned arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     * Calling {@link #close()} on the returned arena will result in an {@link UnsupportedOperationException}.\n+     *\n+     * @return a new arena that is managed, automatically, by the garbage collector.\n+     *\/\n+    static Arena ofAuto() {\n+        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner()).asArena();\n+    }\n+\n+    \/**\n+     * Obtains the global arena. Segments obtained with the global arena can be\n+     * {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} by any thread.\n+     * Calling {@link #close()} on the returned arena will result in an {@link UnsupportedOperationException}.\n+     *\n+     * @return the global arena.\n+     *\/\n+    static Arena global() {\n+        class Holder {\n+            static final Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+        }\n+        return Holder.GLOBAL;\n+    }\n+\n+    \/**\n+     * {@return a new confined arena, owned by the current thread}\n+     *\/\n+    static Arena ofConfined() {\n+        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n+    }\n+\n+    \/**\n+     * {@return a new shared arena}\n+     *\/\n+    static Arena ofShared() {\n+        return MemorySessionImpl.createShared().asArena();\n+    }\n+\n@@ -90,1 +245,1 @@\n-     * The returned segment is associated with the arena scope.\n+     * The returned segment is associated with this {@linkplain #scope() arena scope}.\n@@ -96,5 +251,1 @@\n-     * The default implementation of this method is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * MemorySegment.allocateNative(bytesSize, byteAlignment, scope());\n-     *}\n-     * More generally implementations of this method must return a native segment featuring the requested size,\n+     * Implementations of this method must return a native segment featuring the requested size,\n@@ -113,4 +264,3 @@\n-     * @throws IllegalStateException if the arena has already been {@linkplain #close() closed}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n-     * @see MemorySegment#allocateNative(long, long, SegmentScope)\n+     * @throws IllegalStateException if this arena has already been {@linkplain #close() closed}.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n+     * other than the arena owner thread.\n@@ -120,1 +270,1 @@\n-        return MemorySegment.allocateNative(byteSize, byteAlignment, scope());\n+        return ((MemorySessionImpl)scope()).allocate(byteSize, byteAlignment);\n@@ -126,1 +276,1 @@\n-    SegmentScope scope();\n+    Scope scope();\n@@ -129,1 +279,1 @@\n-     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain SegmentScope#isAlive() alive},\n+     * Closes this arena. If this method completes normally, the arena scope is no longer {@linkplain Scope#isAlive() alive},\n@@ -131,1 +281,1 @@\n-     * segments associated with that scope are also released.\n+     * segments obtained from this arena are also released.\n@@ -137,1 +287,5 @@\n-     * @see SegmentScope#isAlive()\n+     * @implSpec If this method completes normally, then {@code this.scope().isAlive() == false}.\n+     * Implementations are allowed to throw {@link UnsupportedOperationException} if an explicit close operation is\n+     * not supported.\n+     *\n+     * @see Scope#isAlive()\n@@ -140,3 +294,5 @@\n-     * @throws IllegalStateException if the arena scope is {@linkplain SegmentScope#whileAlive(Runnable) kept alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code isCloseableBy(T) == false}.\n+     * @throws IllegalStateException if a segment associated with this arena is being accessed concurrently, e.g.\n+     * by a {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handle}.\n+     * @throws WrongThreadException if this arena is confined, and this method is called from a thread {@code T}\n+     * other than the arena owner thread.\n+     * @throws UnsupportedOperationException if this arena does not support explicit closure.\n@@ -147,19 +303,0 @@\n-    \/**\n-     * {@return {@code true} if the provided thread can close this arena}\n-     * @param thread the thread to be tested.\n-     *\/\n-    boolean isCloseableBy(Thread thread);\n-\n-    \/**\n-     * {@return a new confined arena, owned by the current thread}\n-     *\/\n-    static Arena openConfined() {\n-        return MemorySessionImpl.createConfined(Thread.currentThread()).asArena();\n-    }\n-\n-    \/**\n-     * {@return a new shared arena}\n-     *\/\n-    static Arena openShared() {\n-        return MemorySessionImpl.createShared().asArena();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":197,"deletions":60,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.\n+ * {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Linker.Option...) upcall stubs}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/FunctionDescriptor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,6 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    GroupLayout withoutName();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/GroupLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -39,0 +40,1 @@\n+import java.util.function.Consumer;\n@@ -57,1 +59,1 @@\n- * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stubs}.<\/li>\n+ * via the generation of {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stubs}.<\/li>\n@@ -63,0 +65,38 @@\n+ *\n+ * <h2 id=\"native-linker\">Calling native functions<\/h2>\n+ *\n+ * The {@linkplain #nativeLinker() native linker} can be used to link against functions\n+ * defined in C libraries (native functions). Suppose we wish to downcall from Java to the {@code strlen} function\n+ * defined in the standard C library:\n+ * {@snippet lang = c:\n+ * size_t strlen(const char *s);\n+ * }\n+ * A downcall method handle that exposes {@code strlen} is obtained, using the native linker, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle strlen = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"strlen\").get(),\n+ *     FunctionDescriptor.of(JAVA_LONG, ADDRESS)\n+ * );\n+ * }\n+ *\n+ * Note how the native linker also provides access, via its {@linkplain #defaultLookup() default lookup},\n+ * to the native functions defined by the C libraries loaded with the Java runtime. Above, the default lookup\n+ * is used to search the address of the {@code strlen} native function. That address is then passed, along with\n+ * a <em>platform-dependent description<\/em> of the signature of the function expressed as a\n+ * {@link FunctionDescriptor} (more on that below) to the native linker's\n+ * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...)} method.\n+ * The obtained downcall method handle is then invoked as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.openConfined()) {\n+ *     MemorySegment str = arena.allocateUtf8String(\"Hello\");\n+ *     long len          = strlen.invoke(str);  \/\/ 5\n+ * }\n+ * }\n+ * <h3 id=\"describing-c-sigs\">Describing C signatures<\/h3>\n+ *\n+ * When interacting with the native linker, clients must provide a platform-dependent description of the signature\n+ * of the C function they wish to link against. This description, a {@link FunctionDescriptor function descriptor},\n+ * defines the layouts associated with the parameter types and return type (if any) of the C function.\n@@ -64,3 +104,96 @@\n- * The {@link #nativeLinker()} method provides a linker for the ABI associated with the OS and processor where the Java runtime\n- * is currently executing. This linker also provides access, via its {@linkplain #defaultLookup() default lookup},\n- * to the native libraries loaded with the Java runtime.\n+ * Scalar C types such as {@code bool}, {@code int} are modelled as {@linkplain ValueLayout value layouts}\n+ * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n+ * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n+ * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n+ * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * Composite types are modelled as {@linkplain GroupLayout group layouts}. More specifically, a C {@code struct} type\n+ * maps to a {@linkplain StructLayout struct layout}, whereas a C {@code union} type maps to a {@link UnionLayout union\n+ * layout}. When defining a struct or union layout, clients must pay attention to the size and alignment constraint\n+ * of the corresponding composite type definition in C. For instance, padding between two struct fields\n+ * must be modelled explicitly, by adding an adequately sized {@linkplain PaddingLayout padding layout} member\n+ * to the resulting struct layout.\n+ * <p>\n+ * Finally, pointer types such as {@code int**} and {@code int(*)(size_t*, size_t*)} are modelled as\n+ * {@linkplain AddressLayout address layouts}. When the spatial bounds of the pointer type are known statically,\n+ * the address layout can be associated with a {@linkplain AddressLayout#targetLayout() target layout}. For instance,\n+ * a pointer that is known to point to a C {@code int[2]} array can be modelled as an address layout whose\n+ * target layout is a sequence layout whose element count is 2, and whose element type is {@link ValueLayout#JAVA_INT}.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ *\n+ * <blockquote><table class=\"plain\">\n+ * <caption style=\"display:none\">Mapping C types<\/caption>\n+ * <thead>\n+ * <tr>\n+ *     <th scope=\"col\">C type<\/th>\n+ *     <th scope=\"col\">Layout<\/th>\n+ *     <th scope=\"col\">Java type<\/th>\n+ * <\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code bool}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_BOOLEAN}<\/td>\n+ *     <td style=\"text-align:center;\">{@code boolean}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_BYTE}<\/td>\n+ *     <td style=\"text-align:center;\">{@code byte}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_SHORT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code short}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_INT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code int}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code float}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_FLOAT}<\/td>\n+ *     <td style=\"text-align:center;\">{@code float}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code double}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_DOUBLE}<\/td>\n+ *     <td style=\"text-align:center;\">{@code double}<\/td>\n+ <tr><th scope=\"row\" style=\"font-weight:normal\">{@code size_t}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_LONG}<\/td>\n+ *     <td style=\"text-align:center;\">{@code long}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char*}, {@code int**}, {@code struct Point*}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#ADDRESS}<\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int (*foo)[10]}<\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * ValueLayout.ADDRESS.withTargetLayout(\n+ *     MemoryLayout.sequenceLayout(10,\n+ *         ValueLayout.JAVA_INT)\n+ * );\n+ * <\/pre>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\"><code>struct Point { int x; long y; };<\/code><\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * MemoryLayout.structLayout(\n+ *     ValueLayout.JAVA_INT.withName(\"x\"),\n+ *     MemoryLayout.paddingLayout(32),\n+ *     ValueLayout.JAVA_LONG.withName(\"y\")\n+ * );\n+ * <\/pre>\n+ *     <\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\"><code>union Choice { float a; int b; }<\/code><\/th>\n+ *     <td style=\"text-align:left;\">\n+ * <pre>\n+ * MemoryLayout.unionLayout(\n+ *     ValueLayout.JAVA_FLOAT.withName(\"a\"),\n+ *     ValueLayout.JAVA_INT.withName(\"b\")\n+ * );\n+ * <\/pre>\n+ *     <\/td>\n+ *     <td style=\"text-align:center;\">{@link MemorySegment}<\/td>\n+ * <\/tbody>\n+ * <\/table><\/blockquote>\n+ *\n+ * <h3 id=\"function-pointers\">Function pointers<\/h3>\n@@ -68,1 +201,3 @@\n- * <h2 id=\"downcall-method-handles\">Downcall method handles<\/h2>\n+ * Sometimes, it is useful to pass Java code as a function pointer to some native function; this is achieved by using\n+ * an {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}. To demonstrate this,\n+ * let's consider the following function from the C standard library:\n@@ -70,3 +205,19 @@\n- * {@linkplain #downcallHandle(FunctionDescriptor, Option...) Linking a foreign function} is a process which requires a function descriptor,\n- * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n- * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target foreign function.\n+ * {@snippet lang = c:\n+ * void qsort(void *base, size_t nmemb, size_t size,\n+ *            int (*compar)(const void *, const void *));\n+ * }\n+ *\n+ * The {@code qsort} function can be used to sort the contents of an array, using a custom comparator function which is\n+ * passed as a function pointer (the {@code compar} parameter). To be able to call the {@code qsort} function from Java,\n+ * we must first create a downcall method handle for it, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle qsort = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"qsort\").get(),\n+ *         FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)\n+ * );\n+ * }\n+ *\n+ * As before, we use {@link ValueLayout#JAVA_LONG} to map the C type {@code size_t} type, and {@link ValueLayout#ADDRESS}\n+ * for both the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n@@ -74,11 +225,39 @@\n- * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n- * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor.\n- * The downcall method handle type, might then be decorated by additional leading parameters, in the given order if both are present:\n- * <ul>\n- * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor, Option...) without specifying a target address},\n- * the downcall method handle type features a leading parameter of type {@link MemorySegment}, from which the\n- * address of the target foreign function can be derived.<\/li>\n- * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n- * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n- * memory region associated with the struct returned by the downcall method handle.<\/li>\n- * <\/ul>\n+ * To invoke the {@code qsort} downcall handle obtained above, we need a function pointer to be passed as the last\n+ * parameter. That is, we need to create a function pointer out of an existing method handle. First, let's write a\n+ * Java method that can compare two int elements passed as pointers (i.e. as {@linkplain MemorySegment memory segments}):\n+ *\n+ * {@snippet lang = java:\n+ * class Qsort {\n+ *     static int qsortCompare(MemorySegment elem1, MemorySegmet elem2) {\n+ *         return Integer.compare(elem1.get(JAVA_INT, 0), elem2.get(JAVA_INT, 0));\n+ *     }\n+ * }\n+ * }\n+ *\n+ * Now let's create a method handle for the comparator method defined above:\n+ *\n+ * {@snippet lang = java:\n+ * FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,\n+ *                                                       ADDRESS.withTargetLayout(JAVA_INT),\n+ *                                                       ADDRESS.withTargetLayout(JAVA_INT));\n+ * MethodHandle comparHandle = MethodHandles.lookup()\n+ *                                          .findStatic(Qsort.class, \"qsortCompare\",\n+ *                                                      comparDesc.toMethodType());\n+ * }\n+ *\n+ * First, we create a function descriptor for the function pointer type. Since we know that the parameters passed to\n+ * the comparator method will be pointers to elements of a C {@code int[]} array, we can specify {@link ValueLayout#JAVA_INT}\n+ * as the target layout for the address layouts of both parameters. This will allow the comparator method to access\n+ * the contents of the array elements to be compared. We then {@linkplain FunctionDescriptor#toMethodType() turn}\n+ * that function descriptor into a suitable {@linkplain java.lang.invoke.MethodType method type} which we then use to look up\n+ * the comparator method handle. We can now create an upcall stub which points to that method, and pass it, as a function\n+ * pointer, to the {@code qsort} downcall handle, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);\n+ *     MemorySegment array = session.allocateArray(0, 9, 3, 4, 6, 5, 1, 8, 2, 7);\n+ *     qsort.invokeExact(array, 10L, 4L, comparFunc);\n+ *     int[] sorted = array.toArray(JAVA_INT); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+ * }\n+ * }\n@@ -86,1 +265,4 @@\n- * <h2 id=\"upcall-stubs\">Upcall stubs<\/h2>\n+ * This code creates an off-heap array, copies the contents of a Java array into it, and then passes the array to the\n+ * {@code qsort} method handle along with the comparator function we obtained from the native linker. After the invocation, the contents\n+ * of the off-heap array will be sorted according to our comparator function, written in Java. We then extract a\n+ * new Java array from the segment, which contains the sorted elements.\n@@ -88,3 +270,21 @@\n- * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) Creating an upcall stub} requires a method\n- * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n- * specify the signature of the function pointer associated with the upcall stub.\n+ * <h3 id=\"by-ref\">Functions returning pointers<\/h3>\n+ *\n+ * When interacting with native functions, it is common for those functions to allocate a region of memory and return\n+ * a pointer to that region. Let's consider the following function from the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * void *malloc(size_t size);\n+ * }\n+ *\n+ * The {@code malloc} function allocates a region of memory of given size,\n+ * and returns a pointer to that region of memory, which is later deallocated using another function from\n+ * the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * void free(void *ptr);\n+ * }\n+ *\n+ * The {@code free} function takes a pointer to a region of memory and deallocates that region. In this section we\n+ * will show how to interact with these native functions, with the aim of providing a <em>safe<\/em> allocation\n+ * API (the approach outlined below can of course be generalized to allocation functions other than {@code malloc}\n+ * and {@code free}).\n@@ -92,2 +292,63 @@\n- * The type of the provided method handle's type has to match the method type associated with the upcall stub,\n- * which is {@linkplain FunctionDescriptor#toMethodType() derived} from the provided function descriptor.\n+ * First, we need to create the downcall method handles for {@code malloc} and {@code free}, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ *\n+ * MethodHandle malloc = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"malloc\").get(),\n+ *     FunctionDescriptor.of(ADDRESS, JAVA_LONG)\n+ * );\n+ *\n+ * MethodHandle free = linker.downcallHandle(\n+ *     linker.defaultLookup().find(\"free\").get(),\n+ *     FunctionDescriptor.ofVoid(ADDRESS)\n+ * );\n+ * }\n+ *\n+ * When interacting with a native functions returning a pointer (such as {@code malloc}), the Java runtime has no insight\n+ * into the size or the lifetime of the returned pointer. Consider the following code:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment segment = (MemorySegment)malloc.invokeExact(100);\n+ * }\n+ *\n+ * The size of the segment returned by the {@code malloc} downcall method handle is\n+ * <a href=\"MemorySegment.html#wrapping-addresses\">zero<\/a>. Moreover, the scope of the\n+ * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * unsafely, resize the segment to the desired size (100, in this case). It might also be desirable to\n+ * attach the segment to some existing {@linkplain Arena arena}, so that the lifetime of the region of memory\n+ * backing the segment can be managed automatically, as for any other native segment created directly from Java code.\n+ * Both these operations are accomplished using the restricted {@link MemorySegment#reinterpret(long, Arena, Consumer)}\n+ * method, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment allocateMemory(long byteSize, Arena arena) {\n+ *     MemorySegment segment = (MemorySegment)malloc.invokeExact(byteSize);   \/\/ size = 0, scope = always alive\n+ *     return segment.reinterpret(size, arena, s -> free.invokeExact(s));     \/\/ size = byteSize, scope = arena.scope()\n+ * }\n+ * }\n+ *\n+ * The {@code allocateMemory} method defined above accepts two parameters: a size and an arena. The method calls the\n+ * {@code malloc} downcall method handle, and unsafely reinterprets the returned segment, by giving it a new size\n+ * (the size passed to the {@code allocateMemory} method) and a new scope (the scope of the provided arena).\n+ * The method also specifies a <em>cleanup action<\/em> to be executed when the provided arena is closed. Unsurprisingly,\n+ * the cleanup action passes the segment to the {@code free} downcall method handle, to deallocate the underlying\n+ * region of memory. We can use the {@code allocateMemory} method as follows:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     MemorySegment segment = allocateMemory(100, arena);\n+ * } \/\/ 'free' called here\n+ * }\n+ *\n+ * Note how the segment obtained from {@code allocateMemory} acts as any other segment managed by the confined arena. More\n+ * specifically, the obtained segment has the desired size, can only be accessed by a single thread (the thread which created\n+ * the confined arena), and its lifetime is tied to the surrounding <em>try-with-resources<\/em> block.\n+ *\n+ * <h3 id=\"variadic-funcs\">Variadic functions<\/h3>\n+ *\n+ * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n+ * list or with an empty formal parameter list) are not supported directly by the native linker. However, it is still possible\n+ * to link a variadic function by using a <em>specialized<\/em> function descriptor, together with a\n+ * {@linkplain Linker.Option#firstVariadicArg(int) a linker option} which indicates the position of the first variadic argument\n+ * in that specialized descriptor.\n@@ -95,2 +356,37 @@\n- * Upcall stubs are modelled by instances of type {@link MemorySegment}; upcall stubs can be passed by reference to other\n- * downcall method handles and, they are released via their associated {@linkplain SegmentScope scope}.\n+ * A well-known variadic function is the {@code printf} function, defined in the C standard library:\n+ *\n+ * {@snippet lang = c:\n+ * int printf(const char *format, ...);\n+ * }\n+ *\n+ * This function takes a format string, and a number of additional arguments (the number of such arguments is\n+ * dictated by the format string). Consider the following variadic call:\n+ *\n+ * {@snippet lang = c:\n+ * printf(\"%d plus %d equals %d\", 2, 2, 4);\n+ * }\n+ *\n+ * To perform an equivalent call using a downcall method handle we must create a function descriptor which\n+ * describes the specialized signature of the C function we want to call. This descriptor must include layouts for any\n+ * additional variadic argument we intend to provide. In this case, the specialized signature of the C\n+ * function is {@code (char*, int, int, int)} as the format string accepts three integer parameters. Then, we need to use\n+ * a linker option to specify the position of the first variadic layout in the provided function descriptor (starting from 0).\n+ * In this case, since the first parameter is the format string (a non-variadic argument), the first variadic index\n+ * needs to be set to 1, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * Linker linker = Linker.nativeLinker();\n+ * MethodHandle printf = linker.downcallHandle(\n+ *     linker.defaultLookup().lookup(\"printf\").get(),\n+ *         FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),\n+ *         Linker.Option.firstVariadicArg(1) \/\/ first int is variadic\n+ * );\n+ * }\n+ *\n+ * We can then call the specialized downcall handle as usual:\n+ *\n+ * {@snippet lang = java:\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     int res = (int)printf.invokeExact(arena.allocateUtf8String(\"%d plus %d equals %d\"), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+ * }\n+ * }\n@@ -104,15 +400,1 @@\n- * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n- * the linker runtime guarantees the following for any argument {@code A} of type {@link MemorySegment} whose corresponding\n- * layout is {@link ValueLayout#ADDRESS}:\n- * <ul>\n- *     <li>The scope of {@code A} is {@linkplain SegmentScope#isAlive() alive}. Otherwise, the invocation throws\n- *     {@link IllegalStateException};<\/li>\n- *     <li>The invocation occurs in a thread {@code T} such that {@code A.scope().isAccessibleBy(T) == true}.\n- *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n- *     <li>The scope of {@code A} is {@linkplain SegmentScope#whileAlive(Runnable) kept alive} during the invocation.<\/li>\n- *<\/ul>\n- * A downcall method handle created from a function descriptor whose return layout is an\n- * {@linkplain ValueLayout.OfAddress address layout} returns a native segment associated with\n- * the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned segment is {@code 0}.\n- * However, if the return layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n- * then the size of the returned segment is {@code Long.MAX_VALUE}.\n+ * the result of such interaction is unspecified and can lead to JVM crashes.\n@@ -127,6 +409,0 @@\n- * <p>\n- * An upcall stub argument whose corresponding layout is an {@linkplain ValueLayout.OfAddress address layout}\n- * is a native segment associated with the {@linkplain SegmentScope#global() global scope}.\n- * Under normal conditions, the size of this segment argument is {@code 0}. However, if the layout associated with\n- * the upcall stub argument is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout,\n- * then the size of the segment argument is {@code Long.MAX_VALUE}.\n@@ -146,25 +422,0 @@\n-     * When interacting with the returned linker, clients must describe the signature of a foreign function using a\n-     * {@link FunctionDescriptor function descriptor} whose argument and return layouts are specified as follows:\n-     * <ul>\n-     *     <li>Scalar types are modelled by a {@linkplain ValueLayout value layout} instance of a suitable carrier. Example\n-     *     of scalar types in C are {@code int}, {@code long}, {@code size_t}, etc. The mapping between a scalar type\n-     *     and its corresponding layout is dependent on the ABI of the returned linker;\n-     *     <li>Composite types are modelled by a {@linkplain GroupLayout group layout}. Depending on the ABI of the\n-     *     returned linker, additional {@linkplain MemoryLayout#paddingLayout(long) padding} member layouts might be required to conform\n-     *     to the size and alignment constraint of a composite type definition in C (e.g. using {@code struct} or {@code union}); and<\/li>\n-     *     <li>Pointer types are modelled by a {@linkplain ValueLayout value layout} instance with carrier {@link MemorySegment}.\n-     *     Examples of pointer types in C are {@code int**} and {@code int(*)(size_t*, size_t*)};<\/li>\n-     * <\/ul>\n-     * <p>\n-     * Any layout not listed above is <em>unsupported<\/em>; function descriptors containing unsupported layouts\n-     * will cause an {@link IllegalArgumentException} to be thrown, when used to create a\n-     * {@link #downcallHandle(MemorySegment, FunctionDescriptor, Option...) downcall method handle} or an\n-     * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, SegmentScope) upcall stub}.\n-     * <p>\n-     * Variadic functions (e.g. a C function declared with a trailing ellipses {@code ...} at the end of the formal parameter\n-     * list or with an empty formal parameter list) are not supported directly. However, it is possible to link a\n-     * variadic function by using {@linkplain Linker.Option#firstVariadicArg(int) a linker option} to indicate\n-     * the start of the list of variadic arguments, together with a specialized function descriptor describing a\n-     * given variable arity callsite. Alternatively, where the foreign library allows it, clients might be able to\n-     * interact with variadic functions by passing a trailing parameter of type {@link VaList} (e.g. as in {@code vsprintf}).\n-     * <p>\n@@ -181,1 +432,1 @@\n-     * @return a linker for the ABI associated with the OS and processor where the Java runtime is currently executing.\n+     * @return a linker for the ABI associated with the underlying native platform.\n@@ -192,5 +443,1 @@\n-     * Creates a method handle which can be used to call a foreign function with the given signature and address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n-     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker to allocate\n-     * structs returned by-value.\n+     * Creates a method handle which is used to call a foreign function with the given signature and address.\n@@ -217,4 +464,1 @@\n-     * Creates a method handle which can be used to call a foreign function with the given signature.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n-     * entry point, of type {@link MemorySegment}, which is used to specify the address of the target function\n-     * to be called.\n+     * Creates a method handle which is used to call a foreign function with the given signature.\n@@ -222,3 +466,6 @@\n-     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n-     * additional prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n-     * which will be used by the linker to allocate structs returned by-value.\n+     * The Java {@linkplain java.lang.invoke.MethodType method type} associated with the returned method handle is\n+     * {@linkplain FunctionDescriptor#toMethodType() derived} from the argument and return layouts in the function descriptor,\n+     * but features an additional leading parameter of type {@link MemorySegment}, from which the address of the target\n+     * foreign function is derived. Moreover, if the function descriptor's return layout is a group layout, the resulting\n+     * downcall method handle accepts an additional leading parameter of type {@link SegmentAllocator}, which is used by\n+     * the linker runtime to allocate the memory region associated with the struct returned by the downcall method handle.\n@@ -226,2 +473,20 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment} parameter passed to it is\n-     * associated with the {@link MemorySegment#NULL} address, or a {@link NullPointerException} if that parameter is {@code null}.\n+     * Upon invoking a downcall method handle, the linker runtime will guarantee the following for any argument\n+     * {@code A} of type {@link MemorySegment} whose corresponding layout is an {@linkplain AddressLayout address layout}:\n+     * <ul>\n+     *     <li>{@code A.scope().isAlive() == true}. Otherwise, the invocation throws {@link IllegalStateException};<\/li>\n+     *     <li>The invocation occurs in a thread {@code T} such that {@code A.isAccessibleBy(T) == true}.\n+     *     Otherwise, the invocation throws {@link WrongThreadException}; and<\/li>\n+     *     <li>{@code A} is kept alive during the invocation. For instance, if {@code A} has been obtained using a\n+     *     {@linkplain Arena#ofShared()} shared arena}, any attempt to {@linkplain Arena#close() close}\n+     *     the shared arena while the downcall method handle is executing will result in an {@link IllegalStateException}.<\/li>\n+     *<\/ul>\n+     * <p>\n+     * Moreover, if the provided function descriptor's return layout is an {@linkplain AddressLayout address layout},\n+     * invoking the returned method handle will return a native segment associated with\n+     * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n+     * However, if the function descriptor's return layout has a {@linkplain AddressLayout#targetLayout()} {@code T},\n+     * then the size of the returned segment is set to {@code T.byteSize()}.\n+     * <p>\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the {@link MemorySegment}\n+     * representing the target address of the foreign function is the {@link MemorySegment#NULL} address.\n+     * The returned method handle will additionally throw {@link NullPointerException} if any argument passed to it is {@code null}.\n@@ -240,1 +505,1 @@\n-     * scope. Calling such a function pointer from foreign code will result in the execution of the provided\n+     * arena. Calling such a function pointer from foreign code will result in the execution of the provided\n@@ -244,2 +509,9 @@\n-     * the provided scope. As such, the corresponding upcall stub will be deallocated\n-     * when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n+     * the provided arena. As such, the lifetime of the returned upcall stub segment is controlled by the\n+     * provided arena. For instance, if the provided arena is a confined arena, the returned\n+     * upcall stub segment will be deallocated when the provided confined arena is {@linkplain Arena#close() closed}.\n+     * <p>\n+     * An upcall stub argument whose corresponding layout is an {@linkplain AddressLayout address layout}\n+     * is a native segment associated with a fresh scope that is always alive.\n+     * Under normal conditions, the size of this segment argument is {@code 0}.\n+     * However, if the address layout has a {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the\n+     * segment argument is set to {@code T.byteSize()}.\n@@ -255,1 +527,2 @@\n-     * @param scope the scope associated with the returned upcall stub segment.\n+     * @param arena the arena associated with the returned upcall stub segment.\n+     * @param options  any linker options.\n@@ -260,3 +533,3 @@\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -264,1 +537,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options);\n@@ -288,2 +561,1 @@\n-            permits LinkerOptions.LinkerOptionImpl,\n-                    Option.CaptureCallState {\n+            permits LinkerOptions.LinkerOptionImpl {\n@@ -305,19 +577,0 @@\n-         * A downcall method handle linked with this option will feature an additional {@link MemorySegment}\n-         * parameter directly following the target address, and optional {@link SegmentAllocator} parameters.\n-         * This memory segment must be a native segment into which the captured state is written.\n-         *\n-         * @param capturedState the names of the values to save.\n-         * @see CaptureCallState#supported()\n-         *\/\n-        static CaptureCallState captureCallState(String... capturedState) {\n-            Set<CapturableState> set = Stream.of(capturedState)\n-                    .map(CapturableState::forName)\n-                    .collect(Collectors.toSet());\n-            return new LinkerOptions.CaptureCallStateImpl(set);\n-        }\n-\n-        \/**\n-         * A linker option for saving portions of the execution state immediately\n-         * after calling a foreign function associated with a downcall method handle,\n-         * before it can be overwritten by the runtime, or read through conventional means.\n-         * <p>\n@@ -326,1 +579,1 @@\n-         * For this purpose, a downcall method handle linked with the {@link #captureCallState(String[])}\n+         * For this purpose, a downcall method handle linked with this\n@@ -329,1 +582,2 @@\n-         * This parameter represents the native segment into which the captured state is written.\n+         * This parameter, called the 'capture state segment', represents the native segment into which\n+         * the captured state is written.\n@@ -331,2 +585,2 @@\n-         * The native segment should have the layout {@linkplain CaptureCallState#layout associated}\n-         * with the particular {@code CaptureCallState} instance used to link the downcall handle.\n+         * The capture state segment should have the layout returned by {@linkplain #captureStateLayout}.\n+         * This layout is a struct layout which has a named field for each captured value.\n@@ -334,2 +588,2 @@\n-         * Captured state can be retrieved from this native segment by constructing var handles\n-         * from the {@linkplain #layout layout} associated with the {@code CaptureCallState} instance.\n+         * Captured state can be retrieved from the capture state segment by constructing var handles\n+         * from the {@linkplain #captureStateLayout capture state layout}.\n@@ -340,1 +594,1 @@\n-         * CaptureCallState ccs = Linker.Option.captureCallState(\"errno\");\n+         * Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n@@ -343,3 +597,4 @@\n-         * VarHandle errnoHandle = ccs.layout().varHandle(PathElement.groupElement(\"errno\"));\n-         * try (Arena arena = Arena.openConfined()) {\n-         *     MemorySegment capturedState = arena.allocate(ccs.layout());\n+         * StructLayout capturedStateLayout = Linker.Option.capturedStateLayout();\n+         * VarHandle errnoHandle = capturedStateLayout.varHandle(PathElement.groupElement(\"errno\"));\n+         * try (Arena arena = Arena.ofConfined()) {\n+         *     MemorySegment capturedState = arena.allocate(capturedStateLayout);\n@@ -351,0 +606,38 @@\n+         *\n+         * @param capturedState the names of the values to save.\n+         * @throws IllegalArgumentException if at least one of the provided {@code capturedState} names\n+         *                                  is unsupported on the current platform.\n+         * @see #captureStateLayout()\n+         *\/\n+        static Option captureCallState(String... capturedState) {\n+            Set<CapturableState> set = Stream.of(Objects.requireNonNull(capturedState))\n+                    .map(Objects::requireNonNull)\n+                    .map(CapturableState::forName)\n+                    .collect(Collectors.toSet());\n+            return new LinkerOptions.CaptureCallState(set);\n+        }\n+\n+         \/**\n+         * {@return A struct layout that represents the layout of the capture state segment that is passed\n+         *          to a downcall handle linked with {@link #captureCallState(String...)}}.\n+         * <p>\n+         * The capture state layout is <em>platform dependent<\/em> but is guaranteed to be\n+         * a {@linkplain StructLayout struct layout} containing only {@linkplain ValueLayout value layouts}\n+         * and possibly {@linkplain PaddingLayout padding layouts}.\n+         * As an example, on Windows, the returned layout might contain three value layouts named:\n+         * <ul>\n+         *     <li>GetLastError<\/li>\n+         *     <li>WSAGetLastError<\/li>\n+         *     <li>errno<\/li>\n+         * <\/ul>\n+         * The following snipet shows how to obtain the names of the supported captured value layouts:\n+         * {@snippet lang = java:\n+         *    String capturedNames = Linker.Option.captureStateLayout().memberLayouts().stream()\n+         *        .map(MemoryLayout::name)\n+         *        .filter(Optional::isPresent)\n+         *        .map(Optional::get)\n+         *        .map(Objects::toString)\n+         *        .collect(Collectors.joining(\", \"));\n+         * }\n+         *\n+         * @see #captureCallState(String...)\n@@ -352,8 +645,3 @@\n-        @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-        sealed interface CaptureCallState extends Option\n-                                          permits LinkerOptions.CaptureCallStateImpl {\n-            \/**\n-             * {@return A struct layout that represents the layout of the native segment passed\n-             *          to a downcall handle linked with this {@code CapturedCallState} instance}\n-             *\/\n-            StructLayout layout();\n+        static StructLayout captureStateLayout() {\n+            return CapturableState.LAYOUT;\n+        }\n@@ -361,8 +649,14 @@\n-            \/**\n-             * {@return the names of the state that can be capture by this implementation}\n-             *\/\n-            static Set<String> supported() {\n-                return Arrays.stream(CapturableState.values())\n-                             .map(CapturableState::stateName)\n-                             .collect(Collectors.toSet());\n-            }\n+        \/**\n+         * {@return A linker option used to mark a foreign function as <em>trivial<\/em>}\n+         * <p>\n+         * A trivial function is a function that has an extremely short running time\n+         * in all cases (similar to calling an empty function), and does not call back into Java (e.g. using an upcall stub).\n+         * <p>\n+         * Using this linker option is a hint which some implementations may use to apply\n+         * optimizations that are only valid for trivial functions.\n+         * <p>\n+         * Using this linker option when linking non trivial functions is likely to have adverse effects,\n+         * such as loss of performance, or JVM crashes.\n+         *\/\n+        static Option isTrivial() {\n+            return LinkerOptions.IsTrivial.INSTANCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":439,"deletions":145,"binary":false,"changes":584,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.nio.ByteOrder;\n@@ -39,0 +38,1 @@\n+\n@@ -47,1 +47,0 @@\n-import jdk.internal.foreign.layout.ValueLayouts;\n@@ -203,0 +202,11 @@\n+    \/**\n+     * Returns a memory layout of the same type with the same size and alignment constraint as this layout,\n+     * but without a name.\n+     * <p>\n+     * This can be useful to compare two layouts that have different names, but are otherwise equal.\n+     *\n+     * @return a memory layout without a name.\n+     * @see MemoryLayout#name()\n+     *\/\n+    MemoryLayout withoutName();\n+\n@@ -238,4 +248,1 @@\n-    default long byteAlignment() {\n-        return Utils.bitsToBytesOrThrow(bitAlignment(),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte alignment; bit alignment is not a multiple of 8\"));\n-    }\n+    long byteAlignment();\n@@ -262,0 +269,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -267,1 +276,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -296,0 +305,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -299,1 +310,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -311,0 +322,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -316,1 +329,1 @@\n-        return Utils.bitsToBytesOrThrow(bitOffset(elements), Utils.BITS_TO_BYTES_THROW_OFFSET);\n+        return Utils.bitsToBytes(bitOffset(elements));\n@@ -349,0 +362,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -352,1 +367,1 @@\n-        mh = MethodHandles.filterReturnValue(mh, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET);\n+        mh = MethodHandles.filterReturnValue(mh, Utils.BITS_TO_BYTES);\n@@ -382,0 +397,22 @@\n+     * <p>\n+     * Multiple paths can be chained, by using {@linkplain PathElement#dereferenceElement() dereference path elements}.\n+     * A dereference path element allows to obtain a native memory segment whose base address is the address obtained\n+     * by following the layout path elements immediately preceding the dereference path element. In other words,\n+     * if a layout path contains one or more dereference path elements, the final address accessed by the returned\n+     * var handle can be computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+     * address_1 = base(segment) + offset_1\n+     * address_2 = base(segment_1) + offset_2\n+     * ...\n+     * address_k = base(segment_k-1) + offset_k\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code k} is the number of dereference path elements in a layout path, {@code segment} is the input segment,\n+     * {@code segment_1}, ...  {@code segment_k-1} are the segments obtained by dereferencing the address associated with\n+     * a given dereference path element (e.g. {@code segment_1} is a native segment whose base address is {@code address_1}),\n+     * and {@code offset_1}, {@code offset_2}, ... {@code offset_k} are the offsets computed by evaluating\n+     * the path elements after a given dereference operation (these offsets are obtained using the computation described\n+     * above). In these more complex access operations, all memory accesses immediately preceding a dereference operation\n+     * (e.g. those at addresses {@code address_1}, {@code address_2}, ...,  {@code address_k-1} are performed using the\n+     * {@link VarHandle.AccessMode#GET} access mode.\n@@ -391,0 +428,2 @@\n+     * @throws IllegalArgumentException if the layout path in {@code elements} contains a {@linkplain PathElement#dereferenceElement()\n+     * dereference path element} for an address layout that has no {@linkplain AddressLayout#targetLayout() target layout}.\n@@ -435,0 +474,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -449,0 +490,2 @@\n+     * @throws IllegalArgumentException if the layout path contains one or more dereference path elements\n+     * (see {@link PathElement#dereferenceElement()}).\n@@ -452,1 +495,1 @@\n-                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE), elements);\n+                EnumSet.of(PathKind.SEQUENCE_ELEMENT_INDEX, PathKind.SEQUENCE_RANGE, PathKind.DEREF_ELEMENT), elements);\n@@ -492,0 +535,1 @@\n+         * In such cases, using {@link #groupElement(long)} might be preferable.\n@@ -502,0 +546,17 @@\n+        \/**\n+         * Returns a path element which selects a member layout with the given index in a group layout.\n+         * The path element returned by this method does not alter the number of free dimensions of any path\n+         * that is combined with such element.\n+         *\n+         * @param index the index of the group element to be selected.\n+         * @return a path element which selects the group element with the given index.\n+         * @throws IllegalArgumentException if {@code index < 0}.\n+         *\/\n+        static PathElement groupElement(long index) {\n+            if (index < 0) {\n+                throw new IllegalArgumentException(\"Index < 0\");\n+            }\n+            return new LayoutPath.PathElementImpl(PathKind.GROUP_ELEMENT,\n+                    path -> path.groupElement(index));\n+        }\n+\n@@ -581,0 +642,15 @@\n+\n+        \/**\n+         * Returns a path element which dereferences an address layout as its\n+         * {@linkplain AddressLayout#targetLayout() target layout} (where set).\n+         * The path element returned by this method does not alter the number of free dimensions of any path\n+         * that is combined with such element. Using this path layout to dereference an address layout\n+         * that has no target layout results in an {@link IllegalArgumentException} (e.g. when\n+         * a var handle is {@linkplain #varHandle(PathElement...) obtained}).\n+         *\n+         * @return a path element which dereferences an address layout.\n+         *\/\n+        static PathElement dereferenceElement() {\n+            return new LayoutPath.PathElementImpl(PathKind.DEREF_ELEMENT,\n+                    LayoutPath::derefElement);\n+        }\n@@ -614,1 +690,1 @@\n-     * Creates a padding layout with the given size.\n+     * Creates a padding layout with the given bitSize and a bit-alignment of eight.\n@@ -616,1 +692,1 @@\n-     * @param size the padding size in bits.\n+     * @param bitSize the padding size in bits.\n@@ -618,1 +694,1 @@\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @throws IllegalArgumentException if {@code bitSize <= 0} or {@code bitSize % 8 != 0}\n@@ -620,48 +696,2 @@\n-    static PaddingLayout paddingLayout(long size) {\n-        MemoryLayoutUtil.checkSize(size);\n-        return PaddingLayoutImpl.of(size);\n-    }\n-\n-    \/**\n-     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n-     * by the carrier provided:\n-     * <ul>\n-     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n-     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n-     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n-     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n-     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n-     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n-     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n-     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n-     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n-     * <\/ul>\n-     * @param carrier the value layout carrier.\n-     * @param order the value layout's byte order.\n-     * @return a value layout with the given Java carrier and byte-order.\n-     * @throws IllegalArgumentException if the carrier type is not supported.\n-     *\/\n-    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(order);\n-        if (carrier == boolean.class) {\n-            return ValueLayouts.OfBooleanImpl.of(order);\n-        } else if (carrier == char.class) {\n-            return ValueLayouts.OfCharImpl.of(order);\n-        } else if (carrier == byte.class) {\n-            return ValueLayouts.OfByteImpl.of(order);\n-        } else if (carrier == short.class) {\n-            return ValueLayouts.OfShortImpl.of(order);\n-        } else if (carrier == int.class) {\n-            return ValueLayouts.OfIntImpl.of(order);\n-        } else if (carrier == float.class) {\n-            return ValueLayouts.OfFloatImpl.of(order);\n-        } else if (carrier == long.class) {\n-            return ValueLayouts.OfLongImpl.of(order);\n-        } else if (carrier == double.class) {\n-            return ValueLayouts.OfDoubleImpl.of(order);\n-        } else if (carrier == MemorySegment.class) {\n-            return ValueLayouts.OfAddressImpl.of(order);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n-        }\n+    static PaddingLayout paddingLayout(long bitSize) {\n+        return PaddingLayoutImpl.of(MemoryLayoutUtil.requireBitSizeValid(bitSize, false));\n@@ -679,1 +709,1 @@\n-        MemoryLayoutUtil.checkSize(elementCount, true);\n+        MemoryLayoutUtil.requireNonNegative(elementCount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":94,"deletions":64,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.lang.foreign.Linker.Option;\n+import java.lang.invoke.MethodHandle;\n@@ -42,0 +44,1 @@\n+import java.util.function.Consumer;\n@@ -45,0 +48,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -50,1 +54,0 @@\n-import jdk.internal.misc.ScopedMemoryAccess;\n@@ -52,1 +55,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -66,1 +68,1 @@\n- * Native segments can be obtained by calling one of the {@link MemorySegment#allocateNative(long, long, SegmentScope)}\n+ * Native segments can be obtained by calling one of the {@link Arena#allocate(long, long)}\n@@ -69,1 +71,1 @@\n- * {@link FileChannel#map(MapMode, long, long, SegmentScope) mapping} a file into a new off-heap region\n+ * {@link FileChannel#map(MapMode, long, long, Arena) mapping} a file into a new off-heap region\n@@ -94,2 +96,2 @@\n- * (as in {@link MemorySegment#allocateNative(long, SegmentScope)}) or derived from a {@link MemoryLayout}\n- * (as in {@link MemorySegment#allocateNative(MemoryLayout, SegmentScope)}). The size of a memory segment is typically\n+ * (as in {@link Arena#allocate(long, long)}) or derived from a {@link MemoryLayout}\n+ * (as in {@link Arena#allocate(MemoryLayout)}). The size of a memory segment is typically\n@@ -102,1 +104,1 @@\n- * Every memory segment is associated with a {@linkplain SegmentScope scope}. This ensures that access operations\n+ * Every memory segment is associated with a {@linkplain Scope scope}. This ensures that access operations\n@@ -104,1 +106,1 @@\n- * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain SegmentScope#isAlive() alive}).\n+ * (e.g., after the scope associated with the accessed memory segment is no longer {@linkplain Scope#isAlive() alive}).\n@@ -107,4 +109,3 @@\n- * Finally, access operations on a memory segment are subject to the thread-confinement checks enforced by the associated\n- * scope; that is, if the segment is associated with the {@linkplain SegmentScope#global() global scope} or an {@linkplain SegmentScope#auto() automatic scope},\n- * it can be accessed by multiple threads. If the segment is associated with an arena scope, then it can only be\n- * accessed compatibly with the <a href=\"Arena.html#thread-confinement\">arena confinement characteristics<\/a>.\n+ * Finally, access operations on a memory segment can be subject to additional thread-confinement checks.\n+ * Heap segments can be accessed from any thread. Conversely, native segments can only be accessed compatibly with the\n+ * <a href=\"ScopedArena.html#thread-confinement\">confinement characteristics<\/a> of the arena used to obtain them.\n@@ -164,1 +165,1 @@\n- * {@snippet lang=java :\n+ * {@snippet lang = java:\n@@ -171,1 +172,1 @@\n- * }\n+ *}\n@@ -175,2 +176,2 @@\n- * {@code slice} segment will result in an exception. The {@linkplain SegmentScope temporal bounds} of the original segment\n- * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain SegmentScope#isAlive() alive},\n+ * {@code slice} segment will result in an exception. The {@linkplain Arena temporal bounds} of the original segment\n+ * is inherited by its slices; that is, when the scope associated with {@code segment} is no longer {@linkplain Scope#isAlive() alive},\n@@ -181,1 +182,1 @@\n- * (to do this, the segment has to be associated with a scope that allows {@linkplain SegmentScope#isAccessibleBy(Thread) access}\n+ * (to do this, the segment has to be {@linkplain MemorySegment#isAccessibleBy(Thread) accessible}\n@@ -185,1 +186,1 @@\n- * try (Arena arena = Arena.openShared()) {\n+ * try (Arena arena = Arena.ofShared()) {\n@@ -244,2 +245,2 @@\n- * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link #allocateNative(long, long, SegmentScope)}\n- * or {@link #allocateNative(MemoryLayout, SegmentScope)}. These factories ensure that the off-heap region of memory backing\n+ * the segment should be allocated by specifying a 8-byte alignment constraint, either via {@link Arena#allocate(long, long)}\n+ * or {@link Arena#allocate(MemoryLayout)}. These factories ensure that the off-heap region of memory backing\n@@ -346,1 +347,3 @@\n- * to the code calling the foreign function and hoping to use its result.\n+ * to the code calling the foreign function and hoping to use its result. In addition to having no insight\n+ * into the size of the region of memory backing a pointer returned from a foreign function, it also has no insight\n+ * into the lifetime intended for said region of memory by the foreign function that allocated it.\n@@ -348,3 +351,18 @@\n- * The {@link Linker} represents a pointer returned from a foreign function with a <em>zero-length memory segment<\/em>.\n- * The address of the segment is the address stored in the pointer. The size of the segment is zero. Similarly, when a\n- * client reads an <em>address<\/em> from a memory segment, a zero-length memory segment is returned.\n+ * The {@code MemorySegment} API uses <em>zero-length memory segments<\/em> to represent:\n+ * <ul>\n+ *     <li>pointers returned from a foreign function;<\/li>\n+ *     <li>pointers passed by a foreign function to an\n+ *     {@linkplain Linker#upcallStub(MethodHandle, FunctionDescriptor, Arena, Option...) upcall stub}; and<\/li>\n+ *     <li>pointers {@linkplain MemorySegment#get(AddressLayout, long) read} from a memory segment.<\/li>\n+ * <\/ul>\n+ * The address of the zero-length segment is the address stored in the pointer. The spatial and temporal bounds of the\n+ * zero-length segment are as follows:\n+ * <ul>\n+ *     <li>The size of the segment is zero. any attempt to access these segments will fail with {@link IndexOutOfBoundsException}.\n+ *     This is a crucial safety feature: as these segments are associated with a region\n+ *     of memory whose size is not known, any access operations involving these segments cannot be validated.\n+ *     In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent\n+ *     (see below);<\/li>\n+ *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     memory segments cannot be accessed directly, they can be passed, opaquely, to other pointer-accepting foreign functions.<\/li>\n+ * <\/ul>\n@@ -352,4 +370,1 @@\n- * Since a zero-length segment features trivial spatial bounds, any attempt to access these segments will fail with\n- * {@link IndexOutOfBoundsException}. This is a crucial safety feature: as these segments are associated with a region\n- * of memory whose size is not known, any access operations involving these segments cannot be validated.\n- * In effect, a zero-length memory segment <em>wraps<\/em> an address, and it cannot be used without explicit intent.\n+ * To work with native zero-length memory segments, clients have several options, all of which are <em>unsafe<\/em>.\n@@ -357,5 +372,9 @@\n- * Zero-length memory segments obtained when interacting with foreign functions are associated with the\n- * {@link SegmentScope#global() global scope}. This is because the Java runtime, in addition to having no insight\n- * into the size of the region of memory backing a pointer returned from a foreign function, also has no insight\n- * into the lifetime intended for said region of memory by the foreign function that allocated it. The global scope\n- * ensures that the obtained segment can be passed, opaquely, to other pointer-accepting foreign functions.\n+ * First, clients can unsafely resize a zero-length memory segment by {@linkplain #reinterpret(long) obtaining} a\n+ * memory segment with the same base address as the zero-length memory segment, but with the desired size,\n+ * so that the resulting segment can then be accessed directly, as follows:\n+ *\n+ * {@snippet lang = java:\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ size = 0\n+ *                                    .reinterpret(4)               \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                    \/\/ ok\n+ *}\n@@ -363,3 +382,3 @@\n- * To access native zero-length memory segments, clients have two options, both of which are <em>unsafe<\/em>. Clients\n- * can {@linkplain java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope) obtain}\n- * a <em>new<\/em> native segment, with new spatial and temporal bounds, as follows:\n+ * In some cases, a client might additionally want to assign new temporal bounds to a zero-length memory segment.\n+ * This can be done using the {@link #reinterpret(long, Arena, Consumer)} method, which returns a\n+ * new native segment with the desired size and the same temporal bounds as those in the provided arena:\n@@ -368,4 +387,7 @@\n- * SegmentScope scope = ... \/\/ obtains a scope\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS, 0); \/\/ wrap address into segment (size = 0)\n- * MemorySegment segment = MemorySegment.ofAddress(foreign.address(), 4, scope); \/\/ create new segment (size = 4)\n- * int x = segment.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = null;\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *       foreign = someSegment.get(ValueLayout.ADDRESS, 0)           \/\/ size = 0, scope = always alive\n+ *                            .reinterpret(4, arena, null);          \/\/ size = 4, scope = arena.scope()\n+ *       int x = foreign.get(ValueLayout.JAVA_INT, 0);               \/\/ ok\n+ * }\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ throws IllegalStateException\n@@ -374,4 +396,5 @@\n- * Alternatively, clients can obtain an {@linkplain java.lang.foreign.ValueLayout.OfAddress#asUnbounded() unbounded}\n- * address value layout. When an access operation, or a function descriptor that is passed to a downcall method handle,\n- * uses an unbounded address value layouts, the runtime will wrap any corresponding raw addresses with native segments\n- * with <em>maximal<\/em> size (i.e. {@linkplain java.lang.Long#MAX_VALUE}). As such, these segments can be accessed directly, as follows:\n+ * Alternatively, if the size of the foreign segment is known statically, clients can associate a\n+ * {@linkplain AddressLayout#withTargetLayout(MemoryLayout) target layout} with the address layout used to obtain the\n+ * segment. When an access operation, or a function descriptor that is passed to a downcall method handle,\n+ * uses an address value layout with target layout {@code T}, the runtime will wrap any corresponding raw addresses\n+ * with native segments with size set to {@code T.byteSize()}:\n@@ -380,2 +403,2 @@\n- * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.asUnbounded(), 0); \/\/ wrap address into segment (size = Long.MAX_VALUE)\n- * int x = foreign.get(ValueLayout.JAVA_INT, 0); \/\/ok\n+ * MemorySegment foreign = someSegment.get(ValueLayout.ADDRESS.withTargetLayout(JAVA_INT), 0); \/\/ size = 4\n+ * int x = foreign.get(ValueLayout.JAVA_INT, 0);                                               \/\/ ok\n@@ -383,4 +406,0 @@\n- *\n- * Both {@link #ofAddress(long, long, SegmentScope)} and {@link ValueLayout.OfAddress#asUnbounded()} are\n- * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n- * for instance, sizing a segment incorrectly could result in a VM crash when attempting to access the memory segment.\n@@ -390,1 +409,2 @@\n- * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API).\n+ * segment unsafely, to match the size of the struct (so that out-of-bounds access will be detected by the API). If the\n+ * size is known statically, using an address layout with the correct target layout might be preferable.\n@@ -393,0 +413,7 @@\n+ * <p>\n+ * All the methods which can be used to manipulate zero-length memory segments\n+ * ({@link #reinterpret(long)}, {@link #reinterpret(Arena, Consumer)}, {@link #reinterpret(long, Arena, Consumer)} and\n+ * {@link AddressLayout#withTargetLayout(MemoryLayout)}) are\n+ * <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> methods, and should be used with caution:\n+ * assigning a segment incorrect spatial and\/or temporal bounds could result in a VM crash when attempting to access\n+ * the memory segment.\n@@ -408,1 +435,5 @@\n-     * {@return the Java array associated with this memory segment, if any}\n+     * Returns the Java object stored in the on-heap memory region backing this memory segment, if any. For instance, if this\n+     * memory segment is a heap segment created with the {@link #ofArray(byte[])} factory method, this method will return the\n+     * {@code byte[]} object which was used to obtain the segment. This method returns an empty {@code Optional} value\n+     * if either this segment is a {@linkplain #isNative() native} segment, or if this segment is {@linkplain #isReadOnly() read-only}.\n+     * @return the Java object associated with this memory segment, if any.\n@@ -410,1 +441,1 @@\n-    Optional<Object> array();\n+    Optional<Object> heapBase();\n@@ -421,1 +452,1 @@\n-     * are associated with the same scope as that associated with this segment.\n+     * have the same lifetime as that of this segment.\n@@ -454,1 +485,7 @@\n-    SegmentScope scope();\n+    Scope scope();\n+\n+    \/**\n+     * {@return {@code true} if this segment can be accessed from the provided thread}\n+     * @param thread the thread to be tested.\n+     *\/\n+    boolean isAccessibleBy(Thread thread);\n@@ -464,0 +501,5 @@\n+     * <p>\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * asSlice(offset, layout.byteSize(), 1);\n+     * }\n@@ -465,1 +507,1 @@\n-     * @see #asSlice(long)\n+     * @see #asSlice(long, long, long)\n@@ -474,0 +516,38 @@\n+    \/**\n+     * Returns a slice of this memory segment, at the given offset, with the provided alignment constraint.\n+     * The returned segment's address is the address of this segment plus the given offset; its size is specified by the given argument.\n+     *\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n+     * @param newSize The new segment size, specified in bytes.\n+     * @param byteAlignment The alignment constraint (in bytes) of the returned slice.\n+     * @return a slice of this memory segment.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n+     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset} under\n+     * the provided alignment constraint.\n+     *\/\n+    MemorySegment asSlice(long offset, long newSize, long byteAlignment);\n+\n+    \/**\n+     * Returns a slice of this memory segment with the given layout, at the given offset. The returned segment's address is the address\n+     * of this segment plus the given offset; its size is the same as the size of the provided layout.\n+     * <p>\n+     * Equivalent to the following code:\n+     * {@snippet lang=java :\n+     * asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+     * }\n+     *\n+     * @see #asSlice(long, long, long)\n+     *\n+     * @param offset The new segment base offset (relative to the address of this segment), specified in bytes.\n+     * @param layout The layout of the segment slice.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > layout.byteSize()},\n+     * {@code newSize < 0}, or {@code newSize > layout.byteSize() - offset}\n+     * @throws IllegalArgumentException if this segment cannot be accessed at {@code offset} under\n+     * the alignment constraint specified by {@code layout}.\n+     * @return a slice of this memory segment.\n+     *\/\n+    default MemorySegment asSlice(long offset, MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return asSlice(offset, layout.byteSize(), layout.byteAlignment());\n+    }\n+\n@@ -489,3 +569,104 @@\n-    default MemorySegment asSlice(long offset) {\n-        return asSlice(offset, byteSize() - offset);\n-    }\n+    MemorySegment asSlice(long offset);\n+\n+    \/**\n+     * Returns a new memory segment that has the same address and scope as this segment, but with the provided size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param newSize the size of the returned segment.\n+     * @return a new memory segment that has the same address and scope as this segment, but the new\n+     * provided size.\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment reinterpret(long newSize);\n+\n+    \/**\n+     * Returns a new memory segment with the same address and size as this segment, but with the provided scope.\n+     * As such, the returned segment cannot be accessed after the provided arena has been closed.\n+     * Moreover, the returned segment can be accessed compatibly with the confinement restrictions associated with the\n+     * provided arena: that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n+     * the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions\n+     * associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated\n+     * using the provided arena.\n+     * <p>\n+     * Clients can specify an optional cleanup action that should be executed when the provided scope becomes\n+     * invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows:\n+     * {@snippet lang=java :\n+     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address());\n+     * }\n+     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * and is accessible from any thread. The size of the segment accepted by the cleanup action is {@link #byteSize()}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @apiNote The cleanup action (if present) should take care not to leak the received segment to external\n+     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n+     * if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena}, the cleanup action\n+     * must not prevent the scope from becoming <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param arena the arena to be associated with the returned segment.\n+     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n+     * @return a new memory segment with unbounded size.\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment reinterpret(Arena arena, Consumer<MemorySegment> cleanup);\n+\n+    \/**\n+     * Returns a new segment with the same address as this segment, but with the provided size and scope.\n+     * As such, the returned segment cannot be accessed after the provided arena has been closed.\n+     * Moreover, if the returned segment can be accessed compatibly with the confinement restrictions associated with the\n+     * provided arena: that is, if the provided arena is a {@linkplain Arena#ofConfined() confined arena},\n+     * the returned segment can only be accessed by the arena's owner thread, regardless of the confinement restrictions\n+     * associated with this segment. In other words, this method returns a segment that behaves as if it had been allocated\n+     * using the provided arena.\n+     * <p>\n+     * Clients can specify an optional cleanup action that should be executed when the provided scope becomes\n+     * invalid. This cleanup action receives a fresh memory segment that is obtained from this segment as follows:\n+     * {@snippet lang=java :\n+     * MemorySegment cleanupSegment = MemorySegment.ofAddress(this.address());\n+     * }\n+     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * and is accessible from any thread. The size of the segment accepted by the cleanup action is {@code newSize}.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @apiNote The cleanup action (if present) should take care not to leak the received segment to external\n+     * clients which might access the segment after its backing region of memory is no longer available. Furthermore,\n+     * if the provided scope is the scope of an {@linkplain Arena#ofAuto() automatic arena}, the cleanup action\n+     * must not prevent the scope from becoming <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+     * A failure to do so will permanently prevent the regions of memory allocated by the automatic arena from being deallocated.\n+     *\n+     * @param newSize the size of the returned segment.\n+     * @param arena the arena to be associated with the returned segment.\n+     * @param cleanup the cleanup action that should be executed when the provided arena is closed (can be {@code null}).\n+     * @return a new segment that has the same address as this segment, but with new size and its scope set to\n+     * that of the provided arena.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalArgumentException if {@code newSize < 0}.\n+     * @throws IllegalStateException if {@code scope.isAlive() == false}.\n+     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment reinterpret(long newSize, Arena arena, Consumer<MemorySegment> cleanup);\n@@ -509,1 +690,1 @@\n-     * created e.g. using the {@link #allocateNative(long, SegmentScope)} (and related) factory, or by\n+     * created e.g. using the {@link Arena#allocate(long, long)} (and related) factory, or by\n@@ -517,1 +698,1 @@\n-     * {@link FileChannel#map(FileChannel.MapMode, long, long, SegmentScope)} factory, or by\n+     * {@link FileChannel#map(FileChannel.MapMode, long, long, Arena)} factory, or by\n@@ -584,1 +765,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -586,1 +767,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -603,1 +784,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -605,1 +786,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -607,1 +788,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -609,1 +790,1 @@\n-     * such that {@code src.scope().isAccessibleBy(T) == false}.\n+     * such that {@code src.isAccessibleBy(T) == false}.\n@@ -637,1 +818,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -639,1 +820,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -641,1 +822,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -643,1 +824,1 @@\n-     * such that {@code other.scope().isAccessibleBy(T) == false}.\n+     * such that {@code other.isAccessibleBy(T) == false}.\n@@ -669,1 +850,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -671,1 +852,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -686,1 +867,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -688,1 +869,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -703,1 +884,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -705,1 +886,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -732,1 +913,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -734,1 +915,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -754,1 +935,1 @@\n-     * after the scope associated with this segment is no longer {@linkplain SegmentScope#isAlive() alive}, will\n+     * after the scope associated with this segment is no longer {@linkplain Scope#isAlive() alive}, will\n@@ -756,1 +937,1 @@\n-     * such that {@code scope().isAccessible(T) == false} will throw a {@link WrongThreadException}.\n+     * such that {@code isAccessible(T) == false} will throw a {@link WrongThreadException}.\n@@ -758,1 +939,1 @@\n-     * If this segment is associated with a scope that can only be accessed from a single thread, calling read\/write I\/O\n+     * If this segment is accessible from a single thread, calling read\/write I\/O\n@@ -779,1 +960,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -781,1 +962,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -793,1 +974,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -795,1 +976,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -807,1 +988,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -809,1 +990,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -821,1 +1002,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -823,1 +1004,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -835,1 +1016,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -837,1 +1018,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -849,1 +1030,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -851,1 +1032,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -863,1 +1044,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -865,1 +1046,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -885,1 +1066,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -887,1 +1068,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -910,1 +1091,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -912,1 +1093,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -927,9 +1108,7 @@\n-     * The scope {@code S} associated with the returned segment is computed as follows:\n-     * <ul>\n-     *     <li>if the buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose scope\n-     *     is {@code S'}, then {@code S = S'}; or<\/li>\n-     *     <li>if the buffer is a heap buffer, then {@code S} is the {@linkplain SegmentScope#global() global scope}; or\n-     *     <li>if the buffer is a direct buffer, then {@code S} is a scope that is always alive and which keeps the buffer reachable.\n-     *     Therefore, the off-heap region of memory backing the buffer instance will remain available as long as the\n-     *     returned segment is reachable.<\/li>\n-     * <\/ul>\n+     * If the provided buffer has been obtained by calling {@link #asByteBuffer()} on a memory segment whose\n+     * {@linkplain Scope scope} is {@code S}, the returned segment will be associated with the\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n+     * <p>\n+     * The scope associated with the returned segment keeps the provided buffer reachable. As such, if\n+     * the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the\n+     * returned segment (or any of its slices) are kept reachable.\n@@ -950,2 +1129,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -962,2 +1141,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -974,2 +1153,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -986,2 +1165,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -998,2 +1177,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1010,2 +1189,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1022,2 +1201,2 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}, and\n-     * its {@link #address()} is set to zero.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given byte array reachable.\n+     * The returned segment is always accessible, from any thread. Its {@link #address()} is set to zero.\n@@ -1035,1 +1214,1 @@\n-    MemorySegment NULL = NativeMemorySegmentImpl.makeNativeSegmentUnchecked(0L, 0);\n+    MemorySegment NULL = new NativeMemorySegmentImpl();\n@@ -1039,1 +1218,1 @@\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n+     * The returned segment is always accessible, from any thread.\n@@ -1041,4 +1220,4 @@\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, 0);\n-     *}\n+     * On 32-bit platforms, the given address value will be normalized such that the\n+     * highest-order (\"leftmost\") 32 bits of the {@link MemorySegment#address() address}\n+     * of the returned memory segment are set to zero.\n+     *\n@@ -1052,202 +1231,0 @@\n-    \/**\n-     * Creates a native segment with the given size and {@linkplain #address() address value}.\n-     * The returned segment is associated with the {@linkplain SegmentScope#global() global scope}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, byteSize, SegmentScope.global());\n-     *}\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param address the address of the returned native segment.\n-     * @param byteSize the size (in bytes) of the returned native segment.\n-     * @return a zero-length native segment with the given address and size.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long byteSize) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        return MemorySegment.ofAddress(address, byteSize, SegmentScope.global());\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size, address, and scope.\n-     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n-     * where an address to some underlying region of memory is typically obtained from foreign code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided scope.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * ofAddress(address, byteSize, scope, null);\n-     *}\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @param address the returned segment's address.\n-     * @param byteSize the desired size.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a native segment with the given address, size and scope.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    @ForceInline\n-    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        Objects.requireNonNull(scope);\n-        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, null);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size, address, and scope.\n-     * This method can be useful when interacting with custom memory sources (e.g. custom allocators),\n-     * where an address to some underlying region of memory is typically obtained from foreign code\n-     * (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided scope.\n-     * <p>\n-     * The provided cleanup action (if any) will be invoked when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid address from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     *\n-     * @param address the returned segment's address.\n-     * @param byteSize the desired size.\n-     * @param scope the scope associated with the returned native segment.\n-     * @param cleanupAction the custom cleanup action to be associated to the returned segment (can be null).\n-     * @return a native segment with the given address, size and scope.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static MemorySegment ofAddress(long address, long byteSize, SegmentScope scope, Runnable cleanupAction) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), MemorySegment.class, \"ofAddress\");\n-        Objects.requireNonNull(scope);\n-        Utils.checkAllocationSizeAndAlign(byteSize, 1);\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, byteSize, scope, cleanupAction);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given layout and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment will be aligned according to the alignment constraint of the provided layout.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n-     * }\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param layout the layout of the off-heap memory region backing the native segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native segment.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(MemoryLayout layout, SegmentScope scope) {\n-        Objects.requireNonNull(layout);\n-        Objects.requireNonNull(scope);\n-        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size (in bytes) and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment is guaranteed to be at least 1-byte aligned.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang=java :\n-     * allocateNative(bytesSize, 1, scope);\n-     * }\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param byteSize the size (in bytes) of the off-heap memory region of memory backing the native memory segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(long byteSize, SegmentScope scope) {\n-        return allocateNative(byteSize, 1, scope);\n-    }\n-\n-    \/**\n-     * Creates a native segment with the given size (in bytes), alignment (in bytes) and scope.\n-     * <p>\n-     * The lifetime off-heap region of memory associated with the returned native segment is determined by the\n-     * provided scope. The off-heap memory region is deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}. If the scope has been obtained using an {@link Arena},\n-     * clients are responsible for ensuring that the arena is closed when the returned segment is no longer in use\n-     * Failure to do so will result in off-heap memory leaks. As an alternative, an {@linkplain SegmentScope#auto() automatic scope}\n-     * can be used, allowing the off-heap memory region associated with the returned native segment to be\n-     * automatically released some unspecified time after the scope is no longer referenced.\n-     * <p>\n-     * The {@linkplain #address() address} of the returned memory segment is the starting address of\n-     * the newly allocated off-heap region backing the segment. Moreover, the {@linkplain #address() address}\n-     * of the returned segment will be aligned according to the provided alignment constraint.\n-     * <p>\n-     * The region of off-heap region backing the returned native segment is initialized to zero.\n-     *\n-     * @param byteSize the size (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @param byteAlignment the alignment constraint (in bytes) of the off-heap region of memory backing the native memory segment.\n-     * @param scope the scope associated with the returned native segment.\n-     * @return a new native memory segment.\n-     * @throws IllegalArgumentException if {@code byteSize < 0}, {@code byteAlignment <= 0}, or if {@code byteAlignment}\n-     *                                  is not a power of 2.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static MemorySegment allocateNative(long byteSize, long byteAlignment, SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        return NativeMemorySegmentImpl.makeNativeSegment(byteSize, byteAlignment, scope);\n-    }\n-\n@@ -1278,1 +1255,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1280,1 +1257,1 @@\n-     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -1282,1 +1259,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1284,1 +1261,1 @@\n-     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -1291,1 +1268,2 @@\n-    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+    static void copy(MemorySegment srcSegment, long srcOffset,\n+                     MemorySegment dstSegment, long dstOffset, long bytes) {\n@@ -1325,1 +1303,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1327,1 +1305,1 @@\n-     * such that {@code srcSegment().scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment().isAccessibleBy(T) == false}.\n@@ -1329,1 +1307,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1331,1 +1309,1 @@\n-     * such that {@code dstSegment().scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment().isAccessibleBy(T) == false}.\n@@ -1338,2 +1316,3 @@\n-    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n-                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset,\n+                     MemorySegment dstSegment, ValueLayout dstElementLayout, long dstOffset,\n+                     long elementCount) {\n@@ -1344,25 +1323,1 @@\n-        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n-        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n-        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Source and destination layouts must have same size\");\n-        }\n-        Utils.checkElementAlignment(srcElementLayout, \"Source layout alignment greater than its size\");\n-        Utils.checkElementAlignment(dstElementLayout, \"Destination layout alignment greater than its size\");\n-        if (!srcImpl.isAlignedForElement(srcOffset, srcElementLayout)) {\n-            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n-        }\n-        if (!dstImpl.isAlignedForElement(dstOffset, dstElementLayout)) {\n-            throw new IllegalArgumentException(\"Destination segment incompatible with alignment constraints\");\n-        }\n-        long size = elementCount * srcElementLayout.byteSize();\n-        srcImpl.checkAccess(srcOffset, size, true);\n-        dstImpl.checkAccess(dstOffset, size, false);\n-        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n-        } else {\n-            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.sessionImpl(), dstImpl.sessionImpl(),\n-                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n-                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n-        }\n+        AbstractMemorySegmentImpl.copy(srcSegment, srcElementLayout, srcOffset, dstSegment, dstElementLayout, dstOffset, elementCount);\n@@ -1378,1 +1333,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1380,1 +1335,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1398,1 +1353,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1400,1 +1355,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1419,1 +1374,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1421,1 +1376,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1439,1 +1394,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1441,1 +1396,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1460,1 +1415,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1462,1 +1417,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1480,1 +1435,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1482,1 +1437,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1501,1 +1456,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1503,1 +1458,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1521,1 +1476,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1523,1 +1478,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1542,1 +1497,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1544,1 +1499,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1562,1 +1517,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1564,1 +1519,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1583,1 +1538,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1585,1 +1540,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1603,1 +1558,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1605,1 +1560,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1624,1 +1579,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1626,1 +1581,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1644,1 +1599,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1646,1 +1601,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1665,1 +1620,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1667,1 +1622,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1685,1 +1640,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1687,1 +1642,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1701,4 +1656,4 @@\n-     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n+     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n+     * is set to {@code T.byteSize()}.\n@@ -1709,1 +1664,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1711,1 +1666,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1714,0 +1669,3 @@\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n+     * {@code T}, and the address of the returned segment\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}.\n@@ -1718,1 +1676,1 @@\n-    default MemorySegment get(ValueLayout.OfAddress layout, long offset) {\n+    default MemorySegment get(AddressLayout layout, long offset) {\n@@ -1729,1 +1687,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1731,1 +1689,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1740,1 +1698,1 @@\n-    default void set(ValueLayout.OfAddress layout, long offset, MemorySegment value) {\n+    default void set(AddressLayout layout, long offset, MemorySegment value) {\n@@ -1744,0 +1702,48 @@\n+    \/**\n+     * Reads a byte from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a byte value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default byte getAtIndex(ValueLayout.OfByte layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (byte) ((ValueLayouts.OfByteImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be read.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @return a boolean value read from this segment.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean getAtIndex(ValueLayout.OfBoolean layout, long index) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return (boolean) ((ValueLayouts.OfBooleanImpl) layout).accessHandle().get(this, index * layout.byteSize());\n+    }\n+\n@@ -1752,1 +1758,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1754,1 +1760,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1776,1 +1782,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1778,1 +1784,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1801,1 +1807,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1803,1 +1809,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1817,0 +1823,51 @@\n+    \/**\n+     * Writes a byte into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfByte layout, long index, byte value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfByteImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+\n+    }\n+\n+    \/**\n+     * Writes a boolean into this segment at the given index, scaled by the given layout size.\n+     *\n+     * @param layout the layout of the region of memory to be written.\n+     * @param index a logical index. The offset in bytes (relative to this segment address) at which the access operation\n+     *              will occur can be expressed as {@code (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with this segment is not\n+     * {@linkplain Scope#isAlive() alive}.\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     * such that {@code isAccessibleBy(T) == false}.\n+     * @throws IllegalArgumentException if the access operation is\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in the provided layout,\n+     * or if the layout alignment is greater than its size.\n+     * @throws IndexOutOfBoundsException when the access operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     * @throws UnsupportedOperationException if this segment is {@linkplain #isReadOnly() read-only}.\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfBoolean layout, long index, boolean value) {\n+        Utils.checkElementAlignment(layout, \"Layout alignment greater than its size\");\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        ((ValueLayouts.OfBooleanImpl) layout).accessHandle().set(this, index * layout.byteSize(), value);\n+    }\n+\n@@ -1825,1 +1882,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1827,1 +1884,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1850,1 +1907,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1852,1 +1909,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1874,1 +1931,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1876,1 +1933,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1899,1 +1956,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1901,1 +1958,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1923,1 +1980,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1925,1 +1982,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1948,1 +2005,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1950,1 +2007,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1972,1 +2029,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1974,1 +2031,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -1997,1 +2054,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -1999,1 +2056,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2021,1 +2078,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2023,1 +2080,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2040,5 +2097,4 @@\n-     * a native segment, associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions,\n-     * the size of the returned segment is {@code 0}. However, if the provided layout is an\n-     * {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded} address layout, then the size of the returned\n-     * segment is {@code Long.MAX_VALUE}.\n-     *\n+     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * the size of the returned segment is {@code 0}. However, if the provided address layout has a\n+     * {@linkplain AddressLayout#targetLayout()} {@code T}, then the size of the returned segment\n+     * is set to {@code T.byteSize()}.\n@@ -2050,1 +2106,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2052,1 +2108,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2056,0 +2112,3 @@\n+     * @throws IllegalArgumentException if provided address layout has a {@linkplain AddressLayout#targetLayout() target layout}\n+     * {@code T}, and the address of the returned segment\n+     * <a href=\"MemorySegment.html#segment-alignment\">incompatible with the alignment constraint<\/a> in {@code T}.\n@@ -2060,1 +2119,1 @@\n-    default MemorySegment getAtIndex(ValueLayout.OfAddress layout, long index) {\n+    default MemorySegment getAtIndex(AddressLayout layout, long index) {\n@@ -2074,1 +2133,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2076,1 +2135,1 @@\n-     * such that {@code scope().isAccessibleBy(T) == false}.\n+     * such that {@code isAccessibleBy(T) == false}.\n@@ -2086,1 +2145,1 @@\n-    default void setAtIndex(ValueLayout.OfAddress layout, long index, MemorySegment value) {\n+    default void setAtIndex(AddressLayout layout, long index, MemorySegment value) {\n@@ -2136,1 +2195,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2170,1 +2229,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2212,1 +2271,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2214,1 +2273,1 @@\n-     * such that {@code srcSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code srcSegment.isAccessibleBy(T) == false}.\n@@ -2216,1 +2275,1 @@\n-     * {@linkplain SegmentScope#isAlive() alive}.\n+     * {@linkplain Scope#isAlive() alive}.\n@@ -2218,1 +2277,1 @@\n-     * such that {@code dstSegment.scope().isAccessibleBy(T) == false}.\n+     * such that {@code dstSegment.isAccessibleBy(T) == false}.\n@@ -2233,0 +2292,34 @@\n+    \/**\n+     * A scope models the <em>lifetime<\/em> of all the memory segments associated with it. That is, a memory segment\n+     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. A new scope is typically\n+     * obtained indirectly, by creating a new {@linkplain Arena arena}.\n+     * <p>\n+     * Scope instances can be compared for equality. That is, two scopes\n+     * are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n+    sealed interface Scope permits MemorySessionImpl {\n+        \/**\n+         * {@return {@code true}, if the regions of memory backing the memory segments associated with this scope are\n+         * still valid}\n+         *\/\n+        boolean isAlive();\n+\n+        \/**\n+         * {@return {@code true}, if the provided object is also a scope, which models the same lifetime as that\n+         * modelled by this scope}. In that case, it is always the case that\n+         * {@code this.isAlive() == ((Scope)that).isAlive()}.\n+         * @param that the object to be tested.\n+         *\/\n+        @Override\n+        boolean equals(Object that);\n+\n+        \/**\n+         * Returns the hash code of this scope object.\n+         * @implSpec Implementations of this method obey the general contract of {@link Object#hashCode}.\n+         * @return the hash code of this scope object.\n+         * @see #equals(Object)\n+         *\/\n+        @Override\n+        int hashCode();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":544,"deletions":451,"binary":false,"changes":995,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    PaddingLayout withoutName();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/PaddingLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.MemorySessionImpl;\n@@ -49,2 +48,0 @@\n- *     <li>{@link #nativeAllocator(SegmentScope)} obtains a simple allocator which can\n- *     be used to allocate native segments;<\/li>\n@@ -204,1 +201,1 @@\n-    default MemorySegment allocate(ValueLayout.OfAddress layout, MemorySegment value) {\n+    default MemorySegment allocate(AddressLayout layout, MemorySegment value) {\n@@ -366,2 +363,2 @@\n-     * new allocation request will return a new slice starting at the segment offset {@code 0} (alignment\n-     * constraints are ignored by this allocator), hence the name <em>prefix allocator<\/em>.\n+     * new allocation request will return a new slice starting at the segment offset {@code 0}, hence the name\n+     * <em>prefix allocator<\/em>.\n@@ -387,27 +384,0 @@\n-\n-    \/**\n-     * Simple allocator used to allocate native segments. The returned allocator responds to an allocation request by\n-     * returning a native segment backed by a fresh off-heap region of memory, with given byte size and alignment constraint.\n-     * <p>\n-     * Each native segment obtained by the returned allocator is associated with the provided scope. As such,\n-     * the off-heap region which backs the returned segment is freed when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * The {@link MemorySegment#address()} of the native segments obtained by the returned allocator is the starting address of\n-     * the newly allocated off-heap memory region backing the segment. Moreover, the {@linkplain MemorySegment#address() address}\n-     * of the native segment will be aligned according the provided alignment constraint.\n-     * <p>\n-     * The off-heap region of memory backing a native segment obtained by the returned allocator is initialized to zero.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * {@snippet lang = java:\n-     * SegmentAllocator nativeAllocator = (byteSize, byteAlignment) ->\n-     *     MemorySegment.allocateNative(byteSize, byteAlignment, scope);\n-     * }\n-     * @param scope the scope associated with the segments returned by the native allocator.\n-     * @return a simple allocator used to allocate native segments.\n-     *\/\n-    static SegmentAllocator nativeAllocator(SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySessionImpl)scope;\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- *  Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.ref.CleanerFactory;\n-\n-\/**\n- * A segment scope controls access to memory segments.\n- * <p>\n- * A memory segment can only be accessed while its scope is {@linkplain #isAlive() alive}. Moreover,\n- * depending on how the segment scope has been obtained, access might additionally be\n- * <a href=\"Arena.html#thread-confinement\">restricted to specific threads<\/a>.\n- * <p>\n- * The simplest segment scope is the {@linkplain SegmentScope#global() global scope}. The global scope\n- * is always alive. As a result, segments associated with the global scope are always accessible and their backing\n- * regions of memory are never deallocated. Moreover, memory segments associated with the global scope\n- * can be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.global());\n- * ...\n- * \/\/ segment is never deallocated!\n- *}\n- * <p>\n- * Alternatively, clients can obtain an {@linkplain SegmentScope#auto() automatic scope}, that is a segment\n- * scope that is managed, automatically, by the garbage collector. The regions of memory backing memory segments associated\n- * with an automatic scope are deallocated at some unspecified time <em>after<\/em> they become\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>, as shown below:\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = MemorySegment.allocateNative(100, SegmentScope.auto());\n- * ...\n- * segment = null; \/\/ the segment region becomes available for deallocation after this point\n- *}\n- * Memory segments associated with an automatic scope can also be {@linkplain #isAccessibleBy(Thread) accessed} from any thread.\n- * <p>\n- * Finally, clients can obtain a segment scope from an existing {@linkplain Arena arena}, the arena scope. The regions of memory\n- * backing memory segments associated with an arena scope are deallocated when the arena is {@linkplain Arena#close() closed}.\n- * When this happens, the arena scope becomes not {@linkplain #isAlive() alive} and subsequent access operations on segments\n- * associated with the arena scope will fail {@link IllegalStateException}.\n- *\n- * {@snippet lang = java:\n- * MemorySegment segment = null;\n- * try (Arena arena = Arena.openConfined()) {\n- *     segment = MemorySegment.allocateNative(100, arena.scope());\n- *     ...\n- * } \/\/ segment region deallocated here\n- * segment.get(ValueLayout.JAVA_BYTE, 0); \/\/ throws IllegalStateException\n- * }\n- *\n- * Which threads can {@link #isAccessibleBy(Thread) access} memory segments associated with an arena scope depends\n- * on the arena kind. For instance, segments associated with the scope of a {@linkplain Arena#openConfined() confined arena}\n- * can only be accessed by the thread that created the arena. Conversely, segments associated with the scope of\n- * {@linkplain Arena#openConfined() shared arena} can be accessed by any thread.\n- *\n- * @implSpec\n- * Implementations of this interface are thread-safe.\n- *\n- * @see Arena\n- * @see MemorySegment\n- *\n- * @since 20\n- *\/\n-@PreviewFeature(feature =PreviewFeature.Feature.FOREIGN)\n-sealed public interface SegmentScope permits MemorySessionImpl {\n-\n-    \/**\n-     * Creates a new scope that is managed, automatically, by the garbage collector.\n-     * Segments associated with the returned scope can be\n-     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n-     *\n-     * @return a new scope that is managed, automatically, by the garbage collector.\n-     *\/\n-    static SegmentScope auto() {\n-        return MemorySessionImpl.createImplicit(CleanerFactory.cleaner());\n-    }\n-\n-    \/**\n-     * Obtains the global scope. Segments associated with the global scope can be\n-     * {@linkplain SegmentScope#isAccessibleBy(Thread) accessed} by any thread.\n-     *\n-     * @return the global scope.\n-     *\/\n-    static SegmentScope global() {\n-        return MemorySessionImpl.GLOBAL;\n-    }\n-\n-    \/**\n-     * {@return {@code true}, if this scope is alive}\n-     *\/\n-    boolean isAlive();\n-\n-    \/**\n-     * {@return {@code true} if the provided thread can access and\/or associate segments with this scope}\n-     * @param thread the thread to be tested.\n-     *\/\n-    boolean isAccessibleBy(Thread thread);\n-\n-    \/**\n-     * Runs a critical action while this scope is kept alive.\n-     * @param action the action to be run.\n-     * @throws IllegalStateException if this scope is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code isAccessibleBy(T) == false}.\n-     *\/\n-    void whileAlive(Runnable action);\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentScope.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -131,0 +131,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -134,0 +137,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    MemoryLayout withoutName();\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SequenceLayout.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n@@ -45,0 +48,9 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    StructLayout withoutName();\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/StructLayout.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n- *     <li>It can be {@linkplain MemorySegment#set(ValueLayout.OfAddress, long, MemorySegment) stored} inside another memory segment.<\/li>\n- *     <li>It can be used to access the region of memory backing a global variable (this might require\n- *     {@link MemorySegment#ofAddress(long, long, SegmentScope) resizing} the segment first).<\/li>\n+ *     <li>It can be {@linkplain MemorySegment#set(AddressLayout, long, MemorySegment) stored} inside another memory segment.<\/li>\n+ *     <li>It can be used to access the region of memory backing a global variable (this requires\n+ *     {@link MemorySegment#reinterpret(long)} () resizing} the segment first).<\/li>\n@@ -62,1 +62,1 @@\n- * The factory methods {@link #libraryLookup(String, SegmentScope)} and {@link #libraryLookup(Path, SegmentScope)}\n+ * The factory methods {@link #libraryLookup(String, Arena)} and {@link #libraryLookup(Path, Arena)}\n@@ -64,2 +64,4 @@\n- * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, is associated\n- * with a {@linkplain  SegmentScope scope}; when the scope becomes not {@link SegmentScope#isAlive()}, the library is unloaded:\n+ * The library is loaded if not already loaded. The symbol lookup, which is known as a <em>library lookup<\/em>, and its\n+ * lifetime is controlled by an {@linkplain Arena arena}. For instance, if the provided arena is a\n+ * confined arena, the library associated with the symbol lookup is unloaded when the confined arena\n+ * is {@linkplain Arena#close()}:\n@@ -68,2 +70,2 @@\n- * try (Arena arena = Arena.openConfined()) {\n- *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena.scope()); \/\/ libGL.so loaded here\n+ * try (Arena arena = Arena.ofConfined()) {\n+ *     SymbolLookup libGL = SymbolLookup.libraryLookup(\"libGL.so\", arena); \/\/ libGL.so loaded here\n@@ -95,1 +97,1 @@\n- * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n@@ -104,1 +106,1 @@\n- * libraryLookup(\"libGL.so\", scope).find(\"glGetString\").isPresent(); \/\/ true\n+ * libraryLookup(\"libGL.so\", arena).find(\"glGetString\").isPresent(); \/\/ true\n@@ -142,3 +144,4 @@\n-     * returned by this method is backed by a scope that is always alive and which keeps the caller's\n-     * class loader reachable. Therefore, libraries associated with the caller's class\n-     * loader are kept loaded (and their symbols available) as long as a loader lookup for that class loader is reachable.\n+     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * class loader reachable. Therefore, libraries associated with the caller's class loader are kept loaded\n+     * (and their symbols available) as long as a loader lookup for that class loader, or any of the segments\n+     * obtained by it, is reachable.\n@@ -161,3 +164,7 @@\n-        SegmentScope loaderScope = (loader == null || loader instanceof BuiltinClassLoader) ?\n-                SegmentScope.global() : \/\/ builtin loaders never go away\n-                MemorySessionImpl.heapSession(loader);\n+        Arena loaderArena;\/\/ builtin loaders never go away\n+        if ((loader == null || loader instanceof BuiltinClassLoader)) {\n+            loaderArena = Arena.global();\n+        } else {\n+            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            loaderArena = session.asArena();\n+        }\n@@ -171,1 +178,2 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0L, loaderScope));\n+                    Optional.of(MemorySegment.ofAddress(addr)\n+                                    .reinterpret(loaderArena, null));\n@@ -177,2 +185,4 @@\n-     * The library will be unloaded when the provided scope becomes\n-     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n+     * The lifetime of the returned library lookup is controlled by the provided arena.\n+     * For instance, if the provided arena is a confined arena, the library\n+     * associated with the returned lookup will be unloaded when the provided confined arena is\n+     * {@linkplain Arena#close() closed}.\n@@ -189,1 +199,1 @@\n-     * @param scope the scope associated with symbols obtained from the returned lookup.\n+     * @param arena the arena associated with symbols obtained from the returned lookup.\n@@ -191,0 +201,3 @@\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -195,1 +208,1 @@\n-    static SymbolLookup libraryLookup(String name, SegmentScope scope) {\n+    static SymbolLookup libraryLookup(String name, Arena arena) {\n@@ -197,1 +210,1 @@\n-        return libraryLookup(name, RawNativeLibraries::load, scope);\n+        return libraryLookup(name, RawNativeLibraries::load, arena);\n@@ -202,2 +215,4 @@\n-     * in that library. The library will be unloaded when the provided scope becomes\n-     * not {@linkplain SegmentScope#isAlive() alive}, if no other library lookup is still using it.\n+     * in that library. The lifetime of the returned library lookup is controlled by the provided arena.\n+     * For instance, if the provided arena is a confined arena, the library\n+     * associated with the returned lookup will be unloaded when the provided confined arena is\n+     * {@linkplain Arena#close() closed}.\n@@ -213,1 +228,1 @@\n-     * @param scope the scope associated with symbols obtained from the returned lookup.\n+     * @param arena the arena associated with symbols obtained from the returned lookup.\n@@ -215,0 +230,3 @@\n+     * @throws IllegalStateException if {@code arena.scope().isAlive() == false}\n+     * @throws WrongThreadException if {@code arena} is a confined arena, and this method is called from a\n+     * thread {@code T}, other than the arena's owner thread.\n@@ -219,1 +237,1 @@\n-    static SymbolLookup libraryLookup(Path path, SegmentScope scope) {\n+    static SymbolLookup libraryLookup(Path path, Arena arena) {\n@@ -221,1 +239,1 @@\n-        return libraryLookup(path, RawNativeLibraries::load, scope);\n+        return libraryLookup(path, RawNativeLibraries::load, arena);\n@@ -224,1 +242,1 @@\n-    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, SegmentScope libScope) {\n+    private static <Z> SymbolLookup libraryLookup(Z libDesc, BiFunction<RawNativeLibraries, Z, NativeLibrary> loadLibraryFunc, Arena libArena) {\n@@ -226,1 +244,1 @@\n-        Objects.requireNonNull(libScope);\n+        Objects.requireNonNull(libArena);\n@@ -234,1 +252,1 @@\n-        ((MemorySessionImpl) libScope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+        MemorySessionImpl.toMemorySession(libArena).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -245,1 +263,2 @@\n-                    Optional.of(MemorySegment.ofAddress(addr, 0, libScope));\n+                    Optional.of(MemorySegment.ofAddress(addr)\n+                            .reinterpret(libArena, null));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -48,0 +48,6 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    UnionLayout withoutName();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/UnionLayout.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,352 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package java.lang.foreign;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64VaList;\n-import jdk.internal.foreign.abi.riscv64.linux.LinuxRISCV64VaList;\n-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n-import jdk.internal.foreign.abi.x64.windows.WinVaList;\n-import jdk.internal.javac.PreviewFeature;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-\/**\n- * Helper class to create and manipulate variable argument lists, similar in functionality to a C {@code va_list}.\n- * <p>\n- * A variable argument list can be created using the {@link #make(Consumer, SegmentScope)} factory, as follows:\n- * {@snippet lang = java:\n- * VaList vaList = VaList.make(builder ->\n- *                                    builder.addVarg(C_INT, 42)\n- *                                           .addVarg(C_DOUBLE, 3.8d));\n- *}\n- * Once created, clients can obtain the platform-dependent {@linkplain #segment() memory segment} associated with a variable\n- * argument list, which can then be passed to {@linkplain Linker#downcallHandle(FunctionDescriptor, Linker.Option...) downcall method handles}\n- * targeting native functions using the C {@code va_list} type.\n- * <p>\n- * The contents of a foreign memory segment modelling a variable argument list can be accessed by <em>unsafely<\/em> creating\n- * a variable argument list, as follows:\n- * {@snippet lang = java:\n- * void upcall(int n, MemorySegment vaListSegment) {\n- *    try (Arena arena = Arena.openConfined()) {\n- *        VaList vaList = VaList.ofAddress(vaListSegment.address(), arena.scope());\n- *        VaList copy = vaList.copy();\n- *        int i = vaList.nextVarg(C_INT);\n- *        double d = vaList.nextVarg(C_DOUBLE);\n- *        \/\/ and again\n- *        int i = copy.nextVarg(C_INT);\n- *        double d = copy.nextVarg(C_DOUBLE);\n- *     }\n- * }\n- *}\n- * The above method receives a foreign segment modelling a variable argument list; the contents of the segment are accessed by creating\n- * a new variable argument list, from the segment address. Note that the variable argument list is first copied into\n- * a second list before any element is accessed: this will allow us to iterate through the elements twice. Elements in\n- * the variable argument list are accessed using {@link #nextVarg(ValueLayout.OfInt)} and\n- * {@link #nextVarg(ValueLayout.OfDouble)}. These methods (as well as other access methods in the {@link VaList} class)\n- * take the layout of the element that needs to be accessed and perform all the necessary alignment checks as well\n- * as endianness conversions.\n- * <p>\n- * Per the C specification (see C99 standard 6.5.2.2 Function calls - item 6),\n- * arguments to variadic calls are erased by way of 'default argument promotions',\n- * which erases integral types by way of integer promotion (see C99 standard 6.3.1.1 - item 2),\n- * and which erases all {@code float} arguments to {@code double}.\n- * <p>\n- * As such, this interface only supports reading {@code int}, {@code double},\n- * and any other type that fits into a {@code long}.\n- * <h2 id=\"safety\">Safety considerations<\/h2>\n- * Accessing a value through a variable argument list using the wrong memory layout will result in undefined behavior.\n- * For instance, if a variable argument list currently points at a C {@code int} value, then accessing it using\n- * {@link #nextVarg(ValueLayout.OfLong)} is illegal. Similarly, accessing the variable argument list with\n- * {@link #skip(MemoryLayout...)}, and providing a layout other than {@link ValueLayout.OfInt} is illegal.\n- * Any such illegal accesses might not be detected by the implementation, and can corrupt the variable argument list,\n- * so that the behavior of subsequent accesses is also undefined.\n- * <p>\n- * It is possible for clients to access elements outside the spatial bounds of a variable argument list.\n- * Variable argument list implementations will try to detect out-of-bounds reads on a best-effort basis.\n- * <p>\n- * Whether this detection succeeds depends on the factory method used to create the variable argument list:\n- * <ul>\n- *     <li>Variable argument lists created <em>safely<\/em>, using {@link #make(Consumer, SegmentScope)} are capable of detecting out-of-bounds reads;<\/li>\n- *     <li>Variable argument lists created <em>unsafely<\/em>, using {@link #ofAddress(long, SegmentScope)} are not capable of detecting out-of-bounds reads<\/li>\n- * <\/ul>\n- * <p>\n- * This class is not thread safe, and all accesses should occur within a single thread\n- * (regardless of the scope used to obtain the variable arity list).\n- *\n- * @since 19\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, WindowsAArch64VaList, LinuxRISCV64VaList, SharedUtils.EmptyVaList {\n-\n-    \/**\n-     * Reads the next value as an {@code int} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return the {@code int} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    int nextVarg(ValueLayout.OfInt layout);\n-\n-    \/**\n-     * Reads the next value as a {@code long} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return the {@code long} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    long nextVarg(ValueLayout.OfLong layout);\n-\n-    \/**\n-     * Reads the next value as a {@code double} and advances this variable argument list's position. The behavior of this\n-     * method is equivalent to the C {@code va_arg} function.\n-     *\n-     * @param layout the layout of the value\n-     * @return the {@code double} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    double nextVarg(ValueLayout.OfDouble layout);\n-\n-    \/**\n-     * Reads the next address value, wraps it into a native segment, and advances this variable argument list's position.\n-     * The behavior of this method is equivalent to the C {@code va_arg} function. The returned segment's base\n-     * {@linkplain MemorySegment#address()} is set to the value read from the variable argument list, and the segment\n-     * is associated with the {@linkplain SegmentScope#global() global scope}. Under normal conditions, the size of the returned\n-     * segment is {@code 0}. However, if the provided layout is an {@linkplain ValueLayout.OfAddress#asUnbounded() unbounded}\n-     * address layout, then the size of the returned segment is {@code Long.MAX_VALUE}.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @return a native segment whose {@linkplain MemorySegment#address() address} is the value read from\n-     * this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    MemorySegment nextVarg(ValueLayout.OfAddress layout);\n-\n-    \/**\n-     * Reads the next composite value into a new {@code MemorySegment}, allocated with the provided allocator,\n-     * and advances this variable argument list's position. The behavior of this method is equivalent to the C\n-     * {@code va_arg} function. The provided group layout must correspond to a C struct or union type.\n-     * <p>\n-     * How the value is read in the returned segment is ABI-dependent: calling this method on a group layout\n-     * with member layouts {@code L_1, L_2, ... L_n} is not guaranteed to be semantically equivalent to perform distinct\n-     * calls to {@code nextVarg} for each of the layouts in {@code L_1, L_2, ... L_n}.\n-     * <p>\n-     * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n-     *\n-     * @param layout the layout of the value to be read.\n-     * @param allocator the allocator to be used to create a segment where the contents of the variable argument list\n-     *                  will be copied.\n-     * @return the {@code MemorySegment} value read from this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator);\n-\n-    \/**\n-     * Skips a number of elements with the given memory layouts, and advances this variable argument list's position.\n-     *\n-     * @param layouts the layouts of the values to be skipped.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     * @throws NoSuchElementException if an <a href=VaList.html#safety>out-of-bounds<\/a> read is detected.\n-     *\/\n-    void skip(MemoryLayout... layouts);\n-\n-    \/**\n-     * Copies this variable argument list at its current position into a new variable argument list associated\n-     * with the same scope as this variable argument list. The behavior of this method is equivalent to the C\n-     * {@code va_copy} function.\n-     * <p>\n-     * Copying is useful to traverse the variable argument list elements, starting from the current position,\n-     * without affecting the state of the original variable argument list, essentially allowing the elements to be\n-     * traversed multiple times.\n-     *\n-     * @return a copy of this variable argument list.\n-     * @throws IllegalStateException if the scope associated with this variable argument list is not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code segment().scope().isAccessibleBy(T) == false}.\n-     *\/\n-    VaList copy();\n-\n-    \/**\n-     * Returns a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n-     * The contents of the returned memory segment are platform-dependent. Whether and how the contents of\n-     * the returned segment are updated when iterating the contents of a variable argument list is also\n-     * platform-dependent.\n-     * @return a zero-length {@linkplain MemorySegment memory segment} associated with this variable argument list.\n-     *\/\n-    MemorySegment segment();\n-\n-    \/**\n-     * Creates a variable argument list from the give address value and scope. The address is typically obtained\n-     * by calling {@link MemorySegment#address()} on a foreign memory segment instance. The provided scope determines\n-     * the lifecycle of the returned variable argument list: the returned variable argument list will no longer be accessible,\n-     * and its associated off-heap memory region will be deallocated when the scope becomes not\n-     * {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param address the address of the variable argument list.\n-     * @param scope the scope associated with the returned variable argument list.\n-     * @return a new variable argument list backed by an off-heap region of memory starting at the given address value.\n-     * @throws IllegalStateException         if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException          if this method is called from a thread {@code T},\n-     *                                       such that {@code scope.isAccessibleBy(T) == false}.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-     *\/\n-    @CallerSensitive\n-    static VaList ofAddress(long address, SegmentScope scope) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), VaList.class, \"ofAddress\");\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaListOfAddress(address, scope);\n-    }\n-\n-    \/**\n-     * Creates a variable argument list using a builder (see {@link Builder}), with the given\n-     * scope. The provided scope determines the lifecycle of the returned variable argument list: the\n-     * returned variable argument list will no longer be accessible, and its associated off-heap memory region will be\n-     * deallocated when the scope becomes not {@linkplain SegmentScope#isAlive() alive}.\n-     * <p>\n-     * Note that when there are no elements added to the created va list,\n-     * this method will return the same as {@link #empty()}.\n-     *\n-     * @implNote variable argument lists created using this method can detect <a href=VaList.html#safety>out-of-bounds<\/a> reads.\n-     *\n-     * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-     *                of the underlying variable argument list.\n-     * @param scope the scope to be associated with the new variable arity list.\n-     * @return a new variable argument list.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     * @throws IllegalStateException if {@code scope} is not {@linkplain SegmentScope#isAlive() alive}.\n-     * @throws WrongThreadException if this method is called from a thread {@code T},\n-     * such that {@code scope.isAccessibleBy(T) == false}.\n-     *\/\n-    static VaList make(Consumer<Builder> actions, SegmentScope scope) {\n-        Objects.requireNonNull(actions);\n-        Objects.requireNonNull(scope);\n-        return SharedUtils.newVaList(actions, scope);\n-    }\n-\n-    \/**\n-     * Returns an empty variable argument list, associated with the {@linkplain SegmentScope#global() global scope}.\n-     * The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n-     * on all operations, except for {@link VaList#segment()}, {@link VaList#copy()}.\n-     * @return an empty variable argument list.\n-     * @throws UnsupportedOperationException if the underlying native platform is not supported.\n-     *\/\n-    static VaList empty() {\n-        return SharedUtils.emptyVaList();\n-    }\n-\n-    \/**\n-     * A builder used to construct a {@linkplain VaList variable argument list}.\n-     *\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature=PreviewFeature.Feature.FOREIGN)\n-    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder, WindowsAArch64VaList.Builder, LinuxRISCV64VaList.Builder {\n-\n-        \/**\n-         * Writes an {@code int} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code int} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfInt layout, int value);\n-\n-        \/**\n-         * Writes a {@code long} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code long} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfLong layout, long value);\n-\n-        \/**\n-         * Writes a {@code double} value to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code double} value to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfDouble layout, double value);\n-\n-        \/**\n-         * Writes the {@linkplain MemorySegment#address() address} of the provided native segment\n-         * to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param segment the segment whose {@linkplain MemorySegment#address() address} is to be written.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(ValueLayout.OfAddress layout, MemorySegment segment);\n-\n-        \/**\n-         * Writes a {@code MemorySegment}, with the given layout, to the variable argument list being constructed.\n-         *\n-         * @param layout the layout of the value to be written.\n-         * @param value the {@code MemorySegment} whose contents will be copied.\n-         * @return this builder.\n-         *\/\n-        Builder addVarg(GroupLayout layout, MemorySegment value);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":0,"deletions":352,"binary":false,"changes":352,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n@@ -52,0 +51,1 @@\n+ * @sealedGraph\n@@ -55,1 +55,3 @@\n-public sealed interface ValueLayout extends MemoryLayout {\n+public sealed interface ValueLayout extends MemoryLayout permits\n+        ValueLayout.OfBoolean, ValueLayout.OfByte, ValueLayout.OfChar, ValueLayout.OfShort, ValueLayout.OfInt,\n+        ValueLayout.OfFloat, ValueLayout.OfLong, ValueLayout.OfDouble, AddressLayout {\n@@ -71,0 +73,6 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    ValueLayout withoutName();\n+\n@@ -164,0 +172,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfBoolean withoutName();\n+\n@@ -193,0 +207,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfByte withoutName();\n+\n@@ -223,0 +243,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfChar withoutName();\n+\n@@ -253,0 +279,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfShort withoutName();\n+\n@@ -283,0 +315,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfInt withoutName();\n+\n@@ -313,0 +351,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfFloat withoutName();\n+\n@@ -343,0 +387,6 @@\n+        \/**\n+         * {@inheritDoc}\n+         *\/\n+        @Override\n+        OfLong withoutName();\n+\n@@ -377,1 +427,1 @@\n-        OfDouble withBitAlignment(long bitAlignment);\n+        OfDouble withoutName();\n@@ -383,25 +433,1 @@\n-        OfDouble withOrder(ByteOrder order);\n-\n-    }\n-\n-    \/**\n-     * A value layout whose carrier is {@code MemorySegment.class}.\n-     *\n-     * @see #ADDRESS\n-     * @see #ADDRESS_UNALIGNED\n-     * @since 19\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.FOREIGN)\n-    sealed interface OfAddress extends ValueLayout permits ValueLayouts.OfAddressImpl {\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        OfAddress withName(String name);\n-\n-        \/**\n-         * {@inheritDoc}\n-         *\/\n-        @Override\n-        OfAddress withBitAlignment(long bitAlignment);\n+        OfDouble withBitAlignment(long bitAlignment);\n@@ -413,24 +439,1 @@\n-        OfAddress withOrder(ByteOrder order);\n-\n-        \/**\n-         * Returns an <em>unbounded<\/em> address layout with the same carrier, alignment constraint, name and order as this address layout,\n-         * but with the specified pointee layout. An unbounded address layout allow raw addresses to be accessed\n-         * as {@linkplain MemorySegment memory segments} whose size is set to {@link Long#MAX_VALUE}. As such,\n-         * these segments can be used in subsequent access operations.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @return an unbounded address layout with same characteristics as this layout.\n-         * @throws IllegalCallerException If the caller is in a module that does not have native access enabled.\n-         * @see #isUnbounded()\n-         *\/\n-        @CallerSensitive\n-        OfAddress asUnbounded();\n-\n-        \/**\n-         * {@return {@code true}, if this address layout is an {@linkplain #asUnbounded() unbounded address layout}}.\n-         *\/\n-        boolean isUnbounded();\n+        OfDouble withOrder(ByteOrder order);\n@@ -443,4 +446,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(MemorySegment.class, ByteOrder.nativeOrder());\n-     * }\n@@ -448,1 +447,1 @@\n-    OfAddress ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n+    AddressLayout ADDRESS = ValueLayouts.OfAddressImpl.of(ByteOrder.nativeOrder());\n@@ -453,4 +452,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder());\n-     * }\n@@ -463,4 +458,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder());\n-     * }\n@@ -473,4 +464,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder());\n-     * }\n@@ -483,4 +470,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder());\n-     * }\n@@ -493,4 +476,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder());\n-     * }\n@@ -503,4 +482,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder());\n-     * }\n@@ -513,4 +488,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(32);\n-     * }\n@@ -523,4 +494,0 @@\n-     * Equivalent to the following code:\n-     * {@snippet lang=java :\n-     * MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder());\n-     * }\n@@ -540,1 +507,1 @@\n-    OfAddress ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n+    AddressLayout ADDRESS_UNALIGNED = ADDRESS.withBitAlignment(8);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/ValueLayout.java","additions":58,"deletions":91,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,7 @@\n- * models a contiguous region of memory, residing either inside or outside the Java heap. The contents of a memory\n- * segment can be described using a {@link java.lang.foreign.MemoryLayout memory layout}, which provides\n- * basic operations to query sizes, offsets and alignment constraints. Memory layouts also provide\n- * an alternate, more abstract way, to <a href=MemorySegment.html#segment-deref>access memory segments<\/a>\n- * using {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n+ * models a contiguous region of memory, residing either inside or outside the Java heap. Memory segments are\n+ * typically allocated using an {@link java.lang.foreign.Arena}, which controls the lifetime of the regions of memory\n+ * backing the segments it allocates. The contents of a memory segment can be described using a\n+ * {@link java.lang.foreign.MemoryLayout memory layout}, which provides basic operations to query sizes, offsets and\n+ * alignment constraints. Memory layouts also provide an alternate, more abstract way, to\n+ * <a href=MemorySegment.html#segment-deref>access memory segments<\/a> using\n+ * {@linkplain java.lang.foreign.MemoryLayout#varHandle(java.lang.foreign.MemoryLayout.PathElement...) var handles},\n@@ -45,34 +47,1 @@\n- * MemorySegment segment = MemorySegment.allocateNative(10 * 4, SegmentScope.auto());\n- * for (int i = 0 ; i < 10 ; i++) {\n- *     segment.setAtIndex(ValueLayout.JAVA_INT, i, i);\n- * }\n- *}\n- *\n- * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n- * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n- * The segment is associated with an {@linkplain java.lang.foreign.SegmentScope#auto() automatic scope}. This\n- * means that the off-heap region of memory backing the segment is managed, automatically, by the garbage collector.\n- * As such, the off-heap memory backing the native segment will be released at some unspecified\n- * point <em>after<\/em> the segment becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * This is similar to what happens with direct buffers created via {@link java.nio.ByteBuffer#allocateDirect(int)}.\n- * It is also possible to manage the lifecycle of allocated native segments more directly, as shown in a later section.\n- * <p>\n- * Inside a loop, we then initialize the contents of the memory segment; note how the\n- * {@linkplain java.lang.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) access method}\n- * accepts a {@linkplain java.lang.foreign.ValueLayout value layout}, which specifies the size, alignment constraint,\n- * byte order as well as the Java type ({@code int}, in this case) associated with the access operation. More specifically,\n- * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n- * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n- * so that {@code s[i] = i}, again where {@code 0 <= i < 10}.\n- *\n- * <h3 id=\"deallocation\">Deterministic deallocation<\/h3>\n- *\n- * When writing code that manipulates memory segments, especially if backed by memory which resides outside the Java heap, it is\n- * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n- * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n- * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n- * Clients that operate under these assumptions might want to programmatically release the memory backing a memory segment.\n- * This can be done, using the {@link java.lang.foreign.Arena} abstraction, as shown below:\n- *\n- * {@snippet lang = java:\n- * try (Arena arena = Arena.openConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) {\n@@ -84,10 +53,1 @@\n- *}\n- *\n- * This example is almost identical to the prior one; this time we first create an arena\n- * which is used to allocate multiple native segments which share the same life-cycle. That is, all the segments\n- * allocated by the arena will be associated with the same {@linkplain java.lang.foreign.SegmentScope scope}.\n- * Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region of memory backing the\n- * native segment will be released at the end of the block, according to the semantics described in Section {@jls 14.20.3}\n- * of <cite>The Java Language Specification<\/cite>.\n- *\n- * <h3 id=\"safety\">Safety<\/h3>\n+ * }\n@@ -95,1 +55,10 @@\n- * This API provides strong safety guarantees when it comes to memory access. First, when dereferencing a memory segment,\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * off-heap memory; the size of the segment is 40 bytes, enough to store 10 values of the primitive type {@code int}.\n+ * The native segment is allocated using a {@linkplain java.lang.foreign.Arena#ofConfined() confined arena}.\n+ * As such, access to the native segment is restricted to the current thread (the thread that created the arena).\n+ * Moreover, when the arena is closed, the native segment is invalidated, and its backing region of memory is\n+ * deallocated. Note the use of the <em>try-with-resources<\/em> construct: this idiom ensures that the off-heap region\n+ * of memory backing the native segment will be released at the end of the block, according to the semantics described\n+ * in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n+ * <p>\n+ * Memory segments provide strong safety guarantees when it comes to memory access. First, when accessing a memory segment,\n@@ -101,4 +70,6 @@\n- * Since memory segments created with an arena can become invalid (see above), segments are also validated (upon access) to make sure that\n- * the scope associated with the segment being accessed is still alive.\n- * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n- * operation either succeeds - and accesses a valid location within the region of memory backing the memory segment - or fails.\n+ * Additionally, to prevent a region of memory from being accessed <em>after<\/em> it has been deallocated\n+ * (i.e. <em>use-after-free<\/em>), a segment is also validated (upon access) to make sure that the arena from which it\n+ * has been obtained has not been closed. We call this guarantee <em>temporal safety<\/em>.\n+ * <p>\n+ * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid\n+ * location within the region of memory backing the memory segment - or fails.\n@@ -114,1 +85,1 @@\n- * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux x64 platform,\n+ * For example, to compute the length of a string using the C standard library function {@code strlen} on a Linux\/x64 platform,\n@@ -125,1 +96,1 @@\n- * try (Arena arena = Arena.openConfined()) {\n+ * try (Arena arena = Arena.ofConfined()) {\n@@ -127,1 +98,1 @@\n- *     long len = (long)strlen.invoke(cString); \/\/ 5\n+ *     long len = (long)strlen.invokeExact(cString); \/\/ 5\n@@ -132,2 +103,2 @@\n- * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} symbol in the\n- * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * to {@linkplain java.lang.foreign.SymbolLookup#find(java.lang.String) look up} the {@code strlen} function in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said function is subsequently\n@@ -138,1 +109,1 @@\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n@@ -145,52 +116,0 @@\n- * <h3 id=\"upcalls\">Upcalls<\/h3>\n- * The {@link java.lang.foreign.Linker} interface also allows clients to turn an existing method handle (which might point\n- * to a Java method) into a memory segment, so that Java code can effectively be passed to other foreign functions.\n- * For instance, we can write a method that compares two integer values, as follows:\n- *\n- * {@snippet lang=java :\n- * class IntComparator {\n- *     static int intCompare(MemorySegment addr1, MemorySegment addr2) {\n- *         return addr1.get(ValueLayout.JAVA_INT, 0) -\n- *                addr2.get(ValueLayout.JAVA_INT, 0);\n- *\n- *     }\n- * }\n- * }\n- *\n- * The above method accesses two foreign memory segments containing an integer value, and performs a simple comparison\n- * by returning the difference between such values. We can then obtain a method handle which targets the above static\n- * method, as follows:\n- *\n- * {@snippet lang = java:\n- * FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT,\n- *                                                                 ValueLayout.ADDRESS.asUnbounded(),\n- *                                                                 ValueLayout.ADDRESS.asUnbounded());\n- * MethodHandle intCompareHandle = MethodHandles.lookup().findStatic(IntComparator.class,\n- *                                                 \"intCompare\",\n- *                                                 intCompareDescriptor.toMethodType());\n- *}\n- *\n- * As before, we need to create a {@link java.lang.foreign.FunctionDescriptor} instance, this time describing the signature\n- * of the function pointer we want to create. The descriptor can be used to\n- * {@linkplain java.lang.foreign.FunctionDescriptor#toMethodType() derive} a method type\n- * that can be used to look up the method handle for {@code IntComparator.intCompare}.\n- * <p>\n- * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n- * using the {@link java.lang.foreign.Linker} interface, as follows:\n- *\n- * {@snippet lang = java:\n- * SegmentScope scope = ...\n- * MemorySegment comparFunc = Linker.nativeLinker().upcallStub(\n- *     intCompareHandle, intCompareDescriptor, scope);\n- * );\n- *}\n- *\n- * The {@link java.lang.foreign.FunctionDescriptor} instance created in the previous step is then used to\n- * {@linkplain java.lang.foreign.Linker#upcallStub(java.lang.invoke.MethodHandle, FunctionDescriptor, SegmentScope) create}\n- * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n- * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the ABI of the\n- * underlying platform.\n- * The lifecycle of the upcall stub is tied to the {@linkplain java.lang.foreign.SegmentScope scope}\n- * provided when the upcall stub is created. This same scope is made available by the {@link java.lang.foreign.MemorySegment}\n- * instance returned by that method.\n- *\n@@ -200,2 +119,3 @@\n- * the restricted method {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}\n- * can be used to create a fresh segment with the given spatial bounds out of a native address.\n+ * the restricted method {@link java.lang.foreign.MemorySegment#reinterpret(long)} ()}\n+ * can be used to create a fresh segment with the same address and temporal bounds,\n+ * but with the provided size. This can be useful to resize memory segments obtained when interacting with native functions.\n@@ -204,5 +124,5 @@\n- * or memory corruption when the bound Java API element is accessed. For instance, in the case of\n- * {@link java.lang.foreign.MemorySegment#ofAddress(long, long, SegmentScope)}, if the provided spatial bounds are\n- * incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n- * memory when attempting to access said segment. For these reasons, it is crucial for code that calls a restricted method\n- * to never pass arguments that might cause incorrect binding of foreign data and\/or functions to a Java API.\n+ * or memory corruption when the bound Java API element is accessed. For instance, incorrectly resizing a native\n+ * memory sgement using {@link java.lang.foreign.MemorySegment#reinterpret(long)} can lead to a JVM crash, or, worse,\n+ * lead to silent memory corruption when attempting to access the resized segment. For these reasons, it is crucial for\n+ * code that calls a restricted method to never pass arguments that might cause incorrect binding of foreign data and\/or\n+ * functions to a Java API.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":40,"deletions":120,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -818,1 +818,3 @@\n-                    return new DirectByteBuffer(address, cap, obj, unmapperProxy.fileDescriptor(), unmapperProxy.isSync(), segment);\n+                    return unmapperProxy == null\n+                            ? new DirectByteBuffer(address, cap, obj, segment)\n+                            : new DirectByteBuffer(address, cap, obj, unmapperProxy.fileDescriptor(), unmapperProxy.isSync(), segment);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.Arena;\n@@ -30,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -1003,1 +1003,1 @@\n-     * with the given offset, size and memory session.\n+     * with the given offset, size and arena.\n@@ -1007,1 +1007,5 @@\n-     *\n+     * <p>\n+     * The lifetime of the returned segment is controlled by the provided arena.\n+     * For instance, if the provided arena is a closeable arena,\n+     * the returned segment will be unmapped when the provided closeable arena\n+     * is {@linkplain Arena#close() closed}.\n@@ -1048,2 +1052,2 @@\n-     * @param   session\n-     *          The segment memory session.\n+     * @param   arena\n+     *          The segment arena.\n@@ -1058,2 +1062,1 @@\n-     *          If the {@code session} is not\n-     *          {@linkplain SegmentScope#isAlive() alive}.\n+     *          If {@code arena.isAlive() == false}.\n@@ -1062,3 +1065,2 @@\n-     *          If this method is called from a thread other than the thread\n-     *          {@linkplain SegmentScope#isAccessibleBy(Thread) owning} the\n-     *          {@code session}.\n+     *          If {@code arena} is a confined scoped arena, and this method is called from a\n+     *          thread {@code T}, other than the scoped arena's owner thread.\n@@ -1086,1 +1088,1 @@\n-    public MemorySegment map(MapMode mode, long offset, long size, SegmentScope session)\n+    public MemorySegment map(MapMode mode, long offset, long size, Arena arena)\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -50,0 +46,1 @@\n+\n@@ -55,0 +52,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -80,1 +79,1 @@\n-    final SegmentScope scope;\n+    final MemorySessionImpl scope;\n@@ -83,1 +82,1 @@\n-    AbstractMemorySegmentImpl(long length, boolean readOnly, SegmentScope scope) {\n+    AbstractMemorySegmentImpl(long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -89,1 +88,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope);\n@@ -115,0 +114,44 @@\n+    @Override\n+    public MemorySegment asSlice(long offset, long newSize, long byteAlignment) {\n+        checkBounds(offset, newSize);\n+        if (!isAlignedForElement(offset, byteAlignment)) {\n+            throw new IllegalArgumentException(\"Target offset incompatible with alignment constraints\");\n+        }\n+        return asSliceNoCheck(offset, newSize);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment reinterpret(long newSize, Arena arena, Consumer<MemorySegment> cleanup) {\n+        Objects.requireNonNull(arena);\n+        return reinterpretInternal(Reflection.getCallerClass(), newSize,\n+                MemorySessionImpl.toMemorySession(arena), null);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment reinterpret(long newSize) {\n+        return reinterpretInternal(Reflection.getCallerClass(), newSize, scope, null);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment reinterpret(Arena arena, Consumer<MemorySegment> cleanup) {\n+        Objects.requireNonNull(arena);\n+        return reinterpretInternal(Reflection.getCallerClass(), byteSize(),\n+                MemorySessionImpl.toMemorySession(arena), cleanup);\n+    }\n+\n+    public MemorySegment reinterpretInternal(Class<?> callerClass, long newSize, Scope scope, Consumer<MemorySegment> cleanup) {\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        if (newSize < 0) {\n+            throw new IllegalArgumentException(\"newSize < 0\");\n+        }\n+        if (!isNative()) throw new UnsupportedOperationException(\"Not a native segment\");\n+        Runnable action = cleanup != null ?\n+                () -> cleanup.accept(NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize)) :\n+                null;\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address(), newSize,\n+                (MemorySessionImpl)scope, action);\n+    }\n+\n@@ -151,1 +194,1 @@\n-        return asSlice(0, byteSize);\n+        return asSlice(0, byteSize, byteAlignment);\n@@ -328,1 +371,6 @@\n-        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (layout.byteAlignment() - 1)) == 0;\n+        return isAlignedForElement(offset, layout.byteAlignment());\n+    }\n+\n+    @ForceInline\n+    public final boolean isAlignedForElement(long offset, long byteAlignment) {\n+        return (((unsafeGetOffset() + offset) | maxAlignMask()) & (byteAlignment - 1)) == 0;\n@@ -361,1 +409,1 @@\n-    public SegmentScope scope() {\n+    public Scope scope() {\n@@ -365,0 +413,5 @@\n+    @Override\n+    public boolean isAccessibleBy(Thread thread) {\n+        return sessionImpl().isAccessibleBy(thread);\n+    }\n+\n@@ -367,1 +420,1 @@\n-        return (MemorySessionImpl)scope;\n+        return scope;\n@@ -453,1 +506,1 @@\n-        return \"MemorySegment{ array: \" + array() + \" address:\" + address() + \" limit: \" + length + \" }\";\n+        return \"MemorySegment{ heapBase: \" + heapBase() + \" address:\" + address() + \" limit: \" + length + \" }\";\n@@ -484,1 +537,3 @@\n-        final SegmentScope bufferScope;\n+        boolean readOnly = bb.isReadOnly();\n+        int scaleFactor = getScaleFactor(bb);\n+        final MemorySessionImpl bufferScope;\n@@ -490,2 +545,0 @@\n-        boolean readOnly = bb.isReadOnly();\n-        int scaleFactor = getScaleFactor(bb);\n@@ -494,1 +547,1 @@\n-                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfByte(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -496,1 +549,1 @@\n-                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfShort(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -498,1 +551,1 @@\n-                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfChar(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -500,1 +553,1 @@\n-                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfInt(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -502,1 +555,1 @@\n-                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfFloat(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -504,1 +557,1 @@\n-                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfLong(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n@@ -506,1 +559,1 @@\n-                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly);\n+                return new HeapMemorySegmentImpl.OfDouble(bbAddress + (pos << scaleFactor), base, size << scaleFactor, readOnly, bufferScope);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":76,"deletions":23,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n+import jdk.internal.vm.ForeignLinkerSupport;\n+\n@@ -37,1 +40,3 @@\n-    LINUX_RISCV_64;\n+    LINUX_RISCV_64,\n+    FALLBACK,\n+    UNSUPPORTED;\n@@ -39,4 +44,1 @@\n-    private static final CABI ABI;\n-    private static final String ARCH;\n-    private static final String OS;\n-    private static final long ADDRESS_SIZE;\n+    private static final CABI CURRENT = computeCurrent();\n@@ -44,27 +46,32 @@\n-    static {\n-        ARCH = privilegedGetProperty(\"os.arch\");\n-        OS = privilegedGetProperty(\"os.name\");\n-        ADDRESS_SIZE = ADDRESS.bitSize();\n-        \/\/ might be running in a 32-bit VM on a 64-bit platform.\n-        \/\/ addressSize will be correctly 32\n-        if ((ARCH.equals(\"amd64\") || ARCH.equals(\"x86_64\")) && ADDRESS_SIZE == 64) {\n-            if (OS.startsWith(\"Windows\")) {\n-                ABI = WIN_64;\n-            } else {\n-                ABI = SYS_V;\n-            }\n-        } else if (ARCH.equals(\"aarch64\")) {\n-            if (OS.startsWith(\"Mac\")) {\n-                ABI = MAC_OS_AARCH_64;\n-            } else if (OS.startsWith(\"Windows\")) {\n-                ABI = WIN_AARCH_64;\n-            } else {\n-                \/\/ The Linux ABI follows the standard AAPCS ABI\n-                ABI = LINUX_AARCH_64;\n-            }\n-        } else if (ARCH.equals(\"riscv64\")) {\n-            if (OS.startsWith(\"Linux\")) {\n-                ABI = LINUX_RISCV_64;\n-            } else {\n-                \/\/ unsupported\n-                ABI = null;\n+    private static CABI computeCurrent() {\n+        String abi = privilegedGetProperty(\"jdk.internal.foreign.CABI\");\n+        if (abi != null) {\n+            return CABI.valueOf(abi);\n+        }\n+\n+        if (ForeignLinkerSupport.isSupported()) {\n+            \/\/ figure out the ABI based on the platform\n+            String arch = privilegedGetProperty(\"os.arch\");\n+            String os = privilegedGetProperty(\"os.name\");\n+            long addressSize = ADDRESS.bitSize();\n+            \/\/ might be running in a 32-bit VM on a 64-bit platform.\n+            \/\/ addressSize will be correctly 32\n+            if ((arch.equals(\"amd64\") || arch.equals(\"x86_64\")) && addressSize == 64) {\n+                if (os.startsWith(\"Windows\")) {\n+                    return WIN_64;\n+                } else {\n+                    return SYS_V;\n+                }\n+            } else if (arch.equals(\"aarch64\")) {\n+                if (os.startsWith(\"Mac\")) {\n+                    return MAC_OS_AARCH_64;\n+                } else if (os.startsWith(\"Windows\")) {\n+                    return WIN_AARCH_64;\n+                } else {\n+                    \/\/ The Linux ABI follows the standard AAPCS ABI\n+                    return LINUX_AARCH_64;\n+                }\n+            } else if (arch.equals(\"riscv64\")) {\n+                if (os.startsWith(\"Linux\")) {\n+                    return LINUX_RISCV_64;\n+                }\n@@ -72,3 +79,2 @@\n-        } else {\n-            \/\/ unsupported\n-            ABI = null;\n+        } else if (FallbackLinker.isSupported()) {\n+            return FALLBACK; \/\/ fallback linker\n@@ -76,0 +82,2 @@\n+\n+        return UNSUPPORTED;\n@@ -79,5 +87,1 @@\n-        if (ABI == null) {\n-            throw new UnsupportedOperationException(\n-                    \"Unsupported os, arch, or address size: \" + OS + \", \" + ARCH + \", \" + ADDRESS_SIZE);\n-        }\n-        return ABI;\n+        return CURRENT;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":45,"deletions":41,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -49,1 +48,1 @@\n- * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, SegmentScope)}.\n+ * such as the elimination of store barriers in methods like {@link HeapMemorySegmentImpl#dup(long, long, boolean, MemorySessionImpl)}.\n@@ -65,2 +64,4 @@\n-    public Optional<Object> array() {\n-        return Optional.of(base);\n+    public Optional<Object> heapBase() {\n+        return readOnly ?\n+                Optional.empty() :\n+                Optional.of(base);\n@@ -70,2 +71,2 @@\n-    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly) {\n-        super(length, readOnly, SegmentScope.global());\n+    HeapMemorySegmentImpl(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+        super(length, readOnly, session);\n@@ -82,1 +83,1 @@\n-    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope);\n+    abstract HeapMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope);\n@@ -86,1 +87,1 @@\n-        if (!(base instanceof byte[])) {\n+        if (!(base instanceof byte[] baseByte)) {\n@@ -90,1 +91,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[])base, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n+        return nioAccess.newHeapByteBuffer(baseByte, (int)offset - BYTE_ARR_BASE, (int) byteSize(), null);\n@@ -97,2 +98,2 @@\n-        OfByte(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfByte(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -102,2 +103,2 @@\n-        OfByte dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfByte(this.offset + offset, base, size, readOnly);\n+        OfByte dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfByte(this.offset + offset, base, size, readOnly, scope);\n@@ -114,1 +115,2 @@\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -130,2 +132,2 @@\n-        OfChar(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfChar(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -135,2 +137,2 @@\n-        OfChar dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfChar(this.offset + offset, base, size, readOnly);\n+        OfChar dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfChar(this.offset + offset, base, size, readOnly, scope);\n@@ -147,1 +149,2 @@\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -163,2 +166,2 @@\n-        OfShort(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfShort(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -168,2 +171,2 @@\n-        OfShort dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfShort(this.offset + offset, base, size, readOnly);\n+        OfShort dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfShort(this.offset + offset, base, size, readOnly, scope);\n@@ -180,1 +183,2 @@\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -196,2 +200,2 @@\n-        OfInt(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfInt(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -201,2 +205,2 @@\n-        OfInt dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfInt(this.offset + offset, base, size, readOnly);\n+        OfInt dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfInt(this.offset + offset, base, size, readOnly, scope);\n@@ -213,1 +217,2 @@\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -229,2 +234,2 @@\n-        OfLong(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfLong(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -234,2 +239,2 @@\n-        OfLong dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfLong(this.offset + offset, base, size, readOnly);\n+        OfLong dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfLong(this.offset + offset, base, size, readOnly, scope);\n@@ -246,1 +251,2 @@\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -262,2 +268,2 @@\n-        OfFloat(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfFloat(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -267,2 +273,2 @@\n-        OfFloat dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfFloat(this.offset + offset, base, size, readOnly);\n+        OfFloat dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfFloat(this.offset + offset, base, size, readOnly, scope);\n@@ -279,1 +285,2 @@\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n@@ -295,2 +302,2 @@\n-        OfDouble(long offset, Object base, long length, boolean readOnly) {\n-            super(offset, base, length, readOnly);\n+        OfDouble(long offset, Object base, long length, boolean readOnly, MemorySessionImpl session) {\n+            super(offset, base, length, readOnly, session);\n@@ -300,2 +307,2 @@\n-        OfDouble dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n-            return new OfDouble(this.offset + offset, base, size, readOnly);\n+        OfDouble dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n+            return new OfDouble(this.offset + offset, base, size, readOnly, scope);\n@@ -312,1 +319,2 @@\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, false,\n+                    MemorySessionImpl.heapSession(arr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":53,"deletions":45,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -56,0 +57,1 @@\n+    private static final MethodHandle[] EMPTY_DEREF_HANDLES = new MethodHandle[0];\n@@ -59,0 +61,1 @@\n+    private static final MethodHandle MH_SEGMENT_RESIZE;\n@@ -67,0 +70,2 @@\n+            MH_SEGMENT_RESIZE = lookup.findStatic(LayoutPath.class, \"resizeSegment\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n@@ -78,0 +83,1 @@\n+    private final MethodHandle[] derefAdapters;\n@@ -79,1 +85,1 @@\n-    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath enclosing) {\n+    private LayoutPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, MethodHandle[] derefAdapters, LayoutPath enclosing) {\n@@ -84,0 +90,1 @@\n+        this.derefAdapters = derefAdapters;\n@@ -93,1 +100,1 @@\n-        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), this);\n+        return LayoutPath.nestedPath(elem, offset, addStride(elem.bitSize()), addBound(seq.elementCount()), derefAdapters, this);\n@@ -107,1 +114,1 @@\n-                                     addStride(elemSize * step), addBound(maxIndex), this);\n+                                     addStride(elemSize * step), addBound(maxIndex), derefAdapters, this);\n@@ -116,1 +123,1 @@\n-        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, this);\n+        return LayoutPath.nestedPath(seq.elementLayout(), offset + elemOffset, strides, bounds, derefAdapters,this);\n@@ -137,1 +144,35 @@\n-        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, this);\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, derefAdapters, this);\n+    }\n+\n+    public LayoutPath groupElement(long index) {\n+        check(GroupLayout.class, \"attempting to select a group element from a non-group layout\");\n+        GroupLayout g = (GroupLayout)layout;\n+        long elemSize = g.memberLayouts().size();\n+        long offset = 0;\n+        MemoryLayout elem = null;\n+        for (int i = 0; i <= index; i++) {\n+            if (i == elemSize) {\n+                throw badLayoutPath(\"cannot resolve element \" + index + \" in layout \" + layout);\n+            }\n+            elem = g.memberLayouts().get(i);\n+            if (g instanceof StructLayout && i < index) {\n+                offset += elem.bitSize();\n+            }\n+        }\n+        return LayoutPath.nestedPath(elem, this.offset + offset, strides, bounds, derefAdapters, this);\n+    }\n+\n+    public LayoutPath derefElement() {\n+        if (!(layout instanceof AddressLayout addressLayout) ||\n+                addressLayout.targetLayout().isEmpty()) {\n+            throw badLayoutPath(\"Cannot dereference layout: \" + layout);\n+        }\n+        MemoryLayout derefLayout = addressLayout.targetLayout().get();\n+        MethodHandle handle = dereferenceHandle(false).toMethodHandle(VarHandle.AccessMode.GET);\n+        handle = MethodHandles.filterReturnValue(handle,\n+                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        return derefPath(derefLayout, handle, this);\n+    }\n+\n+    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n+        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n@@ -147,0 +188,4 @@\n+        return dereferenceHandle(true);\n+    }\n+\n+    public VarHandle dereferenceHandle(boolean adapt) {\n@@ -155,1 +200,1 @@\n-                    Utils.bitsToBytesOrThrow(strides[i], IllegalArgumentException::new),\n+                    Utils.bitsToBytes(strides[i]),\n@@ -162,1 +207,7 @@\n-                Utils.bitsToBytesOrThrow(offset, IllegalArgumentException::new));\n+                Utils.bitsToBytes(offset));\n+\n+        if (adapt) {\n+            for (int i = derefAdapters.length; i > 0; i--) {\n+                handle = MethodHandles.collectCoordinates(handle, 0, derefAdapters[i - 1]);\n+            }\n+        }\n@@ -185,5 +236,0 @@\n-        if (strides.length == 0) {\n-            \/\/ trigger checks eagerly\n-            Utils.bitsToBytesOrThrow(offset, Utils.BITS_TO_BYTES_THROW_OFFSET);\n-        }\n-\n@@ -191,1 +237,1 @@\n-        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET); \/\/ byte offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.BITS_TO_BYTES); \/\/ byte offset\n@@ -207,1 +253,5 @@\n-        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, null);\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, EMPTY_DEREF_HANDLES, null);\n+    }\n+\n+    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, MethodHandle[] derefAdapters, LayoutPath encl) {\n+        return new LayoutPath(layout, offset, strides, bounds, derefAdapters, encl);\n@@ -210,2 +260,4 @@\n-    private static LayoutPath nestedPath(MemoryLayout layout, long offset, long[] strides, long[] bounds, LayoutPath encl) {\n-        return new LayoutPath(layout, offset, strides, bounds, encl);\n+    private static LayoutPath derefPath(MemoryLayout layout, MethodHandle handle, LayoutPath encl) {\n+        MethodHandle[] handles = Arrays.copyOf(encl.derefAdapters, encl.derefAdapters.length + 1);\n+        handles[encl.derefAdapters.length] = handle;\n+        return new LayoutPath(layout, 0L, EMPTY_STRIDES, EMPTY_BOUNDS, handles, null);\n@@ -274,1 +326,2 @@\n-            GROUP_ELEMENT(\"group element\");\n+            GROUP_ELEMENT(\"group element\"),\n+            DEREF_ELEMENT(\"dereference element\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":71,"deletions":18,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n@@ -40,1 +38,1 @@\n-public sealed class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n+public final class MappedMemorySegmentImpl extends NativeMemorySegmentImpl {\n@@ -46,1 +44,1 @@\n-    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, SegmentScope scope) {\n+    public MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -58,1 +56,1 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+    MappedMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n@@ -76,4 +74,0 @@\n-    public MemorySegment segment() {\n-        return MappedMemorySegmentImpl.this;\n-    }\n-\n@@ -81,1 +75,3 @@\n-        SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+        if (unmapper != null) {\n+            SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+        }\n@@ -85,1 +81,3 @@\n-        SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+        if (unmapper != null) {\n+            SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+        }\n@@ -89,1 +87,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n+        return unmapper == null || SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n@@ -93,27 +91,2 @@\n-        SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n-    }\n-\n-    public static final class EmptyMappedMemorySegmentImpl extends MappedMemorySegmentImpl {\n-\n-        public EmptyMappedMemorySegmentImpl(boolean readOnly, MemorySessionImpl session) {\n-            super(0, null, 0, readOnly, session);\n-        }\n-\n-        @Override\n-        public void load() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public void unload() {\n-            \/\/ do nothing\n-        }\n-\n-        @Override\n-        public boolean isLoaded() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void force() {\n-            \/\/ do nothing\n+        if (unmapper != null) {\n+            SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n@@ -122,0 +95,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":14,"deletions":40,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.Arena;\n@@ -31,2 +30,2 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -54,1 +53,1 @@\n-        implements SegmentScope, SegmentAllocator\n+        implements Scope\n@@ -83,1 +82,1 @@\n-            public SegmentScope scope() {\n+            public Scope scope() {\n@@ -91,7 +90,0 @@\n-\n-            @Override\n-            public boolean isCloseableBy(Thread thread) {\n-                Objects.requireNonNull(thread);\n-                return ownerThread() == null || \/\/ shared\n-                        ownerThread() == thread;\n-            }\n@@ -101,0 +93,11 @@\n+    @ForceInline\n+    public static final MemorySessionImpl toMemorySession(Arena arena) {\n+        return (MemorySessionImpl) arena.scope();\n+    }\n+\n+    public final boolean isCloseableBy(Thread thread) {\n+        Objects.requireNonNull(thread);\n+        return isCloseable() &&\n+                (owner == null || owner == thread);\n+    }\n+\n@@ -153,1 +156,0 @@\n-    @Override\n@@ -163,1 +165,0 @@\n-    @Override\n@@ -178,6 +179,0 @@\n-    public static boolean sameOwnerThread(SegmentScope scope1, SegmentScope scope2) {\n-        return ((MemorySessionImpl) scope1).ownerThread() ==\n-                ((MemorySessionImpl) scope2).ownerThread();\n-    }\n-\n-    @Override\n@@ -228,0 +223,4 @@\n+    public static final void checkValidState(MemorySegment segment) {\n+        ((AbstractMemorySegmentImpl)segment).sessionImpl().checkValidState();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -55,1 +54,1 @@\n-    NativeMemorySegmentImpl(long min, long length, boolean readOnly, SegmentScope scope) {\n+    NativeMemorySegmentImpl(long min, long length, boolean readOnly, MemorySessionImpl scope) {\n@@ -57,1 +56,16 @@\n-        this.min = min;\n+        this.min = (Unsafe.getUnsafe().addressSize() == 4)\n+                \/\/ On 32-bit systems, normalize the upper unused 32-bits to zero\n+                ? min & 0x0000_0000_FFFF_FFFFL\n+                \/\/ On 64-bit systems, all the bits are used\n+                : min;\n+    }\n+\n+    \/**\n+     * This constructor should only be used when initializing {@link MemorySegment#NULL}. Note: because of the memory\n+     * segment class hierarchy, it is possible to end up in a situation where this constructor is called\n+     * when the static fields in this class are not yet initialized.\n+     *\/\n+    @ForceInline\n+    public NativeMemorySegmentImpl() {\n+        super(0L, false, new GlobalSession(null));\n+        this.min = 0L;\n@@ -66,1 +80,1 @@\n-    public Optional<Object> array() {\n+    public Optional<Object> heapBase() {\n@@ -72,1 +86,1 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, SegmentScope scope) {\n+    NativeMemorySegmentImpl dup(long offset, long size, boolean readOnly, MemorySessionImpl scope) {\n@@ -104,2 +118,1 @@\n-    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, SegmentScope scope) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegment(long byteSize, long byteAlignment, MemorySessionImpl sessionImpl) {\n@@ -122,1 +135,1 @@\n-                false, scope);\n+                false, sessionImpl);\n@@ -141,2 +154,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n@@ -148,1 +160,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -152,2 +164,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, SegmentScope scope) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) scope;\n+    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl) {\n@@ -155,1 +166,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, scope);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n@@ -160,1 +171,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, SegmentScope.global());\n+        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import java.lang.foreign.ValueLayout;\n-\n-public final class PlatformLayouts {\n-\n-    private PlatformLayouts() {\n-        \/\/just the one\n-    }\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.\n-     *\/\n-    public static final class SysV {\n-        private SysV() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The {@code bool} native type.\n-         *\/\n-        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final ValueLayout.OfAddress C_VA_LIST = SysV.C_POINTER;\n-    }\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.\n-     *\/\n-    public static final class Win64 {\n-\n-        private Win64() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The {@code bool} native type.\n-         *\/\n-        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final ValueLayout.OfAddress C_VA_LIST = Win64.C_POINTER;\n-    }\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.\n-     *\/\n-    public static final class AArch64 {\n-\n-        private AArch64() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The {@code bool} native type.\n-         *\/\n-        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final ValueLayout.OfAddress C_VA_LIST = AArch64.C_POINTER;\n-    }\n-\n-    public static final class RISCV64 {\n-        private RISCV64() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The {@code bool} native type.\n-         *\/\n-        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n-\n-        \/**\n-         * The {@code va_list} native type, as it is passed to a function.\n-         *\/\n-        public static final ValueLayout.OfAddress C_VA_LIST = RISCV64.C_POINTER;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -46,1 +46,1 @@\n-        MemorySegment slice = segment.asSlice(start, byteSize);\n+        MemorySegment slice = segment.asSlice(start, byteSize, byteAlignment);\n@@ -53,1 +53,1 @@\n-        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment, maxAlign);\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SlicingAllocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.*;\n@@ -50,1 +48,4 @@\n-    private static final SymbolLookup FALLBACK_LOOKUP = name -> Optional.empty();\n+    private static final SymbolLookup FALLBACK_LOOKUP = name -> {\n+        Objects.requireNonNull(name);\n+        return Optional.empty();\n+    };\n@@ -60,4 +61,5 @@\n-            return switch (CABI.current()) {\n-                case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_RISCV_64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n-                case WIN_64, WIN_AARCH_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n-            };\n+            if (Utils.IS_WINDOWS) {\n+                return makeWindowsLookup();\n+            } else {\n+                return libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+            }\n@@ -87,3 +89,2 @@\n-            int numSymbols = WindowsFallbackSymbols.values().length;\n-            MemorySegment funcs = MemorySegment.ofAddress(fallbackLibLookup.find(\"funcs\").orElseThrow().address(),\n-                ADDRESS.byteSize() * numSymbols, SegmentScope.global());\n+            MemorySegment funcs = fallbackLibLookup.find(\"funcs\").orElseThrow()\n+                    .reinterpret(WindowsFallbackSymbols.LAYOUT.byteSize());\n@@ -92,1 +93,1 @@\n-                .map(symbol -> MemorySegment.ofAddress(funcs.getAtIndex(ADDRESS, symbol.ordinal()).address(), 0L, SegmentScope.global()));\n+                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n@@ -95,1 +96,4 @@\n-            lookup = name -> finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            lookup = name -> {\n+                Objects.requireNonNull(name);\n+                return finalLookup.find(name).or(() -> fallbackLookup.apply(name));\n+            };\n@@ -109,1 +113,1 @@\n-                        Optional.of(MemorySegment.ofAddress(addr, 0, SegmentScope.global()));\n+                        Optional.of(MemorySegment.ofAddress(addr));\n@@ -121,4 +125,1 @@\n-        String lib = switch (CABI.current()) {\n-            case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_RISCV_64 -> \"lib\";\n-            case WIN_64, WIN_AARCH_64 -> \"bin\";\n-        };\n+        String lib = Utils.IS_WINDOWS ? \"bin\" : \"lib\";\n@@ -205,0 +206,3 @@\n+\n+        static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(\n+                values().length, ADDRESS);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -42,1 +43,1 @@\n-import java.util.function.Supplier;\n+\n@@ -49,0 +50,1 @@\n+import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -54,0 +56,6 @@\n+\n+    public static final boolean IS_WINDOWS = privilegedGetProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private Utils() {}\n+\n@@ -57,6 +65,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS_SAFE;\n-    private static final MethodHandle LONG_TO_ADDRESS_UNSAFE;\n-    public static final MethodHandle MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET;\n-\n-    public static final Supplier<RuntimeException> BITS_TO_BYTES_THROW_OFFSET\n-            = () -> new UnsupportedOperationException(\"Cannot compute byte offset; bit offset is not a multiple of 8\");\n+    private static final MethodHandle LONG_TO_ADDRESS;\n+    public static final MethodHandle BITS_TO_BYTES;\n@@ -73,9 +77,4 @@\n-            LONG_TO_ADDRESS_SAFE = lookup.findStatic(Utils.class, \"longToAddressSafe\",\n-                    MethodType.methodType(MemorySegment.class, long.class));\n-            LONG_TO_ADDRESS_UNSAFE = lookup.findStatic(Utils.class, \"longToAddressUnsafe\",\n-                    MethodType.methodType(MemorySegment.class, long.class));\n-            MH_BITS_TO_BYTES_OR_THROW_FOR_OFFSET = MethodHandles.insertArguments(\n-                    lookup.findStatic(Utils.class, \"bitsToBytesOrThrow\",\n-                            MethodType.methodType(long.class, long.class, Supplier.class)),\n-                    1,\n-                    BITS_TO_BYTES_THROW_OFFSET);\n+            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            BITS_TO_BYTES = lookup.findStatic(Utils.class, \"bitsToBytes\",\n+                    MethodType.methodType(long.class, long.class));\n@@ -96,6 +95,3 @@\n-    public static long bitsToBytesOrThrow(long bits, Supplier<RuntimeException> exFactory) {\n-        if (Utils.isAligned(bits, 8)) {\n-            return bits \/ 8;\n-        } else {\n-            throw exFactory.get();\n-        }\n+    public static long bitsToBytes(long bits) {\n+        assert Utils.isAligned(bits, 8);\n+        return bits \/ Byte.SIZE;\n@@ -105,2 +101,2 @@\n-        class VarHandleCache {\n-            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n+        final class VarHandleCache {\n+            private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n@@ -109,1 +105,1 @@\n-                VarHandle prev = handleMap.putIfAbsent(layout, handle);\n+                VarHandle prev = HANDLE_MAP.putIfAbsent(layout, handle);\n@@ -116,2 +112,2 @@\n-                case 8 -> long.class;\n-                case 4 -> int.class;\n+                case Long.BYTES -> long.class;\n+                case Integer.BYTES -> int.class;\n@@ -129,1 +125,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress addressLayout) {\n+        } else if (layout instanceof AddressLayout addressLayout) {\n@@ -131,3 +127,3 @@\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(addressLayout.isUnbounded() ?\n-                            LONG_TO_ADDRESS_UNSAFE : LONG_TO_ADDRESS_SAFE, MethodType.methodType(MemorySegment.class, baseCarrier)));\n+                    ADDRESS_TO_LONG,\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n+                            pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)));\n@@ -147,2 +143,5 @@\n-    private static MemorySegment longToAddressSafe(long addr) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, 0);\n+    public static MemorySegment longToAddress(long addr, long size, long align) {\n+        if (!isAligned(addr, align)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size);\n@@ -152,2 +151,5 @@\n-    private static MemorySegment longToAddressUnsafe(long addr) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, Long.MAX_VALUE);\n+    public static MemorySegment longToAddress(long addr, long size, long align, MemorySessionImpl scope) {\n+        if (!isAligned(addr, align)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint for address: \" + addr);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(addr, size, scope);\n@@ -175,1 +177,1 @@\n-        if (layout.bitAlignment() > layout.bitSize()) {\n+        if (layout.byteAlignment() > layout.byteSize()) {\n@@ -180,6 +182,4 @@\n-    public static long pointeeSize(MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfAddress addressLayout) {\n-            return addressLayout.isUnbounded() ? Long.MAX_VALUE : 0L;\n-        } else {\n-            throw new UnsupportedOperationException();\n-        }\n+    public static long pointeeByteSize(AddressLayout addressLayout) {\n+        return addressLayout.targetLayout()\n+                .map(MemoryLayout::byteSize)\n+                .orElse(0L);\n@@ -188,5 +188,4 @@\n-    public static void checkAllocationSizeAndAlign(long byteSize, long byteAlignment, long maxAlignment) {\n-        checkAllocationSizeAndAlign(byteSize, byteAlignment);\n-        if (maxAlignment != 0 && byteAlignment > maxAlignment) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + byteAlignment + \" > \" + maxAlignment);\n-        }\n+    public static long pointeeByteAlign(AddressLayout addressLayout) {\n+        return addressLayout.targetLayout()\n+                .map(MemoryLayout::byteAlignment)\n+                .orElse(1L);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":47,"deletions":48,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -38,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -49,1 +50,2 @@\n-                                                                      Windowsx64Linker, LinuxRISCV64Linker {\n+                                                                      Windowsx64Linker, LinuxRISCV64Linker,\n+                                                                      FallbackLinker {\n@@ -52,1 +54,1 @@\n-        MemorySegment makeStub(MethodHandle target, SegmentScope arena);\n+        MemorySegment makeStub(MethodHandle target, Arena arena);\n@@ -57,1 +59,1 @@\n-    private final SoftReferenceCache<FunctionDescriptor, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n+    private final SoftReferenceCache<LinkRequest, UpcallStubFactory> UPCALL_CACHE = new SoftReferenceCache<>();\n@@ -77,2 +79,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, SegmentScope scope) {\n-        Objects.requireNonNull(scope);\n+    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, Arena arena, Linker.Option... options) {\n+        Objects.requireNonNull(arena);\n@@ -83,0 +85,1 @@\n+        LinkerOptions optionSet = LinkerOptions.forUpcall(function, options);\n@@ -89,2 +92,3 @@\n-        UpcallStubFactory factory = UPCALL_CACHE.get(function, f -> arrangeUpcall(type, f));\n-        return factory.makeStub(target, scope);\n+        UpcallStubFactory factory = UPCALL_CACHE.get(new LinkRequest(function, optionSet), linkRequest ->\n+            arrangeUpcall(type, linkRequest.descriptor(), linkRequest.options()));\n+        return factory.makeStub(target, arena);\n@@ -93,1 +97,1 @@\n-    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function);\n+    protected abstract UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -29,0 +28,2 @@\n+import jdk.internal.foreign.abi.BindingInterpreter.LoadFunc;\n+import jdk.internal.foreign.abi.BindingInterpreter.StoreFunc;\n@@ -30,5 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -202,93 +199,0 @@\n-    \/**\n-     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n-     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n-     * the allocation operation, or {@link BoxAddress} bindings, by providing the {@link SegmentScope} that\n-     * should be used to create an unsafe struct from a memory address.\n-     *\/\n-    class Context implements AutoCloseable {\n-        private final SegmentAllocator allocator;\n-        private final SegmentScope scope;\n-\n-        private Context(SegmentAllocator allocator, SegmentScope scope) {\n-            this.allocator = allocator;\n-            this.scope = scope;\n-        }\n-\n-        public SegmentAllocator allocator() {\n-            return allocator;\n-        }\n-\n-        public SegmentScope scope() {\n-            return scope;\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        \/**\n-         * Create a binding context from given native scope.\n-         *\/\n-        public static Context ofBoundedAllocator(long size) {\n-            Arena arena = Arena.openConfined();\n-            return new Context(SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, arena.scope())), arena.scope()) {\n-                @Override\n-                public void close() {\n-                    arena.close();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Create a binding context from given segment allocator. The resulting context will throw when\n-         * the context's scope is accessed.\n-         *\/\n-        public static Context ofAllocator(SegmentAllocator allocator) {\n-            return new Context(allocator, null) {\n-                @Override\n-                public SegmentScope scope() {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Create a binding context from given scope. The resulting context will throw when\n-         * the context's allocator is accessed.\n-         *\/\n-        public static Context ofScope() {\n-            Arena arena = Arena.openConfined();\n-            return new Context(null, arena.scope()) {\n-                @Override\n-                public SegmentAllocator allocator() { throw new UnsupportedOperationException(); }\n-\n-                @Override\n-                public void close() {\n-                    arena.close();\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n-         * an idempotent {@link #close()}.\n-         *\/\n-        public static final Context DUMMY = new Context(null, null) {\n-            @Override\n-            public SegmentAllocator allocator() {\n-                return SharedUtils.THROWING_ALLOCATOR;\n-            }\n-\n-            @Override\n-            public SegmentScope scope() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void close() {\n-                \/\/ do nothing\n-            }\n-        };\n-    }\n-\n@@ -297,2 +201,2 @@\n-    void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                   BindingInterpreter.LoadFunc loadFunc, Context context);\n+    void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                   LoadFunc loadFunc, SegmentAllocator allocator);\n@@ -355,2 +259,2 @@\n-    static BoxAddress boxAddressRaw(long size) {\n-        return new BoxAddress(size, false);\n+    static BoxAddress boxAddressRaw(long size, long align) {\n+        return new BoxAddress(size, align, false);\n@@ -360,1 +264,1 @@\n-        return new BoxAddress(layout.byteSize(), true);\n+        return new BoxAddress(layout.byteSize(), layout.byteAlignment(), true);\n@@ -364,1 +268,1 @@\n-        return new BoxAddress(byteSize, true);\n+        return new BoxAddress(byteSize, 1, true);\n@@ -466,2 +370,2 @@\n-        public Binding.Builder boxAddressRaw(long size) {\n-            bindings.add(Binding.boxAddressRaw(size));\n+        public Binding.Builder boxAddressRaw(long size, long align) {\n+            bindings.add(Binding.boxAddressRaw(size, align));\n@@ -511,2 +415,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -530,2 +434,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -558,2 +462,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -615,2 +519,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -660,2 +564,2 @@\n-        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment)\n+        private static MemorySegment copyBuffer(MemorySegment operand, long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment)\n@@ -673,2 +577,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -676,1 +580,1 @@\n-            MemorySegment copy = copyBuffer(operand, size, alignment, context);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n@@ -686,2 +590,2 @@\n-        private static MemorySegment allocateBuffer(long size, long alignment, Context context) {\n-            return context.allocator().allocate(size, alignment);\n+        private static MemorySegment allocateBuffer(long size, long alignment, SegmentAllocator allocator) {\n+            return allocator.allocate(size, alignment);\n@@ -696,3 +600,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(allocateBuffer(size, alignment, context));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(allocateBuffer(size, alignment, allocator));\n@@ -718,3 +622,3 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment)stack.pop()).address());\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            stack.push(SharedUtils.unboxSegment((MemorySegment)stack.pop()));\n@@ -729,1 +633,1 @@\n-    record BoxAddress(long size, boolean needsScope) implements Binding {\n+    record BoxAddress(long size, long align, boolean needsScope) implements Binding {\n@@ -739,5 +643,7 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            SegmentScope scope = needsScope ?\n-                    context.scope() : SegmentScope.global();\n-            stack.push(NativeMemorySegmentImpl.makeNativeSegmentUnchecked((long) stack.pop(), size, scope));\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n+            MemorySegment segment = Utils.longToAddress((long) stack.pop(), size, align);\n+            if (needsScope) {\n+                segment = segment.reinterpret((Arena) allocator, null);\n+            }\n+            stack.push(segment);\n@@ -761,2 +667,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -776,2 +682,2 @@\n-            public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                                  BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                                  LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -816,2 +722,2 @@\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+        public void interpret(Deque<Object> stack, StoreFunc storeFunc,\n+                              LoadFunc loadFunc, SegmentAllocator allocator) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":46,"deletions":140,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -33,1 +34,1 @@\n-    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, Binding.Context context) {\n+    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, SegmentAllocator allocator) {\n@@ -38,1 +39,1 @@\n-            b.interpret(stack, storeFunc, null, context);\n+            b.interpret(stack, storeFunc, null, allocator);\n@@ -42,1 +43,1 @@\n-    static Object box(List<Binding> bindings, LoadFunc loadFunc, Binding.Context context) {\n+    static Object box(List<Binding> bindings, LoadFunc loadFunc, SegmentAllocator allocator) {\n@@ -45,1 +46,1 @@\n-            b.interpret(stack, null, loadFunc, context);\n+            b.interpret(stack, null, loadFunc, allocator);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -57,6 +56,1 @@\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -91,5 +85,4 @@\n-    private static final String BINDING_CONTEXT_DESC = Binding.Context.class.descriptorString();\n-    private static final String OF_BOUNDED_ALLOCATOR_DESC = methodType(Binding.Context.class, long.class).descriptorString();\n-    private static final String OF_SCOPE_DESC = methodType(Binding.Context.class).descriptorString();\n-    private static final String ALLOCATOR_DESC = methodType(SegmentAllocator.class).descriptorString();\n-    private static final String SCOPE_DESC = methodType(SegmentScope.class).descriptorString();\n+    private static final String ARENA_DESC = Arena.class.descriptorString();\n+    private static final String NEW_BOUNDED_ARENA_DESC = methodType(Arena.class, long.class).descriptorString();\n+    private static final String NEW_EMPTY_ARENA_DESC = methodType(Arena.class).descriptorString();\n+    private static final String SCOPE_DESC = methodType(MemorySegment.Scope.class).descriptorString();\n@@ -100,2 +93,2 @@\n-    private static final String OF_LONG_DESC = methodType(MemorySegment.class, long.class, long.class).descriptorString();\n-    private static final String OF_LONG_UNCHECKED_DESC = methodType(MemorySegment.class, long.class, long.class, SegmentScope.class).descriptorString();\n+    private static final String LONG_TO_ADDRESS_NO_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class).descriptorString();\n+    private static final String LONG_TO_ADDRESS_SCOPE_DESC = methodType(MemorySegment.class, long.class, long.class, long.class, MemorySessionImpl.class).descriptorString();\n@@ -168,1 +161,2 @@\n-            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup().defineHiddenClassWithClassData(bytes, leafHandle, false);\n+            MethodHandles.Lookup definedClassLookup = MethodHandles.lookup()\n+                    .defineHiddenClassWithClassData(bytes, leafHandle, false);\n@@ -297,1 +291,1 @@\n-            emitInvokeStatic(Binding.Context.class, \"ofBoundedAllocator\", OF_BOUNDED_ALLOCATOR_DESC);\n+            emitInvokeStatic(SharedUtils.class, \"newBoundedArena\", NEW_BOUNDED_ARENA_DESC);\n@@ -299,1 +293,1 @@\n-            emitInvokeStatic(Binding.Context.class, \"ofScope\", OF_SCOPE_DESC);\n+            emitInvokeStatic(SharedUtils.class, \"newEmptyArena\", NEW_EMPTY_ARENA_DESC);\n@@ -301,1 +295,1 @@\n-            emitGetStatic(Binding.Context.class, \"DUMMY\", BINDING_CONTEXT_DESC);\n+            emitGetStatic(SharedUtils.class, \"DUMMY_ARENA\", ARENA_DESC);\n@@ -425,7 +419,7 @@\n-           emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n-           if (callerMethodType.returnType() != void.class) {\n-               emitConstZero(callerMethodType.returnType());\n-               emitReturn(callerMethodType.returnType());\n-           } else {\n-               mv.visitInsn(RETURN);\n-           }\n+            emitInvokeStatic(SharedUtils.class, \"handleUncaughtException\", HANDLE_UNCAUGHT_EXCEPTION_DESC);\n+            if (callerMethodType.returnType() != void.class) {\n+                emitConstZero(callerMethodType.returnType());\n+                emitReturn(callerMethodType.returnType());\n+            } else {\n+                mv.visitInsn(RETURN);\n+            }\n@@ -457,1 +451,1 @@\n-        return paramLayout instanceof ValueLayout.OfAddress;\n+        return paramLayout instanceof AddressLayout;\n@@ -566,1 +560,3 @@\n-        emitInvokeVirtual(Binding.Context.class, \"scope\", SCOPE_DESC);\n+        emitCheckCast(Arena.class);\n+        emitInvokeInterface(Arena.class, \"scope\", SCOPE_DESC);\n+        emitCheckCast(MemorySessionImpl.class);\n@@ -572,1 +568,0 @@\n-        emitInvokeVirtual(Binding.Context.class, \"allocator\", ALLOCATOR_DESC);\n@@ -578,1 +573,2 @@\n-        emitInvokeVirtual(Binding.Context.class, \"close\", CLOSE_DESC);\n+        emitCheckCast(Arena.class);\n+        emitInvokeInterface(Arena.class, \"close\", CLOSE_DESC);\n@@ -584,0 +580,1 @@\n+        emitConst(boxAddress.align());\n@@ -586,1 +583,1 @@\n-            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_UNCHECKED_DESC);\n+            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_SCOPE_DESC);\n@@ -588,1 +585,1 @@\n-            emitInvokeStatic(NativeMemorySegmentImpl.class, \"makeNativeSegmentUnchecked\", OF_LONG_DESC);\n+            emitInvokeStatic(Utils.class, \"longToAddress\", LONG_TO_ADDRESS_NO_SCOPE_DESC);\n@@ -937,1 +934,1 @@\n-            return ValueLayout.OfAddress.class;\n+            return AddressLayout.class;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+    public boolean needsTransition() {\n+        return !linkerOptions.isTrivial();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n@@ -32,0 +36,1 @@\n+import static sun.security.action.GetPropertyAction.privilegedGetProperty;\n@@ -34,3 +39,6 @@\n-    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0),\n-    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1),\n-    ERRNO             (\"errno\",           JAVA_INT, 1 << 2);\n+    GET_LAST_ERROR    (\"GetLastError\",    JAVA_INT, 1 << 0, Utils.IS_WINDOWS),\n+    WSA_GET_LAST_ERROR(\"WSAGetLastError\", JAVA_INT, 1 << 1, Utils.IS_WINDOWS),\n+    ERRNO             (\"errno\",           JAVA_INT, 1 << 2, true);\n+\n+    public static final StructLayout LAYOUT = MemoryLayout.structLayout(\n+        supportedStates().map(CapturableState::layout).toArray(MemoryLayout[]::new));\n@@ -41,0 +49,1 @@\n+    private final boolean isSupported;\n@@ -42,1 +51,1 @@\n-    CapturableState(String stateName, ValueLayout layout, int mask) {\n+    CapturableState(String stateName, ValueLayout layout, int mask, boolean isSupported) {\n@@ -46,0 +55,5 @@\n+        this.isSupported = isSupported;\n+    }\n+\n+    private static Stream<CapturableState> supportedStates() {\n+        return Stream.of(values()).filter(CapturableState::isSupported);\n@@ -51,0 +65,1 @@\n+                .filter(CapturableState::isSupported)\n@@ -54,1 +69,1 @@\n-                            + Stream.of(CapturableState.values())\n+                            + supportedStates()\n@@ -70,0 +85,4 @@\n+\n+    public boolean isSupported() {\n+        return isSupported;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -53,1 +54,0 @@\n-    private static final MethodHandle MH_CHECK_SYMBOL;\n@@ -61,2 +61,0 @@\n-            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n-                    methodType(void.class, MemorySegment.class));\n@@ -89,1 +87,2 @@\n-            callingSequence.capturedStateMask()\n+            callingSequence.capturedStateMask(),\n+            callingSequence.needsTransition()\n@@ -114,1 +113,1 @@\n-        handle = foldArguments(handle, 1, MH_CHECK_SYMBOL);\n+        handle = foldArguments(handle, 1, SharedUtils.MH_CHECK_SYMBOL);\n@@ -153,4 +152,4 @@\n-        Binding.Context unboxContext = callingSequence.allocationSize() != 0\n-                ? Binding.Context.ofBoundedAllocator(callingSequence.allocationSize())\n-                : Binding.Context.DUMMY;\n-        try (unboxContext) {\n+        Arena unboxArena = callingSequence.allocationSize() != 0\n+                ? SharedUtils.newBoundedArena(callingSequence.allocationSize())\n+                : SharedUtils.DUMMY_ARENA;\n+        try (unboxArena) {\n@@ -164,1 +163,1 @@\n-                returnBuffer = unboxContext.allocator().allocate(callingSequence.returnBufferSize());\n+                returnBuffer = unboxArena.allocate(callingSequence.returnBufferSize());\n@@ -172,1 +171,1 @@\n-                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxContext);\n+                        (storage, type, value) -> leafArgs[invData.argIndexMap.get(storage)] = value, unboxArena);\n@@ -193,1 +192,1 @@\n-                        }, Binding.Context.ofAllocator(allocator));\n+                        }, allocator);\n@@ -196,1 +195,1 @@\n-                        Binding.Context.ofAllocator(allocator));\n+                        allocator);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,3 +29,0 @@\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.util.Comparator;\n@@ -36,0 +33,1 @@\n+import java.util.function.BiConsumer;\n@@ -48,1 +46,10 @@\n-        Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n+        return forShared(LinkerOptionImpl::validateForDowncall, desc, options);\n+    }\n+\n+    public static LinkerOptions forUpcall(FunctionDescriptor desc, Linker.Option[] options) {\n+        return forShared(LinkerOptionImpl::validateForUpcall, desc, options);\n+    }\n+\n+    private static LinkerOptions forShared(BiConsumer<LinkerOptionImpl, FunctionDescriptor> validator,\n+                                           FunctionDescriptor desc, Linker.Option... options) {\n+       Map<Class<?>, LinkerOptionImpl> optionMap = new HashMap<>();\n@@ -55,1 +62,1 @@\n-            opImpl.validateForDowncall(desc);\n+            validator.accept(opImpl, desc);\n@@ -76,1 +83,1 @@\n-        return getOption(CaptureCallStateImpl.class) != null;\n+        return getOption(CaptureCallState.class) != null;\n@@ -80,1 +87,1 @@\n-        CaptureCallStateImpl stl = getOption(CaptureCallStateImpl.class);\n+        CaptureCallState stl = getOption(CaptureCallState.class);\n@@ -89,0 +96,5 @@\n+    public boolean isTrivial() {\n+        IsTrivial it = getOption(IsTrivial.class);\n+        return it != null;\n+    }\n+\n@@ -102,2 +114,1 @@\n-                                             permits FirstVariadicArg,\n-                                                     CaptureCallStateImpl {\n+            permits CaptureCallState, FirstVariadicArg, IsTrivial {\n@@ -107,0 +118,4 @@\n+\n+        default void validateForUpcall(FunctionDescriptor descriptor) {\n+            throw new IllegalArgumentException(\"Not supported for upcall: \" + this);\n+        }\n@@ -118,2 +133,1 @@\n-    public record CaptureCallStateImpl(Set<CapturableState> saved) implements LinkerOptionImpl, Linker.Option.CaptureCallState {\n-\n+    public record CaptureCallState(Set<CapturableState> saved) implements LinkerOptionImpl {\n@@ -124,0 +138,4 @@\n+    }\n+\n+    public record IsTrivial() implements LinkerOptionImpl {\n+        public static IsTrivial INSTANCE = new IsTrivial();\n@@ -126,7 +144,2 @@\n-        public StructLayout layout() {\n-            return MemoryLayout.structLayout(\n-                saved.stream()\n-                      .sorted(Comparator.comparingInt(CapturableState::ordinal))\n-                      .map(CapturableState::layout)\n-                      .toArray(MemoryLayout[]::new)\n-            );\n+        public void validateForDowncall(FunctionDescriptor descriptor) {\n+            \/\/ always allowed\n@@ -135,1 +148,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":31,"deletions":19,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-                            boolean needsReturnBuffer, int capturedStateMask) {}\n+                            boolean needsReturnBuffer, int capturedStateMask,\n+                            boolean needsTransition) {}\n@@ -61,1 +62,2 @@\n-                                        int capturedStateMask) {\n+                                        int capturedStateMask,\n+                                        boolean needsTransition) {\n@@ -67,1 +69,2 @@\n-        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves), needsReturnBuffer, capturedStateMask);\n+        CacheKey key = new CacheKey(methodType, abi, Arrays.asList(argMoves), Arrays.asList(returnMoves),\n+                                    needsReturnBuffer, capturedStateMask, needsTransition);\n@@ -69,1 +72,2 @@\n-            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer, capturedStateMask);\n+            long downcallStub = makeDowncallStub(methodType, abi, argMoves, returnMoves, needsReturnBuffer,\n+                                                 capturedStateMask, needsTransition);\n@@ -90,1 +94,2 @@\n-                                                int capturedStateMask);\n+                                                int capturedStateMask,\n+                                                boolean needsTransition);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.fallback.FallbackLinker;\n@@ -40,0 +41,2 @@\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n@@ -45,1 +48,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -47,1 +50,0 @@\n-import java.lang.foreign.VaList;\n@@ -58,1 +60,0 @@\n-import java.util.NoSuchElementException;\n@@ -60,1 +61,0 @@\n-import java.util.function.Consumer;\n@@ -79,0 +79,22 @@\n+    public static final MethodHandle MH_CHECK_SYMBOL;\n+\n+    public static final AddressLayout C_POINTER = ADDRESS\n+            .withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(JAVA_BYTE));\n+\n+    public static final Arena DUMMY_ARENA = new Arena() {\n+        @Override\n+        public Scope scope() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long byteSize) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/ do nothing\n+        }\n+    };\n@@ -89,0 +111,2 @@\n+            MH_CHECK_SYMBOL = lookup.findStatic(SharedUtils.class, \"checkSymbol\",\n+                    methodType(void.class, MemorySegment.class));\n@@ -217,0 +241,2 @@\n+            case FALLBACK -> FallbackLinker.getInstance();\n+            case UNSUPPORTED -> throw new UnsupportedOperationException(\"Platform does not support native linker\");\n@@ -268,1 +294,1 @@\n-    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+    public static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n@@ -286,1 +312,1 @@\n-    static void handleUncaughtException(Throwable t) {\n+    public static void handleUncaughtException(Throwable t) {\n@@ -288,2 +314,6 @@\n-            t.printStackTrace();\n-            JLA.exit(1);\n+            try {\n+                t.printStackTrace();\n+                System.err.println(\"Unrecoverable uncaught exception encountered. The VM will now exit\");\n+            } finally {\n+                JLA.exit(1);\n+            }\n@@ -322,33 +352,0 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaList(actions, scope);\n-            case SYS_V -> SysVx64Linker.newVaList(actions, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaList(actions, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaList(actions, scope);\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.newVaList(actions, scope);\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaList(actions, scope);\n-        };\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.newVaListOfAddress(address, scope);\n-            case SYS_V -> SysVx64Linker.newVaListOfAddress(address, scope);\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.newVaListOfAddress(address, scope);\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.newVaListOfAddress(address, scope);\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.newVaListOfAddress(address, scope);\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaListOfAddress(address, scope);\n-        };\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return switch (CABI.current()) {\n-            case WIN_64 -> Windowsx64Linker.emptyVaList();\n-            case SYS_V -> SysVx64Linker.emptyVaList();\n-            case LINUX_AARCH_64 -> LinuxAArch64Linker.emptyVaList();\n-            case MAC_OS_AARCH_64 -> MacOsAArch64Linker.emptyVaList();\n-            case LINUX_RISCV_64 -> LinuxRISCV64Linker.emptyVaList();\n-            case WIN_AARCH_64 -> WindowsAArch64Linker.emptyVaList();\n-        };\n-    }\n-\n@@ -372,2 +369,41 @@\n-    public static NoSuchElementException newVaListNSEE(MemoryLayout layout) {\n-        return new NoSuchElementException(\"No such element: \" + layout);\n+    public static Arena newBoundedArena(long size) {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicingAllocator = SegmentAllocator.slicingAllocator(arena.allocate(size));\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n+\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicingAllocator.allocate(byteSize, byteAlignment);\n+            }\n+        };\n+    }\n+\n+    public static Arena newEmptyArena() {\n+        return new Arena() {\n+            final Arena arena = Arena.ofConfined();\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            @Override\n+            public void close() {\n+                arena.close();\n+            }\n+\n+            @Override\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n@@ -390,53 +426,0 @@\n-    public static final class EmptyVaList implements VaList {\n-\n-        private final MemorySegment address;\n-\n-        public EmptyVaList(MemorySegment address) {\n-            this.address = address;\n-        }\n-\n-        private static UnsupportedOperationException uoe() {\n-            return new UnsupportedOperationException(\"Empty VaList\");\n-        }\n-\n-        @Override\n-        public int nextVarg(ValueLayout.OfInt layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long nextVarg(ValueLayout.OfLong layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public double nextVarg(ValueLayout.OfDouble layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public void skip(MemoryLayout... layouts) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public VaList copy() {\n-            return this;\n-        }\n-\n-        @Override\n-        public MemorySegment segment() {\n-            return address;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":79,"deletions":96,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -144,3 +144,3 @@\n-        Binding.Context allocator = invData.callingSequence.allocationSize() != 0\n-                ? Binding.Context.ofBoundedAllocator(invData.callingSequence.allocationSize())\n-                : Binding.Context.ofScope();\n+        Arena allocator = invData.callingSequence.allocationSize() != 0\n+                ? SharedUtils.newBoundedArena(invData.callingSequence.allocationSize())\n+                : SharedUtils.newEmptyArena();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallLinker.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -53,2 +53,2 @@\n-    static MemorySegment makeUpcall(long entry, SegmentScope scope) {\n-        ((MemorySessionImpl) scope).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n+    static MemorySegment makeUpcall(long entry, Arena arena) {\n+        MemorySessionImpl.toMemorySession(arena).addOrCleanupIfFail(new MemorySessionImpl.ResourceList.ResourceCleanup() {\n@@ -60,1 +60,1 @@\n-        return MemorySegment.ofAddress(entry, 0, scope);\n+        return MemorySegment.ofAddress(entry).reinterpret(arena, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-public class AArch64Architecture implements Architecture {\n+public final class AArch64Architecture implements Architecture {\n@@ -42,0 +42,3 @@\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private AArch64Architecture() {}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -47,1 +48,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -54,1 +54,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -85,1 +84,1 @@\n-    \/\/ r2-7 and v4-7 so they are omitted here.\n+    \/\/ r2-7 and v4-7 so, they are omitted here.\n@@ -161,1 +160,1 @@\n-            csb.addArgumentBindings(MemorySegment.class, AArch64.C_POINTER,\n+            csb.addArgumentBindings(MemorySegment.class, SharedUtils.C_POINTER,\n@@ -193,2 +192,3 @@\n-    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc,\n+                                                          LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n@@ -432,1 +432,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -467,1 +467,1 @@\n-                .boxAddressRaw(Long.MAX_VALUE)\n+                .boxAddressRaw(Long.MAX_VALUE, 1)\n@@ -491,1 +491,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, AArch64.C_POINTER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, SharedUtils.C_POINTER);\n@@ -496,1 +496,2 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, (ValueLayout) layout);\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER, addressLayout);\n@@ -498,1 +499,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.VaList;\n@@ -37,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -63,16 +60,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return CallArranger.LINUX.arrangeUpcall(targetType, function);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        LinuxAArch64VaList.Builder builder = LinuxAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return LinuxAArch64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return LinuxAArch64VaList.empty();\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.LINUX.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,568 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.linux;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.SegmentAllocator;\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.AArch64;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n-import static jdk.internal.foreign.abi.aarch64.CallArranger.MAX_REGISTER_ARGUMENTS;\n-\n-\/**\n- * Standard va_list implementation as defined by AAPCS document and used on\n- * Linux. Variadic parameters may be passed in registers or on the stack.\n- *\/\n-public non-sealed class LinuxAArch64VaList implements VaList {\n-\n-    \/\/ See AAPCS Appendix B \"Variable Argument Lists\" for definition of\n-    \/\/ va_list on AArch64.\n-    \/\/\n-    \/\/ typedef struct __va_list {\n-    \/\/     void *__stack;   \/\/ next stack param\n-    \/\/     void *__gr_top;  \/\/ end of GP arg reg save area\n-    \/\/     void *__vr_top;  \/\/ end of FP\/SIMD arg reg save area\n-    \/\/     int __gr_offs;   \/\/ offset from __gr_top to next GP register arg\n-    \/\/     int __vr_offs;   \/\/ offset from __vr_top to next FP\/SIMD register arg\n-    \/\/ } va_list;\n-\n-    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n-        AArch64.C_POINTER.withName(\"__stack\"),\n-        AArch64.C_POINTER.withName(\"__gr_top\"),\n-        AArch64.C_POINTER.withName(\"__vr_top\"),\n-        AArch64.C_INT.withName(\"__gr_offs\"),\n-        AArch64.C_INT.withName(\"__vr_offs\")\n-    ).withName(\"__va_list\");\n-\n-    private static final long STACK_SLOT_SIZE = 8;\n-\n-    private static final MemoryLayout GP_REG\n-        = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n-    private static final MemoryLayout FP_REG\n-        = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n-\n-    private static final MemoryLayout LAYOUT_GP_REGS\n-        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, GP_REG);\n-    private static final MemoryLayout LAYOUT_FP_REGS\n-        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, FP_REG);\n-\n-    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n-    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n-\n-    private static final int MAX_GP_OFFSET = (int) LAYOUT_GP_REGS.byteSize();\n-    private static final int MAX_FP_OFFSET = (int) LAYOUT_FP_REGS.byteSize();\n-\n-    private static final VarHandle VH_stack = LAYOUT.varHandle(groupElement(\"__stack\"));\n-    private static final VarHandle VH_gr_top = LAYOUT.varHandle(groupElement(\"__gr_top\"));\n-    private static final VarHandle VH_vr_top = LAYOUT.varHandle(groupElement(\"__vr_top\"));\n-    private static final VarHandle VH_gr_offs\n-        = LAYOUT.varHandle(groupElement(\"__gr_offs\"));\n-    private static final VarHandle VH_vr_offs\n-        = LAYOUT.varHandle(groupElement(\"__vr_offs\"));\n-\n-    private static final VaList EMPTY\n-        = new SharedUtils.EmptyVaList(emptyListAddress());\n-\n-    private final MemorySegment segment;\n-    private MemorySegment stack;\n-    private final MemorySegment gpRegsArea;\n-    private final long gpLimit;\n-    private final MemorySegment fpRegsArea;\n-    private final long fpLimit;\n-\n-    private LinuxAArch64VaList(MemorySegment segment, MemorySegment stack,\n-                               MemorySegment gpRegsArea, long gpLimit, MemorySegment fpRegsArea, long fpLimit) {\n-        this.segment = segment;\n-        this.stack = stack;\n-        this.gpRegsArea = gpRegsArea;\n-        this.gpLimit = gpLimit;\n-        this.fpRegsArea = fpRegsArea;\n-        this.fpLimit = fpLimit;\n-    }\n-\n-    private static LinuxAArch64VaList readFromAddress(long address, SegmentScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n-        MemorySegment stack = stackPtr(segment); \/\/ size unknown\n-        MemorySegment gpRegsArea = MemorySegment.ofAddress(grTop(segment).address() - MAX_GP_OFFSET, MAX_GP_OFFSET, scope);\n-        MemorySegment fpRegsArea = MemorySegment.ofAddress(vrTop(segment).address() - MAX_FP_OFFSET, MAX_FP_OFFSET, scope);\n-        return new LinuxAArch64VaList(segment, stack, gpRegsArea, MAX_GP_OFFSET, fpRegsArea, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        MemorySegment ms = MemorySegment.allocateNative(LAYOUT, SegmentScope.global());\n-        VH_stack.set(ms, MemorySegment.NULL);\n-        VH_gr_top.set(ms, MemorySegment.NULL);\n-        VH_vr_top.set(ms, MemorySegment.NULL);\n-        VH_gr_offs.set(ms, 0);\n-        VH_vr_offs.set(ms, 0);\n-        return ms.asSlice(0, 0);\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private MemorySegment grTop() {\n-        return grTop(segment);\n-    }\n-\n-    private static MemorySegment grTop(MemorySegment segment) {\n-        return (MemorySegment) VH_gr_top.get(segment);\n-    }\n-\n-    private MemorySegment vrTop() {\n-        return vrTop(segment);\n-    }\n-\n-    private static MemorySegment vrTop(MemorySegment segment) {\n-        return (MemorySegment) VH_vr_top.get(segment);\n-    }\n-\n-    private int grOffs() {\n-        final int offs = (int) VH_gr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private int vrOffs() {\n-        final int offs = (int) VH_vr_offs.get(segment);\n-        assert offs <= 0;\n-        return offs;\n-    }\n-\n-    private static MemorySegment stackPtr(MemorySegment segment) {\n-        return (MemorySegment) VH_stack.get(segment);\n-    }\n-\n-    private MemorySegment stackPtr() {\n-        return stackPtr(segment);\n-    }\n-\n-    private void setStack(MemorySegment newStack) {\n-        stack = newStack;\n-        VH_stack.set(segment, stack);\n-    }\n-\n-    private void consumeGPSlots(int num) {\n-        final int old = (int) VH_gr_offs.get(segment);\n-        VH_gr_offs.set(segment, old + num * GP_SLOT_SIZE);\n-    }\n-\n-    private void consumeFPSlots(int num) {\n-        final int old = (int) VH_vr_offs.get(segment);\n-        VH_vr_offs.set(segment, old + num * FP_SLOT_SIZE);\n-    }\n-\n-    private long currentGPOffset() {\n-        \/\/ Offset from start of GP register segment. __gr_top points to the top\n-        \/\/ (highest address) of the GP registers area. __gr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return gpRegsArea.byteSize() + grOffs();\n-    }\n-\n-    private long currentFPOffset() {\n-        \/\/ Offset from start of FP register segment. __vr_top points to the top\n-        \/\/ (highest address) of the FP registers area. __vr_offs is the negative\n-        \/\/ offset of next saved register from the top.\n-\n-        return fpRegsArea.byteSize() + vrOffs();\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = stack.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n-    }\n-\n-    private void preAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(preAlignOffset(layout)));\n-    }\n-\n-    private void postAlignStack(MemoryLayout layout) {\n-        setStack(stack.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read( layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        TypeClass typeClass = TypeClass.classifyLayout(layout);\n-        if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n-            checkStackElement(layout);\n-            preAlignStack(layout);\n-            return switch (typeClass) {\n-                case STRUCT_REGISTER, STRUCT_HFA, STRUCT_REFERENCE -> {\n-                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    postAlignStack(layout);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER, FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    MemorySegment slice = stack.asSlice(0, layout.byteSize());\n-                    Object res = reader.get(slice);\n-                    postAlignStack(layout);\n-                    yield res;\n-                }\n-            };\n-        } else {\n-            return switch (typeClass) {\n-                case STRUCT_REGISTER -> {\n-                    checkGPElement(layout, numSlots(layout));\n-                    \/\/ Struct is passed packed in integer registers.\n-                    MemorySegment value = allocator.allocate(layout);\n-                    long offset = 0;\n-                    while (offset < layout.byteSize()) {\n-                        final long copy = Math.min(layout.byteSize() - offset, 8);\n-                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n-                        consumeGPSlots(1);\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case STRUCT_HFA -> {\n-                    checkFPElement(layout, numSlots(layout));\n-                    \/\/ Struct is passed with each element in a separate floating\n-                    \/\/ point register.\n-                    MemorySegment value = allocator.allocate(layout);\n-                    GroupLayout group = (GroupLayout)layout;\n-                    long offset = 0;\n-                    for (MemoryLayout elem : group.memberLayouts()) {\n-                        assert elem.byteSize() <= 8;\n-                        final long copy = elem.byteSize();\n-                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n-                        consumeFPSlots(1);\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case STRUCT_REFERENCE -> {\n-                    checkGPElement(layout, 1);\n-                    \/\/ Struct is passed indirectly via a pointer in an integer register.\n-                    VarHandle ptrReader = AArch64.C_POINTER.varHandle();\n-                    MemorySegment ptr = (MemorySegment) ptrReader.get(\n-                        gpRegsArea.asSlice(currentGPOffset()));\n-                    consumeGPSlots(1);\n-\n-                    MemorySegment slice = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER -> {\n-                    checkGPElement(layout, 1);\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(gpRegsArea.asSlice(currentGPOffset()));\n-                    consumeGPSlots(1);\n-                    yield res;\n-                }\n-                case FLOAT -> {\n-                    checkFPElement(layout, 1);\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(fpRegsArea.asSlice(currentFPOffset()));\n-                    consumeFPSlots(1);\n-                    yield res;\n-                }\n-            };\n-        }\n-    }\n-\n-    private void checkGPElement(MemoryLayout layout, long slots) {\n-        if ((grOffs() + MAX_GP_OFFSET) + (slots * GP_SLOT_SIZE) > gpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkFPElement(MemoryLayout layout, long slots) {\n-        if ((vrOffs() + MAX_FP_OFFSET) + (slots * FP_SLOT_SIZE) > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkStackElement(MemoryLayout layout) {\n-        if (preAlignOffset(layout) + layout.byteSize() > stack.byteSize()) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass, layout)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-                long slots = numSlots(layout);\n-                checkFPElement(layout, slots);\n-                consumeFPSlots((int) slots);\n-            } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-                checkGPElement(layout, 1);\n-                consumeGPSlots(1);\n-            } else {\n-                long slots = numSlots(layout);\n-                checkGPElement(layout, slots);\n-                consumeGPSlots((int) slots);\n-            }\n-        }\n-    }\n-\n-    static LinuxAArch64VaList.Builder builder(SegmentScope scope) {\n-        return new LinuxAArch64VaList.Builder(scope);\n-    }\n-\n-    public static VaList ofAddress(long address, SegmentScope scope) {\n-        return readFromAddress(address, scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n-        copy.copyFrom(segment);\n-        return new LinuxAArch64VaList(copy, stack, gpRegsArea, gpLimit, fpRegsArea, fpLimit);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    private static long numSlots(MemoryLayout layout) {\n-        return Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) \/ STACK_SLOT_SIZE;\n-    }\n-\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset,\n-                                         TypeClass typeClass, MemoryLayout layout) {\n-        if (typeClass == TypeClass.FLOAT || typeClass == TypeClass.STRUCT_HFA) {\n-            return currentFPOffset > MAX_FP_OFFSET - numSlots(layout) * FP_SLOT_SIZE;\n-        } else if (typeClass == TypeClass.STRUCT_REFERENCE) {\n-            return currentGPOffset > MAX_GP_OFFSET - GP_SLOT_SIZE;\n-        } else {\n-            return currentGPOffset > MAX_GP_OFFSET - numSlots(layout) * GP_SLOT_SIZE;\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LinuxAArch64VaList{\"\n-            + \"__stack=\" + stackPtr()\n-            + \", __gr_top=\" + grTop()\n-            + \", __vr_top=\" + vrTop()\n-            + \", __gr_offs=\" + grOffs()\n-            + \", __vr_offs=\" + vrOffs()\n-            + '}';\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-        private final SegmentScope scope;\n-        private final MemorySegment gpRegs;\n-        private final MemorySegment fpRegs;\n-\n-        private long currentGPOffset = 0;\n-        private long currentFPOffset = 0;\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n-\n-        Builder(SegmentScope scope) {\n-            this.scope = scope;\n-            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n-            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset, currentFPOffset, typeClass, layout)) {\n-                stackArgs.add(new SimpleVaArg(layout, value));\n-            } else {\n-                switch (typeClass) {\n-                    case STRUCT_REGISTER -> {\n-                        \/\/ Struct is passed packed in integer registers.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        long offset = 0;\n-                        while (offset < layout.byteSize()) {\n-                            final long copy = Math.min(layout.byteSize() - offset, 8);\n-                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n-                            currentGPOffset += GP_SLOT_SIZE;\n-                            offset += copy;\n-                        }\n-                    }\n-                    case STRUCT_HFA -> {\n-                        \/\/ Struct is passed with each element in a separate floating\n-                        \/\/ point register.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        GroupLayout group = (GroupLayout)layout;\n-                        long offset = 0;\n-                        for (MemoryLayout elem : group.memberLayouts()) {\n-                            assert elem.byteSize() <= 8;\n-                            final long copy = elem.byteSize();\n-                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n-                            currentFPOffset += FP_SLOT_SIZE;\n-                            offset += copy;\n-                        }\n-                    }\n-                    case STRUCT_REFERENCE -> {\n-                        \/\/ Struct is passed indirectly via a pointer in an integer register.\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        VarHandle writer = AArch64.C_POINTER.varHandle();\n-                        writer.set(gpRegs.asSlice(currentGPOffset),\n-                                   valueSegment);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case POINTER, INTEGER -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(gpRegs.asSlice(currentGPOffset), value);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case FLOAT -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(fpRegs.asSlice(currentFPOffset), value);\n-                        currentFPOffset += FP_SLOT_SIZE;\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == 0 && stackArgs.isEmpty();\n-        }\n-\n-        public VaList build() {\n-            if (isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n-            MemorySegment stackArgsSegment;\n-            if (!stackArgs.isEmpty()) {\n-                long stackArgsSize = stackArgs.stream()\n-                    .reduce(0L, (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n-                MemorySegment writeCursor = stackArgsSegment;\n-                for (SimpleVaArg arg : stackArgs) {\n-                    final long alignedSize = Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE);\n-                    writeCursor = Utils.alignUp(writeCursor, alignedSize);\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(writeCursor, arg.value);\n-                    writeCursor = writeCursor.asSlice(alignedSize);\n-                }\n-            } else {\n-                stackArgsSegment = MemorySegment.NULL;\n-            }\n-\n-            VH_gr_top.set(vaListSegment, gpRegs.asSlice(gpRegs.byteSize()));\n-            VH_vr_top.set(vaListSegment, fpRegs.asSlice(fpRegs.byteSize()));\n-            VH_stack.set(vaListSegment, stackArgsSegment);\n-            VH_gr_offs.set(vaListSegment, -MAX_GP_OFFSET);\n-            VH_vr_offs.set(vaListSegment, -MAX_FP_OFFSET);\n-\n-            assert MemorySessionImpl.sameOwnerThread(gpRegs.scope(), vaListSegment.scope());\n-            assert MemorySessionImpl.sameOwnerThread(fpRegs.scope(), vaListSegment.scope());\n-            return new LinuxAArch64VaList(vaListSegment, stackArgsSegment, gpRegs, currentGPOffset, fpRegs, currentFPOffset);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":0,"deletions":568,"binary":false,"changes":568,"status":"deleted"},{"patch":"@@ -33,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n@@ -37,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -63,16 +60,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return CallArranger.MACOS.arrangeUpcall(targetType, function);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        MacOsAArch64VaList.Builder builder = MacOsAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return MacOsAArch64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return MacOsAArch64VaList.empty();\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.MACOS.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.macos;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n-import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n-\n-\/**\n- * Simplified va_list implementation used on macOS where all variadic\n- * parameters are passed on the stack and the type of va_list decays to\n- * char* instead of the structure defined in the AAPCS.\n- *\/\n-public non-sealed class MacOsAArch64VaList implements VaList {\n-    private static final long VA_SLOT_SIZE_BYTES = 8;\n-    private static final VarHandle VH_address = C_POINTER.varHandle();\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    private MemorySegment segment;\n-\n-    private MacOsAArch64VaList(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        Object res;\n-        if (layout instanceof GroupLayout) {\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            res = switch (typeClass) {\n-                case STRUCT_REFERENCE -> {\n-                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n-                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(struct);\n-                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-                    yield seg;\n-                }\n-                case STRUCT_REGISTER, STRUCT_HFA -> {\n-                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-                    checkElement(layout, size);\n-                    MemorySegment struct = allocator.allocate(layout)\n-                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n-                    segment = segment.asSlice(size);\n-                    yield struct;\n-                }\n-                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-            };\n-        } else {\n-            checkElement(layout, VA_SLOT_SIZE_BYTES);\n-            VarHandle reader = layout.varHandle();\n-            res = reader.get(segment);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n-        return res;\n-    }\n-\n-    private static long sizeOf(MemoryLayout layout) {\n-        return switch (TypeClass.classifyLayout(layout)) {\n-            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-            default -> VA_SLOT_SIZE_BYTES;\n-        };\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            long size = sizeOf(layout);\n-            checkElement(layout, size);\n-            segment = segment.asSlice(size);\n-        }\n-    }\n-\n-    private void checkElement(MemoryLayout layout, long size) {\n-        if (segment.byteSize() < size) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n-        return new MacOsAArch64VaList(segment);\n-    }\n-\n-    static Builder builder(SegmentScope session) {\n-        return new Builder(session);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        return new MacOsAArch64VaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope session;\n-        private final List<SimpleVaArg> args = new ArrayList<>();\n-\n-        public Builder(SegmentScope session) {\n-            ((MemorySessionImpl) session).checkValidState();\n-            this.session = session;\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            args.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        public VaList build() {\n-            if (args.isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n-            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n-            MemorySegment cursor = segment;\n-\n-            for (SimpleVaArg arg : args) {\n-                if (arg.layout instanceof GroupLayout) {\n-                    MemorySegment msArg = ((MemorySegment) arg.value);\n-                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n-                    switch (typeClass) {\n-                        case STRUCT_REFERENCE -> {\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n-                            copy.copyFrom(msArg); \/\/ by-value\n-                            VH_address.set(cursor, copy);\n-                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                        }\n-                        case STRUCT_REGISTER, STRUCT_HFA ->\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n-                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-                    }\n-                } else {\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(cursor, arg.value);\n-                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                }\n-            }\n-\n-            return new MacOsAArch64VaList(segment);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"},{"patch":"@@ -34,2 +34,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n@@ -38,1 +36,0 @@\n-import java.util.function.Consumer;\n@@ -60,2 +57,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return CallArranger.WINDOWS.arrangeUpcall(targetType, function);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.WINDOWS.arrangeUpcall(targetType, function, options);\n@@ -63,15 +60,0 @@\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        WindowsAArch64VaList.Builder builder = WindowsAArch64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return WindowsAArch64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return WindowsAArch64VaList.empty();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.aarch64.windows;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.abi.aarch64.TypeClass;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.C_POINTER;\n-import static jdk.internal.foreign.abi.SharedUtils.alignUp;\n-\n-\/\/ see vadefs.h (VC header) for the ARM64 va_arg impl\n-\/\/\n-\/\/    typedef char* va_list;\n-\/\/\n-\/\/    #define __crt_va_arg(ap, t)                                                \\\n-\/\/        ((sizeof(t) > (2 * sizeof(__int64)))                                   \\\n-\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \\\n-\/\/            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))\n-\/\/\n-public non-sealed class WindowsAArch64VaList implements VaList {\n-    private static final long VA_SLOT_SIZE_BYTES = 8;\n-    private static final VarHandle VH_address = C_POINTER.varHandle();\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    private MemorySegment segment;\n-\n-    private WindowsAArch64VaList(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        Object res;\n-        if (layout instanceof GroupLayout) {\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            res = switch (typeClass) {\n-                case STRUCT_REFERENCE -> {\n-                    checkElement(layout, VA_SLOT_SIZE_BYTES);\n-                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(struct);\n-                    segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-                    yield seg;\n-                }\n-                case STRUCT_REGISTER, STRUCT_HFA -> {\n-                    long size = alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-                    checkElement(layout, size);\n-                    MemorySegment struct = allocator.allocate(layout)\n-                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n-                    segment = segment.asSlice(size);\n-                    yield struct;\n-                }\n-                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-            };\n-        } else {\n-            checkElement(layout, VA_SLOT_SIZE_BYTES);\n-            VarHandle reader = layout.varHandle();\n-            res = reader.get(segment);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n-        return res;\n-    }\n-\n-    private static long sizeOf(MemoryLayout layout) {\n-        return switch (TypeClass.classifyLayout(layout)) {\n-            case STRUCT_REGISTER, STRUCT_HFA -> alignUp(layout.byteSize(), VA_SLOT_SIZE_BYTES);\n-            default -> VA_SLOT_SIZE_BYTES;\n-        };\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            long size = sizeOf(layout);\n-            checkElement(layout, size);\n-            segment = segment.asSlice(size);\n-        }\n-    }\n-\n-    private void checkElement(MemoryLayout layout, long size) {\n-        if (segment.byteSize() < size) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    static WindowsAArch64VaList ofAddress(long address, SegmentScope session) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, session);\n-        return new WindowsAArch64VaList(segment);\n-    }\n-\n-    static Builder builder(SegmentScope session) {\n-        return new Builder(session);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        return new WindowsAArch64VaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope session;\n-        private final List<SimpleVaArg> args = new ArrayList<>();\n-\n-        public Builder(SegmentScope session) {\n-            ((MemorySessionImpl) session).checkValidState();\n-            this.session = session;\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            args.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        public VaList build() {\n-            if (args.isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            long allocationSize = args.stream().reduce(0L, (acc, e) -> acc + sizeOf(e.layout), Long::sum);\n-            MemorySegment segment = MemorySegment.allocateNative(allocationSize, session);\n-            MemorySegment cursor = segment;\n-\n-            for (SimpleVaArg arg : args) {\n-                if (arg.layout instanceof GroupLayout) {\n-                    MemorySegment msArg = ((MemorySegment) arg.value);\n-                    TypeClass typeClass = TypeClass.classifyLayout(arg.layout);\n-                    switch (typeClass) {\n-                        case STRUCT_REFERENCE -> {\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, session);\n-                            copy.copyFrom(msArg); \/\/ by-value\n-                            VH_address.set(cursor, copy);\n-                            cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                        }\n-                        case STRUCT_REGISTER, STRUCT_HFA ->\n-                            cursor = cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n-                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-                    }\n-                } else {\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(cursor, arg.value);\n-                    cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-                }\n-            }\n-\n-            return new WindowsAArch64VaList(segment);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64VaList.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+\/**\n+ * enum which maps the {@code ffi_abi} enum\n+ *\/\n+enum FFIABI {\n+    DEFAULT(LibFallback.DEFAULT_ABI);\n+\n+    private final int value;\n+\n+    FFIABI(int abi) {\n+        this.value = abi;\n+    }\n+\n+    int value() {\n+        return value;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIABI.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+\/**\n+ * See doc: <a href=\"https:\/\/github.com\/libffi\/libffi\/blob\/7611bb4cfe90884b55ad225e0166136a1d2cf22b\/doc\/libffi.texi#L159\"><\/a>\n+ * <p>\n+ * typedef enum {\n+ *   FFI_OK = 0,\n+ *   FFI_BAD_TYPEDEF,\n+ *   FFI_BAD_ABI,\n+ *   FFI_BAD_ARGTYPE\n+ * } ffi_status;\n+ *\/\n+enum FFIStatus {\n+    FFI_OK,\n+    FFI_BAD_TYPEDEF,\n+    FFI_BAD_ABI,\n+    FFI_BAD_ARGTYPE;\n+\n+    static FFIStatus of(int code) {\n+        return switch (code) {\n+            case 0 -> FFI_OK;\n+            case 1 -> FFI_BAD_TYPEDEF;\n+            case 2 -> FFI_BAD_ABI;\n+            case 3 -> FFI_BAD_ARGTYPE;\n+            default -> throw new IllegalArgumentException(\"Unknown status code: \" + code);\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIStatus.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+\n+\/**\n+ * typedef struct _ffi_type\n+ * {\n+ *   size_t size;\n+ *   unsigned short alignment;\n+ *   unsigned short type;\n+ *   struct _ffi_type **elements;\n+ * } ffi_type;\n+ *\/\n+class FFIType {\n+    private static final ValueLayout SIZE_T = switch ((int) ADDRESS.bitSize()) {\n+            case 64 -> JAVA_LONG;\n+            case 32 -> JAVA_INT;\n+            default -> throw new IllegalStateException(\"Address size not supported: \" + ADDRESS.byteSize());\n+        };\n+    private static final ValueLayout UNSIGNED_SHORT = JAVA_SHORT;\n+    private static final StructLayout LAYOUT = Utils.computePaddedStructLayout(\n+            SIZE_T, UNSIGNED_SHORT, UNSIGNED_SHORT.withName(\"type\"), ADDRESS.withName(\"elements\"));\n+\n+    private static final VarHandle VH_TYPE = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"type\"));\n+    private static final VarHandle VH_ELEMENTS = LAYOUT.varHandle(MemoryLayout.PathElement.groupElement(\"elements\"));\n+    private static final VarHandle VH_SIZE_T_ARRAY = SIZE_T.arrayElementVarHandle();\n+\n+    private static MemorySegment make(List<MemoryLayout> elements, FFIABI abi, Arena scope) {\n+        MemorySegment elementsSeg = scope.allocate((elements.size() + 1) * ADDRESS.byteSize());\n+        int i = 0;\n+        for (; i < elements.size(); i++) {\n+            MemoryLayout elementLayout = elements.get(i);\n+            MemorySegment elementType = toFFIType(elementLayout, abi, scope);\n+            elementsSeg.setAtIndex(ADDRESS, i, elementType);\n+        }\n+        \/\/ elements array is null-terminated\n+        elementsSeg.setAtIndex(ADDRESS, i, MemorySegment.NULL);\n+\n+        MemorySegment ffiType = scope.allocate(LAYOUT);\n+        VH_TYPE.set(ffiType, LibFallback.STRUCT_TAG);\n+        VH_ELEMENTS.set(ffiType, elementsSeg);\n+\n+        return ffiType;\n+    }\n+\n+    private static final Map<Class<?>, MemorySegment> CARRIER_TO_TYPE = Map.of(\n+        boolean.class, LibFallback.UINT8_TYPE,\n+        byte.class, LibFallback.SINT8_TYPE,\n+        short.class, LibFallback.SINT16_TYPE,\n+        char.class, LibFallback.UINT16_TYPE,\n+        int.class, LibFallback.SINT32_TYPE,\n+        long.class, LibFallback.SINT64_TYPE,\n+        float.class, LibFallback.FLOAT_TYPE,\n+        double.class, LibFallback.DOUBLE_TYPE,\n+        MemorySegment.class, LibFallback.POINTER_TYPE\n+    );\n+\n+    static MemorySegment toFFIType(MemoryLayout layout, FFIABI abi, Arena scope) {\n+        if (layout instanceof GroupLayout grpl) {\n+            if (grpl instanceof StructLayout strl) {\n+                \/\/ libffi doesn't want our padding\n+                List<MemoryLayout> filteredLayouts = strl.memberLayouts().stream()\n+                        .filter(Predicate.not(PaddingLayout.class::isInstance))\n+                        .toList();\n+                MemorySegment structType = make(filteredLayouts, abi, scope);\n+                verifyStructType(strl, filteredLayouts, structType, abi);\n+                return structType;\n+            }\n+            assert grpl instanceof UnionLayout;\n+            \/\/ JDK-8301800\n+            throw new IllegalArgumentException(\"Fallback linker does not support by-value unions: \" + grpl);\n+        } else if (layout instanceof SequenceLayout sl) {\n+            List<MemoryLayout> elements = Collections.nCopies(Math.toIntExact(sl.elementCount()), sl.elementLayout());\n+            return make(elements, abi, scope);\n+        }\n+        return Objects.requireNonNull(CARRIER_TO_TYPE.get(((ValueLayout) layout).carrier()));\n+    }\n+\n+    \/\/ verify layout against what libffi sets\n+    private static void verifyStructType(StructLayout structLayout, List<MemoryLayout> filteredLayouts, MemorySegment structType,\n+                                         FFIABI abi) {\n+        try (Arena verifyArena = Arena.ofConfined()) {\n+            MemorySegment offsetsOut = verifyArena.allocate(SIZE_T.byteSize() * filteredLayouts.size());\n+            LibFallback.getStructOffsets(structType, offsetsOut, abi);\n+            long expectedOffset = 0;\n+            int offsetIdx = 0;\n+            for (MemoryLayout element : structLayout.memberLayouts()) {\n+                if (!(element instanceof PaddingLayout)) {\n+                    long ffiOffset = (long) VH_SIZE_T_ARRAY.get(offsetsOut, offsetIdx++);\n+                    if (ffiOffset != expectedOffset) {\n+                        throw new IllegalArgumentException(\"Invalid group layout.\" +\n+                                \" Offset of '\" + element.name().orElse(\"<unnamed>\")\n+                                + \"': \" + expectedOffset + \" != \" + ffiOffset);\n+                    }\n+                }\n+                expectedOffset += element.byteSize();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FFIType.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.CapturableState;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.ref.Reference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n+\n+public final class FallbackLinker extends AbstractLinker {\n+\n+    private static final MethodHandle MH_DO_DOWNCALL;\n+    private static final MethodHandle MH_DO_UPCALL;\n+\n+    static {\n+        try {\n+            MH_DO_DOWNCALL = MethodHandles.lookup().findStatic(FallbackLinker.class, \"doDowncall\",\n+                    MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class, FallbackLinker.DowncallData.class));\n+            MH_DO_UPCALL = MethodHandles.lookup().findStatic(FallbackLinker.class, \"doUpcall\",\n+                    MethodType.methodType(void.class, MethodHandle.class, MemorySegment.class, MemorySegment.class, UpcallData.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static FallbackLinker getInstance() {\n+        class Holder {\n+            static final FallbackLinker INSTANCE = new FallbackLinker();\n+        }\n+        return Holder.INSTANCE;\n+    }\n+\n+    public static boolean isSupported() {\n+        return LibFallback.SUPPORTED;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        MemorySegment cif = makeCif(inferredMethodType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+\n+        int capturedStateMask = options.capturedCallState()\n+                .mapToInt(CapturableState::mask)\n+                .reduce(0, (a, b) -> a | b);\n+        DowncallData invData = new DowncallData(cif, function.returnLayout().orElse(null),\n+                function.argumentLayouts(), capturedStateMask);\n+\n+        MethodHandle target = MethodHandles.insertArguments(MH_DO_DOWNCALL, 2, invData);\n+\n+        int leadingArguments = 1; \/\/ address\n+        MethodType type = inferredMethodType.insertParameterTypes(0, SegmentAllocator.class, MemorySegment.class);\n+        if (capturedStateMask != 0) {\n+            leadingArguments++;\n+            type = type.insertParameterTypes(2, MemorySegment.class);\n+        }\n+        target = target.asCollector(1, Object[].class, inferredMethodType.parameterCount() + leadingArguments);\n+        target = target.asType(type);\n+        target = foldArguments(target, 1, SharedUtils.MH_CHECK_SYMBOL);\n+        target = SharedUtils.swapArguments(target, 0, 1); \/\/ normalize parameter order\n+\n+        return target;\n+    }\n+\n+    @Override\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        MemorySegment cif = makeCif(targetType, function, FFIABI.DEFAULT, Arena.ofAuto());\n+\n+        UpcallData invData = new UpcallData(function.returnLayout().orElse(null), function.argumentLayouts(), cif);\n+        MethodHandle doUpcallMH = MethodHandles.insertArguments(MH_DO_UPCALL, 3, invData);\n+\n+        return (target, scope) -> {\n+            target = MethodHandles.insertArguments(doUpcallMH, 0, target);\n+            return LibFallback.createClosure(cif, target, scope);\n+        };\n+    }\n+\n+    private static MemorySegment makeCif(MethodType methodType, FunctionDescriptor function, FFIABI abi, Arena scope) {\n+        MemorySegment argTypes = scope.allocate(function.argumentLayouts().size() * ADDRESS.byteSize());\n+        List<MemoryLayout> argLayouts = function.argumentLayouts();\n+        for (int i = 0; i < argLayouts.size(); i++) {\n+            MemoryLayout layout = argLayouts.get(i);\n+            argTypes.setAtIndex(ADDRESS, i, FFIType.toFFIType(layout, abi, scope));\n+        }\n+\n+        MemorySegment returnType = methodType.returnType() != void.class\n+                ? FFIType.toFFIType(function.returnLayout().orElseThrow(), abi, scope)\n+                : LibFallback.VOID_TYPE;\n+        return LibFallback.prepCif(returnType, argLayouts.size(), argTypes, abi, scope);\n+    }\n+\n+    private record DowncallData(MemorySegment cif, MemoryLayout returnLayout, List<MemoryLayout> argLayouts,\n+                                int capturedStateMask) {}\n+\n+    private static Object doDowncall(SegmentAllocator returnAllocator, Object[] args, DowncallData invData) {\n+        List<MemorySessionImpl> acquiredSessions = new ArrayList<>();\n+        try (Arena arena = Arena.ofConfined()) {\n+            int argStart = 0;\n+\n+            MemorySegment target = (MemorySegment) args[argStart++];\n+            MemorySessionImpl targetImpl = ((AbstractMemorySegmentImpl) target).sessionImpl();\n+            targetImpl.acquire0();\n+            acquiredSessions.add(targetImpl);\n+\n+            MemorySegment capturedState = null;\n+            if (invData.capturedStateMask() != 0) {\n+                capturedState = (MemorySegment) args[argStart++];\n+                MemorySessionImpl capturedStateImpl = ((AbstractMemorySegmentImpl) capturedState).sessionImpl();\n+                capturedStateImpl.acquire0();\n+                acquiredSessions.add(capturedStateImpl);\n+            }\n+\n+            List<MemoryLayout> argLayouts = invData.argLayouts();\n+            MemorySegment argPtrs = arena.allocate(argLayouts.size() * ADDRESS.byteSize());\n+            for (int i = 0; i < argLayouts.size(); i++) {\n+                Object arg = args[argStart + i];\n+                MemoryLayout layout = argLayouts.get(i);\n+                MemorySegment argSeg = arena.allocate(layout);\n+                writeValue(arg, layout, argSeg, addr -> {\n+                    MemorySessionImpl sessionImpl = ((AbstractMemorySegmentImpl) addr).sessionImpl();\n+                    sessionImpl.acquire0();\n+                    acquiredSessions.add(sessionImpl);\n+                });\n+                argPtrs.setAtIndex(ADDRESS, i, argSeg);\n+            }\n+\n+            MemorySegment retSeg = null;\n+            if (invData.returnLayout() != null) {\n+                retSeg = (invData.returnLayout() instanceof GroupLayout ? returnAllocator : arena).allocate(invData.returnLayout);\n+            }\n+\n+            LibFallback.doDowncall(invData.cif, target, retSeg, argPtrs, capturedState, invData.capturedStateMask());\n+\n+            Reference.reachabilityFence(invData.cif());\n+\n+            return readValue(retSeg, invData.returnLayout());\n+        } finally {\n+            for (MemorySessionImpl session : acquiredSessions) {\n+                session.release0();\n+            }\n+        }\n+    }\n+\n+    \/\/ note that cif is not used, but we store it here to keep it alive\n+    private record UpcallData(MemoryLayout returnLayout, List<MemoryLayout> argLayouts, MemorySegment cif) {}\n+\n+    private static void doUpcall(MethodHandle target, MemorySegment retPtr, MemorySegment argPtrs, UpcallData data) throws Throwable {\n+        List<MemoryLayout> argLayouts = data.argLayouts();\n+        int numArgs = argLayouts.size();\n+        MemoryLayout retLayout = data.returnLayout();\n+        try (Arena upcallArena = Arena.ofConfined()) {\n+            MemorySegment argsSeg = argPtrs.reinterpret(numArgs * ADDRESS.byteSize(), upcallArena, null);\n+            MemorySegment retSeg = retLayout != null\n+                ? retPtr.reinterpret(retLayout.byteSize(), upcallArena, null)\n+                : null;\n+\n+            Object[] args = new Object[numArgs];\n+            for (int i = 0; i < numArgs; i++) {\n+                MemoryLayout argLayout = argLayouts.get(i);\n+                MemorySegment argPtr = argsSeg.getAtIndex(ADDRESS, i)\n+                        .reinterpret(argLayout.byteSize(), upcallArena, null);\n+                args[i] = readValue(argPtr, argLayout);\n+            }\n+\n+            Object result = target.invokeWithArguments(args);\n+\n+            writeValue(result, data.returnLayout(), retSeg);\n+        }\n+    }\n+\n+    \/\/ where\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg) {\n+        writeValue(arg, layout, argSeg, addr -> {});\n+    }\n+\n+    private static void writeValue(Object arg, MemoryLayout layout, MemorySegment argSeg,\n+                                   Consumer<MemorySegment> acquireCallback) {\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            argSeg.set(bl, 0, (Boolean) arg);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            argSeg.set(bl, 0, (Byte) arg);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            argSeg.set(sl, 0, (Short) arg);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            argSeg.set(cl, 0, (Character) arg);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            argSeg.set(il, 0, (Integer) arg);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            argSeg.set(ll, 0, (Long) arg);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            argSeg.set(fl, 0, (Float) arg);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            argSeg.set(dl, 0, (Double) arg);\n+        } else if (layout instanceof AddressLayout al) {\n+            MemorySegment addrArg = (MemorySegment) arg;\n+            acquireCallback.accept(addrArg);\n+            argSeg.set(al, 0, addrArg);\n+        } else if (layout instanceof GroupLayout) {\n+            argSeg.copyFrom((MemorySegment) arg); \/\/ by-value struct\n+        } else {\n+            assert layout == null;\n+        }\n+    }\n+\n+    private static Object readValue(MemorySegment seg, MemoryLayout layout) {\n+        if (layout instanceof ValueLayout.OfBoolean bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfByte bl) {\n+            return seg.get(bl, 0);\n+        } else if (layout instanceof ValueLayout.OfShort sl) {\n+            return seg.get(sl, 0);\n+        } else if (layout instanceof ValueLayout.OfChar cl) {\n+            return seg.get(cl, 0);\n+        } else if (layout instanceof ValueLayout.OfInt il) {\n+            return seg.get(il, 0);\n+        } else if (layout instanceof ValueLayout.OfLong ll) {\n+            return seg.get(ll, 0);\n+        } else if (layout instanceof ValueLayout.OfFloat fl) {\n+            return seg.get(fl, 0);\n+        } else if (layout instanceof ValueLayout.OfDouble dl) {\n+            return seg.get(dl, 0);\n+        } else if (layout instanceof AddressLayout al) {\n+            return seg.get(al, 0);\n+        } else if (layout instanceof GroupLayout) {\n+            return seg;\n+        }\n+        assert layout == null;\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.fallback;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+class LibFallback {\n+    static final boolean SUPPORTED = tryLoadLibrary();\n+\n+    private static boolean tryLoadLibrary() {\n+        try {\n+            System.loadLibrary(\"fallbackLinker\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            return false;\n+        }\n+        init();\n+        return true;\n+    }\n+\n+    static final int DEFAULT_ABI = ffi_default_abi();\n+\n+    static final MemorySegment UINT8_TYPE = MemorySegment.ofAddress(ffi_type_uint8());\n+    static final MemorySegment SINT8_TYPE = MemorySegment.ofAddress(ffi_type_sint8());\n+    static final MemorySegment UINT16_TYPE = MemorySegment.ofAddress(ffi_type_uint16());\n+    static final MemorySegment SINT16_TYPE = MemorySegment.ofAddress(ffi_type_sint16());\n+    static final MemorySegment SINT32_TYPE = MemorySegment.ofAddress(ffi_type_sint32());\n+    static final MemorySegment SINT64_TYPE = MemorySegment.ofAddress(ffi_type_sint64());\n+    static final MemorySegment FLOAT_TYPE = MemorySegment.ofAddress(ffi_type_float());\n+    static final MemorySegment DOUBLE_TYPE = MemorySegment.ofAddress(ffi_type_double());\n+    static final MemorySegment POINTER_TYPE = MemorySegment.ofAddress(ffi_type_pointer());\n+\n+    static final MemorySegment VOID_TYPE = MemorySegment.ofAddress(ffi_type_void());\n+    static final short STRUCT_TAG = ffi_type_struct();\n+    private static final long SIZEOF_CIF = sizeofCif();\n+\n+    private static final MethodType UPCALL_TARGET_TYPE = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class);\n+\n+    \/**\n+     * Do a libffi based downcall. This method wraps the {@code ffi_call} function\n+     *\n+     * @param cif a pointer to a {@code ffi_cif} struct\n+     * @param target the address of the target function\n+     * @param retPtr a pointer to a buffer into which the return value shall be written, or {@code null} if the target\n+     *               function does not return a value\n+     * @param argPtrs a pointer to an array of pointers, which each point to an argument value\n+     * @param capturedState a pointer to a buffer into which captured state is written, or {@code null} if no state is\n+     *                      to be captured\n+     * @param capturedStateMask the bit mask indicating which state to capture\n+     *\n+     * @see jdk.internal.foreign.abi.CapturableState\n+     *\/\n+    static void doDowncall(MemorySegment cif, MemorySegment target, MemorySegment retPtr, MemorySegment argPtrs,\n+                                  MemorySegment capturedState, int capturedStateMask) {\n+            doDowncall(cif.address(), target.address(),\n+                    retPtr == null ? 0 : retPtr.address(), argPtrs.address(),\n+                    capturedState == null ? 0 : capturedState.address(), capturedStateMask);\n+    }\n+\n+    \/**\n+     * Wrapper for {@code ffi_prep_cif}\n+     *\n+     * @param returnType a pointer to an @{code ffi_type} describing the return type\n+     * @param numArgs the number of arguments\n+     * @param paramTypes a pointer to an array of pointers, which each point to an {@code ffi_type} describing a\n+     *                parameter type\n+     * @param abi the abi to be used\n+     * @param scope the scope into which to allocate the returned {@code ffi_cif} struct\n+     * @return a pointer to a prepared {@code ffi_cif} struct\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_cif} returns a non-zero status code\n+     *\/\n+    static MemorySegment prepCif(MemorySegment returnType, int numArgs, MemorySegment paramTypes, FFIABI abi,\n+                                         Arena scope) throws IllegalStateException {\n+        MemorySegment cif = scope.allocate(SIZEOF_CIF);\n+        checkStatus(ffi_prep_cif(cif.address(), abi.value(), numArgs, returnType.address(), paramTypes.address()));\n+        return cif;\n+    }\n+\n+    \/**\n+     * Create an upcallStub-style closure. This method wraps the {@code ffi_closure_alloc}\n+     * and {@code ffi_prep_closure_loc} functions.\n+     * <p>\n+     * The closure will end up calling into {@link #doUpcall(long, long, MethodHandle)}\n+     * <p>\n+     * The target method handle should have the type {@code (MemorySegment, MemorySegment) -> void}. The first\n+     * argument is a pointer to the buffer into which the native return value should be written. The second argument\n+     * is a pointer to an array of pointers, which each point to a native argument value.\n+     *\n+     * @param cif a pointer to a {@code ffi_cif} struct\n+     * @param target a method handle that points to the target function\n+     * @param arena the scope to which to attach the created upcall stub\n+     * @return the created upcall stub\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_prep_closure_loc} returns a non-zero status code\n+     * @throws IllegalArgumentException if {@code target} does not have the right type\n+     *\/\n+    static MemorySegment createClosure(MemorySegment cif, MethodHandle target, Arena arena)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (target.type() != UPCALL_TARGET_TYPE) {\n+            throw new IllegalArgumentException(\"Target handle has wrong type: \" + target.type() + \" != \" + UPCALL_TARGET_TYPE);\n+        }\n+\n+        long[] ptrs = new long[3];\n+        checkStatus(createClosure(cif.address(), target, ptrs));\n+        long closurePtr = ptrs[0];\n+        long execPtr = ptrs[1];\n+        long globalTarget = ptrs[2];\n+\n+        return MemorySegment.ofAddress(execPtr).reinterpret(arena, unused -> freeClosure(closurePtr, globalTarget));\n+    }\n+\n+    \/\/ the target function for a closure call\n+    private static void doUpcall(long retPtr, long argPtrs, MethodHandle target) {\n+        try {\n+            target.invokeExact(MemorySegment.ofAddress(retPtr), MemorySegment.ofAddress(argPtrs));\n+        } catch (Throwable t) {\n+            SharedUtils.handleUncaughtException(t);\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper for {@code ffi_get_struct_offsets}\n+     *\n+     * @param structType a pointer to an {@code ffi_type} representing a struct\n+     * @param offsetsOut a pointer to an array of {@code size_t}, with one element for each element of the struct.\n+     *                   This is an 'out' parameter that will be filled in by this call\n+     * @param abi the abi to be used\n+     *\n+     * @throws IllegalStateException if the call to {@code ffi_get_struct_offsets} returns a non-zero status code\n+     *\/\n+    static void getStructOffsets(MemorySegment structType, MemorySegment offsetsOut, FFIABI abi)\n+            throws IllegalStateException {\n+        checkStatus(ffi_get_struct_offsets(abi.value(), structType.address(), offsetsOut.address()));\n+    }\n+\n+    private static void checkStatus(int code) {\n+        FFIStatus status = FFIStatus.of(code);\n+        if (status != FFIStatus.FFI_OK) {\n+            throw new IllegalStateException(\"libffi call failed with status: \" + status);\n+        }\n+    }\n+\n+    private static native void init();\n+\n+    private static native long sizeofCif();\n+\n+    private static native int createClosure(long cif, Object userData, long[] ptrs);\n+    private static native void freeClosure(long closureAddress, long globalTarget);\n+    private static native void doDowncall(long cif, long fn, long rvalue, long avalues, long capturedState, int capturedStateMask);\n+\n+    private static native int ffi_prep_cif(long cif, int abi, int nargs, long rtype, long atypes);\n+    private static native int ffi_get_struct_offsets(int abi, long type, long offsets);\n+\n+    private static native int ffi_default_abi();\n+    private static native short ffi_type_struct();\n+\n+    private static native long ffi_type_void();\n+    private static native long ffi_type_uint8();\n+    private static native long ffi_type_sint8();\n+    private static native long ffi_type_uint16();\n+    private static native long ffi_type_sint16();\n+    private static native long ffi_type_uint32();\n+    private static native long ffi_type_sint32();\n+    private static native long ffi_type_uint64();\n+    private static native long ffi_type_sint64();\n+    private static native long ffi_type_float();\n+    private static native long ffi_type_double();\n+    private static native long ffi_type_pointer();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-public class RISCV64Architecture implements Architecture {\n+public final class RISCV64Architecture implements Architecture {\n@@ -44,0 +44,3 @@\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private RISCV64Architecture() {}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/RISCV64Architecture.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -45,1 +46,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.ValueLayout;\n@@ -55,1 +56,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n@@ -94,1 +94,1 @@\n-            MemoryLayout layout = RISCV64.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -124,2 +124,2 @@\n-    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n@@ -394,0 +394,1 @@\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n@@ -396,1 +397,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64CallArranger.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -34,2 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.VaList;\n@@ -38,1 +35,0 @@\n-import java.util.function.Consumer;\n@@ -60,16 +56,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        LinuxRISCV64VaList.Builder builder = LinuxRISCV64VaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return LinuxRISCV64VaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return LinuxRISCV64VaList.empty();\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return LinuxRISCV64CallArranger.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, Institute of Software, Chinese Academy of Sciences.\n- * All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package jdk.internal.foreign.abi.riscv64.linux;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.foreign.VaList;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Utils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n-\n-\/**\n- * Standard va_list implementation as defined by RISC-V ABI document and used on Linux.\n- * In the base integer calling convention, variadic arguments are passed in the same\n- * manner as named arguments, with one exception. Variadic arguments with 2 * XLEN-bit\n- * alignment and size at most 2 * XLEN bits are passed in an aligned register pair\n- * (i.e., the first register in the pair is even-numbered), or on the stack by value\n- * if none is available. After a variadic argument has been passed on the stack, all\n- * future arguments will also be passed on the stack (i.e. the last argument register\n- * may be left unused due to the aligned register pair rule).\n- *\/\n-\n-public non-sealed class LinuxRISCV64VaList implements VaList {\n-    \/\/ The va_list type is void* on RISCV64.\n-    \/\/ See https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc#cc-type-representations\n-\n-    private final MemorySegment segment;\n-    private long offset;\n-\n-    private static final long STACK_SLOT_SIZE = 8;\n-    private static final VaList EMPTY\n-            = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    public LinuxRISCV64VaList(MemorySegment segment, long offset) {\n-        this.segment = segment;\n-        this.offset = offset;\n-    }\n-\n-    private static LinuxRISCV64VaList readFromAddress(long address, SegmentScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, Long.MAX_VALUE, scope); \/\/ size unknown\n-        return new LinuxRISCV64VaList(segment, 0);\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        TypeClass typeClass = TypeClass.classifyLayout(layout);\n-        preAlignStack(layout);\n-\n-        return switch (typeClass) {\n-            case INTEGER, FLOAT, POINTER -> {\n-                checkStackElement(layout);\n-                VarHandle reader = layout.varHandle();\n-                MemorySegment slice = segment.asSlice(offset, layout.byteSize());\n-                Object res = reader.get(slice);\n-                postAlignStack(layout);\n-                yield res;\n-            }\n-            case STRUCT_REGISTER_X, STRUCT_REGISTER_F, STRUCT_REGISTER_XF -> {\n-                checkStackElement(layout);\n-                \/\/ Struct is passed indirectly via a pointer in an integer register.\n-                MemorySegment slice = segment.asSlice(offset, layout.byteSize());\n-                MemorySegment seg = allocator.allocate(layout);\n-                seg.copyFrom(slice);\n-                postAlignStack(layout);\n-                yield seg;\n-            }\n-            case STRUCT_REFERENCE -> {\n-                checkStackElement(ADDRESS);\n-                VarHandle addrReader = ADDRESS.varHandle();\n-                MemorySegment slice = segment.asSlice(offset, ADDRESS.byteSize());\n-                MemorySegment addr = (MemorySegment) addrReader.get(slice);\n-                MemorySegment seg = allocator.allocate(layout);\n-                seg.copyFrom(MemorySegment.ofAddress(addr.address(), layout.byteSize(), segment.scope()));\n-                postAlignStack(ADDRESS);\n-                yield seg;\n-            }\n-        };\n-    }\n-\n-    private void checkStackElement(MemoryLayout layout) {\n-        if (Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE) > segment.byteSize()) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void preAlignStack(MemoryLayout layout) {\n-        if (layout.byteSize() <= 16 && layout.byteAlignment() == 16) {\n-            offset = Utils.alignUp(offset, 16);\n-        } else {\n-            offset = Utils.alignUp(offset, STACK_SLOT_SIZE);\n-        }\n-    }\n-\n-    private void postAlignStack(MemoryLayout layout) {\n-        if (layout.byteSize() <= 16 && layout.byteAlignment() == 16) {\n-            offset += 16;\n-        } else {\n-            offset += Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            preAlignStack(layout);\n-            postAlignStack(layout);\n-        }\n-    }\n-\n-    static LinuxRISCV64VaList.Builder builder(SegmentScope scope) {\n-        return new LinuxRISCV64VaList.Builder(scope);\n-    }\n-\n-    public static VaList ofAddress(long address, SegmentScope scope) {\n-        return readFromAddress(address, scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) segment.scope();\n-        sessionImpl.checkValidState();\n-        return new LinuxRISCV64VaList(segment, offset);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public long address() {\n-        return segment.address() + offset;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"LinuxRISCV64VaList{\" + \"seg: \" + address() + \", \" + \"offset: \" + offset + '}';\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope scope;\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n-\n-        Builder(SegmentScope scope) {\n-            this.scope = scope;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            stackArgs.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        boolean isEmpty() {\n-            return stackArgs.isEmpty();\n-        }\n-\n-        public VaList build() {\n-            if (isEmpty()) {\n-                return EMPTY;\n-            }\n-            long stackArgsSize = 0;\n-            for (SimpleVaArg arg : stackArgs) {\n-                MemoryLayout layout = arg.layout;\n-                long elementSize = TypeClass.classifyLayout(layout) == TypeClass.STRUCT_REFERENCE ?\n-                    ADDRESS.byteSize() : layout.byteSize();\n-                \/\/ arguments with 2 * XLEN-bit alignment and size at most 2 * XLEN bits\n-                \/\/ are saved on memory aligned with 2 * XLEN (XLEN=64 for RISCV64).\n-                if (layout.byteSize() <= 16 && layout.byteAlignment() == 16) {\n-                    stackArgsSize = Utils.alignUp(stackArgsSize, 16);\n-                    elementSize = 16;\n-                }\n-                stackArgsSize += Utils.alignUp(elementSize, STACK_SLOT_SIZE);\n-            }\n-            MemorySegment argsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n-            MemorySegment writeCursor = argsSegment;\n-            for (SimpleVaArg arg : stackArgs) {\n-                MemoryLayout layout;\n-                Object value = arg.value;\n-                if (TypeClass.classifyLayout(arg.layout) == TypeClass.STRUCT_REFERENCE) {\n-                    layout = ADDRESS;\n-                } else {\n-                    layout = arg.layout;\n-                }\n-                long alignedSize = Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE);\n-                if (layout.byteSize() <= 16 && layout.byteAlignment() == 16) {\n-                    writeCursor = Utils.alignUp(writeCursor, 16);\n-                    alignedSize = 16;\n-                }\n-                if (layout instanceof GroupLayout) {\n-                    writeCursor.copyFrom((MemorySegment) value);\n-                } else {\n-                    VarHandle writer = layout.varHandle();\n-                    writer.set(writeCursor, value);\n-                }\n-                writeCursor = writeCursor.asSlice(alignedSize);\n-            }\n-            return new LinuxRISCV64VaList(argsSegment, 0L);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64VaList.java","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-public class X86_64Architecture implements Architecture {\n+public final class X86_64Architecture implements Architecture {\n@@ -51,0 +51,3 @@\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private X86_64Architecture() {}\n+\n@@ -157,1 +160,3 @@\n-                IntStream.range(0, numX87Outputs).mapToObj(X86_64Architecture::x87Storage).toArray(VMStorage[]::new)\n+                IntStream.range(0, numX87Outputs)\n+                         .mapToObj(X86_64Architecture::x87Storage)\n+                         .toArray(VMStorage[]::new)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.AddressLayout;\n@@ -46,0 +46,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -52,1 +53,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.SysV;\n@@ -68,0 +68,5 @@\n+    \/**\n+     * The {@code long} native type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n@@ -100,1 +105,1 @@\n-            MemoryLayout layout = SysV.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -116,1 +121,1 @@\n-            csb.addArgumentBindings(long.class, SysV.C_LONG,\n+            csb.addArgumentBindings(long.class, C_LONG,\n@@ -136,2 +141,2 @@\n-    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n@@ -317,0 +322,1 @@\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n@@ -319,1 +325,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,479 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign.abi.x64.sysv;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.SysV;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n-\n-\/\/ See https:\/\/software.intel.com\/sites\/default\/files\/article\/402129\/mpx-linux64-abi.pdf \"3.5.7 Variable Argument Lists\"\n-public non-sealed class SysVVaList implements VaList {\n-\n-\/\/    struct typedef __va_list_tag __va_list_tag {\n-\/\/        unsigned int               gp_offset;            \/*     0     4 *\/\n-\/\/        unsigned int               fp_offset;            \/*     4     4 *\/\n-\/\/        void *                     overflow_arg_area;    \/*     8     8 *\/\n-\/\/        void *                     reg_save_area;        \/*    16     8 *\/\n-\/\/\n-\/\/        \/* size: 24, cachelines: 1, members: 4 *\/\n-\/\/        \/* last cacheline: 24 bytes *\/\n-\/\/    };\n-    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n-        SysV.C_INT.withName(\"gp_offset\"),\n-        SysV.C_INT.withName(\"fp_offset\"),\n-        SysV.C_POINTER.withName(\"overflow_arg_area\"),\n-        SysV.C_POINTER.withName(\"reg_save_area\")\n-    ).withName(\"__va_list_tag\");\n-\n-    private static final long STACK_SLOT_SIZE = 8;\n-\n-    private static final MemoryLayout GP_REG = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n-    private static final MemoryLayout FP_REG = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n-\n-    private static final GroupLayout LAYOUT_REG_SAVE_AREA = MemoryLayout.structLayout(\n-        GP_REG.withName(\"%rdi\"),\n-        GP_REG.withName(\"%rsi\"),\n-        GP_REG.withName(\"%rdx\"),\n-        GP_REG.withName(\"%rcx\"),\n-        GP_REG.withName(\"%r8\"),\n-        GP_REG.withName(\"%r9\"),\n-        FP_REG.withName(\"%xmm0\"),\n-        FP_REG.withName(\"%xmm1\"),\n-        FP_REG.withName(\"%xmm2\"),\n-        FP_REG.withName(\"%xmm3\"),\n-        FP_REG.withName(\"%xmm4\"),\n-        FP_REG.withName(\"%xmm5\"),\n-        FP_REG.withName(\"%xmm6\"),\n-        FP_REG.withName(\"%xmm7\")\n-\/\/ specification and implementation differ as to whether the following are part of a reg save area\n-\/\/ Let's go with the implementation, since then it actually works :)\n-\/\/        FP_REG.withName(\"%xmm8\"),\n-\/\/        FP_REG.withName(\"%xmm9\"),\n-\/\/        FP_REG.withName(\"%xmm10\"),\n-\/\/        FP_REG.withName(\"%xmm11\"),\n-\/\/        FP_REG.withName(\"%xmm12\"),\n-\/\/        FP_REG.withName(\"%xmm13\"),\n-\/\/        FP_REG.withName(\"%xmm14\"),\n-\/\/        FP_REG.withName(\"%xmm15\")\n-    );\n-\n-    private static final long FP_OFFSET = LAYOUT_REG_SAVE_AREA.byteOffset(groupElement(\"%xmm0\"));\n-\n-    private static final int GP_SLOT_SIZE = (int) GP_REG.byteSize();\n-    private static final int FP_SLOT_SIZE = (int) FP_REG.byteSize();\n-\n-    private static final int MAX_GP_OFFSET = (int) FP_OFFSET; \/\/ 6 regs used\n-    private static final int MAX_FP_OFFSET = (int) LAYOUT_REG_SAVE_AREA.byteSize(); \/\/ 8 16 byte regs\n-\n-    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(groupElement(\"fp_offset\"));\n-    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(groupElement(\"gp_offset\"));\n-    private static final VarHandle VH_overflow_arg_area = LAYOUT.varHandle(groupElement(\"overflow_arg_area\"));\n-    private static final VarHandle VH_reg_save_area = LAYOUT.varHandle(groupElement(\"reg_save_area\"));\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(emptyListAddress());\n-\n-    private final MemorySegment segment;\n-    private MemorySegment overflowArgArea;\n-    private final MemorySegment regSaveArea;\n-    private final long gpLimit;\n-    private final long fpLimit;\n-\n-    private SysVVaList(MemorySegment segment,\n-                       MemorySegment overflowArgArea,\n-                       MemorySegment regSaveArea, long gpLimit, long fpLimit) {\n-        this.segment = segment;\n-        this.overflowArgArea = overflowArgArea;\n-        this.regSaveArea = regSaveArea;\n-        this.gpLimit = gpLimit;\n-        this.fpLimit = fpLimit;\n-    }\n-\n-    private static SysVVaList readFromAddress(long address, SegmentScope scope) {\n-        MemorySegment segment = MemorySegment.ofAddress(address, LAYOUT.byteSize(), scope);\n-        MemorySegment regSaveArea = getRegSaveArea(segment);\n-        MemorySegment overflowArgArea = getArgOverflowArea(segment);\n-        return new SysVVaList(segment, overflowArgArea, regSaveArea, MAX_GP_OFFSET, MAX_FP_OFFSET);\n-    }\n-\n-    private static MemorySegment emptyListAddress() {\n-        MemorySegment base = MemorySegment.allocateNative(LAYOUT, SegmentScope.global());\n-        VH_gp_offset.set(base, MAX_GP_OFFSET);\n-        VH_fp_offset.set(base, MAX_FP_OFFSET);\n-        VH_overflow_arg_area.set(base, MemorySegment.NULL);\n-        VH_reg_save_area.set(base, MemorySegment.NULL);\n-        return base.asSlice(0, 0);\n-    }\n-\n-    public static VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    private int currentGPOffset() {\n-        return (int) VH_gp_offset.get(segment);\n-    }\n-\n-    private void currentGPOffset(int i) {\n-        VH_gp_offset.set(segment, i);\n-    }\n-\n-    private int currentFPOffset() {\n-        return (int) VH_fp_offset.get(segment);\n-    }\n-\n-    private void currentFPOffset(int i) {\n-        VH_fp_offset.set(segment, i);\n-    }\n-\n-    private static MemorySegment getRegSaveArea(MemorySegment segment) {\n-        return ((MemorySegment)VH_reg_save_area.get(segment))\n-                .asSlice(0, LAYOUT_REG_SAVE_AREA.byteSize());\n-    }\n-\n-    private static MemorySegment getArgOverflowArea(MemorySegment segment) {\n-        return (MemorySegment)VH_overflow_arg_area.get(segment); \/\/ size unknown\n-    }\n-\n-    private long preAlignOffset(MemoryLayout layout) {\n-        long alignmentOffset = 0;\n-        if (layout.byteAlignment() > STACK_SLOT_SIZE) {\n-            long addr = overflowArgArea.address();\n-            alignmentOffset = Utils.alignUp(addr, 16) - addr;\n-        }\n-        return alignmentOffset;\n-    }\n-\n-    private void setOverflowArgArea(MemorySegment newSegment) {\n-        overflowArgArea = newSegment;\n-        VH_overflow_arg_area.set(segment, overflowArgArea);\n-    }\n-\n-    private void preAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(preAlignOffset(layout)));\n-    }\n-\n-    private void postAlignStack(MemoryLayout layout) {\n-        setOverflowArgArea(overflowArgArea.asSlice(Utils.alignUp(layout.byteSize(), STACK_SLOT_SIZE)));\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        TypeClass typeClass = TypeClass.classifyLayout(layout);\n-        if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)\n-                || typeClass.inMemory()) {\n-            checkStackElement(layout);\n-            preAlignStack(layout);\n-            return switch (typeClass.kind()) {\n-                case STRUCT -> {\n-                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(slice);\n-                    postAlignStack(layout);\n-                    yield seg;\n-                }\n-                case POINTER, INTEGER, FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    MemorySegment slice = overflowArgArea.asSlice(0, layout.byteSize());\n-                    Object res = reader.get(slice);\n-                    postAlignStack(layout);\n-                    yield res;\n-                }\n-            };\n-        } else {\n-            checkRegSaveAreaElement(layout, typeClass);\n-            return switch (typeClass.kind()) {\n-                case STRUCT -> {\n-                    MemorySegment value = allocator.allocate(layout);\n-                    int classIdx = 0;\n-                    long offset = 0;\n-                    while (offset < layout.byteSize()) {\n-                        final long copy = Math.min(layout.byteSize() - offset, 8);\n-                        boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;\n-                        if (isSSE) {\n-                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n-                            currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);\n-                        } else {\n-                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n-                            currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);\n-                        }\n-                        offset += copy;\n-                    }\n-                    yield value;\n-                }\n-                case POINTER, INTEGER -> {\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(regSaveArea.asSlice(currentGPOffset()));\n-                    currentGPOffset(currentGPOffset() + GP_SLOT_SIZE);\n-                    yield res;\n-                }\n-                case FLOAT -> {\n-                    VarHandle reader = layout.varHandle();\n-                    Object res = reader.get(regSaveArea.asSlice(currentFPOffset()));\n-                    currentFPOffset(currentFPOffset() + FP_SLOT_SIZE);\n-                    yield res;\n-                }\n-            };\n-        }\n-    }\n-\n-    private void checkRegSaveAreaElement(MemoryLayout layout, TypeClass typeClass) {\n-        long gpSize = typeClass.nIntegerRegs() * GP_SLOT_SIZE;\n-        long fpSize = typeClass.nVectorRegs() * FP_SLOT_SIZE;\n-        if (currentGPOffset() + gpSize > gpLimit\n-            || currentFPOffset() + fpSize > fpLimit) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    private void checkStackElement(MemoryLayout layout) {\n-        long offset = preAlignOffset(layout);\n-        if (offset + layout.byteSize() > overflowArgArea.byteSize()) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset(), currentFPOffset(), typeClass)) {\n-                checkStackElement(layout);\n-                preAlignStack(layout);\n-                postAlignStack(layout);\n-            } else {\n-                checkRegSaveAreaElement(layout, typeClass);\n-                currentGPOffset(currentGPOffset() + (((int) typeClass.nIntegerRegs()) * GP_SLOT_SIZE));\n-                currentFPOffset(currentFPOffset() + (((int) typeClass.nVectorRegs()) * FP_SLOT_SIZE));\n-            }\n-        }\n-    }\n-\n-    static SysVVaList.Builder builder(SegmentScope scope) {\n-        return new SysVVaList.Builder(scope);\n-    }\n-\n-    public static VaList ofAddress(long address, SegmentScope scope) {\n-        return readFromAddress(address, scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n-        copy.copyFrom(segment);\n-        return new SysVVaList(copy, overflowArgArea, regSaveArea, gpLimit, fpLimit);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    private static boolean isRegOverflow(long currentGPOffset, long currentFPOffset, TypeClass typeClass) {\n-        return currentGPOffset > MAX_GP_OFFSET - typeClass.nIntegerRegs() * GP_SLOT_SIZE\n-                || currentFPOffset > MAX_FP_OFFSET - typeClass.nVectorRegs() * FP_SLOT_SIZE;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"SysVVaList{\"\n-               + \"gp_offset=\" + currentGPOffset()\n-               + \", fp_offset=\" + currentFPOffset()\n-               + \", overflow_arg_area=\" + overflowArgArea\n-               + \", reg_save_area=\" + regSaveArea\n-               + '}';\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-        private final SegmentScope scope;\n-        private final MemorySegment reg_save_area;\n-        private long currentGPOffset = 0;\n-        private long currentFPOffset = FP_OFFSET;\n-        private final List<SimpleVaArg> stackArgs = new ArrayList<>();\n-\n-        public Builder(SegmentScope scope) {\n-            this.scope = scope;\n-            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            TypeClass typeClass = TypeClass.classifyLayout(layout);\n-            if (isRegOverflow(currentGPOffset, currentFPOffset, typeClass)\n-                    || typeClass.inMemory()) {\n-                \/\/ stack it!\n-                stackArgs.add(new SimpleVaArg(layout, value));\n-            } else {\n-                switch (typeClass.kind()) {\n-                    case STRUCT -> {\n-                        MemorySegment valueSegment = (MemorySegment) value;\n-                        int classIdx = 0;\n-                        long offset = 0;\n-                        while (offset < layout.byteSize()) {\n-                            final long copy = Math.min(layout.byteSize() - offset, 8);\n-                            boolean isSSE = typeClass.classes.get(classIdx++) == ArgumentClassImpl.SSE;\n-                            if (isSSE) {\n-                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n-                                currentFPOffset += FP_SLOT_SIZE;\n-                            } else {\n-                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n-                                currentGPOffset += GP_SLOT_SIZE;\n-                            }\n-                            offset += copy;\n-                        }\n-                    }\n-                    case POINTER, INTEGER -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(reg_save_area.asSlice(currentGPOffset), value);\n-                        currentGPOffset += GP_SLOT_SIZE;\n-                    }\n-                    case FLOAT -> {\n-                        VarHandle writer = layout.varHandle();\n-                        writer.set(reg_save_area.asSlice(currentFPOffset), value);\n-                        currentFPOffset += FP_SLOT_SIZE;\n-                    }\n-                }\n-            }\n-            return this;\n-        }\n-\n-        private boolean isEmpty() {\n-            return currentGPOffset == 0 && currentFPOffset == FP_OFFSET && stackArgs.isEmpty();\n-        }\n-\n-        public VaList build() {\n-            if (isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment vaListSegment = MemorySegment.allocateNative(LAYOUT, scope);\n-            MemorySegment stackArgsSegment;\n-            if (!stackArgs.isEmpty()) {\n-                long stackArgsSize = stackArgs.stream().reduce(0L,\n-                        (acc, e) -> acc + Utils.alignUp(e.layout.byteSize(), STACK_SLOT_SIZE), Long::sum);\n-                stackArgsSegment = MemorySegment.allocateNative(stackArgsSize, 16, scope);\n-                MemorySegment writeCursor = stackArgsSegment;\n-                for (SimpleVaArg arg : stackArgs) {\n-                    if (arg.layout.byteSize() > 8) {\n-                        writeCursor = Utils.alignUp(writeCursor, Math.min(16, arg.layout.byteSize()));\n-                    }\n-                    if (arg.layout instanceof GroupLayout) {\n-                        writeCursor.copyFrom((MemorySegment) arg.value);\n-                    } else {\n-                        VarHandle writer = arg.varHandle();\n-                        writer.set(writeCursor, arg.value);\n-                    }\n-                    writeCursor = writeCursor.asSlice(Utils.alignUp(arg.layout.byteSize(), STACK_SLOT_SIZE));\n-                }\n-            } else {\n-                stackArgsSegment = MemorySegment.NULL;\n-            }\n-\n-            VH_fp_offset.set(vaListSegment, (int) FP_OFFSET);\n-            VH_overflow_arg_area.set(vaListSegment, stackArgsSegment);\n-            VH_reg_save_area.set(vaListSegment, reg_save_area);\n-            assert MemorySessionImpl.sameOwnerThread(reg_save_area.scope(), vaListSegment.scope());\n-            return new SysVVaList(vaListSegment, stackArgsSegment, reg_save_area, currentGPOffset, currentFPOffset);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":0,"deletions":479,"binary":false,"changes":479,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -33,1 +32,0 @@\n-import java.lang.foreign.VaList;\n@@ -36,1 +34,0 @@\n-import java.util.function.Consumer;\n@@ -61,16 +58,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return CallArranger.arrangeUpcall(targetType, function);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        SysVVaList.Builder builder = SysVVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return SysVVaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return SysVVaList.empty();\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.AddressLayout;\n@@ -45,0 +45,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -50,1 +51,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.Win64;\n@@ -107,1 +107,1 @@\n-            MemoryLayout layout = Win64.C_POINTER;\n+            MemoryLayout layout = SharedUtils.C_POINTER;\n@@ -135,2 +135,2 @@\n-    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n-        Bindings bindings = getBindings(mt, cDesc, true);\n+    public static UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc, LinkerOptions options) {\n+        Bindings bindings = getBindings(mt, cDesc, true, options);\n@@ -268,0 +268,1 @@\n+                    AddressLayout addressLayout = (AddressLayout) layout;\n@@ -270,1 +271,1 @@\n-                            .boxAddressRaw(Utils.pointeeSize(layout));\n+                            .boxAddressRaw(Utils.pointeeByteSize(addressLayout), Utils.pointeeByteAlign(addressLayout));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign.abi.x64.windows;\n-\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n-\n-import jdk.internal.foreign.MemorySessionImpl;\n-import jdk.internal.foreign.abi.SharedUtils;\n-import jdk.internal.foreign.abi.SharedUtils.SimpleVaArg;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import static jdk.internal.foreign.PlatformLayouts.Win64.C_POINTER;\n-\n-\/\/ see vadefs.h (VC header)\n-\/\/\n-\/\/ in short\n-\/\/ -> va_list is just a pointer to a buffer with 64 bit entries.\n-\/\/ -> non-power-of-two-sized, or larger than 64 bit types passed by reference.\n-\/\/ -> other types passed in 64 bit slots by normal function calling convention.\n-\/\/\n-\/\/ X64 va_arg impl:\n-\/\/\n-\/\/    typedef char* va_list;\n-\/\/\n-\/\/    #define __crt_va_arg(ap, t)                                               \\\n-\/\/        ((sizeof(t) > sizeof(__int64) || (sizeof(t) & (sizeof(t) - 1)) != 0) \\\n-\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))             \\\n-\/\/            :  *(t* )((ap += sizeof(__int64)) - sizeof(__int64)))\n-\/\/\n-public non-sealed class WinVaList implements VaList {\n-    private static final long VA_SLOT_SIZE_BYTES = 8;\n-    private static final VarHandle VH_address = C_POINTER.varHandle();\n-\n-    private static final VaList EMPTY = new SharedUtils.EmptyVaList(MemorySegment.NULL);\n-\n-    private MemorySegment segment;\n-\n-    private WinVaList(MemorySegment segment) {\n-        this.segment = segment;\n-    }\n-\n-    public static final VaList empty() {\n-        return EMPTY;\n-    }\n-\n-    @Override\n-    public int nextVarg(ValueLayout.OfInt layout) {\n-        return (int) read(layout);\n-    }\n-\n-    @Override\n-    public long nextVarg(ValueLayout.OfLong layout) {\n-        return (long) read(layout);\n-    }\n-\n-    @Override\n-    public double nextVarg(ValueLayout.OfDouble layout) {\n-        return (double) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(ValueLayout.OfAddress layout) {\n-        return (MemorySegment) read(layout);\n-    }\n-\n-    @Override\n-    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(allocator);\n-        return (MemorySegment) read(layout, allocator);\n-    }\n-\n-    private Object read(MemoryLayout layout) {\n-        return read(layout, SharedUtils.THROWING_ALLOCATOR);\n-    }\n-\n-    private Object read(MemoryLayout layout, SegmentAllocator allocator) {\n-        Objects.requireNonNull(layout);\n-        Object res;\n-        checkElement(layout);\n-        if (layout instanceof GroupLayout) {\n-            TypeClass typeClass = TypeClass.typeClassFor(layout, false);\n-            res = switch (typeClass) {\n-                case STRUCT_REFERENCE -> {\n-                    MemorySegment structAddr = (MemorySegment) VH_address.get(segment);\n-                    MemorySegment struct = MemorySegment.ofAddress(structAddr.address(), layout.byteSize(), segment.scope());\n-                    MemorySegment seg = allocator.allocate(layout);\n-                    seg.copyFrom(struct);\n-                    yield seg;\n-                }\n-                case STRUCT_REGISTER ->\n-                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n-                default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-            };\n-        } else {\n-            VarHandle reader = layout.varHandle();\n-            res = reader.get(segment);\n-        }\n-        segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        return res;\n-    }\n-\n-    private void checkElement(MemoryLayout layout) {\n-        if (segment.byteSize() < VA_SLOT_SIZE_BYTES) {\n-            throw SharedUtils.newVaListNSEE(layout);\n-        }\n-    }\n-\n-    @Override\n-    public void skip(MemoryLayout... layouts) {\n-        Objects.requireNonNull(layouts);\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        for (MemoryLayout layout : layouts) {\n-            Objects.requireNonNull(layout);\n-            checkElement(layout);\n-            segment = segment.asSlice(VA_SLOT_SIZE_BYTES);\n-        }\n-    }\n-\n-    static WinVaList ofAddress(long address, SegmentScope scope) {\n-        return new WinVaList(MemorySegment.ofAddress(address, Long.MAX_VALUE, scope));\n-    }\n-\n-    static Builder builder(SegmentScope scope) {\n-        return new Builder(scope);\n-    }\n-\n-    @Override\n-    public VaList copy() {\n-        ((MemorySessionImpl) segment.scope()).checkValidState();\n-        return new WinVaList(segment);\n-    }\n-\n-    @Override\n-    public MemorySegment segment() {\n-        \/\/ make sure that returned segment cannot be accessed\n-        return segment.asSlice(0, 0);\n-    }\n-\n-    public static non-sealed class Builder implements VaList.Builder {\n-\n-        private final SegmentScope scope;\n-        private final List<SimpleVaArg> args = new ArrayList<>();\n-\n-        public Builder(SegmentScope scope) {\n-            ((MemorySessionImpl) scope).checkValidState();\n-            this.scope = scope;\n-        }\n-\n-        private Builder arg(MemoryLayout layout, Object value) {\n-            Objects.requireNonNull(layout);\n-            Objects.requireNonNull(value);\n-            args.add(new SimpleVaArg(layout, value));\n-            return this;\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(ValueLayout.OfAddress layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        @Override\n-        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n-            return arg(layout, value);\n-        }\n-\n-        public VaList build() {\n-            if (args.isEmpty()) {\n-                return EMPTY;\n-            }\n-\n-            MemorySegment segment = MemorySegment.allocateNative(VA_SLOT_SIZE_BYTES * args.size(), scope);\n-            MemorySegment cursor = segment;\n-\n-            for (SimpleVaArg arg : args) {\n-                if (arg.layout instanceof GroupLayout) {\n-                    MemorySegment msArg = ((MemorySegment) arg.value);\n-                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout, false);\n-                    switch (typeClass) {\n-                        case STRUCT_REFERENCE -> {\n-                            MemorySegment copy = MemorySegment.allocateNative(arg.layout, scope);\n-                            copy.copyFrom(msArg); \/\/ by-value\n-                            VH_address.set(cursor, copy);\n-                        }\n-                        case STRUCT_REGISTER ->\n-                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n-                        default -> throw new IllegalStateException(\"Unexpected TypeClass: \" + typeClass);\n-                    }\n-                } else {\n-                    VarHandle writer = arg.varHandle();\n-                    writer.set(cursor, arg.value);\n-                }\n-                cursor = cursor.asSlice(VA_SLOT_SIZE_BYTES);\n-            }\n-\n-            return new WinVaList(segment);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -31,3 +31,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n@@ -36,1 +33,0 @@\n-import java.util.function.Consumer;\n@@ -61,16 +57,2 @@\n-    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n-        return CallArranger.arrangeUpcall(targetType, function);\n-    }\n-\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n-        WinVaList.Builder builder = WinVaList.builder(scope);\n-        actions.accept(builder);\n-        return builder.build();\n-    }\n-\n-    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n-        return WinVaList.ofAddress(address, scope);\n-    }\n-\n-    public static VaList emptyVaList() {\n-        return WinVaList.empty();\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.arrangeUpcall(targetType, function, options);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,9 +91,5 @@\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof AbstractGroupLayout<?> otherGroup &&\n-                kind == otherGroup.kind &&\n-                elements.equals(otherGroup.elements);\n+        return this == other ||\n+                other instanceof AbstractGroupLayout<?> otherGroup &&\n+                        super.equals(other) &&\n+                        kind == otherGroup.kind &&\n+                        elements.equals(otherGroup.elements);\n@@ -148,1 +144,1 @@\n-                    .orElse(1); \/\/ or minimal alignment if no member layout is given\n+                    .orElse(8); \/\/ or minimal alignment if no member layout is given\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractGroupLayout.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n@@ -44,2 +40,2 @@\n-    private final long bitSize;\n-    private final long bitAlignment;\n+    private final long byteSize;\n+    private final long byteAlignment;\n@@ -47,2 +43,0 @@\n-    @Stable\n-    private long byteSize;\n@@ -51,3 +45,3 @@\n-        this.bitSize = bitSize;\n-        this.bitAlignment = bitAlignment;\n-        this.name = name;\n+        this.byteSize = MemoryLayoutUtil.requireBitSizeValid(bitSize, true) \/ 8;\n+        this.byteAlignment = requirePowerOfTwoAndGreaterOrEqualToEight(bitAlignment) \/ 8;\n+        this.name = Objects.requireNonNull(name);\n@@ -57,2 +51,5 @@\n-        Objects.requireNonNull(name);\n-        return dup(bitAlignment, Optional.of(name));\n+        return dup(bitAlignment(), Optional.of(name));\n+    }\n+\n+    public final L withoutName() {\n+        return dup(bitAlignment(), Optional.empty());\n@@ -66,1 +63,0 @@\n-        checkAlignment(bitAlignment);\n@@ -71,1 +67,5 @@\n-        return bitAlignment;\n+        return byteAlignment * 8;\n+    }\n+\n+    public final long byteAlignment() {\n+        return byteAlignment;\n@@ -74,1 +74,0 @@\n-    @ForceInline\n@@ -76,4 +75,0 @@\n-        if (byteSize == 0) {\n-            byteSize = Utils.bitsToBytesOrThrow(bitSize(),\n-                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-        }\n@@ -84,1 +79,1 @@\n-        return bitSize;\n+        return byteSize * 8;\n@@ -88,1 +83,1 @@\n-        return bitSize == bitAlignment;\n+        return byteSize == byteAlignment;\n@@ -99,1 +94,1 @@\n-        return Objects.hash(name, bitSize, bitAlignment);\n+        return Objects.hash(name, byteSize, byteAlignment);\n@@ -121,4 +116,0 @@\n-        if (this == other) {\n-            return true;\n-        }\n-\n@@ -127,2 +118,2 @@\n-                bitSize == otherLayout.bitSize &&\n-                bitAlignment == otherLayout.bitAlignment;\n+                byteSize == otherLayout.byteSize &&\n+                byteAlignment == otherLayout.byteAlignment;\n@@ -134,0 +125,1 @@\n+    @Override\n@@ -136,1 +128,1 @@\n-    abstract L dup(long alignment, Optional<String> name);\n+    abstract L dup(long bitAlignment, Optional<String> name);\n@@ -143,1 +135,1 @@\n-            s = bitAlignment + \"%\" + s;\n+            s = bitAlignment() + \"%\" + s;\n@@ -148,4 +140,4 @@\n-    private static void checkAlignment(long alignmentBitCount) {\n-        if (((alignmentBitCount & (alignmentBitCount - 1)) != 0L) || \/\/alignment must be a power of two\n-                (alignmentBitCount < 8)) { \/\/alignment must be greater than 8\n-            throw new IllegalArgumentException(\"Invalid alignment: \" + alignmentBitCount);\n+    private static long requirePowerOfTwoAndGreaterOrEqualToEight(long value) {\n+        if (((value & (value - 1)) != 0L) || \/\/ value must be a power of two\n+                (value < 8)) { \/\/ value must be greater or equal to 8\n+            throw new IllegalArgumentException(\"Invalid alignment: \" + value);\n@@ -153,0 +145,1 @@\n+        return value;\n@@ -155,1 +148,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,5 @@\n-    public static void checkSize(long size) {\n-        checkSize(size, false);\n+    public static long requireNonNegative(long value) {\n+        if (value < 0) {\n+            throw new IllegalArgumentException(\"The provided value was negative: \" + value);\n+        }\n+        return value;\n@@ -37,3 +40,3 @@\n-    public static void checkSize(long size, boolean includeZero) {\n-        if (size < 0 || (!includeZero && size == 0)) {\n-            throw new IllegalArgumentException(\"Invalid size for layout: \" + size);\n+    public static long requireBitSizeValid(long bitSize, boolean allowZero) {\n+        if ((bitSize == 0 && !allowZero) || bitSize < 0 || bitSize % 8 != 0) {\n+            throw new IllegalArgumentException(\"Invalid bitSize: \" + bitSize);\n@@ -41,0 +44,1 @@\n+        return bitSize;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/MemoryLayoutUtil.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-        this(bitSize, 1, Optional.empty());\n+        this(bitSize, 8, Optional.empty());\n@@ -49,10 +49,4 @@\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        if (!(other instanceof PaddingLayoutImpl p)) {\n-            return false;\n-        }\n-        return bitSize() == p.bitSize();\n+        return this == other ||\n+                other instanceof PaddingLayoutImpl otherPadding &&\n+                super.equals(other) &&\n+                bitSize() == otherPadding.bitSize();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/PaddingLayoutImpl.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,0 @@\n-        MemoryLayoutUtil.checkSize(elementCount, true);\n@@ -180,0 +179,1 @@\n+        boolean max = (Long.MAX_VALUE \/ elementLayout.bitSize()) == elemCount;\n@@ -181,1 +181,1 @@\n-                elemCount, elementLayout));\n+                max ? \"*\" : elemCount, elementLayout));\n@@ -186,9 +186,5 @@\n-        if (this == other) {\n-            return true;\n-        }\n-        if (!super.equals(other)) {\n-            return false;\n-        }\n-        return other instanceof SequenceLayoutImpl otherSeq &&\n-                elemCount == otherSeq.elemCount &&\n-                elementLayout.equals(otherSeq.elementLayout);\n+        return this == other ||\n+                other instanceof SequenceLayoutImpl otherSeq &&\n+                        super.equals(other) &&\n+                        elemCount == otherSeq.elemCount &&\n+                        elementLayout.equals(otherSeq.elementLayout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/SequenceLayoutImpl.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -61,2 +62,2 @@\n-    private ValueLayouts() {\n-    }\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private ValueLayouts() {}\n@@ -73,4 +74,0 @@\n-        AbstractValueLayout(Class<?> carrier, ByteOrder order, long bitSize) {\n-            this(carrier, order, bitSize, bitSize, Optional.empty());\n-        }\n-\n@@ -81,1 +78,1 @@\n-            checkCarrierSize(carrier, bitSize);\n+            assertCarrierSize(carrier, bitSize);\n@@ -98,1 +95,4 @@\n-        abstract V withOrder(ByteOrder order);\n+        public final V withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return dup(order, bitAlignment(), name());\n+        }\n@@ -101,2 +101,2 @@\n-        public final String toString() {\n-            char descriptor = carrier == MemorySegment.class ? 'A' : carrier.descriptorString().charAt(0);\n+        public String toString() {\n+            char descriptor = carrier.descriptorString().charAt(0);\n@@ -111,9 +111,5 @@\n-            if (this == other) {\n-                return true;\n-            }\n-            if (!super.equals(other)) {\n-                return false;\n-            }\n-            return other instanceof AbstractValueLayout<?> otherValue &&\n-                    carrier.equals(otherValue.carrier) &&\n-                    order.equals(otherValue.order);\n+            return this == other ||\n+                    other instanceof AbstractValueLayout<?> otherValue &&\n+                            super.equals(other) &&\n+                            carrier.equals(otherValue.carrier) &&\n+                            order.equals(otherValue.order);\n@@ -150,1 +146,3 @@\n-        abstract V dup(long bitAlignment, Optional<String> name);\n+        final V dup(long bitAlignment, Optional<String> name) {\n+            return dup(order(), bitAlignment, name);\n+        }\n@@ -152,13 +150,10 @@\n-        static void checkCarrierSize(Class<?> carrier, long size) {\n-            if (!isValidCarrier(carrier)) {\n-                throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n-            }\n-            if (carrier == MemorySegment.class && size != ADDRESS_SIZE_BITS) {\n-                throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n-            }\n-            if (carrier.isPrimitive()) {\n-                int expectedSize = carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n-                if (size != expectedSize) {\n-                    throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n-                }\n-            }\n+        abstract V dup(ByteOrder order, long bitAlignment, Optional<String> name);\n+\n+        static void assertCarrierSize(Class<?> carrier, long bitSize) {\n+            assert isValidCarrier(carrier);\n+            assert carrier != MemorySegment.class\n+                    \/\/ MemorySegment bitSize must always equal ADDRESS_SIZE_BITS\n+                    || bitSize == ADDRESS_SIZE_BITS;\n+            assert !carrier.isPrimitive() ||\n+                    \/\/ Primitive class bitSize must always correspond\n+                    bitSize == (carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth());\n@@ -168,0 +163,1 @@\n+            \/\/ void.class is not valid\n@@ -179,1 +175,0 @@\n-\n@@ -197,4 +192,0 @@\n-        private OfBooleanImpl(ByteOrder order) {\n-            super(boolean.class, order, 8);\n-        }\n-\n@@ -202,1 +193,1 @@\n-            super(boolean.class, order, 8, bitAlignment, name);\n+            super(boolean.class, order, Byte.SIZE, bitAlignment, name);\n@@ -206,8 +197,2 @@\n-        OfBooleanImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfBooleanImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfBooleanImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfBooleanImpl(order, bitAlignment(), name());\n+        OfBooleanImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfBooleanImpl(order, bitAlignment, name);\n@@ -217,1 +202,1 @@\n-            return new OfBooleanImpl(order);\n+            return new OfBooleanImpl(order, Byte.SIZE, Optional.empty());\n@@ -223,4 +208,0 @@\n-        private OfByteImpl(ByteOrder order) {\n-            super(byte.class, order, 8);\n-        }\n-\n@@ -228,1 +209,1 @@\n-            super(byte.class, order, 8, bitAlignment, name);\n+            super(byte.class, order, Byte.SIZE, bitAlignment, name);\n@@ -232,8 +213,2 @@\n-        OfByteImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfByteImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfByteImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfByteImpl(order, bitAlignment(), name());\n+        OfByteImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfByteImpl(order, bitAlignment, name);\n@@ -243,1 +218,1 @@\n-            return new OfByteImpl(order);\n+            return new OfByteImpl(order, Byte.SIZE, Optional.empty());\n@@ -249,4 +224,0 @@\n-        private OfCharImpl(ByteOrder order) {\n-            super(char.class, order, 16);\n-        }\n-\n@@ -254,1 +225,1 @@\n-            super(char.class, order, 16, bitAlignment, name);\n+            super(char.class, order, Character.SIZE, bitAlignment, name);\n@@ -258,8 +229,2 @@\n-        OfCharImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfCharImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfCharImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfCharImpl(order, bitAlignment(), name());\n+        OfCharImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfCharImpl(order, bitAlignment, name);\n@@ -269,1 +234,1 @@\n-            return new OfCharImpl(order);\n+            return new OfCharImpl(order, Character.SIZE, Optional.empty());\n@@ -275,4 +240,0 @@\n-        private OfShortImpl(ByteOrder order) {\n-            super(short.class, order, 16);\n-        }\n-\n@@ -280,1 +241,1 @@\n-            super(short.class, order, 16, bitAlignment, name);\n+            super(short.class, order, Short.SIZE, bitAlignment, name);\n@@ -284,8 +245,2 @@\n-        OfShortImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfShortImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfShortImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfShortImpl(order, bitAlignment(), name());\n+        OfShortImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfShortImpl(order, bitAlignment, name);\n@@ -295,1 +250,1 @@\n-            return new OfShortImpl(order);\n+            return new OfShortImpl(order, Short.SIZE, Optional.empty());\n@@ -301,4 +256,0 @@\n-        private OfIntImpl(ByteOrder order) {\n-            super(int.class, order, 32);\n-        }\n-\n@@ -306,1 +257,1 @@\n-            super(int.class, order, 32, bitAlignment, name);\n+            super(int.class, order, Integer.SIZE, bitAlignment, name);\n@@ -310,8 +261,2 @@\n-        OfIntImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfIntImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfIntImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfIntImpl(order, bitAlignment(), name());\n+        OfIntImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfIntImpl(order, bitAlignment, name);\n@@ -321,1 +266,1 @@\n-            return new OfIntImpl(order);\n+            return new OfIntImpl(order, Integer.SIZE, Optional.empty());\n@@ -327,4 +272,0 @@\n-        private OfFloatImpl(ByteOrder order) {\n-            super(float.class, order, 32);\n-        }\n-\n@@ -332,1 +273,1 @@\n-            super(float.class, order, 32, bitAlignment, name);\n+            super(float.class, order, Float.SIZE, bitAlignment, name);\n@@ -336,8 +277,2 @@\n-        OfFloatImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfFloatImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfFloatImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfFloatImpl(order, bitAlignment(), name());\n+        OfFloatImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfFloatImpl(order, bitAlignment, name);\n@@ -347,1 +282,1 @@\n-            return new OfFloatImpl(order);\n+            return new OfFloatImpl(order, Float.SIZE, Optional.empty());\n@@ -353,4 +288,0 @@\n-        private OfLongImpl(ByteOrder order) {\n-            super(long.class, order, 64);\n-        }\n-\n@@ -358,6 +289,1 @@\n-            super(long.class, order, 64, bitAlignment, name);\n-        }\n-\n-        @Override\n-        OfLongImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfLongImpl(order(), bitAlignment, name);\n+            super(long.class, order, Long.SIZE, bitAlignment, name);\n@@ -367,3 +293,2 @@\n-        public OfLongImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfLongImpl(order, bitAlignment(), name());\n+        OfLongImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfLongImpl(order, bitAlignment, name);\n@@ -373,1 +298,1 @@\n-            return new OfLongImpl(order);\n+            return new OfLongImpl(order, Long.SIZE, Optional.empty());\n@@ -379,4 +304,0 @@\n-        private OfDoubleImpl(ByteOrder order) {\n-            super(double.class, order, 64);\n-        }\n-\n@@ -384,1 +305,1 @@\n-            super(double.class, order, 64, bitAlignment, name);\n+            super(double.class, order, Double.SIZE, bitAlignment, name);\n@@ -388,8 +309,2 @@\n-        OfDoubleImpl dup(long bitAlignment, Optional<String> name) {\n-            return new OfDoubleImpl(order(), bitAlignment, name);\n-        }\n-\n-        @Override\n-        public OfDoubleImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfDoubleImpl(order, bitAlignment(), name());\n+        OfDoubleImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfDoubleImpl(order, bitAlignment, name);\n@@ -399,1 +314,1 @@\n-            return new OfDoubleImpl(order);\n+            return new OfDoubleImpl(order, Double.SIZE, Optional.empty());\n@@ -404,8 +319,1 @@\n-    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements ValueLayout.OfAddress {\n-\n-        private final boolean isUnbounded;\n-\n-        private OfAddressImpl(ByteOrder order) {\n-            super(MemorySegment.class, order, ADDRESS_SIZE_BITS);\n-            this.isUnbounded = false; \/\/ safe\n-        }\n+    public static final class OfAddressImpl extends AbstractValueLayout<OfAddressImpl> implements AddressLayout {\n@@ -413,4 +321,1 @@\n-        private OfAddressImpl(ByteOrder order, long size, long bitAlignment, boolean isUnbounded, Optional<String> name) {\n-            super(MemorySegment.class, order, size, bitAlignment, name);\n-            this.isUnbounded = isUnbounded;\n-        }\n+        private final MemoryLayout targetLayout;\n@@ -418,3 +323,3 @@\n-        @Override\n-        OfAddressImpl dup(long alignment, Optional<String> name) {\n-            return new OfAddressImpl(order(), bitSize(), alignment, isUnbounded, name);\n+        private OfAddressImpl(ByteOrder order, long bitSize, long bitAlignment, MemoryLayout targetLayout, Optional<String> name) {\n+            super(MemorySegment.class, order, bitSize, bitAlignment, name);\n+            this.targetLayout = targetLayout;\n@@ -424,3 +329,2 @@\n-        public OfAddressImpl withOrder(ByteOrder order) {\n-            Objects.requireNonNull(order);\n-            return new OfAddressImpl(order, bitSize(), bitAlignment(), isUnbounded, name());\n+        OfAddressImpl dup(ByteOrder order, long bitAlignment, Optional<String> name) {\n+            return new OfAddressImpl(order, bitSize(), bitAlignment,targetLayout, name);\n@@ -432,1 +336,1 @@\n-                    ((OfAddressImpl) other).isUnbounded == this.isUnbounded;\n+                    Objects.equals(((OfAddressImpl)other).targetLayout, this.targetLayout);\n@@ -437,1 +341,1 @@\n-            return Objects.hash(super.hashCode(), isUnbounded);\n+            return Objects.hash(super.hashCode(), targetLayout);\n@@ -442,3 +346,4 @@\n-        public OfAddress asUnbounded() {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), OfAddress.class, \"asUnbounded\");\n-            return new OfAddressImpl(order(), bitSize(), bitAlignment(), true, name());\n+        public AddressLayout withTargetLayout(MemoryLayout layout) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n+            Objects.requireNonNull(layout);\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), layout, name());\n@@ -448,2 +353,2 @@\n-        public boolean isUnbounded() {\n-            return isUnbounded;\n+        public AddressLayout withoutTargetLayout() {\n+            return new OfAddressImpl(order(), bitSize(), bitAlignment(), null, name());\n@@ -452,2 +357,20 @@\n-        public static OfAddress of(ByteOrder order) {\n-            return new OfAddressImpl(order);\n+        @Override\n+        public Optional<MemoryLayout> targetLayout() {\n+            return Optional.ofNullable(targetLayout);\n+        }\n+\n+        public static AddressLayout of(ByteOrder order) {\n+            return new OfAddressImpl(order, ADDRESS_SIZE_BITS, ADDRESS_SIZE_BITS, null, Optional.empty());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            char descriptor = 'A';\n+            if (order() == ByteOrder.LITTLE_ENDIAN) {\n+                descriptor = Character.toLowerCase(descriptor);\n+            }\n+            String str = decorateLayoutString(String.format(\"%s%d\", descriptor, bitSize()));\n+            if (targetLayout != null) {\n+                str += \":\" + targetLayout;\n+            }\n+            return str;\n@@ -457,0 +380,44 @@\n+    \/**\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemorySegment.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n+     * @param order the value layout's byte order.\n+     * @return a value layout with the given Java carrier and byte-order.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n+     *\/\n+    public static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(order);\n+        if (carrier == boolean.class) {\n+            return ValueLayouts.OfBooleanImpl.of(order);\n+        } else if (carrier == char.class) {\n+            return ValueLayouts.OfCharImpl.of(order);\n+        } else if (carrier == byte.class) {\n+            return ValueLayouts.OfByteImpl.of(order);\n+        } else if (carrier == short.class) {\n+            return ValueLayouts.OfShortImpl.of(order);\n+        } else if (carrier == int.class) {\n+            return ValueLayouts.OfIntImpl.of(order);\n+        } else if (carrier == float.class) {\n+            return ValueLayouts.OfFloatImpl.of(order);\n+        } else if (carrier == long.class) {\n+            return ValueLayouts.OfLongImpl.of(order);\n+        } else if (carrier == double.class) {\n+            return ValueLayouts.OfDoubleImpl.of(order);\n+        } else if (carrier == MemorySegment.class) {\n+            return ValueLayouts.OfAddressImpl.of(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":141,"deletions":174,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+\/**\n+ * Defines a static method to test if the VM has support for the foreign java.lang.foreign.Linker.\n+ *\/\n+public class ForeignLinkerSupport {\n+    private static final boolean SUPPORTED = isSupported0();\n+\n+    private ForeignLinkerSupport() {\n+    }\n+\n+    \/**\n+     * Return true if the VM has support for the foreign Linker.\n+     *\/\n+    public static boolean isSupported() {\n+        return SUPPORTED;\n+    }\n+\n+    \/**\n+     * Ensures that VM has support for the foreign Linker.\n+     * @throws UnsupportedOperationException if not supported\n+     *\/\n+    public static void ensureSupported() {\n+        if (!isSupported()) {\n+            throw new UnsupportedOperationException(\"VM does not support linker\");\n+        }\n+    }\n+\n+    private static native boolean isSupported0();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ForeignLinkerSupport.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -1211,1 +1211,1 @@\n-                             SegmentScope session)\n+                             Arena arena)\n@@ -1215,2 +1215,2 @@\n-        Objects.requireNonNull(session, \"Session is null\");\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n+        Objects.requireNonNull(arena, \"Arena is null\");\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toMemorySession(arena);\n@@ -1233,1 +1233,1 @@\n-                                            readOnly, session);\n+                                            readOnly, sessionImpl);\n@@ -1244,1 +1244,1 @@\n-            return new MappedMemorySegmentImpl.EmptyMappedMemorySegmentImpl(readOnly, sessionImpl);\n+            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jdk_internal_foreign_abi_fallback_LibFallback.h\"\n+\n+#include <ffi.h>\n+\n+#include <errno.h>\n+#ifdef _WIN64\n+#include <Windows.h>\n+#include <Winsock2.h>\n+#endif\n+\n+#include \"jlong.h\"\n+\n+static JavaVM* VM;\n+static jclass LibFallback_class;\n+static jmethodID LibFallback_doUpcall_ID;\n+static const char* LibFallback_doUpcall_sig = \"(JJLjava\/lang\/invoke\/MethodHandle;)V\";\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_init(JNIEnv* env, jclass cls) {\n+  (*env)->GetJavaVM(env, &VM);\n+  LibFallback_class = (*env)->FindClass(env, \"jdk\/internal\/foreign\/abi\/fallback\/LibFallback\");\n+  LibFallback_doUpcall_ID = (*env)->GetStaticMethodID(env,\n+    LibFallback_class, \"doUpcall\", LibFallback_doUpcall_sig);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_sizeofCif(JNIEnv* env, jclass cls) {\n+  return sizeof(ffi_cif);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1prep_1cif(JNIEnv* env, jclass cls, jlong cif, jint abi, jint nargs, jlong rtype, jlong atypes) {\n+  return ffi_prep_cif(jlong_to_ptr(cif), (ffi_abi) abi, (unsigned int) nargs, jlong_to_ptr(rtype), jlong_to_ptr(atypes));\n+}\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1get_1struct_1offsets(JNIEnv* env, jclass cls, jint abi, jlong type, jlong offsets) {\n+  return ffi_get_struct_offsets((ffi_abi) abi, jlong_to_ptr(type), jlong_to_ptr(offsets));\n+}\n+\n+static void do_capture_state(int32_t* value_ptr, int captured_state_mask) {\n+    \/\/ keep in synch with jdk.internal.foreign.abi.CapturableState\n+  enum PreservableValues {\n+    NONE = 0,\n+    GET_LAST_ERROR = 1,\n+    WSA_GET_LAST_ERROR = 1 << 1,\n+    ERRNO = 1 << 2\n+  };\n+#ifdef _WIN64\n+  if (captured_state_mask & GET_LAST_ERROR) {\n+    *value_ptr = GetLastError();\n+  }\n+  value_ptr++;\n+  if (captured_state_mask & WSA_GET_LAST_ERROR) {\n+    *value_ptr = WSAGetLastError();\n+  }\n+  value_ptr++;\n+#endif\n+  if (captured_state_mask & ERRNO) {\n+    *value_ptr = errno;\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_doDowncall(JNIEnv* env, jclass cls, jlong cif, jlong fn, jlong rvalue, jlong avalues, jlong jcaptured_state, jint captured_state_mask) {\n+  ffi_call(jlong_to_ptr(cif), jlong_to_ptr(fn), jlong_to_ptr(rvalue), jlong_to_ptr(avalues));\n+\n+  if (captured_state_mask != 0) {\n+    int32_t* captured_state = jlong_to_ptr(jcaptured_state);\n+    do_capture_state(captured_state, captured_state_mask);\n+  }\n+}\n+\n+static void do_upcall(ffi_cif* cif, void* ret, void** args, void* user_data) {\n+  \/\/ attach thread\n+  JNIEnv* env;\n+  jint result = (*VM)->AttachCurrentThreadAsDaemon(VM, (void**) &env, NULL);\n+\n+  \/\/ call into doUpcall in LibFallback\n+  jobject upcall_data = (jobject) user_data;\n+  (*env)->CallStaticVoidMethod(env, LibFallback_class, LibFallback_doUpcall_ID,\n+    ptr_to_jlong(ret), ptr_to_jlong(args), upcall_data);\n+\n+  \/\/ always detach for now\n+  (*VM)->DetachCurrentThread(VM);\n+}\n+\n+static void free_closure(JNIEnv* env, void* closure, jobject upcall_data) {\n+  ffi_closure_free(closure);\n+  (*env)->DeleteGlobalRef(env, upcall_data);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_createClosure(JNIEnv* env, jclass cls, jlong cif, jobject upcall_data, jlongArray jptrs) {\n+  void* code;\n+  void* closure = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+\n+  jobject global_upcall_data = (*env)->NewGlobalRef(env, upcall_data);\n+\n+  ffi_status status = ffi_prep_closure_loc(closure, jlong_to_ptr(cif), &do_upcall, (void*) global_upcall_data, code);\n+\n+  if (status != FFI_OK) {\n+    free_closure(env,closure, global_upcall_data);\n+    return status;\n+  }\n+\n+  jlong* ptrs = (*env)->GetLongArrayElements(env, jptrs, NULL);\n+  ptrs[0] = ptr_to_jlong(closure);\n+  ptrs[1] = ptr_to_jlong(code);\n+  ptrs[2] = ptr_to_jlong(global_upcall_data);\n+  (*env)->ReleaseLongArrayElements(env, jptrs, ptrs, JNI_COMMIT);\n+\n+  return status;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_freeClosure(JNIEnv* env, jclass cls, jlong closure, jlong upcall_data) {\n+  free_closure(env, jlong_to_ptr(closure), jlong_to_ptr(upcall_data));\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1default_1abi(JNIEnv* env, jclass cls) {\n+  return (jint) FFI_DEFAULT_ABI;\n+}\n+\n+JNIEXPORT jshort JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1struct(JNIEnv* env, jclass cls) {\n+  return (jshort) FFI_TYPE_STRUCT;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1void(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_void);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint8(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint8);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint8(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint8);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint16(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint16);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint16(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint16);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint32(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint32);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint32(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint32);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1uint64(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_uint64);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1sint64(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_sint64);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1float(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_float);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1double(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_double);\n+}\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_foreign_abi_fallback_LibFallback_ffi_1type_1pointer(JNIEnv* env, jclass cls) {\n+  return ptr_to_jlong(&ffi_type_pointer);\n+}\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_vm_ForeignLinkerSupport.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_vm_ForeignLinkerSupport_isSupported0(JNIEnv *env, jclass cls) {\n+    return JVM_IsForeignLinkerSupported();\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/ForeignLinkerSupport.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -362,0 +362,1 @@\n+    jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.*;\n@@ -27,5 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n@@ -54,6 +50,6 @@\n-        try (Arena arena0 = Arena.openConfined()) {\n-            callFunc(loadLibrary(arena0.scope()));\n-            try (Arena arena1 = Arena.openConfined()) {\n-                callFunc(loadLibrary(arena1.scope()));\n-                try (Arena arena2 = Arena.openConfined()) {\n-                    callFunc(loadLibrary(arena2.scope()));\n+        try (Arena arena0 = Arena.ofConfined()) {\n+            callFunc(loadLibrary(arena0));\n+            try (Arena arena1 = Arena.ofConfined()) {\n+                callFunc(loadLibrary(arena1));\n+                try (Arena arena2 = Arena.ofConfined()) {\n+                    callFunc(loadLibrary(arena2));\n@@ -68,2 +64,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            addr = loadLibrary(arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            addr = loadLibrary(arena);\n@@ -74,1 +70,1 @@\n-    private static MemorySegment loadLibrary(SegmentScope session) {\n+    private static MemorySegment loadLibrary(Arena session) {\n@@ -77,1 +73,1 @@\n-        assertEquals(addr.scope(), session);\n+        assertEquals(addr.scope(), session.scope());\n@@ -97,1 +93,1 @@\n-        SymbolLookup.libraryLookup(\"nonExistent\", SegmentScope.global());\n+        SymbolLookup.libraryLookup(\"nonExistent\", Arena.global());\n@@ -102,1 +98,1 @@\n-        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), SegmentScope.global());\n+        SymbolLookup.libraryLookup(Path.of(\"nonExistent\"), Arena.global());\n@@ -119,2 +115,2 @@\n-                try (Arena arena = Arena.openConfined()) {\n-                    callFunc(loadLibrary(arena.scope()));\n+                try (Arena arena = Arena.ofConfined()) {\n+                    callFunc(loadLibrary(arena));\n@@ -128,2 +124,2 @@\n-        Arena arena = Arena.openShared();\n-        MemorySegment addr = loadLibrary(arena.scope());\n+        Arena arena = Arena.ofShared();\n+        MemorySegment addr = loadLibrary(arena);\n","filename":"test\/jdk\/java\/foreign\/LibraryLookupTest.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            case OfAddress oa -> 0; \/\/ leaf\n+            case AddressLayout oa -> 0; \/\/ leaf\n@@ -103,1 +103,1 @@\n-            case OfAddress oa -> 0; \/\/ leaf\n+            case AddressLayout oa -> 0; \/\/ leaf\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutPrincipalTotalityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,2 +44,4 @@\n-    private static final long BIT_ALIGNMENT = 64;\n-    private static final ByteOrder BYTE_ORDER = ByteOrder.LITTLE_ENDIAN;\n+    private static final long BIT_ALIGNMENT = Long.SIZE * 2;\n+    private static final ByteOrder BYTE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN\n+            ? ByteOrder.LITTLE_ENDIAN\n+            : ByteOrder.BIG_ENDIAN;\n@@ -51,0 +53,1 @@\n+                .withoutName()\n@@ -60,0 +63,1 @@\n+                .withoutName()\n@@ -69,0 +73,1 @@\n+                .withoutName()\n@@ -78,0 +83,1 @@\n+                .withoutName()\n@@ -87,0 +93,1 @@\n+                .withoutName()\n@@ -96,0 +103,1 @@\n+                .withoutName()\n@@ -105,0 +113,1 @@\n+                .withoutName()\n@@ -114,0 +123,1 @@\n+                .withoutName()\n@@ -120,2 +130,2 @@\n-    public void testOfAddress() {\n-        OfAddress v = ADDRESS\n+    public void testValueLayout() {\n+        ValueLayout v = ((ValueLayout) JAVA_INT)\n@@ -123,0 +133,1 @@\n+                .withoutName()\n@@ -126,3 +137,18 @@\n-        assertFalse(v.isUnbounded());\n-        OfAddress v2 = v.asUnbounded();\n-        assertTrue(v2.isUnbounded());\n+    }\n+\n+    @Test\n+    public void testAddressLayout() {\n+        AddressLayout v = ADDRESS\n+                .withBitAlignment(BIT_ALIGNMENT)\n+                .withoutName()\n+                .withName(NAME)\n+                .withoutTargetLayout()\n+                .withOrder(BYTE_ORDER);\n+        check(v);\n+        assertEquals(v.order(), BYTE_ORDER);\n+\n+        assertFalse(v.targetLayout().isPresent());\n+        AddressLayout v2 = v.withTargetLayout(JAVA_INT);\n+        assertTrue(v2.targetLayout().isPresent());\n+        assertEquals(v2.targetLayout().get(), JAVA_INT);\n+        assertTrue(v2.withoutTargetLayout().targetLayout().isEmpty());\n@@ -135,0 +161,1 @@\n+                .withoutName()\n@@ -143,0 +170,1 @@\n+                .withoutName()\n@@ -151,0 +179,1 @@\n+                .withoutName()\n@@ -159,0 +188,1 @@\n+                .withoutName()\n@@ -169,0 +199,1 @@\n+        \/\/ Check name properties\n@@ -170,0 +201,2 @@\n+        assertTrue(v.withoutName().name().isEmpty());\n+\n","filename":"test\/jdk\/java\/foreign\/MemoryLayoutTypeRetentionTest.java","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -33,1 +34,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -124,1 +124,2 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64).asUnbounded();\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64)\n+            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -161,1 +162,1 @@\n-            return LINKER.upcallStub(target, descriptor, SegmentScope.auto());\n+            return LINKER.upcallStub(target, descriptor, Arena.ofAuto());\n@@ -212,1 +213,1 @@\n-        } else if (layout instanceof ValueLayout.OfAddress) {\n+        } else if (layout instanceof AddressLayout) {\n@@ -290,1 +291,1 @@\n-        return LINKER.upcallStub(target, fd, arena.scope());\n+        return LINKER.upcallStub(target, fd, arena);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -42,1 +41,0 @@\n-import java.lang.foreign.VaList;\n@@ -61,1 +59,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -79,1 +77,1 @@\n-                Arena arena = Arena.openShared();\n+                Arena arena = Arena.ofShared();\n@@ -115,14 +113,0 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testClosedVaList() throws Throwable {\n-        VaList list;\n-        try (Arena arena = Arena.openConfined()) {\n-            list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n-        }\n-        assertFalse(list.segment().scope().isAlive());\n-        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"addr_func\"),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n-\n-        handle.invokeExact(list.segment());\n-    }\n-\n@@ -132,1 +116,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -134,1 +118,1 @@\n-            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n+            upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena);\n@@ -146,12 +130,0 @@\n-    @Test\n-    public void testClosedVaListCallback() throws Throwable {\n-        MethodHandle handle = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"addr_func_cb\"),\n-                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), arena.scope());\n-            handle.invokeExact(list.segment(), sessionChecker(arena));\n-        }\n-    }\n-\n@@ -164,1 +136,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -176,1 +148,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -178,1 +150,1 @@\n-            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena.scope());\n+            MemorySegment upcall = Linker.nativeLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), arena);\n@@ -188,1 +160,1 @@\n-            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), SegmentScope.auto());\n+            return Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), Arena.ofAuto());\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":8,"deletions":36,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.util.function.BiConsumer;\n@@ -138,15 +137,0 @@\n-    @Test(dataProvider = \"printfArgs\")\n-    void test_vprintf(List<PrintfArg> args) throws Throwable {\n-        String formatArgs = args.stream()\n-                .map(a -> a.format)\n-                .collect(Collectors.joining(\",\"));\n-\n-        String formatString = \"hello(\" + formatArgs + \")\\n\";\n-\n-        String expected = String.format(formatString, args.stream()\n-                .map(a -> a.javaValue).toArray());\n-\n-        int found = stdLibHelper.vprintf(formatString, args);\n-        assertEquals(found, expected.length());\n-    }\n-\n@@ -168,1 +152,1 @@\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+                FunctionDescriptor.of(C_POINTER.withTargetLayout(Tm.LAYOUT), C_POINTER));\n@@ -173,1 +157,2 @@\n-        final static FunctionDescriptor qsortComparFunction = FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER);\n+        final static FunctionDescriptor qsortComparFunction = FunctionDescriptor.of(C_INT,\n+                C_POINTER.withTargetLayout(C_INT), C_POINTER.withTargetLayout(C_INT));\n@@ -198,1 +183,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -207,1 +192,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -215,1 +200,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -222,1 +207,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -229,1 +214,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -241,1 +226,12 @@\n-            static final long SIZE = 56;\n+            static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n+                    C_INT.withName(\"sec\"),\n+                    C_INT.withName(\"min\"),\n+                    C_INT.withName(\"hour\"),\n+                    C_INT.withName(\"mday\"),\n+                    C_INT.withName(\"mon\"),\n+                    C_INT.withName(\"year\"),\n+                    C_INT.withName(\"wday\"),\n+                    C_INT.withName(\"yday\"),\n+                    C_BOOL.withName(\"isdst\"),\n+                    MemoryLayout.paddingLayout(24)\n+            );\n@@ -244,1 +240,1 @@\n-                this.base = addr.asSlice(0, SIZE);\n+                this.base = addr;\n@@ -278,1 +274,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -282,1 +278,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena.scope());\n+                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, arena);\n@@ -301,1 +297,1 @@\n-            try (var arena = Arena.openConfined()) {\n+            try (var arena = Arena.ofConfined()) {\n@@ -308,8 +304,0 @@\n-        int vprintf(String format, List<PrintfArg> args) throws Throwable {\n-            try (var arena = Arena.openConfined()) {\n-                MemorySegment formatStr = arena.allocateUtf8String(format);\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, arena)), arena.scope());\n-                return (int)vprintf.invokeExact(formatStr, vaList.segment());\n-            }\n-        }\n-\n@@ -387,1 +375,1 @@\n-    enum PrintfArg implements BiConsumer<VaList.Builder, Arena> {\n+    enum PrintfArg {\n@@ -389,1 +377,1 @@\n-        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42, VaList.Builder::addVarg),\n+        INTEGRAL(int.class, C_INT, \"%d\", arena -> 42, 42),\n@@ -392,3 +380,3 @@\n-        }, \"str\", VaList.Builder::addVarg),\n-        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n-        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n+        }, \"str\"),\n+        CHAR(byte.class, C_CHAR, \"%c\", arena -> (byte) 'h', 'h'),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", arena ->1.2345d, 1.2345d);\n@@ -401,2 +389,0 @@\n-        @SuppressWarnings(\"rawtypes\")\n-        final VaListBuilderCall builderCall;\n@@ -404,1 +390,1 @@\n-        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<Arena, Z> nativeValueFactory, Object javaValue) {\n@@ -410,11 +396,0 @@\n-            this.builderCall = builderCall;\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void accept(VaList.Builder builder, Arena arena) {\n-            builderCall.build(builder, layout, nativeValueFactory.apply(arena));\n-        }\n-\n-        interface VaListBuilderCall<V, L> {\n-            void build(VaList.Builder builder, L layout, V value);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":30,"deletions":55,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -34,4 +34,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n+\n@@ -97,1 +95,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -116,1 +115,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -137,1 +137,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -194,2 +195,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(ValueLayout.JAVA_INT);\n@@ -205,2 +206,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = arena.allocate(ValueLayout.JAVA_INT);\n@@ -214,1 +215,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -257,1 +259,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -295,1 +298,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -334,1 +338,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -377,1 +382,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ *  Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestAddressDereference\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.testng.annotations.*;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestAddressDereference extends UpcallTestHelper {\n+\n+    static final Linker LINKER = Linker.nativeLinker();\n+    static final MemorySegment GET_ADDR_SYM;\n+    static final MethodHandle GET_ADDR_CB_HANDLE, TEST_ARG_HANDLE;\n+\n+    static {\n+        System.loadLibrary(\"AddressDereference\");\n+        GET_ADDR_SYM = SymbolLookup.loaderLookup().find(\"get_addr\").get();\n+        GET_ADDR_CB_HANDLE = LINKER.downcallHandle(\n+                SymbolLookup.loaderLookup().find(\"get_addr_cb\").get(),\n+                FunctionDescriptor.ofVoid(ValueLayout.ADDRESS, ValueLayout.ADDRESS));\n+        try {\n+            TEST_ARG_HANDLE = MethodHandles.lookup().findStatic(TestAddressDereference.class, \"testArg\",\n+                    MethodType.methodType(void.class, MemorySegment.class, long.class));\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testGetAddress(long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(ValueLayout.ADDRESS);\n+            segment.set(ValueLayout.ADDRESS, 0, MemorySegment.ofAddress(alignment));\n+            MemorySegment deref = segment.get(ValueLayout.ADDRESS.withTargetLayout(layout), 0);\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testGetAddressIndex(long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(ValueLayout.ADDRESS);\n+            segment.set(ValueLayout.ADDRESS, 0, MemorySegment.ofAddress(alignment));\n+            MemorySegment deref = segment.getAtIndex(ValueLayout.ADDRESS.withTargetLayout(layout), 0);\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeReturn(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try {\n+            MethodHandle get_addr_handle = LINKER.downcallHandle(GET_ADDR_SYM,\n+                    FunctionDescriptor.of(ValueLayout.ADDRESS.withTargetLayout(layout), ValueLayout.ADDRESS));\n+            MemorySegment deref = (MemorySegment)get_addr_handle.invokeExact(MemorySegment.ofAddress(alignment));\n+            assertFalse(badAlign);\n+            assertEquals(deref.byteSize(), layout.byteSize());\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"alignment constraint for address\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeUpcallArgPos(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        if (badAlign) return; \/\/ this will crash the JVM (exception occurs when going into the upcall stub)\n+        try (Arena arena = Arena.ofConfined()) {\n+            FunctionDescriptor testDesc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withTargetLayout(layout));\n+            MethodHandle upcallHandle = MethodHandles.insertArguments(TEST_ARG_HANDLE, 1, layout.byteSize());\n+            MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena);\n+            GET_ADDR_CB_HANDLE.invokeExact(MemorySegment.ofAddress(alignment), testStub);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"layoutsAndAlignments\")\n+    public void testNativeUpcallArgNeg(long alignment, ValueLayout layout) throws Throwable {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        if (!badAlign) return;\n+        runInNewProcess(UpcallTestRunner.class, true,\n+                new String[] {Long.toString(alignment), layout.toString() })\n+                .assertStdErrContains(\"alignment constraint for address\");\n+    }\n+\n+    public static class UpcallTestRunner {\n+        public static void main(String[] args) throws Throwable {\n+            long alignment = parseAlignment(args[0]);\n+            ValueLayout layout = parseLayout(args[1]);\n+            try (Arena arena = Arena.ofConfined()) {\n+                FunctionDescriptor testDesc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS.withTargetLayout(layout));\n+                MethodHandle upcallHandle = MethodHandles.insertArguments(TEST_ARG_HANDLE, 1, layout.byteSize());\n+                MemorySegment testStub = LINKER.upcallStub(upcallHandle, testDesc, arena);\n+                GET_ADDR_CB_HANDLE.invokeExact(MemorySegment.ofAddress(alignment), testStub);\n+            }\n+        }\n+\n+        static long parseAlignment(String s) {\n+            return Long.parseLong(s);\n+        }\n+\n+        static ValueLayout parseLayout(String s) {\n+            return LayoutKind.parse(s).layout;\n+        }\n+    }\n+\n+    static void testArg(MemorySegment deref, long expectedSize) {\n+        assertEquals(deref.byteSize(), expectedSize);\n+    }\n+\n+    @DataProvider(name = \"layoutsAndAlignments\")\n+    static Object[][] layoutsAndAlignments() {\n+        List<Object[]> layoutsAndAlignments = new ArrayList<>();\n+        for (LayoutKind lk : LayoutKind.values()) {\n+            for (int align : new int[]{ 1, 2, 4, 8 }) {\n+                layoutsAndAlignments.add(new Object[] { align, lk.layout });\n+            }\n+        }\n+        return layoutsAndAlignments.toArray(Object[][]::new);\n+    }\n+\n+    enum LayoutKind {\n+        BOOL(ValueLayout.JAVA_BOOLEAN),\n+        CHAR(ValueLayout.JAVA_CHAR),\n+        SHORT(ValueLayout.JAVA_SHORT),\n+        INT(ValueLayout.JAVA_INT),\n+        FLOAT(ValueLayout.JAVA_FLOAT),\n+        LONG(ValueLayout.JAVA_LONG),\n+        DOUBLE(ValueLayout.JAVA_DOUBLE),\n+        ADDRESS(ValueLayout.ADDRESS);\n+\n+\n+        final ValueLayout layout;\n+\n+        LayoutKind(ValueLayout segment) {\n+            this.layout = segment;\n+        }\n+\n+        static LayoutKind parse(String layoutString) {\n+            return switch (layoutString.charAt(0)) {\n+                case 'A','a' -> ADDRESS;\n+                case 'z','Z' -> BOOL;\n+                case 'c','C' -> CHAR;\n+                case 's','S' -> SHORT;\n+                case 'i','I' -> INT;\n+                case 'f','F' -> FLOAT;\n+                case 'j','J' -> LONG;\n+                case 'd','D' -> DOUBLE;\n+                default -> throw new AssertionError(\"Invalid layout string: \" + layoutString);\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestAddressDereference.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -31,2 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -34,3 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n@@ -111,1 +107,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -122,1 +119,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, seq.byteSize(), SegmentScope.global());\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(seq.byteSize());\n@@ -130,2 +127,4 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            long byteSize = layout.byteSize() + 1;\n+            long byteAlignment = layout.byteSize();\n+            MemorySegment segment = arena.allocate(byteSize, byteAlignment);\n@@ -139,2 +138,2 @@\n-        Arena arena = Arena.openConfined();\n-        MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment segment = arena.allocate(layout);\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -35,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n@@ -40,1 +36,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -188,2 +183,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(tuples, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(tuples);;\n@@ -233,1 +228,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -235,1 +230,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena);\n@@ -239,1 +234,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -241,1 +236,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 8L, arena);\n@@ -252,1 +247,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -255,1 +250,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, tuples.byteSize(), arena);\n@@ -260,1 +255,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -263,1 +258,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena);\n@@ -274,1 +269,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -276,1 +271,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 8L, arena);\n@@ -293,1 +288,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -296,1 +291,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, i, tuples.byteSize(), arena);\n@@ -304,1 +299,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -307,1 +302,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, tuples.byteSize(), arena);\n@@ -313,0 +308,36 @@\n+    @Test(dataProvider = \"fromArrays\")\n+    public void testAsByteBufferFromNonByteArray(MemorySegment segment) {\n+        if (!segment.heapBase().map(a -> a instanceof byte[]).get()) {\n+            \/\/ This should not work as the segment is not backed by a byte array\n+            assertThrows(UnsupportedOperationException.class, segment::asByteBuffer);\n+        }\n+    }\n+\n+    @Test\n+    public void testMappedSegmentAsByteBuffer() throws Throwable {\n+        File f = new File(\"test4.out\");\n+        assertTrue(f.createNewFile());\n+        f.deleteOnExit();\n+\n+        for (var mapOption : List.of(FileChannel.MapMode.READ_WRITE, FileChannel.MapMode.READ_ONLY, FileChannel.MapMode.PRIVATE)) {\n+            for (var arena : List.of(Arena.ofConfined(), Arena.global())) {\n+                try (FileChannel fileChannel = FileChannel.open(f.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                    \/\/write to channel\n+                    MemorySegment segment = fileChannel.map(mapOption, 0L, 32L, arena);\n+                    segment.force();\n+                    segment.load();\n+                    segment.isLoaded();\n+                    segment.unload();\n+                    ByteBuffer byteBuffer = segment.asByteBuffer();\n+                    assertEquals(byteBuffer.capacity(), segment.byteSize());\n+                    assertEquals(byteBuffer.isReadOnly(), segment.isReadOnly());\n+                    assertTrue(byteBuffer.isDirect());\n+                } finally {\n+                    if (arena.scope() != Arena.global().scope()) {\n+                        arena.close();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -325,1 +356,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -327,1 +358,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, LARGE_SIZE, arena);\n@@ -363,2 +394,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -389,2 +420,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -423,2 +454,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(bytes);;\n@@ -436,2 +467,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -474,2 +505,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -485,2 +516,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            leaked = MemorySegment.allocateNative(bytes, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            leaked = arena.allocate(bytes);;\n@@ -494,1 +525,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(0, Integer.MAX_VALUE + 10L, SegmentScope.auto());\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(Integer.MAX_VALUE + 10L);\n@@ -504,1 +535,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, -1L, Arena.ofAuto());\n@@ -514,1 +545,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, -1L, 1L, Arena.ofAuto());\n@@ -526,1 +557,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -528,1 +559,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SIZE, arena);\n@@ -536,1 +567,1 @@\n-            try (Arena arena = Arena.openConfined();\n+            try (Arena arena = Arena.ofConfined();\n@@ -538,1 +569,1 @@\n-                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena.scope());\n+                MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, offset, SIZE - offset, arena);\n@@ -550,1 +581,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -552,1 +583,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, arena);\n@@ -560,0 +591,3 @@\n+            ByteBuffer byteBuffer = segment.asByteBuffer();\n+            assertEquals(byteBuffer.capacity(), 0);\n+            assertFalse(byteBuffer.isReadOnly());\n@@ -562,1 +596,1 @@\n-        try (Arena arena = Arena.openConfined();\n+        try (Arena arena = Arena.ofConfined();\n@@ -564,1 +598,1 @@\n-            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena.scope());\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0L, 0L, arena);\n@@ -572,0 +606,3 @@\n+            ByteBuffer byteBuffer = segment.asByteBuffer();\n+            assertEquals(byteBuffer.capacity(), 0);\n+            assertTrue(byteBuffer.isReadOnly());\n@@ -579,1 +616,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, SegmentScope.auto());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 0L, Arena.ofAuto());\n@@ -587,2 +624,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment nativeArray = arena.allocate(bytes, 1);;\n@@ -600,2 +637,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment nativeArray = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment nativeArray = arena.allocate(seq);;\n@@ -672,2 +709,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment ms = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment ms = arena.allocate(4, 1);;\n@@ -676,0 +713,1 @@\n+            assertEquals(msRoundTrip.scope(), ms.scope());\n@@ -680,0 +718,15 @@\n+    @Test(dataProvider = \"bufferFactories\")\n+    public void testDerivedBufferScopes(Supplier<Buffer> bufferFactory) {\n+        MemorySegment segment = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertEquals(segment.scope(), segment.scope());\n+        \/\/ one level\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        \/\/ two levels\n+        assertEquals(segment.asSlice(0).asReadOnly().scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().asSlice(0).scope(), segment.scope());\n+        \/\/ check fresh every time\n+        MemorySegment another = MemorySegment.ofBuffer(bufferFactory.get());\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n@@ -682,2 +735,2 @@\n-        Arena arena = Arena.openConfined();\n-        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        MemorySegment s1 = arena.allocate(JAVA_INT);\n@@ -698,1 +751,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());;\n+            MemorySegment segment = arena.allocate(10, 1);;\n@@ -719,1 +772,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(10, arena.scope());\n+            MemorySegment segment = arena.allocate(10, 1);\n@@ -736,2 +789,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(16, 1);;\n@@ -754,2 +807,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(16, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(16, 1);;\n@@ -765,2 +818,2 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, SegmentScope.auto()) },\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, Arena.openConfined().scope()) },\n+                { (Supplier<MemorySegment>) () -> Arena.ofAuto().allocate(16, 1)},\n+                { (Supplier<MemorySegment>) () -> Arena.ofConfined().allocate(16, 1)},\n@@ -774,2 +827,2 @@\n-                { (Supplier<Arena>) Arena::openConfined },\n-                { (Supplier<Arena>) Arena::openShared },\n+                { (Supplier<Arena>) Arena::ofConfined},\n+                { (Supplier<Arena>) Arena::ofShared},\n@@ -972,1 +1025,1 @@\n-        private Consumer<MemorySegment> segmentOp;\n+        private final Consumer<MemorySegment> segmentOp;\n@@ -989,0 +1042,37 @@\n+\n+    @DataProvider(name = \"bufferFactories\")\n+    public static Object[][] bufferFactories() {\n+        List<Supplier<Buffer>> l = List.of(\n+                () -> ByteBuffer.allocate(10),\n+                () -> CharBuffer.allocate(10),\n+                () -> ShortBuffer.allocate(10),\n+                () -> IntBuffer.allocate(10),\n+                () -> FloatBuffer.allocate(10),\n+                () -> LongBuffer.allocate(10),\n+                () -> DoubleBuffer.allocate(10),\n+                () -> ByteBuffer.allocateDirect(10),\n+                () -> ByteBuffer.allocateDirect(10).asCharBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asShortBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asIntBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asFloatBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asLongBuffer(),\n+                () -> ByteBuffer.allocateDirect(10).asDoubleBuffer()\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+\n+    }\n+    @DataProvider(name = \"fromArrays\")\n+    public static Object[][] fromArrays() {\n+        int len = 16;\n+        return Stream.of(\n+                        MemorySegment.ofArray(new byte[len]),\n+                        MemorySegment.ofArray(new short[len]),\n+                        MemorySegment.ofArray(new char[len]),\n+                        MemorySegment.ofArray(new int[len]),\n+                        MemorySegment.ofArray(new long[len]),\n+                        MemorySegment.ofArray(new float[len]),\n+                        MemorySegment.ofArray(new double[len])\n+                )\n+                .map(s -> new Object[] { s })\n+                .toArray(Object[][]::new);\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":158,"deletions":68,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -34,1 +33,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -62,4 +60,1 @@\n-        MemorySegment segment = MemorySegment.ofAddress(\n-                SymbolLookup.loaderLookup().find(\"c\").get().address(),\n-                ValueLayout.JAVA_INT.byteSize(),\n-                SegmentScope.global());\n+        MemorySegment segment = SymbolLookup.loaderLookup().find(\"c\").get().reinterpret(1);\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @run testng TestDereferencePath\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemoryLayout.PathElement;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.lang.foreign.ValueLayout;\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.VarHandle;\n+import static org.testng.Assert.*;\n+\n+public class TestDereferencePath {\n+\n+    static final MemoryLayout C = MemoryLayout.structLayout(\n+            ValueLayout.JAVA_INT.withName(\"x\")\n+    );\n+\n+    static final MemoryLayout B = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"c\")\n+                               .withTargetLayout(C)\n+    );\n+\n+    static final MemoryLayout A = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                               .withTargetLayout(B)\n+    );\n+\n+    static final VarHandle abcx = A.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement(),\n+            PathElement.groupElement(\"c\"), PathElement.dereferenceElement(),\n+            PathElement.groupElement(\"x\"));\n+\n+    @Test\n+    public void testSingle() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(B);\n+            MemorySegment c = arena.allocate(C);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.ADDRESS, 0, c);\n+            c.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) abcx.get(a);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+    static final MemoryLayout B_MULTI = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"cs\")\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(2, C))\n+    );\n+\n+    static final MemoryLayout A_MULTI = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"bs\")\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(2, B_MULTI))\n+    );\n+\n+    static final VarHandle abcx_multi = A_MULTI.varHandle(\n+            PathElement.groupElement(\"bs\"), PathElement.dereferenceElement(), PathElement.sequenceElement(),\n+            PathElement.groupElement(\"cs\"), PathElement.dereferenceElement(), PathElement.sequenceElement(),\n+            PathElement.groupElement(\"x\"));\n+\n+    @Test\n+    public void testMulti() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocateArray(B, 2);\n+            MemorySegment c = arena.allocateArray(C, 4);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.ADDRESS, 0, c);\n+            b.setAtIndex(ValueLayout.ADDRESS, 1, c.asSlice(C.byteSize() * 2));\n+            c.setAtIndex(ValueLayout.JAVA_INT, 0, 1);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 1, 2);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 2, 3);\n+            c.setAtIndex(ValueLayout.JAVA_INT, 3, 4);\n+            \/\/ dereference\n+            int val00 = (int) abcx_multi.get(a, 0, 0); \/\/ a->b[0]->c[0] = 1\n+            assertEquals(val00, 1);\n+            int val10 = (int) abcx_multi.get(a, 1, 0); \/\/ a->b[1]->c[0] = 3\n+            assertEquals(val10, 3);\n+            int val01 = (int) abcx_multi.get(a, 0, 1); \/\/ a->b[0]->c[1] = 2\n+            assertEquals(val01, 2);\n+            int val11 = (int) abcx_multi.get(a, 1, 1); \/\/ a->b[1]->c[1] = 4\n+            assertEquals(val11, 4);\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadDerefInSelect() {\n+        A.select(PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void testBadDerefInOffset() {\n+        A.byteOffset(PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+    }\n+\n+    static final MemoryLayout A_MULTI_NO_TARGET = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"bs\")\n+    );\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    void badDerefAddressNoTarget() {\n+        A_MULTI_NO_TARGET.varHandle(PathElement.groupElement(\"bs\"), PathElement.dereferenceElement());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -42,5 +42,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -66,1 +62,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -70,1 +66,1 @@\n-                    SegmentAllocator.nativeAllocator(arena.scope()) :\n+                    arena :\n","filename":"test\/jdk\/java\/foreign\/TestDowncallScope.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n","filename":"test\/jdk\/java\/foreign\/TestDowncallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,6 @@\n+        FunctionDescriptor fdReturnSomethingElse = FunctionDescriptor.of(C_LONG_LONG, C_INT, C_INT);\n+        FunctionDescriptor fdOtherArguments = FunctionDescriptor.of(C_INT, C_INT);\n+        assertFalse(fd.equals(fdReturnSomethingElse));\n+        assertFalse(fd.equals(fdOtherArguments));\n+        assertFalse(fd.equals(null));\n+        assertFalse(fd.equals(\"A\"));\n@@ -124,0 +130,13 @@\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testIllegalInsertArgNegIndex() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT);\n+        fd.insertArgumentLayouts(-1, C_INT);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testIllegalInsertArgOutOfBounds() {\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT);\n+        fd.insertArgumentLayouts(2, C_INT);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-            Arena arena = Arena.openShared();\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, arena.scope());\n+            Arena arena = Arena.ofShared();\n+            MemorySegment segment = arena.allocate(SEGMENT_SIZE, 1);\n@@ -77,1 +77,1 @@\n-                accessExecutor.execute(accessorFactory.make(i, segment));\n+                accessExecutor.execute(accessorFactory.make(i, segment, arena));\n@@ -139,1 +139,1 @@\n-        AbstractBufferAccessor(int id, MemorySegment segment) {\n+        AbstractBufferAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -147,1 +147,1 @@\n-        SegmentAccessor(int id, MemorySegment segment) {\n+        SegmentAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -165,1 +165,1 @@\n-        SegmentCopyAccessor(int id, MemorySegment segment) {\n+        SegmentCopyAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -180,1 +180,1 @@\n-        SegmentFillAccessor(int id, MemorySegment segment) {\n+        SegmentFillAccessor(int id, MemorySegment segment, Arena _unused) {\n@@ -194,1 +194,1 @@\n-        SegmentMismatchAccessor(int id, MemorySegment segment) {\n+        SegmentMismatchAccessor(int id, MemorySegment segment, Arena arena) {\n@@ -196,1 +196,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n+            this.copy = arena.allocate(SEGMENT_SIZE, 1);\n@@ -209,2 +209,2 @@\n-        BufferAccessor(int id, MemorySegment segment) {\n-            super(id, segment);\n+        BufferAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment, null);\n@@ -226,2 +226,2 @@\n-        public BufferHandleAccessor(int id, MemorySegment segment) {\n-            super(id, segment);\n+        public BufferHandleAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment, null);\n@@ -264,1 +264,1 @@\n-        AbstractSegmentAccessor make(int id, MemorySegment segment);\n+        AbstractSegmentAccessor make(int id, MemorySegment segment, Arena arena);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -34,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -93,1 +94,1 @@\n-    static final ValueLayout.OfAddress ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n+    static final AddressLayout ADDRESS_ALIGNED = ValueLayout.ADDRESS.withBitAlignment(ValueLayout.ADDRESS.bitSize());\n@@ -103,1 +104,1 @@\n-        NATIVE(MemorySegment.allocateNative(8, SegmentScope.auto()), -1);\n+        NATIVE(Arena.ofAuto().allocate(8, 1), -1);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.Arena;\n@@ -36,0 +37,4 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -47,0 +52,1 @@\n+    private static final MethodHandle DUMMY_TARGET_MH = MethodHandles.empty(MethodType.methodType(void.class));\n@@ -50,1 +56,1 @@\n-    public void testTypeMismatch(FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testIllegalLayouts(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -60,0 +66,36 @@\n+    @Test(dataProvider = \"downcallOnlyOptions\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Not supported for upcall.*\")\n+    public void testIllegalUpcallOptions(Linker.Option downcallOnlyOption) {\n+        ABI.upcallStub(DUMMY_TARGET_MH, FunctionDescriptor.ofVoid(), Arena.ofAuto(), downcallOnlyOption);\n+    }\n+\n+    @Test(dataProvider = \"illegalCaptureState\",\n+          expectedExceptions = IllegalArgumentException.class,\n+          expectedExceptionsMessageRegExp = \".*Unknown name.*\")\n+    public void testIllegalCaptureState(String name) {\n+        Linker.Option.captureCallState(name);\n+    }\n+\n+    \/\/ where\n+\n+    @DataProvider\n+    public static Object[][] illegalCaptureState() {\n+        if (!IS_WINDOWS) {\n+            return new Object[][]{\n+                { \"GetLastError\" },\n+                { \"WSAGetLastError\" },\n+            };\n+        }\n+        return new Object[][]{};\n+    }\n+\n+    @DataProvider\n+    public static Object[][] downcallOnlyOptions() {\n+        return new Object[][]{\n+            { Linker.Option.firstVariadicArg(0) },\n+            { Linker.Option.captureCallState(\"errno\") },\n+            { Linker.Option.isTrivial() },\n+        };\n+    }\n+\n@@ -88,1 +130,1 @@\n-                    FunctionDescriptor.ofVoid(MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(32)),\n+                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withBitAlignment(32)),\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-        try (var arena = Arena.openConfined()) {\n-            var segment = MemorySegment.allocateNative((long) longArrayLength * Long.BYTES, Long.SIZE, arena.scope());\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate((long) longArrayLength * Long.BYTES, Long.SIZE);\n","filename":"test\/jdk\/java\/foreign\/TestLargeSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @modules java.base\/jdk.internal.foreign\n- * @run testng TestLayoutEquality\n- *\/\n-\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.ValueLayout;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestLayoutEquality {\n-\n-    @Test(dataProvider = \"layoutConstants\")\n-    public void testReconstructedEquality(ValueLayout layout) {\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.carrier(), layout.order());\n-        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n-        if (layout instanceof ValueLayout.OfAddress addressLayout && addressLayout.isUnbounded()) {\n-            newLayout = ((ValueLayout.OfAddress)newLayout).asUnbounded();\n-        }\n-\n-        \/\/ properties should be equal\n-        assertEquals(newLayout.bitSize(), layout.bitSize());\n-        assertEquals(newLayout.bitAlignment(), layout.bitAlignment());\n-        assertEquals(newLayout.name(), layout.name());\n-\n-        \/\/ layouts should be equals\n-        assertEquals(newLayout, layout);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] layoutConstants() throws ReflectiveOperationException {\n-        List<ValueLayout> testValues = new ArrayList<>();\n-\n-        addLayoutConstants(testValues, PlatformLayouts.SysV.class);\n-        addLayoutConstants(testValues, PlatformLayouts.Win64.class);\n-        addLayoutConstants(testValues, PlatformLayouts.AArch64.class);\n-        addLayoutConstants(testValues, PlatformLayouts.RISCV64.class);\n-\n-        return testValues.stream().map(e -> new Object[]{ e }).toArray(Object[][]::new);\n-    }\n-\n-    private static void addLayoutConstants(List<ValueLayout> testValues, Class<?> cls) throws ReflectiveOperationException {\n-        for (Field f : cls.getFields()) {\n-            if (f.getName().startsWith(\"C_\"))\n-                testValues.add((ValueLayout) f.get(null));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -35,2 +33,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n@@ -38,1 +34,0 @@\n-import java.lang.foreign.ValueLayout;\n@@ -45,0 +40,1 @@\n+import java.util.function.IntFunction;\n@@ -101,0 +97,12 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testTooBigGroupElementIndex() {\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n+        g.byteOffset(groupElement(1));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNegativeGroupElementIndex() {\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n+        g.byteOffset(groupElement(-1));\n+    }\n+\n@@ -171,19 +179,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadMultiple() {\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(3), JAVA_INT.withName(\"foo\"));\n-        g.byteOffset(groupElement(\"foo\"));\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadByteOffsetNoMultipleOf8() {\n-        MemoryLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(7), JAVA_INT.withName(\"x\"));\n-        layout.byteOffset(groupElement(\"x\"));\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadByteOffsetHandleNoMultipleOf8() throws Throwable {\n-        MemoryLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(7), JAVA_INT.withName(\"x\"));\n-        MethodHandle handle = layout.byteOffsetHandle(groupElement(\"x\"));\n-        handle.invoke();\n-    }\n-\n@@ -261,2 +250,2 @@\n-    @Test\n-    public void testStructPaths() {\n+    @Test(dataProvider = \"groupSelectors\")\n+    public void testStructPaths(IntFunction<PathElement> groupSelector) {\n@@ -265,4 +254,4 @@\n-                ValueLayout.JAVA_BYTE.withName(\"1\"),\n-                ValueLayout.JAVA_CHAR.withName(\"2\"),\n-                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n-                ValueLayout.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"0\"),\n+                ValueLayout.JAVA_CHAR.withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"2\"),\n+                ValueLayout.JAVA_LONG.withName(\"3\")\n@@ -273,3 +262,3 @@\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n-            assertTrue(selected == g.memberLayouts().get(i - 1));\n+        for (int i = 0 ; i < 4 ; i++) {\n+            MemoryLayout selected = g.select(groupSelector.apply(i));\n+            assertTrue(selected == g.memberLayouts().get(i));\n@@ -280,5 +269,5 @@\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n-            assertEquals(offsets[i - 1], bitOffset);\n-            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n-            assertEquals((offsets[i - 1]) >>> 3, byteOffset);\n+        for (int i = 0 ; i < 4 ; i++) {\n+            long bitOffset = g.bitOffset(groupSelector.apply(i));\n+            assertEquals(offsets[i], bitOffset);\n+            long byteOffset = g.byteOffset(groupSelector.apply(i));\n+            assertEquals((offsets[i]) >>> 3, byteOffset);\n@@ -288,2 +277,2 @@\n-    @Test\n-    public void testUnionPaths() {\n+    @Test(dataProvider = \"groupSelectors\")\n+    public void testUnionPaths(IntFunction<PathElement> groupSelector) {\n@@ -292,4 +281,4 @@\n-                ValueLayout.JAVA_BYTE.withName(\"1\"),\n-                ValueLayout.JAVA_CHAR.withName(\"2\"),\n-                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n-                ValueLayout.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"0\"),\n+                ValueLayout.JAVA_CHAR.withName(\"1\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"2\"),\n+                ValueLayout.JAVA_LONG.withName(\"3\")\n@@ -300,3 +289,3 @@\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n-            assertTrue(selected == g.memberLayouts().get(i - 1));\n+        for (int i = 0 ; i < 4 ; i++) {\n+            MemoryLayout selected = g.select(groupSelector.apply(i));\n+            assertTrue(selected == g.memberLayouts().get(i));\n@@ -307,5 +296,5 @@\n-        for (int i = 1 ; i <= 4 ; i++) {\n-            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n-            assertEquals(offsets[i - 1], bitOffset);\n-            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n-            assertEquals((offsets[i - 1]) >>> 3, byteOffset);\n+        for (int i = 0 ; i < 4 ; i++) {\n+            long bitOffset = g.bitOffset(groupSelector.apply(i));\n+            assertEquals(offsets[i], bitOffset);\n+            long byteOffset = g.byteOffset(groupSelector.apply(i));\n+            assertEquals((offsets[i]) >>> 3, byteOffset);\n@@ -315,0 +304,8 @@\n+    @DataProvider\n+    public static Object[][] groupSelectors() {\n+        return new Object[][] {\n+                { (IntFunction<PathElement>) PathElement::groupElement }, \/\/ by index\n+                { (IntFunction<PathElement>) i -> PathElement.groupElement(String.valueOf(i)) } \/\/ by name\n+        };\n+    }\n+\n@@ -367,1 +364,1 @@\n-            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(5), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withName(\"y\"))),\n@@ -370,1 +367,1 @@\n-            (JAVA_INT.bitSize() + 5) * 4 + 5\n+            (JAVA_INT.bitSize() + 8) * 4 + 8\n@@ -436,2 +433,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(layout);\n@@ -444,40 +441,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testSliceHandleUOEInvalidOffsetEager() throws Throwable {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-            MemoryLayout.paddingLayout(5),\n-            JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n-        );\n-\n-        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testSliceHandleUOEInvalidOffsetLate() throws Throwable {\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(3,\n-            MemoryLayout.structLayout(\n-                MemoryLayout.paddingLayout(4),\n-                    JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n-            )\n-        );\n-\n-        MethodHandle sliceHandle;\n-        try {\n-            sliceHandle = layout.sliceHandle(sequenceElement(), groupElement(\"y\")); \/\/ should work\n-        } catch (UnsupportedOperationException uoe) {\n-            fail(\"Unexpected exception\", uoe);\n-            return;\n-        }\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());\n-\n-            try {\n-                sliceHandle.invokeExact(segment, 1); \/\/ should work\n-            } catch (UnsupportedOperationException uoe) {\n-                fail(\"Unexpected exception\", uoe);\n-                return;\n-            }\n-\n-            sliceHandle.invokeExact(segment, 0); \/\/ should throw\n-        }\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":55,"deletions":98,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -39,4 +40,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -52,0 +50,42 @@\n+    @Test(dataProvider = \"basicLayoutsAndAddressAndGroups\")\n+    public void testEqualities(MemoryLayout layout) {\n+\n+        \/\/ Use another Type\n+        MemoryLayout differentType = MemoryLayout.paddingLayout(8);\n+        assertFalse(layout.equals(differentType));\n+\n+        \/\/ Use another name\n+        MemoryLayout differentName = layout.withName(\"CustomName\");\n+        assertFalse(layout.equals(differentName));\n+\n+        \/\/ Use another alignment\n+        MemoryLayout differentAlignment = layout.withBitAlignment(layout.bitAlignment() * 2);\n+        assertFalse(layout.equals(differentAlignment));\n+\n+        \/\/ Swap endian\n+        MemoryLayout differentOrder = JAVA_INT.withOrder(JAVA_INT.order() == ByteOrder.BIG_ENDIAN ? ByteOrder.LITTLE_ENDIAN : ByteOrder.BIG_ENDIAN);\n+        assertFalse(layout.equals(differentOrder));\n+\n+        \/\/ Something totally different\n+        assertFalse(layout.equals(\"A\"));\n+\n+        \/\/ Null\n+        assertFalse(layout.equals(null));\n+\n+        \/\/ Identity\n+        assertTrue(layout.equals(layout));\n+\n+        assertFalse(layout.equals(MemoryLayout.sequenceLayout(13, JAVA_LONG)));\n+\n+        MemoryLayout other = layout.withBitAlignment(128).withBitAlignment(layout.bitAlignment());\n+        assertTrue(layout.equals(other));\n+\n+    }\n+\n+    public void testTargetLayoutEquals() {\n+        MemoryLayout differentTargetLayout = ADDRESS.withTargetLayout(JAVA_CHAR);\n+        assertFalse(ADDRESS.equals(differentTargetLayout));\n+        var equalButNotSame = ADDRESS.withTargetLayout(JAVA_INT).withTargetLayout(JAVA_CHAR);\n+        assertTrue(differentTargetLayout.equals(equalButNotSame));\n+    }\n+\n@@ -55,2 +95,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -78,0 +118,24 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testReshape() {\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(10, JAVA_INT);\n+        layout.reshape();\n+    }\n+\n+    @Test(dataProvider = \"basicLayoutsAndAddressAndGroups\", expectedExceptions = IllegalArgumentException.class)\n+    public void testGroupIllegalAlignmentNotPowerOfTwo(MemoryLayout layout) {\n+        layout.withBitAlignment(3);\n+    }\n+\n+    @Test(dataProvider = \"basicLayoutsAndAddressAndGroups\", expectedExceptions = IllegalArgumentException.class)\n+    public void testGroupIllegalAlignmentNotGreaterOrEqualTo8(MemoryLayout layout) {\n+        layout.withBitAlignment(4);\n+    }\n+\n+    @Test\n+    public void testEqualsPadding() {\n+        PaddingLayout paddingLayout = MemoryLayout.paddingLayout(16);\n+        testEqualities(paddingLayout);\n+        PaddingLayout paddingLayout2 = MemoryLayout.paddingLayout(32);\n+        assertNotEquals(paddingLayout, paddingLayout2);\n+    }\n+\n@@ -82,1 +146,1 @@\n-        assertEquals(struct.bitAlignment(), 1);\n+        assertEquals(struct.bitAlignment(), 8);\n@@ -86,1 +150,1 @@\n-        assertEquals(union.bitAlignment(), 1);\n+        assertEquals(union.bitAlignment(), 8);\n@@ -104,1 +168,1 @@\n-        assertEquals(MemoryLayout.paddingLayout(layout.bitSize()).bitAlignment(), 1);\n+        assertEquals(MemoryLayout.paddingLayout(layout.bitSize()).bitAlignment(), 8);\n@@ -169,0 +233,33 @@\n+    @Test\n+    public void testPadding() {\n+        var padding = MemoryLayout.paddingLayout(8);\n+        assertEquals(padding.byteAlignment(), 1);\n+    }\n+\n+    @Test\n+    public void testPaddingInStruct() {\n+        var padding = MemoryLayout.paddingLayout(8);\n+        var struct = MemoryLayout.structLayout(padding);\n+        assertEquals(struct.byteAlignment(), 1);\n+    }\n+\n+    @Test\n+    public void testPaddingIllegalBitSize() {\n+        for (long bitSize : List.of(-8L, -1L, 0L, 1L, 7L)) {\n+            try {\n+                MemoryLayout.paddingLayout(bitSize);\n+                fail(\"bitSize cannot be \" + bitSize);\n+            } catch (IllegalArgumentException ignore) {\n+                \/\/ Happy path\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStructToString() {\n+        StructLayout padding = MemoryLayout.structLayout(JAVA_INT).withName(\"struct\");\n+        assertEquals(padding.toString(), \"[i32](struct)\");\n+        var toStringUnaligned = padding.withBitAlignment(64).toString();\n+        assertEquals(toStringUnaligned, \"64%[i32](struct)\");\n+    }\n+\n@@ -185,0 +282,7 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testSequenceElement() {\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(10, JAVA_INT);\n+        \/\/ Step must be != 0\n+        PathElement.sequenceElement(3, 0);\n+    }\n+\n@@ -251,0 +355,14 @@\n+    @DataProvider(name = \"basicLayoutsAndAddress\")\n+    public Object[][] basicLayoutsAndAddress() {\n+        return Stream.concat(Stream.of(basicLayouts), Stream.of(ADDRESS))\n+                .map(l -> new Object[] { l })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"basicLayoutsAndAddressAndGroups\")\n+    public Object[][] basicLayoutsAndAddressAndGroups() {\n+        return Stream.concat(Stream.concat(Stream.of(basicLayouts), Stream.of(ADDRESS)), groupLayoutStream())\n+                .map(l -> new Object[] { l })\n+                .toArray(Object[][]::new);\n+    }\n+\n@@ -274,0 +392,33 @@\n+    @DataProvider(name = \"groupLayouts\")\n+    public Object[][] groupLayouts() {\n+        return groupLayoutStream()\n+                .map(l -> new Object[] { l })\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"validCarriers\")\n+    public Object[][] validCarriers() {\n+        return Stream.of(\n+                        boolean.class,\n+                        byte.class,\n+                        char.class,\n+                        short.class,\n+                        int.class,\n+                        long.class,\n+                        float.class,\n+                        double.class,\n+                        MemorySegment.class\n+                )\n+                .map(l -> new Object[]{l})\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static Stream<MemoryLayout> groupLayoutStream() {\n+        return Stream.of(\n+                MemoryLayout.sequenceLayout(10, JAVA_INT),\n+                MemoryLayout.sequenceLayout(JAVA_INT),\n+                MemoryLayout.structLayout(JAVA_INT, JAVA_LONG),\n+                MemoryLayout.unionLayout(JAVA_LONG, JAVA_DOUBLE)\n+        );\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":161,"deletions":10,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -37,3 +35,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -94,2 +89,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(layout));\n@@ -126,2 +121,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(seq));\n@@ -195,2 +190,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, arena.scope()));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = viewFactory.apply(arena.allocate(seq));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.foreign.Arena;\n@@ -32,1 +31,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -83,2 +82,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(128, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(128, 1);\n@@ -96,2 +95,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(64, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(64, 1);\n@@ -139,1 +138,3 @@\n-        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        long byteSize = ValueLayout.ADDRESS.byteSize();\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment targetSegment = scope.allocate(byteSize, 1);\n@@ -147,1 +148,3 @@\n-        MemorySegment targetSegment = MemorySegment.allocateNative(ValueLayout.ADDRESS.byteSize(), SegmentScope.auto());\n+        long byteSize = ValueLayout.ADDRESS.byteSize();\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment targetSegment = scope.allocate(byteSize, 1);\n@@ -162,1 +165,1 @@\n-                {\"bool\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                {\"boolean\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n@@ -170,0 +173,4 @@\n+                {\"short\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getShort(pos), (bb, pos, v) -> bb.order(NE).putShort(pos, v))\n+                },\n@@ -204,0 +211,8 @@\n+                {\"byte\/index\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).get(pos), (bb, pos, v) -> bb.order(NE).put(pos, v))\n+                },\n+                {\"boolean\/index\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, true,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).get(pos) != 0, (bb, pos, v) -> bb.order(NE).put(pos, (byte) (v ? 1 : 0)))\n+                },\n@@ -208,0 +223,4 @@\n+                {\"short\/index\", Accessor.ofSegment(ValueLayout.JAVA_SHORT, (short) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getShort(pos * 2), (bb, pos, v) -> bb.order(NE).putShort(pos * 2, v))\n+                },\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.GroupLayout;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -34,3 +32,0 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n@@ -55,2 +50,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(aligned, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(aligned);;\n@@ -73,2 +68,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(alignedGroup);;\n@@ -100,2 +95,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment segment = arena.allocate(layout);;\n@@ -124,2 +119,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(g, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(g);;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n+ * @modules java.base\/jdk.internal.foreign\n@@ -33,2 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-\n@@ -40,0 +38,1 @@\n+import java.lang.reflect.Method;\n@@ -54,1 +53,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -57,1 +56,1 @@\n-            addCloseAction(arena.scope(), () -> acc.addAndGet(delta));\n+            addCloseAction(arena, () -> acc.addAndGet(delta));\n@@ -66,1 +65,1 @@\n-    public void testSharedSingleThread(SessionSupplier sessionSupplier) {\n+    public void testSharedSingleThread(ArenaSupplier arenaSupplier) {\n@@ -68,1 +67,1 @@\n-        SegmentScope session = sessionSupplier.get();\n+        Arena session = arenaSupplier.get();\n@@ -75,2 +74,2 @@\n-        if (!SessionSupplier.isImplicit(session)) {\n-            SessionSupplier.close(session);\n+        if (!TestMemorySession.ArenaSupplier.isImplicit(session)) {\n+            TestMemorySession.ArenaSupplier.close(session);\n@@ -88,1 +87,1 @@\n-    public void testSharedMultiThread(SessionSupplier sessionSupplier) {\n+    public void testSharedMultiThread(ArenaSupplier arenaSupplier) {\n@@ -91,2 +90,2 @@\n-        SegmentScope session = sessionSupplier.get();\n-        AtomicReference<SegmentScope> sessionRef = new AtomicReference<>(session);\n+        Arena session = arenaSupplier.get();\n+        AtomicReference<Arena> sessionRef = new AtomicReference<>(session);\n@@ -112,1 +111,1 @@\n-        if (!SessionSupplier.isImplicit(session)) {\n+        if (!TestMemorySession.ArenaSupplier.isImplicit(session)) {\n@@ -115,1 +114,1 @@\n-                    SessionSupplier.close(session);\n+                    TestMemorySession.ArenaSupplier.close(session);\n@@ -131,1 +130,1 @@\n-        if (!SessionSupplier.isImplicit(session)) {\n+        if (!TestMemorySession.ArenaSupplier.isImplicit(session)) {\n@@ -145,1 +144,1 @@\n-        Arena arena = Arena.openConfined();\n+        Arena arena = Arena.ofConfined();\n@@ -148,2 +147,2 @@\n-            Arena handle = Arena.openConfined();\n-            keepAlive(handle.scope(), arena.scope());\n+            Arena handle = Arena.ofConfined();\n+            keepAlive(handle, arena);\n@@ -168,1 +167,1 @@\n-        Arena arena = Arena.openShared();\n+        Arena arena = Arena.ofShared();\n@@ -172,2 +171,2 @@\n-                try (Arena handle = Arena.openConfined()) {\n-                    keepAlive(handle.scope(), arena.scope());\n+                try (Arena handle = Arena.ofConfined()) {\n+                    keepAlive(handle, arena);\n@@ -196,1 +195,1 @@\n-        Arena.openConfined().close();\n+        Arena.ofConfined().close();\n@@ -201,1 +200,1 @@\n-        Arena.openShared().close();\n+        Arena.ofShared().close();\n@@ -206,3 +205,3 @@\n-        Arena arena = Arena.openConfined();\n-        Arena handle = Arena.openConfined();\n-        keepAlive(handle.scope(), arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        Arena handle = Arena.ofConfined();\n+        keepAlive(handle, arena);\n@@ -228,2 +227,2 @@\n-    public void testSessionAcquires(SessionSupplier sessionSupplier) {\n-        SegmentScope session = sessionSupplier.get();\n+    public void testSessionAcquires(ArenaSupplier ArenaSupplier) {\n+        Arena session = ArenaSupplier.get();\n@@ -231,2 +230,2 @@\n-        if (!SessionSupplier.isImplicit(session))\n-            SessionSupplier.close(session);\n+        if (!TestMemorySession.ArenaSupplier.isImplicit(session))\n+            TestMemorySession.ArenaSupplier.close(session);\n@@ -235,3 +234,3 @@\n-    private void acquireRecursive(SegmentScope session, int acquireCount) {\n-        try (Arena arena = Arena.openConfined()) {\n-            keepAlive(arena.scope(), session);\n+    private void acquireRecursive(Arena session, int acquireCount) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            keepAlive(arena, session);\n@@ -242,2 +241,2 @@\n-            if (!SessionSupplier.isImplicit(session)) {\n-                assertThrows(IllegalStateException.class, () -> SessionSupplier.close(session));\n+            if (!ArenaSupplier.isImplicit(session)) {\n+                assertThrows(IllegalStateException.class, () -> ArenaSupplier.close(session));\n@@ -250,1 +249,1 @@\n-        Arena root = Arena.openConfined();\n+        Arena root = Arena.ofConfined();\n@@ -253,1 +252,1 @@\n-            keepAlive(SegmentScope.auto(), root.scope());\n+            keepAlive(Arena.ofAuto(), root);\n@@ -265,2 +264,2 @@\n-                    try (Arena arena = Arena.openConfined()) {\n-                        keepAlive(arena.scope(), root.scope());\n+                    try (Arena arena = Arena.ofConfined()) {\n+                        keepAlive(arena, root);\n@@ -277,1 +276,1 @@\n-        Arena root = Arena.openConfined();\n+        Arena root = Arena.ofConfined();\n@@ -281,2 +280,2 @@\n-            Arena arena = Arena.openShared(); \/\/ create session inside same thread!\n-            keepAlive(arena.scope(), root.scope());\n+            Arena arena = Arena.ofShared(); \/\/ create session inside same thread!\n+            keepAlive(arena, root);\n@@ -288,2 +287,2 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                keepAlive(arena.scope(), root.scope());\n+            try (Arena arena = Arena.ofConfined()) {\n+                keepAlive(arena, root);\n@@ -305,0 +304,19 @@\n+    @Test(dataProvider = \"nonCloseableSessions\")\n+    public void testNonCloseableSessions(ArenaSupplier arenaSupplier) {\n+        var arena = arenaSupplier.get();\n+        var sessionImpl = ((MemorySessionImpl) arena.scope());\n+        assertFalse(sessionImpl.isCloseable());\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sessionImpl.close());\n+    }\n+\n+    @Test(dataProvider = \"allSessionsAndGlobal\")\n+    public void testIsCloseableBy(ArenaSupplier arenaSupplier) {\n+        var arena = arenaSupplier.get();\n+        var sessionImpl = ((MemorySessionImpl) arena.scope());\n+        assertEquals(sessionImpl.isCloseableBy(Thread.currentThread()), sessionImpl.isCloseable());\n+        Thread otherThread = new Thread();\n+        boolean isCloseableByOther = sessionImpl.isCloseable() && !\"ConfinedSession\".equals(sessionImpl.getClass().getSimpleName());\n+        assertEquals(sessionImpl.isCloseableBy(otherThread), isCloseableByOther);\n+    }\n+\n@@ -324,2 +342,2 @@\n-                { (Supplier<Arena>) Arena::openConfined},\n-                { (Supplier<Arena>) Arena::openShared},\n+                { (Supplier<Arena>) Arena::ofConfined},\n+                { (Supplier<Arena>) Arena::ofShared},\n@@ -329,2 +347,2 @@\n-    private void keepAlive(SegmentScope child, SegmentScope parent) {\n-        MemorySessionImpl parentImpl = (MemorySessionImpl) parent;\n+    private void keepAlive(Arena child, Arena parent) {\n+        MemorySessionImpl parentImpl = MemorySessionImpl.toMemorySession(parent);\n@@ -335,2 +353,2 @@\n-    private void addCloseAction(SegmentScope session, Runnable action) {\n-        MemorySessionImpl sessionImpl = (MemorySessionImpl) session;\n+    private void addCloseAction(Arena session, Runnable action) {\n+        MemorySessionImpl sessionImpl = MemorySessionImpl.toMemorySession(session);\n@@ -340,1 +358,5 @@\n-    interface SessionSupplier extends Supplier<SegmentScope> {\n+    interface ArenaSupplier extends Supplier<Arena> {\n+\n+        static void close(Arena arena) {\n+            MemorySessionImpl.toMemorySession(arena).close();\n+        }\n@@ -342,2 +364,2 @@\n-        static void close(SegmentScope session) {\n-            ((MemorySessionImpl)session).close();\n+        static boolean isImplicit(Arena arena) {\n+            return !MemorySessionImpl.toMemorySession(arena).isCloseable();\n@@ -346,2 +368,2 @@\n-        static boolean isImplicit(SegmentScope session) {\n-            return !((MemorySessionImpl)session).isCloseable();\n+        static ArenaSupplier ofAuto() {\n+            return Arena::ofAuto;\n@@ -350,2 +372,2 @@\n-        static SessionSupplier ofImplicit() {\n-            return SegmentScope::auto;\n+        static ArenaSupplier ofGlobal() {\n+            return Arena::global;\n@@ -354,2 +376,2 @@\n-        static SessionSupplier ofArena(Supplier<Arena> arenaSupplier) {\n-            return () -> arenaSupplier.get().scope();\n+        static ArenaSupplier ofArena(Supplier<Arena> arenaSupplier) {\n+            return arenaSupplier::get;\n@@ -362,2 +384,2 @@\n-                { SessionSupplier.ofArena(Arena::openShared) },\n-                { SessionSupplier.ofImplicit() },\n+                { ArenaSupplier.ofArena(Arena::ofShared) },\n+                { ArenaSupplier.ofAuto() },\n@@ -370,3 +392,21 @@\n-                { SessionSupplier.ofArena(Arena::openConfined) },\n-                { SessionSupplier.ofArena(Arena::openShared) },\n-                { SessionSupplier.ofImplicit() },\n+                { ArenaSupplier.ofArena(Arena::ofConfined) },\n+                { ArenaSupplier.ofArena(Arena::ofShared) },\n+                { ArenaSupplier.ofAuto() },\n+        };\n+    }\n+\n+    @DataProvider(name = \"nonCloseableSessions\")\n+    static Object[][] nonCloseableSessions() {\n+        return new Object[][] {\n+                { ArenaSupplier.ofGlobal() },\n+                { ArenaSupplier.ofAuto() }\n+        };\n+    }\n+\n+    @DataProvider(name = \"allSessionsAndGlobal\")\n+    static Object[][] allSessionsAndGlobal() {\n+        return new Object[][] {\n+                { ArenaSupplier.ofArena(Arena::ofConfined) },\n+                { ArenaSupplier.ofArena(Arena::ofShared) },\n+                { ArenaSupplier.ofAuto() },\n+                { ArenaSupplier.ofGlobal() },\n@@ -375,0 +415,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":106,"deletions":65,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -175,2 +174,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            var nativeSegment = MemorySegment.allocateNative(4, 4, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            var nativeSegment = arena.allocate(4, 4);;\n@@ -187,3 +186,3 @@\n-            try (Arena arena = Arena.openConfined()) {\n-                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n-                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, arena.scope());;\n+            try (Arena arena = Arena.ofConfined()) {\n+                var s1 = arena.allocate((long) Integer.MAX_VALUE + 10L, 8);;\n+                var s2 = arena.allocate((long) Integer.MAX_VALUE + 10L, 8);;\n@@ -231,3 +230,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            s1 = MemorySegment.allocateNative(4, 1, arena.scope());;\n-            s2 = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            s1 = arena.allocate(4, 1);\n+            s2 = arena.allocate(4, 1);;\n@@ -242,2 +241,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            var segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(4, 1);;\n@@ -284,1 +283,1 @@\n-        NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+        NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public void testNULLReturn_unbounded() throws Throwable {\n+    public void testNULLReturn_target() throws Throwable {\n@@ -69,1 +69,1 @@\n-                FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded()));\n+                FunctionDescriptor.of(ValueLayout.ADDRESS.withTargetLayout(ValueLayout.JAVA_INT)));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,3 +32,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.*;\n@@ -36,3 +34,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+\n@@ -148,2 +144,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(seq, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(seq);;\n@@ -158,2 +154,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(doubles, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(doubles);;\n@@ -171,3 +167,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n-                    arena.scope(), () -> freeMemory(addr));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment mallocSegment = addr.asSlice(0, 12)\n+                    .reinterpret(arena, TestNative::freeMemory);\n@@ -182,3 +178,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            mallocSegment = MemorySegment.ofAddress(addr.address(), 12,\n-                    arena.scope(), () -> freeMemory(addr));\n+        try (Arena arena = Arena.ofConfined()) {\n+            mallocSegment = addr.asSlice(0, 12)\n+                    .reinterpret(arena, TestNative::freeMemory);\n@@ -199,1 +195,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -201,3 +197,4 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(4, 1, arena.scope());;\n-            MemorySegment.ofAddress(segment.address(), -1, SegmentScope.global());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(4, 1);\n+            assertThrows(IllegalArgumentException.class, () -> segment.reinterpret(-1));\n+            assertThrows(IllegalArgumentException.class, () -> segment.reinterpret(-1, Arena.ofAuto(), null));\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -59,1 +59,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -98,1 +97,2 @@\n-            ValueLayout.OfAddress.class,\n+            AddressLayout.class,\n+            PaddingLayout.class,\n@@ -100,0 +100,2 @@\n+            StructLayout.class,\n+            UnionLayout.class,\n@@ -101,2 +103,1 @@\n-            VaList.class,\n-            VaList.Builder.class,\n+            Linker.Option.class,\n@@ -105,1 +106,1 @@\n-            SegmentScope.class,\n+            MemorySegment.Scope.class,\n@@ -110,17 +111,2 @@\n-            \"java.lang.foreign.MemorySegment\/ofAddress(long,long,java.lang.foreign.SegmentScope,java.lang.Runnable)\/3\/0\",\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openConfined(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemorySegment.MemorySession\/openShared(java.lang.ref.Cleaner)\/0\/0\",\n-            \"java.lang.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n-            \"java.lang.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+            \"java.lang.foreign.MemorySegment\/reinterpret(java.lang.foreign.Arena,java.util.function.Consumer)\/1\/0\",\n+            \"java.lang.foreign.MemorySegment\/reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)\/2\/0\"\n@@ -169,1 +155,1 @@\n-        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(AddressLayout.class, ValueLayout.ADDRESS);\n@@ -178,0 +164,1 @@\n+        addDefaultMapping(PaddingLayout.class, MemoryLayout.paddingLayout(32));\n@@ -179,0 +166,2 @@\n+        addDefaultMapping(StructLayout.class, MemoryLayout.structLayout(ValueLayout.JAVA_INT));\n+        addDefaultMapping(UnionLayout.class, MemoryLayout.unionLayout(ValueLayout.JAVA_INT));\n@@ -184,4 +173,2 @@\n-        addDefaultMapping(VaList.class, VaListHelper.vaList);\n-        addDefaultMapping(VaList.Builder.class, VaListHelper.vaListBuilder);\n-        addDefaultMapping(Arena.class, Arena.openConfined());\n-        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n+        addDefaultMapping(Arena.class, Arena.ofConfined());\n+        addDefaultMapping(MemorySegment.Scope.class, Arena.ofAuto().scope());\n@@ -191,14 +178,1 @@\n-    }\n-\n-    static class VaListHelper {\n-        static final VaList vaList;\n-        static final VaList.Builder vaListBuilder;\n-\n-        static {\n-            AtomicReference<VaList.Builder> builderRef = new AtomicReference<>();\n-            vaList = VaList.make(b -> {\n-                builderRef.set(b);\n-                b.addVarg(JAVA_LONG, 42L);\n-            }, SegmentScope.auto());\n-            vaListBuilder = builderRef.get();\n-        }\n+        addDefaultMapping(Thread.UncaughtExceptionHandler.class, (thread, ex) -> {});\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":16,"deletions":42,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -34,3 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.VaList;\n@@ -54,2 +50,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -77,2 +71,2 @@\n-        Arena arena = Arena.openConfined();\n-        Z obj = scopedOperation.apply(arena.scope());\n+        Arena arena = Arena.ofConfined();\n+        Z obj = scopedOperation.apply(arena);\n@@ -90,2 +84,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            Z obj = scopedOperation.apply(arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            Z obj = scopedOperation.apply(arena);\n@@ -114,1 +108,1 @@\n-        ScopedOperation.ofScope(session -> MemorySegment.allocateNative(100, session), \"MemorySession::allocate\");;\n+        ScopedOperation.ofScope(session -> session.allocate(100, 1), \"MemorySession::allocate\");\n@@ -122,2 +116,0 @@\n-        ScopedOperation.ofScope(session -> VaList.make(b -> b.addVarg(JAVA_INT, 42), session), \"VaList::make\");\n-        ScopedOperation.ofScope(session -> VaList.ofAddress(42, session), \"VaList::make\");\n@@ -129,9 +121,0 @@\n-        \/\/ valist operations\n-        ScopedOperation.ofVaList(VaList::copy, \"VaList::copy\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.ADDRESS), \"VaList::nextVarg\/address\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_INT), \"VaList::nextVarg\/int\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_LONG), \"VaList::nextVarg\/long\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_DOUBLE), \"VaList::nextVarg\/double\");\n-        ScopedOperation.ofVaList(VaList::skip, \"VaList::skip\");\n-        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT),\n-                SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[4]))), \"VaList::nextVargs\/segment\");\n@@ -139,18 +122,18 @@\n-        ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        ScopedOperation.ofScope(a -> a.allocate(1), \"Arena::allocate\/size\");\n+        ScopedOperation.ofScope(a -> a.allocate(1, 1), \"Arena::allocate\/size\/align\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE), \"Arena::allocate\/layout\");\n+        ScopedOperation.ofScope(a -> a.allocate(JAVA_BYTE, (byte) 0), \"Arena::allocate\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"Arena::allocate\/char\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"Arena::allocate\/short\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"Arena::allocate\/int\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"Arena::allocate\/float\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"Arena::allocate\/long\");\n+        ScopedOperation.ofScope(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"Arena::allocate\/double\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, 1L), \"Arena::allocateArray\/size\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"Arena::allocateArray\/byte\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"Arena::allocateArray\/char\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"Arena::allocateArray\/short\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"Arena::allocateArray\/int\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"Arena::allocateArray\/float\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"Arena::allocateArray\/long\");\n+        ScopedOperation.ofScope(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"Arena::allocateArray\/double\");\n@@ -164,1 +147,1 @@\n-    static class ScopedOperation<X> implements Consumer<X>, Function<SegmentScope, X> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<Arena, X> {\n@@ -166,1 +149,1 @@\n-        final Function<SegmentScope, X> factory;\n+        final Function<Arena, X> factory;\n@@ -170,1 +153,1 @@\n-        private ScopedOperation(Function<SegmentScope, X> factory, Consumer<X> operation, String name) {\n+        private ScopedOperation(Function<Arena, X> factory, Consumer<X> operation, String name) {\n@@ -182,1 +165,1 @@\n-        public X apply(SegmentScope session) {\n+        public X apply(Arena session) {\n@@ -186,1 +169,1 @@\n-        static <Z> void of(Function<SegmentScope, Z> factory, Consumer<Z> consumer, String name) {\n+        static <Z> void of(Function<Arena, Z> factory, Consumer<Z> consumer, String name) {\n@@ -190,1 +173,1 @@\n-        static void ofScope(Consumer<SegmentScope> scopeConsumer, String name) {\n+        static void ofScope(Consumer<Arena> scopeConsumer, String name) {\n@@ -194,5 +177,0 @@\n-        static void ofVaList(Consumer<VaList> vaListConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation<>(session -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), session),\n-                    vaListConsumer, name));\n-        }\n-\n@@ -208,9 +186,0 @@\n-        static void ofAllocator(Consumer<SegmentAllocator> allocatorConsumer, String name) {\n-            for (AllocatorFactory allocatorFactory : AllocatorFactory.values()) {\n-                scopedOperations.add(new ScopedOperation<>(\n-                        allocatorFactory.allocatorFactory,\n-                        allocatorConsumer,\n-                        allocatorFactory.name() + \"\/\" + name));\n-            }\n-        }\n-\n@@ -219,1 +188,1 @@\n-            NATIVE(session -> MemorySegment.allocateNative(10, session)),\n+            NATIVE(session -> session.allocate(10, 1)),\n@@ -227,1 +196,1 @@\n-            UNSAFE(session -> MemorySegment.ofAddress(0, 10, session));\n+            UNSAFE(session -> MemorySegment.NULL.reinterpret(10, session, null));\n@@ -239,1 +208,1 @@\n-            final Function<SegmentScope, MemorySegment> segmentFactory;\n+            final Function<Arena, MemorySegment> segmentFactory;\n@@ -241,1 +210,1 @@\n-            SegmentFactory(Function<SegmentScope, MemorySegment> segmentFactory) {\n+            SegmentFactory(Function<Arena, MemorySegment> segmentFactory) {\n@@ -245,10 +214,0 @@\n-\n-        enum AllocatorFactory {\n-            NATIVE_ALLOCATOR(SegmentAllocator::nativeAllocator);\n-\n-            final Function<SegmentScope, SegmentAllocator> allocatorFactory;\n-\n-            AllocatorFactory(Function<SegmentScope, SegmentAllocator> allocatorFactory) {\n-                this.allocatorFactory = allocatorFactory;\n-            }\n-        }\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":33,"deletions":74,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign\n@@ -33,0 +34,2 @@\n+import jdk.internal.foreign.MappedMemorySegmentImpl;\n+import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -35,1 +38,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,2 +75,2 @@\n-                    Arena.openConfined(),\n-                    Arena.openShared()\n+                    Arena.ofConfined(),\n+                    Arena.ofShared()\n@@ -106,1 +109,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -120,1 +123,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -154,1 +157,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -191,1 +194,1 @@\n-                return MemorySegment.allocateNative(byteSize, byteAlignment, SegmentScope.auto());\n+                return Arena.ofAuto().allocate(byteSize, byteAlignment);\n@@ -209,2 +212,2 @@\n-                Arena.openConfined(),\n-                Arena.openShared()\n+                Arena.ofConfined(),\n+                Arena.ofShared()\n@@ -222,0 +225,21 @@\n+    @Test(dataProvider = \"arrayAllocations\")\n+    public <Z> void testPredicatesAndCommands(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object, ValueLayout> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+        Z arr = arrayHelper.array();\n+        Arena[] arenas = {\n+                Arena.ofConfined(),\n+                Arena.ofShared()\n+        };\n+        for (Arena arena : arenas) {\n+            try (arena) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, arena);\n+                MemorySegment segment = allocationFunction.allocate(allocator, layout, arr);\n+                assertThrows(UnsupportedOperationException.class, segment::load);\n+                assertThrows(UnsupportedOperationException.class, segment::unload);\n+                assertThrows(UnsupportedOperationException.class, segment::isLoaded);\n+                assertThrows(UnsupportedOperationException.class, segment::force);\n+                assertFalse(segment.isMapped());\n+                assertEquals(segment.isNative(), segment instanceof NativeMemorySegmentImpl);\n+            }\n+        }\n+    }\n+\n@@ -339,1 +363,1 @@\n-        interface OfAddress extends AllocationFunction<MemorySegment, ValueLayout.OfAddress> { }\n+        interface OfAddress extends AllocationFunction<MemorySegment, AddressLayout> { }\n@@ -351,2 +375,3 @@\n-        SLICING(true, (size, drop) -> SegmentAllocator.slicingAllocator(MemorySegment.allocateNative(size, drop.scope()))),\n-        NATIVE_ALLOCATOR(false, (size, drop) -> SegmentAllocator.nativeAllocator(drop.scope()));\n+        SLICING(true, (size, arena) -> {\n+            return SegmentAllocator.slicingAllocator(arena.allocate(size, 1));\n+        });\n@@ -484,2 +509,1 @@\n-                { SegmentAllocator.nativeAllocator(SegmentScope.global()) },\n-                { SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(10, SegmentScope.global())) },\n+                { SegmentAllocator.prefixAllocator(Arena.global().allocate(10, 1)) },\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.foreign.Arena;\n@@ -32,1 +33,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -147,1 +147,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.foreign.Arena;\n@@ -35,1 +36,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -84,1 +84,1 @@\n-            NATIVE(i -> MemorySegment.allocateNative(i, SegmentScope.auto())),\n+            NATIVE(i -> Arena.ofAuto().allocate(i, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -65,1 +65,1 @@\n-                () -> MemorySegment.allocateNative(16, SegmentScope.auto()),\n+                () -> Arena.ofAuto().allocate(16, 1),\n@@ -68,1 +68,1 @@\n-                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, SegmentScope.auto());\n+                        return fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, 16L, Arena.ofAuto());\n@@ -135,1 +135,1 @@\n-        NATIVE(() -> MemorySegment.allocateNative(16, SegmentScope.auto())),\n+        NATIVE(() -> Arena.ofAuto().allocate(16, 1)),\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,5 +31,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n+\n@@ -53,1 +50,1 @@\n-        MemorySegment.allocateNative(size, align, SegmentScope.auto());\n+        Arena.ofAuto().allocate(size, align);\n@@ -58,3 +55,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            SegmentScope session = arena.scope();\n-            var segment = MemorySegment.allocateNative(0, session);\n+        try (Arena arena = Arena.ofConfined()) {\n+            Arena session = arena;\n+            var segment = session.allocate(0, 1);\n@@ -63,1 +60,1 @@\n-            segment = MemorySegment.allocateNative(seq, session);\n+            segment = session.allocate(seq);\n@@ -66,1 +63,1 @@\n-            segment = MemorySegment.allocateNative(0, 4, session);\n+            segment = session.allocate(0, 4);\n@@ -69,1 +66,1 @@\n-            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address(), 0, session);\n+            MemorySegment rawAddress = MemorySegment.ofAddress(segment.address());\n@@ -78,1 +75,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE, SegmentScope.auto());\n+        Arena.ofAuto().allocate(Long.MAX_VALUE, 1);\n@@ -83,1 +80,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1024L * 1024 * 8 * 2, SegmentScope.auto()); \/\/ 2M\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(1024L * 1024 * 8 * 2, 1); \/\/ 2M\n@@ -89,2 +87,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(1000, 1, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(1000, 1);\n@@ -100,2 +98,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(10, 1, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(10, 1);\n@@ -118,0 +116,15 @@\n+    @Test(dataProvider = \"segmentFactories\")\n+    public void testDerivedScopes(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment segment = segmentSupplier.get();\n+        assertEquals(segment.scope(), segment.scope());\n+        \/\/ one level\n+        assertEquals(segment.asSlice(0).scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().scope(), segment.scope());\n+        \/\/ two levels\n+        assertEquals(segment.asSlice(0).asReadOnly().scope(), segment.scope());\n+        assertEquals(segment.asReadOnly().asSlice(0).scope(), segment.scope());\n+        \/\/ check fresh every time\n+        MemorySegment another = segmentSupplier.get();\n+        assertNotEquals(segment.scope(), another.scope());\n+    }\n+\n@@ -120,2 +133,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            Arena scope1 = arena;\n+            MemorySegment segment = scope1.allocate(100, 1);\n@@ -126,2 +140,2 @@\n-            assertEquals(segment, MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()));\n-            MemorySegment segment2 = MemorySegment.allocateNative(100, arena.scope());\n+            assertEquals(segment, MemorySegment.ofAddress(segment.address()));\n+            MemorySegment segment2 = arena.allocate(100, 1);\n@@ -145,2 +159,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(100, 1);\n@@ -150,1 +164,1 @@\n-            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address(), 100, SegmentScope.global()).hashCode());\n+            assertEquals(segment.hashCode(), MemorySegment.ofAddress(segment.address()).hashCode());\n@@ -165,1 +179,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment memorySegment = scope.allocate(10, 1);\n@@ -172,1 +187,2 @@\n-        MemorySegment memorySegment = MemorySegment.allocateNative(10L, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment memorySegment = scope.allocate(10L, 1);\n@@ -179,1 +195,1 @@\n-            var segment = MemorySegment.allocateNative(10, SegmentScope.global());\n+            var segment = Arena.global().allocate(10, 1);\n@@ -197,4 +213,4 @@\n-                { SegmentScope.auto(), false },\n-                { SegmentScope.global(), false },\n-                { Arena.openConfined().scope(), true },\n-                { Arena.openShared().scope(), false }\n+                { Arena.ofAuto(), false },\n+                { Arena.global(), false },\n+                { Arena.ofConfined(), true },\n+                { Arena.ofShared(), false }\n@@ -205,6 +221,4 @@\n-    public void testIsAccessibleBy(SegmentScope scope, boolean isConfined) {\n-        assertTrue(scope.isAccessibleBy(Thread.currentThread()));\n-        assertTrue(scope.isAccessibleBy(new Thread()) != isConfined);\n-        MemorySegment segment = MemorySegment.ofAddress(0, 0, scope);\n-        assertTrue(segment.scope().isAccessibleBy(Thread.currentThread()));\n-        assertTrue(segment.scope().isAccessibleBy(new Thread()) != isConfined);\n+    public void testIsAccessibleBy(Arena arena, boolean isConfined) {\n+        MemorySegment segment = MemorySegment.NULL.reinterpret(arena, null);\n+        assertTrue(segment.isAccessibleBy(Thread.currentThread()));\n+        assertTrue(segment.isAccessibleBy(new Thread()) != isConfined);\n@@ -223,6 +237,6 @@\n-                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(4L, 8, SegmentScope.auto()),\n-                () -> MemorySegment.allocateNative(JAVA_INT, SegmentScope.auto())\n+                () -> Arena.ofAuto().allocate(4L, 1),\n+                () -> Arena.ofAuto().allocate(4L, 8),\n+                () -> Arena.ofAuto().allocate(JAVA_INT),\n+                () -> Arena.ofAuto().allocate(4L, 1),\n+                () -> Arena.ofAuto().allocate(4L, 8),\n+                () -> Arena.ofAuto().allocate(JAVA_INT)\n@@ -260,1 +274,1 @@\n-    public void testNativeSegments(Supplier<MemorySegment> segmentSupplier) {\n+    public void testHeapBase(Supplier<MemorySegment> segmentSupplier) {\n@@ -262,1 +276,33 @@\n-        assertEquals(segment.isNative(), !segment.array().isPresent());\n+        assertEquals(segment.isNative(), !segment.heapBase().isPresent());\n+        segment = segment.asReadOnly();\n+        assertTrue(segment.heapBase().isEmpty());\n+    }\n+\n+    @Test\n+    public void testScopeConfinedArena() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(100);\n+            assertEquals(segment.scope(), arena.scope());\n+        }\n+    }\n+\n+    @Test\n+    public void testScopeSharedArena() {\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(100);\n+            assertEquals(segment.scope(), arena.scope());\n+        }\n+    }\n+\n+    @Test\n+    public void testScopeAutoArena() {\n+        Arena arena = Arena.ofAuto();\n+        MemorySegment segment = arena.allocate(100);\n+        assertEquals(segment.scope(), arena.scope());\n+    }\n+\n+    @Test\n+    public void testScopeGlobalArena() {\n+        Arena arena = Arena.global();\n+        MemorySegment segment = arena.allocate(100);\n+        assertEquals(segment.scope(), arena.scope());\n@@ -286,1 +332,1 @@\n-        if (!segment.scope().isAccessibleBy(Thread.currentThread())) {\n+        if (!segment.isAccessibleBy(Thread.currentThread())) {\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":93,"deletions":47,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment s = MemorySegment.allocateNative(layout, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment s = arena.allocate(layout);;\n@@ -97,2 +97,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment s = MemorySegment.allocateNative(4, 1, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment s = arena.allocate(4, 1);;\n@@ -102,1 +102,0 @@\n-            MemorySegment sharedSegment = MemorySegment.ofAddress(s.address(), s.byteSize(), arena.scope());\n@@ -105,1 +104,1 @@\n-                    assertEquals(getInt(sharedSegment), 42);\n+                    assertEquals(getInt(s), 42);\n@@ -124,2 +123,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT);\n+            MemorySegment s1 = arena.allocate(layout);;\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -49,2 +51,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(LAYOUT);;\n@@ -64,2 +66,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(LAYOUT);;\n@@ -82,0 +84,53 @@\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffset() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffsetGoodSize() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1, 10);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceGoodOffsetNegativeSize() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(10, -1);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceNegativeOffsetGoodLayout() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(-1, ValueLayout.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetTooBig() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(120);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetTooBigSizeGood() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(120, 0);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceOffsetOkSizeTooBig() {\n+        MemorySegment.ofArray(new byte[100]).asSlice(0, 120);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSliceLayoutTooBig() {\n+        MemorySegment.ofArray(new byte[100])\n+                .asSlice(0, MemoryLayout.sequenceLayout(120, ValueLayout.JAVA_BYTE));\n+    }\n+\n+    @Test(dataProvider = \"segmentsAndLayouts\")\n+    public void testSliceAlignment(MemorySegment segment, long alignment, ValueLayout layout) {\n+        boolean badAlign = layout.byteAlignment() > alignment;\n+        try {\n+            segment.asSlice(0, layout);\n+            assertFalse(badAlign);\n+        } catch (IllegalArgumentException ex) {\n+            assertTrue(badAlign);\n+            assertTrue(ex.getMessage().contains(\"incompatible with alignment constraints\"));\n+        }\n+    }\n+\n@@ -101,0 +156,52 @@\n+\n+    @DataProvider(name = \"segmentsAndLayouts\")\n+    static Object[][] segmentsAndLayouts() {\n+        List<Object[]> segmentsAndLayouts = new ArrayList<>();\n+        for (SegmentKind sk : SegmentKind.values()) {\n+            for (LayoutKind lk : LayoutKind.values()) {\n+                for (int align : new int[]{ 1, 2, 4, 8 }) {\n+                    if (align > sk.maxAlign) break;\n+                    segmentsAndLayouts.add(new Object[] { sk.segment.asSlice(align), align, lk.layout });\n+                }\n+            }\n+        }\n+        return segmentsAndLayouts.toArray(Object[][]::new);\n+    }\n+\n+    enum SegmentKind {\n+        NATIVE(Arena.ofAuto().allocate(100), 8),\n+        BYTE_ARRAY(MemorySegment.ofArray(new byte[100]), 1),\n+        CHAR_ARRAY(MemorySegment.ofArray(new char[100]), 2),\n+        SHORT_ARRAY(MemorySegment.ofArray(new short[100]), 2),\n+        INT_ARRAY(MemorySegment.ofArray(new int[100]), 4),\n+        FLOAT_ARRAY(MemorySegment.ofArray(new float[100]), 4),\n+        LONG_ARRAY(MemorySegment.ofArray(new long[100]), 8),\n+        DOUBLE_ARRAY(MemorySegment.ofArray(new double[100]), 8);\n+\n+\n+        final MemorySegment segment;\n+        final int maxAlign;\n+\n+        SegmentKind(MemorySegment segment, int maxAlign) {\n+            this.segment = segment;\n+            this.maxAlign = maxAlign;\n+        }\n+    }\n+\n+    enum LayoutKind {\n+        BOOL(ValueLayout.JAVA_BOOLEAN),\n+        CHAR(ValueLayout.JAVA_CHAR),\n+        SHORT(ValueLayout.JAVA_SHORT),\n+        INT(ValueLayout.JAVA_INT),\n+        FLOAT(ValueLayout.JAVA_FLOAT),\n+        LONG(ValueLayout.JAVA_LONG),\n+        DOUBLE(ValueLayout.JAVA_DOUBLE),\n+        ADDRESS(ValueLayout.ADDRESS);\n+\n+\n+        final ValueLayout layout;\n+\n+        LayoutKind(ValueLayout segment) {\n+            this.layout = segment;\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":112,"deletions":5,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -30,5 +30,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.*;\n@@ -45,2 +41,0 @@\n-import java.lang.foreign.ValueLayout;\n-\n@@ -62,2 +56,2 @@\n-        try (Arena arena = Arena.openShared()) {\n-            MemorySegment segment = MemorySegment.allocateNative(layout, arena.scope());;\n+        try (Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = arena.allocate(layout);;\n@@ -89,1 +83,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(layout);\n@@ -104,1 +99,2 @@\n-        MemorySegment.allocateNative(2, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(2, 1)\n@@ -110,1 +106,2 @@\n-        MemorySegment.allocateNative(2, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(2, 1)\n@@ -116,1 +113,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -122,1 +120,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -128,1 +127,2 @@\n-        MemorySegment.allocateNative(12, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(12, 1)\n@@ -134,1 +134,2 @@\n-        MemorySegment.allocateNative(12, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(12, 1)\n@@ -140,1 +141,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -146,1 +148,2 @@\n-        MemorySegment.allocateNative(7, SegmentScope.auto())\n+        Arena scope = Arena.ofAuto();\n+        scope.allocate(7, 1)\n@@ -152,1 +155,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(8, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(8, 1);\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -64,2 +64,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -72,2 +72,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n@@ -80,2 +80,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment s = arena.allocate(8, 8);;\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dos.arch=unknown -Dos.name=unknown --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n+ * @run testng\/othervm -Djdk.internal.foreign.CABI=UNSUPPORTED --enable-native-access=ALL-UNNAMED TestUnsupportedLinker\n@@ -32,3 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n-import java.lang.foreign.ValueLayout;\n@@ -44,15 +41,0 @@\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testEmptyVaList() {\n-        VaList.empty();\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNonEmptyVaList() {\n-        VaList.make(builder -> builder.addVarg(ValueLayout.JAVA_INT, 42), SegmentScope.auto());\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testUnsafeVaList() {\n-        VaList.ofAddress(0L, SegmentScope.auto());\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedLinker.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -73,1 +73,1 @@\n-            MemorySegment callback = LINKER.upcallStub(mh, callbackDesc, arena.scope());\n+            MemorySegment callback = LINKER.upcallStub(mh, callbackDesc, arena);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @build ThrowingUpcall TestUpcallException\n+ * @build TestUpcallException\n@@ -40,0 +40,7 @@\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -43,3 +50,3 @@\n-    @Test(dataProvider = \"cases\")\n-    public void testException(boolean useSpec, boolean isVoid) throws InterruptedException, IOException {\n-        runInNewProcess(ThrowingUpcall.class, useSpec, isVoid ? \"void\" : \"\")\n+    @Test(dataProvider = \"exceptionCases\")\n+    public void testException(Class<?> target, boolean useSpec) throws InterruptedException, IOException {\n+        runInNewProcess(target, useSpec)\n@@ -50,1 +57,1 @@\n-    public static Object[][] cases() {\n+    public static Object[][] exceptionCases() {\n@@ -52,4 +59,4 @@\n-            { false, true,  },\n-            { false, false, },\n-            { true,  true,  },\n-            { true,  false, }\n+            { VoidUpcallRunner.class,    false },\n+            { NonVoidUpcallRunner.class, false },\n+            { VoidUpcallRunner.class,    true  },\n+            { NonVoidUpcallRunner.class, true  }\n@@ -58,0 +65,59 @@\n+\n+    public static class VoidUpcallRunner extends ExceptionRunnerBase {\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(VOID_TARGET, FunctionDescriptor.ofVoid(), arena);\n+                downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n+            }\n+        }\n+    }\n+\n+    public static class NonVoidUpcallRunner extends ExceptionRunnerBase {\n+        public static void main(String[] args) throws Throwable {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment stub = Linker.nativeLinker().upcallStub(INT_TARGET, FunctionDescriptor.of(C_INT, C_INT), arena);\n+                downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n+            }\n+        }\n+    }\n+\n+    \/\/ where\n+\n+    private static class ExceptionRunnerBase {\n+        static final MethodHandle downcallVoid;\n+        static final MethodHandle downcallNonVoid;\n+        static final MethodHandle VOID_TARGET;\n+        static final MethodHandle INT_TARGET;\n+\n+        static final Thread.UncaughtExceptionHandler UNCAUGHT_EXCEPTION_HANDLER\n+                = (thread, throwable) -> System.out.println(\"From uncaught exception handler\");\n+\n+        static {\n+                System.loadLibrary(\"TestUpcall\");\n+            downcallVoid = Linker.nativeLinker().downcallHandle(\n+                findNativeOrThrow(\"f0_V__\"),\n+                    FunctionDescriptor.ofVoid(C_POINTER)\n+            );\n+            downcallNonVoid = Linker.nativeLinker().downcallHandle(\n+                    findNativeOrThrow(\"f10_I_I_\"),\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n+            );\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                VOID_TARGET = lookup.findStatic(ExceptionRunnerBase.class, \"throwException\",\n+                        MethodType.methodType(void.class));\n+                INT_TARGET = lookup.findStatic(ExceptionRunnerBase.class, \"throwException\",\n+                        MethodType.methodType(int.class, int.class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+\n+        public static void throwException() {\n+            throw new RuntimeException(\"Testing upcall exceptions\");\n+        }\n+\n+        public static int throwException(int x) {\n+            throw new RuntimeException(\"Testing upcall exceptions\");\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":75,"deletions":9,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=false\n@@ -36,1 +36,1 @@\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.DowncallLinker.USE_SPEC=true\n@@ -40,5 +40,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -92,3 +88,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena.scope());\n-            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena);\n+            MemorySegment argSegment = arena.allocate(S_PDI_LAYOUT);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import java.lang.foreign.SegmentAllocator;\n-import java.lang.foreign.SegmentScope;\n@@ -74,1 +72,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -77,1 +75,1 @@\n-            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena.scope());\n+            MemorySegment writeBack = LINKER.upcallStub(checker, FunctionDescriptor.ofVoid(C_INT, C_POINTER), arena);\n@@ -82,2 +80,0 @@\n-            MemorySegment callInfoPtr = callInfo;\n-\n@@ -102,1 +98,1 @@\n-            argValues.add(callInfoPtr); \/\/ call info\n+            argValues.add(callInfo); \/\/ call info\n@@ -181,2 +177,3 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment seg = MemorySegment.ofAddress(ptr.address(), layout.byteSize(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment seg = ptr.asSlice(0, layout)\n+                    .reinterpret(arena, null);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -69,1 +68,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1L, 2, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(1L, 2);\n@@ -105,2 +105,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, arena.scope());;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(inner_size * outer_size * 8, 4);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-public class ThrowingUpcall extends NativeTestHelper {\n-\n-    private static final MethodHandle downcallVoid;\n-    private static final MethodHandle downcallNonVoid;\n-    public static final MethodHandle MH_throwException;\n-\n-    static {\n-        System.loadLibrary(\"TestUpcall\");\n-        downcallVoid = Linker.nativeLinker().downcallHandle(\n-            findNativeOrThrow(\"f0_V__\"),\n-                FunctionDescriptor.ofVoid(C_POINTER)\n-        );\n-        downcallNonVoid = Linker.nativeLinker().downcallHandle(\n-                findNativeOrThrow(\"f10_I_I_\"),\n-                FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n-        );\n-\n-        try {\n-            MH_throwException = MethodHandles.lookup().findStatic(ThrowingUpcall.class, \"throwException\",\n-                    MethodType.methodType(void.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static void throwException() throws Throwable {\n-        throw new Throwable(\"Testing upcall exceptions\");\n-    }\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args[0].equals(\"void\")) {\n-            testVoid();\n-        } else {\n-            testNonVoid();\n-        }\n-    }\n-\n-    public static void testVoid() throws Throwable {\n-        MethodHandle handle = MH_throwException;\n-        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(void.class));\n-        handle = MethodHandles.insertArguments(invoker, 0, handle);\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), arena.scope());\n-\n-            downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n-        }\n-    }\n-\n-    public static void testNonVoid() throws Throwable {\n-        MethodHandle handle = MethodHandles.identity(int.class);\n-        handle = MethodHandles.collectArguments(handle, 0, MH_throwException);\n-        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(int.class, int.class));\n-        handle = MethodHandles.insertArguments(invoker, 0, handle);\n-\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = Linker.nativeLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), arena.scope());\n-\n-            downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -40,1 +40,1 @@\n-        private static void assertContains(List<String> lines, String shouldInclude) {\n+        private static void assertContains(List<String> lines, String shouldInclude, String name) {\n@@ -42,1 +42,1 @@\n-                \"Did not find '\" + shouldInclude + \"' in stderr\");\n+                \"Did not find '\" + shouldInclude + \"' in \" + name);\n@@ -45,2 +45,8 @@\n-        public void assertStdErrContains(String shouldInclude) {\n-            assertContains(stderr, shouldInclude);\n+        public Output assertStdErrContains(String shouldInclude) {\n+            assertContains(stderr, shouldInclude, \"stderr\");\n+            return this;\n+        }\n+\n+        public Output assertStdOutContains(String shouldInclude) {\n+            assertContains(stdout, shouldInclude, \"stdout\");\n+            return this;\n@@ -62,1 +68,1 @@\n-            \"-Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=\" + useSpec,\n+            \"-Djdk.internal.foreign.UpcallLinker.USE_SPEC=\" + useSpec,\n","filename":"test\/jdk\/java\/foreign\/UpcallTestHelper.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/arraystructs\/TestArrayStructs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @compile platform\/PlatformLayouts.java\n+ * @modules java.base\/jdk.internal.foreign.abi\n+ * @modules java.base\/jdk.internal.foreign.layout\n+ * @run testng TestLayoutEquality\n+ *\/\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n+import platform.PlatformLayouts;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestLayoutEquality {\n+\n+    @Test(dataProvider = \"layoutConstants\")\n+    public void testReconstructedEquality(ValueLayout layout) {\n+        ValueLayout newLayout = ValueLayouts.valueLayout(layout.carrier(), layout.order());\n+        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        if (layout instanceof AddressLayout addressLayout && addressLayout.targetLayout().isPresent()) {\n+            newLayout = ((AddressLayout)newLayout).withTargetLayout(addressLayout.targetLayout().get());\n+        }\n+\n+        \/\/ properties should be equal\n+        assertEquals(newLayout.bitSize(), layout.bitSize());\n+        assertEquals(newLayout.bitAlignment(), layout.bitAlignment());\n+        assertEquals(newLayout.name(), layout.name());\n+\n+        \/\/ layouts should be equals\n+        assertEquals(newLayout, layout);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] layoutConstants() throws ReflectiveOperationException {\n+        List<ValueLayout> testValues = new ArrayList<>();\n+\n+        addLayoutConstants(testValues, PlatformLayouts.SysV.class);\n+        addLayoutConstants(testValues, PlatformLayouts.Win64.class);\n+        addLayoutConstants(testValues, PlatformLayouts.AArch64.class);\n+        addLayoutConstants(testValues, PlatformLayouts.RISCV64.class);\n+\n+        return testValues.stream().map(e -> new Object[]{ e }).toArray(Object[][]::new);\n+    }\n+\n+    private static void addLayoutConstants(List<ValueLayout> testValues, Class<?> cls) throws ReflectiveOperationException {\n+        for (Field f : cls.getFields()) {\n+            if (f.getName().startsWith(\"C_\"))\n+                testValues.add((ValueLayout) f.get(null));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLayoutEquality.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -53,1 +54,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n@@ -57,0 +57,1 @@\n+import static platform.PlatformLayouts.AArch64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -53,1 +54,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n@@ -57,0 +57,1 @@\n+import static platform.PlatformLayouts.AArch64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -42,1 +43,0 @@\n-import java.lang.foreign.StructLayout;\n@@ -52,0 +52,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -56,1 +57,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.RISCV64.*;\n@@ -60,0 +60,1 @@\n+import static platform.PlatformLayouts.RISCV64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestRISCV64CallArranger.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -50,1 +51,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.SysV.*;\n@@ -54,0 +54,1 @@\n+import static platform.PlatformLayouts.SysV.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -37,1 +38,0 @@\n-import java.lang.foreign.StructLayout;\n@@ -52,1 +52,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n@@ -56,0 +55,1 @@\n+import static platform.PlatformLayouts.AArch64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @compile platform\/PlatformLayouts.java\n@@ -51,1 +52,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.Win64.*;\n@@ -56,0 +56,1 @@\n+import static platform.PlatformLayouts.Win64.*;\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package platform;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.ValueLayout;\n+\n+public final class PlatformLayouts {\n+\n+    \/\/ Suppresses default constructor, ensuring non-instantiability.\n+    private PlatformLayouts() {}\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the x64 SystemV ABI.\n+     *\/\n+    public static final class SysV {\n+\n+        \/\/ Suppresses default constructor, ensuring non-instantiability.\n+        private SysV() {}\n+\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;;\n+\n+    }\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the x64 Windows ABI.\n+     *\/\n+    public static final class Win64 {\n+\n+        \/\/ Suppresses default constructor, ensuring non-instantiability.\n+        private Win64() {}\n+\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n+\n+    }\n+\n+    \/**\n+     * This class defines layout constants modelling standard primitive types supported by the AArch64 ABI.\n+     *\/\n+    public static final class AArch64 {\n+\n+        \/\/ Suppresses default constructor, ensuring non-instantiability.\n+        private AArch64() {}\n+\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n+\n+    }\n+\n+    public static final class RISCV64 {\n+\n+        \/\/ Suppresses default constructor, ensuring non-instantiability.\n+        private RISCV64() {}\n+\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n+        \/**\n+         * The {@code char} native type.\n+         *\/\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+\n+        \/**\n+         * The {@code short} native type.\n+         *\/\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+\n+        \/**\n+         * The {@code int} native type.\n+         *\/\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+        \/**\n+         * The {@code long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code long long} native type.\n+         *\/\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+\n+        \/**\n+         * The {@code float} native type.\n+         *\/\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+\n+        \/**\n+         * The {@code double} native type.\n+         *\/\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+\n+        \/**\n+         * The {@code T*} native type.\n+         *\/\n+        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/platform\/PlatformLayouts.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-        Linker.Option.CaptureCallState stl = Linker.Option.captureCallState(testCase.threadLocalName());\n+        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n@@ -72,1 +72,2 @@\n-        VarHandle errnoHandle = stl.layout().varHandle(groupElement(testCase.threadLocalName()));\n+        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n+        VarHandle errnoHandle = capturedStateLayout.varHandle(groupElement(testCase.threadLocalName()));\n@@ -74,2 +75,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment saveSeg = arena.allocate(stl.layout());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment saveSeg = arena.allocate(capturedStateLayout);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -71,2 +70,2 @@\n-    static ByteBuffer segmentBufferOfSize(SegmentScope session, int size) {\n-        var segment = MemorySegment.allocateNative(size, 1, session);\n+    static ByteBuffer segmentBufferOfSize(Arena session, int size) {\n+        var segment = session.allocate(size, 1);\n@@ -79,1 +78,1 @@\n-    static ByteBuffer[] segmentBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] segmentBuffersOfSize(int len, Arena session, int size) {\n@@ -91,1 +90,1 @@\n-    static ByteBuffer[] mixedBuffersOfSize(int len, SegmentScope session, int size) {\n+    static ByteBuffer[] mixedBuffersOfSize(int len, Arena session, int size) {\n@@ -156,1 +155,1 @@\n-                new ArenaSupplier(Arena::openConfined, \"confined arena\");\n+                new ArenaSupplier(Arena::ofConfined, \"confined arena\");\n@@ -158,1 +157,1 @@\n-                new ArenaSupplier(Arena::openShared, \"shared arena\");\n+                new ArenaSupplier(Arena::ofShared, \"shared arena\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -78,1 +78,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -111,2 +112,2 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 64);\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 32);\n+            ByteBuffer bb = segmentBufferOfSize(drop, 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop, 32);\n@@ -163,2 +164,4 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope1 = drop;\n+            MemorySegment segment1 = scope1.allocate(10, 1);\n+            Arena scope = drop;\n+            MemorySegment segment2 = scope.allocate(10, 1);\n@@ -187,2 +190,2 @@\n-                var writeBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n-                var readBuffers = mixedBuffersOfSize(16, drop.scope(), 32);\n+                var writeBuffers = mixedBuffersOfSize(16, drop, 32);\n+                var readBuffers = mixedBuffersOfSize(16, drop, 32);\n@@ -210,1 +213,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -255,1 +259,1 @@\n-            var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n+            var bba = segmentBuffersOfSize(32, drop, 128);\n@@ -264,1 +268,1 @@\n-                                var bba = segmentBuffersOfSize(32, drop.scope(), 128);\n+                                var bba = segmentBuffersOfSize(32, drop, 128);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            ByteBuffer bb = segmentBufferOfSize(drop.scope(), 16);\n+            ByteBuffer bb = segmentBufferOfSize(drop, 16);\n@@ -87,1 +87,1 @@\n-            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop.scope(), 16);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, drop, 16);\n@@ -105,2 +105,4 @@\n-            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, drop.scope());\n-            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope1 = drop;\n+            MemorySegment segment1 = scope1.allocate(10, 1);\n+            Arena scope = drop;\n+            MemorySegment segment2 = scope.allocate(10, 1);\n@@ -144,1 +146,2 @@\n-            var segment = MemorySegment.allocateNative(10, 1, drop.scope());\n+            Arena scope = drop;\n+            var segment = scope.allocate(10, 1);\n@@ -174,2 +177,2 @@\n-            var writeBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n-            var readBuffers = mixedBuffersOfSize(32, drop.scope(), 64);\n+            var writeBuffers = mixedBuffersOfSize(32, drop, 64);\n+            var readBuffers = mixedBuffersOfSize(32, drop, 64);\n@@ -192,1 +195,1 @@\n-            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, drop1, 64), mixedBuffersOfSize(16, drop2, 64))\n@@ -195,1 +198,1 @@\n-            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1.scope(), 64), mixedBuffersOfSize(16, drop2.scope(), 64))\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, drop1, 64), mixedBuffersOfSize(16, drop2, 64))\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.ref java.base\/jdk.internal.foreign\n@@ -32,0 +33,1 @@\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -52,1 +54,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -54,1 +56,1 @@\n-            arena.scope().whileAlive(() -> {\n+            ((MemorySessionImpl)arena.scope()).whileAlive(() -> {\n","filename":"test\/jdk\/java\/foreign\/dontrelease\/TestDontRelease.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -43,1 +43,1 @@\n-        MemorySegment.ofAddress(0, 4000, SegmentScope.global());\n+        MemorySegment.NULL.reinterpret(10);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainDirect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -46,3 +46,3 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class));\n-        var seg = (MemorySegment)mh.invokeExact(0L, 4000L, SegmentScope.global());\n+        var mh = MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                MethodType.methodType(MemorySegment.class, long.class));\n+        var seg = (MemorySegment)mh.invokeExact(MemorySegment.NULL, 10L);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -45,2 +45,2 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddress\", long.class, long.class, SegmentScope.class);\n-        method.invoke(null, 0L, 4000L, SegmentScope.global());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"reinterpret\", long.class);\n+        method.invoke(MemorySegment.NULL, 10L);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n@@ -42,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -75,1 +77,2 @@\n-        addDefaultMapping(SegmentScope.class, SegmentScope.auto());\n+        addDefaultMapping(Arena.class, Arena.ofAuto());\n+        addDefaultMapping(MemorySegment.Scope.class, Arena.ofAuto().scope());\n@@ -85,1 +88,1 @@\n-        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(AddressLayout.class, ValueLayout.ADDRESS);\n@@ -87,0 +90,1 @@\n+        addDefaultMapping(Consumer.class, (Consumer<Object>)(Object o) -> {});\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -37,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -53,9 +54,9 @@\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class)),\n-                            \"MemorySegment::ofAddress\/2\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class)),\n-                            \"MemorySegment::ofAddress\/3\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddress\",\n-                            MethodType.methodType(MemorySegment.class, long.class, long.class, SegmentScope.class, Runnable.class)),\n-                            \"MemorySegment::ofAddress\/4\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, long.class)),\n+                            \"MemorySegment::reinterpret\/1\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, Arena.class, Consumer.class)),\n+                            \"MemorySegment::reinterpret\/2\" },\n+                    { MethodHandles.lookup().findVirtual(MemorySegment.class, \"reinterpret\",\n+                            MethodType.methodType(MemorySegment.class, long.class, Arena.class, Consumer.class)),\n+                            \"MemorySegment::reinterpret\/3\" },\n@@ -63,1 +64,1 @@\n-                            MethodType.methodType(SymbolLookup.class, String.class, SegmentScope.class)),\n+                            MethodType.methodType(SymbolLookup.class, String.class, Arena.class)),\n@@ -66,1 +67,1 @@\n-                            MethodType.methodType(SymbolLookup.class, Path.class, SegmentScope.class)),\n+                            MethodType.methodType(SymbolLookup.class, Path.class, Arena.class)),\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void* get_addr(void* align) {\n+    return align;\n+}\n+\n+EXPORT void get_addr_cb(void* align, void (*cb)(void*)) {\n+    cb(align);\n+}\n","filename":"test\/jdk\/java\/foreign\/libAddressDereference.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/foreign\/nested\/TestNested.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,5 +39,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -118,1 +114,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -121,1 +117,1 @@\n-            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena.scope());\n+            MemorySegment upcallStub = LINKER.upcallStub(saver, upcallDesc, arena);\n@@ -188,2 +184,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment callback = LINKER.upcallStub(upcallTarget, FunctionDescriptor.ofVoid(JAVA_BOOLEAN), arena);\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -118,2 +118,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -74,1 +74,1 @@\n-                    MethodHandles.insertArguments(MH_m, 2, downcallHandle), descriptor, arena.scope());\n+                    MethodHandles.insertArguments(MH_m, 2, downcallHandle), descriptor, arena);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestReentrantUpcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,2 +117,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), arena);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivial\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestTrivial extends NativeTestHelper {\n+\n+    static {\n+        System.loadLibrary(\"Trivial\");\n+    }\n+\n+    @Test\n+    public void testEmpty() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"empty\", FunctionDescriptor.ofVoid(), Linker.Option.isTrivial());\n+        handle.invokeExact();\n+    }\n+\n+    @Test\n+    public void testIdentity() throws Throwable {\n+        MethodHandle handle = downcallHandle(\"identity\", FunctionDescriptor.of(C_INT, C_INT), Linker.Option.isTrivial());\n+        int result = (int) handle.invokeExact(42);\n+        assertEquals(result, 42);\n+    }\n+\n+    @Test\n+    public void testWithReturnBuffer() throws Throwable {\n+        StructLayout bigLayout = MemoryLayout.structLayout(\n+                C_LONG_LONG.withName(\"x\"),\n+                C_LONG_LONG.withName(\"y\"));\n+\n+        MethodHandle handle = downcallHandle(\"with_return_buffer\", FunctionDescriptor.of(bigLayout), Linker.Option.isTrivial());\n+        VarHandle vhX = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"x\"));\n+        VarHandle vhY = bigLayout.varHandle(MemoryLayout.PathElement.groupElement(\"y\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment result = (MemorySegment) handle.invokeExact((SegmentAllocator) arena);\n+            long x = (long) vhX.get(result);\n+            assertEquals(x, 10);\n+            long y = (long) vhY.get(result);\n+            assertEquals(y, 11);\n+        }\n+    }\n+\n+    @Test\n+    public void testCaptureErrno() throws Throwable {\n+        Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n+        MethodHandle handle = downcallHandle(\"capture_errno\", FunctionDescriptor.ofVoid(C_INT), Linker.Option.isTrivial(), ccs);\n+        StructLayout capturedStateLayout = Linker.Option.captureStateLayout();\n+        VarHandle errnoHandle = capturedStateLayout.varHandle(MemoryLayout.PathElement.groupElement(\"errno\"));\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment captureSeg = arena.allocate(capturedStateLayout);\n+            handle.invokeExact(captureSeg, 42);\n+            int capturedErrno = (int) errnoHandle.get(captureSeg);\n+            assertEquals(capturedErrno, 42);\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivial.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @library ..\/ \/test\/lib\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @requires vm.flavor != \"zero\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestTrivialUpcall\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+\n+import static org.testng.Assert.fail;\n+\n+public class TestTrivialUpcall extends UpcallTestHelper {\n+\n+    @Test\n+    public void testUpcallFailure() throws IOException, InterruptedException {\n+        \/\/ test to see if we catch a trivial downcall doing an upcall\n+        runInNewProcess(Runner.class, true).assertStdOutContains(\"wrong thread state for upcall\");\n+    }\n+\n+    public static class Runner extends NativeTestHelper {\n+        public static void main(String[] args) throws Throwable {\n+            System.loadLibrary(\"Trivial\");\n+\n+            MethodHandle mh = downcallHandle(\"do_upcall\", FunctionDescriptor.ofVoid(C_POINTER), Linker.Option.isTrivial());\n+            MemorySegment stub = upcallStub(Runner.class, \"target\", FunctionDescriptor.ofVoid());\n+            mh.invokeExact(stub);\n+        }\n+\n+        public static void target() {\n+            fail(\"Should not get here\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/TestTrivialUpcall.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void empty() {}\n+\n+EXPORT int identity(int value) {\n+    return value;\n+}\n+\n+\/\/ 128 bit struct returned in buffer on SysV\n+struct Big {\n+    long long x;\n+    long long y;\n+};\n+\n+EXPORT struct Big with_return_buffer() {\n+    struct Big b;\n+    b.x = 10;\n+    b.y = 11;\n+    return b;\n+}\n+\n+EXPORT void capture_errno(int value) {\n+    errno = value;\n+}\n+\n+EXPORT void do_upcall(void(*f)(void)) {\n+    f();\n+}\n","filename":"test\/jdk\/java\/foreign\/trivial\/libTrivial.c","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -82,2 +82,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(C_INT, C_INT, C_INT, C_INT), arena);\n","filename":"test\/jdk\/java\/foreign\/upcalldeopt\/TestUpcallDeopt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,933 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @library ..\/\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n- * @modules java.base\/jdk.internal.foreign\n- *          java.base\/jdk.internal.foreign.abi\n- *          java.base\/jdk.internal.foreign.abi.x64\n- *          java.base\/jdk.internal.foreign.abi.x64.sysv\n- *          java.base\/jdk.internal.foreign.abi.x64.windows\n- *          java.base\/jdk.internal.foreign.abi.aarch64\n- *          java.base\/jdk.internal.foreign.abi.aarch64.linux\n- *          java.base\/jdk.internal.foreign.abi.aarch64.macos\n- *          java.base\/jdk.internal.foreign.abi.aarch64.windows\n- *          java.base\/jdk.internal.foreign.abi.riscv64\n- *          java.base\/jdk.internal.foreign.abi.riscv64.linux\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED VaListTest\n- *\/\n-\n-import java.lang.foreign.*;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.VaList;\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n-import jdk.internal.foreign.abi.riscv64.linux.LinuxRISCV64Linker;\n-import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n-import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.util.List;\n-import java.util.NoSuchElementException;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import java.util.stream.DoubleStream;\n-import java.util.stream.IntStream;\n-\n-import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static java.lang.foreign.ValueLayout.JAVA_DOUBLE;\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-import static org.testng.Assert.*;\n-\n-public class VaListTest extends NativeTestHelper {\n-\n-    private static final Linker abi = Linker.nativeLinker();\n-    static {\n-        System.loadLibrary(\"VaList\");\n-    }\n-\n-    private static final MethodHandle VALIST_TO_ADDRESS;\n-    private static final MethodHandle SEGMENT_TO_VALIST;\n-\n-    static {\n-        try {\n-            VALIST_TO_ADDRESS = MethodHandles.lookup().findVirtual(VaList.class, \"segment\", MethodType.methodType(MemorySegment.class));\n-            SEGMENT_TO_VALIST = MethodHandles.lookup().findStatic(VaListTest.class, \"segmentToValist\", MethodType.methodType(VaList.class, MemorySegment.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-\n-    private static final MethodHandle MH_sumInts = linkVaList(\"sumInts\",\n-            FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumDoubles = linkVaList(\"sumDoubles\",\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, C_POINTER));\n-    private static final MethodHandle MH_getInt = linkVaList(\"getInt\",\n-            FunctionDescriptor.of(C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumStruct = linkVaList(\"sumStruct\",\n-            FunctionDescriptor.of(C_INT, C_POINTER));\n-    private static final MethodHandle MH_sumBigStruct = linkVaList(\"sumBigStruct\",\n-            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n-    private static final MethodHandle MH_sumHugeStruct = linkVaList(\"sumHugeStruct\",\n-            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n-    private static final MethodHandle MH_sumFloatStruct = linkVaList(\"sumFloatStruct\",\n-            FunctionDescriptor.of(C_FLOAT, C_POINTER));\n-    private static final MethodHandle MH_sumStack = linkVaList(\"sumStack\",\n-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER));\n-\n-    private static MethodHandle link(String symbol, FunctionDescriptor fd) {\n-        return linkInternal(symbol, fd);\n-    }\n-\n-    private static MethodHandle linkVaList(String symbol, FunctionDescriptor fd) {\n-        return MethodHandles.filterArguments(linkInternal(symbol, fd), fd.argumentLayouts().size() - 1, VALIST_TO_ADDRESS);\n-    }\n-\n-\n-    private static MethodHandle linkInternal(String symbol, FunctionDescriptor fd) {\n-        return abi.downcallHandle(findNativeOrThrow(symbol), fd);\n-    }\n-\n-    private static MethodHandle linkVaListCB(String symbol) {\n-        return link(symbol,\n-                FunctionDescriptor.ofVoid(C_POINTER));\n-\n-    }\n-\n-    private static final Function<Consumer<VaList.Builder>, VaList> winVaListFactory\n-            = actions -> Windowsx64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> sysvVaListFactory\n-            = actions -> SysVx64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> linuxAArch64VaListFactory\n-            = actions -> LinuxAArch64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> macAArch64VaListFactory\n-            = actions -> MacOsAArch64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> linuxRISCV64VaListFactory\n-            = actions -> LinuxRISCV64Linker.newVaList(actions, SegmentScope.auto());\n-    private static final Function<Consumer<VaList.Builder>, VaList> platformVaListFactory\n-            = (builder) -> VaList.make(builder, SegmentScope.auto());\n-\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> winVaListScopedFactory\n-            = Windowsx64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> sysvVaListScopedFactory\n-            = SysVx64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> linuxAArch64VaListScopedFactory\n-            = LinuxAArch64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> macAArch64VaListScopedFactory\n-            = MacOsAArch64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> linuxRISCV64VaListScopedFactory\n-            = LinuxRISCV64Linker::newVaList;\n-    private static final BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> platformVaListScopedFactory\n-            = VaList::make;\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumInts() {\n-        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Integer> sumIntsNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);\n-        return new Object[][]{\n-                { winVaListFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { linuxAArch64VaListFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { macAArch64VaListFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { linuxRISCV64VaListFactory, sumIntsJavaFact.apply(RISCV64.C_INT), RISCV64.C_INT },\n-                { platformVaListFactory,     sumIntsNative,                        C_INT         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumInts\")\n-    public void testIntSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                           BiFunction<Integer, VaList, Integer> sumInts,\n-                           ValueLayout.OfInt intLayout) {\n-        VaList vaList = vaListFactory.apply(b ->\n-                b.addVarg(intLayout, 10)\n-                        .addVarg(intLayout, 15)\n-                        .addVarg(intLayout, 20));\n-        int x = sumInts.apply(3, vaList);\n-        assertEquals(x, 45);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumDoubles() {\n-        Function<ValueLayout.OfDouble, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n-                (num, list) -> DoubleStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Double> sumDoublesNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumDoubles);\n-        return new Object[][]{\n-                { winVaListFactory,          sumDoublesJavaFact.apply(Win64.C_DOUBLE),   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,         sumDoublesJavaFact.apply(SysV.C_DOUBLE),    SysV.C_DOUBLE    },\n-                { linuxAArch64VaListFactory, sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { macAArch64VaListFactory,   sumDoublesJavaFact.apply(AArch64.C_DOUBLE), AArch64.C_DOUBLE },\n-                { linuxRISCV64VaListFactory, sumDoublesJavaFact.apply(RISCV64.C_DOUBLE), RISCV64.C_DOUBLE },\n-                { platformVaListFactory,     sumDoublesNative,                           C_DOUBLE         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumDoubles\")\n-    public void testDoubleSum(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                              BiFunction<Integer, VaList, Double> sumDoubles,\n-                              ValueLayout.OfDouble doubleLayout) {\n-        VaList vaList = vaListFactory.apply(b ->\n-                b.addVarg(doubleLayout, 3.0D)\n-                        .addVarg(doubleLayout, 4.0D)\n-                        .addVarg(doubleLayout, 5.0D));\n-        double x = sumDoubles.apply(3, vaList);\n-        assertEquals(x, 12.0D);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] pointers() {\n-        Function<ValueLayout.OfAddress, Function<VaList, Integer>> getIntJavaFact = layout ->\n-                list -> {\n-                    MemorySegment ma = list.nextVarg(layout);\n-                    return ma.get(JAVA_INT, 0);\n-                };\n-        Function<VaList, Integer> getIntNative = MethodHandleProxies.asInterfaceInstance(Function.class, MH_getInt);\n-        return new Object[][]{\n-                { winVaListFactory,          getIntJavaFact.apply(Win64.C_POINTER),   Win64.C_POINTER   },\n-                { sysvVaListFactory,         getIntJavaFact.apply(SysV.C_POINTER),    SysV.C_POINTER    },\n-                { linuxAArch64VaListFactory, getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { macAArch64VaListFactory,   getIntJavaFact.apply(AArch64.C_POINTER), AArch64.C_POINTER },\n-                { linuxRISCV64VaListFactory, getIntJavaFact.apply(RISCV64.C_POINTER), RISCV64.C_POINTER },\n-                { platformVaListFactory,     getIntNative,                            C_POINTER         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"pointers\")\n-    public void testVaListMemorySegment(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                        Function<VaList, Integer> getFromPointer,\n-                                        ValueLayout.OfAddress pointerLayout) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, arena.scope());;\n-            msInt.set(JAVA_INT, 0, 10);\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt));\n-            int x = getFromPointer.apply(vaList);\n-            assertEquals(x, 10);\n-        }\n-    }\n-\n-    interface TriFunction<S, T, U, R> {\n-        R apply(S s, T t, U u);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] structs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n-                = (pointLayout, VH_Point_x, VH_Point_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, SegmentScope.auto());\n-                    list.nextVarg(pointLayout, SegmentAllocator.prefixAllocator(struct));\n-                    int x = (int) VH_Point_x.get(struct);\n-                    int y = (int) VH_Point_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n-                = (pointLayout, VH_Point_x, VH_Point_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n-                = (vaListFact, intLayout, sumStructFact) -> {\n-            GroupLayout pointLayout =  MemoryLayout.structLayout(\n-                    intLayout.withName(\"x\"),\n-                    intLayout.withName(\"y\")\n-            );\n-            VarHandle VH_Point_x = pointLayout.varHandle(groupElement(\"x\"));\n-            VarHandle VH_Point_y = pointLayout.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumStructFact.apply(pointLayout, VH_Point_x, VH_Point_y),\n-                    pointLayout, VH_Point_x, VH_Point_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_INT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_INT,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_INT, sumStructJavaFact),\n-                argsFact.apply(linuxRISCV64VaListFactory, RISCV64.C_INT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_INT,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                           Function<VaList, Integer> sumStruct,\n-                           GroupLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n-            VH_Point_x.set(struct, 5);\n-            VH_Point_y.set(struct, 10);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, struct));\n-            int sum = sumStruct.apply(vaList);\n-            assertEquals(sum, 15);\n-        }\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] bigStructs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n-                = (BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    long x = (long) VH_BigPoint_x.get(struct);\n-                    long y = (long) VH_BigPoint_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n-                = (pointLayout, VH_BigPoint_x, VH_BigPoint_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumBigStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n-                = (vaListFact, longLongLayout, sumBigStructFact) -> {\n-            GroupLayout BigPoint_LAYOUT =  MemoryLayout.structLayout(\n-                    longLongLayout.withName(\"x\"),\n-                    longLongLayout.withName(\"y\")\n-            );\n-            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumBigStructFact.apply(BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y),\n-                    BigPoint_LAYOUT, VH_BigPoint_x, VH_BigPoint_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(linuxRISCV64VaListFactory, RISCV64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"bigStructs\")\n-    public void testBigStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                              Function<VaList, Long> sumBigStruct,\n-                              GroupLayout BigPoint_LAYOUT, VarHandle VH_BigPoint_x, VarHandle VH_BigPoint_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, arena.scope());;\n-            VH_BigPoint_x.set(struct, 5);\n-            VH_BigPoint_y.set(struct, 10);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(BigPoint_LAYOUT, struct));\n-            long sum = sumBigStruct.apply(vaList);\n-            assertEquals(sum, 15);\n-        }\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] floatStructs() {\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n-                = (FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    float x = (float) VH_FloatPoint_x.get(struct);\n-                    float y = (float) VH_FloatPoint_y.get(struct);\n-                    return x + y;\n-                };\n-\n-        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n-                = (pointLayout, VH_FloatPoint_x, VH_FloatPoint_y) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumFloatStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n-                = (vaListFact, floatLayout, sumFloatStructFact) -> {\n-            GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n-                    floatLayout.withName(\"x\"),\n-                    floatLayout.withName(\"y\")\n-            );\n-            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            return new Object[] { vaListFact, sumFloatStructFact.apply(FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y),\n-                    FloatPoint_LAYOUT, VH_FloatPoint_x, VH_FloatPoint_y  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_FLOAT,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_FLOAT,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(linuxRISCV64VaListFactory, RISCV64.C_FLOAT, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_FLOAT,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"floatStructs\")\n-    public void testFloatStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                Function<VaList, Float> sumFloatStruct,\n-                                GroupLayout FloatPoint_LAYOUT,\n-                                VarHandle VH_FloatPoint_x, VarHandle VH_FloatPoint_y) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, arena.scope());;\n-            VH_FloatPoint_x.set(struct, 1.234f);\n-            VH_FloatPoint_y.set(struct, 3.142f);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(FloatPoint_LAYOUT, struct));\n-            float sum = sumFloatStruct.apply(vaList);\n-            assertEquals(sum, 4.376f, 0.00001f);\n-        }\n-    }\n-\n-    interface QuadFunc<T0, T1, T2, T3, R> {\n-        R apply(T0 t0, T1 t1, T2 t2, T3 t3);\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] hugeStructs() {\n-        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n-                = (HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->\n-                list -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n-                    list.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    long x = (long) VH_HugePoint_x.get(struct);\n-                    long y = (long) VH_HugePoint_y.get(struct);\n-                    long z = (long) VH_HugePoint_z.get(struct);\n-                    return x + y + z;\n-                };\n-\n-        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n-                = (pointLayout, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z) ->\n-                MethodHandleProxies.asInterfaceInstance(Function.class, MH_sumHugeStruct);\n-\n-        TriFunction<Function<Consumer<VaList.Builder>, VaList>, MemoryLayout,\n-                QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n-                = (vaListFact, longLongLayout, sumBigStructFact) -> {\n-            GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n-                    longLongLayout.withName(\"x\"),\n-                    longLongLayout.withName(\"y\"),\n-                    longLongLayout.withName(\"z\")\n-            );\n-            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n-            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n-            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n-            return new Object[] { vaListFact,\n-                    sumBigStructFact.apply(HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z),\n-                    HugePoint_LAYOUT, VH_HugePoint_x, VH_HugePoint_y, VH_HugePoint_z  };\n-        };\n-        return new Object[][]{\n-                argsFact.apply(winVaListFactory,          Win64.C_LONG_LONG,   sumStructJavaFact),\n-                argsFact.apply(sysvVaListFactory,         SysV.C_LONG_LONG,    sumStructJavaFact),\n-                argsFact.apply(linuxAArch64VaListFactory, AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(macAArch64VaListFactory,   AArch64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(linuxRISCV64VaListFactory, RISCV64.C_LONG_LONG, sumStructJavaFact),\n-                argsFact.apply(platformVaListFactory,     C_LONG_LONG,         sumStructNativeFact),\n-        };\n-    }\n-\n-    @Test(dataProvider = \"hugeStructs\")\n-    public void testHugeStruct(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                               Function<VaList, Long> sumHugeStruct,\n-                               GroupLayout HugePoint_LAYOUT,\n-                               VarHandle VH_HugePoint_x, VarHandle VH_HugePoint_y, VarHandle VH_HugePoint_z) {\n-        \/\/ On AArch64 a struct needs to be larger than 16 bytes to be\n-        \/\/ passed by reference.\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, arena.scope());;\n-            VH_HugePoint_x.set(struct, 1);\n-            VH_HugePoint_y.set(struct, 2);\n-            VH_HugePoint_z.set(struct, 3);\n-\n-            VaList vaList = vaListFactory.apply(b -> b.addVarg(HugePoint_LAYOUT, struct));\n-            long sum = sumHugeStruct.apply(vaList);\n-            assertEquals(sum, 6);\n-        }\n-    }\n-\n-    public interface SumStackFunc {\n-        void invoke(MemorySegment longSum, MemorySegment doubleSum, VaList list);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] sumStack() {\n-        BiFunction<ValueLayout.OfLong, ValueLayout.OfDouble, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n-                (longSum, doubleSum, list) -> {\n-                    long lSum = 0L;\n-                    for (int i = 0; i < 16; i++) {\n-                        lSum += list.nextVarg(longLayout);\n-                    }\n-                    longSum.set(JAVA_LONG, 0, lSum);\n-                    double dSum = 0D;\n-                    for (int i = 0; i < 16; i++) {\n-                        dSum += list.nextVarg(doubleLayout);\n-                    }\n-                    doubleSum.set(JAVA_DOUBLE, 0, dSum);\n-                };\n-        SumStackFunc sumStackNative = (longSum, doubleSum, list) -> {\n-            try {\n-                MH_sumStack.invokeExact(longSum, doubleSum, list);\n-            } catch (Throwable ex) {\n-                throw new AssertionError(ex);\n-            }\n-        };\n-        return new Object[][]{\n-                { winVaListFactory,           sumStackJavaFact.apply(Win64.C_LONG_LONG, Win64.C_DOUBLE),     Win64.C_LONG_LONG,   Win64.C_DOUBLE   },\n-                { sysvVaListFactory,          sumStackJavaFact.apply(SysV.C_LONG_LONG, SysV.C_DOUBLE),       SysV.C_LONG_LONG,    SysV.C_DOUBLE    },\n-                { linuxAArch64VaListFactory,  sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { macAArch64VaListFactory,    sumStackJavaFact.apply(AArch64.C_LONG_LONG, AArch64.C_DOUBLE), AArch64.C_LONG_LONG, AArch64.C_DOUBLE },\n-                { linuxRISCV64VaListFactory,  sumStackJavaFact.apply(RISCV64.C_LONG_LONG, RISCV64.C_DOUBLE), RISCV64.C_LONG_LONG, RISCV64.C_DOUBLE },\n-                { platformVaListFactory,      sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumStack\")\n-    public void testStack(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                          SumStackFunc sumStack,\n-                          ValueLayout.OfLong longLayout,\n-                          ValueLayout.OfDouble doubleLayout) {\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment longSum = MemorySegment.allocateNative(longLayout, arena.scope());;\n-            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, arena.scope());;\n-            longSum.set(JAVA_LONG, 0, 0L);\n-            doubleSum.set(JAVA_DOUBLE, 0, 0D);\n-\n-            VaList list = vaListFactory.apply(b -> {\n-                for (long l = 1; l <= 16L; l++) {\n-                    b.addVarg(longLayout, l);\n-                }\n-                for (double d = 1; d <= 16D; d++) {\n-                    b.addVarg(doubleLayout, d);\n-                }\n-            });\n-\n-            sumStack.invoke(longSum, doubleSum, list);\n-\n-            long lSum = longSum.get(JAVA_LONG, 0);\n-            double dSum = doubleSum.get(JAVA_DOUBLE, 0);\n-\n-            assertEquals(lSum, 136L);\n-            assertEquals(dSum, 136D);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"upcalls\")\n-    public void testUpcall(MethodHandle target, MethodHandle callback) throws Throwable {\n-        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_POINTER);\n-        try (Arena arena = Arena.openConfined()) {\n-            MemorySegment stub = abi.upcallStub(callback, desc, arena.scope());\n-            target.invokeExact(stub);\n-        }\n-    }\n-\n-    @DataProvider\n-    public Object[][] emptyVaLists() {\n-        return new Object[][] {\n-                { Windowsx64Linker.emptyVaList()           },\n-                { winVaListFactory.apply(b -> {})          },\n-                { SysVx64Linker.emptyVaList()              },\n-                { sysvVaListFactory.apply(b -> {})         },\n-                { LinuxAArch64Linker.emptyVaList()         },\n-                { linuxAArch64VaListFactory.apply(b -> {}) },\n-                { MacOsAArch64Linker.emptyVaList()         },\n-                { macAArch64VaListFactory.apply(b -> {})   },\n-                { LinuxRISCV64Linker.emptyVaList()         },\n-                { linuxRISCV64VaListFactory.apply(b -> {}) },\n-        };\n-    }\n-\n-    @DataProvider\n-    @SuppressWarnings(\"unchecked\")\n-    public static Object[][] sumIntsScoped() {\n-        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n-        BiFunction<Integer, VaList, Integer> sumIntsNative\n-                = MethodHandleProxies.asInterfaceInstance(BiFunction.class, MH_sumInts);\n-        return new Object[][]{\n-                { winVaListScopedFactory,          sumIntsJavaFact.apply(Win64.C_INT),   Win64.C_INT   },\n-                { sysvVaListScopedFactory,         sumIntsJavaFact.apply(SysV.C_INT),    SysV.C_INT    },\n-                { linuxAArch64VaListScopedFactory, sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { macAArch64VaListScopedFactory,   sumIntsJavaFact.apply(AArch64.C_INT), AArch64.C_INT },\n-                { linuxRISCV64VaListScopedFactory, sumIntsJavaFact.apply(RISCV64.C_INT), RISCV64.C_INT },\n-                { platformVaListScopedFactory,     sumIntsNative,                        C_INT         },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"sumIntsScoped\")\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n-                                 BiFunction<Integer, VaList, Integer> sumInts,\n-                                 ValueLayout.OfInt intLayout) {\n-        VaList listLeaked;\n-        try (Arena arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            int x = sumInts.apply(2, list);\n-            assertEquals(x, 12);\n-            listLeaked = list;\n-        }\n-        assertFalse(listLeaked.segment().scope().isAlive());\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testScopeMSRead(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                Function<VaList, Integer> sumStruct, \/\/ ignored\n-                                GroupLayout Point_LAYOUT, VarHandle VH_Point_x, VarHandle VH_Point_y) {\n-        MemorySegment pointOut;\n-        try (Arena arena = Arena.openConfined()) {\n-            try (Arena innerArena = Arena.openConfined()) {\n-                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerArena.scope());;\n-                VH_Point_x.set(pointIn, 3);\n-                VH_Point_y.set(pointIn, 6);\n-                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n-                pointOut = MemorySegment.allocateNative(Point_LAYOUT, arena.scope());;\n-                list.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(pointOut));\n-                assertEquals((int) VH_Point_x.get(pointOut), 3);\n-                assertEquals((int) VH_Point_y.get(pointOut), 6);\n-                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n-            }\n-            assertTrue(pointOut.scope().isAlive()); \/\/ after inner session freed\n-        }\n-        assertFalse(pointOut.scope().isAlive()); \/\/ after outer session freed\n-    }\n-\n-    @DataProvider\n-    public Object[][] copy() {\n-        return new Object[][] {\n-                { winVaListScopedFactory,          Win64.C_INT   },\n-                { sysvVaListScopedFactory,         SysV.C_INT    },\n-                { linuxAArch64VaListScopedFactory, AArch64.C_INT },\n-                { macAArch64VaListScopedFactory,   AArch64.C_INT },\n-                { linuxRISCV64VaListScopedFactory, RISCV64.C_INT },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"copy\")\n-    public void testCopy(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n-        try (var arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            VaList copy = list.copy();\n-            assertEquals(copy.nextVarg(intLayout), 4);\n-            assertEquals(copy.nextVarg(intLayout), 8);\n-\n-            \/\/        try { \/\/ this logic only works on Windows!\n-            \/\/            int x = copy.vargAsInt(intLayout);\n-            \/\/            fail();\n-            \/\/        } catch (IndexOutOfBoundsException ex) {\n-            \/\/            \/\/ ok - we exhausted the list\n-            \/\/        }\n-\n-            assertEquals(list.nextVarg(intLayout), 4);\n-            assertEquals(list.nextVarg(intLayout), 8);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copy\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testCopyUnusableAfterOriginalClosed(BiFunction<Consumer<VaList.Builder>, SegmentScope, VaList> vaListFactory,\n-                                                    ValueLayout.OfInt intLayout) {\n-        VaList copy;\n-        try (var arena = Arena.openConfined()) {\n-            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n-                    .addVarg(intLayout, 8), arena.scope());\n-            copy = list.copy();\n-        }\n-\n-        copy.nextVarg(intLayout); \/\/ should throw\n-    }\n-\n-    @DataProvider\n-    public static Object[][] upcalls() {\n-        GroupLayout BigPoint_LAYOUT = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\")\n-        );\n-        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout Point_LAYOUT = MemoryLayout.structLayout(\n-                C_INT.withName(\"x\"),\n-                C_INT.withName(\"y\")\n-        );\n-        VarHandle VH_Point_x = Point_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_Point_y = Point_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n-                C_FLOAT.withName(\"x\"),\n-                C_FLOAT.withName(\"y\")\n-        );\n-        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n-                C_LONG_LONG.withName(\"x\"),\n-                C_LONG_LONG.withName(\"y\"),\n-                C_LONG_LONG.withName(\"z\")\n-        );\n-        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n-        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n-        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n-\n-        return new Object[][]{\n-                { linkVaListCB(\"upcallBigStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                })},\n-                { linkVaListCB(\"upcallBigStruct\"), VaListConsumer.mh(vaList -> {\n-                    VaList copy = vaList.copy();\n-                    MemorySegment struct =  MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-\n-                    VH_BigPoint_x.set(struct, 0);\n-                    VH_BigPoint_y.set(struct, 0);\n-\n-                    \/\/ should be independent\n-                    copy.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                })},\n-                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n-                })},\n-                { linkVaListCB(\"upcallBigStructPlusScalar\"), VaListConsumer.mh(vaList -> {\n-                    vaList.skip(BigPoint_LAYOUT);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n-                })},\n-                { linkVaListCB(\"upcallStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((int) VH_Point_x.get(struct), 5);\n-                    assertEquals((int) VH_Point_y.get(struct), 10);\n-                })},\n-                { linkVaListCB(\"upcallHugeStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((long) VH_HugePoint_x.get(struct), 1);\n-                    assertEquals((long) VH_HugePoint_y.get(struct), 2);\n-                    assertEquals((long) VH_HugePoint_z.get(struct), 3);\n-                })},\n-                { linkVaListCB(\"upcallFloatStruct\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, SegmentScope.auto());\n-                    vaList.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n-                    assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n-                    assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n-                })},\n-                { linkVaListCB(\"upcallMemoryAddress\"), VaListConsumer.mh(vaList -> {\n-                    MemorySegment intPtr = vaList.nextVarg(C_POINTER);\n-                    int x = intPtr.get(JAVA_INT, 0);\n-                    assertEquals(x, 10);\n-                })},\n-                { linkVaListCB(\"upcallDoubles\"), VaListConsumer.mh(vaList -> {\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 3.0);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 4.0);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 5.0);\n-                })},\n-                { linkVaListCB(\"upcallInts\"), VaListConsumer.mh(vaList -> {\n-                    assertEquals(vaList.nextVarg(C_INT), 10);\n-                    assertEquals(vaList.nextVarg(C_INT), 15);\n-                    assertEquals(vaList.nextVarg(C_INT), 20);\n-                })},\n-                { linkVaListCB(\"upcallStack\"), VaListConsumer.mh(vaList -> {\n-                    \/\/ skip all registers\n-                    for (long l = 1; l <= 16; l++) {\n-                        assertEquals(vaList.nextVarg(C_LONG_LONG), l);\n-                    }\n-                    for (double d = 1; d <= 16; d++) {\n-                        assertEquals(vaList.nextVarg(C_DOUBLE), d);\n-                    }\n-\n-                    \/\/ test some arbitrary values on the stack\n-                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 1);\n-                    assertEquals((char) vaList.nextVarg(C_INT), 'a');\n-                    assertEquals((short) vaList.nextVarg(C_INT), (short) 3);\n-                    assertEquals(vaList.nextVarg(C_INT), 4);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n-                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 6.0F);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 7.0D);\n-                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 8);\n-                    assertEquals((char) vaList.nextVarg(C_INT), 'b');\n-                    assertEquals((short) vaList.nextVarg(C_INT), (short) 10);\n-                    assertEquals(vaList.nextVarg(C_INT), 11);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 12L);\n-                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 13.0F);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 14.0D);\n-\n-                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, SegmentScope.auto());\n-                    SegmentAllocator bufferAllocator = SegmentAllocator.prefixAllocator(buffer);\n-\n-                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, bufferAllocator);\n-                    assertEquals((int) VH_Point_x.get(point), 5);\n-                    assertEquals((int) VH_Point_y.get(point), 10);\n-\n-                    VaList copy = vaList.copy();\n-                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n-                    assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n-                    assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n-\n-                    VH_BigPoint_x.set(bigPoint, 0);\n-                    VH_BigPoint_y.set(bigPoint, 0);\n-\n-                    \/\/ should be independent\n-                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n-                    assertEquals((long) VH_BigPoint_x.get(struct), 15);\n-                    assertEquals((long) VH_BigPoint_y.get(struct), 20);\n-                })},\n-                \/\/ test skip\n-                { linkVaListCB(\"upcallStack\"), VaListConsumer.mh(vaList -> {\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_LONG_LONG), 10L);\n-                    vaList.skip(C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 1.0D);\n-                    vaList.skip(C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE);\n-                    assertEquals(vaList.nextVarg(C_DOUBLE), 6.0D);\n-                })},\n-        };\n-    }\n-\n-    interface VaListConsumer {\n-        void accept(VaList list);\n-\n-        static MethodHandle mh(VaListConsumer instance) {\n-            try {\n-                MethodHandle handle = MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n-                        MethodType.methodType(void.class, VaList.class)).bindTo(instance);\n-                return MethodHandles.filterArguments(handle, 0,\n-                        SEGMENT_TO_VALIST);\n-            } catch (ReflectiveOperationException e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-    }\n-\n-    static VaList segmentToValist(MemorySegment segment) {\n-        return VaList.ofAddress(segment.address(), SegmentScope.auto());\n-    }\n-\n-    @DataProvider\n-    public static Object[][] overflow() {\n-        List<Function<Consumer<VaList.Builder>, VaList>> factories = List.of(\n-            winVaListFactory,\n-            sysvVaListFactory,\n-            linuxAArch64VaListFactory,\n-            macAArch64VaListFactory\n-        );\n-        List<List<MemoryLayout>> contentsCases = List.of(\n-            List.of(JAVA_INT),\n-            List.of(JAVA_LONG),\n-            List.of(JAVA_DOUBLE),\n-            List.of(ADDRESS),\n-            List.of(JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n-                    JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG, JAVA_LONG,\n-                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n-                    JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE, JAVA_DOUBLE,\n-                    JAVA_INT, JAVA_LONG, JAVA_DOUBLE, ADDRESS)\n-        );\n-        List<MemoryLayout> overflowCases = List.of(\n-            JAVA_INT,\n-            JAVA_LONG,\n-            JAVA_DOUBLE,\n-            ADDRESS\n-        );\n-        return factories.stream()\n-                .<Object[]>mapMulti((factory, sink) -> {\n-                    for (List<MemoryLayout> content : contentsCases) {\n-                        for (MemoryLayout overflow : overflowCases) {\n-                            sink.accept(new Object[]{ factory, content, overflow });\n-                        }\n-                    }\n-                })\n-                .toArray(Object[][]::new);\n-    }\n-\n-    private static void buildVaList(VaList.Builder builder, List<MemoryLayout> contents) {\n-        for (MemoryLayout layout : contents) {\n-            if (layout instanceof ValueLayout.OfInt ofInt) {\n-                 builder.addVarg(ofInt, 1);\n-            } else if (layout instanceof ValueLayout.OfLong ofLong) {\n-                 builder.addVarg(ofLong, 1L);\n-            } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-                 builder.addVarg(ofDouble, 1D);\n-            } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n-                 builder.addVarg(ofAddress, MemorySegment.ofAddress(1));\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"overflow\")\n-    public void testSkipOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                 List<MemoryLayout> contents,\n-                                 MemoryLayout skipped) {\n-        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n-        vaList.skip(contents.toArray(MemoryLayout[]::new));\n-        assertThrows(NoSuchElementException.class, () -> vaList.skip(skipped));\n-    }\n-\n-    private static void nextVarg(VaList vaList, MemoryLayout layout) {\n-        if (layout instanceof ValueLayout.OfInt ofInt) {\n-            assertEquals(vaList.nextVarg(ofInt), 1);\n-        } else if (layout instanceof ValueLayout.OfLong ofLong) {\n-            assertEquals(vaList.nextVarg(ofLong), 1L);\n-        } else if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-            assertEquals(vaList.nextVarg(ofDouble), 1D);\n-        } else if (layout instanceof ValueLayout.OfAddress ofAddress) {\n-            assertEquals(vaList.nextVarg(ofAddress), MemorySegment.ofAddress(1));\n-        }\n-    }\n-\n-    @Test(dataProvider = \"overflow\")\n-    public void testVargOverflow(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                 List<MemoryLayout> contents,\n-                                 MemoryLayout next) {\n-        VaList vaList = vaListFactory.apply(b -> buildVaList(b, contents));\n-        for (MemoryLayout layout : contents) {\n-            nextVarg(vaList, layout);\n-        }\n-        assertThrows(NoSuchElementException.class, () -> nextVarg(vaList, next));\n-    }\n-\n-    @Test(dataProvider = \"emptyVaLists\")\n-    public void testEmptyVaListScope(VaList vaList) {\n-        assertEquals(vaList.segment().scope(), SegmentScope.global());\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":0,"deletions":933,"binary":false,"changes":933,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-#include <stdarg.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-\/\/ ###### Down calls\n-\n-EXPORT int sumInts(int argNum, va_list list) {\n-    int sum = 0;\n-    for (int i = 0; i < argNum; i++) {\n-        sum += va_arg(list, int);\n-    }\n-    return sum;\n-}\n-\n-EXPORT double sumDoubles(int argNum, va_list list) {\n-    double sum = 0;\n-    for (int i = 0; i < argNum; i++) {\n-        sum += va_arg(list, double);\n-    }\n-    return sum;\n-}\n-\n-EXPORT int getInt(va_list list) {\n-    int* ptr = va_arg(list, int*);\n-    return *ptr;\n-}\n-\n-typedef struct {\n-    int x;\n-    int y;\n-} Point;\n-\n-EXPORT int sumStruct(va_list list) {\n-    Point point = va_arg(list, Point);\n-    return point.x + point.y;\n-}\n-\n-typedef struct {\n-    long long x;\n-    long long y;\n-} BigPoint;\n-\n-EXPORT long long sumBigStruct(va_list list) {\n-    BigPoint point = va_arg(list, BigPoint);\n-    return point.x + point.y;\n-}\n-\n-typedef struct {\n-    long long x;\n-    long long y;\n-    long long z;\n-} HugePoint;\n-\n-EXPORT long long sumHugeStruct(va_list list) {\n-    HugePoint point = va_arg(list, HugePoint);\n-    return point.x + point.y + point.z;\n-}\n-\n-typedef struct {\n-    float x;\n-    float y;\n-} FloatPoint;\n-\n-EXPORT float sumFloatStruct(va_list list) {\n-    FloatPoint point = va_arg(list, FloatPoint);\n-    return point.x + point.y;\n-}\n-\n-EXPORT void sumStack(long long* longSum, double* doubleSum, va_list list) {\n-    long long lSum = 0;\n-    for (int i = 0; i < 16; i++) {\n-        lSum += va_arg(list, long long);\n-    }\n-    *longSum = lSum;\n-    double dSum = 0.0;\n-    for (int i = 0; i < 16; i++) {\n-        dSum += va_arg(list, double);\n-    }\n-    *doubleSum = dSum;\n-}\n-\n-\/\/ ###### Up calls\n-\n-typedef void CB(va_list);\n-\n-static void passToUpcall(CB cb, int numArgs, ...) {\n-    va_list list;\n-    va_start(list, numArgs);\n-    cb(list);\n-    va_end(list);\n-}\n-\n-EXPORT void upcallInts(CB cb) {\n-    passToUpcall(cb, 3, 10, 15, 20);\n-}\n-\n-EXPORT void upcallDoubles(CB cb) {\n-    passToUpcall(cb, 3, 3.0, 4.0, 5.0);\n-}\n-\n-EXPORT void upcallStack(CB cb) {\n-    Point point;\n-    point.x = 5;\n-    point.y = 10;\n-\n-    BigPoint bigPoint;\n-    bigPoint.x = 15;\n-    bigPoint.y = 20;\n-\n-    passToUpcall(cb, 32 + 14,\n-        1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 7LL, 8LL,\n-        9LL, 10LL, 11LL, 12LL, 13LL, 14LL, 15LL, 16LL,\n-        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0,\n-        9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0,\n-        \/\/ should all be passed on the stack\n-        1, 'a', 3,  4,  5LL,  6.0f,  7.0,\n-        8, 'b', 10, 11, 12LL, 13.0f, 14.0,\n-        point, bigPoint);\n-}\n-\n-EXPORT void upcallMemoryAddress(CB cb) {\n-    int x = 10;\n-    passToUpcall(cb, 1, &x);\n-}\n-\n-EXPORT void upcallStruct(CB cb) {\n-    Point point;\n-    point.x = 5;\n-    point.y = 10;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallFloatStruct(CB cb) {\n-    FloatPoint point;\n-    point.x = 1.0f;\n-    point.y = 2.0f;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallBigStruct(CB cb) {\n-    BigPoint point;\n-    point.x = 8;\n-    point.y = 16;\n-    passToUpcall(cb, 1, point);\n-}\n-\n-EXPORT void upcallBigStructPlusScalar(CB cb) {\n-    BigPoint point;\n-    point.x = 8;\n-    point.y = 16;\n-    passToUpcall(cb, 2, point, 42);\n-}\n-\n-EXPORT void upcallHugeStruct(CB cb) {\n-    HugePoint point;\n-    point.x = 1;\n-    point.y = 2;\n-    point.z = 3;\n-    passToUpcall(cb, 1, point);\n-}\n","filename":"test\/jdk\/java\/foreign\/valist\/libVaList.c","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n+    private static final AddressLayout C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -61,1 +61,1 @@\n-                SegmentScope.global());\n+                Arena.global());\n","filename":"test\/jdk\/java\/lang\/Thread\/jni\/AttachCurrentThread\/ImplicitAttach.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.foreign.layout\n@@ -50,1 +51,0 @@\n-import java.lang.foreign.MemoryLayout;\n@@ -52,0 +52,2 @@\n+\n+import jdk.internal.foreign.layout.ValueLayouts;\n@@ -172,2 +174,2 @@\n-        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n-        try (Arena arena = Arena.openConfined()) {\n+        VarHandle vh = MethodHandles.memorySegmentViewVarHandle(ValueLayouts.valueLayout(carrier, ByteOrder.nativeOrder()));\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.Arena;\n@@ -27,1 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -81,1 +81,1 @@\n-                       SegmentScope.auto());\n+                       Arena.ofAuto());\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/LargeMapTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -65,1 +64,1 @@\n-        var arena = Arena.openConfined();\n+        var arena = Arena.ofConfined();\n@@ -69,1 +68,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena.scope());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena);\n@@ -75,1 +74,1 @@\n-        var arena = Arena.openConfined();\n+        var arena = Arena.ofConfined();\n@@ -79,1 +78,1 @@\n-            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena.scope());\n+            fileChannel.map(FileChannel.MapMode.READ_WRITE, 1L, 10L, arena);\n@@ -164,1 +163,1 @@\n-        public MemorySegment map(MapMode mode, long offset, long size, SegmentScope scope)\n+        public MemorySegment map(MapMode mode, long offset, long size, Arena arena)\n@@ -167,1 +166,1 @@\n-            return fc.map(mode, offset, size, scope);\n+            return fc.map(mode, offset, size, arena);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/MapToMemorySegmentTest.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.foreign.Arena;\n@@ -25,1 +26,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -46,1 +46,1 @@\n-                    MemorySegment.allocateNative(s, SegmentScope.auto())\n+                    Arena.ofAuto().allocate(s)\n@@ -54,1 +54,1 @@\n-                    MemorySegment.allocateNative(s, SegmentScope.auto())\n+                    Arena.ofAuto().allocate(s)\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Byte.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Byte.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Byte.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Byte.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Double.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Double.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Double.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Double.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Float.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Float.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Float.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Float.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Integer.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Integer.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Integer.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Integer.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Long.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Long.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Long.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Long.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -482,2 +482,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -511,2 +511,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -575,2 +575,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -606,2 +606,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -489,2 +489,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -518,2 +518,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -582,2 +582,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n@@ -613,2 +613,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, Short.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), Short.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, Short.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), Short.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -502,2 +502,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n@@ -531,2 +531,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n@@ -595,2 +595,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n@@ -626,2 +626,2 @@\n-        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, $Boxtype$.SIZE, SegmentScope.auto()));\n-        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), $Boxtype$.SIZE, SegmentScope.auto());\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> Arena.ofAuto().allocate(i, $Boxtype$.SIZE));\n+        MemorySegment r = Arena.ofAuto().allocate(a.byteSize(), $Boxtype$.SIZE);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.Supplier;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n-public class BulkMismatchAcquire {\n-\n-    public enum SessionKind {\n-        CONFINED(Arena::openConfined),\n-        SHARED(Arena::openShared);\n-\n-        final Supplier<Arena> arenaFactory;\n-\n-        SessionKind(Supplier<Arena> arenaFactory) {\n-            this.arenaFactory = arenaFactory;\n-        }\n-\n-        Arena makeArena() {\n-            return arenaFactory.get();\n-        }\n-    }\n-\n-    @Param({\"CONFINED\", \"SHARED\"})\n-    public BulkMismatchAcquire.SessionKind sessionKind;\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-\n-    Arena arena;\n-    MemorySegment mismatchSegmentLarge1;\n-    MemorySegment mismatchSegmentLarge2;\n-    ByteBuffer mismatchBufferLarge1;\n-    ByteBuffer mismatchBufferLarge2;\n-    MemorySegment mismatchSegmentSmall1;\n-    MemorySegment mismatchSegmentSmall2;\n-    ByteBuffer mismatchBufferSmall1;\n-    ByteBuffer mismatchBufferSmall2;\n-\n-    @Setup\n-    public void setup() {\n-        arena = sessionKind.makeArena();\n-        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL);\n-        mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL);\n-        mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-        mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-        \/\/ mismatch at first byte\n-        mismatchSegmentSmall1 = arena.allocate(7);\n-        mismatchSegmentSmall2 = arena.allocate(7);\n-        mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-        mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-        {\n-            mismatchSegmentSmall1.fill((byte) 0xFF);\n-            mismatchBufferSmall1.put((byte) 0xFF).clear();\n-            \/\/ verify expected mismatch indices\n-            long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-            if (si != -1)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-            int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-            if (bi != -1)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-            si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-            if (si != 0)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-            bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-            if (bi != 0)\n-                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment_acquire() {\n-        long[] arr = new long[1];\n-        mismatchSegmentLarge1.scope().whileAlive(() -> {\n-            arr[0] = mismatchSegmentLarge1.mismatch(mismatchSegmentSmall2);\n-        });\n-        return arr[0];\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment_acquire() {\n-        long[] arr = new long[1];\n-        mismatchSegmentLarge1.scope().whileAlive(() -> {\n-            arr[0] = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        });\n-        return arr[0];\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkMismatchAcquire.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -46,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -64,1 +63,1 @@\n-    final Arena arena = Arena.openShared();\n+    final Arena arena = Arena.ofShared();\n@@ -67,1 +66,2 @@\n-    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+    final MemorySegment segment = arena.allocate(ALLOC_SIZE, 1);\n+\n@@ -76,2 +76,7 @@\n-    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());\n-    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, arena.scope());;\n+    final MemorySegment mismatchSegmentLarge1;\n+\n+    {\n+        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL, 1);\n+    }\n+\n+    final MemorySegment mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL, 1);\n@@ -82,2 +87,2 @@\n-    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, arena.scope());;\n-    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, arena.scope());;\n+    final MemorySegment mismatchSegmentSmall1 = arena.allocate(7, 1);\n+    final MemorySegment mismatchSegmentSmall2 = arena.allocate(7, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -28,0 +29,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -69,1 +71,2 @@\n-    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.asUnbounded();\n+    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(C_CHAR));\n@@ -74,1 +77,1 @@\n-            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+            LINKER.defaultLookup().find(\"free\").get(), FunctionDescriptor.ofVoid(C_POINTER));\n@@ -77,1 +80,1 @@\n-            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS.asUnbounded(), ValueLayout.JAVA_LONG));\n+            LINKER.defaultLookup().find(\"malloc\").get(), FunctionDescriptor.of(C_POINTER, ValueLayout.JAVA_LONG));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CLayouts.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -57,0 +57,5 @@\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial.invokeExact();\n+    }\n+\n@@ -67,0 +72,5 @@\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial.invokeExact(10);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadConstant.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,9 +25,2 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n-\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.*;\n+\n@@ -44,0 +37,1 @@\n+    static final MethodHandle func_trivial;\n@@ -45,0 +39,1 @@\n+    static final MethodHandle func_trivial_v;\n@@ -47,0 +42,1 @@\n+    static final MethodHandle identity_trivial;\n@@ -48,0 +44,1 @@\n+    static final MethodHandle identity_trivial_v;\n@@ -84,2 +81,8 @@\n-    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openShared().scope());\n-    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, Arena.openConfined().scope());\n+    static final MemorySegment sharedPoint;\n+\n+    static {\n+        Arena scope = Arena.ofShared();\n+        sharedPoint = scope.allocate(POINT_LAYOUT);\n+    }\n+\n+    static final MemorySegment confinedPoint;\n@@ -87,1 +90,11 @@\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto());\n+    static {\n+        Arena scope = Arena.ofConfined();\n+        confinedPoint = scope.allocate(POINT_LAYOUT);\n+    }\n+\n+    static final MemorySegment point;\n+\n+    static {\n+        Arena scope = Arena.ofAuto();\n+        point = scope.allocate(POINT_LAYOUT);\n+    }\n@@ -89,1 +102,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, SegmentScope.auto()));\n+    static final SegmentAllocator recycling_allocator;\n@@ -92,0 +105,2 @@\n+        Arena scope = Arena.ofAuto();\n+        recycling_allocator = SegmentAllocator.prefixAllocator(scope.allocate(POINT_LAYOUT));\n@@ -101,0 +116,1 @@\n+            func_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n@@ -102,0 +118,1 @@\n+            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n@@ -107,0 +124,1 @@\n+            identity_trivial_v = abi.downcallHandle(fd, Linker.Option.isTrivial());\n@@ -108,0 +126,1 @@\n+            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadHelper.java","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -57,0 +57,5 @@\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial_v.invokeExact(func_addr);\n+    }\n+\n@@ -106,0 +111,5 @@\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CallOverheadVirtual.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/JavaLayouts.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,2 +39,0 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.Arena;\n@@ -68,2 +67,2 @@\n-        try (Arena arena = Arena.openConfined()) {\n-            return LINKER.upcallStub(BLANK, BLANK_DESC, arena.scope());\n+        try (Arena arena = Arena.ofConfined()) {\n+            return LINKER.upcallStub(BLANK, BLANK_DESC, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LinkUpcall.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,1 +72,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, SegmentScope.auto());\n+    static final MemorySegment segment;\n@@ -75,0 +75,2 @@\n+        Arena scope = Arena.ofAuto();\n+        segment = scope.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverConstant.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -63,2 +59,2 @@\n-    final Arena arena = Arena.openConfined();\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, arena.scope()));\n+    final Arena arena = Arena.ofConfined();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(arena.allocate(ALLOC_LAYOUT));\n@@ -82,1 +78,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -92,1 +88,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -138,1 +134,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        MemorySegment segment = scope.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNew.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-        arena = Arena.openConfined();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-        arena = Arena.openConfined();\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segmentIn = arena.allocate(ALLOC_SIZE, 1);\n+        segmentOut = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantFP.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -40,1 +41,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -79,1 +79,2 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, SegmentScope.auto());\n+            Arena scope = Arena.ofAuto();\n+            MemorySegment s = scope.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantHeap.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -98,2 +98,2 @@\n-        arena = Arena.openConfined();\n-        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, ALLOC_SIZE, arena);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantMapped.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-        arena = Arena.openConfined();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        segment = arena.allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverNonConstantShared.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.lang.foreign.Arena;\n@@ -38,1 +39,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -64,1 +64,2 @@\n-            res += MemorySegment.ofAddress(i, i % 100).address();\n+            res += MemorySegment.ofAddress(i)\n+                    .reinterpret(i % 100).address();\n@@ -73,1 +74,2 @@\n-            res += MemorySegment.ofAddress(i, i % 100, SegmentScope.global()).address();\n+            res += MemorySegment.ofAddress(i)\n+                    .reinterpret(i % 100, Arena.global(), null).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverOfAddress.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,4 +71,6 @@\n-        confinedArena = Arena.openConfined();\n-        sharedArena = Arena.openShared();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, confinedArena.scope());\n-        nativeSharedSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, sharedArena.scope());\n+        confinedArena = Arena.ofConfined();\n+        sharedArena = Arena.ofShared();\n+        Arena scope1 = confinedArena;\n+        nativeSegment = scope1.allocate(ALLOC_SIZE, 4);\n+        Arena scope = sharedArena;\n+        nativeSharedSegment = scope.allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverPollutedSegments.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n-        arena = Arena.openConfined();\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, arena.scope());\n+        arena = Arena.ofConfined();\n+        nativeSegment = arena.allocate(ALLOC_SIZE, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/LoopOverSlice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.LongBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+\n+\/**\n+ * This benchmark creates an array of longs with random contents. The array\n+ * is then copied into a byte array (using big endian) using different\n+ * methods.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\"})\n+public class MemorySegmentVsBits {\n+\n+    public static final VarHandle LONG_ARRAY_VH = MethodHandles.byteArrayViewVarHandle(long[].class, BIG_ENDIAN);\n+\n+    Arena arena = Arena.ofConfined();\n+\n+    @Param({\"1\", \"2\", \"16\", \"64\", \"256\"})\n+    public int size;\n+    private long[] longs;\n+    private byte[] bytes;\n+\n+    private ByteBuffer byteBuffer;\n+    private LongBuffer longBuffer;\n+    private MemorySegment segment;\n+    private MemorySegment nativeSegment;\n+\n+    private static final ValueLayout.OfLong OF_LONG = (JAVA_LONG.order() != BIG_ENDIAN)\n+            ? JAVA_LONG.withOrder(BIG_ENDIAN)\n+            : JAVA_LONG;\n+\n+    @Setup\n+    public void setup() {\n+        longs = ThreadLocalRandom.current().longs(size).toArray();\n+        bytes = new byte[size * Long.BYTES];\n+        byteBuffer = ByteBuffer.wrap(bytes);\n+        longBuffer = byteBuffer.asLongBuffer();\n+        segment = MemorySegment.ofArray(bytes);\n+        nativeSegment = arena.allocate(size * Long.BYTES);\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        arena.close();\n+    }\n+\n+    @Benchmark\n+    public void bitsEquivalent() {\n+        for (int i = 0; i < size; i++) {\n+            putLong(bytes, i * Long.BYTES, longs[i]);\n+        }\n+    }\n+    @Benchmark\n+    public void byteVarHandle() {\n+        for (int i = 0; i < size; i++) {\n+            LONG_ARRAY_VH.set(bytes, i * Long.BYTES, longs[i]);\n+        }\n+    }\n+    @Benchmark\n+    public void byteBuffer() {\n+        for (int i = 0; i < size; i++) {\n+            byteBuffer.putLong(i * Long.BYTES, longs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void longBuffer() {\n+        for (int i = 0; i < size; i++) {\n+            longBuffer.put(i, longs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void panamaHeap() {\n+        for (int i = 0; i < size; i++) {\n+            segment.set(JAVA_LONG_UNALIGNED, i * Long.BYTES, longs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void panamaNative() {\n+        for (int i = 0; i < size; i++) {\n+            nativeSegment.set(OF_LONG, i * Long.BYTES, longs[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void panamaNativeUnaligned() {\n+        for (int i = 0; i < size; i++) {\n+            nativeSegment.set(JAVA_LONG_UNALIGNED, i * Long.BYTES, longs[i]);\n+        }\n+    }\n+\n+    \/\/ java.io.Bits is package private\n+    static void putLong(byte[] b, int off, long val) {\n+        b[off + 7] = (byte) (val);\n+        b[off + 6] = (byte) (val >>> 8);\n+        b[off + 5] = (byte) (val >>> 16);\n+        b[off + 4] = (byte) (val >>> 24);\n+        b[off + 3] = (byte) (val >>> 32);\n+        b[off + 2] = (byte) (val >>> 40);\n+        b[off + 1] = (byte) (val >>> 48);\n+        b[off] = (byte) (val >>> 56);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentVsBits.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.foreign.Arena;\n@@ -40,1 +39,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -107,1 +106,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -114,1 +113,1 @@\n-        try (Arena arena = Arena.openShared()) {\n+        try (Arena arena = Arena.ofShared()) {\n@@ -121,1 +120,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        return Arena.ofAuto().allocate(ALLOC_SIZE, 4);\n@@ -127,1 +126,1 @@\n-        return MemorySegment.allocateNative(ALLOC_SIZE, 4, SegmentScope.auto());\n+        return Arena.ofAuto().allocate(ALLOC_SIZE, 4);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySessionClose.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.SequenceLayout;\n-import java.lang.foreign.ValueLayout;\n+import java.lang.foreign.*;\n@@ -43,1 +40,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -82,2 +78,2 @@\n-        arena = Arena.openShared();\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, arena.scope());\n+        arena = Arena.ofShared();\n+        segment = arena.allocate(ALLOC_SIZE, CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ParallelSum.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -43,1 +40,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -55,2 +51,2 @@\n-    Arena arena = Arena.openConfined();\n-    MemorySegment segment = MemorySegment.allocateNative(100, arena.scope());\n+    Arena arena = Arena.ofConfined();\n+    MemorySegment segment = arena.allocate(100, 1);\n@@ -62,1 +58,1 @@\n-    static final MethodHandle F_LONG, F_PTR;\n+    static final MethodHandle F_LONG_LONG, F_PTR_LONG, F_LONG_PTR, F_PTR_PTR;\n@@ -67,4 +63,8 @@\n-        F_LONG = abi.downcallHandle(loaderLibs.find(\"func_as_long\").get(),\n-                FunctionDescriptor.of(C_INT, C_LONG_LONG));\n-        F_PTR = abi.downcallHandle(loaderLibs.find(\"func_as_ptr\").get(),\n-                FunctionDescriptor.of(C_INT, C_POINTER));\n+        F_LONG_LONG = abi.downcallHandle(loaderLibs.find(\"id_long_long\").get(),\n+                FunctionDescriptor.of(C_LONG_LONG, C_LONG_LONG));\n+        F_PTR_LONG = abi.downcallHandle(loaderLibs.find(\"id_ptr_long\").get(),\n+                FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+        F_LONG_PTR = abi.downcallHandle(loaderLibs.find(\"id_long_ptr\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+        F_PTR_PTR = abi.downcallHandle(loaderLibs.find(\"id_ptr_ptr\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n@@ -79,2 +79,2 @@\n-    public int panama_call_as_long() throws Throwable {\n-        return (int)F_LONG.invokeExact(segment.address());\n+    public long long_to_long() throws Throwable {\n+        return (long)F_LONG_LONG.invokeExact(segment.address());\n@@ -84,2 +84,2 @@\n-    public int panama_call_as_address() throws Throwable {\n-        return (int)F_PTR.invokeExact(segment);\n+    public long ptr_to_long() throws Throwable {\n+        return (long)F_PTR_LONG.invokeExact(segment);\n@@ -89,3 +89,19 @@\n-    public int panama_call_as_new_segment() throws Throwable {\n-        MemorySegment newSegment = MemorySegment.ofAddress(segment.address(), 100, arena.scope());\n-        return (int)F_PTR.invokeExact(newSegment);\n+    public long ptr_to_long_new_segment() throws Throwable {\n+        MemorySegment newSegment = segment.reinterpret(100, arena, null);\n+        return (long)F_PTR_LONG.invokeExact(newSegment);\n+    }\n+\n+    @Benchmark\n+    public long long_to_ptr() throws Throwable {\n+        return ((MemorySegment)F_LONG_PTR.invokeExact(segment.address())).address();\n+    }\n+\n+    @Benchmark\n+    public long ptr_to_ptr() throws Throwable {\n+        return ((MemorySegment)F_PTR_PTR.invokeExact(segment)).address();\n+    }\n+\n+    @Benchmark\n+    public long ptr_to_ptr_new_segment() throws Throwable {\n+        MemorySegment newSegment = segment.reinterpret(100, arena, null);\n+        return ((MemorySegment)F_PTR_PTR.invokeExact(newSegment)).address();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/PointerInvoke.java","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -25,4 +25,1 @@\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -39,2 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.Arena;\n@@ -68,1 +64,2 @@\n-        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), SegmentScope.global());\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT);\n+        INPUT_SEGMENT = Arena.global().allocate(layout);\n@@ -86,1 +83,1 @@\n-                    SegmentScope.global()\n+                    Arena.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/QSort.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.*;\n@@ -47,0 +42,1 @@\n+import java.lang.foreign.MemorySegment.Scope;\n@@ -60,1 +56,1 @@\n-    Arena arena = Arena.openConfined();\n+    Arena arena = Arena.ofConfined();\n@@ -63,1 +59,2 @@\n-    SegmentAllocator arenaAllocator = new RingAllocator(arena.scope());\n+    SegmentAllocator arenaAllocator = new RingAllocator(arena);\n+    SlicingPool pool = new SlicingPool();\n@@ -84,1 +81,1 @@\n-        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, arena.scope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(arena.allocate(size + 1, 1));\n@@ -99,1 +96,1 @@\n-        try (Arena arena = Arena.openConfined()) {\n+        try (Arena arena = Arena.ofConfined()) {\n@@ -110,0 +107,8 @@\n+    @Benchmark\n+    public int panama_strlen_pool() throws Throwable {\n+        Arena arena = pool.acquire();\n+        int l = (int) STRLEN.invokeExact(arena.allocateUtf8String(str));\n+        arena.close();\n+        return l;\n+    }\n+\n@@ -151,2 +156,2 @@\n-        public RingAllocator(SegmentScope session) {\n-            this.segment = MemorySegment.allocateNative(1024, session);\n+        public RingAllocator(Arena session) {\n+            this.segment = session.allocate(1024, 1);\n@@ -172,0 +177,34 @@\n+\n+    static class SlicingPool {\n+        final MemorySegment pool = Arena.ofAuto().allocate(1024);\n+        boolean isAcquired = false;\n+\n+        public Arena acquire() {\n+            if (isAcquired) {\n+                throw new IllegalStateException(\"An allocator is already in use\");\n+            }\n+            isAcquired = true;\n+            return new SlicingPoolAllocator();\n+        }\n+\n+        class SlicingPoolAllocator implements Arena {\n+\n+            final Arena arena = Arena.ofConfined();\n+            final SegmentAllocator slicing = SegmentAllocator.slicingAllocator(pool);\n+\n+            public MemorySegment allocate(long byteSize, long byteAlignment) {\n+                return slicing.allocate(byteSize, byteAlignment)\n+                        .reinterpret(arena, null);\n+            }\n+\n+            @Override\n+            public Scope scope() {\n+                return arena.scope();\n+            }\n+\n+            public void close() {\n+                isAcquired = false;\n+                arena.close();\n+            }\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -71,1 +71,2 @@\n-        srcSegmentImplicit = MemorySegment.allocateNative(size, SegmentScope.auto());\n+        Arena scope = Arena.ofAuto();\n+        srcSegmentImplicit = scope.allocate(size, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestLoadBytes.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -70,2 +70,4 @@\n-            this.inputSegment = MemorySegment.ofAddress(inputAddress, 8*SIZE, SegmentScope.global());\n-            this.outputSegment = MemorySegment.ofAddress(outputAddress, 8*SIZE, SegmentScope.global());\n+            this.inputSegment = MemorySegment.ofAddress(inputAddress)\n+                    .reinterpret(8*SIZE);\n+            this.outputSegment = MemorySegment.ofAddress(outputAddress)\n+                    .reinterpret(8*SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/UnrolledAccess.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.*;\n@@ -38,2 +36,1 @@\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.Arena;\n@@ -134,1 +131,1 @@\n-            fd, SegmentScope.global()\n+            fd, Arena.global()\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/Upcalls.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.invoke.MethodHandle;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\", \"--enable-preview\" })\n-public class VaList extends CLayouts {\n-\n-    static final Linker linker = Linker.nativeLinker();\n-    static {\n-        System.loadLibrary(\"VaList\");\n-    }\n-\n-    static final MethodHandle MH_ellipsis;\n-    static final MethodHandle MH_vaList;\n-\n-    static {\n-        SymbolLookup loaderLibs = SymbolLookup.loaderLookup();\n-        MH_ellipsis = linker.downcallHandle(loaderLibs.find(\"ellipsis\").get(),\n-                FunctionDescriptor.ofVoid(C_INT, C_INT, C_DOUBLE, C_LONG_LONG),\n-                Linker.Option.firstVariadicArg(1));\n-        MH_vaList = linker.downcallHandle(loaderLibs.find(\"vaList\").get(),\n-                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n-    }\n-\n-    @Benchmark\n-    public void ellipsis() throws Throwable {\n-        MH_ellipsis.invokeExact(3,\n-                                1, 2D, 3L);\n-    }\n-\n-    @Benchmark\n-    public void vaList() throws Throwable {\n-        try (Arena arena = Arena.openConfined()) {\n-            java.lang.foreign.VaList vaList = java.lang.foreign.VaList.make(b ->\n-                    b.addVarg(C_INT, 1)\n-                            .addVarg(C_DOUBLE, 2D)\n-                            .addVarg(C_LONG_LONG, 3L), arena.scope());\n-            MH_vaList.invokeExact(3,\n-                    vaList.segment());\n-        }\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VaList.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -66,2 +66,2 @@\n-        arena = Arena.openConfined();\n-        data = MemorySegment.allocateNative(JAVA_INT, arena.scope());\n+        arena = Arena.ofConfined();\n+        data = arena.allocate(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-EXPORT int func_as_long(long long value) {\n-  return 0;\n+EXPORT long long id_long_long(long long value) {\n+  return value;\n@@ -36,2 +36,10 @@\n-EXPORT int func_as_ptr(void* ptr) {\n-  return 0;\n+EXPORT long long id_ptr_long(void* ptr) {\n+  return (long long)ptr;\n+}\n+\n+EXPORT void* id_long_ptr(long long value) {\n+  return (void*)value;\n+}\n+\n+EXPORT void* id_ptr_ptr(void* ptr) {\n+  return ptr;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libPtr.c","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdarg.h>\n-\n-#ifdef _WIN64\n-#define EXPORT __declspec(dllexport)\n-#else\n-#define EXPORT\n-#endif\n-\n-EXPORT void vaList(int argCount, va_list list) {\n-    \/\/...\n-}\n-\n-EXPORT void ellipsis(int argCount, ...) {\n-    va_list list;\n-    va_start(list, argCount);\n-    vaList(argCount, list);\n-    va_end(list);\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/libVaList.c","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -41,1 +42,2 @@\n-    private static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+    private static final AddressLayout UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n@@ -44,1 +46,1 @@\n-        public ValueLayout.OfAddress layout() {\n+        public AddressLayout layout() {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/NativeType.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.AddressLayout;\n@@ -39,0 +40,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -51,1 +53,1 @@\n-    final Arena arena = Arena.openConfined();\n+    final Arena arena = Arena.ofConfined();\n@@ -60,1 +62,2 @@\n-    public static final ValueLayout.OfAddress UNSAFE_ADDRESS = ValueLayout.ADDRESS.asUnbounded();\n+    public static final AddressLayout UNSAFE_ADDRESS = ValueLayout.ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/pointers\/PointerBench.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.*;\n@@ -33,1 +29,0 @@\n-import java.lang.foreign.SymbolLookup;\n@@ -69,2 +64,2 @@\n-        this.arena = Arena.openConfined();\n-        this.segment = MemorySegment.allocateNative(LAYOUT, arena.scope());\n+        this.arena = Arena.ofConfined();\n+        this.segment = arena.allocate(LAYOUT);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/points\/support\/PanamaPoint.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.Arena;\n@@ -72,2 +72,4 @@\n-    nativeIn = MemorySegment.allocateNative(size, SegmentScope.auto());\n-    nativeOut = MemorySegment.allocateNative(size, SegmentScope.auto());\n+      Arena scope1 = Arena.ofAuto();\n+      nativeIn = scope1.allocate(size, 1);\n+      Arena scope = Arena.ofAuto();\n+      nativeOut = scope.allocate(size, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -88,2 +87,6 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+      long byteAlignment1 = SPECIES.vectorByteSize();\n+      Arena scope1 = Arena.ofAuto();\n+      srcSegment = scope1.allocate(size, byteAlignment1);\n+      long byteAlignment = SPECIES.vectorByteSize();\n+      Arena scope = Arena.ofAuto();\n+      dstSegment = scope.allocate(size, byteAlignment);\n@@ -166,3 +169,3 @@\n-    try (final var arena = Arena.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n+    try (final var arena = Arena.ofConfined()) {\n+      final var srcSegmentConfined = srcSegment.reinterpret(arena, null);\n+      final var dstSegmentConfined = dstSegment.reinterpret(arena, null);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.foreign.SegmentScope;\n@@ -93,2 +92,6 @@\n-    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n-    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), SegmentScope.auto());\n+      long byteAlignment1 = SPECIES.vectorByteSize();\n+      Arena scope1 = Arena.ofAuto();\n+      srcSegment = scope1.allocate(size, byteAlignment1);\n+      long byteAlignment = SPECIES.vectorByteSize();\n+      Arena scope = Arena.ofAuto();\n+      dstSegment = scope.allocate(size, byteAlignment);\n@@ -164,3 +167,3 @@\n-    try (final var arena = Arena.openConfined()) {\n-      final var srcSegmentConfined = MemorySegment.ofAddress(srcSegment.address(), size, arena.scope());\n-      final var dstSegmentConfined = MemorySegment.ofAddress(dstSegment.address(), size, arena.scope());\n+    try (final var arena = Arena.ofConfined()) {\n+      final var srcSegmentConfined = srcSegment.reinterpret(arena, null);\n+      final var dstSegmentConfined = dstSegment.reinterpret(arena, null);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}