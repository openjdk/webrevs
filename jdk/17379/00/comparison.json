{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,0 +262,1 @@\n+            vec.release();\n@@ -473,0 +474,1 @@\n+            vec.release();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,1 @@\n-\n-import jdk.internal.misc.CarrierThreadLocal;\n-import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.misc.TerminatingThreadLocal;\n@@ -74,4 +72,5 @@\n-    private static class Deallocator implements Runnable {\n-        private final AllocatedNativeObject obj;\n-        Deallocator(AllocatedNativeObject obj) {\n-            this.obj = obj;\n+    \/\/ per carrier-thread IOVecWrapper\n+    private static final TerminatingThreadLocal<IOVecWrapper[]> IOV_CACHE = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected IOVecWrapper[] initialValue() {\n+            return new IOVecWrapper[1];  \/\/ one slot cache\n@@ -79,2 +78,6 @@\n-        public void run() {\n-            obj.free();\n+        @Override\n+        protected void threadTerminated(IOVecWrapper[] cache) {\n+            IOVecWrapper wrapper = cache[0];\n+            if (wrapper != null) {\n+                wrapper.vecArray.free();\n+            }\n@@ -82,4 +85,1 @@\n-    }\n-\n-    \/\/ per carrier-thread IOVecWrapper\n-    private static final CarrierThreadLocal<IOVecWrapper> cached = new CarrierThreadLocal<>();\n+    };\n@@ -98,5 +98,9 @@\n-        IOVecWrapper wrapper = cached.get();\n-        if (wrapper != null && wrapper.size < size) {\n-            \/\/ not big enough; eagerly release memory\n-            wrapper.vecArray.free();\n-            wrapper = null;\n+        IOVecWrapper[] cache = IOV_CACHE.get();\n+        IOVecWrapper wrapper = cache[0];\n+        if (wrapper != null) {\n+            cache[0] = null;\n+            if (wrapper.size < size) {\n+                \/\/ not big enough; eagerly release memory\n+                wrapper.vecArray.free();\n+                wrapper = null;\n+            }\n@@ -104,0 +108,6 @@\n+        return (wrapper != null) ? wrapper : new IOVecWrapper(size);\n+    }\n+\n+    void release() {\n+        IOVecWrapper[] cache = IOV_CACHE.get();\n+        IOVecWrapper wrapper = cache[0];\n@@ -105,3 +115,4 @@\n-            wrapper = new IOVecWrapper(size);\n-            CleanerFactory.cleaner().register(wrapper, new Deallocator(wrapper.vecArray));\n-            cached.set(wrapper);\n+            cache[0] = this;\n+        } else {\n+            \/\/ slot already used\n+            vecArray.free();\n@@ -109,1 +120,0 @@\n-        return wrapper;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOVecWrapper.java","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"}]}