{"files":[{"patch":"@@ -194,0 +194,3 @@\n+    LIBPIPEWIRE_HEADER_DIRS := \\\n+    \t$(TOPDIR)\/src\/$(MODULE)\/unix\/native\/libpipewire\/include\n+\n@@ -203,1 +206,1 @@\n-        #\n+        $(LIBPIPEWIRE_HEADER_DIRS)\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/peer\/RobotPeer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import sun.awt.screencast.ScreencastHelper;\n@@ -44,0 +45,2 @@\n+    private static final boolean useScreencast;\n+\n@@ -46,0 +49,1 @@\n+\n@@ -47,3 +51,17 @@\n-                            AccessController.doPrivileged(\n-                                    new GetPropertyAction(\"awt.robot.gtk\", \"true\")\n-                            ));\n+                AccessController.doPrivileged(\n+                        new GetPropertyAction(\"awt.robot.gtk\",\n+                                \"true\")\n+                ));\n+\n+        boolean isOnWayland = false;\n+\n+        if (Toolkit.getDefaultToolkit() instanceof SunToolkit sunToolkit) {\n+            isOnWayland = sunToolkit.isRunningOnWayland();\n+        }\n+\n+        useScreencast = Boolean.parseBoolean(\n+                AccessController.doPrivileged(\n+                        new GetPropertyAction(\n+                                \"awt.robot.screencastEnabled\",\n+                                String.valueOf(isOnWayland)\n+                        )));\n@@ -51,0 +69,1 @@\n+\n@@ -103,1 +122,5 @@\n-        getRGBPixelsImpl(xgc, x, y, 1, 1, pixelArray, useGtk);\n+        if (useScreencast && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.getRGBPixels(x, y, 1, 1, pixelArray);\n+        } else {\n+            getRGBPixelsImpl(xgc, x, y, 1, 1, pixelArray, useGtk);\n+        }\n@@ -109,3 +132,15 @@\n-        int[] pixelArray = new int[bounds.width*bounds.height];\n-        getRGBPixelsImpl(xgc, bounds.x, bounds.y, bounds.width, bounds.height,\n-                            pixelArray, useGtk);\n+        int[] pixelArray = new int[bounds.width * bounds.height];\n+        if (useScreencast && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.getRGBPixels(\n+                    bounds.x, bounds.y,\n+                    bounds.width, bounds.height,\n+                    pixelArray\n+            );\n+        } else {\n+            getRGBPixelsImpl(\n+                    xgc,\n+                    bounds.x, bounds.y,\n+                    bounds.width, bounds.height,\n+                    pixelArray, useGtk\n+            );\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XRobotPeer.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+package sun.awt.screencast;\n+\n+import sun.security.action.GetPropertyAction;\n+\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.security.AccessController;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.IntStream;\n+\n+@SuppressWarnings(\"removal\")\n+public class ScreencastHelper {\n+\n+    static final boolean SCREENCAST_DEBUG;\n+    private static final boolean IS_NATIVE_LOADED;\n+\n+\n+    private static final int DENIED = -11;\n+\n+    private ScreencastHelper() {\n+    }\n+\n+    static {\n+        SCREENCAST_DEBUG = Boolean.parseBoolean(\n+                AccessController.doPrivileged(\n+                        new GetPropertyAction(\n+                                \"awt.robot.screencastDebug\",\n+                                \"false\"\n+                        )\n+                ));\n+\n+        boolean loadFailed = false;\n+\n+        if (!TokenStorage.initSuccessful()\n+                || !loadPipewire(SCREENCAST_DEBUG)) {\n+\n+            System.err.println(\n+                    \"Could not load native libraries for ScreencastHelper\"\n+            );\n+\n+            loadFailed = true;\n+        }\n+\n+        IS_NATIVE_LOADED = !loadFailed;\n+    }\n+\n+    public static boolean isAvailable() {\n+        return IS_NATIVE_LOADED;\n+    }\n+\n+    private static native boolean loadPipewire(boolean screencastDebug);\n+\n+    private static native int getRGBPixelsImpl(\n+            int x, int y, int width, int height,\n+            int[] pixelArray,\n+            int[] affectedScreensBoundsArray,\n+            String token\n+    );\n+\n+    private static List<Rectangle> getSystemScreensBounds() {\n+        return Arrays\n+                .stream(GraphicsEnvironment\n+                        .getLocalGraphicsEnvironment()\n+                        .getScreenDevices())\n+                .map(graphicsDevice ->\n+                        graphicsDevice.getDefaultConfiguration().getBounds()\n+                ).toList();\n+    }\n+\n+    public static synchronized void getRGBPixels(\n+            int x, int y, int width, int height, int[] pixelArray\n+    ) {\n+        if (!IS_NATIVE_LOADED) return;\n+\n+        Rectangle captureArea = new Rectangle(x, y, width, height);\n+\n+        List<Rectangle> affectedScreenBounds =  getSystemScreensBounds()\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .toList();\n+\n+        if (SCREENCAST_DEBUG) {\n+            System.out.println(\"\/\/ getRGBPixels affectedScreenBounds \"\n+                    + affectedScreenBounds);\n+        }\n+\n+        if (affectedScreenBounds.isEmpty()) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getRGBPixels - requested area \"\n+                        + \"outside of any screen\");\n+            }\n+            return;\n+        }\n+\n+        int retVal;\n+        Set<TokenItem> tokensForRectangle =\n+                TokenStorage.getTokens(affectedScreenBounds);\n+\n+        int[] affectedScreenBoundsArray = affectedScreenBounds\n+                .stream()\n+                .filter(captureArea::intersects)\n+                .flatMapToInt(bounds -> IntStream.of(\n+                        bounds.x, bounds.y,\n+                        bounds.width, bounds.height\n+                ))\n+                .toArray();\n+\n+        for (TokenItem tokenItem : tokensForRectangle) {\n+            retVal = getRGBPixelsImpl(\n+                    x, y, width, height,\n+                    pixelArray,\n+                    affectedScreenBoundsArray,\n+                    tokenItem.token\n+            );\n+\n+            if (retVal >= 0) { \/\/ we have received a screen data\n+                return;\n+            }\n+        }\n+\n+        \/\/ we do not have a saved token or it did not work,\n+        \/\/ try without the token to show the system's permission request window\n+        retVal = getRGBPixelsImpl(\n+                x, y, width, height,\n+                pixelArray,\n+                affectedScreenBoundsArray,\n+                null\n+        );\n+\n+        if (retVal == DENIED) {\n+            throw new SecurityException(\n+                    \"Screen Capture in the selected area was not allowed\"\n+            );\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+final class TokenItem implements Serializable {\n+    static final long serialVersionUID = -289029960632065531L;\n+\n+    String token;\n+    ArrayList<Rectangle> allowedScreensBounds;\n+\n+    public TokenItem(String token, int[] allowedScreenBounds) {\n+        if (allowedScreenBounds.length % 4 != 0) {\n+            throw new RuntimeException(\"array with incorrect length provided\");\n+        }\n+\n+        this.token = token;\n+\n+        this.allowedScreensBounds =\n+                (ArrayList<Rectangle>) IntStream\n+                        .iterate(0,\n+                                i -> i < allowedScreenBounds.length,\n+                                i -> i + 4)\n+                        .mapToObj(i -> new Rectangle(\n+                                allowedScreenBounds[i], allowedScreenBounds[i+1],\n+                                allowedScreenBounds[i+2], allowedScreenBounds[i+3]\n+                        ))\n+                        .collect(Collectors.toList());\n+    }\n+\n+    public boolean hasAllScreensWithExactMatch(List<Rectangle> bounds) {\n+        return allowedScreensBounds.containsAll(bounds);\n+    }\n+\n+    public boolean hasAllScreensOfSameSize(List<Dimension> screenSizes) {\n+        \/\/ We also need to consider duplicates, since there may be\n+        \/\/ multiple screens of the same size.\n+        \/\/ The token item must also have at least the same number\n+        \/\/ of screens with that size.\n+\n+        List<Dimension> tokenSizes = allowedScreensBounds\n+                .stream()\n+                .map(bounds -> new Dimension(bounds.width, bounds.height))\n+                .collect(Collectors.toCollection(ArrayList::new));\n+\n+        return screenSizes.size() == screenSizes\n+                .stream()\n+                .filter(tokenSizes::remove)\n+                .count();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"Token: \" + token + \"\\n\");\n+        for (Rectangle bounds : allowedScreensBounds) {\n+            sb.append(\"\\t\").append(bounds).append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenItem.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+package sun.awt.screencast;\n+\n+import java.awt.Dimension;\n+import java.awt.Rectangle;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.prefs.BackingStoreException;\n+import java.util.prefs.Preferences;\n+import java.util.stream.Collectors;\n+\n+import static sun.awt.screencast.ScreencastHelper.SCREENCAST_DEBUG;\n+\n+final class TokenStorage {\n+    private TokenStorage() {\n+    }\n+\n+    private static final Preferences TOKEN_STORE;\n+\n+    static {\n+        Preferences tokenStore;\n+        try {\n+            tokenStore = Preferences\n+                    .userNodeForPackage(ScreencastHelper.class)\n+                    .node(\"tokenStorage\");\n+        } catch (Exception e) {\n+            System.err.println(\"Failed to initialize token storage\");\n+            tokenStore = null;\n+        }\n+\n+        TOKEN_STORE = tokenStore;\n+    }\n+\n+\n+    static boolean initSuccessful() {\n+        return TOKEN_STORE != null;\n+    }\n+\n+    \/\/ called from native\n+    private static void storeTokenFromNative(String oldToken,\n+                                             String newToken,\n+                                             int[] allowedScreenBounds) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"\/\/ storeToken old: |%s| new |%s| \" +\n+                            \"allowed bounds %s\\n\",\n+                    oldToken, newToken,\n+                    Arrays.toString(allowedScreenBounds));\n+        }\n+\n+        if (allowedScreenBounds == null) return;\n+\n+        storeToken(new TokenItem(newToken, allowedScreenBounds));\n+\n+        if (oldToken != null && !oldToken.equals(newToken)) {\n+            \/\/ old token is no longer valid\n+            if (SCREENCAST_DEBUG) {\n+                System.out.printf(\n+                        \"\/\/ storeTokenFromNative old token |%s| is \"\n+                        + \"no longer valid, removing\\n\", oldToken);\n+            }\n+            TOKEN_STORE.remove(oldToken);\n+        }\n+    }\n+\n+    private static void storeToken(TokenItem tokenItem) {\n+        if (SCREENCAST_DEBUG) {\n+            System.out.printf(\"Storing TokenItem:\\n%s\\n\", tokenItem);\n+        }\n+\n+        try {\n+            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(bos);\n+            out.writeObject(tokenItem);\n+            TOKEN_STORE.putByteArray(tokenItem.token, bos.toByteArray());\n+            TOKEN_STORE.flush();\n+        } catch (IOException | BackingStoreException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+    }\n+\n+    private static TokenItem readToken(String token) {\n+        byte[] bytes = TOKEN_STORE.getByteArray(token, null);\n+        if (bytes == null) {\n+            return null;\n+        }\n+        try {\n+            ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n+            ObjectInputStream in = new ObjectInputStream(bis);\n+            Object o = in.readObject();\n+            if (o instanceof TokenItem t) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.out.printf(\"TokenItem read:\\n%s\\n\", t);\n+                }\n+                return t;\n+            }\n+        } catch (ClassNotFoundException | IOException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    static Set<TokenItem> getTokens(List<Rectangle> affectedScreenBounds) {\n+        \/\/ We need an ordered set to store tokens with exact matches at the beginning.\n+        LinkedHashSet<TokenItem> result = new LinkedHashSet<>();\n+        try {\n+            TOKEN_STORE.sync();\n+\n+            List<TokenItem> allTokenItems =\n+                    Arrays.stream(TOKEN_STORE.keys())\n+                            .map(TokenStorage::readToken)\n+                            .toList();\n+\n+\n+            \/\/ 1. Try to find exact matches\n+            for (TokenItem tokenItem : allTokenItems) {\n+                if (tokenItem != null\n+                        && tokenItem\n+                        .hasAllScreensWithExactMatch(affectedScreenBounds)) {\n+                    result.add(tokenItem);\n+                }\n+            }\n+\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getTokens exact matches 1. \" + result);\n+            }\n+\n+\n+            \/\/ 2. Try screens of the same size but in different locations,\n+            \/\/ screens may have been moved while the token is still valid\n+            List<Dimension> dimensions = affectedScreenBounds\n+                    .stream()\n+                    .map(rectangle -> new Dimension(\n+                            rectangle.width,\n+                            rectangle.height\n+                    ))\n+                    .collect(Collectors.toCollection(ArrayList::new));\n+\n+            for (TokenItem tokenItem : allTokenItems) {\n+                if (tokenItem != null\n+                        && tokenItem.hasAllScreensOfSameSize(dimensions)) {\n+                    result.add(tokenItem);\n+                }\n+            }\n+\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"\/\/ getTokens same sizes 2. \" + result);\n+            }\n+\n+            return result;\n+        } catch (BackingStoreException e) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(e);\n+            }\n+        }\n+        return Set.of();\n+    }\n+}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+## PipeWire 0.3.68\n+\n+### PipeWire license:\n+\n+All PipeWire header files are licensed under the MIT License:\n+\n+\n+<pre>\n+Copyright © 2018-2023 Wim Taymans\n+\n+Permission is hereby granted, free of charge, to any person obtaining a\n+copy of this software and associated documentation files (the \"Software\"),\n+to deal in the Software without restriction, including without limitation\n+the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+and\/or sell copies of the Software, and to permit persons to whom the\n+Software is furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice (including the next\n+paragraph) shall be included in all copies or substantial portions of the\n+Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL\n+THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE.\n+<\/pre>\n+\n+The below copyright applies to the following files:\n+\n+spa\/include\/spa\/monitor\/type-info.h\n+```\n+Copyright © 2021 Collabora Ltd.\n+```\n+\n+spa\/include\/spa\/utils\/string.h\n+```\n+Copyright © 2021 Red Hat, Inc.\n+```\n","filename":"src\/java.desktop\/unix\/legal\/pipewire.md","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+#ifndef _FP_PIPEWIRE_H\n+#define _FP_PIPEWIRE_H\n+\n+\n+struct pw_buffer *(*fp_pw_stream_dequeue_buffer)(struct pw_stream *stream);\n+const char * (*fp_pw_stream_state_as_string)(enum pw_stream_state state);\n+int (*fp_pw_stream_queue_buffer)(struct pw_stream *stream,\n+                                 struct pw_buffer *buffer);\n+int (*fp_pw_stream_set_active)(struct pw_stream *stream, bool active);\n+\n+int (*fp_pw_stream_connect)(\n+        struct pw_stream *stream,\n+        enum pw_direction direction,\n+        uint32_t target_id,\n+        enum pw_stream_flags flags,\n+        const struct spa_pod **params,\n+        uint32_t n_params);\n+\n+struct pw_stream *(*fp_pw_stream_new)(\n+        struct pw_core *core,\n+        const char *name,\n+        struct pw_properties *props\n+);\n+void (*fp_pw_stream_add_listener)(struct pw_stream *stream,\n+                            struct spa_hook *listener,\n+                            const struct pw_stream_events *events,\n+                            void *data);\n+int (*fp_pw_stream_disconnect)(struct pw_stream *stream);\n+void (*fp_pw_stream_destroy)(struct pw_stream *stream);\n+\n+\n+void (*fp_pw_init)(int *argc, char **argv[]);\n+\n+\n+struct pw_core *\n+(*fp_pw_context_connect_fd)(struct pw_context *context,\n+                      int fd,\n+                      struct pw_properties *properties,\n+                      size_t user_data_size);\n+\n+int (*fp_pw_core_disconnect)(struct pw_core *core);\n+\n+struct pw_context * (*fp_pw_context_new)(struct pw_loop *main_loop,\n+                                   struct pw_properties *props,\n+                                   size_t user_data_size);\n+\n+struct pw_thread_loop *\n+(*fp_pw_thread_loop_new)(const char *name, const struct spa_dict *props);\n+struct pw_loop * (*fp_pw_thread_loop_get_loop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_signal)(struct pw_thread_loop *loop,\n+                                 bool wait_for_accept);\n+void (*fp_pw_thread_loop_wait)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_accept)(struct pw_thread_loop *loop);\n+int (*fp_pw_thread_loop_start)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_stop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_destroy)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_lock)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_unlock)(struct pw_thread_loop *loop);\n+\n+struct pw_properties * (*fp_pw_properties_new)(const char *key, ...);\n+\n+\n+#endif \/\/_FP_PIPEWIRE_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/fp_pipewire.h","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,7 +89,0 @@\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GdkRectangle;\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,4 @@\n+static void transform_detail_string (const gchar *detail,\n+                                     GtkStyleContext *context);\n+static void gtk3_init(GtkApi* gtk);\n+\n@@ -249,0 +253,1 @@\n+gboolean glib_version_2_68 = FALSE;\n@@ -570,0 +575,44 @@\n+\n+        \/**\n+         * other\n+         *\/\n+\n+        fp_g_bus_get_sync = dl_symbol(\"g_bus_get_sync\");\n+        fp_g_dbus_proxy_call_sync = dl_symbol(\"g_dbus_proxy_call_sync\");\n+        fp_g_dbus_proxy_new_sync = dl_symbol(\"g_dbus_proxy_new_sync\");\n+        fp_g_dbus_connection_get_unique_name = dl_symbol(\"g_dbus_connection_get_unique_name\");\n+        fp_g_dbus_connection_call_sync = dl_symbol(\"g_dbus_connection_call_sync\");\n+        fp_g_dbus_connection_signal_subscribe = dl_symbol(\"g_dbus_connection_signal_subscribe\");\n+        fp_g_dbus_connection_signal_unsubscribe = dl_symbol(\"g_dbus_connection_signal_unsubscribe\");\n+        fp_g_dbus_proxy_call_with_unix_fd_list_sync = dl_symbol(\"g_dbus_proxy_call_with_unix_fd_list_sync\");\n+\n+        fp_g_variant_builder_init = dl_symbol(\"g_variant_builder_init\");\n+        fp_g_variant_builder_add = dl_symbol(\"g_variant_builder_add\");\n+        fp_g_variant_new = dl_symbol(\"g_variant_new\");\n+        fp_g_variant_new_string = dl_symbol(\"g_variant_new_string\");\n+        fp_g_variant_new_uint32 = dl_symbol(\"g_variant_new_uint32\");\n+        fp_g_variant_new_boolean = dl_symbol(\"g_variant_new_boolean\");\n+        fp_g_variant_get = dl_symbol(\"g_variant_get\");\n+        fp_g_variant_get_string = dl_symbol(\"g_variant_get_string\");\n+        fp_g_variant_get_uint32 = dl_symbol(\"g_variant_get_uint32\");\n+        fp_g_variant_iter_loop = dl_symbol(\"g_variant_iter_loop\");\n+        fp_g_variant_unref = dl_symbol(\"g_variant_unref\");\n+        fp_g_variant_lookup = dl_symbol(\"g_variant_lookup\");\n+        fp_g_variant_lookup_value = dl_symbol(\"g_variant_lookup_value\");\n+        fp_g_variant_iter_init = dl_symbol(\"g_variant_iter_init\");\n+        fp_g_variant_iter_n_children = dl_symbol(\"g_variant_iter_n_children\");\n+\n+        fp_g_string_new = dl_symbol(\"g_string_new\");\n+        fp_g_string_erase = dl_symbol(\"g_string_erase\");\n+        fp_g_string_free = dl_symbol(\"g_string_free\");\n+\n+        glib_version_2_68 = !fp_glib_check_version(2, 68, 0);\n+        if (glib_version_2_68) {\n+            fp_g_string_replace = dl_symbol(\"g_string_replace\"); \/\/since: 2.68\n+            fp_g_uuid_string_is_valid = \/\/since: 2.52\n+                    dl_symbol(\"g_uuid_string_is_valid\");\n+        }\n+        fp_g_string_printf = dl_symbol(\"g_string_printf\");\n+\n+        fp_g_error_free = dl_symbol(\"g_error_free\");\n+        fp_g_unix_fd_list_get = dl_symbol(\"g_unix_fd_list_get\");\n@@ -3030,0 +3079,42 @@\n+\n+    gtk->g_bus_get_sync = fp_g_bus_get_sync;\n+    gtk->g_dbus_proxy_call_sync = fp_g_dbus_proxy_call_sync;\n+    gtk->g_dbus_proxy_new_sync = fp_g_dbus_proxy_new_sync;\n+    gtk->g_dbus_connection_get_unique_name = fp_g_dbus_connection_get_unique_name;\n+    gtk->g_dbus_connection_signal_subscribe = fp_g_dbus_connection_signal_subscribe;\n+    gtk->g_dbus_connection_signal_unsubscribe = fp_g_dbus_connection_signal_unsubscribe;\n+    gtk->g_dbus_proxy_call_with_unix_fd_list_sync = fp_g_dbus_proxy_call_with_unix_fd_list_sync;\n+    gtk->g_dbus_connection_call_sync = fp_g_dbus_connection_call_sync;\n+\n+    gtk->g_variant_new = fp_g_variant_new;\n+    gtk->g_variant_new_string = fp_g_variant_new_string;\n+    gtk->g_variant_new_boolean = fp_g_variant_new_boolean;\n+    gtk->g_variant_new_uint32 = fp_g_variant_new_uint32;\n+\n+    gtk->g_variant_get = fp_g_variant_get;\n+    gtk->g_variant_get_string = fp_g_variant_get_string;\n+    gtk->g_variant_get_uint32 = fp_g_variant_get_uint32;\n+\n+    gtk->g_variant_lookup = fp_g_variant_lookup;\n+\n+    gtk->g_variant_iter_loop = fp_g_variant_iter_loop;\n+\n+    gtk->g_variant_unref = fp_g_variant_unref;\n+\n+    gtk->g_variant_builder_init = fp_g_variant_builder_init;\n+    gtk->g_variant_builder_add = fp_g_variant_builder_add;\n+\n+    gtk->g_variant_lookup_value = fp_g_variant_lookup_value;\n+    gtk->g_variant_iter_init = fp_g_variant_iter_init;\n+    gtk->g_variant_iter_n_children = fp_g_variant_iter_n_children;\n+\n+    gtk->g_string_new = fp_g_string_new;\n+    gtk->g_string_erase = fp_g_string_erase;\n+    gtk->g_string_free = fp_g_string_free;\n+    gtk->g_string_replace = fp_g_string_replace;\n+    gtk->g_string_printf = fp_g_string_printf;\n+    gtk->g_uuid_string_is_valid = fp_g_uuid_string_is_valid;\n+\n+    gtk->g_main_context_iteration = fp_g_main_context_iteration;\n+    gtk->g_error_free = fp_g_error_free;\n+    gtk->g_unix_fd_list_get = fp_g_unix_fd_list_get;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,7 +238,0 @@\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GdkRectangle;\n-\n@@ -378,1 +371,0 @@\n-static void gtk3_init(GtkApi* gtk);\n@@ -497,3 +489,2 @@\n-static void transform_detail_string (const gchar *detail,\n-                     GtkStyleContext *context);\n-void (*fp_gtk_style_context_set_junction_sides)(GtkStyleContext  *context,\n+\n+static void (*fp_gtk_style_context_set_junction_sides)(GtkStyleContext  *context,\n@@ -501,1 +492,1 @@\n-void (*fp_gtk_style_context_add_region)(GtkStyleContext *context,\n+static void (*fp_gtk_style_context_add_region)(GtkStyleContext *context,\n@@ -503,1 +494,1 @@\n-void (*fp_gtk_render_arrow)(GtkStyleContext *context, cairo_t *cr,\n+static void (*fp_gtk_render_arrow)(GtkStyleContext *context, cairo_t *cr,\n@@ -505,2 +496,2 @@\n-void (*fp_gtk_bin_set_child)(GtkBin *bin, GtkWidget *widget);\n-void (*fp_gtk_scrolled_window_set_shadow_type)(\n+static void (*fp_gtk_bin_set_child)(GtkBin *bin, GtkWidget *widget);\n+static void (*fp_gtk_scrolled_window_set_shadow_type)(\n@@ -525,1 +516,1 @@\n-                     gdouble page_increment);\n+                                                    gdouble page_increment);\n@@ -640,0 +631,152 @@\n+\n+\/\/ ---------- fp_g_dbus_* ----------\n+static GVariant *(*fp_g_dbus_proxy_call_sync)(\n+        GDBusProxy *proxy,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static GDBusProxy *(*fp_g_dbus_proxy_new_sync)(\n+        GDBusConnection *connection,\n+        GDBusProxyFlags flags,\n+        GDBusInterfaceInfo *info,\n+        const gchar *name,\n+        const gchar *object_path,\n+        const gchar *interface_name,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static const gchar *(*fp_g_dbus_connection_get_unique_name)(\n+        GDBusConnection *connection\n+);\n+\n+static GDBusConnection *(*fp_g_bus_get_sync)(GBusType bus_type,\n+                                             GCancellable *cancellable,\n+                                             GError **error);\n+\n+static guint (*fp_g_dbus_connection_signal_subscribe)(\n+        GDBusConnection *connection,\n+        const gchar *sender,\n+        const gchar *interface_name,\n+        const gchar *member,\n+        const gchar *object_path,\n+        const gchar *arg0,\n+        GDBusSignalFlags flags,\n+        GDBusSignalCallback callback,\n+        gpointer user_data,\n+        GDestroyNotify user_data_free_func\n+);\n+\n+static void (*fp_g_dbus_connection_signal_unsubscribe)(\n+        GDBusConnection *connection,\n+        guint subscription_id\n+);\n+\n+static GVariant *(*fp_g_dbus_proxy_call_with_unix_fd_list_sync)(\n+        GDBusProxy *proxy,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GUnixFDList *fd_list,\n+        GUnixFDList **out_fd_list,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+static GVariant *(*fp_g_dbus_connection_call_sync)(\n+        GDBusConnection *connection,\n+        const gchar *bus_name,\n+        const gchar *object_path,\n+        const gchar *interface_name,\n+        const gchar *method_name,\n+        GVariant *parameters,\n+        const GVariantType *reply_type,\n+        GDBusCallFlags flags,\n+        gint timeout_msec,\n+        GCancellable *cancellable,\n+        GError **error\n+);\n+\n+\/\/ ---------- fp_g_variant_*  ----------\n+\n+static GVariant *(*fp_g_variant_new)(const gchar *format_string, ...);\n+\n+static GVariant *(*fp_g_variant_new_string)(const gchar *string);\n+\n+static GVariant *(*fp_g_variant_new_boolean)(gboolean value);\n+\n+static GVariant *(*fp_g_variant_new_uint32)(guint32 value);\n+\n+static void (*fp_g_variant_get)(GVariant *value,\n+                                const gchar *format_string,\n+                                ...);\n+\n+static const gchar *(*fp_g_variant_get_string)(GVariant *value,\n+                                               gsize *length);\n+\n+static guint32 (*fp_g_variant_get_uint32)(GVariant *value);\n+\n+static gboolean (*fp_g_variant_lookup)(GVariant *dictionary,\n+                                       const gchar *key,\n+                                       const gchar *format_string,\n+                                       ...);\n+\n+static gboolean (*fp_g_variant_iter_loop)(GVariantIter *iter,\n+                                          const gchar *format_string,\n+                                          ...);\n+\n+static void (*fp_g_variant_unref)(GVariant *value);\n+\n+static void (*fp_g_variant_builder_init)(GVariantBuilder *builder,\n+                                         const GVariantType *type);\n+\n+static void (*fp_g_variant_builder_add)(GVariantBuilder *builder,\n+                                        const gchar *format_string,\n+                                        ...);\n+\n+static GVariant *(*fp_g_variant_lookup_value)(GVariant *dictionary,\n+                                              const gchar *key,\n+                                              const GVariantType *expected_type);\n+\n+static gsize (*fp_g_variant_iter_init)(GVariantIter *iter,\n+                                       GVariant *value);\n+\n+static gsize (*fp_g_variant_iter_n_children)(GVariantIter *iter);\n+\n+\n+\/\/ ---------- fp_g_string_* ----------\n+\n+static GString *(*fp_g_string_new)(const gchar *init);\n+\n+static GString *(*fp_g_string_erase)(GString *string,\n+                                     gssize pos,\n+                                     gssize len);\n+\n+static gchar *(*fp_g_string_free)(GString *string,\n+                                  gboolean free_segment);\n+\n+static guint (*fp_g_string_replace)(GString *string,\n+                                    const gchar *find,\n+                                    const gchar *replace,\n+                                    guint limit);\n+\n+static void *(*fp_g_string_printf)(GString *string,\n+                                   const gchar *format,\n+                                   ...);\n+\n+static gboolean (*fp_g_uuid_string_is_valid)(const gchar *str);\n+\n+\n+\/\/ ---------- * ----------\n+static void (*fp_g_error_free)(GError *error);\n+\n+static gint (*fp_g_unix_fd_list_get)(GUnixFDList *list,\n+                                     gint index_,\n+                                     GError **error);\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":160,"deletions":17,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-typedef unsigned int   gsize;\n+typedef unsigned long   gsize;\n@@ -131,0 +131,87 @@\n+typedef signed long gssize;\n+typedef struct _GString         GString;\n+\n+struct _GString\n+{\n+    gchar  *str;\n+    gsize len;\n+    gsize allocated_len;\n+};\n+\n+typedef struct _GVariant                      GVariant;\n+typedef struct _GVariantIter GVariantIter;\n+struct _GVariantIter {\n+    \/*< private >*\/\n+    gsize x[16];\n+};\n+\n+typedef struct _GVariantType GVariantType;\n+typedef struct _GVariantBuilder GVariantBuilder;\n+\n+struct _GVariantBuilder {\n+    \/*< private >*\/\n+    union\n+    {\n+        struct {\n+            gsize partial_magic;\n+            const GVariantType *type;\n+            gsize y[14];\n+        } s;\n+        gsize x[16];\n+    } u;\n+};\n+\n+\n+#define G_VARIANT_TYPE_VARDICT              ((const GVariantType *) \"a{sv}\")\n+#define G_VARIANT_TYPE_ARRAY                ((const GVariantType *) \"a*\")\n+#define G_VARIANT_TYPE_STRING               ((const GVariantType *) \"s\")\n+\n+typedef struct _GDBusProxy                    GDBusProxy;\n+typedef enum {\n+    G_DBUS_CALL_FLAGS_NONE = 0,\n+    G_DBUS_CALL_FLAGS_NO_AUTO_START = (1<<0),\n+    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = (1<<1)\n+} GDBusCallFlags;\n+\n+typedef void GMainContext;\n+typedef void GUnixFDList;\n+\n+typedef void GDBusConnection;\n+typedef enum \/*< flags >*\/\n+{\n+    G_DBUS_SIGNAL_FLAGS_NONE = 0,\n+    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = (1<<0),\n+    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = (1<<1),\n+    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = (1<<2)\n+} GDBusSignalFlags;\n+\n+typedef void (*GDBusSignalCallback) (GDBusConnection  *connection,\n+                                     const gchar      *sender_name,\n+                                     const gchar      *object_path,\n+                                     const gchar      *interface_name,\n+                                     const gchar      *signal_name,\n+                                     GVariant         *parameters,\n+                                     gpointer          user_data);\n+\n+typedef struct _GCancellable                  GCancellable;\n+\n+typedef enum\n+{\n+    G_BUS_TYPE_STARTER = -1,\n+    G_BUS_TYPE_NONE = 0,\n+    G_BUS_TYPE_SYSTEM  = 1,\n+    G_BUS_TYPE_SESSION = 2\n+} GBusType;\n+\n+typedef enum\n+{\n+    G_DBUS_PROXY_FLAGS_NONE = 0,\n+    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = (1<<0),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = (1<<1),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = (1<<2),\n+    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = (1<<3),\n+    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = (1<<4)\n+} GDBusProxyFlags;\n+\n+typedef struct _GDBusInterfaceInfo            GDBusInterfaceInfo;\n+\n@@ -412,0 +499,8 @@\n+typedef guint32 GQuark;\n+struct _GError\n+{\n+    GQuark       domain;\n+    gint         code;\n+    gchar       *message;\n+};\n+typedef struct _GError GError;\n@@ -413,1 +508,0 @@\n-typedef void GError;\n@@ -420,0 +514,8 @@\n+\n+typedef struct {\n+    gint x;\n+    gint y;\n+    gint width;\n+    gint height;\n+} GdkRectangle;\n+\n@@ -516,1 +618,0 @@\n-\n@@ -561,0 +662,135 @@\n+\n+\n+    \/* <for screencast, used only with GTK3>  *\/\n+    GVariant *(*g_dbus_proxy_call_sync)(\n+            GDBusProxy *proxy,\n+            const gchar *method_name,\n+            GVariant *parameters,\n+            GDBusCallFlags flags,\n+            gint timeout_msec,\n+            GCancellable *cancellable,\n+            GError **error);\n+\n+    GVariant *(*g_variant_new)(const gchar *format_string, ...);\n+    GVariant *(*g_variant_new_string)(const gchar *string);\n+    GVariant *(*g_variant_new_boolean)(gboolean value);\n+    GVariant *(*g_variant_new_uint32)(guint32 value);\n+\n+\n+    void (*g_variant_get)(GVariant *value,\n+                                    const gchar *format_string,\n+                                    ...);\n+    const gchar *(*g_variant_get_string)(GVariant *value, gsize *length);\n+    guint32 (*g_variant_get_uint32)(GVariant *value);\n+\n+    gboolean (*g_variant_lookup)(GVariant *dictionary,\n+                                           const gchar *key,\n+                                           const gchar *format_string,\n+                                           ...);\n+    gboolean (*g_variant_iter_loop)(GVariantIter *iter,\n+                                              const gchar *format_string,\n+                                              ...);\n+\n+    void (*g_variant_unref)(GVariant             *value);\n+\n+    void (*g_variant_builder_init)(GVariantBuilder *builder, \/\/+\n+                                             const GVariantType *type);\n+\n+    void (*g_variant_builder_add)(GVariantBuilder *builder, \/\/+\n+                                            const gchar *format_string,\n+                                            ...);\n+\n+    GVariant *(*g_variant_lookup_value)(GVariant *dictionary,\n+                                                  const gchar *key,\n+                                                  const GVariantType *expected_type);\n+\n+    gsize (*g_variant_iter_init)(GVariantIter *iter,\n+                                           GVariant *value);\n+\n+    gsize (*g_variant_iter_n_children)(GVariantIter *iter);\n+\n+\n+    GString *(*g_string_new)(const gchar *init);\n+\n+    GString *(*g_string_erase)(GString *string,\n+                               gssize pos,\n+                               gssize len);\n+\n+    gchar *(*g_string_free)(GString *string,\n+                            gboolean free_segment);\n+\n+    guint (*g_string_replace)(GString *string,\n+                              const gchar *find,\n+                              const gchar *replace,\n+                              guint limit);\n+\n+    void *(*g_string_printf)(GString *string,\n+                             const gchar *format,\n+                             ...);\n+\n+    gboolean (*g_uuid_string_is_valid)(const gchar *str);\n+\n+\n+    GDBusConnection *(*g_bus_get_sync)(GBusType bus_type,\n+                                       GCancellable *cancellable,\n+                                       GError **error);\n+\n+    GDBusProxy *(*g_dbus_proxy_new_sync)(GDBusConnection *connection,\n+                                                   GDBusProxyFlags flags,\n+                                                   GDBusInterfaceInfo *info,\n+                                                   const gchar *name,\n+                                                   const gchar *object_path,\n+                                                   const gchar *interface_name,\n+                                                   GCancellable *cancellable,\n+                                                   GError **error);\n+\n+    const gchar *(*g_dbus_connection_get_unique_name)(GDBusConnection *connection);\n+\n+\n+\n+    guint (*g_dbus_connection_signal_subscribe)(GDBusConnection *connection,\n+                                                          const gchar *sender,\n+                                                          const gchar *interface_name,\n+                                                          const gchar *member,\n+                                                          const gchar *object_path,\n+                                                          const gchar *arg0,\n+                                                          GDBusSignalFlags flags,\n+                                                          GDBusSignalCallback callback,\n+                                                          gpointer user_data,\n+                                                          GDestroyNotify user_data_free_func);\n+\n+    void (*g_dbus_connection_signal_unsubscribe)(GDBusConnection *connection,\n+                                                           guint subscription_id);\n+\n+    GVariant *(*g_dbus_proxy_call_with_unix_fd_list_sync)(GDBusProxy *proxy,\n+                                                                    const gchar *method_name,\n+                                                                    GVariant *parameters,\n+                                                                    GDBusCallFlags flags,\n+                                                                    gint timeout_msec,\n+                                                                    GUnixFDList *fd_list,\n+                                                                    GUnixFDList **out_fd_list,\n+                                                                    GCancellable *cancellable,\n+                                                                    GError **error);\n+\n+    GVariant *(*g_dbus_connection_call_sync)(GDBusConnection *connection,\n+                                                       const gchar *bus_name,\n+                                                       const gchar *object_path,\n+                                                       const gchar *interface_name,\n+                                                       const gchar *method_name,\n+                                                       GVariant *parameters,\n+                                                       const GVariantType *reply_type,\n+                                                       GDBusCallFlags flags,\n+                                                       gint timeout_msec,\n+                                                       GCancellable *cancellable,\n+                                                       GError **error);\n+\n+    gboolean (*g_main_context_iteration)(GMainContext *context,\n+                                         gboolean may_block);\n+\n+    void (*g_error_free)(GError *error);\n+\n+    gint (*g_unix_fd_list_get)(GUnixFDList *list,\n+                               gint index_,\n+                               GError **error);\n+\n+    \/* <\/for screencast, used only with GTK3>  *\/\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.h","additions":240,"deletions":4,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -0,0 +1,915 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+#include <dlfcn.h>\n+#include \"jni_util.h\"\n+#include \"awt.h\"\n+#include \"screencast_pipewire.h\"\n+#include \"fp_pipewire.h\"\n+#include <stdio.h>\n+\n+#include \"gtk_interface.h\"\n+#include \"gtk3_interface.h\"\n+\n+int DEBUG_SCREENCAST_ENABLED = FALSE;\n+\n+#define EXCEPTION_CHECK_DESCRIBE_CLEAR() if ((*env)->ExceptionCheck(env)) { \\\n+                                            (*env)->ExceptionDescribe(env); \\\n+                                            (*env)->ExceptionClear(env);    \\\n+                                         }\n+\n+struct ScreenSpace screenSpace = {0};\n+static struct PwLoopData pw = {0};\n+\n+jclass tokenStorageClass = NULL;\n+jmethodID storeTokenMethodID = NULL;\n+\n+inline void debug_screencast(\n+        const char *__restrict fmt,\n+        ...\n+) {\n+    if (DEBUG_SCREENCAST_ENABLED) {\n+        va_list myargs;\n+        va_start(myargs, fmt);\n+        vfprintf(stdout, fmt, myargs);\n+        va_end(myargs);\n+    }\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+static gboolean initScreenSpace() {\n+    screenSpace.screenCount = 0;\n+    screenSpace.allocated = SCREEN_SPACE_DEFAULT_ALLOCATED;\n+    screenSpace.screens = calloc(\n+            SCREEN_SPACE_DEFAULT_ALLOCATED,\n+            sizeof(struct ScreenProps)\n+    );\n+\n+    if (!screenSpace.screens) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return FALSE;\n+    }\n+    return TRUE;\n+}\n+\n+static void doCleanup() {\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct ScreenProps *screenProps = &screenSpace.screens[i];\n+        if (screenProps->data) {\n+            if (screenProps->data->stream) {\n+                fp_pw_stream_disconnect(screenProps->data->stream);\n+                fp_pw_stream_destroy(screenProps->data->stream);\n+                screenProps->data->stream = NULL;\n+            }\n+            free(screenProps->data);\n+            screenProps->data = NULL;\n+        }\n+    }\n+\n+    if (pw.pwFd > 0) {\n+        close(pw.pwFd);\n+        pw.pwFd = -1;\n+    }\n+\n+    portalScreenCastCleanup();\n+\n+    if (pw.core) {\n+        fp_pw_core_disconnect(pw.core);\n+        pw.core = NULL;\n+    }\n+\n+    DEBUG_SCREENCAST(\"STOPPING loop\\n\", NULL)\n+\n+    if (pw.loop) {\n+        fp_pw_thread_loop_stop(pw.loop);\n+        fp_pw_thread_loop_destroy(pw.loop);\n+        pw.loop = NULL;\n+    }\n+\n+    if (screenSpace.screens) {\n+        free(screenSpace.screens);\n+        screenSpace.screens = NULL;\n+    }\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+static gboolean initScreencast(const gchar *token,\n+                               GdkRectangle *affectedBounds,\n+                               gint affectedBoundsLength) {\n+    fp_pw_init(NULL, NULL);\n+\n+    pw.pwFd = -1;\n+\n+    if (!initScreenSpace()\n+        || !initXdgDesktopPortal()\n+        || (pw.pwFd = getPipewireFd(token,\n+                                    affectedBounds,\n+                                    affectedBoundsLength)) < 0) {\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+static inline void convertRGBxToBGRx(int* in) {\n+    char* o = (char*) in;\n+    char tmp = o[0];\n+    o[0] = o[2];\n+    o[2] = tmp;\n+}\n+\n+static gchar * cropTo(\n+        struct spa_data data,\n+        struct spa_video_info_raw raw,\n+        guint32 x,\n+        guint32 y,\n+        guint32 width,\n+        guint32 height\n+) {\n+    int srcW = raw.size.width;\n+    if (data.chunk->stride \/ 4 != srcW) {\n+        fprintf(stderr, \"%s:%i Unexpected stride \/ 4: %i srcW: %i\\n\",\n+                __func__, __LINE__, data.chunk->stride \/ 4, srcW);\n+    }\n+\n+    int* d = data.data;\n+\n+    int *outData = calloc(width * height, sizeof(int));\n+    if (!outData) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return NULL;\n+    }\n+\n+    gboolean needConversion = raw.format != SPA_VIDEO_FORMAT_BGRx;\n+    for (guint32 j = y; j < y + height; ++j) {\n+        for (guint32 i = x; i < x + width; ++i) {\n+            int color = *(d + (j * srcW) + i);\n+            if (needConversion) {\n+                convertRGBxToBGRx(&color);\n+            }\n+            *(outData + ((j - y) * width) + (i - x)) = color;\n+        }\n+    }\n+\n+    return (gchar*) outData;\n+}\n+\n+static void onStreamParamChanged(\n+        void *userdata,\n+        uint32_t id,\n+        const struct spa_pod *param\n+) {\n+    struct PwStreamData *data = userdata;\n+    uint32_t mediaType;\n+    uint32_t mediaSubtype;\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"param event id %i\\n\", id);\n+\n+    if (param == NULL || id != SPA_PARAM_Format) {\n+        return;\n+    }\n+\n+    if (spa_format_parse(param,\n+                         &mediaType,\n+                         &mediaSubtype) < 0) {\n+        return;\n+    }\n+\n+    if (mediaType != SPA_MEDIA_TYPE_video ||\n+        mediaSubtype != SPA_MEDIA_SUBTYPE_raw) {\n+        return;\n+    }\n+\n+    if (spa_format_video_raw_parse(param, &data->rawFormat) < 0) {\n+        return;\n+    }\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"stream format: %s (%d)\\t%dx%d\\n\",\n+                     spa_debug_type_find_name(\n+                             spa_type_video_format,\n+                             data->rawFormat.format\n+                     ),\n+                     data->rawFormat.format,\n+                     data->rawFormat.size.width,\n+                     data->rawFormat.size.height);\n+\n+    data->hasFormat = TRUE;\n+    fp_pw_thread_loop_signal(pw.loop, TRUE);\n+}\n+\n+static void onStreamProcess(void *userdata) {\n+    struct PwStreamData *data = userdata;\n+\n+    struct ScreenProps *screen = data->screenProps;\n+\n+    DEBUG_SCREEN_PREFIX(screen,\n+                        \"hasFormat %i \"\n+                        \"captureDataReady %i shouldCapture %i\\n\",\n+                        data->hasFormat,\n+                        screen->captureDataReady,\n+                        screen->shouldCapture\n+    );\n+    if (\n+            !data->hasFormat\n+            || !screen->shouldCapture\n+            || screen->captureDataReady\n+    ) {\n+        return;\n+    }\n+\n+    struct pw_buffer *pwBuffer;\n+    struct spa_buffer *spaBuffer;\n+\n+    if (!data->stream\n+        || (pwBuffer = fp_pw_stream_dequeue_buffer(data->stream)) == NULL) {\n+        DEBUG_SCREEN_PREFIX(screen, \"⚠ out of buffers\\n\", NULL);\n+        return;\n+    }\n+\n+    spaBuffer = pwBuffer->buffer;\n+    if (!spaBuffer\n+        || spaBuffer->n_datas < 1\n+        || spaBuffer->datas[0].data == NULL) {\n+        DEBUG_SCREEN_PREFIX(screen, \"⚠ no data, n_datas %d\\n\",\n+                            spaBuffer->n_datas);\n+        return;\n+    }\n+\n+    struct spa_data spaData = spaBuffer->datas[0];\n+\n+    DEBUG_SCREEN(screen);\n+    DEBUG_SCREEN_PREFIX(screen,\n+                        \"got a frame of size %d offset %d stride %d \"\n+                        \"flags %d FD %li captureDataReady %i\\n\",\n+                        spaBuffer->datas[0].chunk->size,\n+                        spaData.chunk->offset,\n+                        spaData.chunk->stride,\n+                        spaData.chunk->flags,\n+                        spaData.fd,\n+                        screen->captureDataReady\n+    );\n+\n+    data->screenProps->captureData = cropTo(\n+            spaData,\n+            data->rawFormat,\n+            screen->captureArea.x, screen->captureArea.y,\n+            screen->captureArea.width, screen->captureArea.height\n+    );\n+\n+    screen->captureDataReady = TRUE;\n+\n+    DEBUG_SCREEN_PREFIX(screen, \"data ready\\n\", NULL);\n+    fp_pw_stream_queue_buffer(data->stream, pwBuffer);\n+}\n+\n+static void onStreamStateChanged(\n+        void *userdata,\n+        enum pw_stream_state old,\n+        enum pw_stream_state state,\n+        const char *error\n+) {\n+    struct PwStreamData *data = userdata;\n+    DEBUG_SCREEN_PREFIX(data->screenProps, \"state %i (%s) -> %i (%s) err %s\\n\",\n+                     old, fp_pw_stream_state_as_string(old),\n+                     state, fp_pw_stream_state_as_string(state),\n+                     error);\n+}\n+\n+static const struct pw_stream_events streamEvents = {\n+        PW_VERSION_STREAM_EVENTS,\n+        .param_changed = onStreamParamChanged,\n+        .process = onStreamProcess,\n+        .state_changed = onStreamStateChanged,\n+};\n+\n+\n+static bool startStream(\n+        struct pw_stream *stream,\n+        uint32_t node\n+) {\n+    char buffer[1024];\n+    struct spa_pod_builder builder =\n+            SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));\n+    const struct spa_pod *param;\n+\n+\n+    param = spa_pod_builder_add_object(\n+            &builder,\n+            SPA_TYPE_OBJECT_Format,\n+            SPA_PARAM_EnumFormat,\n+            SPA_FORMAT_mediaType,\n+            SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,\n+            SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),\n+            SPA_FORMAT_VIDEO_format,\n+            SPA_POD_CHOICE_ENUM_Id(\n+                    2,\n+                    SPA_VIDEO_FORMAT_RGBx,\n+                    SPA_VIDEO_FORMAT_BGRx\n+            ),\n+            SPA_FORMAT_VIDEO_size,\n+            SPA_POD_CHOICE_RANGE_Rectangle(\n+                    &SPA_RECTANGLE(320, 240),\n+                    &SPA_RECTANGLE(1, 1),\n+                    &SPA_RECTANGLE(8192, 8192)\n+            ),\n+            SPA_FORMAT_VIDEO_framerate,\n+            SPA_POD_CHOICE_RANGE_Fraction(\n+                    &SPA_FRACTION(25, 1),\n+                    &SPA_FRACTION(0, 1),\n+                    &SPA_FRACTION(1000, 1)\n+            )\n+    );\n+\n+    DEBUG_SCREENCAST(\"screenId#%i: stream connecting %p\\n\", node, stream);\n+\n+    return fp_pw_stream_connect(\n+            stream,\n+            PW_DIRECTION_INPUT,\n+            node,\n+            PW_STREAM_FLAG_AUTOCONNECT\n+            | PW_STREAM_FLAG_MAP_BUFFERS,\n+            &param,\n+            1\n+    ) >= 0;\n+}\n+\n+\/**\n+ * @param index of a screen\n+ * @return TRUE on success\n+ *\/\n+static gboolean connectStream(int index) {\n+    DEBUG_SCREENCAST(\"@@@ using screen %i\\n\", index);\n+    if (index >= screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"⚠ Wrong index for screen\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    struct PwStreamData *data = screenSpace.screens[index].data;\n+\n+    data->screenProps = &screenSpace.screens[index];\n+\n+    data->hasFormat = FALSE;\n+\n+\n+    data->stream = fp_pw_stream_new(\n+            pw.core,\n+            \"AWT Screen Stream\",\n+            fp_pw_properties_new(\n+                    PW_KEY_MEDIA_TYPE, \"Video\",\n+                    PW_KEY_MEDIA_CATEGORY, \"Capture\",\n+                    PW_KEY_MEDIA_ROLE, \"Screen\",\n+                    NULL\n+            )\n+    );\n+\n+    if (!data->stream) {\n+        DEBUG_SCREEN_PREFIX(data->screenProps,\n+                            \"⚠ Could not create a pipewire stream\\n\", NULL);\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        return FALSE;\n+    }\n+\n+    fp_pw_stream_add_listener(\n+            data->stream,\n+            &data->streamListener,\n+            &streamEvents,\n+            data\n+    );\n+\n+    DEBUG_SCREEN(data->screenProps);\n+\n+    if (!startStream(data->stream, screenSpace.screens[index].id)){\n+        DEBUG_SCREEN_PREFIX(data->screenProps,\n+                            \"⚠ Could not start a pipewire stream\\n\", NULL);\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        return FALSE;\n+    }\n+\n+    while (!data->hasFormat) {\n+        fp_pw_thread_loop_wait(pw.loop);\n+    }\n+\n+    DEBUG_SCREEN_PREFIX(data->screenProps,\n+            \"frame size: %dx%d\\n\",\n+            data->rawFormat.size.width, data->rawFormat.size.height\n+    );\n+\n+    fp_pw_thread_loop_accept(pw.loop);\n+\n+    return TRUE;\n+}\n+\n+\/**\n+ * @return TRUE if requested screenshot area intersects with a screen\n+ *\/\n+static gboolean checkScreen(int index, GdkRectangle requestedArea) {\n+    if (index >= screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"⚠ Wrong index for screen %i >= %i\\n\",\n+                         index, screenSpace.screenCount);\n+        return FALSE;\n+    }\n+\n+    struct ScreenProps * screen = &screenSpace.screens[index];\n+\n+    int x1 = MAX(requestedArea.x, screen->bounds.x);\n+    int y1 = MAX(requestedArea.y, screen->bounds.y);\n+\n+    int x2 = MIN(\n+            requestedArea.x + requestedArea.width,\n+            screen->bounds.x + screen->bounds.width\n+    );\n+    int y2 = MIN(\n+            requestedArea.y + requestedArea.height,\n+            screen->bounds.y + screen->bounds.height\n+    );\n+\n+    screen->shouldCapture = x2 > x1 && y2 > y1;\n+\n+    if (screen->shouldCapture) {  \/\/intersects\n+        \/\/in screen coords:\n+        GdkRectangle * captureArea = &(screen->captureArea);\n+\n+        captureArea->x = x1 - screen->bounds.x;\n+        captureArea->y = y1 - screen->bounds.y;\n+        captureArea->width = x2 - x1;\n+        captureArea->height = y2 - y1;\n+\n+        screen->captureArea.x = x1 - screen->bounds.x;\n+    }\n+\n+    DEBUG_SCREEN(screen);\n+    return screen->shouldCapture;\n+}\n+\n+\n+static void onCoreError(\n+        void *data,\n+        uint32_t id,\n+        int seq,\n+        int res,\n+        const char *message\n+) {\n+    DEBUG_SCREENCAST(\n+            \"⚠ pipewire error: id %u, seq: %d, res: %d (%s): %s\\n\",\n+            id, seq, res, strerror(res), message\n+    );\n+    fp_pw_thread_loop_unlock(pw.loop);\n+}\n+\n+static const struct pw_core_events coreEvents = {\n+        PW_VERSION_CORE_EVENTS,\n+        .error = onCoreError,\n+};\n+\n+\/**\n+ *\n+ * @param requestedArea requested screenshot area\n+ * @return TRUE on success\n+ *\/\n+static gboolean doLoop(GdkRectangle requestedArea) {\n+    pw.loop = fp_pw_thread_loop_new(\"AWT Pipewire Thread\", NULL);\n+\n+    if (!pw.loop) {\n+        DEBUG_SCREENCAST(\"⚠ Could not create a loop\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    pw.context = fp_pw_context_new(\n+            fp_pw_thread_loop_get_loop(pw.loop),\n+            NULL,\n+            0\n+    );\n+\n+    if (!pw.context) {\n+        DEBUG_SCREENCAST(\"⚠ Could not create a pipewire context\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    if (fp_pw_thread_loop_start(pw.loop) != 0) {\n+        DEBUG_SCREENCAST(\"⚠ Could not start pipewire thread loop\\n\", NULL);\n+        doCleanup();\n+        return FALSE;\n+    }\n+\n+    fp_pw_thread_loop_lock(pw.loop);\n+\n+    pw.core = fp_pw_context_connect_fd(\n+            pw.context,\n+            pw.pwFd,\n+            NULL,\n+            0\n+    );\n+\n+    if (!pw.core) {\n+        DEBUG_SCREENCAST(\"⚠ Could not create pipewire core\\n\", NULL);\n+        goto fail;\n+    }\n+\n+    pw_core_add_listener(pw.core, &pw.coreListener, &coreEvents, NULL);\n+\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct PwStreamData *data =\n+                (struct PwStreamData*) malloc(sizeof (struct PwStreamData));\n+        if (!data) {\n+            ERR(\"failed to allocate memory\\n\");\n+            goto fail;\n+        }\n+\n+        memset(data, 0, sizeof (struct PwStreamData));\n+\n+        struct ScreenProps *screen = &screenSpace.screens[i];\n+        screen->data = data;\n+\n+        DEBUG_SCREEN_PREFIX(screen, \"@@@ adding screen %i\\n\", i);\n+        if (checkScreen(i, requestedArea)) {\n+            if (!connectStream(i)){\n+                goto fail;\n+            }\n+        }\n+        DEBUG_SCREEN_PREFIX(screen, \"@@@ screen processed %i\\n\", i);\n+    }\n+\n+    fp_pw_thread_loop_unlock(pw.loop);\n+\n+    return TRUE;\n+\n+    fail:\n+        fp_pw_thread_loop_unlock(pw.loop);\n+        doCleanup();\n+        return FALSE;\n+}\n+\n+static gboolean isAllDataReady() {\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        if (!screenSpace.screens[i].shouldCapture) {\n+            continue;\n+        }\n+        if (!screenSpace.screens[i].captureDataReady ) {\n+            return FALSE;\n+        }\n+    }\n+    return TRUE;\n+}\n+\n+\n+static void *pipewire_libhandle = NULL;\n+\/\/glib_version_2_68 false for gtk2, as it comes from gtk3_interface.c\n+\n+extern gboolean glib_version_2_68;\n+\n+#define LOAD_SYMBOL(fp_name, name) do {                             \\\n+    (fp_name) = dlsym(pipewire_libhandle, name);                    \\\n+    if (!(fp_name)) {                                               \\\n+       debug_screencast(\"⚠ %s:%i error loading dl_symbol %s\\n\",     \\\n+                        __func__, __LINE__, name);                  \\\n+       goto fail;                                                   \\\n+    }                                                               \\\n+} while(0);\n+\n+static gboolean loadSymbols() {\n+    if (!glib_version_2_68) {\n+        DEBUG_SCREENCAST(\"glib version 2.68+ required\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    pipewire_libhandle = dlopen(VERSIONED_JNI_LIB_NAME(\"pipewire-0.3\", \"0\"),\n+            RTLD_LAZY | RTLD_LOCAL);\n+\n+    if (!pipewire_libhandle) {\n+        DEBUG_SCREENCAST(\"could not load pipewire library\\n\", NULL);\n+        return FALSE;\n+    }\n+\n+    LOAD_SYMBOL(fp_pw_stream_dequeue_buffer, \"pw_stream_dequeue_buffer\");\n+    LOAD_SYMBOL(fp_pw_stream_state_as_string, \"pw_stream_state_as_string\");\n+    LOAD_SYMBOL(fp_pw_stream_queue_buffer, \"pw_stream_queue_buffer\");\n+    LOAD_SYMBOL(fp_pw_stream_set_active, \"pw_stream_set_active\");\n+    LOAD_SYMBOL(fp_pw_stream_connect, \"pw_stream_connect\");\n+    LOAD_SYMBOL(fp_pw_stream_new, \"pw_stream_new\");\n+    LOAD_SYMBOL(fp_pw_stream_add_listener, \"pw_stream_add_listener\");\n+    LOAD_SYMBOL(fp_pw_stream_disconnect, \"pw_stream_disconnect\");\n+    LOAD_SYMBOL(fp_pw_stream_destroy, \"pw_stream_destroy\");\n+    LOAD_SYMBOL(fp_pw_init, \"pw_init\");\n+    LOAD_SYMBOL(fp_pw_context_connect_fd, \"pw_context_connect_fd\");\n+    LOAD_SYMBOL(fp_pw_core_disconnect, \"pw_core_disconnect\");\n+    LOAD_SYMBOL(fp_pw_context_new, \"pw_context_new\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_new, \"pw_thread_loop_new\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_get_loop, \"pw_thread_loop_get_loop\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_signal, \"pw_thread_loop_signal\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_wait, \"pw_thread_loop_wait\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_accept, \"pw_thread_loop_accept\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_start, \"pw_thread_loop_start\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_stop, \"pw_thread_loop_stop\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_destroy, \"pw_thread_loop_destroy\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_lock, \"pw_thread_loop_lock\");\n+    LOAD_SYMBOL(fp_pw_thread_loop_unlock, \"pw_thread_loop_unlock\");\n+    LOAD_SYMBOL(fp_pw_properties_new, \"pw_properties_new\");\n+\n+    return TRUE;\n+\n+    fail:\n+        dlclose(pipewire_libhandle);\n+        pipewire_libhandle = NULL;\n+    return FALSE;\n+}\n+\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken) {\n+\n+    JNIEnv* env = (JNIEnv *) JNU_GetEnv(jvm, JNI_VERSION_1_2);\n+    DEBUG_SCREENCAST(\"saving token, old: |%s| > new: |%s|\\n\", oldToken, newToken);\n+    if (env) {\n+        jstring jOldToken = NULL;\n+        if (oldToken) {\n+            jOldToken = (*env)->NewStringUTF(env, oldToken);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!jOldToken) {\n+                return;\n+            }\n+        }\n+        jstring jNewToken = (*env)->NewStringUTF(env, newToken);\n+        EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+        if (!jNewToken) {\n+            (*env)->DeleteLocalRef(env, jOldToken);\n+            return;\n+        }\n+\n+        jintArray allowedBounds = NULL;\n+        if (screenSpace.screenCount > 0) {\n+            allowedBounds = (*env)->NewIntArray(env, screenSpace.screenCount*4);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!allowedBounds) {\n+                (*env)->ExceptionClear(env);\n+                return;\n+            }\n+            jint* elements = (*env)->GetIntArrayElements(env, allowedBounds, NULL);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            if (!elements) {\n+                return;\n+            }\n+\n+            gboolean failed = false;\n+\n+            for (int i = 0; i < screenSpace.screenCount; ++i) {\n+                GdkRectangle bounds = screenSpace.screens[i].bounds;\n+                elements[4 * i] = bounds.x;\n+                elements[4 * i + 1] = bounds.y;\n+                elements[4 * i + 2] = bounds.width;\n+                elements[4 * i + 3] = bounds.height;\n+\n+                if ((*env)->ExceptionCheck(env)) {\n+                    (*env)->ExceptionDescribe(env);\n+                    (*env)->ExceptionClear(env);\n+                    failed = true;\n+                    break;\n+                }\n+            }\n+\n+            (*env)->ReleaseIntArrayElements(env, allowedBounds, elements, 0);\n+            EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+\n+            if (!failed) {\n+                (*env)->CallStaticVoidMethod(env, tokenStorageClass,\n+                                             storeTokenMethodID,\n+                                             jOldToken, jNewToken,\n+                                             allowedBounds);\n+                EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+            }\n+        }\n+        (*env)->DeleteLocalRef(env, jOldToken);\n+        (*env)->DeleteLocalRef(env, jNewToken);\n+    } else {\n+        DEBUG_SCREENCAST(\"⚠ Could not get env\\n\", NULL);\n+    }\n+}\n+\n+\/*\n+ * Class:     sun_awt_UNIXToolkit\n+ * Method:    load_gtk\n+ * Signature: (IZ)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_sun_awt_screencast_ScreencastHelper_loadPipewire(\n+        JNIEnv *env, jclass cls, jboolean screencastDebug\n+) {\n+    DEBUG_SCREENCAST_ENABLED = screencastDebug;\n+\n+    if (!loadSymbols()) {\n+        return JNI_FALSE;\n+    }\n+\n+    tokenStorageClass = (*env)->FindClass(env, \"sun\/awt\/screencast\/TokenStorage\");\n+    if (!tokenStorageClass) {\n+        return JNI_FALSE;\n+    }\n+\n+    tokenStorageClass = (*env)->NewGlobalRef(env, tokenStorageClass);\n+\n+    if (tokenStorageClass) {\n+        storeTokenMethodID = (*env)->GetStaticMethodID(\n+                env,\n+                tokenStorageClass,\n+                \"storeTokenFromNative\",\n+                \"(Ljava\/lang\/String;Ljava\/lang\/String;[I)V\"\n+                );\n+        if (!storeTokenMethodID) {\n+            return JNI_FALSE;\n+        }\n+    } else {\n+        DEBUG_SCREENCAST(\"⚠ @@@ tokenStorageClass %p\\n\",\n+                         tokenStorageClass);\n+        return JNI_FALSE;\n+    }\n+\n+    gboolean usable = initXdgDesktopPortal();\n+    portalScreenCastCleanup();\n+    return usable;\n+}\n+\n+static void releaseToken(JNIEnv *env, jstring jtoken, const gchar *token) {\n+    if (token) {\n+        (*env)->ReleaseStringUTFChars(env, jtoken, token);\n+    }\n+}\n+\n+static void arrayToRectangles(JNIEnv *env,\n+                             jintArray boundsArray,\n+                             jint boundsLen,\n+                             GdkRectangle *out\n+) {\n+    if (!boundsArray) {\n+        return;\n+    }\n+\n+    jint * body = (*env)->GetIntArrayElements(env, boundsArray, 0);\n+    EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+    if (!body) {\n+        return;\n+    }\n+\n+    for (int i = 0; i < boundsLen; i += 4) {\n+        GdkRectangle screenBounds = {\n+                body[i], body[i + 1],\n+                body[i + 2], body[i + 3]\n+        };\n+        out[i \/ 4] = screenBounds;\n+    }\n+\n+    (*env)->ReleaseIntArrayElements(env, boundsArray, body, 0);\n+}\n+\n+\/*\n+ * Class:     sun_awt_screencast_ScreencastHelper\n+ * Method:    getRGBPixelsImpl\n+ * Signature: (IIII[I[ILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_sun_awt_screencast_ScreencastHelper_getRGBPixelsImpl(\n+        JNIEnv *env,\n+        jclass cls,\n+        jint jx,\n+        jint jy,\n+        jint jwidth,\n+        jint jheight,\n+        jintArray pixelArray,\n+        jintArray affectedScreensBoundsArray,\n+        jstring jtoken\n+) {\n+    jsize boundsLen = 0;\n+    gint affectedBoundsLength = 0;\n+    if (affectedScreensBoundsArray) {\n+        boundsLen = (*env)->GetArrayLength(env, affectedScreensBoundsArray);\n+        EXCEPTION_CHECK_DESCRIBE_CLEAR();\n+        if (boundsLen % 4 != 0) {\n+            DEBUG_SCREENCAST(\"%s:%i incorrect array length\\n\", __FUNCTION__, __LINE__);\n+            return -1;\n+        }\n+        affectedBoundsLength = boundsLen \/ 4;\n+    }\n+\n+    GdkRectangle affectedScreenBounds[affectedBoundsLength];\n+    arrayToRectangles(env,\n+                     affectedScreensBoundsArray,\n+                     boundsLen,\n+                     (GdkRectangle *) &affectedScreenBounds);\n+\n+    GdkRectangle requestedArea = { jx, jy, jwidth, jheight};\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+\n+    DEBUG_SCREENCAST(\n+            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i with token |%s|\\n\",\n+            jx, jy, jwidth, jheight, token\n+    );\n+\n+    if (!initScreencast(token, affectedScreenBounds, affectedBoundsLength)) {\n+        releaseToken(env, jtoken, token);\n+        if (pw.pwFd == START_DENIED) {\n+            return START_DENIED;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    if (!doLoop(requestedArea)) {\n+        releaseToken(env, jtoken, token);\n+        return -1;\n+    }\n+\n+    while (!isAllDataReady()) {\n+        fp_pw_thread_loop_wait(pw.loop);\n+    }\n+\n+    DEBUG_SCREENCAST(\"\\nall data ready\\n\", NULL);\n+\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct ScreenProps * screenProps = &screenSpace.screens[i];\n+\n+        if (screenProps->shouldCapture) {\n+            GdkRectangle bounds = screenProps->bounds;\n+            GdkRectangle captureArea  = screenProps->captureArea;\n+            DEBUG_SCREEN_PREFIX(screenProps,\n+                                \"@@@ copying screen data %i, captureData %p\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\"\n+                                \"\\t||\\tx %5i y %5i w %5i h %5i %s\\n\\n\",\n+                                i, screenProps->captureData,\n+                                requestedArea.x, requestedArea.y,\n+                                requestedArea.width, requestedArea.height,\n+                                \"requested area\",\n+\n+                                bounds.x, bounds.y,\n+                                bounds.width, bounds.height,\n+                                \"screen bound\",\n+\n+                                captureArea.x, captureArea.y,\n+                                captureArea.width, captureArea.height,\n+                                \"in-screen coords capture area\"\n+            );\n+\n+            if (screenProps->captureData) {\n+                for (int y = 0; y < captureArea.height; y++) {\n+                    jsize preY = (requestedArea.y > screenProps->bounds.y)\n+                            ? 0\n+                            : screenProps->bounds.y - requestedArea.y;\n+                    jsize preX = (requestedArea.x > screenProps->bounds.x)\n+                            ? 0\n+                            : screenProps->bounds.x - requestedArea.x;\n+                    jsize start = jwidth * (preY + y) + preX;\n+\n+                    jsize len = captureArea.width;\n+\n+                    (*env)->SetIntArrayRegion(\n+                            env, pixelArray,\n+                            start, len,\n+                            ((jint *) screenProps->captureData)\n+                                + (captureArea.width * y)\n+                    );\n+                }\n+            }\n+\n+            free(screenProps->captureData);\n+            screenProps->captureData = NULL;\n+            screenProps->shouldCapture = FALSE;\n+\n+            fp_pw_stream_set_active(screenProps->data->stream, FALSE);\n+            fp_pw_stream_disconnect(screenProps->data->stream);\n+        }\n+    }\n+    doCleanup();\n+    releaseToken(env, jtoken, token);\n+    return 0;\n+}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":915,"deletions":0,"binary":false,"changes":915,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+\n+#ifndef _SCREENCAST_PIPEWIRE_H\n+#define _SCREENCAST_PIPEWIRE_H\n+\n+#include \"screencast_portal.h\"\n+\n+#include <pipewire\/stream.h>\n+#include <pipewire\/keys.h>\n+\n+#include <spa\/param\/video\/format-utils.h>\n+#include <spa\/debug\/types.h>\n+\n+void storeRestoreToken(const gchar* oldToken, const gchar* newToken);\n+\n+struct ScreenProps {\n+    guint32 id;\n+    GdkRectangle bounds;\n+\n+    GdkRectangle captureArea;\n+    struct PwStreamData *data;\n+\n+    gchar *captureData;\n+    volatile gboolean shouldCapture;\n+    volatile gboolean captureDataReady;\n+};\n+\n+\n+#define SCREEN_SPACE_DEFAULT_ALLOCATED 2\n+struct ScreenSpace {\n+    struct ScreenProps *screens;\n+    int screenCount;\n+    int allocated;\n+};\n+\n+#define DEBUG_SCREENCAST(FORMAT, ...) debug_screencast(\"%s:%i \" FORMAT, \\\n+                                        __func__, __LINE__, __VA_ARGS__);\n+\n+#define DEBUG_SCREEN(SCREEN)                                            \\\n+    DEBUG_SCREENCAST(\"screenId#%i\\n\"                                    \\\n+    \"||\\tbounds         x %5i y %5i w %5i h %5i\\n\"                      \\\n+    \"||\\tcapture area   x %5i y %5i w %5i h %5i shouldCapture %i\\n\\n\",  \\\n+    (SCREEN)->id,                                                       \\\n+    (SCREEN)->bounds.x,          (SCREEN)->bounds.y,                    \\\n+    (SCREEN)->bounds.width,      (SCREEN)->bounds.height,               \\\n+    (SCREEN)->captureArea.x,     (SCREEN)->captureArea.y,               \\\n+    (SCREEN)->captureArea.width, (SCREEN)->captureArea.height,          \\\n+    (SCREEN)->shouldCapture);\n+\n+#define DEBUG_SCREEN_PREFIX(SCREEN, FORMAT, ...)                        \\\n+    DEBUG_SCREENCAST(\"screenId#%i[loc(%d,%d) size(%dx%d)] \"FORMAT,      \\\n+    (SCREEN)->id, (SCREEN)->bounds.x, (SCREEN)->bounds.y,               \\\n+    (SCREEN)->bounds.width, (SCREEN)->bounds.height, __VA_ARGS__);\n+\n+#define ERR(MSG) fprintf(stderr, \"%s:%i \" MSG, __func__, __LINE__);\n+#define ERR_HANDLE(ERROR) errHandle((ERROR), __func__, __LINE__);\n+\n+struct PwLoopData {\n+    struct pw_thread_loop *loop;\n+    struct pw_context *context;\n+    struct pw_core *core;\n+    struct spa_hook coreListener;\n+    int pwFd; \/\/negative values can also be used to store a failure reason\n+};\n+\n+struct PwStreamData {\n+    struct pw_stream *stream;\n+    struct spa_hook streamListener;\n+\n+    struct spa_video_info_raw rawFormat;\n+    struct ScreenProps *screenProps;\n+\n+    gboolean hasFormat;\n+};\n+\n+#endif \/\/_SCREENCAST_PIPEWIRE_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,909 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"stdlib.h\"\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <string.h>\n+#include <pwd.h>\n+#include <unistd.h>\n+#include \"screencast_pipewire.h\"\n+#include \"screencast_portal.h\"\n+\n+\n+extern struct ScreenSpace screenSpace;\n+\n+struct XdgDesktopPortalApi *portal = NULL;\n+\n+void errHandle(\n+        GError *error,\n+        const gchar *functionName,\n+        int lineNum\n+) {\n+    if (error) {\n+        fprintf(stderr, \"⚠ %s:%i Error: domain %i code %i message: \\\"%s\\\"\\n\",\n+                functionName, lineNum,\n+                error->domain, error->code, error->message);\n+    }\n+    if (error) {\n+        gtk->g_error_free(error);\n+    }\n+    error = NULL;\n+}\n+\n+gboolean validateToken(const gchar *token) {\n+    if (!token) {\n+        return FALSE;\n+    }\n+\n+    gboolean isValid = gtk->g_uuid_string_is_valid(token);\n+    if (!isValid) {\n+        DEBUG_SCREENCAST(\"⚠ restore token \"\n+                         \"is not a valid UUID string:\\n\\\"%s\\\"\\n\",\n+                         token);\n+    }\n+    return isValid;\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+gboolean rebuildScreenData(GVariantIter *iterStreams, gboolean isTheOnlyMon) {\n+    guint32 nodeID;\n+    GVariant* prop = NULL;\n+\n+    int screenIndex = 0;\n+\n+    gboolean hasFailures = FALSE;\n+\n+    while (gtk->g_variant_iter_loop(\n+            iterStreams,\n+            \"(u@a{sv})\",\n+            &nodeID,\n+            &prop\n+    )) {\n+        DEBUG_SCREENCAST(\"\\n==== screenId#%i\\n\", nodeID);\n+\n+        if (screenIndex >= screenSpace.allocated) {\n+            screenSpace.screens = realloc(\n+                    screenSpace.screens,\n+                    ++screenSpace.allocated * sizeof(struct ScreenProps)\n+            );\n+            if (!screenSpace.screens) {\n+                ERR(\"failed to allocate memory\\n\");\n+                return FALSE;\n+            }\n+        }\n+\n+        struct ScreenProps * screen = &screenSpace.screens[screenIndex];\n+        memset(screen, 0, sizeof(struct ScreenProps));\n+\n+        screenSpace.screenCount = screenIndex + 1;\n+\n+        screen->id = nodeID;\n+\n+        if (\n+                !gtk->g_variant_lookup(\n+                        prop,\n+                        \"size\",\n+                        \"(ii)\",\n+                        &screen->bounds.width,\n+                        &screen->bounds.height\n+                )\n+                || (\n+                        !gtk->g_variant_lookup(\n+                                prop,\n+                                \"position\",\n+                                \"(ii)\",\n+                                &screen->bounds.x,\n+                                &screen->bounds.y\n+                        )\n+                        \/\/Screen position is not specified in some cases\n+                        \/\/(e.g. on Plasma).\n+                        \/\/In this case, proceed only if there is only one screen.\n+                        && !isTheOnlyMon\n+                )\n+                ) {\n+            hasFailures = TRUE;\n+        }\n+\n+        DEBUG_SCREENCAST(\"-----------------------\\n\", NULL);\n+        DEBUG_SCREEN(screen);\n+        DEBUG_SCREENCAST(\"#---------------------#\\n\\n\", NULL);\n+\n+        gtk->g_variant_unref(prop);\n+        screenIndex++;\n+    };\n+\n+    if (hasFailures) {\n+        DEBUG_SCREENCAST(\"screenId#%i hasFailures\\n\", nodeID);\n+    }\n+\n+    return !hasFailures;\n+}\n+\n+\/**\n+ * Checks screencast protocol version\n+ * @return FALSE if version < 4, or could not be determined\n+ *\/\n+gboolean checkVersion() {\n+    static guint32 version = 0;\n+    if (version == 0) {\n+        GError *error = NULL;\n+        GVariant *retVersion = gtk->g_dbus_proxy_call_sync(\n+                portal->screenCastProxy,\n+                \"org.freedesktop.DBus.Properties.Get\",\n+                gtk->g_variant_new(\"(ss)\",\n+                                   \"org.freedesktop.portal.ScreenCast\",\n+                                   \"version\"),\n+                G_DBUS_CALL_FLAGS_NONE,\n+                -1, NULL, NULL\n+        );\n+\n+        if (!retVersion) { \/\/no backend on system\n+            DEBUG_SCREENCAST(\"⚠ could not detect the screencast version\\n\",\n+                             NULL);\n+            return FALSE;\n+        }\n+\n+        ERR_HANDLE(error);\n+\n+        GVariant *varVersion = NULL;\n+        gtk->g_variant_get(retVersion, \"(v)\", &varVersion);\n+\n+        if (!varVersion){\n+            gtk->g_variant_unref(retVersion);\n+            DEBUG_SCREENCAST(\"⚠ could not get the screencast version\\n\",\n+                             NULL);\n+            return FALSE;\n+        }\n+\n+        version = gtk->g_variant_get_uint32(varVersion);\n+\n+        gtk->g_variant_unref(varVersion);\n+        gtk->g_variant_unref(retVersion);\n+\n+    }\n+\n+    DEBUG_SCREENCAST(\"ScreenCast protocol version %d\\n\", version);\n+    if (version < 4) {\n+        DEBUG_SCREENCAST(\"⚠ ScreenCast protocol version %d < 4,\"\n+                         \" session restore is not available\\n\",\n+                         version);\n+    }\n+\n+    \/\/ restore_token was added in version 4, without it,\n+    \/\/ user confirmation is required for every screenshot.\n+    return version >= 4;\n+}\n+\n+\/**\n+ * @return TRUE on success\n+ *\/\n+gboolean initXdgDesktopPortal() {\n+    portal = calloc(1, sizeof(*portal));\n+\n+    if (!portal) {\n+        ERR(\"failed to allocate memory\\n\");\n+        return FALSE;\n+    }\n+\n+    GError* err = NULL;\n+\n+    portal->connection = gtk->g_bus_get_sync(G_BUS_TYPE_SESSION, NULL, &err);\n+\n+    if (err) {\n+        ERR_HANDLE(err);\n+        return FALSE;\n+    }\n+\n+    const gchar *name = gtk\n+            ->g_dbus_connection_get_unique_name(portal->connection);\n+    if (!name) {\n+        ERR(\"Failed to get unique connection name\\n\");\n+        return FALSE;\n+    }\n+\n+    GString * nameStr = gtk->g_string_new(name);\n+    gtk->g_string_erase(nameStr, 0, 1); \/\/remove leading colon \":\"\n+    gtk->g_string_replace(nameStr, \".\", \"_\", 0);\n+    portal->senderName = nameStr->str;\n+\n+    gtk->g_string_free(nameStr, FALSE);\n+\n+    DEBUG_SCREENCAST(\"connection\/sender name %s \/ %s\\n\",\n+                     name,\n+                     portal->senderName);\n+\n+    portal->screenCastProxy = gtk->g_dbus_proxy_new_sync(\n+            portal->connection,\n+            G_DBUS_PROXY_FLAGS_NONE,\n+            NULL,\n+            \"org.freedesktop.portal.Desktop\",\n+            \"\/org\/freedesktop\/portal\/desktop\",\n+            \"org.freedesktop.portal.ScreenCast\",\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get ScreenCast portal: %s\", err->message);\n+        ERR_HANDLE(err);\n+        return FALSE;\n+    }\n+\n+    return checkVersion();\n+}\n+\n+static void updateRequestPath(\n+        gchar **path,\n+        gchar **token\n+) {\n+    static uint64_t counter = 0;\n+    ++counter;\n+\n+    GString *tokenStr = gtk->g_string_new(NULL);\n+    gtk->g_string_printf(\n+            tokenStr,\n+            PORTAL_TOKEN_TEMPLATE,\n+            counter\n+    );\n+\n+    *token = tokenStr->str;\n+    gtk->g_string_free(tokenStr, FALSE);\n+\n+    GString *pathStr = gtk->g_string_new(NULL);\n+\n+    gtk->g_string_printf(\n+            pathStr,\n+            PORTAL_REQUEST_TEMPLATE,\n+            portal->senderName,\n+            counter\n+    );\n+\n+    *path = pathStr->str;\n+    gtk->g_string_free(pathStr, FALSE);\n+}\n+\n+static void updateSessionToken(\n+        gchar **token\n+) {\n+    static uint64_t counter = 0;\n+    counter++;\n+\n+    GString *tokenStr = gtk->g_string_new(NULL);\n+\n+    gtk->g_string_printf(\n+            tokenStr,\n+            PORTAL_TOKEN_TEMPLATE,\n+            counter\n+    );\n+\n+    *token = tokenStr->str;\n+    gtk->g_string_free(tokenStr, FALSE);\n+}\n+\n+static void registerScreenCastCallback(\n+        const char *path,\n+        struct DBusCallbackHelper *helper,\n+        GDBusSignalCallback callback\n+) {\n+    helper->id = gtk->g_dbus_connection_signal_subscribe(\n+            portal->connection,\n+            \"org.freedesktop.portal.Desktop\",\n+            \"org.freedesktop.portal.Request\",\n+            \"Response\",\n+            path,\n+            NULL,\n+            G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE,\n+            callback,\n+            helper,\n+            NULL\n+    );\n+}\n+\n+static void unregisterScreenCastCallback(\n+        struct DBusCallbackHelper *helper\n+) {\n+    if (helper->id) {\n+        gtk->g_dbus_connection_signal_unsubscribe(\n+                portal->connection,\n+                helper->id\n+        );\n+    }\n+}\n+\n+static void callbackScreenCastCreateSession(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+    uint32_t status;\n+    GVariant *result = NULL;\n+\n+    gtk->g_variant_get(\n+            parameters,\n+            \"(u@a{sv})\",\n+            &status,\n+            &result\n+    );\n+\n+    if (status != 0) {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast: %u\\n\", status);\n+    } else {\n+        gtk->g_variant_lookup(result, \"session_handle\", \"s\", helper->data);\n+    }\n+\n+    helper->isDone = TRUE;\n+}\n+\n+gboolean portalScreenCastCreateSession() {\n+    GError *err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+    gchar *sessionToken = NULL;\n+\n+    struct DBusCallbackHelper helper = {\n+            .id = 0,\n+            .data = &portal->screenCastSessionHandle\n+    };\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+    updateSessionToken(&sessionToken);\n+\n+    portal->screenCastSessionHandle = NULL;\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastCreateSession\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"session_handle_token\",\n+            gtk->g_variant_new_string(sessionToken)\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"CreateSession\",\n+            gtk->g_variant_new(\"(a{sv})\", &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast session: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(sessionToken);\n+    free(requestPath);\n+    free(requestToken);\n+\n+    return portal->screenCastSessionHandle != NULL;\n+}\n+\n+static void callbackScreenCastSelectSources(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+\n+    helper->data = (void *) 0;\n+\n+    uint32_t status;\n+    GVariant* result = NULL;\n+\n+    gtk->g_variant_get(parameters, \"(u@a{sv})\", &status, &result);\n+\n+    if (status != 0) {\n+        DEBUG_SCREENCAST(\"Failed select sources: %u\\n\", status);\n+    } else {\n+        helper->data = (void *) 1;\n+    }\n+\n+    helper->isDone = TRUE;\n+\n+    if (result) {\n+        gtk->g_variant_unref(result);\n+    }\n+}\n+\n+gboolean portalScreenCastSelectSources(const gchar *token) {\n+    GError* err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+\n+    struct DBusCallbackHelper helper = {0};\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastSelectSources\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\", \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\", \"multiple\",\n+            gtk->g_variant_new_boolean(TRUE));\n+\n+    \/\/ 1: MONITOR\n+    \/\/ 2: WINDOW\n+    \/\/ 4: VIRTUAL\n+    gtk->g_variant_builder_add(\n+            &builder, \"{sv}\", \"types\",\n+            gtk->g_variant_new_uint32(1)\n+    );\n+\n+    \/\/ 0: Do not persist (default)\n+    \/\/ 1: Permissions persist as long as the application is running\n+    \/\/ 2: Permissions persist until explicitly revoked\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"persist_mode\",\n+            gtk->g_variant_new_uint32(2)\n+    );\n+\n+    if (validateToken(token)) {\n+        gtk->g_variant_builder_add(\n+                &builder,\n+                \"{sv}\",\n+                \"restore_token\",\n+                gtk->g_variant_new_string(token)\n+        );\n+    }\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"SelectSources\",\n+            gtk->g_variant_new(\"(oa{sv})\", portal->screenCastSessionHandle, &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to call SelectSources: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(requestPath);\n+    free(requestToken);\n+\n+    return helper.data != NULL;\n+}\n+\n+static void callbackScreenCastStart(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+    struct StartHelper *startHelper = helper->data;\n+\n+    uint32_t status;\n+    GVariant* result = NULL;\n+    const gchar *oldToken = startHelper->token;\n+\n+    gtk->g_variant_get(parameters, \"(u@a{sv})\", &status, &result);\n+\n+    if (status != 0) {\n+        \/\/ Cancel pressed on the system dialog\n+        DEBUG_SCREENCAST(\"Failed to start screencast: %u\\n\", status);\n+        startHelper->result = START_DENIED;\n+        helper->isDone = TRUE;\n+        return;\n+    }\n+\n+    GVariant *streams = gtk->g_variant_lookup_value(\n+            result,\n+            \"streams\",\n+            G_VARIANT_TYPE_ARRAY\n+    );\n+\n+    GVariantIter iter;\n+    gtk->g_variant_iter_init(\n+            &iter,\n+            streams\n+    );\n+\n+    size_t count = gtk->g_variant_iter_n_children(&iter);\n+\n+    DEBUG_SCREENCAST(\"available screen count %i\\n\", count);\n+\n+    startHelper->result = (rebuildScreenData(&iter, count == 1))\n+                   ? START_OK\n+                   : -1;\n+\n+    DEBUG_SCREENCAST(\"rebuildScreenData result |%i|\\n\", startHelper->result);\n+\n+    if (startHelper->result == START_OK) {\n+        GVariant *restoreTokenVar = gtk->g_variant_lookup_value(\n+                result,\n+                \"restore_token\",\n+                G_VARIANT_TYPE_STRING\n+        );\n+\n+        if (restoreTokenVar) {\n+            gsize len;\n+            const gchar *newToken = gtk->\n+                    g_variant_get_string(restoreTokenVar, &len);\n+            DEBUG_SCREENCAST(\"restore_token |%s|\\n\", newToken);\n+\n+            storeRestoreToken(oldToken, newToken);\n+\n+            gtk->g_variant_unref(restoreTokenVar);\n+        }\n+    }\n+\n+    helper->isDone = TRUE;\n+\n+    if (streams) {\n+        gtk->g_variant_unref(streams);\n+    }\n+}\n+\n+ScreenCastStartResult portalScreenCastStart(const gchar *token) {\n+    GError *err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+\n+    struct StartHelper startHelper = { 0 };\n+    startHelper.token = token;\n+\n+    struct DBusCallbackHelper helper = { 0 };\n+    helper.data = &startHelper;\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackScreenCastStart\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    gtk->g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"handle_token\",\n+            gtk->g_variant_new_string(requestToken)\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_sync(\n+            portal->screenCastProxy,\n+            \"Start\",\n+            gtk->g_variant_new(\"(osa{sv})\", portal->screenCastSessionHandle, \"\", &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to start session: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        while (!helper.isDone) {\n+            gtk->g_main_context_iteration(NULL, TRUE);\n+        }\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        gtk->g_variant_unref(response);\n+    }\n+\n+    free(requestPath);\n+    free(requestToken);\n+\n+    DEBUG_SCREENCAST(\"ScreenCastStartResult |%i|\\n\", startHelper.result);\n+\n+    return startHelper.result;\n+}\n+\n+int portalScreenCastOpenPipewireRemote() {\n+    GError* err = NULL;\n+    GUnixFDList* fdList = NULL;\n+\n+    GVariantBuilder builder;\n+\n+    gtk->g_variant_builder_init(\n+            &builder, G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    GVariant *response = gtk->g_dbus_proxy_call_with_unix_fd_list_sync(\n+            portal->screenCastProxy,\n+            \"OpenPipeWireRemote\",\n+            gtk->g_variant_new(\"(oa{sv})\", portal->screenCastSessionHandle, &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &fdList,\n+            NULL,\n+            &err\n+    );\n+\n+    if (err || !response) {\n+        DEBUG_SCREENCAST(\"Failed to call OpenPipeWireRemote on session: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+        return -1;\n+    }\n+\n+    gint32 index;\n+    gtk->g_variant_get(\n+            response,\n+            \"(h)\",\n+            &index,\n+            &err\n+    );\n+\n+    gtk->g_variant_unref(response);\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get pipewire fd index: %s\\n\",\n+                         err->message);\n+        ERR_HANDLE(err);\n+        return -1;\n+    }\n+\n+    int fd = gtk->g_unix_fd_list_get(\n+            fdList,\n+            index,\n+            &err\n+    );\n+\n+    if (fdList) {\n+        gtk->g_object_unref(fdList);\n+    }\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to get pipewire fd: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+        return -1;\n+    }\n+\n+    return fd;\n+}\n+\n+void portalScreenCastCleanup() {\n+    if (portal->screenCastSessionHandle) {\n+        gtk->g_dbus_connection_call_sync(\n+                portal->connection,\n+                \"org.freedesktop.portal.Desktop\",\n+                portal->screenCastSessionHandle,\n+                \"org.freedesktop.portal.Session\",\n+                \"Close\",\n+                NULL,\n+                NULL,\n+                G_DBUS_CALL_FLAGS_NONE,\n+                -1,\n+                NULL,\n+                NULL\n+        );\n+\n+        gtk->g_free(portal->screenCastSessionHandle);\n+        portal->screenCastSessionHandle = NULL;\n+    }\n+\n+    if (!portal) {\n+        return;\n+    }\n+    if (portal->connection) {\n+        gtk->g_object_unref(portal->connection);\n+        portal->connection = NULL;\n+    }\n+\n+    if (portal->screenCastProxy) {\n+        gtk->g_object_unref(portal->screenCastProxy);\n+        portal->screenCastProxy = NULL;\n+    }\n+\n+    if (portal->senderName) {\n+        free(portal->senderName);\n+        portal->senderName = NULL;\n+    }\n+\n+    free(portal);\n+    portal = NULL;\n+}\n+\n+gboolean rectanglesEqual(GdkRectangle rect1, GdkRectangle rect2) {\n+    return rect1.x == rect2.x\n+           && rect1.y == rect2.y\n+           && rect1.width == rect2.width\n+           && rect1.height == rect2.height;\n+}\n+\n+gboolean checkCanCaptureAllRequiredScreens(GdkRectangle *affectedBounds,\n+                        gint affectedBoundsLength) {\n+\n+\n+    if (affectedBoundsLength > screenSpace.screenCount) {\n+        DEBUG_SCREENCAST(\"Requested screen count is greater \"\n+                         \"than allowed with token (%i > %i)\\n\",\n+                         affectedBoundsLength, screenSpace.screenCount);\n+        return false;\n+    }\n+\n+\n+    for (int i = 0; i < affectedBoundsLength; ++i) {\n+        gboolean found = false;\n+        GdkRectangle affBounds = affectedBounds[i];\n+        for (int j = 0; j < screenSpace.screenCount; ++j) {\n+            GdkRectangle allowedBounds = screenSpace.screens[j].bounds;\n+\n+            if (rectanglesEqual(allowedBounds, affBounds)) {\n+                DEBUG_SCREENCAST(\"Found allowed screen bounds in affected \"\n+                                 \"screen bounds %i %i %i %i\\n\",\n+                                 affBounds.x, affBounds.y,\n+                                 affBounds.width, affBounds.height);\n+                found = true;\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            DEBUG_SCREENCAST(\"Could not find required screen %i %i %i %i \"\n+                             \"in allowed bounds\\n\",\n+                             affBounds.x, affBounds.y,\n+                             affBounds.width, affBounds.height);\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+\n+\/**\n+ * @return negative values on error,\n+ * -1 for generic error, or enum value of ScreenCastStartResult for specific failure\n+ *\/\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength) {\n+    if (!portalScreenCastCreateSession())  {\n+        DEBUG_SCREENCAST(\"Failed to create ScreenCast session\\n\", NULL);\n+        return -1;\n+    }\n+\n+    if (!portalScreenCastSelectSources(token)) {\n+        DEBUG_SCREENCAST(\"Failed to select sources\\n\", NULL);\n+        return -1;\n+    }\n+\n+    ScreenCastStartResult startResult = portalScreenCastStart(token);\n+    DEBUG_SCREENCAST(\"portalScreenCastStart result |%i|\\n\", startResult);\n+    if (startResult != START_OK) {\n+        DEBUG_SCREENCAST(\"Failed to start\\n\", NULL);\n+        return startResult;\n+    } else {\n+        if (!checkCanCaptureAllRequiredScreens(affectedBounds,\n+                                               affectedBoundsLength)) {\n+            DEBUG_SCREENCAST(\"The location of the screens has changed, \"\n+                             \"the capture area is outside the allowed \"\n+                             \"area.\\n\", NULL)\n+            return START_DENIED;\n+        }\n+    }\n+\n+    DEBUG_SCREENCAST(\"--- portalScreenCastStart\\n\", NULL);\n+\n+    int pipewireFd = portalScreenCastOpenPipewireRemote();\n+    if (pipewireFd < 0) {\n+        DEBUG_SCREENCAST(\"⚠ Failed to get pipewire fd\\n\", NULL);\n+    }\n+\n+    DEBUG_SCREENCAST(\"pwFd %i\\n\", pipewireFd);\n+    return pipewireFd;\n+}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.c","additions":909,"deletions":0,"binary":false,"changes":909,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef HEADLESS\n+#error This file should not be included in headless library\n+#endif\n+\n+#ifndef _SCREENCAST_PORTAL_H\n+#define _SCREENCAST_PORTAL_H\n+\n+#include \"gtk_interface.h\"\n+\n+#define PORTAL_TOKEN_TEMPLATE \"awtPipewire%lu\"\n+#define PORTAL_REQUEST_TEMPLATE \"\/org\/freedesktop\/portal\/desktop\/\" \\\n+                                \"request\/%s\/awtPipewire%lu\"\n+\n+void debug_screencast(const char *__restrict fmt, ...);\n+\n+int getPipewireFd(const gchar *token,\n+                  GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength);\n+\n+void portalScreenCastCleanup();\n+\n+gboolean initXdgDesktopPortal();\n+\n+void errHandle(GError *error, const gchar *functionName, int lineNum);\n+\n+struct XdgDesktopPortalApi {\n+    GDBusConnection *connection;\n+    GDBusProxy *screenCastProxy;\n+    gchar *senderName;\n+    char *screenCastSessionHandle;\n+};\n+\n+struct DBusCallbackHelper {\n+    guint id;\n+    void *data;\n+    gboolean isDone;\n+};\n+\n+typedef enum {\n+    START_OK = 0,\n+    START_DENIED = -11,\n+} ScreenCastStartResult;\n+\n+struct StartHelper {\n+    const gchar *token;\n+    ScreenCastStartResult result;\n+};\n+\n+#endif \/\/_SCREENCAST_PORTAL_H\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_portal.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_CONTEXT_H\n+#define PIPEWIRE_CONTEXT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup pw_context Context\n+ *\n+ * \\brief The PipeWire context object manages all locally available\n+ * resources. It is used by both clients and servers.\n+ *\n+ * The context is used to:\n+ *\n+ *  - Load modules and extend the functionality. This includes\n+ *    extending the protocol with new object types or creating\n+ *    any of the available objects.\n+ *\n+ *  - Create implementations of various objects like nodes,\n+ *    devices, factories, modules, etc.. This will usually also\n+ *    create pw_global objects that can then be shared with\n+ *    clients.\n+ *\n+ *  - Connect to another PipeWire instance (the main daemon, for\n+ *    example) and interact with it (See \\ref page_core_api).\n+ *\n+ *  - Export a local implementation of an object to another\n+ *    instance.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_context\n+ * @{\n+ *\/\n+struct pw_context;\n+\n+struct pw_global;\n+struct pw_impl_client;\n+\n+#include <pipewire\/core.h>\n+#include <pipewire\/loop.h>\n+#include <pipewire\/properties.h>\n+\n+\/** context events emitted by the context object added with \\ref pw_context_add_listener *\/\n+struct pw_context_events {\n+#define PW_VERSION_CONTEXT_EVENTS    0\n+    uint32_t version;\n+\n+    \/** The context is being destroyed *\/\n+    void (*destroy) (void *data);\n+    \/** The context is being freed *\/\n+    void (*free) (void *data);\n+    \/** a new client object is added *\/\n+    void (*check_access) (void *data, struct pw_impl_client *client);\n+    \/** a new global object was added *\/\n+    void (*global_added) (void *data, struct pw_global *global);\n+    \/** a global object was removed *\/\n+    void (*global_removed) (void *data, struct pw_global *global);\n+};\n+\n+\/** Make a new context object for a given main_loop. Ownership of the properties is taken *\/\n+struct pw_context * pw_context_new(struct pw_loop *main_loop,        \/**< a main loop to run in *\/\n+                 struct pw_properties *props,    \/**< extra properties *\/\n+                 size_t user_data_size        \/**< extra user data size *\/);\n+\n+\/** destroy a context object, all resources except the main_loop will be destroyed *\/\n+void pw_context_destroy(struct pw_context *context);\n+\n+\/** Get the context user data *\/\n+void *pw_context_get_user_data(struct pw_context *context);\n+\n+\/** Add a new event listener to a context *\/\n+void pw_context_add_listener(struct pw_context *context,\n+              struct spa_hook *listener,\n+              const struct pw_context_events *events,\n+              void *data);\n+\n+\/** Get the context properties *\/\n+const struct pw_properties *pw_context_get_properties(struct pw_context *context);\n+\n+\/** Update the context properties *\/\n+int pw_context_update_properties(struct pw_context *context, const struct spa_dict *dict);\n+\n+\/** Get a config section for this context. Since 0.3.22, deprecated,\n+ * use pw_context_conf_section_for_each(). *\/\n+const char *pw_context_get_conf_section(struct pw_context *context, const char *section);\n+\/** Parse a standard config section for this context. Since 0.3.22 *\/\n+int pw_context_parse_conf_section(struct pw_context *context,\n+        struct pw_properties *conf, const char *section);\n+\n+\/** update properties from a section into props. Since 0.3.45 *\/\n+int pw_context_conf_update_props(struct pw_context *context, const char *section,\n+        struct pw_properties *props);\n+\/** emit callback for all config sections. Since 0.3.45 *\/\n+int pw_context_conf_section_for_each(struct pw_context *context, const char *section,\n+        int (*callback) (void *data, const char *location, const char *section,\n+            const char *str, size_t len),\n+        void *data);\n+\/** emit callback for all matched properties. Since 0.3.46 *\/\n+int pw_context_conf_section_match_rules(struct pw_context *context, const char *section,\n+        const struct spa_dict *props,\n+        int (*callback) (void *data, const char *location, const char *action,\n+            const char *str, size_t len),\n+        void *data);\n+\n+\/** Get the context support objects *\/\n+const struct spa_support *pw_context_get_support(struct pw_context *context, uint32_t *n_support);\n+\n+\/** get the context main loop *\/\n+struct pw_loop *pw_context_get_main_loop(struct pw_context *context);\n+\n+\/** get the context data loop. Since 0.3.56 *\/\n+struct pw_data_loop *pw_context_get_data_loop(struct pw_context *context);\n+\n+\/** Get the work queue from the context: Since 0.3.26 *\/\n+struct pw_work_queue *pw_context_get_work_queue(struct pw_context *context);\n+\n+\/** Iterate the globals of the context. The callback should return\n+ * 0 to fetch the next item, any other value stops the iteration and returns\n+ * the value. When all callbacks return 0, this function returns 0 when all\n+ * globals are iterated. *\/\n+int pw_context_for_each_global(struct pw_context *context,\n+                int (*callback) (void *data, struct pw_global *global),\n+                void *data);\n+\n+\/** Find a context global by id *\/\n+struct pw_global *pw_context_find_global(struct pw_context *context,    \/**< the context *\/\n+                      uint32_t id        \/**< the global id *\/);\n+\n+\/** add a spa library for the given factory_name regex *\/\n+int pw_context_add_spa_lib(struct pw_context *context, const char *factory_regex, const char *lib);\n+\n+\/** find the library name for a spa factory *\/\n+const char * pw_context_find_spa_lib(struct pw_context *context, const char *factory_name);\n+\n+struct spa_handle *pw_context_load_spa_handle(struct pw_context *context,\n+        const char *factory_name,\n+        const struct spa_dict *info);\n+\n+\n+\/** data for registering export functions *\/\n+struct pw_export_type {\n+    struct spa_list link;\n+    const char *type;\n+    struct pw_proxy * (*func) (struct pw_core *core,\n+        const char *type, const struct spa_dict *props, void *object,\n+        size_t user_data_size);\n+};\n+\n+\/** register a type that can be exported on a context_proxy. This is usually used by\n+ * extension modules *\/\n+int pw_context_register_export_type(struct pw_context *context, struct pw_export_type *type);\n+\/** find information about registered export type *\/\n+const struct pw_export_type *pw_context_find_export_type(struct pw_context *context, const char *type);\n+\n+\/** add an object to the context *\/\n+int pw_context_set_object(struct pw_context *context, const char *type, void *value);\n+\/** get an object from the context *\/\n+void *pw_context_get_object(struct pw_context *context, const char *type);\n+\n+\/**\n+ * \\}\n+ *\/\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_CONTEXT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/context.h","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,612 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_CORE_H\n+#define PIPEWIRE_CORE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <errno.h>\n+\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup pw_core Core\n+ *\n+ * \\brief The core global object.\n+ *\n+ * This is a special singleton object. It is used for internal PipeWire\n+ * protocol features. Connecting to a PipeWire instance returns one core\n+ * object, the caller should then register event listeners\n+ * using \\ref pw_core_add_listener.\n+ *\n+ * Updates to the core object are then provided through the \\ref\n+ * pw_core_events interface. See \\ref page_tutorial2 for an example.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_core\n+ * \\{\n+ *\/\n+#define PW_TYPE_INTERFACE_Core        PW_TYPE_INFO_INTERFACE_BASE \"Core\"\n+#define PW_TYPE_INTERFACE_Registry    PW_TYPE_INFO_INTERFACE_BASE \"Registry\"\n+\n+#define PW_VERSION_CORE        4\n+struct pw_core;\n+#define PW_VERSION_REGISTRY    3\n+struct pw_registry;\n+\n+\/** The default remote name to connect to *\/\n+#define PW_DEFAULT_REMOTE    \"pipewire-0\"\n+\n+\/** default ID for the core object after connect *\/\n+#define PW_ID_CORE        0\n+\n+\/* invalid ID that matches any object when used for permissions *\/\n+#define PW_ID_ANY        (uint32_t)(0xffffffff)\n+\n+\/**  The core information. Extra information may be added in later versions,\n+ * clients must not assume a constant struct size *\/\n+struct pw_core_info {\n+    uint32_t id;            \/**< id of the global *\/\n+    uint32_t cookie;        \/**< a random cookie for identifying this instance of PipeWire *\/\n+    const char *user_name;        \/**< name of the user that started the core *\/\n+    const char *host_name;        \/**< name of the machine the core is running on *\/\n+    const char *version;        \/**< version of the core *\/\n+    const char *name;        \/**< name of the core *\/\n+#define PW_CORE_CHANGE_MASK_PROPS      (1 << 0)\n+#define PW_CORE_CHANGE_MASK_ALL        ((1 << 1)-1)\n+    uint64_t change_mask;        \/**< bitfield of changed fields since last call *\/\n+    struct spa_dict *props;        \/**< extra properties *\/\n+};\n+\n+#include <pipewire\/context.h>\n+#include <pipewire\/properties.h>\n+#include <pipewire\/proxy.h>\n+\n+\/** Update an existing \\ref pw_core_info with \\a update with reset *\/\n+struct pw_core_info *\n+pw_core_info_update(struct pw_core_info *info,\n+        const struct pw_core_info *update);\n+\/** Update an existing \\ref pw_core_info with \\a update *\/\n+struct pw_core_info *\n+pw_core_info_merge(struct pw_core_info *info,\n+        const struct pw_core_info *update, bool reset);\n+\/** Free a \\ref pw_core_info  *\/\n+void pw_core_info_free(struct pw_core_info *info);\n+\n+\/** Core *\/\n+\n+#define PW_CORE_EVENT_INFO        0\n+#define PW_CORE_EVENT_DONE        1\n+#define PW_CORE_EVENT_PING        2\n+#define PW_CORE_EVENT_ERROR        3\n+#define PW_CORE_EVENT_REMOVE_ID        4\n+#define PW_CORE_EVENT_BOUND_ID        5\n+#define PW_CORE_EVENT_ADD_MEM        6\n+#define PW_CORE_EVENT_REMOVE_MEM    7\n+#define PW_CORE_EVENT_BOUND_PROPS    8\n+#define PW_CORE_EVENT_NUM        9\n+\n+\/** \\struct pw_core_events\n+ *  \\brief Core events\n+ *\/\n+struct pw_core_events {\n+#define PW_VERSION_CORE_EVENTS    1\n+    uint32_t version;\n+\n+    \/**\n+     * Notify new core info\n+     *\n+     * This event is emitted when first bound to the core or when the\n+     * hello method is called.\n+     *\n+     * \\param info new core info\n+     *\/\n+    void (*info) (void *data, const struct pw_core_info *info);\n+    \/**\n+     * Emit a done event\n+     *\n+     * The done event is emitted as a result of a sync method with the\n+     * same seq number.\n+     *\n+     * \\param seq the seq number passed to the sync method call\n+     *\/\n+    void (*done) (void *data, uint32_t id, int seq);\n+\n+    \/** Emit a ping event\n+     *\n+     * The client should reply with a pong reply with the same seq\n+     * number.\n+     *\/\n+    void (*ping) (void *data, uint32_t id, int seq);\n+\n+    \/**\n+     * Fatal error event\n+         *\n+         * The error event is sent out when a fatal (non-recoverable)\n+         * error has occurred. The id argument is the proxy object where\n+         * the error occurred, most often in response to a request to that\n+         * object. The message is a brief description of the error,\n+         * for (debugging) convenience.\n+     *\n+     * This event is usually also emitted on the proxy object with\n+     * \\a id.\n+     *\n+         * \\param id object where the error occurred\n+         * \\param seq the sequence number that generated the error\n+         * \\param res error code\n+         * \\param message error description\n+     *\/\n+    void (*error) (void *data, uint32_t id, int seq, int res, const char *message);\n+    \/**\n+     * Remove an object ID\n+         *\n+         * This event is used internally by the object ID management\n+         * logic. When a client deletes an object, the server will send\n+         * this event to acknowledge that it has seen the delete request.\n+         * When the client receives this event, it will know that it can\n+         * safely reuse the object ID.\n+     *\n+         * \\param id deleted object ID\n+     *\/\n+    void (*remove_id) (void *data, uint32_t id);\n+\n+    \/**\n+     * Notify an object binding\n+     *\n+     * This event is emitted when a local object ID is bound to a\n+     * global ID. It is emitted before the global becomes visible in the\n+     * registry.\n+     *\n+     * \\param id bound object ID\n+     * \\param global_id the global id bound to\n+     *\/\n+    void (*bound_id) (void *data, uint32_t id, uint32_t global_id);\n+\n+    \/**\n+     * Add memory for a client\n+     *\n+     * Memory is given to a client as \\a fd of a certain\n+     * memory \\a type.\n+     *\n+     * Further references to this fd will be made with the per memory\n+     * unique identifier \\a id.\n+     *\n+     * \\param id the unique id of the memory\n+     * \\param type the memory type, one of enum spa_data_type\n+     * \\param fd the file descriptor\n+     * \\param flags extra flags\n+     *\/\n+    void (*add_mem) (void *data, uint32_t id, uint32_t type, int fd, uint32_t flags);\n+\n+    \/**\n+     * Remove memory for a client\n+     *\n+     * \\param id the memory id to remove\n+     *\/\n+    void (*remove_mem) (void *data, uint32_t id);\n+\n+    void (*bound_props) (void *data, uint32_t id, uint32_t global_id, const struct spa_dict *props);\n+};\n+\n+#define PW_CORE_METHOD_ADD_LISTENER    0\n+#define PW_CORE_METHOD_HELLO        1\n+#define PW_CORE_METHOD_SYNC        2\n+#define PW_CORE_METHOD_PONG        3\n+#define PW_CORE_METHOD_ERROR        4\n+#define PW_CORE_METHOD_GET_REGISTRY    5\n+#define PW_CORE_METHOD_CREATE_OBJECT    6\n+#define PW_CORE_METHOD_DESTROY        7\n+#define PW_CORE_METHOD_NUM        8\n+\n+\/**\n+ * \\struct pw_core_methods\n+ * \\brief Core methods\n+ *\n+ * The core global object. This is a singleton object used for\n+ * creating new objects in the remote PipeWire instance. It is\n+ * also used for internal features.\n+ *\/\n+struct pw_core_methods {\n+#define PW_VERSION_CORE_METHODS    0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_core_events *events,\n+            void *data);\n+    \/**\n+     * Start a conversation with the server. This will send\n+     * the core info and will destroy all resources for the client\n+     * (except the core and client resource).\n+     *\/\n+    int (*hello) (void *object, uint32_t version);\n+    \/**\n+     * Do server roundtrip\n+     *\n+     * Ask the server to emit the 'done' event with \\a seq.\n+     *\n+     * Since methods are handled in-order and events are delivered\n+     * in-order, this can be used as a barrier to ensure all previous\n+     * methods and the resulting events have been handled.\n+     *\n+     * \\param seq the seq number passed to the done event\n+     *\/\n+    int (*sync) (void *object, uint32_t id, int seq);\n+    \/**\n+     * Reply to a server ping event.\n+     *\n+     * Reply to the server ping event with the same seq.\n+     *\n+     * \\param seq the seq number received in the ping event\n+     *\/\n+    int (*pong) (void *object, uint32_t id, int seq);\n+    \/**\n+     * Fatal error event\n+         *\n+         * The error method is sent out when a fatal (non-recoverable)\n+         * error has occurred. The id argument is the proxy object where\n+         * the error occurred, most often in response to an event on that\n+         * object. The message is a brief description of the error,\n+         * for (debugging) convenience.\n+     *\n+     * This method is usually also emitted on the resource object with\n+     * \\a id.\n+     *\n+         * \\param id object where the error occurred\n+         * \\param res error code\n+         * \\param message error description\n+     *\/\n+    int (*error) (void *object, uint32_t id, int seq, int res, const char *message);\n+    \/**\n+     * Get the registry object\n+     *\n+     * Create a registry object that allows the client to list and bind\n+     * the global objects available from the PipeWire server\n+     * \\param version the client version\n+     * \\param user_data_size extra size\n+     *\/\n+    struct pw_registry * (*get_registry) (void *object, uint32_t version,\n+            size_t user_data_size);\n+\n+    \/**\n+     * Create a new object on the PipeWire server from a factory.\n+     *\n+     * \\param factory_name the factory name to use\n+     * \\param type the interface to bind to\n+     * \\param version the version of the interface\n+     * \\param props extra properties\n+     * \\param user_data_size extra size\n+     *\/\n+    void * (*create_object) (void *object,\n+                   const char *factory_name,\n+                   const char *type,\n+                   uint32_t version,\n+                   const struct spa_dict *props,\n+                   size_t user_data_size);\n+    \/**\n+     * Destroy an resource\n+     *\n+     * Destroy the server resource for the given proxy.\n+     *\n+     * \\param obj the proxy to destroy\n+     *\/\n+    int (*destroy) (void *object, void *proxy);\n+};\n+\n+#define pw_core_method(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_core_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define pw_core_add_listener(c,...)    pw_core_method(c,add_listener,0,__VA_ARGS__)\n+#define pw_core_hello(c,...)        pw_core_method(c,hello,0,__VA_ARGS__)\n+#define pw_core_sync(c,...)        pw_core_method(c,sync,0,__VA_ARGS__)\n+#define pw_core_pong(c,...)        pw_core_method(c,pong,0,__VA_ARGS__)\n+#define pw_core_error(c,...)        pw_core_method(c,error,0,__VA_ARGS__)\n+\n+\n+static inline\n+SPA_PRINTF_FUNC(5, 0) int\n+pw_core_errorv(struct pw_core *core, uint32_t id, int seq,\n+        int res, const char *message, va_list args)\n+{\n+    char buffer[1024];\n+    vsnprintf(buffer, sizeof(buffer), message, args);\n+    buffer[1023] = '\\0';\n+    return pw_core_error(core, id, seq, res, buffer);\n+}\n+\n+static inline\n+SPA_PRINTF_FUNC(5, 6) int\n+pw_core_errorf(struct pw_core *core, uint32_t id, int seq,\n+        int res, const char *message, ...)\n+{\n+        va_list args;\n+    int r;\n+    va_start(args, message);\n+    r = pw_core_errorv(core, id, seq, res, message, args);\n+    va_end(args);\n+    return r;\n+}\n+\n+static inline struct pw_registry *\n+pw_core_get_registry(struct pw_core *core, uint32_t version, size_t user_data_size)\n+{\n+    struct pw_registry *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)core,\n+            struct pw_core_methods, res,\n+            get_registry, 0, version, user_data_size);\n+    return res;\n+}\n+\n+static inline void *\n+pw_core_create_object(struct pw_core *core,\n+                const char *factory_name,\n+                const char *type,\n+                uint32_t version,\n+                const struct spa_dict *props,\n+                size_t user_data_size)\n+{\n+    void *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)core,\n+            struct pw_core_methods, res,\n+            create_object, 0, factory_name,\n+            type, version, props, user_data_size);\n+    return res;\n+}\n+\n+#define pw_core_destroy(c,...)        pw_core_method(c,destroy,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/** \\defgroup pw_registry Registry\n+ *\n+ * The registry object is a singleton object that keeps track of\n+ * global objects on the PipeWire instance. See also \\ref pw_global.\n+ *\n+ * Global objects typically represent an actual object in PipeWire\n+ * (for example, a module or node) or they are singleton\n+ * objects such as the core.\n+ *\n+ * When a client creates a registry object, the registry object\n+ * will emit a global event for each global currently in the\n+ * registry.  Globals come and go as a result of device hotplugs or\n+ * reconfiguration or other events, and the registry will send out\n+ * global and global_remove events to keep the client up to date\n+ * with the changes.  To mark the end of the initial burst of\n+ * events, the client can use the pw_core.sync methosd immediately\n+ * after calling pw_core.get_registry.\n+ *\n+ * A client can bind to a global object by using the bind\n+ * request.  This creates a client-side proxy that lets the object\n+ * emit events to the client and lets the client invoke methods on\n+ * the object. See \\ref page_proxy\n+ *\n+ * Clients can also change the permissions of the global objects that\n+ * it can see. This is interesting when you want to configure a\n+ * pipewire session before handing it to another application. You\n+ * can, for example, hide certain existing or new objects or limit\n+ * the access permissions on an object.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_registry\n+ * \\{\n+ *\/\n+\n+#define PW_REGISTRY_EVENT_GLOBAL             0\n+#define PW_REGISTRY_EVENT_GLOBAL_REMOVE      1\n+#define PW_REGISTRY_EVENT_NUM                2\n+\n+\/** Registry events *\/\n+struct pw_registry_events {\n+#define PW_VERSION_REGISTRY_EVENTS    0\n+    uint32_t version;\n+    \/**\n+     * Notify of a new global object\n+     *\n+     * The registry emits this event when a new global object is\n+     * available.\n+     *\n+     * \\param id the global object id\n+     * \\param permissions the permissions of the object\n+     * \\param type the type of the interface\n+     * \\param version the version of the interface\n+     * \\param props extra properties of the global\n+     *\/\n+    void (*global) (void *data, uint32_t id,\n+               uint32_t permissions, const char *type, uint32_t version,\n+               const struct spa_dict *props);\n+    \/**\n+     * Notify of a global object removal\n+     *\n+     * Emitted when a global object was removed from the registry.\n+     * If the client has any bindings to the global, it should destroy\n+     * those.\n+     *\n+     * \\param id the id of the global that was removed\n+     *\/\n+    void (*global_remove) (void *data, uint32_t id);\n+};\n+\n+#define PW_REGISTRY_METHOD_ADD_LISTENER    0\n+#define PW_REGISTRY_METHOD_BIND        1\n+#define PW_REGISTRY_METHOD_DESTROY    2\n+#define PW_REGISTRY_METHOD_NUM        3\n+\n+\/** Registry methods *\/\n+struct pw_registry_methods {\n+#define PW_VERSION_REGISTRY_METHODS    0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_registry_events *events,\n+            void *data);\n+    \/**\n+     * Bind to a global object\n+     *\n+     * Bind to the global object with \\a id and use the client proxy\n+     * with new_id as the proxy. After this call, methods can be\n+     * send to the remote global object and events can be received\n+     *\n+     * \\param id the global id to bind to\n+     * \\param type the interface type to bind to\n+     * \\param version the interface version to use\n+     * \\returns the new object\n+     *\/\n+    void * (*bind) (void *object, uint32_t id, const char *type, uint32_t version,\n+            size_t use_data_size);\n+\n+    \/**\n+     * Attempt to destroy a global object\n+     *\n+     * Try to destroy the global object.\n+     *\n+     * \\param id the global id to destroy\n+     *\/\n+    int (*destroy) (void *object, uint32_t id);\n+};\n+\n+#define pw_registry_method(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_registry_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\/** Registry *\/\n+#define pw_registry_add_listener(p,...)    pw_registry_method(p,add_listener,0,__VA_ARGS__)\n+\n+static inline void *\n+pw_registry_bind(struct pw_registry *registry,\n+               uint32_t id, const char *type, uint32_t version,\n+               size_t user_data_size)\n+{\n+    void *res = NULL;\n+    spa_interface_call_res((struct spa_interface*)registry,\n+            struct pw_registry_methods, res,\n+            bind, 0, id, type, version, user_data_size);\n+    return res;\n+}\n+\n+#define pw_registry_destroy(p,...)    pw_registry_method(p,destroy,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_core\n+ * \\{\n+ *\/\n+\n+\/** Connect to a PipeWire instance\n+ *\n+ * \\param context a \\ref pw_context\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error. The core\n+ * will have an id of \\ref PW_ID_CORE (0)\n+ *\/\n+struct pw_core *\n+pw_context_connect(struct pw_context *context,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Connect to a PipeWire instance on the given socket\n+ *\n+ * \\param context a \\ref pw_context\n+ * \\param fd the connected socket to use, the socket will be closed\n+ *    automatically on disconnect or error.\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error *\/\n+struct pw_core *\n+pw_context_connect_fd(struct pw_context *context,\n+          int fd,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Connect to a given PipeWire instance\n+ *\n+ * \\param context a \\ref pw_context to connect to\n+ * \\param properties optional properties, ownership of the properties is\n+ *    taken.\n+ * \\param user_data_size extra user data size\n+ *\n+ * \\return a \\ref pw_core on success or NULL with errno set on error *\/\n+struct pw_core *\n+pw_context_connect_self(struct pw_context *context,\n+          struct pw_properties *properties,\n+          size_t user_data_size);\n+\n+\/** Steal the fd of the core connection or < 0 on error. The core\n+  * will be disconnected after this call. *\/\n+int pw_core_steal_fd(struct pw_core *core);\n+\n+\/** Pause or resume the core. When the core is paused, no new events\n+ *  will be dispatched until the core is resumed again. *\/\n+int pw_core_set_paused(struct pw_core *core, bool paused);\n+\n+\/** disconnect and destroy a core *\/\n+int pw_core_disconnect(struct pw_core *core);\n+\n+\/** Get the user_data. It is of the size specified when this object was\n+ * constructed *\/\n+void *pw_core_get_user_data(struct pw_core *core);\n+\n+\/** Get the client proxy of the connected core. This will have the id\n+ * of PW_ID_CLIENT (1) *\/\n+struct pw_client * pw_core_get_client(struct pw_core *core);\n+\n+\/** Get the context object used to created this core *\/\n+struct pw_context * pw_core_get_context(struct pw_core *core);\n+\n+\/** Get properties from the core *\/\n+const struct pw_properties *pw_core_get_properties(struct pw_core *core);\n+\n+\/** Update the core properties. This updates the properties\n+ * of the associated client.\n+ * \\return the number of properties that were updated *\/\n+int pw_core_update_properties(struct pw_core *core, const struct spa_dict *dict);\n+\n+\/** Get the core mempool object *\/\n+struct pw_mempool * pw_core_get_mempool(struct pw_core *core);\n+\n+\/** Get the proxy with the given id *\/\n+struct pw_proxy *pw_core_find_proxy(struct pw_core *core, uint32_t id);\n+\n+\/** Export an object into the PipeWire instance associated with core *\/\n+struct pw_proxy *pw_core_export(struct pw_core *core,            \/**< the core *\/\n+                  const char *type,            \/**< the type of object *\/\n+                  const struct spa_dict *props,        \/**< extra properties *\/\n+                  void *object,                \/**< object to export *\/\n+                  size_t user_data_size            \/**< extra user data *\/);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_CORE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/core.h","additions":612,"deletions":0,"binary":false,"changes":612,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_KEYS_H\n+#define PIPEWIRE_KEYS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <pipewire\/utils.h>\n+\/**\n+ * \\defgroup pw_keys Key Names\n+ *\n+ * A collection of keys that are used to add extra information on objects.\n+ *\n+ * Keys that start with \"pipewire.\" are in general set-once and then\n+ * read-only. They are usually used for security sensitive information that\n+ * needs to be fixed.\n+ *\n+ * Properties from other objects can also appear. This usually suggests some\n+ * sort of parent\/child or owner\/owned relationship.\n+ *\n+ * \\addtogroup pw_keys\n+ * \\{\n+ *\/\n+#define PW_KEY_PROTOCOL            \"pipewire.protocol\"    \/**< protocol used for connection *\/\n+#define PW_KEY_ACCESS            \"pipewire.access\"    \/**< how the client access is controlled *\/\n+#define PW_KEY_CLIENT_ACCESS        \"pipewire.client.access\"\/**< how the client wants to be access\n+                                  *  controlled *\/\n+\n+\/** Various keys related to the identity of a client process and its security.\n+ * Must be obtained from trusted sources by the protocol and placed as\n+ * read-only properties. *\/\n+#define PW_KEY_SEC_PID            \"pipewire.sec.pid\"    \/**< Client pid, set by protocol *\/\n+#define PW_KEY_SEC_UID            \"pipewire.sec.uid\"    \/**< Client uid, set by protocol*\/\n+#define PW_KEY_SEC_GID            \"pipewire.sec.gid\"    \/**< client gid, set by protocol*\/\n+#define PW_KEY_SEC_LABEL        \"pipewire.sec.label\"    \/**< client security label, set by protocol*\/\n+\n+#define PW_KEY_LIBRARY_NAME_SYSTEM    \"library.name.system\"    \/**< name of the system library to use *\/\n+#define PW_KEY_LIBRARY_NAME_LOOP    \"library.name.loop\"    \/**< name of the loop library to use *\/\n+#define PW_KEY_LIBRARY_NAME_DBUS    \"library.name.dbus\"    \/**< name of the dbus library to use *\/\n+\n+\/** object properties *\/\n+#define PW_KEY_OBJECT_PATH        \"object.path\"        \/**< unique path to construct the object *\/\n+#define PW_KEY_OBJECT_ID        \"object.id\"        \/**< a global object id *\/\n+#define PW_KEY_OBJECT_SERIAL        \"object.serial\"        \/**< a 64 bit object serial number. This is a number\n+                                  *  incremented for each object that is created.\n+                                  *  The lower 32 bits are guaranteed to never be\n+                                  *  SPA_ID_INVALID. *\/\n+#define PW_KEY_OBJECT_LINGER        \"object.linger\"        \/**< the object lives on even after the client\n+                                  *  that created it has been destroyed *\/\n+#define PW_KEY_OBJECT_REGISTER        \"object.register\"    \/**< If the object should be registered. *\/\n+\n+\n+\/* config *\/\n+#define PW_KEY_CONFIG_PREFIX        \"config.prefix\"        \/**< a config prefix directory *\/\n+#define PW_KEY_CONFIG_NAME        \"config.name\"        \/**< a config file name *\/\n+#define PW_KEY_CONFIG_OVERRIDE_PREFIX    \"config.override.prefix\"    \/**< a config override prefix directory *\/\n+#define PW_KEY_CONFIG_OVERRIDE_NAME    \"config.override.name\"    \/**< a config override file name *\/\n+\n+\/* context *\/\n+#define PW_KEY_CONTEXT_PROFILE_MODULES    \"context.profile.modules\"    \/**< a context profile for modules, deprecated *\/\n+#define PW_KEY_USER_NAME        \"context.user-name\"    \/**< The user name that runs pipewire *\/\n+#define PW_KEY_HOST_NAME        \"context.host-name\"    \/**< The host name of the machine *\/\n+\n+\/* core *\/\n+#define PW_KEY_CORE_NAME        \"core.name\"        \/**< The name of the core. Default is\n+                                  *  `pipewire-<username>-<pid>`, overwritten\n+                                  *  by env(PIPEWIRE_CORE) *\/\n+#define PW_KEY_CORE_VERSION        \"core.version\"        \/**< The version of the core. *\/\n+#define PW_KEY_CORE_DAEMON        \"core.daemon\"        \/**< If the core is listening for connections. *\/\n+\n+#define PW_KEY_CORE_ID            \"core.id\"        \/**< the core id *\/\n+#define PW_KEY_CORE_MONITORS        \"core.monitors\"        \/**< the apis monitored by core. *\/\n+\n+\/* cpu *\/\n+#define PW_KEY_CPU_MAX_ALIGN        \"cpu.max-align\"        \/**< maximum alignment needed to support\n+                                  *  all CPU optimizations *\/\n+#define PW_KEY_CPU_CORES        \"cpu.cores\"        \/**< number of cores *\/\n+\n+\/* priorities *\/\n+#define PW_KEY_PRIORITY_SESSION        \"priority.session\"    \/**< priority in session manager *\/\n+#define PW_KEY_PRIORITY_DRIVER        \"priority.driver\"    \/**< priority to be a driver *\/\n+\n+\/* remote keys *\/\n+#define PW_KEY_REMOTE_NAME        \"remote.name\"        \/**< The name of the remote to connect to,\n+                                  *  default pipewire-0, overwritten by\n+                                  *  env(PIPEWIRE_REMOTE) *\/\n+#define PW_KEY_REMOTE_INTENTION        \"remote.intention\"    \/**< The intention of the remote connection,\n+                                  *  \"generic\", \"screencast\" *\/\n+\n+\/** application keys *\/\n+#define PW_KEY_APP_NAME            \"application.name\"    \/**< application name. Ex: \"Totem Music Player\" *\/\n+#define PW_KEY_APP_ID            \"application.id\"    \/**< a textual id for identifying an\n+                                  *  application logically. Ex: \"org.gnome.Totem\" *\/\n+#define PW_KEY_APP_VERSION        \"application.version\"   \/**< application version. Ex: \"1.2.0\" *\/\n+#define PW_KEY_APP_ICON            \"application.icon\"    \/**< aa base64 blob with PNG image data *\/\n+#define PW_KEY_APP_ICON_NAME        \"application.icon-name\"    \/**< an XDG icon name for the application.\n+                                  *  Ex: \"totem\" *\/\n+#define PW_KEY_APP_LANGUAGE        \"application.language\"    \/**< application language if applicable, in\n+                                  *  standard POSIX format. Ex: \"en_GB\" *\/\n+\n+#define PW_KEY_APP_PROCESS_ID        \"application.process.id\"    \/**< process id  (pid)*\/\n+#define PW_KEY_APP_PROCESS_BINARY    \"application.process.binary\"    \/**< binary name *\/\n+#define PW_KEY_APP_PROCESS_USER        \"application.process.user\"    \/**< user name *\/\n+#define PW_KEY_APP_PROCESS_HOST        \"application.process.host\"    \/**< host name *\/\n+#define PW_KEY_APP_PROCESS_MACHINE_ID    \"application.process.machine-id\" \/**< the D-Bus host id the\n+                                       *  application runs on *\/\n+#define PW_KEY_APP_PROCESS_SESSION_ID    \"application.process.session-id\" \/**< login session of the\n+                                       *  application, on Unix the\n+                                       *  value of $XDG_SESSION_ID. *\/\n+\/** window system *\/\n+#define PW_KEY_WINDOW_X11_DISPLAY    \"window.x11.display\"    \/**< the X11 display string. Ex. \":0.0\" *\/\n+\n+\/** Client properties *\/\n+#define PW_KEY_CLIENT_ID        \"client.id\"        \/**< a client id *\/\n+#define PW_KEY_CLIENT_NAME        \"client.name\"        \/**< the client name *\/\n+#define PW_KEY_CLIENT_API        \"client.api\"        \/**< the client api used to access\n+                                  *  PipeWire *\/\n+\n+\/** Node keys *\/\n+#define PW_KEY_NODE_ID            \"node.id\"        \/**< node id *\/\n+#define PW_KEY_NODE_NAME        \"node.name\"        \/**< node name *\/\n+#define PW_KEY_NODE_NICK        \"node.nick\"        \/**< short node name *\/\n+#define PW_KEY_NODE_DESCRIPTION        \"node.description\"    \/**< localized human readable node one-line\n+                                  *  description. Ex. \"Foobar USB Headset\" *\/\n+#define PW_KEY_NODE_PLUGGED        \"node.plugged\"        \/**< when the node was created. As a uint64 in\n+                                  *  nanoseconds. *\/\n+\n+#define PW_KEY_NODE_SESSION        \"node.session\"        \/**< the session id this node is part of *\/\n+#define PW_KEY_NODE_GROUP        \"node.group\"        \/**< the group id this node is part of. Nodes\n+                                  *  in the same group are always scheduled\n+                                  *  with the same driver. *\/\n+#define PW_KEY_NODE_EXCLUSIVE        \"node.exclusive\"    \/**< node wants exclusive access to resources *\/\n+#define PW_KEY_NODE_AUTOCONNECT        \"node.autoconnect\"    \/**< node wants to be automatically connected\n+                                  *  to a compatible node *\/\n+#define PW_KEY_NODE_LATENCY        \"node.latency\"        \/**< the requested latency of the node as\n+                                  *  a fraction. Ex: 128\/48000 *\/\n+#define PW_KEY_NODE_MAX_LATENCY        \"node.max-latency\"    \/**< the maximum supported latency of the\n+                                  *  node as a fraction. Ex: 1024\/48000 *\/\n+#define PW_KEY_NODE_LOCK_QUANTUM    \"node.lock-quantum\"    \/**< don't change quantum when this node\n+                                  *  is active *\/\n+#define PW_KEY_NODE_FORCE_QUANTUM    \"node.force-quantum\"    \/**< force a quantum while the node is\n+                                  *  active *\/\n+#define PW_KEY_NODE_RATE        \"node.rate\"        \/**< the requested rate of the graph as\n+                                  *  a fraction. Ex: 1\/48000 *\/\n+#define PW_KEY_NODE_LOCK_RATE        \"node.lock-rate\"    \/**< don't change rate when this node\n+                                  *  is active *\/\n+#define PW_KEY_NODE_FORCE_RATE        \"node.force-rate\"    \/**< force a rate while the node is\n+                                  *  active. A value of 0 takes the denominator\n+                                  *  of node.rate *\/\n+\n+#define PW_KEY_NODE_DONT_RECONNECT    \"node.dont-reconnect\"    \/**< don't reconnect this node. The node is\n+                                  *  initially linked to target.object or the\n+                                  *  default node. If the target is removed,\n+                                  *  the node is destroyed *\/\n+#define PW_KEY_NODE_ALWAYS_PROCESS    \"node.always-process\"    \/**< process even when unlinked *\/\n+#define PW_KEY_NODE_WANT_DRIVER        \"node.want-driver\"    \/**< the node wants to be grouped with a driver\n+                                  *  node in order to schedule the graph. *\/\n+#define PW_KEY_NODE_PAUSE_ON_IDLE    \"node.pause-on-idle\"    \/**< pause the node when idle *\/\n+#define PW_KEY_NODE_SUSPEND_ON_IDLE    \"node.suspend-on-idle\"    \/**< suspend the node when idle *\/\n+#define PW_KEY_NODE_CACHE_PARAMS    \"node.cache-params\"    \/**< cache the node params *\/\n+#define PW_KEY_NODE_TRANSPORT_SYNC    \"node.transport.sync\"    \/**< the node handles transport sync *\/\n+#define PW_KEY_NODE_DRIVER        \"node.driver\"        \/**< node can drive the graph *\/\n+#define PW_KEY_NODE_STREAM        \"node.stream\"        \/**< node is a stream, the server side should\n+                                  *  add a converter *\/\n+#define PW_KEY_NODE_VIRTUAL        \"node.virtual\"        \/**< the node is some sort of virtual\n+                                  *  object *\/\n+#define PW_KEY_NODE_PASSIVE        \"node.passive\"        \/**< indicate that a node wants passive links\n+                                  *  on output\/input\/all ports when the value is\n+                                  *  \"out\"\/\"in\"\/\"true\" respectively *\/\n+#define PW_KEY_NODE_LINK_GROUP        \"node.link-group\"    \/**< the node is internally linked to\n+                                  *  nodes with the same link-group *\/\n+#define PW_KEY_NODE_NETWORK        \"node.network\"        \/**< the node is on a network *\/\n+#define PW_KEY_NODE_TRIGGER        \"node.trigger\"        \/**< the node is not scheduled automatically\n+                                  *   based on the dependencies in the graph\n+                                  *   but it will be triggered explicitly. *\/\n+#define PW_KEY_NODE_CHANNELNAMES        \"node.channel-names\"        \/**< names of node's\n+                                    *   channels (unrelated to positions) *\/\n+#define PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX            \"node.device-port-name-prefix\"        \/** override\n+                                    *        port name prefix for device ports, like capture and playback\n+                                    *        or disable the prefix completely if an empty string is provided *\/\n+\n+\/** Port keys *\/\n+#define PW_KEY_PORT_ID            \"port.id\"        \/**< port id *\/\n+#define PW_KEY_PORT_NAME        \"port.name\"        \/**< port name *\/\n+#define PW_KEY_PORT_DIRECTION        \"port.direction\"    \/**< the port direction, one of \"in\" or \"out\"\n+                                  *  or \"control\" and \"notify\" for control ports *\/\n+#define PW_KEY_PORT_ALIAS        \"port.alias\"        \/**< port alias *\/\n+#define PW_KEY_PORT_PHYSICAL        \"port.physical\"        \/**< if this is a physical port *\/\n+#define PW_KEY_PORT_TERMINAL        \"port.terminal\"        \/**< if this port consumes the data *\/\n+#define PW_KEY_PORT_CONTROL        \"port.control\"        \/**< if this port is a control port *\/\n+#define PW_KEY_PORT_MONITOR        \"port.monitor\"        \/**< if this port is a monitor port *\/\n+#define PW_KEY_PORT_CACHE_PARAMS    \"port.cache-params\"    \/**< cache the node port params *\/\n+#define PW_KEY_PORT_EXTRA        \"port.extra\"        \/**< api specific extra port info, API name\n+                                  *  should be prefixed. \"jack:flags:56\" *\/\n+#define PW_KEY_PORT_PASSIVE        \"port.passive\"        \/**< the ports wants passive links, since 0.3.67 *\/\n+\n+\/** link properties *\/\n+#define PW_KEY_LINK_ID            \"link.id\"        \/**< a link id *\/\n+#define PW_KEY_LINK_INPUT_NODE        \"link.input.node\"    \/**< input node id of a link *\/\n+#define PW_KEY_LINK_INPUT_PORT        \"link.input.port\"    \/**< input port id of a link *\/\n+#define PW_KEY_LINK_OUTPUT_NODE        \"link.output.node\"    \/**< output node id of a link *\/\n+#define PW_KEY_LINK_OUTPUT_PORT        \"link.output.port\"    \/**< output port id of a link *\/\n+#define PW_KEY_LINK_PASSIVE        \"link.passive\"        \/**< indicate that a link is passive and\n+                                  *  does not cause the graph to be\n+                                  *  runnable. *\/\n+#define PW_KEY_LINK_FEEDBACK        \"link.feedback\"        \/**< indicate that a link is a feedback\n+                                  *  link and the target will receive data\n+                                  *  in the next cycle *\/\n+\n+\/** device properties *\/\n+#define PW_KEY_DEVICE_ID        \"device.id\"        \/**< device id *\/\n+#define PW_KEY_DEVICE_NAME        \"device.name\"        \/**< device name *\/\n+#define PW_KEY_DEVICE_PLUGGED        \"device.plugged\"    \/**< when the device was created. As a uint64 in\n+                                  *  nanoseconds. *\/\n+#define PW_KEY_DEVICE_NICK        \"device.nick\"        \/**< a short device nickname *\/\n+#define PW_KEY_DEVICE_STRING        \"device.string\"        \/**< device string in the underlying layer's\n+                                  *  format. Ex. \"surround51:0\" *\/\n+#define PW_KEY_DEVICE_API        \"device.api\"        \/**< API this device is accessed with.\n+                                  *  Ex. \"alsa\", \"v4l2\" *\/\n+#define PW_KEY_DEVICE_DESCRIPTION    \"device.description\"    \/**< localized human readable device one-line\n+                                  *  description. Ex. \"Foobar USB Headset\" *\/\n+#define PW_KEY_DEVICE_BUS_PATH        \"device.bus-path\"    \/**< bus path to the device in the OS'\n+                                  *  format. Ex. \"pci-0000:00:14.0-usb-0:3.2:1.0\" *\/\n+#define PW_KEY_DEVICE_SERIAL        \"device.serial\"        \/**< Serial number if applicable *\/\n+#define PW_KEY_DEVICE_VENDOR_ID        \"device.vendor.id\"    \/**< vendor ID if applicable *\/\n+#define PW_KEY_DEVICE_VENDOR_NAME    \"device.vendor.name\"    \/**< vendor name if applicable *\/\n+#define PW_KEY_DEVICE_PRODUCT_ID    \"device.product.id\"    \/**< product ID if applicable *\/\n+#define PW_KEY_DEVICE_PRODUCT_NAME    \"device.product.name\"    \/**< product name if applicable *\/\n+#define PW_KEY_DEVICE_CLASS        \"device.class\"        \/**< device class *\/\n+#define PW_KEY_DEVICE_FORM_FACTOR    \"device.form-factor\"    \/**< form factor if applicable. One of\n+                                  *  \"internal\", \"speaker\", \"handset\", \"tv\",\n+                                  *  \"webcam\", \"microphone\", \"headset\",\n+                                  *  \"headphone\", \"hands-free\", \"car\", \"hifi\",\n+                                  *  \"computer\", \"portable\" *\/\n+#define PW_KEY_DEVICE_BUS        \"device.bus\"        \/**< bus of the device if applicable. One of\n+                                  *  \"isa\", \"pci\", \"usb\", \"firewire\",\n+                                  *  \"bluetooth\" *\/\n+#define PW_KEY_DEVICE_SUBSYSTEM        \"device.subsystem\"    \/**< device subsystem *\/\n+#define PW_KEY_DEVICE_SYSFS_PATH    \"device.sysfs.path\"    \/**< device sysfs path *\/\n+#define PW_KEY_DEVICE_ICON        \"device.icon\"        \/**< icon for the device. A base64 blob\n+                                  *  containing PNG image data *\/\n+#define PW_KEY_DEVICE_ICON_NAME        \"device.icon-name\"    \/**< an XDG icon name for the device.\n+                                  *  Ex. \"sound-card-speakers-usb\" *\/\n+#define PW_KEY_DEVICE_INTENDED_ROLES    \"device.intended-roles\"    \/**< intended use. A space separated list of\n+                                  *  roles (see PW_KEY_MEDIA_ROLE) this device\n+                                  *  is particularly well suited for, due to\n+                                  *  latency, quality or form factor. *\/\n+#define PW_KEY_DEVICE_CACHE_PARAMS    \"device.cache-params\"    \/**< cache the device spa params *\/\n+\n+\/** module properties *\/\n+#define PW_KEY_MODULE_ID        \"module.id\"        \/**< the module id *\/\n+#define PW_KEY_MODULE_NAME        \"module.name\"        \/**< the name of the module *\/\n+#define PW_KEY_MODULE_AUTHOR        \"module.author\"        \/**< the author's name *\/\n+#define PW_KEY_MODULE_DESCRIPTION    \"module.description\"    \/**< a human readable one-line description\n+                                  *  of the module's purpose.*\/\n+#define PW_KEY_MODULE_USAGE        \"module.usage\"        \/**< a human readable usage description of\n+                                  *  the module's arguments. *\/\n+#define PW_KEY_MODULE_VERSION        \"module.version\"    \/**< a version string for the module. *\/\n+\n+\/** Factory properties *\/\n+#define PW_KEY_FACTORY_ID        \"factory.id\"        \/**< the factory id *\/\n+#define PW_KEY_FACTORY_NAME        \"factory.name\"        \/**< the name of the factory *\/\n+#define PW_KEY_FACTORY_USAGE        \"factory.usage\"        \/**< the usage of the factory *\/\n+#define PW_KEY_FACTORY_TYPE_NAME    \"factory.type.name\"    \/**< the name of the type created by a factory *\/\n+#define PW_KEY_FACTORY_TYPE_VERSION    \"factory.type.version\"    \/**< the version of the type created by a factory *\/\n+\n+\/** Stream properties *\/\n+#define PW_KEY_STREAM_IS_LIVE        \"stream.is-live\"    \/**< Indicates that the stream is live. *\/\n+#define PW_KEY_STREAM_LATENCY_MIN    \"stream.latency.min\"    \/**< The minimum latency of the stream. *\/\n+#define PW_KEY_STREAM_LATENCY_MAX    \"stream.latency.max\"    \/**< The maximum latency of the stream *\/\n+#define PW_KEY_STREAM_MONITOR        \"stream.monitor\"    \/**< Indicates that the stream is monitoring\n+                                  *  and might select a less accurate but faster\n+                                  *  conversion algorithm. *\/\n+#define PW_KEY_STREAM_DONT_REMIX    \"stream.dont-remix\"    \/**< don't remix channels *\/\n+#define PW_KEY_STREAM_CAPTURE_SINK    \"stream.capture.sink\"    \/**< Try to capture the sink output instead of\n+                                  *  source output *\/\n+\n+\/** Media *\/\n+#define PW_KEY_MEDIA_TYPE        \"media.type\"        \/**< Media type, one of\n+                                  *  Audio, Video, Midi *\/\n+#define PW_KEY_MEDIA_CATEGORY        \"media.category\"    \/**< Media Category:\n+                                  *  Playback, Capture, Duplex, Monitor, Manager *\/\n+#define PW_KEY_MEDIA_ROLE        \"media.role\"        \/**< Role: Movie, Music, Camera,\n+                                  *  Screen, Communication, Game,\n+                                  *  Notification, DSP, Production,\n+                                  *  Accessibility, Test *\/\n+#define PW_KEY_MEDIA_CLASS        \"media.class\"        \/**< class Ex: \"Video\/Source\" *\/\n+#define PW_KEY_MEDIA_NAME        \"media.name\"        \/**< media name. Ex: \"Pink Floyd: Time\" *\/\n+#define PW_KEY_MEDIA_TITLE        \"media.title\"        \/**< title. Ex: \"Time\" *\/\n+#define PW_KEY_MEDIA_ARTIST        \"media.artist\"        \/**< artist. Ex: \"Pink Floyd\" *\/\n+#define PW_KEY_MEDIA_COPYRIGHT        \"media.copyright\"    \/**< copyright string *\/\n+#define PW_KEY_MEDIA_SOFTWARE        \"media.software\"    \/**< generator software *\/\n+#define PW_KEY_MEDIA_LANGUAGE        \"media.language\"    \/**< language in POSIX format. Ex: en_GB *\/\n+#define PW_KEY_MEDIA_FILENAME        \"media.filename\"    \/**< filename *\/\n+#define PW_KEY_MEDIA_ICON        \"media.icon\"        \/**< icon for the media, a base64 blob with\n+                                  *  PNG image data *\/\n+#define PW_KEY_MEDIA_ICON_NAME        \"media.icon-name\"    \/**< an XDG icon name for the media.\n+                                  *  Ex: \"audio-x-mp3\" *\/\n+#define PW_KEY_MEDIA_COMMENT        \"media.comment\"        \/**< extra comment *\/\n+#define PW_KEY_MEDIA_DATE        \"media.date\"        \/**< date of the media *\/\n+#define PW_KEY_MEDIA_FORMAT        \"media.format\"        \/**< format of the media *\/\n+\n+\/** format related properties *\/\n+#define PW_KEY_FORMAT_DSP        \"format.dsp\"        \/**< a dsp format.\n+                                  *  Ex: \"32 bit float mono audio\" *\/\n+\/** audio related properties *\/\n+#define PW_KEY_AUDIO_CHANNEL        \"audio.channel\"        \/**< an audio channel. Ex: \"FL\" *\/\n+#define PW_KEY_AUDIO_RATE        \"audio.rate\"        \/**< an audio samplerate *\/\n+#define PW_KEY_AUDIO_CHANNELS        \"audio.channels\"    \/**< number of audio channels *\/\n+#define PW_KEY_AUDIO_FORMAT        \"audio.format\"        \/**< an audio format. Ex: \"S16LE\" *\/\n+#define PW_KEY_AUDIO_ALLOWED_RATES    \"audio.allowed-rates\"    \/**< a list of allowed samplerates\n+                                  *  ex. \"[ 44100 48000 ]\" *\/\n+\n+\/** video related properties *\/\n+#define PW_KEY_VIDEO_RATE        \"video.framerate\"    \/**< a video framerate *\/\n+#define PW_KEY_VIDEO_FORMAT        \"video.format\"        \/**< a video format *\/\n+#define PW_KEY_VIDEO_SIZE        \"video.size\"        \/**< a video size as \"<width>x<height\" *\/\n+\n+#define PW_KEY_TARGET_OBJECT        \"target.object\"        \/**< a target object to link to. This can be\n+                                  * and object name or object.serial *\/\n+\n+#ifndef PW_REMOVE_DEPRECATED\n+# ifdef PW_ENABLE_DEPRECATED\n+#  define PW_KEY_PRIORITY_MASTER    \"priority.master\"    \/**< deprecated, use priority.driver *\/\n+#  define PW_KEY_NODE_TARGET        \"node.target\"        \/**< deprecated since 0.3.64, use target.object. *\/\n+# else\n+#  define PW_KEY_PRIORITY_MASTER    PW_DEPRECATED(\"priority.master\")\n+#  define PW_KEY_NODE_TARGET        PW_DEPRECATED(\"node.target\")\n+# endif \/* PW_ENABLE_DEPRECATED *\/\n+#endif \/* PW_REMOVE_DEPRECATED *\/\n+\n+\/** \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_KEYS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/keys.h","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_LOOP_H\n+#define PIPEWIRE_LOOP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/support\/loop.h>\n+#include <spa\/utils\/dict.h>\n+\n+\/** \\defgroup pw_loop Loop\n+ *\n+ * PipeWire loop object provides an implementation of\n+ * the spa loop interfaces. It can be used to implement various\n+ * event loops.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_loop\n+ * \\{\n+ *\/\n+\n+struct pw_loop {\n+    struct spa_system *system;        \/**< system utils *\/\n+    struct spa_loop *loop;            \/**< wrapped loop *\/\n+    struct spa_loop_control *control;    \/**< loop control *\/\n+    struct spa_loop_utils *utils;        \/**< loop utils *\/\n+};\n+\n+struct pw_loop *\n+pw_loop_new(const struct spa_dict *props);\n+\n+void\n+pw_loop_destroy(struct pw_loop *loop);\n+\n+#define pw_loop_add_source(l,...)    spa_loop_add_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_update_source(l,...)    spa_loop_update_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_remove_source(l,...)    spa_loop_remove_source((l)->loop,__VA_ARGS__)\n+#define pw_loop_invoke(l,...)        spa_loop_invoke((l)->loop,__VA_ARGS__)\n+\n+#define pw_loop_get_fd(l)        spa_loop_control_get_fd((l)->control)\n+#define pw_loop_add_hook(l,...)        spa_loop_control_add_hook((l)->control,__VA_ARGS__)\n+#define pw_loop_enter(l)        spa_loop_control_enter((l)->control)\n+#define pw_loop_iterate(l,...)        spa_loop_control_iterate((l)->control,__VA_ARGS__)\n+#define pw_loop_leave(l)        spa_loop_control_leave((l)->control)\n+\n+#define pw_loop_add_io(l,...)        spa_loop_utils_add_io((l)->utils,__VA_ARGS__)\n+#define pw_loop_update_io(l,...)    spa_loop_utils_update_io((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_idle(l,...)        spa_loop_utils_add_idle((l)->utils,__VA_ARGS__)\n+#define pw_loop_enable_idle(l,...)    spa_loop_utils_enable_idle((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_event(l,...)    spa_loop_utils_add_event((l)->utils,__VA_ARGS__)\n+#define pw_loop_signal_event(l,...)    spa_loop_utils_signal_event((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_timer(l,...)    spa_loop_utils_add_timer((l)->utils,__VA_ARGS__)\n+#define pw_loop_update_timer(l,...)    spa_loop_utils_update_timer((l)->utils,__VA_ARGS__)\n+#define pw_loop_add_signal(l,...)    spa_loop_utils_add_signal((l)->utils,__VA_ARGS__)\n+#define pw_loop_destroy_source(l,...)    spa_loop_utils_destroy_source((l)->utils,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_LOOP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/loop.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PORT_H\n+#define PIPEWIRE_PORT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <errno.h>\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+#include <spa\/param\/param.h>\n+\n+#include <pipewire\/proxy.h>\n+\n+\/** \\defgroup pw_port Port\n+ * Port interface\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_port\n+ * \\{\n+ *\/\n+\n+#define PW_TYPE_INTERFACE_Port    PW_TYPE_INFO_INTERFACE_BASE \"Port\"\n+\n+#define PW_VERSION_PORT        3\n+struct pw_port;\n+\n+\/** The direction of a port *\/\n+#define pw_direction spa_direction\n+#define PW_DIRECTION_INPUT SPA_DIRECTION_INPUT\n+#define PW_DIRECTION_OUTPUT SPA_DIRECTION_OUTPUT\n+\n+\/** Convert a \\ref pw_direction to a readable string *\/\n+const char * pw_direction_as_string(enum pw_direction direction);\n+\n+struct pw_port_info {\n+    uint32_t id;                \/**< id of the global *\/\n+    enum pw_direction direction;        \/**< port direction *\/\n+#define PW_PORT_CHANGE_MASK_PROPS        (1 << 0)\n+#define PW_PORT_CHANGE_MASK_PARAMS        (1 << 1)\n+#define PW_PORT_CHANGE_MASK_ALL            ((1 << 2)-1)\n+    uint64_t change_mask;            \/**< bitfield of changed fields since last call *\/\n+    struct spa_dict *props;            \/**< the properties of the port *\/\n+    struct spa_param_info *params;        \/**< parameters *\/\n+    uint32_t n_params;            \/**< number of items in \\a params *\/\n+};\n+\n+struct pw_port_info *\n+pw_port_info_update(struct pw_port_info *info,\n+        const struct pw_port_info *update);\n+\n+struct pw_port_info *\n+pw_port_info_merge(struct pw_port_info *info,\n+        const struct pw_port_info *update, bool reset);\n+\n+void\n+pw_port_info_free(struct pw_port_info *info);\n+\n+#define PW_PORT_EVENT_INFO    0\n+#define PW_PORT_EVENT_PARAM    1\n+#define PW_PORT_EVENT_NUM    2\n+\n+\/** Port events *\/\n+struct pw_port_events {\n+#define PW_VERSION_PORT_EVENTS    0\n+    uint32_t version;\n+    \/**\n+     * Notify port info\n+     *\n+     * \\param info info about the port\n+     *\/\n+    void (*info) (void *data, const struct pw_port_info *info);\n+    \/**\n+     * Notify a port param\n+     *\n+     * Event emitted as a result of the enum_params method.\n+     *\n+     * \\param seq the sequence number of the request\n+     * \\param id the param id\n+     * \\param index the param index\n+     * \\param next the param index of the next param\n+     * \\param param the parameter\n+     *\/\n+    void (*param) (void *data, int seq,\n+               uint32_t id, uint32_t index, uint32_t next,\n+               const struct spa_pod *param);\n+};\n+\n+#define PW_PORT_METHOD_ADD_LISTENER    0\n+#define PW_PORT_METHOD_SUBSCRIBE_PARAMS    1\n+#define PW_PORT_METHOD_ENUM_PARAMS    2\n+#define PW_PORT_METHOD_NUM        3\n+\n+\/** Port methods *\/\n+struct pw_port_methods {\n+#define PW_VERSION_PORT_METHODS        0\n+    uint32_t version;\n+\n+    int (*add_listener) (void *object,\n+            struct spa_hook *listener,\n+            const struct pw_port_events *events,\n+            void *data);\n+    \/**\n+     * Subscribe to parameter changes\n+     *\n+     * Automatically emit param events for the given ids when\n+     * they are changed.\n+     *\n+     * \\param ids an array of param ids\n+     * \\param n_ids the number of ids in \\a ids\n+     *\/\n+    int (*subscribe_params) (void *object, uint32_t *ids, uint32_t n_ids);\n+\n+    \/**\n+     * Enumerate port parameters\n+     *\n+     * Start enumeration of port parameters. For each param, a\n+     * param event will be emitted.\n+     *\n+     * \\param seq a sequence number returned in the reply\n+     * \\param id the parameter id to enumerate\n+     * \\param start the start index or 0 for the first param\n+     * \\param num the maximum number of params to retrieve\n+     * \\param filter a param filter or NULL\n+     *\/\n+    int (*enum_params) (void *object, int seq,\n+            uint32_t id, uint32_t start, uint32_t num,\n+            const struct spa_pod *filter);\n+};\n+\n+#define pw_port_method(o,method,version,...)                \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)o,        \\\n+            struct pw_port_methods, _res,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define pw_port_add_listener(c,...)    pw_port_method(c,add_listener,0,__VA_ARGS__)\n+#define pw_port_subscribe_params(c,...)    pw_port_method(c,subscribe_params,0,__VA_ARGS__)\n+#define pw_port_enum_params(c,...)    pw_port_method(c,enum_params,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_PORT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/port.h","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROPERTIES_H\n+#define PIPEWIRE_PROPERTIES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+\n+#include <spa\/utils\/dict.h>\n+#include <spa\/utils\/string.h>\n+\n+\/** \\defgroup pw_properties Properties\n+ *\n+ * Properties are used to pass around arbitrary key\/value pairs.\n+ * Both keys and values are strings which keeps things simple.\n+ * Encoding of arbitrary values should be done by using a string\n+ * serialization such as base64 for binary blobs.\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_properties\n+ * \\{\n+ *\/\n+struct pw_properties {\n+    struct spa_dict dict;    \/**< dictionary of key\/values *\/\n+    uint32_t flags;        \/**< extra flags *\/\n+};\n+\n+struct pw_properties *\n+pw_properties_new(const char *key, ...) SPA_SENTINEL;\n+\n+struct pw_properties *\n+pw_properties_new_dict(const struct spa_dict *dict);\n+\n+struct pw_properties *\n+pw_properties_new_string(const char *args);\n+\n+struct pw_properties *\n+pw_properties_copy(const struct pw_properties *properties);\n+\n+int pw_properties_update_keys(struct pw_properties *props,\n+             const struct spa_dict *dict, const char * const keys[]);\n+int pw_properties_update_ignore(struct pw_properties *props,\n+        const struct spa_dict *dict, const char * const ignore[]);\n+\n+\/* Update props with all key\/value pairs from dict *\/\n+int pw_properties_update(struct pw_properties *props,\n+             const struct spa_dict *dict);\n+\/* Update props with all key\/value pairs from str *\/\n+int pw_properties_update_string(struct pw_properties *props,\n+        const char *str, size_t size);\n+\n+int pw_properties_add(struct pw_properties *oldprops,\n+             const struct spa_dict *dict);\n+int pw_properties_add_keys(struct pw_properties *oldprops,\n+             const struct spa_dict *dict, const char * const keys[]);\n+\n+void pw_properties_clear(struct pw_properties *properties);\n+\n+void\n+pw_properties_free(struct pw_properties *properties);\n+\n+int\n+pw_properties_set(struct pw_properties *properties, const char *key, const char *value);\n+\n+int\n+pw_properties_setf(struct pw_properties *properties,\n+           const char *key, const char *format, ...) SPA_PRINTF_FUNC(3, 4);\n+int\n+pw_properties_setva(struct pw_properties *properties,\n+           const char *key, const char *format, va_list args) SPA_PRINTF_FUNC(3,0);\n+const char *\n+pw_properties_get(const struct pw_properties *properties, const char *key);\n+\n+int\n+pw_properties_fetch_uint32(const struct pw_properties *properties, const char *key, uint32_t *value);\n+\n+int\n+pw_properties_fetch_int32(const struct pw_properties *properties, const char *key, int32_t *value);\n+\n+int\n+pw_properties_fetch_uint64(const struct pw_properties *properties, const char *key, uint64_t *value);\n+\n+int\n+pw_properties_fetch_int64(const struct pw_properties *properties, const char *key, int64_t *value);\n+\n+int\n+pw_properties_fetch_bool(const struct pw_properties *properties, const char *key, bool *value);\n+\n+static inline uint32_t\n+pw_properties_get_uint32(const struct pw_properties *properties, const char *key, uint32_t deflt)\n+{\n+    uint32_t val = deflt;\n+    pw_properties_fetch_uint32(properties, key, &val);\n+    return val;\n+}\n+\n+static inline int32_t\n+pw_properties_get_int32(const struct pw_properties *properties, const char *key, int32_t deflt)\n+{\n+    int32_t val = deflt;\n+    pw_properties_fetch_int32(properties, key, &val);\n+    return val;\n+}\n+\n+static inline uint64_t\n+pw_properties_get_uint64(const struct pw_properties *properties, const char *key, uint64_t deflt)\n+{\n+    uint64_t val = deflt;\n+    pw_properties_fetch_uint64(properties, key, &val);\n+    return val;\n+}\n+\n+static inline int64_t\n+pw_properties_get_int64(const struct pw_properties *properties, const char *key, int64_t deflt)\n+{\n+    int64_t val = deflt;\n+    pw_properties_fetch_int64(properties, key, &val);\n+    return val;\n+}\n+\n+\n+static inline bool\n+pw_properties_get_bool(const struct pw_properties *properties, const char *key, bool deflt)\n+{\n+    bool val = deflt;\n+    pw_properties_fetch_bool(properties, key, &val);\n+    return val;\n+}\n+\n+const char *\n+pw_properties_iterate(const struct pw_properties *properties, void **state);\n+\n+#define PW_PROPERTIES_FLAG_NL    (1<<0)\n+int pw_properties_serialize_dict(FILE *f, const struct spa_dict *dict, uint32_t flags);\n+\n+static inline bool pw_properties_parse_bool(const char *value) {\n+    return spa_atob(value);\n+}\n+\n+static inline int pw_properties_parse_int(const char *value) {\n+    int v;\n+    return spa_atoi32(value, &v, 0) ? v: 0;\n+}\n+\n+static inline int64_t pw_properties_parse_int64(const char *value) {\n+    int64_t v;\n+    return spa_atoi64(value, &v, 0) ? v : 0;\n+}\n+\n+static inline uint64_t pw_properties_parse_uint64(const char *value) {\n+    uint64_t v;\n+    return spa_atou64(value, &v, 0) ? v : 0;\n+}\n+\n+static inline float pw_properties_parse_float(const char *value) {\n+    float v;\n+    return spa_atof(value, &v) ? v : 0.0f;\n+}\n+\n+static inline double pw_properties_parse_double(const char *value) {\n+    double v;\n+    return spa_atod(value, &v) ? v : 0.0;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_PROPERTIES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/properties.h","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROTOCOL_H\n+#define PIPEWIRE_PROTOCOL_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/list.h>\n+\n+\/** \\defgroup pw_protocol Protocol\n+ *\n+ * \\brief Manages protocols and their implementation\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_protocol\n+ * \\{\n+ *\/\n+\n+struct pw_protocol;\n+\n+#include <pipewire\/context.h>\n+#include <pipewire\/properties.h>\n+#include <pipewire\/utils.h>\n+\n+#define PW_TYPE_INFO_Protocol        \"PipeWire:Protocol\"\n+#define PW_TYPE_INFO_PROTOCOL_BASE    PW_TYPE_INFO_Protocol \":\"\n+\n+struct pw_protocol_client {\n+    struct spa_list link;        \/**< link in protocol client_list *\/\n+    struct pw_protocol *protocol;    \/**< the owner protocol *\/\n+\n+    struct pw_core *core;\n+\n+    int (*connect) (struct pw_protocol_client *client,\n+            const struct spa_dict *props,\n+            void (*done_callback) (void *data, int result),\n+            void *data);\n+    int (*connect_fd) (struct pw_protocol_client *client, int fd, bool close);\n+    int (*steal_fd) (struct pw_protocol_client *client);\n+    void (*disconnect) (struct pw_protocol_client *client);\n+    void (*destroy) (struct pw_protocol_client *client);\n+    int (*set_paused) (struct pw_protocol_client *client, bool paused);\n+};\n+\n+#define pw_protocol_client_connect(c,p,cb,d)    ((c)->connect(c,p,cb,d))\n+#define pw_protocol_client_connect_fd(c,fd,cl)    ((c)->connect_fd(c,fd,cl))\n+#define pw_protocol_client_steal_fd(c)        ((c)->steal_fd(c))\n+#define pw_protocol_client_disconnect(c)    ((c)->disconnect(c))\n+#define pw_protocol_client_destroy(c)        ((c)->destroy(c))\n+#define pw_protocol_client_set_paused(c,p)    ((c)->set_paused(c,p))\n+\n+struct pw_protocol_server {\n+    struct spa_list link;        \/**< link in protocol server_list *\/\n+    struct pw_protocol *protocol;    \/**< the owner protocol *\/\n+\n+    struct pw_impl_core *core;\n+\n+    struct spa_list client_list;    \/**< list of clients of this protocol *\/\n+\n+    void (*destroy) (struct pw_protocol_server *listen);\n+};\n+\n+#define pw_protocol_server_destroy(l)    ((l)->destroy(l))\n+\n+struct pw_protocol_marshal {\n+    const char *type;        \/**< interface type *\/\n+    uint32_t version;        \/**< version *\/\n+#define PW_PROTOCOL_MARSHAL_FLAG_IMPL    (1 << 0)    \/**< marshal for implementations *\/\n+    uint32_t flags;            \/**< version *\/\n+    uint32_t n_client_methods;    \/**< number of client methods *\/\n+    uint32_t n_server_methods;    \/**< number of server methods *\/\n+    const void *client_marshal;\n+    const void *server_demarshal;\n+    const void *server_marshal;\n+    const void *client_demarshal;\n+};\n+\n+struct pw_protocol_implementation {\n+#define PW_VERSION_PROTOCOL_IMPLEMENTATION    0\n+    uint32_t version;\n+\n+    struct pw_protocol_client * (*new_client) (struct pw_protocol *protocol,\n+                           struct pw_core *core,\n+                           const struct spa_dict *props);\n+    struct pw_protocol_server * (*add_server) (struct pw_protocol *protocol,\n+                           struct pw_impl_core *core,\n+                           const struct spa_dict *props);\n+};\n+\n+struct pw_protocol_events {\n+#define PW_VERSION_PROTOCOL_EVENTS        0\n+    uint32_t version;\n+\n+    void (*destroy) (void *data);\n+};\n+\n+#define pw_protocol_new_client(p,...)    (pw_protocol_get_implementation(p)->new_client(p,__VA_ARGS__))\n+#define pw_protocol_add_server(p,...)    (pw_protocol_get_implementation(p)->add_server(p,__VA_ARGS__))\n+#define pw_protocol_ext(p,type,method,...)    (((type*)pw_protocol_get_extension(p))->method( __VA_ARGS__))\n+\n+struct pw_protocol *pw_protocol_new(struct pw_context *context, const char *name, size_t user_data_size);\n+\n+void pw_protocol_destroy(struct pw_protocol *protocol);\n+\n+struct pw_context *pw_protocol_get_context(struct pw_protocol *protocol);\n+\n+void *pw_protocol_get_user_data(struct pw_protocol *protocol);\n+\n+const struct pw_protocol_implementation *\n+pw_protocol_get_implementation(struct pw_protocol *protocol);\n+\n+const void *\n+pw_protocol_get_extension(struct pw_protocol *protocol);\n+\n+\n+void pw_protocol_add_listener(struct pw_protocol *protocol,\n+                              struct spa_hook *listener,\n+                              const struct pw_protocol_events *events,\n+                              void *data);\n+\n+int pw_protocol_add_marshal(struct pw_protocol *protocol,\n+                const struct pw_protocol_marshal *marshal);\n+\n+const struct pw_protocol_marshal *\n+pw_protocol_get_marshal(struct pw_protocol *protocol, const char *type, uint32_t version, uint32_t flags);\n+\n+struct pw_protocol * pw_context_find_protocol(struct pw_context *context, const char *name);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_PROTOCOL_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/protocol.h","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_PROXY_H\n+#define PIPEWIRE_PROXY_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\page page_proxy Proxy\n+ *\n+ * \\section sec_page_proxy_overview Overview\n+ *\n+ * The proxy object is a client side representation of a resource\n+ * that lives on a remote PipeWire instance.\n+ *\n+ * It is used to communicate with the remote object.\n+ *\n+ * \\section sec_page_proxy_core Core proxy\n+ *\n+ * A proxy for a remote core object can be obtained by making\n+ * a remote connection with \\ref pw_context_connect.\n+ * See \\ref pw_proxy\n+ *\n+ * Some methods on proxy object allow creation of more proxy objects or\n+ * create a binding between a local proxy and global resource.\n+ *\n+ * \\section sec_page_proxy_create Create\n+ *\n+ * A client first creates a new proxy object with pw_proxy_new(). A\n+ * type must be provided for this object.\n+ *\n+ * The protocol of the context will usually install an interface to\n+ * translate method calls and events to the wire format.\n+ *\n+ * The creator of the proxy will usually also install an event\n+ * implementation of the particular object type.\n+ *\n+ * \\section sec_page_proxy_bind Bind\n+ *\n+ * To actually use the proxy object, one needs to create a server\n+ * side resource for it. This can be done by, for example, binding\n+ * to a global object or by calling a method that creates and binds\n+ * to a new remote object. In all cases, the local id is passed to\n+ * the server and is used to create a resource with the same id.\n+ *\n+ * \\section sec_page_proxy_methods Methods\n+ *\n+ * To call a method on the proxy use the interface methods. Calling\n+ * any interface method will result in a request to the server to\n+ * perform the requested action on the corresponding resource.\n+ *\n+ * \\section sec_page_proxy_events Events\n+ *\n+ * Events send from the server to the proxy will be demarshalled by\n+ * the protocol and will then result in a call to the installed\n+ * implementation of the proxy.\n+ *\n+ * \\section sec_page_proxy_destroy Destroy\n+ *\n+ * Use pw_proxy_destroy() to destroy the client side object. This\n+ * is usually done automatically when the server removes the resource\n+ * associated to the proxy.\n+ *\/\n+\n+\/** \\defgroup pw_proxy Proxy\n+ *\n+ * \\brief Represents an object on the client side.\n+ *\n+ * A pw_proxy acts as a client side proxy to an object existing in a remote\n+ * pipewire instance. The proxy is responsible for converting interface functions\n+ * invoked by the client to PipeWire messages. Events will call the handlers\n+ * set in listener.\n+ *\n+ * See \\ref page_proxy\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_proxy\n+ * \\{\n+ *\/\n+struct pw_proxy;\n+\n+#include <pipewire\/protocol.h>\n+\n+\/** Proxy events, use \\ref pw_proxy_add_listener *\/\n+struct pw_proxy_events {\n+#define PW_VERSION_PROXY_EVENTS        1\n+        uint32_t version;\n+\n+    \/** The proxy is destroyed *\/\n+        void (*destroy) (void *data);\n+\n+    \/** a proxy is bound to a global id *\/\n+        void (*bound) (void *data, uint32_t global_id);\n+\n+    \/** a proxy is removed from the server. Use pw_proxy_destroy to\n+     * free the proxy. *\/\n+        void (*removed) (void *data);\n+\n+    \/** a reply to a sync method completed *\/\n+        void (*done) (void *data, int seq);\n+\n+    \/** an error occurred on the proxy *\/\n+        void (*error) (void *data, int seq, int res, const char *message);\n+\n+        void (*bound_props) (void *data, uint32_t global_id, const struct spa_dict *props);\n+};\n+\n+\/* Make a new proxy object. The id can be used to bind to a remote object and\n+ * can be retrieved with \\ref pw_proxy_get_id . *\/\n+struct pw_proxy *\n+pw_proxy_new(struct pw_proxy *factory,\n+         const char *type,        \/* interface type *\/\n+         uint32_t version,        \/* interface version *\/\n+         size_t user_data_size    \/* size of user data *\/);\n+\n+\/** Add an event listener to proxy *\/\n+void pw_proxy_add_listener(struct pw_proxy *proxy,\n+               struct spa_hook *listener,\n+               const struct pw_proxy_events *events,\n+               void *data);\n+\n+\/** Add a listener for the events received from the remote object. The\n+  * events depend on the type of the remote object type. *\/\n+void pw_proxy_add_object_listener(struct pw_proxy *proxy,    \/**< the proxy *\/\n+                 struct spa_hook *listener,    \/**< listener *\/\n+                 const void *funcs,        \/**< proxied functions *\/\n+                 void *data            \/**< data passed to events *\/);\n+\n+\/** destroy a proxy *\/\n+void pw_proxy_destroy(struct pw_proxy *proxy);\n+\n+void pw_proxy_ref(struct pw_proxy *proxy);\n+void pw_proxy_unref(struct pw_proxy *proxy);\n+\n+\/** Get the user_data. The size was given in \\ref pw_proxy_new *\/\n+void *pw_proxy_get_user_data(struct pw_proxy *proxy);\n+\n+\/** Get the local id of the proxy *\/\n+uint32_t pw_proxy_get_id(struct pw_proxy *proxy);\n+\n+\/** Get the type and version of the proxy *\/\n+const char *pw_proxy_get_type(struct pw_proxy *proxy, uint32_t *version);\n+\n+\/** Get the protocol used for the proxy *\/\n+struct pw_protocol *pw_proxy_get_protocol(struct pw_proxy *proxy);\n+\n+\/** Generate an sync method for a proxy. This will generate a done event\n+ * with the same seq number of the reply. *\/\n+int pw_proxy_sync(struct pw_proxy *proxy, int seq);\n+\n+\/** Set the global id this proxy is bound to. This is usually used internally\n+ * and will also emit the bound event *\/\n+int pw_proxy_set_bound_id(struct pw_proxy *proxy, uint32_t global_id);\n+\/** Get the global id bound to this proxy of SPA_ID_INVALID when not bound\n+ * to a global *\/\n+uint32_t pw_proxy_get_bound_id(struct pw_proxy *proxy);\n+\n+\/** Generate an error for a proxy *\/\n+int pw_proxy_error(struct pw_proxy *proxy, int res, const char *error);\n+int pw_proxy_errorf(struct pw_proxy *proxy, int res, const char *error, ...) SPA_PRINTF_FUNC(3, 4);\n+\n+\/** Get the listener of proxy *\/\n+struct spa_hook_list *pw_proxy_get_object_listeners(struct pw_proxy *proxy);\n+\n+\/** Get the marshal functions for the proxy *\/\n+const struct pw_protocol_marshal *pw_proxy_get_marshal(struct pw_proxy *proxy);\n+\n+\/** Install a marshal function on a proxy *\/\n+int pw_proxy_install_marshal(struct pw_proxy *proxy, bool implementor);\n+\n+#define pw_proxy_notify(p,type,event,version,...)            \\\n+    spa_hook_list_call(pw_proxy_get_object_listeners(p),        \\\n+            type, event, version, ## __VA_ARGS__)\n+\n+#define pw_proxy_call(p,type,method,version,...)            \\\n+    spa_interface_call((struct spa_interface*)p,            \\\n+            type, method, version, ##__VA_ARGS__)\n+\n+#define pw_proxy_call_res(p,type,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    spa_interface_call_res((struct spa_interface*)p,        \\\n+            type, _res, method, version, ##__VA_ARGS__);    \\\n+    _res;                                \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_PROXY_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/proxy.h","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,509 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_STREAM_H\n+#define PIPEWIRE_STREAM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\page page_streams Streams\n+ *\n+ * \\section sec_overview Overview\n+ *\n+ * \\ref pw_stream \"Streams\" are used to exchange data with the\n+ * PipeWire server. A stream is a wrapper around a proxy for a pw_client_node\n+ * with an adapter. This means the stream will automatically do conversion\n+ * to the type required by the server.\n+ *\n+ * Streams can be used to:\n+ *\n+ * \\li Consume a stream from PipeWire. This is a PW_DIRECTION_INPUT stream.\n+ * \\li Produce a stream to PipeWire. This is a PW_DIRECTION_OUTPUT stream\n+ *\n+ * You can connect the stream port to a specific server port or let PipeWire\n+ * choose a port for you.\n+ *\n+ * For more complicated nodes such as filters or ports with multiple\n+ * inputs and\/or outputs you will need to use the pw_filter or make\n+ * a pw_node yourself and export it with \\ref pw_core_export.\n+ *\n+ * Streams can also be used to:\n+ *\n+ * \\li Implement a Sink in PipeWire. This is a PW_DIRECTION_INPUT stream.\n+ * \\li Implement a Source in PipeWire. This is a PW_DIRECTION_OUTPUT stream\n+ *\n+ * In this case, the PW_KEY_MEDIA_CLASS property needs to be set to\n+ * \"Audio\/Sink\" or \"Audio\/Source\" respectively.\n+ *\n+ * \\section sec_create Create\n+ *\n+ * Make a new stream with \\ref pw_stream_new(). You will need to specify\n+ * a name for the stream and extra properties. The basic set of properties\n+ * each stream must provide is filled in automatically.\n+ *\n+ * Once the stream is created, the state_changed event should be used to\n+ * track the state of the stream.\n+ *\n+ * \\section sec_connect Connect\n+ *\n+ * The stream is initially unconnected. To connect the stream, use\n+ * \\ref pw_stream_connect(). Pass the desired direction as an argument.\n+ *\n+ * The direction is:\n+\n+ * \\li PW_DIRECTION_INPUT for a stream that *consumes* data. This can be a\n+ * stream that captures from a Source or a when the stream is used to\n+ * implement a Sink.\n+ *\n+ * \\li PW_DIRECTION_OUTPUT for a stream that *produces* data. This can be a\n+ * stream that plays to a Sink or when the stream is used to implement\n+ * a Source.\n+ *\n+ * \\subsection ssec_stream_target Stream target\n+ *\n+ * To make the newly connected stream automatically connect to an existing\n+ * PipeWire node, use the \\ref PW_STREAM_FLAG_AUTOCONNECT and set the\n+ * PW_KEY_OBJECT_SERIAL or the PW_KEY_NODE_NAME value of the target node\n+ * in the PW_KEY_TARGET_OBJECT property before connecting.\n+ *\n+ * \\subsection ssec_stream_formats Stream formats\n+ *\n+ * An array of possible formats that this stream can consume or provide\n+ * must be specified.\n+ *\n+ * \\section sec_format Format negotiation\n+ *\n+ * After connecting the stream, the server will want to configure some\n+ * parameters on the stream. You will be notified of these changes\n+ * with the param_changed event.\n+ *\n+ * When a format param change is emitted, the client should now prepare\n+ * itself to deal with the format and complete the negotiation procedure\n+ * with a call to \\ref pw_stream_update_params().\n+ *\n+ * As arguments to \\ref pw_stream_update_params() an array of spa_param\n+ * structures must be given. They contain parameters such as buffer size,\n+ * number of buffers, required metadata and other parameters for the\n+ * media buffers.\n+ *\n+ * \\section sec_buffers Buffer negotiation\n+ *\n+ * After completing the format negotiation, PipeWire will allocate and\n+ * notify the stream of the buffers that will be used to exchange data\n+ * between client and server.\n+ *\n+ * With the add_buffer event, a stream will be notified of a new buffer\n+ * that can be used for data transport. You can attach user_data to these\n+ * buffers. The buffers can only be used with the stream that emitted\n+ * the add_buffer event.\n+ *\n+ * After the buffers are negotiated, the stream will transition to the\n+ * \\ref PW_STREAM_STATE_PAUSED state.\n+ *\n+ * \\section sec_streaming Streaming\n+ *\n+ * From the \\ref PW_STREAM_STATE_PAUSED state, the stream can be set to\n+ * the \\ref PW_STREAM_STATE_STREAMING state by the PipeWire server when\n+ * data transport is started.\n+ *\n+ * Depending on how the stream was connected it will need to Produce or\n+ * Consume data for\/from PipeWire as explained in the following\n+ * subsections.\n+ *\n+ * \\subsection ssec_consume Consume data\n+ *\n+ * The process event is emitted for each new buffer that can be\n+ * consumed.\n+ *\n+ * \\ref pw_stream_dequeue_buffer() should be used to get the data and\n+ * metadata of the buffer.\n+ *\n+ * The buffer is owned by the stream and stays alive until the\n+ * remove_buffer callback has returned or the stream is destroyed.\n+ *\n+ * When the buffer has been processed, call \\ref pw_stream_queue_buffer()\n+ * to let PipeWire reuse the buffer.\n+ *\n+ * \\subsection ssec_produce Produce data\n+ *\n+ * \\ref pw_stream_dequeue_buffer() gives an empty buffer that can be filled.\n+ *\n+ * The buffer is owned by the stream and stays alive until the\n+ * remove_buffer event is emitted or the stream is destroyed.\n+ *\n+ * Filled buffers should be queued with \\ref pw_stream_queue_buffer().\n+ *\n+ * The process event is emitted when PipeWire has emptied a buffer that\n+ * can now be refilled.\n+ *\n+ * \\section sec_stream_disconnect Disconnect\n+ *\n+ * Use \\ref pw_stream_disconnect() to disconnect a stream after use.\n+ *\n+ * \\section sec_stream_configuration Configuration\n+ *\n+ * \\subsection ssec_config_properties Stream Properties\n+ *\n+ * \\subsection ssec_config_rules Stream Rules\n+ *\n+ * \\section sec_stream_environment Environment Variables\n+ *\n+ *\/\n+\/** \\defgroup pw_stream Stream\n+ *\n+ * \\brief PipeWire stream objects\n+ *\n+ * The stream object provides a convenient way to send and\n+ * receive data streams from\/to PipeWire.\n+ *\n+ * See also \\ref page_streams and \\ref api_pw_core\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_stream\n+ * \\{\n+ *\/\n+struct pw_stream;\n+\n+#include <spa\/buffer\/buffer.h>\n+#include <spa\/param\/param.h>\n+#include <spa\/pod\/command.h>\n+\n+\/** \\enum pw_stream_state The state of a stream *\/\n+enum pw_stream_state {\n+    PW_STREAM_STATE_ERROR = -1,        \/**< the stream is in error *\/\n+    PW_STREAM_STATE_UNCONNECTED = 0,    \/**< unconnected *\/\n+    PW_STREAM_STATE_CONNECTING = 1,        \/**< connection is in progress *\/\n+    PW_STREAM_STATE_PAUSED = 2,        \/**< paused *\/\n+    PW_STREAM_STATE_STREAMING = 3        \/**< streaming *\/\n+};\n+\n+\/** a buffer structure obtained from pw_stream_dequeue_buffer(). The size of this\n+  * structure can grow as more field are added in the future *\/\n+struct pw_buffer {\n+    struct spa_buffer *buffer;    \/**< the spa buffer *\/\n+    void *user_data;        \/**< user data attached to the buffer *\/\n+    uint64_t size;            \/**< This field is set by the user and the sum of\n+                      *  all queued buffer is returned in the time info.\n+                      *  For audio, it is advised to use the number of\n+                      *  samples in the buffer for this field. *\/\n+    uint64_t requested;        \/**< For playback streams, this field contains the\n+                      *  suggested amount of data to provide. For audio\n+                      *  streams this will be the amount of samples\n+                      *  required by the resampler. This field is 0\n+                      *  when no suggestion is provided. Since 0.3.49 *\/\n+};\n+\n+struct pw_stream_control {\n+    const char *name;        \/**< name of the control *\/\n+    uint32_t flags;            \/**< extra flags (unused) *\/\n+    float def;            \/**< default value *\/\n+    float min;            \/**< min value *\/\n+    float max;            \/**< max value *\/\n+    float *values;            \/**< array of values *\/\n+    uint32_t n_values;        \/**< number of values in array *\/\n+    uint32_t max_values;        \/**< max values that can be set on this control *\/\n+};\n+\n+\/** A time structure.\n+ *\n+ * Use pw_stream_get_time_n() to get an updated time snapshot of the stream.\n+ * The time snapshot can give information about the time in the driver of the\n+ * graph, the delay to the edge of the graph and the internal queuing in the\n+ * stream.\n+ *\n+ * pw_time.ticks gives a monotonic increasing counter of the time in the graph\n+ * driver. I can be used to generate a timetime to schedule samples as well\n+ * as detect discontinuities in the timeline caused by xruns.\n+ *\n+ * pw_time.delay is expressed as pw_time.rate, the time domain of the graph. This\n+ * value, and pw_time.ticks, were captured at pw_time.now and can be extrapolated\n+ * to the current time like this:\n+ *\n+ *    struct timespec ts;\n+ *    clock_gettime(CLOCK_MONOTONIC, &ts);\n+ *    int64_t diff = SPA_TIMESPEC_TO_NSEC(&ts) - pw_time.now;\n+ *    int64_t elapsed = (pw_time.rate.denom * diff) \/ (pw_time.rate.num * SPA_NSEC_PER_SEC);\n+ *\n+ * pw_time.delay contains the total delay that a signal will travel through the\n+ * graph. This includes the delay caused by filters in the graph as well as delays\n+ * caused by the hardware. The delay is usually quite stable and should only change when\n+ * the topology, quantum or samplerate of the graph changes.\n+ *\n+ * pw_time.queued and pw_time.buffered is expressed in the time domain of the stream,\n+ * or the format that is used for the buffers of this stream.\n+ *\n+ * pw_time.queued is the sum of all the pw_buffer.size fields of the buffers that are\n+ * currently queued in the stream but not yet processed. The application can choose\n+ * the units of this value, for example, time, samples or bytes (below expressed\n+ * as app.rate).\n+ *\n+ * pw_time.buffered is format dependent, for audio\/raw it contains the number of samples\n+ * that are buffered inside the resampler\/converter.\n+ *\n+ * The total delay of data in a stream is the sum of the queued and buffered data\n+ * (not yet processed data) and the delay to the edge of the graph, usually a\n+ * playback or capture device.\n+ *\n+ * For an audio playback stream, if you were to queue a buffer, the total delay\n+ * in milliseconds for the first sample in the newly queued buffer to be played\n+ * by the hardware can be calculated as:\n+ *\n+ *  (pw_time.buffered * 1000 \/ stream.samplerate) +\n+ *    (pw_time.queued * 1000 \/ app.rate) +\n+ *     ((pw_time.delay - elapsed) * 1000 * pw_time.rate.num \/ pw_time.rate.denom)\n+ *\n+ * The current extrapolated time (in ms) in the source or sink can be calculated as:\n+ *\n+ *  (pw_time.ticks + elapsed) * 1000 * pw_time.rate.num \/ pw_time.rate.denom\n+ *\n+ *\n+ *           stream time domain           graph time domain\n+ *         \/-----------------------\\\/-----------------------------\\\n+ *\n+ * queue     +-+ +-+  +-----------+                 +--------+\n+ * ---->     | | | |->| converter | ->   graph  ->  | kernel | -> speaker\n+ * <----     +-+ +-+  +-----------+                 +--------+\n+ * dequeue   buffers                \\-------------------\/\\--------\/\n+ *                                     graph              internal\n+ *                                    latency             latency\n+ *         \\--------\/\\-------------\/\\-----------------------------\/\n+ *           queued      buffered            delay\n+ *\/\n+struct pw_time {\n+    int64_t now;            \/**< the monotonic time in nanoseconds. This is the time\n+                      *  when this time report was updated. It is usually\n+                      *  updated every graph cycle. You can use the current\n+                      *  monotonic time to calculate the elapsed time between\n+                      *  this report and the current state and calculate\n+                      *  updated ticks and delay values. *\/\n+    struct spa_fraction rate;    \/**< the rate of \\a ticks and delay. This is usually\n+                      *  expressed in 1\/<samplerate>. *\/\n+    uint64_t ticks;            \/**< the ticks at \\a now. This is the current time that\n+                      *  the remote end is reading\/writing. This is monotonicaly\n+                      *  increasing. *\/\n+    int64_t delay;            \/**< delay to device. This is the time it will take for\n+                      *  the next output sample of the stream to be presented by\n+                      *  the playback device or the time a sample traveled\n+                      *  from the capture device. This delay includes the\n+                      *  delay introduced by all filters on the path between\n+                      *  the stream and the device. The delay is normally\n+                      *  constant in a graph and can change when the topology\n+                      *  of the graph or the quantum changes. This delay does\n+                      *  not include the delay caused by queued buffers. *\/\n+    uint64_t queued;        \/**< data queued in the stream, this is the sum\n+                      *  of the size fields in the pw_buffer that are\n+                      *  currently queued *\/\n+    uint64_t buffered;        \/**< for audio\/raw streams, this contains the extra\n+                      *  number of samples buffered in the resampler.\n+                      *  Since 0.3.50. *\/\n+    uint32_t queued_buffers;    \/**< The number of buffers that are queued. Since 0.3.50 *\/\n+    uint32_t avail_buffers;        \/**< The number of buffers that can be dequeued. Since 0.3.50 *\/\n+};\n+\n+#include <pipewire\/port.h>\n+\n+\/** Events for a stream. These events are always called from the mainloop\n+ * unless explicitly documented otherwise. *\/\n+struct pw_stream_events {\n+#define PW_VERSION_STREAM_EVENTS    2\n+    uint32_t version;\n+\n+    void (*destroy) (void *data);\n+    \/** when the stream state changes *\/\n+    void (*state_changed) (void *data, enum pw_stream_state old,\n+                enum pw_stream_state state, const char *error);\n+\n+    \/** Notify information about a control.  *\/\n+    void (*control_info) (void *data, uint32_t id, const struct pw_stream_control *control);\n+\n+    \/** when io changed on the stream. *\/\n+    void (*io_changed) (void *data, uint32_t id, void *area, uint32_t size);\n+    \/** when a parameter changed *\/\n+    void (*param_changed) (void *data, uint32_t id, const struct spa_pod *param);\n+\n+        \/** when a new buffer was created for this stream *\/\n+        void (*add_buffer) (void *data, struct pw_buffer *buffer);\n+        \/** when a buffer was destroyed for this stream *\/\n+        void (*remove_buffer) (void *data, struct pw_buffer *buffer);\n+\n+        \/** when a buffer can be queued (for playback streams) or\n+         *  dequeued (for capture streams). This is normally called from the\n+     *  mainloop but can also be called directly from the realtime data\n+     *  thread if the user is prepared to deal with this. *\/\n+        void (*process) (void *data);\n+\n+    \/** The stream is drained *\/\n+        void (*drained) (void *data);\n+\n+    \/** A command notify, Since 0.3.39:1 *\/\n+    void (*command) (void *data, const struct spa_command *command);\n+\n+    \/** a trigger_process completed. Since version 0.3.40:2 *\/\n+    void (*trigger_done) (void *data);\n+};\n+\n+\/** Convert a stream state to a readable string *\/\n+const char * pw_stream_state_as_string(enum pw_stream_state state);\n+\n+\/** \\enum pw_stream_flags Extra flags that can be used in \\ref pw_stream_connect() *\/\n+enum pw_stream_flags {\n+    PW_STREAM_FLAG_NONE = 0,            \/**< no flags *\/\n+    PW_STREAM_FLAG_AUTOCONNECT    = (1 << 0),    \/**< try to automatically connect\n+                              *  this stream *\/\n+    PW_STREAM_FLAG_INACTIVE        = (1 << 1),    \/**< start the stream inactive,\n+                              *  pw_stream_set_active() needs to be\n+                              *  called explicitly *\/\n+    PW_STREAM_FLAG_MAP_BUFFERS    = (1 << 2),    \/**< mmap the buffers except DmaBuf *\/\n+    PW_STREAM_FLAG_DRIVER        = (1 << 3),    \/**< be a driver *\/\n+    PW_STREAM_FLAG_RT_PROCESS    = (1 << 4),    \/**< call process from the realtime\n+                              *  thread. You MUST use RT safe functions\n+                              *  in the process callback. *\/\n+    PW_STREAM_FLAG_NO_CONVERT    = (1 << 5),    \/**< don't convert format *\/\n+    PW_STREAM_FLAG_EXCLUSIVE    = (1 << 6),    \/**< require exclusive access to the\n+                              *  device *\/\n+    PW_STREAM_FLAG_DONT_RECONNECT    = (1 << 7),    \/**< don't try to reconnect this stream\n+                              *  when the sink\/source is removed *\/\n+    PW_STREAM_FLAG_ALLOC_BUFFERS    = (1 << 8),    \/**< the application will allocate buffer\n+                              *  memory. In the add_buffer event, the\n+                              *  data of the buffer should be set *\/\n+    PW_STREAM_FLAG_TRIGGER        = (1 << 9),    \/**< the output stream will not be scheduled\n+                              *  automatically but _trigger_process()\n+                              *  needs to be called. This can be used\n+                              *  when the output of the stream depends\n+                              *  on input from other streams. *\/\n+};\n+\n+\/** Create a new unconneced \\ref pw_stream\n+ * \\return a newly allocated \\ref pw_stream *\/\n+struct pw_stream *\n+pw_stream_new(struct pw_core *core,        \/**< a \\ref pw_core *\/\n+          const char *name,            \/**< a stream media name *\/\n+          struct pw_properties *props    \/**< stream properties, ownership is taken *\/);\n+\n+struct pw_stream *\n+pw_stream_new_simple(struct pw_loop *loop,    \/**< a \\ref pw_loop to use *\/\n+             const char *name,        \/**< a stream media name *\/\n+             struct pw_properties *props,\/**< stream properties, ownership is taken *\/\n+             const struct pw_stream_events *events,    \/**< stream events *\/\n+             void *data                    \/**< data passed to events *\/);\n+\n+\/** Destroy a stream *\/\n+void pw_stream_destroy(struct pw_stream *stream);\n+\n+void pw_stream_add_listener(struct pw_stream *stream,\n+                struct spa_hook *listener,\n+                const struct pw_stream_events *events,\n+                void *data);\n+\n+enum pw_stream_state pw_stream_get_state(struct pw_stream *stream, const char **error);\n+\n+const char *pw_stream_get_name(struct pw_stream *stream);\n+\n+struct pw_core *pw_stream_get_core(struct pw_stream *stream);\n+\n+const struct pw_properties *pw_stream_get_properties(struct pw_stream *stream);\n+\n+int pw_stream_update_properties(struct pw_stream *stream, const struct spa_dict *dict);\n+\n+\/** Connect a stream for input or output on \\a port_path.\n+ * \\return 0 on success < 0 on error.\n+ *\n+ * You should connect to the process event and use pw_stream_dequeue_buffer()\n+ * to get the latest metadata and data. *\/\n+int\n+pw_stream_connect(struct pw_stream *stream,        \/**< a \\ref pw_stream *\/\n+          enum pw_direction direction,        \/**< the stream direction *\/\n+          uint32_t target_id,            \/**< should have the value PW_ID_ANY.\n+                              * To select a specific target\n+                              * node, specify the\n+                              * PW_KEY_OBJECT_SERIAL or the\n+                              * PW_KEY_NODE_NAME value of the target\n+                              * node in the PW_KEY_TARGET_OBJECT\n+                              * property of the stream.\n+                              * Specifying target nodes by\n+                              * their id is deprecated.\n+                              *\/\n+          enum pw_stream_flags flags,        \/**< stream flags *\/\n+          const struct spa_pod **params,    \/**< an array with params. The params\n+                              *  should ideally contain supported\n+                              *  formats. *\/\n+          uint32_t n_params            \/**< number of items in \\a params *\/);\n+\n+\/** Get the node ID of the stream.\n+ * \\return node ID. *\/\n+uint32_t\n+pw_stream_get_node_id(struct pw_stream *stream);\n+\n+\/** Disconnect \\a stream  *\/\n+int pw_stream_disconnect(struct pw_stream *stream);\n+\n+\/** Set the stream in error state *\/\n+int pw_stream_set_error(struct pw_stream *stream,    \/**< a \\ref pw_stream *\/\n+            int res,            \/**< a result code *\/\n+            const char *error,        \/**< an error message *\/\n+            ...) SPA_PRINTF_FUNC(3, 4);\n+\n+\/** Complete the negotiation process with result code \\a res\n+ *\n+ * This function should be called after notification of the format.\n+\n+ * When \\a res indicates success, \\a params contain the parameters for the\n+ * allocation state.  *\/\n+int\n+pw_stream_update_params(struct pw_stream *stream,    \/**< a \\ref pw_stream *\/\n+            const struct spa_pod **params,    \/**< an array of params. The params should\n+                              *  ideally contain parameters for doing\n+                              *  buffer allocation. *\/\n+            uint32_t n_params        \/**< number of elements in \\a params *\/);\n+\n+\/** Get control values *\/\n+const struct pw_stream_control *pw_stream_get_control(struct pw_stream *stream, uint32_t id);\n+\n+\/** Set control values *\/\n+int pw_stream_set_control(struct pw_stream *stream, uint32_t id, uint32_t n_values, float *values, ...);\n+\n+\/** Query the time on the stream *\/\n+int pw_stream_get_time_n(struct pw_stream *stream, struct pw_time *time, size_t size);\n+\n+\/** Query the time on the stream, deprecated since 0.3.50,\n+ * use pw_stream_get_time_n() to get the fields added since 0.3.50. *\/\n+SPA_DEPRECATED\n+int pw_stream_get_time(struct pw_stream *stream, struct pw_time *time);\n+\n+\/** Get a buffer that can be filled for playback streams or consumed\n+ * for capture streams. *\/\n+struct pw_buffer *pw_stream_dequeue_buffer(struct pw_stream *stream);\n+\n+\/** Submit a buffer for playback or recycle a buffer for capture. *\/\n+int pw_stream_queue_buffer(struct pw_stream *stream, struct pw_buffer *buffer);\n+\n+\/** Activate or deactivate the stream *\/\n+int pw_stream_set_active(struct pw_stream *stream, bool active);\n+\n+\/** Flush a stream. When \\a drain is true, the drained callback will\n+ * be called when all data is played or recorded *\/\n+int pw_stream_flush(struct pw_stream *stream, bool drain);\n+\n+\/** Check if the stream is driving. The stream needs to have the\n+ * PW_STREAM_FLAG_DRIVER set. When the stream is driving,\n+ * pw_stream_trigger_process() needs to be called when data is\n+ * available (output) or needed (input). Since 0.3.34 *\/\n+bool pw_stream_is_driving(struct pw_stream *stream);\n+\n+\/** Trigger a push\/pull on the stream. One iteration of the graph will\n+ * scheduled and process() will be called. Since 0.3.34 *\/\n+int pw_stream_trigger_process(struct pw_stream *stream);\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* PIPEWIRE_STREAM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/stream.h","additions":509,"deletions":0,"binary":false,"changes":509,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/* PipeWire *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef PIPEWIRE_UTILS_H\n+#define PIPEWIRE_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/un.h>\n+#ifndef _POSIX_C_SOURCE\n+# include <sys\/mount.h>\n+#endif\n+\n+#ifndef ENODATA\n+#define ENODATA 9919\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** \\defgroup pw_utils Utilities\n+ *\n+ * Various utility functions\n+ *\/\n+\n+\/**\n+ * \\addtogroup pw_utils\n+ * \\{\n+ *\/\n+\n+\/** a function to destroy an item *\/\n+typedef void (*pw_destroy_t) (void *object);\n+\n+const char *\n+pw_split_walk(const char *str, const char *delimiter, size_t *len, const char **state);\n+\n+char **\n+pw_split_strv(const char *str, const char *delimiter, int max_tokens, int *n_tokens);\n+\n+int\n+pw_split_ip(char *str, const char *delimiter, int max_tokens, char *tokens[]);\n+\n+void\n+pw_free_strv(char **str);\n+\n+char *\n+pw_strip(char *str, const char *whitespace);\n+\n+#if !defined(strndupa)\n+# define strndupa(s, n)                                      \\\n+    ({                                          \\\n+        const char *__old = (s);                          \\\n+        size_t __len = strnlen(__old, (n));                      \\\n+        char *__new = (char *) __builtin_alloca(__len + 1);              \\\n+        memcpy(__new, __old, __len);                          \\\n+        __new[__len] = '\\0';                              \\\n+        __new;                                      \\\n+    })\n+#endif\n+\n+#if !defined(strdupa)\n+# define strdupa(s)                                      \\\n+    ({                                          \\\n+        const char *__old = (s);                          \\\n+        size_t __len = strlen(__old) + 1;                      \\\n+        char *__new = (char *) alloca(__len);                      \\\n+        (char *) memcpy(__new, __old, __len);                      \\\n+    })\n+#endif\n+\n+SPA_WARN_UNUSED_RESULT\n+ssize_t pw_getrandom(void *buf, size_t buflen, unsigned int flags);\n+\n+void pw_random(void *buf, size_t buflen);\n+\n+#define pw_rand32() ({ uint32_t val; pw_random(&val, sizeof(val)); val; })\n+\n+void* pw_reallocarray(void *ptr, size_t nmemb, size_t size);\n+\n+#ifdef PW_ENABLE_DEPRECATED\n+#define PW_DEPRECATED(v)        (v)\n+#else\n+#define PW_DEPRECATED(v)    ({ __typeof__(v) _v SPA_DEPRECATED = (v); (void)_v; (v); })\n+#endif \/* PW_ENABLE_DEPRECATED *\/\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* PIPEWIRE_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/pipewire\/utils.h","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BUFFER_H\n+#define SPA_BUFFER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/buffer\/meta.h>\n+\n+\/** \\defgroup spa_buffer Buffers\n+ *\n+ * Buffers describe the data and metadata that is exchanged between\n+ * ports of a node.\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+enum spa_data_type {\n+    SPA_DATA_Invalid,\n+    SPA_DATA_MemPtr,        \/**< pointer to memory, the data field in\n+                      *  struct spa_data is set. *\/\n+    SPA_DATA_MemFd,            \/**< generic fd, mmap to get to memory *\/\n+    SPA_DATA_DmaBuf,        \/**< fd to dmabuf memory *\/\n+    SPA_DATA_MemId,            \/**< memory is identified with an id *\/\n+\n+    _SPA_DATA_LAST,            \/**< not part of ABI *\/\n+};\n+\n+\/** Chunk of memory, can change for each buffer *\/\n+struct spa_chunk {\n+    uint32_t offset;        \/**< offset of valid data. Should be taken\n+                      *  modulo the data maxsize to get the offset\n+                      *  in the data memory. *\/\n+    uint32_t size;            \/**< size of valid data. Should be clamped to\n+                      *  maxsize. *\/\n+    int32_t stride;            \/**< stride of valid data *\/\n+#define SPA_CHUNK_FLAG_NONE        0\n+#define SPA_CHUNK_FLAG_CORRUPTED    (1u<<0)    \/**< chunk data is corrupted in some way *\/\n+#define SPA_CHUNK_FLAG_EMPTY        (1u<<1)    \/**< chunk data is empty with media specific\n+                          *  neutral data such as silence or black. This\n+                          *  could be used to optimize processing. *\/\n+    int32_t flags;            \/**< chunk flags *\/\n+};\n+\n+\/** Data for a buffer this stays constant for a buffer *\/\n+struct spa_data {\n+    uint32_t type;            \/**< memory type, one of enum spa_data_type, when\n+                      *  allocating memory, the type contains a bitmask\n+                      *  of allowed types. SPA_ID_INVALID is a special\n+                      *  value for the allocator to indicate that the\n+                      *  other side did not explicitly specify any\n+                      *  supported data types. It should probably use\n+                      *  a memory type that does not require special\n+                      *  handling in addition to simple mmap\/munmap. *\/\n+#define SPA_DATA_FLAG_NONE     0\n+#define SPA_DATA_FLAG_READABLE    (1u<<0)    \/**< data is readable *\/\n+#define SPA_DATA_FLAG_WRITABLE    (1u<<1)    \/**< data is writable *\/\n+#define SPA_DATA_FLAG_DYNAMIC    (1u<<2)    \/**< data pointer can be changed *\/\n+#define SPA_DATA_FLAG_READWRITE    (SPA_DATA_FLAG_READABLE|SPA_DATA_FLAG_WRITABLE)\n+    uint32_t flags;            \/**< data flags *\/\n+    int64_t fd;            \/**< optional fd for data *\/\n+    uint32_t mapoffset;        \/**< offset to map fd at *\/\n+    uint32_t maxsize;        \/**< max size of data *\/\n+    void *data;            \/**< optional data pointer *\/\n+    struct spa_chunk *chunk;    \/**< valid chunk of memory *\/\n+};\n+\n+\/** A Buffer *\/\n+struct spa_buffer {\n+    uint32_t n_metas;        \/**< number of metadata *\/\n+    uint32_t n_datas;        \/**< number of data members *\/\n+    struct spa_meta *metas;        \/**< array of metadata *\/\n+    struct spa_data *datas;        \/**< array of data members *\/\n+};\n+\n+\/** Find metadata in a buffer *\/\n+static inline struct spa_meta *spa_buffer_find_meta(const struct spa_buffer *b, uint32_t type)\n+{\n+    uint32_t i;\n+\n+    for (i = 0; i < b->n_metas; i++)\n+        if (b->metas[i].type == type)\n+            return &b->metas[i];\n+\n+    return NULL;\n+}\n+\n+static inline void *spa_buffer_find_meta_data(const struct spa_buffer *b, uint32_t type, size_t size)\n+{\n+    struct spa_meta *m;\n+    if ((m = spa_buffer_find_meta(b, type)) && m->size >= size)\n+        return m->data;\n+    return NULL;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BUFFER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/buffer.h","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_META_H\n+#define SPA_META_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+enum spa_meta_type {\n+    SPA_META_Invalid,\n+    SPA_META_Header,        \/**< struct spa_meta_header *\/\n+    SPA_META_VideoCrop,        \/**< struct spa_meta_region with cropping data *\/\n+    SPA_META_VideoDamage,        \/**< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end. *\/\n+    SPA_META_Bitmap,        \/**< struct spa_meta_bitmap *\/\n+    SPA_META_Cursor,        \/**< struct spa_meta_cursor *\/\n+    SPA_META_Control,        \/**< metadata contains a spa_meta_control\n+                      *  associated with the data *\/\n+    SPA_META_Busy,            \/**< don't write to buffer when count > 0 *\/\n+    SPA_META_VideoTransform,    \/**< struct spa_meta_transform *\/\n+\n+    _SPA_META_LAST,            \/**< not part of ABI\/API *\/\n+};\n+\n+\/**\n+ * A metadata element.\n+ *\n+ * This structure is available on the buffer structure and contains\n+ * the type of the metadata and a pointer\/size to the actual metadata\n+ * itself.\n+ *\/\n+struct spa_meta {\n+    uint32_t type;        \/**< metadata type, one of enum spa_meta_type *\/\n+    uint32_t size;        \/**< size of metadata *\/\n+    void *data;        \/**< pointer to metadata *\/\n+};\n+\n+static inline void *spa_meta_first(const struct spa_meta *m) {\n+    return m->data;\n+}\n+#define spa_meta_first spa_meta_first\n+static inline void *spa_meta_end(const struct spa_meta *m) {\n+    return SPA_PTROFF(m->data,m->size,void);\n+}\n+#define spa_meta_end spa_meta_end\n+#define spa_meta_check(p,m)    (SPA_PTROFF(p,sizeof(*(p)),void) <= spa_meta_end(m))\n+\n+\/**\n+ * Describes essential buffer header metadata such as flags and\n+ * timestamps.\n+ *\/\n+struct spa_meta_header {\n+#define SPA_META_HEADER_FLAG_DISCONT    (1 << 0)    \/**< data is not continuous with previous buffer *\/\n+#define SPA_META_HEADER_FLAG_CORRUPTED    (1 << 1)    \/**< data might be corrupted *\/\n+#define SPA_META_HEADER_FLAG_MARKER    (1 << 2)    \/**< media specific marker *\/\n+#define SPA_META_HEADER_FLAG_HEADER    (1 << 3)    \/**< data contains a codec specific header *\/\n+#define SPA_META_HEADER_FLAG_GAP    (1 << 4)    \/**< data contains media neutral data *\/\n+#define SPA_META_HEADER_FLAG_DELTA_UNIT    (1 << 5)    \/**< cannot be decoded independently *\/\n+    uint32_t flags;                \/**< flags *\/\n+    uint32_t offset;            \/**< offset in current cycle *\/\n+    int64_t pts;                \/**< presentation timestamp in nanoseconds *\/\n+    int64_t dts_offset;            \/**< decoding timestamp as a difference with pts *\/\n+    uint64_t seq;                \/**< sequence number, increments with a\n+                          *  media specific frequency *\/\n+};\n+\n+\/** metadata structure for Region or an array of these for RegionArray *\/\n+struct spa_meta_region {\n+    struct spa_region region;\n+};\n+\n+static inline bool spa_meta_region_is_valid(const struct spa_meta_region *m) {\n+    return m->region.size.width != 0 && m->region.size.height != 0;\n+}\n+#define spa_meta_region_is_valid spa_meta_region_is_valid\n+\n+\/** iterate all the items in a metadata *\/\n+#define spa_meta_for_each(pos,meta)                    \\\n+    for ((pos) = (__typeof(pos))spa_meta_first(meta);            \\\n+        spa_meta_check(pos, meta);                    \\\n+            (pos)++)\n+\n+#define spa_meta_bitmap_is_valid(m)    ((m)->format != 0)\n+\n+\/**\n+ * Bitmap information\n+ *\n+ * This metadata contains a bitmap image in the given format and size.\n+ * It is typically used for cursor images or other small images that are\n+ * better transferred inline.\n+ *\/\n+struct spa_meta_bitmap {\n+    uint32_t format;        \/**< bitmap video format, one of enum spa_video_format. 0 is\n+                      *  and invalid format and should be handled as if there is\n+                      *  no new bitmap information. *\/\n+    struct spa_rectangle size;    \/**< width and height of bitmap *\/\n+    int32_t stride;            \/**< stride of bitmap data *\/\n+    uint32_t offset;        \/**< offset of bitmap data in this structure. An offset of\n+                      *  0 means no image data (invisible), an offset >=\n+                      *  sizeof(struct spa_meta_bitmap) contains valid bitmap\n+                      *  info. *\/\n+};\n+\n+#define spa_meta_cursor_is_valid(m)    ((m)->id != 0)\n+\n+\/**\n+ * Cursor information\n+ *\n+ * Metadata to describe the position and appearance of a pointing device.\n+ *\/\n+struct spa_meta_cursor {\n+    uint32_t id;            \/**< cursor id. an id of 0 is an invalid id and means that\n+                      *  there is no new cursor data *\/\n+    uint32_t flags;            \/**< extra flags *\/\n+    struct spa_point position;    \/**< position on screen *\/\n+    struct spa_point hotspot;    \/**< offsets for hotspot in bitmap, this field has no meaning\n+                      *  when there is no valid bitmap (see below) *\/\n+    uint32_t bitmap_offset;        \/**< offset of bitmap meta in this structure. When the offset\n+                      *  is 0, there is no new bitmap information. When the offset is\n+                      *  >= sizeof(struct spa_meta_cursor) there is a\n+                      *  struct spa_meta_bitmap at the offset. *\/\n+};\n+\n+\/** a timed set of events associated with the buffer *\/\n+struct spa_meta_control {\n+    struct spa_pod_sequence sequence;\n+};\n+\n+\/** a busy counter for the buffer *\/\n+struct spa_meta_busy {\n+    uint32_t flags;\n+    uint32_t count;            \/**< number of users busy with the buffer *\/\n+};\n+\n+enum spa_meta_videotransform_value {\n+    SPA_META_TRANSFORMATION_None = 0,    \/**< no transform *\/\n+    SPA_META_TRANSFORMATION_90,        \/**< 90 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_180,        \/**< 180 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_270,        \/**< 270 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped,    \/**< 180 degree flipped around the vertical axis. Equivalent\n+                          * to a reflexion through the vertical line splitting the\n+                          * bufffer in two equal sized parts *\/\n+    SPA_META_TRANSFORMATION_Flipped90,    \/**< flip then rotate around 90 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped180,    \/**< flip then rotate around 180 degree counter-clockwise *\/\n+    SPA_META_TRANSFORMATION_Flipped270,    \/**< flip then rotate around 270 degree counter-clockwise *\/\n+};\n+\n+\/** a transformation of the buffer *\/\n+struct spa_meta_videotransform {\n+    uint32_t transform;            \/**< orientation transformation that was applied to the buffer,\n+                          *  one of enum spa_meta_videotransform_value *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_META_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/meta.h","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BUFFER_TYPES_H\n+#define SPA_BUFFER_TYPES_H\n+\n+\/**\n+ * \\addtogroup spa_buffer\n+ * \\{\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/buffer\/buffer.h>\n+#include <spa\/buffer\/meta.h>\n+#include <spa\/utils\/type.h>\n+\n+#define SPA_TYPE_INFO_Buffer            SPA_TYPE_INFO_POINTER_BASE \"Buffer\"\n+#define SPA_TYPE_INFO_BUFFER_BASE        SPA_TYPE_INFO_Buffer \":\"\n+\n+\/** Buffers contain data of a certain type *\/\n+#define SPA_TYPE_INFO_Data            SPA_TYPE_INFO_ENUM_BASE \"Data\"\n+#define SPA_TYPE_INFO_DATA_BASE            SPA_TYPE_INFO_Data \":\"\n+\n+\/** base type for fd based memory *\/\n+#define SPA_TYPE_INFO_DATA_Fd            SPA_TYPE_INFO_DATA_BASE \"Fd\"\n+#define SPA_TYPE_INFO_DATA_FD_BASE        SPA_TYPE_INFO_DATA_Fd \":\"\n+\n+static const struct spa_type_info spa_type_data_type[] = {\n+    { SPA_DATA_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"Invalid\", NULL },\n+    { SPA_DATA_MemPtr, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"MemPtr\", NULL },\n+    { SPA_DATA_MemFd, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_FD_BASE \"MemFd\", NULL },\n+    { SPA_DATA_DmaBuf, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_FD_BASE \"DmaBuf\", NULL },\n+    { SPA_DATA_MemId, SPA_TYPE_Int, SPA_TYPE_INFO_DATA_BASE \"MemId\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_Meta            SPA_TYPE_INFO_POINTER_BASE \"Meta\"\n+#define SPA_TYPE_INFO_META_BASE            SPA_TYPE_INFO_Meta \":\"\n+\n+#define SPA_TYPE_INFO_META_Array        SPA_TYPE_INFO_META_BASE \"Array\"\n+#define SPA_TYPE_INFO_META_ARRAY_BASE        SPA_TYPE_INFO_META_Array \":\"\n+\n+#define SPA_TYPE_INFO_META_Region        SPA_TYPE_INFO_META_BASE \"Region\"\n+#define SPA_TYPE_INFO_META_REGION_BASE        SPA_TYPE_INFO_META_Region \":\"\n+\n+#define SPA_TYPE_INFO_META_ARRAY_Region        SPA_TYPE_INFO_META_ARRAY_BASE \"Region\"\n+#define SPA_TYPE_INFO_META_ARRAY_REGION_BASE    SPA_TYPE_INFO_META_ARRAY_Region \":\"\n+\n+static const struct spa_type_info spa_type_meta_type[] = {\n+    { SPA_META_Invalid, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Invalid\", NULL },\n+    { SPA_META_Header, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Header\", NULL },\n+    { SPA_META_VideoCrop, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_REGION_BASE \"VideoCrop\", NULL },\n+    { SPA_META_VideoDamage, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_ARRAY_REGION_BASE \"VideoDamage\", NULL },\n+    { SPA_META_Bitmap, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Bitmap\", NULL },\n+    { SPA_META_Cursor, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Cursor\", NULL },\n+    { SPA_META_Control, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Control\", NULL },\n+    { SPA_META_Busy, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"Busy\", NULL },\n+    { SPA_META_VideoTransform, SPA_TYPE_Pointer, SPA_TYPE_INFO_META_BASE \"VideoTransform\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BUFFER_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/buffer\/type-info.h","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_CONTROL_H\n+#define SPA_CONTROL_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** \\defgroup spa_control Control\n+ * Control type declarations\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_control\n+ * \\{\n+ *\/\n+\n+\/** Different Control types *\/\n+enum spa_control_type {\n+    SPA_CONTROL_Invalid,\n+    SPA_CONTROL_Properties,        \/**< data contains a SPA_TYPE_OBJECT_Props *\/\n+    SPA_CONTROL_Midi,        \/**< data contains a spa_pod_bytes with raw midi data *\/\n+    SPA_CONTROL_OSC,        \/**< data contains a spa_pod_bytes with an OSC packet *\/\n+\n+    _SPA_CONTROL_LAST,        \/**< not part of ABI *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_CONTROL_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/control\/control.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_CONTROL_TYPES_H\n+#define SPA_CONTROL_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_control\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/type-info.h>\n+#include <spa\/control\/control.h>\n+\n+\/* base for parameter object enumerations *\/\n+#define SPA_TYPE_INFO_Control        SPA_TYPE_INFO_ENUM_BASE \"Control\"\n+#define SPA_TYPE_INFO_CONTROL_BASE        SPA_TYPE_INFO_Control \":\"\n+\n+static const struct spa_type_info spa_type_control[] = {\n+    { SPA_CONTROL_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Invalid\", NULL },\n+    { SPA_CONTROL_Properties, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Properties\", NULL },\n+    { SPA_CONTROL_Midi, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"Midi\", NULL },\n+    { SPA_CONTROL_OSC, SPA_TYPE_Int, SPA_TYPE_INFO_CONTROL_BASE \"OSC\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_CONTROL_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/control\/type-info.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DEBUG_TYPES_H\n+#define SPA_DEBUG_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_debug\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type-info.h>\n+\n+#include <string.h>\n+\n+static inline const struct spa_type_info *spa_debug_type_find(const struct spa_type_info *info, uint32_t type)\n+{\n+    const struct spa_type_info *res;\n+\n+    if (info == NULL)\n+        info = SPA_TYPE_ROOT;\n+\n+    while (info && info->name) {\n+        if (info->type == SPA_ID_INVALID) {\n+            if (info->values && (res = spa_debug_type_find(info->values, type)))\n+                return res;\n+        }\n+        else if (info->type == type)\n+            return info;\n+        info++;\n+    }\n+    return NULL;\n+}\n+\n+static inline const char *spa_debug_type_short_name(const char *name)\n+{\n+    const char *h;\n+    if ((h = strrchr(name, ':')) != NULL)\n+        name = h + 1;\n+    return name;\n+}\n+\n+static inline const char *spa_debug_type_find_name(const struct spa_type_info *info, uint32_t type)\n+{\n+    if ((info = spa_debug_type_find(info, type)) == NULL)\n+        return NULL;\n+    return info->name;\n+}\n+\n+static inline const char *spa_debug_type_find_short_name(const struct spa_type_info *info, uint32_t type)\n+{\n+    const char *str;\n+    if ((str = spa_debug_type_find_name(info, type)) == NULL)\n+        return NULL;\n+    return spa_debug_type_short_name(str);\n+}\n+\n+static inline uint32_t spa_debug_type_find_type(const struct spa_type_info *info, const char *name)\n+{\n+    if (info == NULL)\n+        info = SPA_TYPE_ROOT;\n+\n+    while (info && info->name) {\n+        uint32_t res;\n+        if (strcmp(info->name, name) == 0)\n+            return info->type;\n+        if (info->values && (res = spa_debug_type_find_type(info->values, name)) != SPA_ID_INVALID)\n+            return res;\n+        info++;\n+    }\n+    return SPA_ID_INVALID;\n+}\n+\n+static inline const struct spa_type_info *spa_debug_type_find_short(const struct spa_type_info *info, const char *name)\n+{\n+    while (info && info->name) {\n+        if (strcmp(spa_debug_type_short_name(info->name), name) == 0)\n+            return info;\n+        if (strcmp(info->name, name) == 0)\n+            return info;\n+        if (info->type != 0 && info->type == (uint32_t)atoi(name))\n+            return info;\n+        info++;\n+    }\n+    return NULL;\n+}\n+\n+static inline uint32_t spa_debug_type_find_type_short(const struct spa_type_info *info, const char *name)\n+{\n+    if ((info = spa_debug_type_find_short(info, name)) == NULL)\n+        return SPA_ID_INVALID;\n+    return info->type;\n+}\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DEBUG_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/debug\/types.h","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_DEVICE_H\n+#define SPA_EVENT_DEVICE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/pod\/event.h>\n+\n+\/**\n+ * \\addtogroup spa_device\n+ * \\{\n+ *\/\n+\n+\/* object id of SPA_TYPE_EVENT_Device *\/\n+enum spa_device_event {\n+    SPA_DEVICE_EVENT_ObjectConfig,\n+};\n+\n+#define SPA_DEVICE_EVENT_ID(ev)    SPA_EVENT_ID(ev, SPA_TYPE_EVENT_Device)\n+#define SPA_DEVICE_EVENT_INIT(id) SPA_EVENT_INIT(SPA_TYPE_EVENT_Device, id)\n+\n+\/* properties for SPA_TYPE_EVENT_Device *\/\n+enum spa_event_device {\n+    SPA_EVENT_DEVICE_START,\n+\n+    SPA_EVENT_DEVICE_Object,    \/* an object id (Int) *\/\n+    SPA_EVENT_DEVICE_Props,        \/* properties for an object (SPA_TYPE_OBJECT_Props) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_DEVICE *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/monitor\/event.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2021 Collabora Ltd. *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DEVICE_TYPE_INFO_H\n+#define SPA_DEVICE_TYPE_INFO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type-info.h>\n+\n+#include <spa\/monitor\/event.h>\n+\n+\/**\n+ * \\addtogroup spa_device\n+ * \\{\n+ *\/\n+\n+#define SPA_TYPE_INFO_DeviceEvent        SPA_TYPE_INFO_EVENT_BASE \"Device\"\n+#define SPA_TYPE_INFO_DEVICE_EVENT_BASE        SPA_TYPE_INFO_DeviceEvent \":\"\n+\n+#define SPA_TYPE_INFO_DeviceEventId        SPA_TYPE_INFO_ENUM_BASE \"DeviceEventId\"\n+#define SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE    SPA_TYPE_INFO_DeviceEventId \":\"\n+\n+static const struct spa_type_info spa_type_device_event_id[] = {\n+    { SPA_DEVICE_EVENT_ObjectConfig, SPA_TYPE_EVENT_Device, SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE \"ObjectConfig\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_device_event[] = {\n+    { SPA_EVENT_DEVICE_START, SPA_TYPE_Id, SPA_TYPE_INFO_DEVICE_EVENT_BASE, spa_type_device_event_id },\n+    { SPA_EVENT_DEVICE_Object, SPA_TYPE_Int, SPA_TYPE_INFO_DEVICE_EVENT_BASE \"Object\", NULL },\n+    { SPA_EVENT_DEVICE_Props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_DEVICE_EVENT_BASE \"Props\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DEVICE_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/monitor\/type-info.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_COMMAND_NODE_H\n+#define SPA_COMMAND_NODE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/command.h>\n+\n+\/* object id of SPA_TYPE_COMMAND_Node *\/\n+enum spa_node_command {\n+    SPA_NODE_COMMAND_Suspend,    \/**< suspend a node, this removes all configured\n+                      * formats and closes any devices *\/\n+    SPA_NODE_COMMAND_Pause,        \/**< pause a node. this makes it stop emitting\n+                      *  scheduling events *\/\n+    SPA_NODE_COMMAND_Start,        \/**< start a node, this makes it start emitting\n+                      *  scheduling events *\/\n+    SPA_NODE_COMMAND_Enable,\n+    SPA_NODE_COMMAND_Disable,\n+    SPA_NODE_COMMAND_Flush,\n+    SPA_NODE_COMMAND_Drain,\n+    SPA_NODE_COMMAND_Marker,\n+    SPA_NODE_COMMAND_ParamBegin,    \/**< begin a set of parameter enumerations or\n+                      *  configuration that require the device to\n+                      *  remain opened, like query formats and then\n+                      *  set a format *\/\n+    SPA_NODE_COMMAND_ParamEnd,    \/**< end a transaction *\/\n+    SPA_NODE_COMMAND_RequestProcess,\/**< Sent to a driver when some other node emitted\n+                      *  the RequestProcess event. *\/\n+};\n+\n+#define SPA_NODE_COMMAND_ID(cmd)    SPA_COMMAND_ID(cmd, SPA_TYPE_COMMAND_Node)\n+#define SPA_NODE_COMMAND_INIT(id)    SPA_COMMAND_INIT(SPA_TYPE_COMMAND_Node, id)\n+\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_COMMAND_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/command.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_NODE_H\n+#define SPA_EVENT_NODE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/event.h>\n+\n+\/* object id of SPA_TYPE_EVENT_Node *\/\n+enum spa_node_event {\n+    SPA_NODE_EVENT_Error,\n+    SPA_NODE_EVENT_Buffering,\n+    SPA_NODE_EVENT_RequestRefresh,\n+    SPA_NODE_EVENT_RequestProcess,        \/*< Ask the driver to start processing\n+                         *  the graph *\/\n+};\n+\n+#define SPA_NODE_EVENT_ID(ev)    SPA_EVENT_ID(ev, SPA_TYPE_EVENT_Node)\n+#define SPA_NODE_EVENT_INIT(id) SPA_EVENT_INIT(SPA_TYPE_EVENT_Node, id)\n+\n+\/* properties for SPA_TYPE_EVENT_Node *\/\n+enum spa_event_node {\n+    SPA_EVENT_NODE_START,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_NODE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/event.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,290 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_IO_H\n+#define SPA_IO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/** IO areas\n+ *\n+ * IO information for a port on a node. This is allocated\n+ * by the host and configured on a node or all ports for which\n+ * IO is requested.\n+ *\n+ * The plugin will communicate with the host through the IO\n+ * areas.\n+ *\/\n+\n+\/** Different IO area types *\/\n+enum spa_io_type {\n+    SPA_IO_Invalid,\n+    SPA_IO_Buffers,        \/**< area to exchange buffers, struct spa_io_buffers *\/\n+    SPA_IO_Range,        \/**< expected byte range, struct spa_io_range *\/\n+    SPA_IO_Clock,        \/**< area to update clock information, struct spa_io_clock *\/\n+    SPA_IO_Latency,        \/**< latency reporting, struct spa_io_latency *\/\n+    SPA_IO_Control,        \/**< area for control messages, struct spa_io_sequence *\/\n+    SPA_IO_Notify,        \/**< area for notify messages, struct spa_io_sequence *\/\n+    SPA_IO_Position,    \/**< position information in the graph, struct spa_io_position *\/\n+    SPA_IO_RateMatch,    \/**< rate matching between nodes, struct spa_io_rate_match *\/\n+    SPA_IO_Memory,        \/**< memory pointer, struct spa_io_memory *\/\n+};\n+\n+\/**\n+ * IO area to exchange buffers.\n+ *\n+ * A set of buffers should first be configured on the node\/port.\n+ * Further references to those buffers will be made by using the\n+ * id of the buffer.\n+ *\n+ * If status is SPA_STATUS_OK, the host should ignore\n+ * the io area.\n+ *\n+ * If status is SPA_STATUS_NEED_DATA, the host should:\n+ * 1) recycle the buffer in buffer_id, if possible\n+ * 2) prepare a new buffer and place the id in buffer_id.\n+ *\n+ * If status is SPA_STATUS_HAVE_DATA, the host should consume\n+ * the buffer in buffer_id and set the state to\n+ * SPA_STATUS_NEED_DATA when new data is requested.\n+ *\n+ * If status is SPA_STATUS_STOPPED, some error occurred on the\n+ * port.\n+ *\n+ * If status is SPA_STATUS_DRAINED, data from the io area was\n+ * used to drain.\n+ *\n+ * Status can also be a negative errno value to indicate errors.\n+ * such as:\n+ * -EINVAL: buffer_id is invalid\n+ * -EPIPE: no more buffers available\n+ *\/\n+struct spa_io_buffers {\n+#define SPA_STATUS_OK            0\n+#define SPA_STATUS_NEED_DATA        (1<<0)\n+#define SPA_STATUS_HAVE_DATA        (1<<1)\n+#define SPA_STATUS_STOPPED        (1<<2)\n+#define SPA_STATUS_DRAINED        (1<<3)\n+    int32_t status;            \/**< the status code *\/\n+    uint32_t buffer_id;        \/**< a buffer id *\/\n+};\n+\n+#define SPA_IO_BUFFERS_INIT  ((struct spa_io_buffers) { SPA_STATUS_OK, SPA_ID_INVALID, })\n+\n+\/**\n+ * IO area to exchange a memory region\n+ *\/\n+struct spa_io_memory {\n+    int32_t status;            \/**< the status code *\/\n+    uint32_t size;            \/**< the size of \\a data *\/\n+    void *data;            \/**< a memory pointer *\/\n+};\n+#define SPA_IO_MEMORY_INIT  ((struct spa_io_memory) { SPA_STATUS_OK, 0, NULL, })\n+\n+\/** A range, suitable for input ports that can suggest a range to output ports *\/\n+struct spa_io_range {\n+    uint64_t offset;    \/**< offset in range *\/\n+    uint32_t min_size;    \/**< minimum size of data *\/\n+    uint32_t max_size;    \/**< maximum size of data *\/\n+};\n+\n+\/**\n+ * Absolute time reporting.\n+ *\n+ * Nodes that can report clocking information will receive this io block.\n+ * The application sets the id. This is usually set as part of the\n+ * position information but can also be set separately.\n+ *\n+ * The clock counts the elapsed time according to the clock provider\n+ * since the provider was last started.\n+ *\/\n+struct spa_io_clock {\n+#define SPA_IO_CLOCK_FLAG_FREEWHEEL (1u<<0)\n+    uint32_t flags;            \/**< clock flags *\/\n+    uint32_t id;            \/**< unique clock id, set by application *\/\n+    char name[64];            \/**< clock name prefixed with API, set by node. The clock name\n+                      *  is unique per clock and can be used to check if nodes\n+                      *  share the same clock. *\/\n+    uint64_t nsec;            \/**< time in nanoseconds against monotonic clock *\/\n+    struct spa_fraction rate;    \/**< rate for position\/duration\/delay *\/\n+    uint64_t position;        \/**< current position *\/\n+    uint64_t duration;        \/**< duration of current cycle *\/\n+    int64_t delay;            \/**< delay between position and hardware,\n+                      *  positive for capture, negative for playback *\/\n+    double rate_diff;        \/**< rate difference between clock and monotonic time *\/\n+    uint64_t next_nsec;        \/**< estimated next wakeup time in nanoseconds *\/\n+\n+    struct spa_fraction target_rate;    \/**< target rate of next cycle *\/\n+    uint64_t target_duration;        \/**< target duration of next cycle *\/\n+    uint32_t target_seq;            \/**< seq counter. must be equal at start and\n+                          *  end of read and lower bit must be 0 *\/\n+\n+    uint32_t padding[3];\n+};\n+\n+\/* the size of the video in this cycle *\/\n+struct spa_io_video_size {\n+#define SPA_IO_VIDEO_SIZE_VALID        (1<<0)\n+    uint32_t flags;            \/**< optional flags *\/\n+    uint32_t stride;        \/**< video stride in bytes *\/\n+    struct spa_rectangle size;    \/**< the video size *\/\n+    struct spa_fraction framerate;  \/**< the minimum framerate, the cycle duration is\n+                      *  always smaller to ensure there is only one\n+                      *  video frame per cycle. *\/\n+    uint32_t padding[4];\n+};\n+\n+\/** latency reporting *\/\n+struct spa_io_latency {\n+    struct spa_fraction rate;    \/**< rate for min\/max *\/\n+    uint64_t min;            \/**< min latency *\/\n+    uint64_t max;            \/**< max latency *\/\n+};\n+\n+\/** control stream, io area for SPA_IO_Control and SPA_IO_Notify *\/\n+struct spa_io_sequence {\n+    struct spa_pod_sequence sequence;    \/**< sequence of timed events *\/\n+};\n+\n+\/** bar and beat segment *\/\n+struct spa_io_segment_bar {\n+#define SPA_IO_SEGMENT_BAR_FLAG_VALID        (1<<0)\n+    uint32_t flags;            \/**< extra flags *\/\n+    uint32_t offset;        \/**< offset in segment of this beat *\/\n+    float signature_num;        \/**< time signature numerator *\/\n+    float signature_denom;        \/**< time signature denominator *\/\n+    double bpm;            \/**< beats per minute *\/\n+    double beat;            \/**< current beat in segment *\/\n+    uint32_t padding[8];\n+};\n+\n+\/** video frame segment *\/\n+struct spa_io_segment_video {\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_VALID        (1<<0)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME    (1<<1)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN    (1<<2)\n+#define SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED    (1<<3)\n+    uint32_t flags;            \/**< flags *\/\n+    uint32_t offset;        \/**< offset in segment *\/\n+    struct spa_fraction framerate;\n+    uint32_t hours;\n+    uint32_t minutes;\n+    uint32_t seconds;\n+    uint32_t frames;\n+    uint32_t field_count;        \/**< 0 for progressive, 1 and 2 for interlaced *\/\n+    uint32_t padding[11];\n+};\n+\n+\/**\n+ * A segment converts a running time to a segment (stream) position.\n+ *\n+ * The segment position is valid when the current running time is between\n+ * start and start + duration. The position is then\n+ * calculated as:\n+ *\n+ *   (running time - start) * rate + position;\n+ *\n+ * Support for looping is done by specifying the LOOPING flags with a\n+ * non-zero duration. When the running time reaches start + duration,\n+ * duration is added to start and the loop repeats.\n+ *\n+ * Care has to be taken when the running time + clock.duration extends\n+ * past the start + duration from the segment; the user should correctly\n+ * wrap around and partially repeat the loop in the current cycle.\n+ *\n+ * Extra information can be placed in the segment by setting the valid flags\n+ * and filling up the corresponding structures.\n+ *\/\n+struct spa_io_segment {\n+    uint32_t version;\n+#define SPA_IO_SEGMENT_FLAG_LOOPING    (1<<0)    \/**< after the duration, the segment repeats *\/\n+#define SPA_IO_SEGMENT_FLAG_NO_POSITION    (1<<1)    \/**< position is invalid. The position can be invalid\n+                          *  after a seek, for example, when the exact mapping\n+                          *  of the extra segment info (bar, video, ...) to\n+                          *  position has not been determined yet *\/\n+    uint32_t flags;                \/**< extra flags *\/\n+    uint64_t start;                \/**< value of running time when this\n+                          *  info is active. Can be in the future for\n+                          *  pending changes. It does not have to be in\n+                          *  exact multiples of the clock duration. *\/\n+    uint64_t duration;            \/**< duration when this info becomes invalid expressed\n+                          *  in running time. If the duration is 0, this\n+                          *  segment extends to the next segment. If the\n+                          *  segment becomes invalid and the looping flag is\n+                          *  set, the segment repeats. *\/\n+    double rate;                \/**< overall rate of the segment, can be negative for\n+                          *  backwards time reporting. *\/\n+    uint64_t position;            \/**< The position when the running time == start.\n+                          *  can be invalid when the owner of the extra segment\n+                          *  information has not yet made the mapping. *\/\n+\n+    struct spa_io_segment_bar bar;\n+    struct spa_io_segment_video video;\n+};\n+\n+enum spa_io_position_state {\n+    SPA_IO_POSITION_STATE_STOPPED,\n+    SPA_IO_POSITION_STATE_STARTING,\n+    SPA_IO_POSITION_STATE_RUNNING,\n+};\n+\n+\/** the maximum number of segments visible in the future *\/\n+#define SPA_IO_POSITION_MAX_SEGMENTS    8\n+\n+\/**\n+ * The position information adds extra meaning to the raw clock times.\n+ *\n+ * It is set on all nodes and the clock id will contain the clock of the\n+ * driving node in the graph.\n+ *\n+ * The position information contains 1 or more segments that convert the\n+ * raw clock times to a stream time. They are sorted based on their\n+ * start times, and thus the order in which they will activate in\n+ * the future. This makes it possible to look ahead in the scheduled\n+ * segments and anticipate the changes in the timeline.\n+ *\/\n+struct spa_io_position {\n+    struct spa_io_clock clock;        \/**< clock position of driver, always valid and\n+                          *  read only *\/\n+    struct spa_io_video_size video;        \/**< size of the video in the current cycle *\/\n+    int64_t offset;                \/**< an offset to subtract from the clock position\n+                          *  to get a running time. This is the time that\n+                          *  the state has been in the RUNNING state and the\n+                          *  time that should be used to compare the segment\n+                          *  start values against. *\/\n+    uint32_t state;                \/**< one of enum spa_io_position_state *\/\n+\n+    uint32_t n_segments;            \/**< number of segments *\/\n+    struct spa_io_segment segments[SPA_IO_POSITION_MAX_SEGMENTS];    \/**< segments *\/\n+};\n+\n+\/** rate matching *\/\n+struct spa_io_rate_match {\n+    uint32_t delay;            \/**< extra delay in samples for resampler *\/\n+    uint32_t size;            \/**< requested input size for resampler *\/\n+    double rate;            \/**< rate for resampler *\/\n+#define SPA_IO_RATE_MATCH_FLAG_ACTIVE    (1 << 0)\n+    uint32_t flags;            \/**< extra flags *\/\n+    uint32_t padding[7];\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_IO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/io.h","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_NODE_TYPES_H\n+#define SPA_NODE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_node\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type.h>\n+\n+#include <spa\/node\/command.h>\n+#include <spa\/node\/event.h>\n+#include <spa\/node\/io.h>\n+\n+#define SPA_TYPE_INFO_IO            SPA_TYPE_INFO_ENUM_BASE \"IO\"\n+#define SPA_TYPE_INFO_IO_BASE        SPA_TYPE_INFO_IO \":\"\n+\n+static const struct spa_type_info spa_type_io[] = {\n+    { SPA_IO_Invalid, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Invalid\", NULL },\n+    { SPA_IO_Buffers, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Buffers\", NULL },\n+    { SPA_IO_Range, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Range\", NULL },\n+    { SPA_IO_Clock, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Clock\", NULL },\n+    { SPA_IO_Latency, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Latency\", NULL },\n+    { SPA_IO_Control, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Control\", NULL },\n+    { SPA_IO_Notify, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Notify\", NULL },\n+    { SPA_IO_Position, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Position\", NULL },\n+    { SPA_IO_RateMatch, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"RateMatch\", NULL },\n+    { SPA_IO_Memory, SPA_TYPE_Int, SPA_TYPE_INFO_IO_BASE \"Memory\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_NodeEvent            SPA_TYPE_INFO_EVENT_BASE \"Node\"\n+#define SPA_TYPE_INFO_NODE_EVENT_BASE        SPA_TYPE_INFO_NodeEvent \":\"\n+\n+static const struct spa_type_info spa_type_node_event_id[] = {\n+    { SPA_NODE_EVENT_Error,         SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"Error\",   NULL },\n+    { SPA_NODE_EVENT_Buffering,     SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"Buffering\", NULL },\n+    { SPA_NODE_EVENT_RequestRefresh, SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"RequestRefresh\", NULL },\n+    { SPA_NODE_EVENT_RequestProcess, SPA_TYPE_EVENT_Node, SPA_TYPE_INFO_NODE_EVENT_BASE \"RequestProcess\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_node_event[] = {\n+    { SPA_EVENT_NODE_START, SPA_TYPE_Id, SPA_TYPE_INFO_NODE_EVENT_BASE, spa_type_node_event_id },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_NodeCommand            SPA_TYPE_INFO_COMMAND_BASE \"Node\"\n+#define SPA_TYPE_INFO_NODE_COMMAND_BASE        SPA_TYPE_INFO_NodeCommand \":\"\n+\n+static const struct spa_type_info spa_type_node_command_id[] = {\n+    { SPA_NODE_COMMAND_Suspend,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Suspend\", NULL },\n+    { SPA_NODE_COMMAND_Pause,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Pause\",   NULL },\n+    { SPA_NODE_COMMAND_Start,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Start\",   NULL },\n+    { SPA_NODE_COMMAND_Enable,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Enable\",  NULL },\n+    { SPA_NODE_COMMAND_Disable,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Disable\", NULL },\n+    { SPA_NODE_COMMAND_Flush,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Flush\",   NULL },\n+    { SPA_NODE_COMMAND_Drain,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Drain\",   NULL },\n+    { SPA_NODE_COMMAND_Marker,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"Marker\",  NULL },\n+    { SPA_NODE_COMMAND_ParamBegin,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"ParamBegin\",  NULL },\n+    { SPA_NODE_COMMAND_ParamEnd,    SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"ParamEnd\",  NULL },\n+    { SPA_NODE_COMMAND_RequestProcess, SPA_TYPE_COMMAND_Node, SPA_TYPE_INFO_NODE_COMMAND_BASE \"RequestProcess\",  NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_node_command[] = {\n+    { 0, SPA_TYPE_Id, SPA_TYPE_INFO_NODE_COMMAND_BASE, spa_type_node_command_id },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_NODE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/node\/type-info.h","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AAC_TYPES_H\n+#define SPA_AUDIO_AAC_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/aac.h>\n+\n+#define SPA_TYPE_INFO_AudioAACStreamFormat        SPA_TYPE_INFO_ENUM_BASE \"AudioAACStreamFormat\"\n+#define SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE    SPA_TYPE_INFO_AudioAACStreamFormat \":\"\n+\n+static const struct spa_type_info spa_type_audio_aac_stream_format[] = {\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_RAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"RAW\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP2ADTS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4ADTS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4LOAS\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4LATM\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_ADIF, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"ADIF\", NULL },\n+    { SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE \"MP4FF\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AAC_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/aac-types.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AAC_H\n+#define SPA_AUDIO_AAC_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_aac_stream_format {\n+    SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN,\n+    \/* Raw AAC frames *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_RAW,\n+    \/* ISO\/IEC 13818-7 MPEG-2 Audio Data Transport Stream (ADTS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS,\n+    \/* ISO\/IEC 14496-3 MPEG-4 Audio Data Transport Stream (ADTS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS,\n+    \/* ISO\/IEC 14496-3 Low Overhead Audio Stream (LOAS) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS,\n+    \/* ISO\/IEC 14496-3 Low Overhead Audio Transport Multiplex (LATM) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM,\n+    \/* ISO\/IEC 14496-3 Audio Data Interchange Format (ADIF) *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_ADIF,\n+    \/* ISO\/IEC 14496-12 MPEG-4 file format *\/\n+    SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF,\n+\n+    SPA_AUDIO_AAC_STREAM_FORMAT_CUSTOM = 0x10000,\n+};\n+\n+struct spa_audio_info_aac {\n+    uint32_t rate;                    \/*< sample rate *\/\n+    uint32_t channels;                \/*< number of channels *\/\n+    uint32_t bitrate;                \/*< stream bitrate *\/\n+    enum spa_audio_aac_stream_format stream_format;    \/*< AAC audio stream format *\/\n+};\n+\n+#define SPA_AUDIO_INFO_AAC_INIT(...)        ((struct spa_audio_info_aac) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AAC_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/aac.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AMR_TYPES_H\n+#define SPA_AUDIO_AMR_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/amr.h>\n+\n+#define SPA_TYPE_INFO_AudioAMRBandMode        SPA_TYPE_INFO_ENUM_BASE \"AudioAMRBandMode\"\n+#define SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE    SPA_TYPE_INFO_AudioAMRBandMode \":\"\n+\n+static const struct spa_type_info spa_type_audio_amr_band_mode[] = {\n+    { SPA_AUDIO_AMR_BAND_MODE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_AMR_BAND_MODE_NB, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"NB\", NULL },\n+    { SPA_AUDIO_AMR_BAND_MODE_WB, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE \"WB\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AMR_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/amr-types.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_AMR_H\n+#define SPA_AUDIO_AMR_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_amr_band_mode {\n+    SPA_AUDIO_AMR_BAND_MODE_UNKNOWN,\n+    SPA_AUDIO_AMR_BAND_MODE_NB,\n+    SPA_AUDIO_AMR_BAND_MODE_WB,\n+};\n+\n+struct spa_audio_info_amr {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    enum spa_audio_amr_band_mode band_mode;\n+};\n+\n+#define SPA_AUDIO_INFO_AMR_INIT(...)        ((struct spa_audio_info_amr) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_AMR_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/amr.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_IEC958_TYPES_H\n+#define SPA_AUDIO_IEC958_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/iec958.h>\n+\n+#define SPA_TYPE_INFO_AudioIEC958Codec        SPA_TYPE_INFO_ENUM_BASE \"AudioIEC958Codec\"\n+#define SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE    SPA_TYPE_INFO_AudioIEC958Codec \":\"\n+\n+static const struct spa_type_info spa_type_audio_iec958_codec[] = {\n+    { SPA_AUDIO_IEC958_CODEC_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_PCM, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"PCM\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_DTS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"DTS\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_AC3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"AC3\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_MPEG, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"MPEG\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_MPEG2_AAC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"MPEG2-AAC\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_EAC3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"EAC3\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_TRUEHD, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"TrueHD\", NULL },\n+    { SPA_AUDIO_IEC958_CODEC_DTSHD, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE \"DTS-HD\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_IEC958_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/iec958-types.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2021 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_IEC958_H\n+#define SPA_AUDIO_IEC958_H\n+\n+#include <stdint.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+enum spa_audio_iec958_codec {\n+    SPA_AUDIO_IEC958_CODEC_UNKNOWN,\n+\n+    SPA_AUDIO_IEC958_CODEC_PCM,\n+    SPA_AUDIO_IEC958_CODEC_DTS,\n+    SPA_AUDIO_IEC958_CODEC_AC3,\n+    SPA_AUDIO_IEC958_CODEC_MPEG,        \/**< MPEG-1 or MPEG-2 (Part 3, not AAC) *\/\n+    SPA_AUDIO_IEC958_CODEC_MPEG2_AAC,    \/**< MPEG-2 AAC *\/\n+\n+    SPA_AUDIO_IEC958_CODEC_EAC3,\n+\n+    SPA_AUDIO_IEC958_CODEC_TRUEHD,        \/**< Dolby TrueHD *\/\n+    SPA_AUDIO_IEC958_CODEC_DTSHD,        \/**< DTS-HD Master Audio *\/\n+};\n+\n+struct spa_audio_info_iec958 {\n+    enum spa_audio_iec958_codec codec;    \/*< format, one of the DSP formats in enum spa_audio_format_dsp *\/\n+    uint32_t flags;                \/*< extra flags *\/\n+    uint32_t rate;                \/*< sample rate *\/\n+};\n+\n+#define SPA_AUDIO_INFO_IEC958_INIT(...)        ((struct spa_audio_info_iec958) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_IEC958_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/iec958.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_MP3_TYPES_H\n+#define SPA_AUDIO_MP3_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/mp3.h>\n+\n+#define SPA_TYPE_INFO_AudioMP3ChannelMode        SPA_TYPE_INFO_ENUM_BASE \"AudioMP3ChannelMode\"\n+#define SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE    SPA_TYPE_INFO_AudioMP3ChannelMode \":\"\n+\n+static const struct spa_type_info spa_type_audio_mp3_channel_mode[] = {\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_MONO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Mono\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_STEREO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Stereo\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Joint-stereo\", NULL },\n+    { SPA_AUDIO_MP3_CHANNEL_MODE_DUAL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE \"Dual\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_MP3_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/mp3-types.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_MP3_H\n+#define SPA_AUDIO_MP3_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_mp3_channel_mode {\n+    SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_MONO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_STEREO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO,\n+    SPA_AUDIO_MP3_CHANNEL_MODE_DUAL,\n+};\n+\n+struct spa_audio_info_mp3 {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+};\n+\n+#define SPA_AUDIO_INFO_MP3_INIT(...)        ((struct spa_audio_info_mp3) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_MP3_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/mp3.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_RAW_TYPES_H\n+#define SPA_AUDIO_RAW_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/raw.h>\n+\n+#define SPA_TYPE_INFO_AudioFormat        SPA_TYPE_INFO_ENUM_BASE \"AudioFormat\"\n+#define SPA_TYPE_INFO_AUDIO_FORMAT_BASE        SPA_TYPE_INFO_AudioFormat \":\"\n+\n+static const struct spa_type_info spa_type_audio_format[] = {\n+    { SPA_AUDIO_FORMAT_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_FORMAT_ENCODED, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ENCODED\", NULL },\n+    { SPA_AUDIO_FORMAT_S8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S8\", NULL },\n+    { SPA_AUDIO_FORMAT_U8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U8\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20BE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18LE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18BE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18LE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18BE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32LE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32BE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_LE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64LE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_BE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64BE\", NULL },\n+\n+    { SPA_AUDIO_FORMAT_ULAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ULAW\", NULL },\n+    { SPA_AUDIO_FORMAT_ALAW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"ALAW\", NULL },\n+\n+    { SPA_AUDIO_FORMAT_U8P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U8P\", NULL },\n+    { SPA_AUDIO_FORMAT_S16P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16P\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32P\", NULL },\n+    { SPA_AUDIO_FORMAT_S32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32P\", NULL },\n+    { SPA_AUDIO_FORMAT_S24P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24P\", NULL },\n+    { SPA_AUDIO_FORMAT_F32P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32P\", NULL },\n+    { SPA_AUDIO_FORMAT_F64P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64P\", NULL },\n+    { SPA_AUDIO_FORMAT_S8P, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S8P\", NULL },\n+\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    { SPA_AUDIO_FORMAT_S16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64\", NULL },\n+#elif __BYTE_ORDER == __LITTLE_ENDIAN\n+    { SPA_AUDIO_FORMAT_S16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16\", NULL },\n+    { SPA_AUDIO_FORMAT_S16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16\", NULL },\n+    { SPA_AUDIO_FORMAT_U16_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U16OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24_32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32\", NULL },\n+    { SPA_AUDIO_FORMAT_S32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32\", NULL },\n+    { SPA_AUDIO_FORMAT_U32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24\", NULL },\n+    { SPA_AUDIO_FORMAT_S24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24\", NULL },\n+    { SPA_AUDIO_FORMAT_U24_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U24OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20\", NULL },\n+    { SPA_AUDIO_FORMAT_S20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20\", NULL },\n+    { SPA_AUDIO_FORMAT_U20_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U20OE\", NULL },\n+    { SPA_AUDIO_FORMAT_S18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18\", NULL },\n+    { SPA_AUDIO_FORMAT_S18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"S18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_U18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18\", NULL },\n+    { SPA_AUDIO_FORMAT_U18_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"U18OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32\", NULL },\n+    { SPA_AUDIO_FORMAT_F32_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F32OE\", NULL },\n+    { SPA_AUDIO_FORMAT_F64, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64\", NULL },\n+    { SPA_AUDIO_FORMAT_F64_OE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FORMAT_BASE \"F64OE\", NULL },\n+#endif\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_AudioFlags    SPA_TYPE_INFO_FLAGS_BASE \"AudioFlags\"\n+#define SPA_TYPE_INFO_AUDIO_FLAGS_BASE    SPA_TYPE_INFO_AudioFlags \":\"\n+\n+static const struct spa_type_info spa_type_audio_flags[] = {\n+    { SPA_AUDIO_FLAG_NONE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FLAGS_BASE \"none\", NULL },\n+    { SPA_AUDIO_FLAG_UNPOSITIONED, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_FLAGS_BASE \"unpositioned\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_AudioChannel        SPA_TYPE_INFO_ENUM_BASE \"AudioChannel\"\n+#define SPA_TYPE_INFO_AUDIO_CHANNEL_BASE    SPA_TYPE_INFO_AudioChannel \":\"\n+\n+static const struct spa_type_info spa_type_audio_channel[] = {\n+    { SPA_AUDIO_CHANNEL_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"UNK\", NULL },\n+    { SPA_AUDIO_CHANNEL_NA,    SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"NA\", NULL },\n+    { SPA_AUDIO_CHANNEL_MONO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"MONO\", NULL },\n+    { SPA_AUDIO_CHANNEL_FL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FL\", NULL },\n+    { SPA_AUDIO_CHANNEL_FR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FR\", NULL },\n+    { SPA_AUDIO_CHANNEL_FC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FC\", NULL },\n+    { SPA_AUDIO_CHANNEL_LFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LFE\", NULL },\n+    { SPA_AUDIO_CHANNEL_SL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"SL\", NULL },\n+    { SPA_AUDIO_CHANNEL_SR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"SR\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RL\", NULL },\n+    { SPA_AUDIO_CHANNEL_RR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RR\", NULL },\n+    { SPA_AUDIO_CHANNEL_TC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFR\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TRR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TRR\", NULL },\n+    { SPA_AUDIO_CHANNEL_RLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_RRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLW\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRW, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRW\", NULL },\n+    { SPA_AUDIO_CHANNEL_LFE2, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LFE2\", NULL },\n+    { SPA_AUDIO_CHANNEL_FLH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FLH\", NULL },\n+    { SPA_AUDIO_CHANNEL_FCH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FCH\", NULL },\n+    { SPA_AUDIO_CHANNEL_FRH, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"FRH\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TFRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TFRC\", NULL },\n+    { SPA_AUDIO_CHANNEL_TSL, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TSL\", NULL },\n+    { SPA_AUDIO_CHANNEL_TSR, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"TSR\", NULL },\n+    { SPA_AUDIO_CHANNEL_LLFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"LLFR\", NULL },\n+    { SPA_AUDIO_CHANNEL_RLFE, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"RLFE\", NULL },\n+    { SPA_AUDIO_CHANNEL_BC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BC\", NULL },\n+    { SPA_AUDIO_CHANNEL_BLC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BLC\", NULL },\n+    { SPA_AUDIO_CHANNEL_BRC, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"BRC\", NULL },\n+\n+    { SPA_AUDIO_CHANNEL_AUX0, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX0\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX1, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX1\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX2, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX2\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX3, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX3\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX4, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX4\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX5, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX5\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX6, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX6\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX7, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX7\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX8\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX9, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX9\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX10, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX10\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX11, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX11\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX12, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX12\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX13, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX13\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX14, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX14\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX15, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX15\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX16, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX16\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX17, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX17\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX18, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX18\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX19, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX19\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX20, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX20\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX21, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX21\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX22, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX22\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX23, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX23\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX24, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX24\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX25, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX25\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX26, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX26\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX27, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX27\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX28, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX28\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX29, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX29\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX30, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX30\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX31, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX31\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX32, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX32\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX33, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX33\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX34, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX34\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX35, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX35\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX36, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX36\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX37, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX37\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX38, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX38\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX39, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX39\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX40, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX40\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX41, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX41\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX42, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX42\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX43, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX43\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX44, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX44\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX45, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX45\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX46, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX46\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX47, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX47\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX48, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX48\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX49, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX49\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX50, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX50\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX51, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX51\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX52, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX52\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX53, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX53\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX54, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX54\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX55, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX55\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX56, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX56\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX57, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX57\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX58, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX58\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX59, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX59\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX60, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX60\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX61, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX61\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX62, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX62\", NULL },\n+    { SPA_AUDIO_CHANNEL_AUX63, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_CHANNEL_BASE \"AUX63\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_RAW_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/raw-types.h","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_RAW_H\n+#define SPA_AUDIO_RAW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+\n+#if !defined(__FreeBSD__) && !defined(__MidnightBSD__)\n+#include <endian.h>\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#define SPA_AUDIO_MAX_CHANNELS    64u\n+\n+enum spa_audio_format {\n+    SPA_AUDIO_FORMAT_UNKNOWN,\n+    SPA_AUDIO_FORMAT_ENCODED,\n+\n+    \/* interleaved formats *\/\n+    SPA_AUDIO_FORMAT_START_Interleaved    = 0x100,\n+    SPA_AUDIO_FORMAT_S8,\n+    SPA_AUDIO_FORMAT_U8,\n+    SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64_LE,\n+    SPA_AUDIO_FORMAT_F64_BE,\n+\n+    SPA_AUDIO_FORMAT_ULAW,\n+    SPA_AUDIO_FORMAT_ALAW,\n+\n+    \/* planar formats *\/\n+    SPA_AUDIO_FORMAT_START_Planar        = 0x200,\n+    SPA_AUDIO_FORMAT_U8P,\n+    SPA_AUDIO_FORMAT_S16P,\n+    SPA_AUDIO_FORMAT_S24_32P,\n+    SPA_AUDIO_FORMAT_S32P,\n+    SPA_AUDIO_FORMAT_S24P,\n+    SPA_AUDIO_FORMAT_F32P,\n+    SPA_AUDIO_FORMAT_F64P,\n+    SPA_AUDIO_FORMAT_S8P,\n+\n+    \/* other formats start here *\/\n+    SPA_AUDIO_FORMAT_START_Other        = 0x400,\n+\n+    \/* Aliases *\/\n+\n+    \/* DSP formats *\/\n+    SPA_AUDIO_FORMAT_DSP_S32 = SPA_AUDIO_FORMAT_S24_32P,\n+    SPA_AUDIO_FORMAT_DSP_F32 = SPA_AUDIO_FORMAT_F32P,\n+    SPA_AUDIO_FORMAT_DSP_F64 = SPA_AUDIO_FORMAT_F64P,\n+\n+    \/* native endian *\/\n+#if __BYTE_ORDER == __BIG_ENDIAN\n+    SPA_AUDIO_FORMAT_S16 = SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16 = SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32 = SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32 = SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32 = SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32 = SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24 = SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24 = SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20 = SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20 = SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18 = SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18 = SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32 = SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64 = SPA_AUDIO_FORMAT_F64_BE,\n+    SPA_AUDIO_FORMAT_S16_OE = SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_U16_OE = SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_S24_32_OE = SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32_OE = SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_S32_OE = SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_U32_OE = SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_S24_OE = SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_U24_OE = SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_S20_OE = SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_U20_OE = SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_S18_OE = SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_U18_OE = SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_F32_OE = SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F64_OE = SPA_AUDIO_FORMAT_F64_LE,\n+#elif __BYTE_ORDER == __LITTLE_ENDIAN\n+    SPA_AUDIO_FORMAT_S16 = SPA_AUDIO_FORMAT_S16_LE,\n+    SPA_AUDIO_FORMAT_U16 = SPA_AUDIO_FORMAT_U16_LE,\n+    SPA_AUDIO_FORMAT_S24_32 = SPA_AUDIO_FORMAT_S24_32_LE,\n+    SPA_AUDIO_FORMAT_U24_32 = SPA_AUDIO_FORMAT_U24_32_LE,\n+    SPA_AUDIO_FORMAT_S32 = SPA_AUDIO_FORMAT_S32_LE,\n+    SPA_AUDIO_FORMAT_U32 = SPA_AUDIO_FORMAT_U32_LE,\n+    SPA_AUDIO_FORMAT_S24 = SPA_AUDIO_FORMAT_S24_LE,\n+    SPA_AUDIO_FORMAT_U24 = SPA_AUDIO_FORMAT_U24_LE,\n+    SPA_AUDIO_FORMAT_S20 = SPA_AUDIO_FORMAT_S20_LE,\n+    SPA_AUDIO_FORMAT_U20 = SPA_AUDIO_FORMAT_U20_LE,\n+    SPA_AUDIO_FORMAT_S18 = SPA_AUDIO_FORMAT_S18_LE,\n+    SPA_AUDIO_FORMAT_U18 = SPA_AUDIO_FORMAT_U18_LE,\n+    SPA_AUDIO_FORMAT_F32 = SPA_AUDIO_FORMAT_F32_LE,\n+    SPA_AUDIO_FORMAT_F64 = SPA_AUDIO_FORMAT_F64_LE,\n+    SPA_AUDIO_FORMAT_S16_OE = SPA_AUDIO_FORMAT_S16_BE,\n+    SPA_AUDIO_FORMAT_U16_OE = SPA_AUDIO_FORMAT_U16_BE,\n+    SPA_AUDIO_FORMAT_S24_32_OE = SPA_AUDIO_FORMAT_S24_32_BE,\n+    SPA_AUDIO_FORMAT_U24_32_OE = SPA_AUDIO_FORMAT_U24_32_BE,\n+    SPA_AUDIO_FORMAT_S32_OE = SPA_AUDIO_FORMAT_S32_BE,\n+    SPA_AUDIO_FORMAT_U32_OE = SPA_AUDIO_FORMAT_U32_BE,\n+    SPA_AUDIO_FORMAT_S24_OE = SPA_AUDIO_FORMAT_S24_BE,\n+    SPA_AUDIO_FORMAT_U24_OE = SPA_AUDIO_FORMAT_U24_BE,\n+    SPA_AUDIO_FORMAT_S20_OE = SPA_AUDIO_FORMAT_S20_BE,\n+    SPA_AUDIO_FORMAT_U20_OE = SPA_AUDIO_FORMAT_U20_BE,\n+    SPA_AUDIO_FORMAT_S18_OE = SPA_AUDIO_FORMAT_S18_BE,\n+    SPA_AUDIO_FORMAT_U18_OE = SPA_AUDIO_FORMAT_U18_BE,\n+    SPA_AUDIO_FORMAT_F32_OE = SPA_AUDIO_FORMAT_F32_BE,\n+    SPA_AUDIO_FORMAT_F64_OE = SPA_AUDIO_FORMAT_F64_BE,\n+#endif\n+};\n+\n+#define SPA_AUDIO_FORMAT_IS_INTERLEAVED(fmt)    ((fmt) > SPA_AUDIO_FORMAT_START_Interleaved && (fmt) < SPA_AUDIO_FORMAT_START_Planar)\n+#define SPA_AUDIO_FORMAT_IS_PLANAR(fmt)        ((fmt) > SPA_AUDIO_FORMAT_START_Planar && (fmt) < SPA_AUDIO_FORMAT_START_Other)\n+\n+enum spa_audio_channel {\n+    SPA_AUDIO_CHANNEL_UNKNOWN,    \/**< unspecified *\/\n+    SPA_AUDIO_CHANNEL_NA,        \/**< N\/A, silent *\/\n+\n+    SPA_AUDIO_CHANNEL_MONO,         \/**< mono stream *\/\n+\n+    SPA_AUDIO_CHANNEL_FL,           \/**< front left *\/\n+    SPA_AUDIO_CHANNEL_FR,           \/**< front right *\/\n+    SPA_AUDIO_CHANNEL_FC,           \/**< front center *\/\n+    SPA_AUDIO_CHANNEL_LFE,          \/**< LFE *\/\n+    SPA_AUDIO_CHANNEL_SL,           \/**< side left *\/\n+    SPA_AUDIO_CHANNEL_SR,           \/**< side right *\/\n+    SPA_AUDIO_CHANNEL_FLC,          \/**< front left center *\/\n+    SPA_AUDIO_CHANNEL_FRC,          \/**< front right center *\/\n+    SPA_AUDIO_CHANNEL_RC,           \/**< rear center *\/\n+    SPA_AUDIO_CHANNEL_RL,           \/**< rear left *\/\n+    SPA_AUDIO_CHANNEL_RR,           \/**< rear right *\/\n+    SPA_AUDIO_CHANNEL_TC,           \/**< top center *\/\n+    SPA_AUDIO_CHANNEL_TFL,          \/**< top front left *\/\n+    SPA_AUDIO_CHANNEL_TFC,          \/**< top front center *\/\n+    SPA_AUDIO_CHANNEL_TFR,          \/**< top front right *\/\n+    SPA_AUDIO_CHANNEL_TRL,          \/**< top rear left *\/\n+    SPA_AUDIO_CHANNEL_TRC,          \/**< top rear center *\/\n+    SPA_AUDIO_CHANNEL_TRR,          \/**< top rear right *\/\n+    SPA_AUDIO_CHANNEL_RLC,          \/**< rear left center *\/\n+    SPA_AUDIO_CHANNEL_RRC,          \/**< rear right center *\/\n+    SPA_AUDIO_CHANNEL_FLW,          \/**< front left wide *\/\n+    SPA_AUDIO_CHANNEL_FRW,          \/**< front right wide *\/\n+    SPA_AUDIO_CHANNEL_LFE2,        \/**< LFE 2 *\/\n+    SPA_AUDIO_CHANNEL_FLH,          \/**< front left high *\/\n+    SPA_AUDIO_CHANNEL_FCH,          \/**< front center high *\/\n+    SPA_AUDIO_CHANNEL_FRH,          \/**< front right high *\/\n+    SPA_AUDIO_CHANNEL_TFLC,         \/**< top front left center *\/\n+    SPA_AUDIO_CHANNEL_TFRC,         \/**< top front right center *\/\n+    SPA_AUDIO_CHANNEL_TSL,          \/**< top side left *\/\n+    SPA_AUDIO_CHANNEL_TSR,          \/**< top side right *\/\n+    SPA_AUDIO_CHANNEL_LLFE,         \/**< left LFE *\/\n+    SPA_AUDIO_CHANNEL_RLFE,         \/**< right LFE *\/\n+    SPA_AUDIO_CHANNEL_BC,           \/**< bottom center *\/\n+    SPA_AUDIO_CHANNEL_BLC,          \/**< bottom left center *\/\n+    SPA_AUDIO_CHANNEL_BRC,          \/**< bottom right center *\/\n+\n+    SPA_AUDIO_CHANNEL_START_Aux    = 0x1000,    \/**< aux channels *\/\n+    SPA_AUDIO_CHANNEL_AUX0 = SPA_AUDIO_CHANNEL_START_Aux,\n+    SPA_AUDIO_CHANNEL_AUX1,\n+    SPA_AUDIO_CHANNEL_AUX2,\n+    SPA_AUDIO_CHANNEL_AUX3,\n+    SPA_AUDIO_CHANNEL_AUX4,\n+    SPA_AUDIO_CHANNEL_AUX5,\n+    SPA_AUDIO_CHANNEL_AUX6,\n+    SPA_AUDIO_CHANNEL_AUX7,\n+    SPA_AUDIO_CHANNEL_AUX8,\n+    SPA_AUDIO_CHANNEL_AUX9,\n+    SPA_AUDIO_CHANNEL_AUX10,\n+    SPA_AUDIO_CHANNEL_AUX11,\n+    SPA_AUDIO_CHANNEL_AUX12,\n+    SPA_AUDIO_CHANNEL_AUX13,\n+    SPA_AUDIO_CHANNEL_AUX14,\n+    SPA_AUDIO_CHANNEL_AUX15,\n+    SPA_AUDIO_CHANNEL_AUX16,\n+    SPA_AUDIO_CHANNEL_AUX17,\n+    SPA_AUDIO_CHANNEL_AUX18,\n+    SPA_AUDIO_CHANNEL_AUX19,\n+    SPA_AUDIO_CHANNEL_AUX20,\n+    SPA_AUDIO_CHANNEL_AUX21,\n+    SPA_AUDIO_CHANNEL_AUX22,\n+    SPA_AUDIO_CHANNEL_AUX23,\n+    SPA_AUDIO_CHANNEL_AUX24,\n+    SPA_AUDIO_CHANNEL_AUX25,\n+    SPA_AUDIO_CHANNEL_AUX26,\n+    SPA_AUDIO_CHANNEL_AUX27,\n+    SPA_AUDIO_CHANNEL_AUX28,\n+    SPA_AUDIO_CHANNEL_AUX29,\n+    SPA_AUDIO_CHANNEL_AUX30,\n+    SPA_AUDIO_CHANNEL_AUX31,\n+    SPA_AUDIO_CHANNEL_AUX32,\n+    SPA_AUDIO_CHANNEL_AUX33,\n+    SPA_AUDIO_CHANNEL_AUX34,\n+    SPA_AUDIO_CHANNEL_AUX35,\n+    SPA_AUDIO_CHANNEL_AUX36,\n+    SPA_AUDIO_CHANNEL_AUX37,\n+    SPA_AUDIO_CHANNEL_AUX38,\n+    SPA_AUDIO_CHANNEL_AUX39,\n+    SPA_AUDIO_CHANNEL_AUX40,\n+    SPA_AUDIO_CHANNEL_AUX41,\n+    SPA_AUDIO_CHANNEL_AUX42,\n+    SPA_AUDIO_CHANNEL_AUX43,\n+    SPA_AUDIO_CHANNEL_AUX44,\n+    SPA_AUDIO_CHANNEL_AUX45,\n+    SPA_AUDIO_CHANNEL_AUX46,\n+    SPA_AUDIO_CHANNEL_AUX47,\n+    SPA_AUDIO_CHANNEL_AUX48,\n+    SPA_AUDIO_CHANNEL_AUX49,\n+    SPA_AUDIO_CHANNEL_AUX50,\n+    SPA_AUDIO_CHANNEL_AUX51,\n+    SPA_AUDIO_CHANNEL_AUX52,\n+    SPA_AUDIO_CHANNEL_AUX53,\n+    SPA_AUDIO_CHANNEL_AUX54,\n+    SPA_AUDIO_CHANNEL_AUX55,\n+    SPA_AUDIO_CHANNEL_AUX56,\n+    SPA_AUDIO_CHANNEL_AUX57,\n+    SPA_AUDIO_CHANNEL_AUX58,\n+    SPA_AUDIO_CHANNEL_AUX59,\n+    SPA_AUDIO_CHANNEL_AUX60,\n+    SPA_AUDIO_CHANNEL_AUX61,\n+    SPA_AUDIO_CHANNEL_AUX62,\n+    SPA_AUDIO_CHANNEL_AUX63,\n+\n+    SPA_AUDIO_CHANNEL_LAST_Aux    = 0x1fff,    \/**< aux channels *\/\n+\n+    SPA_AUDIO_CHANNEL_START_Custom    = 0x10000,\n+};\n+\n+enum spa_audio_volume_ramp_scale {\n+    SPA_AUDIO_VOLUME_RAMP_INVALID,\n+    SPA_AUDIO_VOLUME_RAMP_LINEAR,\n+    SPA_AUDIO_VOLUME_RAMP_CUBIC,\n+};\n+\n+\/** Extra audio flags *\/\n+#define SPA_AUDIO_FLAG_NONE        (0)        \/*< no valid flag *\/\n+#define SPA_AUDIO_FLAG_UNPOSITIONED    (1 << 0)    \/*< the position array explicitly\n+                             *  contains unpositioned channels. *\/\n+\/** Audio information description *\/\n+struct spa_audio_info_raw {\n+    enum spa_audio_format format;        \/*< format, one of enum spa_audio_format *\/\n+    uint32_t flags;                \/*< extra flags *\/\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    uint32_t position[SPA_AUDIO_MAX_CHANNELS];    \/*< channel position from enum spa_audio_channel *\/\n+};\n+\n+#define SPA_AUDIO_INFO_RAW_INIT(...)        ((struct spa_audio_info_raw) { __VA_ARGS__ })\n+\n+#define SPA_KEY_AUDIO_FORMAT        \"audio.format\"        \/**< an audio format as string,\n+                                  *  Ex. \"S16LE\" *\/\n+#define SPA_KEY_AUDIO_CHANNEL        \"audio.channel\"        \/**< an audio channel as string,\n+                                  *  Ex. \"FL\" *\/\n+#define SPA_KEY_AUDIO_CHANNELS        \"audio.channels\"    \/**< an audio channel count as int *\/\n+#define SPA_KEY_AUDIO_RATE        \"audio.rate\"        \/**< an audio sample rate as int *\/\n+#define SPA_KEY_AUDIO_POSITION        \"audio.position\"    \/**< channel positions as comma separated list\n+                                  *  of channels ex. \"FL,FR\" *\/\n+#define SPA_KEY_AUDIO_ALLOWED_RATES    \"audio.allowed-rates\"    \/**< a list of allowed samplerates\n+                                  *  ex. \"[ 44100 48000 ]\" *\/\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_RAW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/raw.h","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_TYPES_H\n+#define SPA_AUDIO_TYPES_H\n+\n+#include <spa\/param\/audio\/raw-types.h>\n+#include <spa\/param\/audio\/iec958-types.h>\n+#include <spa\/param\/audio\/mp3-types.h>\n+#include <spa\/param\/audio\/aac-types.h>\n+#include <spa\/param\/audio\/wma-types.h>\n+#include <spa\/param\/audio\/amr-types.h>\n+\n+#endif \/* SPA_AUDIO_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/type-info.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_WMA_TYPES_H\n+#define SPA_AUDIO_WMA_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/audio\/wma.h>\n+\n+#define SPA_TYPE_INFO_AudioWMAProfile        SPA_TYPE_INFO_ENUM_BASE \"AudioWMAProfile\"\n+#define SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE    SPA_TYPE_INFO_AudioWMAProfile \":\"\n+\n+static const struct spa_type_info spa_type_audio_wma_profile[] = {\n+    { SPA_AUDIO_WMA_PROFILE_UNKNOWN, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"UNKNOWN\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA7, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA7\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA8, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA8\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA10, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA10\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9_PRO, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9-Pro\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA9-Lossless\", NULL },\n+    { SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS, SPA_TYPE_Int, SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE \"WMA10-Lossless\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_WMA_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/wma-types.h","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_AUDIO_WMA_H\n+#define SPA_AUDIO_WMA_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/audio\/raw.h>\n+\n+enum spa_audio_wma_profile {\n+    SPA_AUDIO_WMA_PROFILE_UNKNOWN,\n+\n+    SPA_AUDIO_WMA_PROFILE_WMA7,\n+    SPA_AUDIO_WMA_PROFILE_WMA8,\n+    SPA_AUDIO_WMA_PROFILE_WMA9,\n+    SPA_AUDIO_WMA_PROFILE_WMA10,\n+    SPA_AUDIO_WMA_PROFILE_WMA9_PRO,\n+    SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS,\n+    SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS,\n+\n+    SPA_AUDIO_WMA_PROFILE_CUSTOM = 0x10000,\n+};\n+\n+struct spa_audio_info_wma {\n+    uint32_t rate;                \/*< sample rate *\/\n+    uint32_t channels;            \/*< number of channels *\/\n+    uint32_t bitrate;            \/*< stream bitrate *\/\n+    uint32_t block_align;            \/*< block alignment *\/\n+    enum spa_audio_wma_profile profile;    \/*< WMA profile *\/\n+\n+};\n+\n+#define SPA_AUDIO_INFO_WMA_INIT(...)        ((struct spa_audio_info_wma) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_AUDIO_WMA_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/audio\/wma.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BLUETOOTH_AUDIO_H\n+#define SPA_BLUETOOTH_AUDIO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+enum spa_bluetooth_audio_codec {\n+    SPA_BLUETOOTH_AUDIO_CODEC_START,\n+\n+    \/* A2DP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_SBC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ,\n+    SPA_BLUETOOTH_AUDIO_CODEC_MPEG,\n+    SPA_BLUETOOTH_AUDIO_CODEC_AAC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD,\n+    SPA_BLUETOOTH_AUDIO_CODEC_LDAC,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL,\n+    SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM,\n+    SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX,\n+    SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO,\n+\n+    \/* HFP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_CVSD = 0x100,\n+    SPA_BLUETOOTH_AUDIO_CODEC_MSBC,\n+\n+    \/* BAP *\/\n+    SPA_BLUETOOTH_AUDIO_CODEC_LC3 = 0x200,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BLUETOOTH_AUDIO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/bluetooth\/audio.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_BLUETOOTH_TYPES_H\n+#define SPA_BLUETOOTH_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/bluetooth\/audio.h>\n+\n+#define SPA_TYPE_INFO_BluetoothAudioCodec        SPA_TYPE_INFO_ENUM_BASE \"BluetoothAudioCodec\"\n+#define SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE    SPA_TYPE_INFO_BluetoothAudioCodec \":\"\n+\n+static const struct spa_type_info spa_type_bluetooth_audio_codec[] = {\n+    \/* A2DP *\/\n+    { SPA_BLUETOOTH_AUDIO_CODEC_SBC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"sbc\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"sbc_xq\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_MPEG, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"mpeg\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_AAC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aac\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_hd\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LDAC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"ldac\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_ll\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"aptx_ll_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"faststream\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"faststream_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"lc3plus_hr\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_51\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_71\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_duplex\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"opus_05_pro\", NULL },\n+\n+    { SPA_BLUETOOTH_AUDIO_CODEC_CVSD, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"cvsd\", NULL },\n+    { SPA_BLUETOOTH_AUDIO_CODEC_MSBC, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"msbc\", NULL },\n+\n+    { SPA_BLUETOOTH_AUDIO_CODEC_LC3, SPA_TYPE_Int, SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE \"lc3\", NULL },\n+\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_BLUETOOTH_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/bluetooth\/type-info.h","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_BUFFERS_TYPES_H\n+#define SPA_PARAM_BUFFERS_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/node\/type-info.h>\n+\n+#include <spa\/param\/buffers.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Meta        SPA_TYPE_INFO_PARAM_BASE \"Meta\"\n+#define SPA_TYPE_INFO_PARAM_META_BASE        SPA_TYPE_INFO_PARAM_Meta \":\"\n+\n+static const struct spa_type_info spa_type_param_meta[] = {\n+    { SPA_PARAM_META_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_META_BASE, spa_type_param },\n+    { SPA_PARAM_META_type, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_META_BASE \"type\", spa_type_meta_type },\n+    { SPA_PARAM_META_size, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_META_BASE \"size\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/** Base for parameters that describe IO areas to exchange data,\n+ * control and properties with a node.\n+ *\/\n+#define SPA_TYPE_INFO_PARAM_IO        SPA_TYPE_INFO_PARAM_BASE \"IO\"\n+#define SPA_TYPE_INFO_PARAM_IO_BASE        SPA_TYPE_INFO_PARAM_IO \":\"\n+\n+static const struct spa_type_info spa_type_param_io[] = {\n+    { SPA_PARAM_IO_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_IO_BASE, spa_type_param, },\n+    { SPA_PARAM_IO_id, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_IO_BASE \"id\", spa_type_io },\n+    { SPA_PARAM_IO_size, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_IO_BASE \"size\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_Buffers            SPA_TYPE_INFO_PARAM_BASE \"Buffers\"\n+#define SPA_TYPE_INFO_PARAM_BUFFERS_BASE        SPA_TYPE_INFO_PARAM_Buffers \":\"\n+\n+#define SPA_TYPE_INFO_PARAM_BlockInfo            SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"BlockInfo\"\n+#define SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE        SPA_TYPE_INFO_PARAM_BlockInfo \":\"\n+\n+static const struct spa_type_info spa_type_param_buffers[] = {\n+    { SPA_PARAM_BUFFERS_START,    SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_BUFFERS_BASE, spa_type_param, },\n+    { SPA_PARAM_BUFFERS_buffers,  SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"buffers\", NULL },\n+    { SPA_PARAM_BUFFERS_blocks,   SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BUFFERS_BASE \"blocks\", NULL },\n+    { SPA_PARAM_BUFFERS_size,     SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"size\", NULL },\n+    { SPA_PARAM_BUFFERS_stride,   SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"stride\", NULL },\n+    { SPA_PARAM_BUFFERS_align,    SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"align\", NULL },\n+    { SPA_PARAM_BUFFERS_dataType, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE \"dataType\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_BUFFERS_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/buffers-types.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_BUFFERS_H\n+#define SPA_PARAM_BUFFERS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamBuffers *\/\n+enum spa_param_buffers {\n+    SPA_PARAM_BUFFERS_START,\n+    SPA_PARAM_BUFFERS_buffers,    \/**< number of buffers (Int) *\/\n+    SPA_PARAM_BUFFERS_blocks,    \/**< number of data blocks per buffer (Int) *\/\n+    SPA_PARAM_BUFFERS_size,        \/**< size of a data block memory (Int)*\/\n+    SPA_PARAM_BUFFERS_stride,    \/**< stride of data block memory (Int) *\/\n+    SPA_PARAM_BUFFERS_align,    \/**< alignment of data block memory (Int) *\/\n+    SPA_PARAM_BUFFERS_dataType,    \/**< possible memory types (Int, mask of enum spa_data_type) *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamMeta *\/\n+enum spa_param_meta {\n+    SPA_PARAM_META_START,\n+    SPA_PARAM_META_type,    \/**< the metadata, one of enum spa_meta_type (Id enum spa_meta_type) *\/\n+    SPA_PARAM_META_size,    \/**< the expected maximum size the meta (Int) *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamIO *\/\n+enum spa_param_io {\n+    SPA_PARAM_IO_START,\n+    SPA_PARAM_IO_id,    \/**< type ID, uniquely identifies the io area (Id enum spa_io_type) *\/\n+    SPA_PARAM_IO_size,    \/**< size of the io area (Int) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_BUFFERS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/buffers.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_TYPES_H\n+#define SPA_PARAM_FORMAT_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/audio\/type-info.h>\n+#include <spa\/param\/video\/type-info.h>\n+\n+#define SPA_TYPE_INFO_Format            SPA_TYPE_INFO_PARAM_BASE \"Format\"\n+#define SPA_TYPE_INFO_FORMAT_BASE        SPA_TYPE_INFO_Format \":\"\n+\n+#define SPA_TYPE_INFO_MediaType        SPA_TYPE_INFO_ENUM_BASE \"MediaType\"\n+#define SPA_TYPE_INFO_MEDIA_TYPE_BASE    SPA_TYPE_INFO_MediaType \":\"\n+\n+static const struct spa_type_info spa_type_media_type[] = {\n+    { SPA_MEDIA_TYPE_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"unknown\", NULL },\n+    { SPA_MEDIA_TYPE_audio,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"audio\", NULL },\n+    { SPA_MEDIA_TYPE_video,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"video\", NULL },\n+    { SPA_MEDIA_TYPE_image,   SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"image\", NULL },\n+    { SPA_MEDIA_TYPE_binary,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"binary\", NULL },\n+    { SPA_MEDIA_TYPE_stream,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"stream\", NULL },\n+    { SPA_MEDIA_TYPE_application,  SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_TYPE_BASE \"application\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_MediaSubtype        SPA_TYPE_INFO_ENUM_BASE \"MediaSubtype\"\n+#define SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE    SPA_TYPE_INFO_MediaSubtype \":\"\n+\n+static const struct spa_type_info spa_type_media_subtype[] = {\n+    { SPA_MEDIA_SUBTYPE_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"unknown\", NULL },\n+    \/* generic subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_raw, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"raw\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dsp, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dsp\", NULL },\n+    { SPA_MEDIA_SUBTYPE_iec958, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"iec958\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dsd, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dsd\", NULL },\n+    \/* audio subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_mp3, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mp3\", NULL },\n+    { SPA_MEDIA_SUBTYPE_aac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"aac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vorbis, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vorbis\", NULL },\n+    { SPA_MEDIA_SUBTYPE_wma, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"wma\", NULL },\n+    { SPA_MEDIA_SUBTYPE_ra, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"ra\", NULL },\n+    { SPA_MEDIA_SUBTYPE_sbc, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"sbc\", NULL },\n+    { SPA_MEDIA_SUBTYPE_adpcm, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"adpcm\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g723, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g723\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g726, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g726\", NULL },\n+    { SPA_MEDIA_SUBTYPE_g729, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"g729\", NULL },\n+    { SPA_MEDIA_SUBTYPE_amr, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"amr\", NULL },\n+    { SPA_MEDIA_SUBTYPE_gsm, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"gsm\", NULL },\n+    { SPA_MEDIA_SUBTYPE_alac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"alac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_flac, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"flac\", NULL },\n+    { SPA_MEDIA_SUBTYPE_ape, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"ape\", NULL },\n+    { SPA_MEDIA_SUBTYPE_opus, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"opus\", NULL },\n+    \/* video subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_h264, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"h264\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mjpg, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mjpg\", NULL },\n+    { SPA_MEDIA_SUBTYPE_dv, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"dv\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpegts, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpegts\", NULL },\n+    { SPA_MEDIA_SUBTYPE_h263, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"h263\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg1, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg1\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg2, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg2\", NULL },\n+    { SPA_MEDIA_SUBTYPE_mpeg4, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"mpeg4\", NULL },\n+    { SPA_MEDIA_SUBTYPE_xvid, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"xvid\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vc1, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vc1\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vp8, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vp8\", NULL },\n+    { SPA_MEDIA_SUBTYPE_vp9, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"vp9\", NULL },\n+    { SPA_MEDIA_SUBTYPE_bayer, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"bayer\", NULL },\n+    \/* image subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_jpeg, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"jpeg\", NULL },\n+    \/* stream subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_midi, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"midi\", NULL },\n+    \/* application subtypes *\/\n+    { SPA_MEDIA_SUBTYPE_control, SPA_TYPE_Int, SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE \"control\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_FormatAudio        SPA_TYPE_INFO_FORMAT_BASE \"Audio\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_BASE        SPA_TYPE_INFO_FormatAudio \":\"\n+\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AAC        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"AAC\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_AAC \":\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_WMA        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"WMA\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_WMA \":\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AMR        SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"AMR\"\n+#define SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE    SPA_TYPE_INFO_FORMAT_AUDIO_AMR \":\"\n+\n+#define SPA_TYPE_INFO_FormatVideo        SPA_TYPE_INFO_FORMAT_BASE \"Video\"\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_BASE        SPA_TYPE_INFO_FormatVideo \":\"\n+\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_H264        SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"H264\"\n+#define SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE    SPA_TYPE_INFO_FORMAT_VIDEO_H264 \":\"\n+\n+static const struct spa_type_info spa_type_format[] = {\n+    { SPA_FORMAT_START, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE, spa_type_param, },\n+\n+    { SPA_FORMAT_mediaType, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE \"mediaType\",\n+        spa_type_media_type, },\n+    { SPA_FORMAT_mediaSubtype, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_BASE \"mediaSubtype\",\n+        spa_type_media_subtype, },\n+\n+    { SPA_FORMAT_AUDIO_format, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"format\",\n+        spa_type_audio_format },\n+    { SPA_FORMAT_AUDIO_flags, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"flags\",\n+        spa_type_audio_flags },\n+    { SPA_FORMAT_AUDIO_rate, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"rate\", NULL },\n+    { SPA_FORMAT_AUDIO_channels, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"channels\", NULL },\n+    { SPA_FORMAT_AUDIO_position, SPA_TYPE_Array, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"position\",\n+        spa_type_prop_channel_map },\n+\n+    { SPA_FORMAT_AUDIO_iec958Codec, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"iec958Codec\",\n+        spa_type_audio_iec958_codec },\n+\n+    { SPA_FORMAT_AUDIO_bitorder, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"bitorder\",\n+        spa_type_param_bitorder },\n+    { SPA_FORMAT_AUDIO_interleave, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"interleave\", NULL },\n+    { SPA_FORMAT_AUDIO_bitrate, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"bitrate\", NULL },\n+    { SPA_FORMAT_AUDIO_blockAlign, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_AUDIO_BASE \"blockAlign\", NULL },\n+\n+    { SPA_FORMAT_AUDIO_AAC_streamFormat, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE \"streamFormat\",\n+        spa_type_audio_aac_stream_format },\n+    { SPA_FORMAT_AUDIO_WMA_profile, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE \"profile\",\n+        spa_type_audio_wma_profile },\n+    { SPA_FORMAT_AUDIO_AMR_bandMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE \"bandMode\",\n+        spa_type_audio_amr_band_mode },\n+\n+    { SPA_FORMAT_VIDEO_format, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"format\",\n+        spa_type_video_format, },\n+    { SPA_FORMAT_VIDEO_modifier, SPA_TYPE_Long, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"modifier\", NULL },\n+    { SPA_FORMAT_VIDEO_size,  SPA_TYPE_Rectangle, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"size\", NULL },\n+    { SPA_FORMAT_VIDEO_framerate, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"framerate\", NULL },\n+    { SPA_FORMAT_VIDEO_maxFramerate, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"maxFramerate\", NULL },\n+    { SPA_FORMAT_VIDEO_views, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"views\", NULL },\n+    { SPA_FORMAT_VIDEO_interlaceMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"interlaceMode\",\n+        spa_type_video_interlace_mode, },\n+    { SPA_FORMAT_VIDEO_pixelAspectRatio, SPA_TYPE_Fraction, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"pixelAspectRatio\", NULL },\n+    { SPA_FORMAT_VIDEO_multiviewMode, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"multiviewMode\", NULL },\n+    { SPA_FORMAT_VIDEO_multiviewFlags, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"multiviewFlags\", NULL },\n+    { SPA_FORMAT_VIDEO_chromaSite, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"chromaSite\", NULL },\n+    { SPA_FORMAT_VIDEO_colorRange, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorRange\", NULL },\n+    { SPA_FORMAT_VIDEO_colorMatrix, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorMatrix\", NULL },\n+    { SPA_FORMAT_VIDEO_transferFunction, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"transferFunction\", NULL },\n+    { SPA_FORMAT_VIDEO_colorPrimaries, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"colorPrimaries\", NULL },\n+    { SPA_FORMAT_VIDEO_profile, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"profile\", NULL },\n+    { SPA_FORMAT_VIDEO_level, SPA_TYPE_Int, SPA_TYPE_INFO_FORMAT_VIDEO_BASE \"level\", NULL },\n+\n+    { SPA_FORMAT_VIDEO_H264_streamFormat, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE \"streamFormat\", NULL },\n+    { SPA_FORMAT_VIDEO_H264_alignment, SPA_TYPE_Id, SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE \"alignment\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format-types.h","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_UTILS_H\n+#define SPA_PARAM_FORMAT_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/param\/format.h>\n+\n+static inline int\n+spa_format_parse(const struct spa_pod *format, uint32_t *media_type, uint32_t *media_subtype)\n+{\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_mediaType,    SPA_POD_Id(media_type),\n+        SPA_FORMAT_mediaSubtype, SPA_POD_Id(media_subtype));\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format-utils.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_FORMAT_H\n+#define SPA_PARAM_FORMAT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** media type for SPA_TYPE_OBJECT_Format *\/\n+enum spa_media_type {\n+    SPA_MEDIA_TYPE_unknown,\n+    SPA_MEDIA_TYPE_audio,\n+    SPA_MEDIA_TYPE_video,\n+    SPA_MEDIA_TYPE_image,\n+    SPA_MEDIA_TYPE_binary,\n+    SPA_MEDIA_TYPE_stream,\n+    SPA_MEDIA_TYPE_application,\n+};\n+\n+\/** media subtype for SPA_TYPE_OBJECT_Format *\/\n+enum spa_media_subtype {\n+    SPA_MEDIA_SUBTYPE_unknown,\n+    SPA_MEDIA_SUBTYPE_raw,\n+    SPA_MEDIA_SUBTYPE_dsp,\n+    SPA_MEDIA_SUBTYPE_iec958,    \/** S\/PDIF *\/\n+    SPA_MEDIA_SUBTYPE_dsd,\n+\n+    SPA_MEDIA_SUBTYPE_START_Audio    = 0x10000,\n+    SPA_MEDIA_SUBTYPE_mp3,\n+    SPA_MEDIA_SUBTYPE_aac,\n+    SPA_MEDIA_SUBTYPE_vorbis,\n+    SPA_MEDIA_SUBTYPE_wma,\n+    SPA_MEDIA_SUBTYPE_ra,\n+    SPA_MEDIA_SUBTYPE_sbc,\n+    SPA_MEDIA_SUBTYPE_adpcm,\n+    SPA_MEDIA_SUBTYPE_g723,\n+    SPA_MEDIA_SUBTYPE_g726,\n+    SPA_MEDIA_SUBTYPE_g729,\n+    SPA_MEDIA_SUBTYPE_amr,\n+    SPA_MEDIA_SUBTYPE_gsm,\n+    SPA_MEDIA_SUBTYPE_alac,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_flac,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_ape,        \/** since 0.3.65 *\/\n+    SPA_MEDIA_SUBTYPE_opus,        \/** since 0.3.68 *\/\n+\n+    SPA_MEDIA_SUBTYPE_START_Video    = 0x20000,\n+    SPA_MEDIA_SUBTYPE_h264,\n+    SPA_MEDIA_SUBTYPE_mjpg,\n+    SPA_MEDIA_SUBTYPE_dv,\n+    SPA_MEDIA_SUBTYPE_mpegts,\n+    SPA_MEDIA_SUBTYPE_h263,\n+    SPA_MEDIA_SUBTYPE_mpeg1,\n+    SPA_MEDIA_SUBTYPE_mpeg2,\n+    SPA_MEDIA_SUBTYPE_mpeg4,\n+    SPA_MEDIA_SUBTYPE_xvid,\n+    SPA_MEDIA_SUBTYPE_vc1,\n+    SPA_MEDIA_SUBTYPE_vp8,\n+    SPA_MEDIA_SUBTYPE_vp9,\n+    SPA_MEDIA_SUBTYPE_bayer,\n+\n+    SPA_MEDIA_SUBTYPE_START_Image    = 0x30000,\n+    SPA_MEDIA_SUBTYPE_jpeg,\n+\n+    SPA_MEDIA_SUBTYPE_START_Binary    = 0x40000,\n+\n+    SPA_MEDIA_SUBTYPE_START_Stream    = 0x50000,\n+    SPA_MEDIA_SUBTYPE_midi,\n+\n+    SPA_MEDIA_SUBTYPE_START_Application    = 0x60000,\n+    SPA_MEDIA_SUBTYPE_control,        \/**< control stream, data contains\n+                          *  spa_pod_sequence with control info. *\/\n+};\n+\n+\/** properties for audio SPA_TYPE_OBJECT_Format *\/\n+enum spa_format {\n+    SPA_FORMAT_START,\n+\n+    SPA_FORMAT_mediaType,        \/**< media type (Id enum spa_media_type) *\/\n+    SPA_FORMAT_mediaSubtype,    \/**< media subtype (Id enum spa_media_subtype) *\/\n+\n+    \/* Audio format keys *\/\n+    SPA_FORMAT_START_Audio = 0x10000,\n+    SPA_FORMAT_AUDIO_format,        \/**< audio format, (Id enum spa_audio_format) *\/\n+    SPA_FORMAT_AUDIO_flags,            \/**< optional flags (Int) *\/\n+    SPA_FORMAT_AUDIO_rate,            \/**< sample rate (Int) *\/\n+    SPA_FORMAT_AUDIO_channels,        \/**< number of audio channels (Int) *\/\n+    SPA_FORMAT_AUDIO_position,        \/**< channel positions (Id enum spa_audio_position) *\/\n+\n+    SPA_FORMAT_AUDIO_iec958Codec,        \/**< codec used (IEC958) (Id enum spa_audio_iec958_codec) *\/\n+\n+    SPA_FORMAT_AUDIO_bitorder,        \/**< bit order (Id enum spa_param_bitorder) *\/\n+    SPA_FORMAT_AUDIO_interleave,        \/**< Interleave bytes (Int) *\/\n+    SPA_FORMAT_AUDIO_bitrate,        \/**< bit rate (Int) *\/\n+    SPA_FORMAT_AUDIO_blockAlign,        \/**< audio data block alignment (Int) *\/\n+\n+    SPA_FORMAT_AUDIO_AAC_streamFormat,    \/**< AAC stream format, (Id enum spa_audio_aac_stream_format) *\/\n+\n+    SPA_FORMAT_AUDIO_WMA_profile,        \/**< WMA profile (Id enum spa_audio_wma_profile) *\/\n+\n+    SPA_FORMAT_AUDIO_AMR_bandMode,        \/**< AMR band mode (Id enum spa_audio_amr_band_mode) *\/\n+\n+\n+    \/* Video Format keys *\/\n+    SPA_FORMAT_START_Video = 0x20000,\n+    SPA_FORMAT_VIDEO_format,        \/**< video format (Id enum spa_video_format) *\/\n+    SPA_FORMAT_VIDEO_modifier,        \/**< format modifier (Long)\n+                          * use only with DMA-BUF and omit for other buffer types *\/\n+    SPA_FORMAT_VIDEO_size,            \/**< size (Rectangle) *\/\n+    SPA_FORMAT_VIDEO_framerate,        \/**< frame rate (Fraction) *\/\n+    SPA_FORMAT_VIDEO_maxFramerate,        \/**< maximum frame rate (Fraction) *\/\n+    SPA_FORMAT_VIDEO_views,            \/**< number of views (Int) *\/\n+    SPA_FORMAT_VIDEO_interlaceMode,        \/**< (Id enum spa_video_interlace_mode) *\/\n+    SPA_FORMAT_VIDEO_pixelAspectRatio,    \/**< (Rectangle) *\/\n+    SPA_FORMAT_VIDEO_multiviewMode,        \/**< (Id enum spa_video_multiview_mode) *\/\n+    SPA_FORMAT_VIDEO_multiviewFlags,    \/**< (Id enum spa_video_multiview_flags) *\/\n+    SPA_FORMAT_VIDEO_chromaSite,        \/**< \/Id enum spa_video_chroma_site) *\/\n+    SPA_FORMAT_VIDEO_colorRange,        \/**< \/Id enum spa_video_color_range) *\/\n+    SPA_FORMAT_VIDEO_colorMatrix,        \/**< \/Id enum spa_video_color_matrix) *\/\n+    SPA_FORMAT_VIDEO_transferFunction,    \/**< \/Id enum spa_video_transfer_function) *\/\n+    SPA_FORMAT_VIDEO_colorPrimaries,    \/**< \/Id enum spa_video_color_primaries) *\/\n+    SPA_FORMAT_VIDEO_profile,        \/**< (Int) *\/\n+    SPA_FORMAT_VIDEO_level,            \/**< (Int) *\/\n+    SPA_FORMAT_VIDEO_H264_streamFormat,    \/**< (Id enum spa_h264_stream_format) *\/\n+    SPA_FORMAT_VIDEO_H264_alignment,    \/**< (Id enum spa_h264_alignment) *\/\n+\n+    \/* Image Format keys *\/\n+    SPA_FORMAT_START_Image = 0x30000,\n+    \/* Binary Format keys *\/\n+    SPA_FORMAT_START_Binary = 0x40000,\n+    \/* Stream Format keys *\/\n+    SPA_FORMAT_START_Stream = 0x50000,\n+    \/* Application Format keys *\/\n+    SPA_FORMAT_START_Application = 0x60000,\n+};\n+\n+#define SPA_KEY_FORMAT_DSP        \"format.dsp\"        \/**< a predefined DSP format,\n+                                  *  Ex. \"32 bit float mono audio\" *\/\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_FORMAT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/format.h","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_LATENCY_TYPES_H\n+#define SPA_PARAM_LATENCY_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/latency.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Latency        SPA_TYPE_INFO_PARAM_BASE \"Latency\"\n+#define SPA_TYPE_INFO_PARAM_LATENCY_BASE    SPA_TYPE_INFO_PARAM_Latency \":\"\n+\n+static const struct spa_type_info spa_type_param_latency[] = {\n+    { SPA_PARAM_LATENCY_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE, spa_type_param, },\n+    { SPA_PARAM_LATENCY_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_LATENCY_minQuantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minQuantum\", NULL, },\n+    { SPA_PARAM_LATENCY_maxQuantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxQuantum\", NULL, },\n+    { SPA_PARAM_LATENCY_minRate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minRate\", NULL, },\n+    { SPA_PARAM_LATENCY_maxRate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxRate\", NULL, },\n+    { SPA_PARAM_LATENCY_minNs, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"minNs\", NULL, },\n+    { SPA_PARAM_LATENCY_maxNs, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_LATENCY_BASE \"maxNs\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_ProcessLatency        SPA_TYPE_INFO_PARAM_BASE \"ProcessLatency\"\n+#define SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE    SPA_TYPE_INFO_PARAM_ProcessLatency \":\"\n+\n+static const struct spa_type_info spa_type_param_process_latency[] = {\n+    { SPA_PARAM_PROCESS_LATENCY_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_LATENCY_BASE, spa_type_param, },\n+    { SPA_PARAM_PROCESS_LATENCY_quantum, SPA_TYPE_Float, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"quantum\", NULL, },\n+    { SPA_PARAM_PROCESS_LATENCY_rate, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"rate\", NULL, },\n+    { SPA_PARAM_PROCESS_LATENCY_ns, SPA_TYPE_Long, SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE \"ns\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_LATENCY_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/latency-types.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_LATENY_H\n+#define SPA_PARAM_LATENY_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamLatency *\/\n+enum spa_param_latency {\n+    SPA_PARAM_LATENCY_START,\n+    SPA_PARAM_LATENCY_direction,        \/**< direction, input\/output (Id enum spa_direction) *\/\n+    SPA_PARAM_LATENCY_minQuantum,        \/**< min latency relative to quantum (Float) *\/\n+    SPA_PARAM_LATENCY_maxQuantum,        \/**< max latency relative to quantum (Float) *\/\n+    SPA_PARAM_LATENCY_minRate,        \/**< min latency (Int) relative to rate *\/\n+    SPA_PARAM_LATENCY_maxRate,        \/**< max latency (Int) relative to rate *\/\n+    SPA_PARAM_LATENCY_minNs,        \/**< min latency (Long) in nanoseconds *\/\n+    SPA_PARAM_LATENCY_maxNs,        \/**< max latency (Long) in nanoseconds *\/\n+};\n+\n+\/** helper structure for managing latency objects *\/\n+struct spa_latency_info {\n+    enum spa_direction direction;\n+    float min_quantum;\n+    float max_quantum;\n+    uint32_t min_rate;\n+    uint32_t max_rate;\n+    uint64_t min_ns;\n+    uint64_t max_ns;\n+};\n+\n+#define SPA_LATENCY_INFO(dir,...) ((struct spa_latency_info) { .direction = (dir), ## __VA_ARGS__ })\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamProcessLatency *\/\n+enum spa_param_process_latency {\n+    SPA_PARAM_PROCESS_LATENCY_START,\n+    SPA_PARAM_PROCESS_LATENCY_quantum,    \/**< latency relative to quantum (Float) *\/\n+    SPA_PARAM_PROCESS_LATENCY_rate,        \/**< latency (Int) relative to rate *\/\n+    SPA_PARAM_PROCESS_LATENCY_ns,        \/**< latency (Long) in nanoseconds *\/\n+};\n+\n+\/** Helper structure for managing process latency objects *\/\n+struct spa_process_latency_info {\n+    float quantum;\n+    uint32_t rate;\n+    uint64_t ns;\n+};\n+\n+#define SPA_PROCESS_LATENCY_INFO_INIT(...)    ((struct spa_process_latency_info) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_LATENY_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/latency.h","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TYPES_H\n+#define SPA_PARAM_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/props.h>\n+#include <spa\/param\/format.h>\n+#include <spa\/buffer\/type-info.h>\n+\n+\/* base for parameter object enumerations *\/\n+#define SPA_TYPE_INFO_ParamId        SPA_TYPE_INFO_ENUM_BASE \"ParamId\"\n+#define SPA_TYPE_INFO_PARAM_ID_BASE    SPA_TYPE_INFO_ParamId \":\"\n+\n+static const struct spa_type_info spa_type_param[] = {\n+    { SPA_PARAM_Invalid, SPA_TYPE_None, SPA_TYPE_INFO_PARAM_ID_BASE \"Invalid\", NULL },\n+    { SPA_PARAM_PropInfo, SPA_TYPE_OBJECT_PropInfo, SPA_TYPE_INFO_PARAM_ID_BASE \"PropInfo\", NULL },\n+    { SPA_PARAM_Props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_PARAM_ID_BASE \"Props\", NULL },\n+    { SPA_PARAM_EnumFormat, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumFormat\", NULL },\n+    { SPA_PARAM_Format, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_ID_BASE \"Format\", NULL },\n+    { SPA_PARAM_Buffers, SPA_TYPE_OBJECT_ParamBuffers, SPA_TYPE_INFO_PARAM_ID_BASE \"Buffers\", NULL },\n+    { SPA_PARAM_Meta, SPA_TYPE_OBJECT_ParamMeta, SPA_TYPE_INFO_PARAM_ID_BASE \"Meta\", NULL },\n+    { SPA_PARAM_IO, SPA_TYPE_OBJECT_ParamIO, SPA_TYPE_INFO_PARAM_ID_BASE \"IO\", NULL },\n+    { SPA_PARAM_EnumProfile, SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumProfile\", NULL },\n+    { SPA_PARAM_Profile, SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_INFO_PARAM_ID_BASE \"Profile\", NULL },\n+    { SPA_PARAM_EnumPortConfig, SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumPortConfig\", NULL },\n+    { SPA_PARAM_PortConfig, SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_INFO_PARAM_ID_BASE \"PortConfig\", NULL },\n+    { SPA_PARAM_EnumRoute, SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_INFO_PARAM_ID_BASE \"EnumRoute\", NULL },\n+    { SPA_PARAM_Route, SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_INFO_PARAM_ID_BASE \"Route\", NULL },\n+    { SPA_PARAM_Control, SPA_TYPE_Sequence, SPA_TYPE_INFO_PARAM_ID_BASE \"Control\", NULL },\n+    { SPA_PARAM_Latency, SPA_TYPE_OBJECT_ParamLatency, SPA_TYPE_INFO_PARAM_ID_BASE \"Latency\", NULL },\n+    { SPA_PARAM_ProcessLatency, SPA_TYPE_OBJECT_ParamProcessLatency, SPA_TYPE_INFO_PARAM_ID_BASE \"ProcessLatency\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/* base for parameter objects *\/\n+#define SPA_TYPE_INFO_Param            SPA_TYPE_INFO_OBJECT_BASE \"Param\"\n+#define SPA_TYPE_INFO_PARAM_BASE        SPA_TYPE_INFO_Param \":\"\n+\n+#include <spa\/param\/audio\/type-info.h>\n+\n+static const struct spa_type_info spa_type_prop_float_array[] = {\n+    { SPA_PROP_START, SPA_TYPE_Float, SPA_TYPE_INFO_BASE \"floatArray\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_prop_channel_map[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_BASE \"channelMap\", spa_type_audio_channel, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+static const struct spa_type_info spa_type_prop_iec958_codec[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_BASE \"iec958Codec\", spa_type_audio_iec958_codec, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_ParamBitorder        SPA_TYPE_INFO_ENUM_BASE \"ParamBitorder\"\n+#define SPA_TYPE_INFO_PARAM_BITORDER_BASE    SPA_TYPE_INFO_ParamBitorder \":\"\n+\n+static const struct spa_type_info spa_type_param_bitorder[] = {\n+    { SPA_PARAM_BITORDER_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"unknown\", NULL },\n+    { SPA_PARAM_BITORDER_msb, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"msb\", NULL },\n+    { SPA_PARAM_BITORDER_lsb, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_BITORDER_BASE \"lsb\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_ParamAvailability        SPA_TYPE_INFO_ENUM_BASE \"ParamAvailability\"\n+#define SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE    SPA_TYPE_INFO_ParamAvailability \":\"\n+\n+static const struct spa_type_info spa_type_param_availability[] = {\n+    { SPA_PARAM_AVAILABILITY_unknown, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"unknown\", NULL },\n+    { SPA_PARAM_AVAILABILITY_no, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"no\", NULL },\n+    { SPA_PARAM_AVAILABILITY_yes, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE \"yes\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/param-types.h","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_H\n+#define SPA_PARAM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\defgroup spa_param Parameters\n+ * Parameter value enumerations and type information\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/** different parameter types that can be queried *\/\n+enum spa_param_type {\n+    SPA_PARAM_Invalid,        \/**< invalid *\/\n+    SPA_PARAM_PropInfo,        \/**< property information as SPA_TYPE_OBJECT_PropInfo *\/\n+    SPA_PARAM_Props,        \/**< properties as SPA_TYPE_OBJECT_Props *\/\n+    SPA_PARAM_EnumFormat,        \/**< available formats as SPA_TYPE_OBJECT_Format *\/\n+    SPA_PARAM_Format,        \/**< configured format as SPA_TYPE_OBJECT_Format *\/\n+    SPA_PARAM_Buffers,        \/**< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers*\/\n+    SPA_PARAM_Meta,            \/**< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta*\/\n+    SPA_PARAM_IO,            \/**< configurable IO areas as SPA_TYPE_OBJECT_ParamIO *\/\n+    SPA_PARAM_EnumProfile,        \/**< profile enumeration as SPA_TYPE_OBJECT_ParamProfile *\/\n+    SPA_PARAM_Profile,        \/**< profile configuration as SPA_TYPE_OBJECT_ParamProfile *\/\n+    SPA_PARAM_EnumPortConfig,    \/**< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig *\/\n+    SPA_PARAM_PortConfig,        \/**< port configuration as SPA_TYPE_OBJECT_ParamPortConfig *\/\n+    SPA_PARAM_EnumRoute,        \/**< routing enumeration as SPA_TYPE_OBJECT_ParamRoute *\/\n+    SPA_PARAM_Route,        \/**< routing configuration as SPA_TYPE_OBJECT_ParamRoute *\/\n+    SPA_PARAM_Control,        \/**< Control parameter, a SPA_TYPE_Sequence *\/\n+    SPA_PARAM_Latency,        \/**< latency reporting, a SPA_TYPE_OBJECT_ParamLatency *\/\n+    SPA_PARAM_ProcessLatency,    \/**< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency *\/\n+};\n+\n+\/** information about a parameter *\/\n+struct spa_param_info {\n+    uint32_t id;            \/**< enum spa_param_type *\/\n+#define SPA_PARAM_INFO_SERIAL        (1<<0)    \/**< bit to signal update even when the\n+                         *   read\/write flags don't change *\/\n+#define SPA_PARAM_INFO_READ        (1<<1)\n+#define SPA_PARAM_INFO_WRITE        (1<<2)\n+#define SPA_PARAM_INFO_READWRITE    (SPA_PARAM_INFO_WRITE|SPA_PARAM_INFO_READ)\n+    uint32_t flags;\n+    uint32_t user;            \/**< private user field. You can use this to keep\n+                      *  state. *\/\n+    int32_t seq;            \/**< private seq field. You can use this to keep\n+                      *  state of a pending update. *\/\n+    uint32_t padding[4];\n+};\n+\n+#define SPA_PARAM_INFO(id,flags) ((struct spa_param_info){ (id), (flags) })\n+\n+enum spa_param_bitorder {\n+    SPA_PARAM_BITORDER_unknown,    \/**< unknown bitorder *\/\n+    SPA_PARAM_BITORDER_msb,        \/**< most significant bit *\/\n+    SPA_PARAM_BITORDER_lsb,        \/**< least significant bit *\/\n+};\n+\n+enum spa_param_availability {\n+    SPA_PARAM_AVAILABILITY_unknown,    \/**< unknown availability *\/\n+    SPA_PARAM_AVAILABILITY_no,    \/**< not available *\/\n+    SPA_PARAM_AVAILABILITY_yes,    \/**< available *\/\n+};\n+\n+#include <spa\/param\/buffers.h>\n+#include <spa\/param\/profile.h>\n+#include <spa\/param\/port-config.h>\n+#include <spa\/param\/route.h>\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/param.h","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PORT_CONFIG_TYPES_H\n+#define SPA_PARAM_PORT_CONFIG_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/port-config.h>\n+\n+#define SPA_TYPE_INFO_ParamPortConfigMode        SPA_TYPE_INFO_ENUM_BASE \"ParamPortConfigMode\"\n+#define SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE    SPA_TYPE_INFO_ParamPortConfigMode \":\"\n+\n+static const struct spa_type_info spa_type_param_port_config_mode[] = {\n+    { SPA_PARAM_PORT_CONFIG_MODE_none, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"none\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_passthrough, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"passthrough\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_convert, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"convert\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_MODE_dsp, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE \"dsp\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_PARAM_PortConfig        SPA_TYPE_INFO_PARAM_BASE \"PortConfig\"\n+#define SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE    SPA_TYPE_INFO_PARAM_PortConfig \":\"\n+\n+static const struct spa_type_info spa_type_param_port_config[] = {\n+    { SPA_PARAM_PORT_CONFIG_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE, spa_type_param, },\n+    { SPA_PARAM_PORT_CONFIG_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_PORT_CONFIG_mode, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"mode\", spa_type_param_port_config_mode },\n+    { SPA_PARAM_PORT_CONFIG_monitor, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"monitor\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_control, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"control\", NULL },\n+    { SPA_PARAM_PORT_CONFIG_format, SPA_TYPE_OBJECT_Format, SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE \"format\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PORT_CONFIG_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/port-config-types.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PORT_CONFIG_H\n+#define SPA_PARAM_PORT_CONFIG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+enum spa_param_port_config_mode {\n+    SPA_PARAM_PORT_CONFIG_MODE_none,    \/**< no configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_passthrough,    \/**< passthrough configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_convert,    \/**< convert configuration *\/\n+    SPA_PARAM_PORT_CONFIG_MODE_dsp,        \/**< dsp configuration, depending on the external\n+                          *  format. For audio, ports will be configured for\n+                          *  the given number of channels with F32 format. *\/\n+};\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamPortConfig *\/\n+enum spa_param_port_config {\n+    SPA_PARAM_PORT_CONFIG_START,\n+    SPA_PARAM_PORT_CONFIG_direction,    \/**< (Id enum spa_direction) direction *\/\n+    SPA_PARAM_PORT_CONFIG_mode,        \/**< (Id enum spa_param_port_config_mode) mode *\/\n+    SPA_PARAM_PORT_CONFIG_monitor,        \/**< (Bool) enable monitor output ports on input ports *\/\n+    SPA_PARAM_PORT_CONFIG_control,        \/**< (Bool) enable control ports *\/\n+    SPA_PARAM_PORT_CONFIG_format,        \/**< (Object) format filter *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PORT_CONFIG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/port-config.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILE_TYPES_H\n+#define SPA_PARAM_PROFILE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/profile.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Profile        SPA_TYPE_INFO_PARAM_BASE \"Profile\"\n+#define SPA_TYPE_INFO_PARAM_PROFILE_BASE    SPA_TYPE_INFO_PARAM_Profile \":\"\n+\n+static const struct spa_type_info spa_type_param_profile[] = {\n+    { SPA_PARAM_PROFILE_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PROFILE_BASE, spa_type_param, },\n+    { SPA_PARAM_PROFILE_index, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"index\", NULL },\n+    { SPA_PARAM_PROFILE_name, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"name\", NULL },\n+    { SPA_PARAM_PROFILE_description, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"description\", NULL },\n+    { SPA_PARAM_PROFILE_priority, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"priority\", NULL },\n+    { SPA_PARAM_PROFILE_available, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"available\", spa_type_param_availability, },\n+    { SPA_PARAM_PROFILE_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"info\", NULL, },\n+    { SPA_PARAM_PROFILE_classes, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"classes\", NULL, },\n+    { SPA_PARAM_PROFILE_save, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_PROFILE_BASE \"save\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profile-types.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILE_H\n+#define SPA_PARAM_PROFILE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamProfile *\/\n+enum spa_param_profile {\n+    SPA_PARAM_PROFILE_START,\n+    SPA_PARAM_PROFILE_index,    \/**< profile index (Int) *\/\n+    SPA_PARAM_PROFILE_name,        \/**< profile name (String) *\/\n+    SPA_PARAM_PROFILE_description,    \/**< profile description (String) *\/\n+    SPA_PARAM_PROFILE_priority,    \/**< profile priority (Int) *\/\n+    SPA_PARAM_PROFILE_available,    \/**< availability of the profile\n+                      *  (Id enum spa_param_availability) *\/\n+    SPA_PARAM_PROFILE_info,        \/**< info (Struct(\n+                      *          Int : n_items,\n+                      *          (String : key,\n+                      *           String : value)*)) *\/\n+    SPA_PARAM_PROFILE_classes,    \/**< node classes provided by this profile\n+                      *  (Struct(\n+                      *       Int : number of items following\n+                      *        Struct(\n+                      *           String : class name (eg. \"Audio\/Source\"),\n+                      *           Int : number of nodes\n+                      *           String : property (eg. \"card.profile.devices\"),\n+                      *           Array of Int: device indexes\n+                      *         )*)) *\/\n+    SPA_PARAM_PROFILE_save,        \/**< If profile should be saved (Bool) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profile.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILER_TYPES_H\n+#define SPA_PARAM_PROFILER_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/profiler.h>\n+\n+#define SPA_TYPE_INFO_Profiler        SPA_TYPE_INFO_OBJECT_BASE \"Profiler\"\n+#define SPA_TYPE_INFO_PROFILER_BASE    SPA_TYPE_INFO_Profiler \":\"\n+\n+static const struct spa_type_info spa_type_profiler[] = {\n+    { SPA_PROFILER_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROFILER_BASE, spa_type_param, },\n+    { SPA_PROFILER_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"info\", NULL, },\n+    { SPA_PROFILER_clock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"clock\", NULL, },\n+    { SPA_PROFILER_driverBlock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"driverBlock\", NULL, },\n+    { SPA_PROFILER_followerBlock, SPA_TYPE_Struct, SPA_TYPE_INFO_PROFILER_BASE \"followerBlock\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILER_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profiler-types.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2020 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROFILER_H\n+#define SPA_PARAM_PROFILER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_Profiler *\/\n+enum spa_profiler {\n+    SPA_PROFILER_START,\n+\n+    SPA_PROFILER_START_Driver    = 0x10000,    \/**< driver related profiler properties *\/\n+    SPA_PROFILER_info,                \/**< Generic info, counter and CPU load,\n+                              * (Struct(\n+                              *      Long : counter,\n+                              *      Float : cpu_load fast,\n+                              *      Float : cpu_load medium,\n+                              *      Float : cpu_load slow),\n+                              *      Int : xrun-count))  *\/\n+    SPA_PROFILER_clock,                \/**< clock information\n+                              *  (Struct(\n+                              *      Int : clock flags,\n+                              *      Int : clock id,\n+                              *      String: clock name,\n+                              *      Long : clock nsec,\n+                              *      Fraction : clock rate,\n+                              *      Long : clock position,\n+                              *      Long : clock duration,\n+                              *      Long : clock delay,\n+                              *      Double : clock rate_diff,\n+                              *      Long : clock next_nsec)) *\/\n+    SPA_PROFILER_driverBlock,            \/**< generic driver info block\n+                              *  (Struct(\n+                              *      Int : driver_id,\n+                              *      String : name,\n+                              *      Long : driver prev_signal,\n+                              *      Long : driver signal,\n+                              *      Long : driver awake,\n+                              *      Long : driver finish,\n+                              *      Int : driver status),\n+                              *      Fraction : latency))  *\/\n+\n+    SPA_PROFILER_START_Follower    = 0x20000,    \/**< follower related profiler properties *\/\n+    SPA_PROFILER_followerBlock,            \/**< generic follower info block\n+                              *  (Struct(\n+                              *      Int : id,\n+                              *      String : name,\n+                              *      Long : prev_signal,\n+                              *      Long : signal,\n+                              *      Long : awake,\n+                              *      Long : finish,\n+                              *      Int : status,\n+                              *      Fraction : latency))  *\/\n+\n+    SPA_PROFILER_START_CUSTOM    = 0x1000000,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROFILER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/profiler.h","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROPS_TYPES_H\n+#define SPA_PARAM_PROPS_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/bluetooth\/type-info.h>\n+\n+\/** Props Param *\/\n+#define SPA_TYPE_INFO_Props            SPA_TYPE_INFO_PARAM_BASE \"Props\"\n+#define SPA_TYPE_INFO_PROPS_BASE        SPA_TYPE_INFO_Props \":\"\n+\n+static const struct spa_type_info spa_type_props[] = {\n+    { SPA_PROP_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE, spa_type_param, },\n+    { SPA_PROP_unknown, SPA_TYPE_None, SPA_TYPE_INFO_PROPS_BASE \"unknown\", NULL },\n+    { SPA_PROP_device, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"device\", NULL },\n+    { SPA_PROP_deviceName, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"deviceName\", NULL },\n+    { SPA_PROP_deviceFd, SPA_TYPE_Fd, SPA_TYPE_INFO_PROPS_BASE \"deviceFd\", NULL },\n+    { SPA_PROP_card, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"card\", NULL },\n+    { SPA_PROP_cardName, SPA_TYPE_String, SPA_TYPE_INFO_PROPS_BASE \"cardName\", NULL },\n+    { SPA_PROP_minLatency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"minLatency\", NULL },\n+    { SPA_PROP_maxLatency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"maxLatency\", NULL },\n+    { SPA_PROP_periods, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"periods\", NULL },\n+    { SPA_PROP_periodSize, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"periodSize\", NULL },\n+    { SPA_PROP_periodEvent, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"periodEvent\", NULL },\n+    { SPA_PROP_live, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"live\", NULL },\n+    { SPA_PROP_rate, SPA_TYPE_Double, SPA_TYPE_INFO_PROPS_BASE \"rate\", NULL },\n+    { SPA_PROP_quality, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"quality\", NULL },\n+    { SPA_PROP_bluetoothAudioCodec, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"bluetoothAudioCodec\", spa_type_bluetooth_audio_codec },\n+    { SPA_PROP_bluetoothOffloadActive, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"bluetoothOffloadActive\", NULL },\n+\n+    { SPA_PROP_waveType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"waveType\", NULL },\n+    { SPA_PROP_frequency, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"frequency\", NULL },\n+    { SPA_PROP_volume, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volume\", NULL },\n+    { SPA_PROP_mute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"mute\", NULL },\n+    { SPA_PROP_patternType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"patternType\", NULL },\n+    { SPA_PROP_ditherType, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"ditherType\", NULL },\n+    { SPA_PROP_truncate, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"truncate\", NULL },\n+    { SPA_PROP_channelVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"channelVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_volumeBase, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volumeBase\", NULL },\n+    { SPA_PROP_volumeStep, SPA_TYPE_Float, SPA_TYPE_INFO_PROPS_BASE \"volumeStep\", NULL },\n+    { SPA_PROP_channelMap, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"channelMap\", spa_type_prop_channel_map },\n+    { SPA_PROP_monitorMute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"monitorMute\", NULL },\n+    { SPA_PROP_monitorVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"monitorVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_latencyOffsetNsec, SPA_TYPE_Long, SPA_TYPE_INFO_PROPS_BASE \"latencyOffsetNsec\", NULL },\n+    { SPA_PROP_softMute, SPA_TYPE_Bool, SPA_TYPE_INFO_PROPS_BASE \"softMute\", NULL },\n+    { SPA_PROP_softVolumes, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"softVolumes\", spa_type_prop_float_array },\n+    { SPA_PROP_iec958Codecs, SPA_TYPE_Array, SPA_TYPE_INFO_PROPS_BASE \"iec958Codecs\", spa_type_prop_iec958_codec },\n+    { SPA_PROP_volumeRampSamples, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampSamples\", NULL },\n+    { SPA_PROP_volumeRampStepSamples, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampStepSamples\", NULL },\n+    { SPA_PROP_volumeRampTime, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampTime\", NULL },\n+    { SPA_PROP_volumeRampStepTime, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"volumeRampStepTime\", NULL },\n+    { SPA_PROP_volumeRampScale, SPA_TYPE_Id, SPA_TYPE_INFO_PROPS_BASE \"volumeRampScale\", NULL },\n+\n+    { SPA_PROP_brightness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"brightness\", NULL },\n+    { SPA_PROP_contrast, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"contrast\", NULL },\n+    { SPA_PROP_saturation, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"saturation\", NULL },\n+    { SPA_PROP_hue, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"hue\", NULL },\n+    { SPA_PROP_gamma, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"gamma\", NULL },\n+    { SPA_PROP_exposure, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"exposure\", NULL },\n+    { SPA_PROP_gain, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"gain\", NULL },\n+    { SPA_PROP_sharpness, SPA_TYPE_Int, SPA_TYPE_INFO_PROPS_BASE \"sharpness\", NULL },\n+\n+    { SPA_PROP_params, SPA_TYPE_Struct, SPA_TYPE_INFO_PROPS_BASE \"params\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/** Enum Property info *\/\n+#define SPA_TYPE_INFO_PropInfo            SPA_TYPE_INFO_PARAM_BASE \"PropInfo\"\n+#define SPA_TYPE_INFO_PROP_INFO_BASE        SPA_TYPE_INFO_PropInfo \":\"\n+\n+static const struct spa_type_info spa_type_prop_info[] = {\n+    { SPA_PROP_INFO_START, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE, spa_type_param, },\n+    { SPA_PROP_INFO_id, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE \"id\", spa_type_props },\n+    { SPA_PROP_INFO_name, SPA_TYPE_String, SPA_TYPE_INFO_PROP_INFO_BASE \"name\", NULL },\n+    { SPA_PROP_INFO_type, SPA_TYPE_Pod, SPA_TYPE_INFO_PROP_INFO_BASE \"type\", NULL },\n+    { SPA_PROP_INFO_labels, SPA_TYPE_Struct, SPA_TYPE_INFO_PROP_INFO_BASE \"labels\", NULL },\n+    { SPA_PROP_INFO_container, SPA_TYPE_Id, SPA_TYPE_INFO_PROP_INFO_BASE \"container\", NULL },\n+    { SPA_PROP_INFO_params, SPA_TYPE_Bool, SPA_TYPE_INFO_PROP_INFO_BASE \"params\", NULL },\n+    { SPA_PROP_INFO_description, SPA_TYPE_String, SPA_TYPE_INFO_PROP_INFO_BASE \"description\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROPS_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/props-types.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_PROPS_H\n+#define SPA_PARAM_PROPS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties of SPA_TYPE_OBJECT_PropInfo *\/\n+enum spa_prop_info {\n+    SPA_PROP_INFO_START,\n+    SPA_PROP_INFO_id,        \/**< associated id of the property *\/\n+    SPA_PROP_INFO_name,        \/**< name of the property *\/\n+    SPA_PROP_INFO_type,        \/**< type and range\/enums of property *\/\n+    SPA_PROP_INFO_labels,        \/**< labels of property if any, this is a\n+                      *  struct with pairs of values, the first one\n+                      *  is of the type of the property, the second\n+                      *  one is a string with a user readable label\n+                      *  for the value. *\/\n+    SPA_PROP_INFO_container,    \/**< type of container if any (Id) *\/\n+    SPA_PROP_INFO_params,        \/**< is part of params property (Bool) *\/\n+    SPA_PROP_INFO_description,    \/**< User readable description *\/\n+};\n+\n+\/** predefined properties for SPA_TYPE_OBJECT_Props *\/\n+enum spa_prop {\n+    SPA_PROP_START,\n+\n+    SPA_PROP_unknown,        \/**< an unknown property *\/\n+\n+    SPA_PROP_START_Device    = 0x100,    \/**< device related properties *\/\n+    SPA_PROP_device,\n+    SPA_PROP_deviceName,\n+    SPA_PROP_deviceFd,\n+    SPA_PROP_card,\n+    SPA_PROP_cardName,\n+\n+    SPA_PROP_minLatency,\n+    SPA_PROP_maxLatency,\n+    SPA_PROP_periods,\n+    SPA_PROP_periodSize,\n+    SPA_PROP_periodEvent,\n+    SPA_PROP_live,\n+    SPA_PROP_rate,\n+    SPA_PROP_quality,\n+    SPA_PROP_bluetoothAudioCodec,\n+    SPA_PROP_bluetoothOffloadActive,\n+\n+    SPA_PROP_START_Audio    = 0x10000,    \/**< audio related properties *\/\n+    SPA_PROP_waveType,\n+    SPA_PROP_frequency,\n+    SPA_PROP_volume,                \/**< a volume (Float), 0.0 silence, 1.0 normal *\/\n+    SPA_PROP_mute,                \/**< mute (Bool) *\/\n+    SPA_PROP_patternType,\n+    SPA_PROP_ditherType,\n+    SPA_PROP_truncate,\n+    SPA_PROP_channelVolumes,        \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+    SPA_PROP_volumeBase,            \/**< a volume base (Float) *\/\n+    SPA_PROP_volumeStep,            \/**< a volume step (Float) *\/\n+    SPA_PROP_channelMap,            \/**< a channelmap array\n+                          * (Array (Id enum spa_audio_channel)) *\/\n+    SPA_PROP_monitorMute,            \/**< mute (Bool) *\/\n+    SPA_PROP_monitorVolumes,        \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+    SPA_PROP_latencyOffsetNsec,        \/**< delay adjustment *\/\n+    SPA_PROP_softMute,            \/**< mute (Bool) *\/\n+    SPA_PROP_softVolumes,            \/**< a volume array, one volume per\n+                          *  channel (Array of Float) *\/\n+\n+    SPA_PROP_iec958Codecs,            \/**< enabled IEC958 (S\/PDIF) codecs,\n+                          *  (Array (Id enum spa_audio_iec958_codec) *\/\n+    SPA_PROP_volumeRampSamples,        \/**< Samples to ramp the volume over *\/\n+    SPA_PROP_volumeRampStepSamples,        \/**< Step or incremental Samples to ramp\n+                          *  the volume over *\/\n+    SPA_PROP_volumeRampTime,        \/**< Time in millisec to ramp the volume over *\/\n+    SPA_PROP_volumeRampStepTime,        \/**< Step or incremental Time in nano seconds\n+                          *  to ramp the *\/\n+    SPA_PROP_volumeRampScale,        \/**< the scale or graph to used to ramp the\n+                          *  volume *\/\n+\n+    SPA_PROP_START_Video    = 0x20000,    \/**< video related properties *\/\n+    SPA_PROP_brightness,\n+    SPA_PROP_contrast,\n+    SPA_PROP_saturation,\n+    SPA_PROP_hue,\n+    SPA_PROP_gamma,\n+    SPA_PROP_exposure,\n+    SPA_PROP_gain,\n+    SPA_PROP_sharpness,\n+\n+    SPA_PROP_START_Other    = 0x80000,    \/**< other properties *\/\n+    SPA_PROP_params,            \/**< simple control params\n+                          *    (Struct(\n+                          *      (String : key,\n+                          *       Pod    : value)*)) *\/\n+\n+\n+    SPA_PROP_START_CUSTOM    = 0x1000000,\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_PROPS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/props.h","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_ROUTE_TYPES_H\n+#define SPA_PARAM_ROUTE_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/utils\/enum-types.h>\n+#include <spa\/param\/param-types.h>\n+\n+#include <spa\/param\/route.h>\n+\n+#define SPA_TYPE_INFO_PARAM_Route        SPA_TYPE_INFO_PARAM_BASE \"Route\"\n+#define SPA_TYPE_INFO_PARAM_ROUTE_BASE        SPA_TYPE_INFO_PARAM_Route \":\"\n+\n+static const struct spa_type_info spa_type_param_route[] = {\n+    { SPA_PARAM_ROUTE_START, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE, spa_type_param, },\n+    { SPA_PARAM_ROUTE_index, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"index\", NULL, },\n+    { SPA_PARAM_ROUTE_direction, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"direction\", spa_type_direction, },\n+    { SPA_PARAM_ROUTE_device, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"device\", NULL, },\n+    { SPA_PARAM_ROUTE_name, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"name\", NULL, },\n+    { SPA_PARAM_ROUTE_description, SPA_TYPE_String, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"description\", NULL, },\n+    { SPA_PARAM_ROUTE_priority, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"priority\", NULL, },\n+    { SPA_PARAM_ROUTE_available, SPA_TYPE_Id, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"available\", spa_type_param_availability, },\n+    { SPA_PARAM_ROUTE_info, SPA_TYPE_Struct, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"info\", NULL, },\n+    { SPA_PARAM_ROUTE_profiles, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profiles\", NULL, },\n+    { SPA_PARAM_ROUTE_props, SPA_TYPE_OBJECT_Props, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"props\", NULL, },\n+    { SPA_PARAM_ROUTE_devices, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"devices\", NULL, },\n+    { SPA_PARAM_ROUTE_profile, SPA_TYPE_Int, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"profile\", NULL, },\n+    { SPA_PARAM_ROUTE_save, SPA_TYPE_Bool, SPA_TYPE_INFO_PARAM_ROUTE_BASE \"save\", NULL, },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_ROUTE_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/route-types.h","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_ROUTE_H\n+#define SPA_PARAM_ROUTE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/param.h>\n+\n+\/** properties for SPA_TYPE_OBJECT_ParamRoute *\/\n+enum spa_param_route {\n+    SPA_PARAM_ROUTE_START,\n+    SPA_PARAM_ROUTE_index,            \/**< index of the routing destination (Int) *\/\n+    SPA_PARAM_ROUTE_direction,        \/**< direction, input\/output (Id enum spa_direction) *\/\n+    SPA_PARAM_ROUTE_device,            \/**< device id (Int) *\/\n+    SPA_PARAM_ROUTE_name,            \/**< name of the routing destination (String) *\/\n+    SPA_PARAM_ROUTE_description,        \/**< description of the destination (String) *\/\n+    SPA_PARAM_ROUTE_priority,        \/**< priority of the destination (Int) *\/\n+    SPA_PARAM_ROUTE_available,        \/**< availability of the destination\n+                          *  (Id enum spa_param_availability) *\/\n+    SPA_PARAM_ROUTE_info,            \/**< info (Struct(\n+                          *          Int : n_items,\n+                          *          (String : key,\n+                          *           String : value)*)) *\/\n+    SPA_PARAM_ROUTE_profiles,        \/**< associated profile indexes (Array of Int) *\/\n+    SPA_PARAM_ROUTE_props,            \/**< properties SPA_TYPE_OBJECT_Props *\/\n+    SPA_PARAM_ROUTE_devices,        \/**< associated device indexes (Array of Int) *\/\n+    SPA_PARAM_ROUTE_profile,        \/**< profile id (Int) *\/\n+    SPA_PARAM_ROUTE_save,            \/**< If route should be saved (Bool) *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_ROUTE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/route.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_TYPE_INFO_H\n+#define SPA_PARAM_TYPE_INFO_H\n+\n+#include <spa\/param\/param-types.h>\n+#include <spa\/param\/buffers-types.h>\n+#include <spa\/param\/props-types.h>\n+#include <spa\/param\/format-types.h>\n+#include <spa\/param\/latency-types.h>\n+#include <spa\/param\/port-config-types.h>\n+#include <spa\/param\/profiler-types.h>\n+#include <spa\/param\/profile-types.h>\n+#include <spa\/param\/route-types.h>\n+\n+#endif \/* SPA_PARAM_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/type-info.h","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_CHROMA_H\n+#define SPA_VIDEO_CHROMA_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/** Various Chroma settings.\n+ *\/\n+enum spa_video_chroma_site {\n+    SPA_VIDEO_CHROMA_SITE_UNKNOWN = 0,        \/**< unknown cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_NONE = (1 << 0),        \/**< no cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_H_COSITED = (1 << 1),    \/**< chroma is horizontally cosited *\/\n+    SPA_VIDEO_CHROMA_SITE_V_COSITED = (1 << 2),    \/**< chroma is vertically cosited *\/\n+    SPA_VIDEO_CHROMA_SITE_ALT_LINE = (1 << 3),    \/**< chroma samples are sited on alternate lines *\/\n+    \/* some common chroma cositing *\/\n+    \/** chroma samples cosited with luma samples *\/\n+    SPA_VIDEO_CHROMA_SITE_COSITED = (SPA_VIDEO_CHROMA_SITE_H_COSITED | SPA_VIDEO_CHROMA_SITE_V_COSITED),\n+    \/** jpeg style cositing, also for mpeg1 and mjpeg *\/\n+    SPA_VIDEO_CHROMA_SITE_JPEG = (SPA_VIDEO_CHROMA_SITE_NONE),\n+    \/** mpeg2 style cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_MPEG2 = (SPA_VIDEO_CHROMA_SITE_H_COSITED),\n+    \/**< DV style cositing *\/\n+    SPA_VIDEO_CHROMA_SITE_DV = (SPA_VIDEO_CHROMA_SITE_COSITED | SPA_VIDEO_CHROMA_SITE_ALT_LINE),\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_CHROMA_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/chroma.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_COLOR_H\n+#define SPA_VIDEO_COLOR_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/**\n+ * Possible color range values. These constants are defined for 8 bit color\n+ * values and can be scaled for other bit depths.\n+ *\/\n+enum spa_video_color_range {\n+    SPA_VIDEO_COLOR_RANGE_UNKNOWN = 0,    \/**< unknown range *\/\n+    SPA_VIDEO_COLOR_RANGE_0_255,        \/**< [0..255] for 8 bit components *\/\n+    SPA_VIDEO_COLOR_RANGE_16_235        \/**< [16..235] for 8 bit components. Chroma has\n+                             [16..240] range. *\/\n+};\n+\n+\/**\n+ * The color matrix is used to convert between Y'PbPr and\n+ * non-linear RGB (R'G'B')\n+ *\/\n+enum spa_video_color_matrix {\n+    SPA_VIDEO_COLOR_MATRIX_UNKNOWN = 0,    \/**< unknown matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_RGB,        \/**< identity matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_FCC,        \/**< FCC color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT709,        \/**< ITU BT.709 color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT601,        \/**< ITU BT.601 color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_SMPTE240M,    \/**< SMTPE  240M color matrix *\/\n+    SPA_VIDEO_COLOR_MATRIX_BT2020,        \/**<  ITU-R BT.2020 color matrix. since 1.6. *\/\n+};\n+\n+\/**\n+ * The video transfer function defines the formula for converting between\n+ * non-linear RGB (R'G'B') and linear RGB\n+ *\/\n+enum spa_video_transfer_function {\n+    SPA_VIDEO_TRANSFER_UNKNOWN = 0,    \/**< unknown transfer function *\/\n+    SPA_VIDEO_TRANSFER_GAMMA10,    \/**< linear RGB, gamma 1.0 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA18,    \/**< Gamma 1.8 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA20,    \/**< Gamma 2.0 curve *\/\n+    SPA_VIDEO_TRANSFER_GAMMA22,    \/**< Gamma 2.2 curve *\/\n+    SPA_VIDEO_TRANSFER_BT709,    \/**< Gamma 2.2 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_SMPTE240M,    \/**< Gamma 2.2 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_SRGB,    \/**< Gamma 2.4 curve with a linear segment in the lower range *\/\n+    SPA_VIDEO_TRANSFER_GAMMA28,    \/**< Gamma 2.8 curve *\/\n+    SPA_VIDEO_TRANSFER_LOG100,    \/**< Logarithmic transfer characteristic 100:1 range *\/\n+    SPA_VIDEO_TRANSFER_LOG316,    \/**< Logarithmic transfer characteristic 316.22777:1 range *\/\n+    SPA_VIDEO_TRANSFER_BT2020_12,    \/**< Gamma 2.2 curve with a linear segment in the lower\n+                     *   range. Used for BT.2020 with 12 bits per\n+                     *   component. \\since 1.6. *\/\n+    SPA_VIDEO_TRANSFER_ADOBERGB,    \/**< Gamma 2.19921875. \\since 1.8 *\/\n+};\n+\n+\/**\n+ * The color primaries define the how to transform linear RGB values to and from\n+ * the CIE XYZ colorspace.\n+ *\/\n+enum spa_video_color_primaries {\n+    SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN = 0,    \/**< unknown color primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT709,    \/**< BT709 primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT470M,    \/**< BT470M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT470BG,    \/**< BT470BG primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M,    \/**< SMPTE170M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M,    \/**< SMPTE240M primaries *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_FILM,        \/**< Generic film *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_BT2020,    \/**< BT2020 primaries. \\since 1.6. *\/\n+    SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB,    \/**< Adobe RGB primaries. \\since 1.8 *\/\n+};\n+\n+\/**\n+ * spa_video_colorimetry:\n+ *\n+ * Structure describing the color info.\n+ *\/\n+struct spa_video_colorimetry {\n+    enum spa_video_color_range range;    \/**< The color range. This is the valid range for the\n+                         *    samples. It is used to convert the samples to Y'PbPr\n+                         *    values. *\/\n+    enum spa_video_color_matrix matrix;    \/**< the color matrix. Used to convert between Y'PbPr and\n+                         *    non-linear RGB (R'G'B') *\/\n+    enum spa_video_transfer_function transfer; \/**< The transfer function. Used to convert between\n+                            *   R'G'B' and RGB *\/\n+    enum spa_video_color_primaries primaries; \/**< Color primaries. Used to convert between R'G'B'\n+                           *   and CIE XYZ *\/\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_COLOR_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/color.h","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_DSP_UTILS_H\n+#define SPA_VIDEO_DSP_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/dsp.h>\n+\n+static inline int\n+spa_format_video_dsp_parse(const struct spa_pod *format,\n+               struct spa_video_info_dsp *info)\n+{\n+    info->flags = SPA_VIDEO_FLAG_NONE;\n+    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+        info->flags |= SPA_VIDEO_FLAG_MODIFIER;\n+    }\n+\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_VIDEO_format,        SPA_POD_OPT_Id(&info->format),\n+        SPA_FORMAT_VIDEO_modifier,        SPA_POD_OPT_Long(&info->modifier));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_dsp_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_dsp *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_dsp),\n+            0);\n+    if (info->format != SPA_VIDEO_FORMAT_UNKNOWN)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_format,    SPA_POD_Id(info->format), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_DSP_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/dsp-utils.h","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_DSP_H\n+#define SPA_VIDEO_DSP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/video\/raw.h>\n+\n+struct spa_video_info_dsp {\n+    enum spa_video_format format;\n+    uint32_t flags;\n+    uint64_t modifier;\n+};\n+\n+#define SPA_VIDEO_INFO_DSP_INIT(...)    ((struct spa_video_info_dsp) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_DSP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/dsp.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_ENCODED_H\n+#define SPA_VIDEO_ENCODED_H\n+\n+#include <spa\/param\/video\/h264.h>\n+#include <spa\/param\/video\/mjpg.h>\n+\n+#endif \/* SPA_VIDEO_ENCODED_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/encoded.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_VIDEO_FORMAT_UTILS_H\n+#define SPA_PARAM_VIDEO_FORMAT_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/param\/format-utils.h>\n+#include <spa\/param\/video\/format.h>\n+#include <spa\/param\/video\/raw-utils.h>\n+#include <spa\/param\/video\/dsp-utils.h>\n+#include <spa\/param\/video\/h264-utils.h>\n+#include <spa\/param\/video\/mjpg-utils.h>\n+\n+static inline int\n+spa_format_video_parse(const struct spa_pod *format, struct spa_video_info *info)\n+{\n+    int res;\n+\n+    if ((res = spa_format_parse(format, &info->media_type, &info->media_subtype)) < 0)\n+        return res;\n+\n+    if (info->media_type != SPA_MEDIA_TYPE_video)\n+        return -EINVAL;\n+\n+    switch (info->media_subtype) {\n+    case SPA_MEDIA_SUBTYPE_raw:\n+        return spa_format_video_raw_parse(format, &info->info.raw);\n+    case SPA_MEDIA_SUBTYPE_dsp:\n+        return spa_format_video_dsp_parse(format, &info->info.dsp);\n+    case SPA_MEDIA_SUBTYPE_h264:\n+        return spa_format_video_h264_parse(format, &info->info.h264);\n+    case SPA_MEDIA_SUBTYPE_mjpg:\n+        return spa_format_video_mjpg_parse(format, &info->info.mjpg);\n+    }\n+    return -ENOTSUP;\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_build(struct spa_pod_builder *builder, uint32_t id, struct spa_video_info *info)\n+{\n+    switch (info->media_subtype) {\n+    case SPA_MEDIA_SUBTYPE_raw:\n+        return spa_format_video_raw_build(builder, id, &info->info.raw);\n+    case SPA_MEDIA_SUBTYPE_dsp:\n+        return spa_format_video_dsp_build(builder, id, &info->info.dsp);\n+    case SPA_MEDIA_SUBTYPE_h264:\n+        return spa_format_video_h264_build(builder, id, &info->info.h264);\n+    case SPA_MEDIA_SUBTYPE_mjpg:\n+        return spa_format_video_mjpg_build(builder, id, &info->info.mjpg);\n+    }\n+    errno = ENOTSUP;\n+    return NULL;\n+}\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_VIDEO_FORMAT_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/format-utils.h","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_PARAM_VIDEO_FORMAT_H\n+#define SPA_PARAM_VIDEO_FORMAT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/video\/raw.h>\n+#include <spa\/param\/video\/dsp.h>\n+#include <spa\/param\/video\/encoded.h>\n+\n+struct spa_video_info {\n+    uint32_t media_type;\n+    uint32_t media_subtype;\n+    union {\n+        struct spa_video_info_raw raw;\n+        struct spa_video_info_dsp dsp;\n+        struct spa_video_info_h264 h264;\n+        struct spa_video_info_mjpg mjpg;\n+    } info;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_PARAM_VIDEO_FORMAT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/format.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_H264_UTILS_H\n+#define SPA_VIDEO_H264_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/h264.h>\n+\n+static inline int\n+spa_format_video_h264_parse(const struct spa_pod *format,\n+                struct spa_video_info_h264 *info)\n+{\n+    return spa_pod_parse_object(format,\n+            SPA_TYPE_OBJECT_Format, NULL,\n+            SPA_FORMAT_VIDEO_size,            SPA_POD_OPT_Rectangle(&info->size),\n+            SPA_FORMAT_VIDEO_framerate,        SPA_POD_OPT_Fraction(&info->framerate),\n+            SPA_FORMAT_VIDEO_maxFramerate,        SPA_POD_OPT_Fraction(&info->max_framerate),\n+            SPA_FORMAT_VIDEO_H264_streamFormat,    SPA_POD_OPT_Id(&info->stream_format),\n+            SPA_FORMAT_VIDEO_H264_alignment,    SPA_POD_OPT_Id(&info->alignment));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_h264_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_h264 *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_h264),\n+            0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    if (info->stream_format != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_H264_streamFormat, SPA_POD_Id(info->stream_format), 0);\n+    if (info->alignment != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_H264_alignment, SPA_POD_Id(info->alignment), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_H264_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/h264-utils.h","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2023 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_H264_H\n+#define SPA_VIDEO_H264_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+\n+enum spa_h264_stream_format {\n+    SPA_H264_STREAM_FORMAT_UNKNOWN = 0,\n+    SPA_H264_STREAM_FORMAT_AVC,\n+    SPA_H264_STREAM_FORMAT_AVC3,\n+    SPA_H264_STREAM_FORMAT_BYTESTREAM\n+};\n+\n+enum spa_h264_alignment {\n+    SPA_H264_ALIGNMENT_UNKNOWN = 0,\n+    SPA_H264_ALIGNMENT_AU,\n+    SPA_H264_ALIGNMENT_NAL\n+};\n+\n+struct spa_video_info_h264 {\n+    struct spa_rectangle size;\n+    struct spa_fraction framerate;\n+    struct spa_fraction max_framerate;\n+    enum spa_h264_stream_format stream_format;\n+    enum spa_h264_alignment alignment;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_H264_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/h264.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MJPG_UTILS_H\n+#define SPA_VIDEO_MJPG_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/mjpg.h>\n+\n+static inline int\n+spa_format_video_mjpg_parse(const struct spa_pod *format,\n+                struct spa_video_info_mjpg *info)\n+{\n+    return spa_pod_parse_object(format,\n+            SPA_TYPE_OBJECT_Format, NULL,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_OPT_Rectangle(&info->size),\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_OPT_Fraction(&info->framerate),\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_OPT_Fraction(&info->max_framerate));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_mjpg_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_mjpg *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_mjpg),\n+            0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MJPG_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/mjpg-utils.h","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MJPG_H\n+#define SPA_VIDEO_MJPG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+\n+struct spa_video_info_mjpg {\n+    struct spa_rectangle size;\n+    struct spa_fraction framerate;\n+    struct spa_fraction max_framerate;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MJPG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/mjpg.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_MULTIVIEW_H\n+#define SPA_VIDEO_MULTIVIEW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+\/**\n+ * All possible stereoscopic 3D and multiview representations.\n+ * In conjunction with \\ref spa_video_multiview_flags, describes how\n+ * multiview content is being transported in the stream.\n+ *\/\n+enum spa_video_multiview_mode {\n+    \/** A special value indicating no multiview information. Used in spa_video_info and other\n+     * places to indicate that no specific multiview handling has been requested or provided.\n+     * This value is never carried on caps. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_NONE = -1,\n+    SPA_VIDEO_MULTIVIEW_MODE_MONO = 0,        \/**< All frames are monoscopic *\/\n+    \/* Single view modes *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_LEFT,            \/**< All frames represent a left-eye view *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_RIGHT,            \/**< All frames represent a right-eye view *\/\n+    \/* Stereo view modes *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE,        \/**< Left and right eye views are provided\n+                             *   in the left and right half of the frame\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX, \/**< Left and right eye views are provided\n+                             *   in the left and right half of the\n+                             *   frame, but have been sampled using\n+                             *   quincunx method, with half-pixel offset\n+                             *   between the 2 views. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED,    \/**< Alternating vertical columns of pixels\n+                             *   represent the left and right eye view\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED,    \/**< Alternating horizontal rows of pixels\n+                             *   represent the left and right eye view\n+                             *   respectively. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM,        \/**< The top half of the frame contains the\n+                             *   left eye, and the bottom half the right\n+                             *   eye. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD,        \/**< Pixels are arranged with alternating\n+                             *   pixels representing left and right eye\n+                             *   views in a checkerboard fashion. *\/\n+    \/* Padding for new frame packing modes *\/\n+\n+    SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME = 32,    \/**< Left and right eye views are provided\n+                             *   in separate frames alternately. *\/\n+    \/* Multiview mode(s) *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME, \/**< Multipleindependent views are\n+                                *   provided in separate frames in\n+                                *   sequence. This method only applies to\n+                                *   raw video buffers at the moment.\n+                                *   Specific view identification is via\n+                                *   \\ref spa_video_multiview_meta on raw\n+                                *   video buffers. *\/\n+    SPA_VIDEO_MULTIVIEW_MODE_SEPARATED,        \/**< Multiple views are provided as separate\n+                             *   \\ref spa_data framebuffers attached\n+                             *   to each \\ref spa_buffer, described\n+                             *   by the \\ref spa_video_multiview_meta *\/\n+    \/* future expansion for annotated modes *\/\n+};\n+\n+\/**\n+ * spa_video_multiview_flags are used to indicate extra properties of a\n+ * stereo\/multiview stream beyond the frame layout and buffer mapping\n+ * that is conveyed in the \\ref spa_video_multiview_mode.\n+ *\/\n+enum spa_video_multiview_flags {\n+    SPA_VIDEO_MULTIVIEW_FLAGS_NONE = 0,            \/**< No flags *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST = (1 << 0),    \/**< For stereo streams, the normal arrangement\n+                                 *   of left and right views is reversed *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED = (1 << 1),    \/**< The left view is vertically mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED = (1 << 2),    \/**< The left view is horizontally mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED = (1 << 3),    \/**< The right view is vertically mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED = (1 << 4),    \/**< The right view is horizontally mirrored *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT = (1 << 14),    \/**< For frame-packed multiview\n+                                 *   modes, indicates that the individual\n+                                 *   views have been encoded with half the true\n+                                 *   width or height and should be scaled back\n+                                 *   up for display. This flag is used for\n+                                 *   overriding input layout interpretation\n+                                 *   by adjusting pixel-aspect-ratio.\n+                                 *   For side-by-side, column interleaved or\n+                                 *   checkerboard packings, the\n+                                 *   pixel width will be doubled.\n+                                 *   For row interleaved and\n+                                 *   top-bottom encodings, pixel height will\n+                                 *   be doubled *\/\n+    SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO = (1 << 15),    \/**< The video stream contains both\n+                                 *   mono and multiview portions,\n+                                 *   signalled on each buffer by the\n+                                 *   absence or presence of the\n+                                 *   \\ref SPA_VIDEO_BUFFER_FLAG_MULTIPLE_VIEW\n+                                 *   buffer flag. *\/\n+};\n+\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_MULTIVIEW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/multiview.h","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_TYPES_H\n+#define SPA_VIDEO_RAW_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+#include <spa\/utils\/type.h>\n+#include <spa\/param\/video\/raw.h>\n+\n+#define SPA_TYPE_INFO_VideoFormat        SPA_TYPE_INFO_ENUM_BASE \"VideoFormat\"\n+#define SPA_TYPE_INFO_VIDEO_FORMAT_BASE        SPA_TYPE_INFO_VideoFormat \":\"\n+\n+static const struct spa_type_info spa_type_video_format[] = {\n+    { SPA_VIDEO_FORMAT_ENCODED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"encoded\", NULL },\n+    { SPA_VIDEO_FORMAT_I420,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420\", NULL },\n+    { SPA_VIDEO_FORMAT_YV12,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YV12\", NULL },\n+    { SPA_VIDEO_FORMAT_YUY2,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YUY2\", NULL },\n+    { SPA_VIDEO_FORMAT_UYVY,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"UYVY\", NULL },\n+    { SPA_VIDEO_FORMAT_AYUV,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"AYUV\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBx,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBx\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRx,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRx\", NULL },\n+    { SPA_VIDEO_FORMAT_xRGB,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xRGB\", NULL },\n+    { SPA_VIDEO_FORMAT_xBGR,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xBGR\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRA\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB\", NULL },\n+    { SPA_VIDEO_FORMAT_ABGR,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ABGR\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR\", NULL },\n+    { SPA_VIDEO_FORMAT_Y41B,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y41B\", NULL },\n+    { SPA_VIDEO_FORMAT_Y42B,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y42B\", NULL },\n+    { SPA_VIDEO_FORMAT_YVYU,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YVYU\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444\", NULL },\n+    { SPA_VIDEO_FORMAT_v210,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v210\", NULL },\n+    { SPA_VIDEO_FORMAT_v216,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v216\", NULL },\n+    { SPA_VIDEO_FORMAT_NV12,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV12\", NULL },\n+    { SPA_VIDEO_FORMAT_NV21,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV21\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY8,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY8\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY16_BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY16_BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GRAY16_LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GRAY16_LE\", NULL },\n+    { SPA_VIDEO_FORMAT_v308,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"v308\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB16\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR16\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB15,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB15\", NULL },\n+    { SPA_VIDEO_FORMAT_BGR15,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGR15\", NULL },\n+    { SPA_VIDEO_FORMAT_UYVP,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"UYVP\", NULL },\n+    { SPA_VIDEO_FORMAT_A420,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420\", NULL },\n+    { SPA_VIDEO_FORMAT_RGB8P,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGB8P\", NULL },\n+    { SPA_VIDEO_FORMAT_YUV9,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YUV9\", NULL },\n+    { SPA_VIDEO_FORMAT_YVU9,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"YVU9\", NULL },\n+    { SPA_VIDEO_FORMAT_IYU1,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"IYU1\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB64,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB64\", NULL },\n+    { SPA_VIDEO_FORMAT_AYUV64,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"AYUV64\", NULL },\n+    { SPA_VIDEO_FORMAT_r210,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"r210\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR,        SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_NV16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV16\", NULL },\n+    { SPA_VIDEO_FORMAT_NV24,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV24\", NULL },\n+    { SPA_VIDEO_FORMAT_NV12_64Z32,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV12_64Z32\", NULL },\n+    { SPA_VIDEO_FORMAT_A420_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A420_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A420_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_A422_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A422_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A422_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A422_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_A444_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A444_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_A444_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"A444_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_NV61,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"NV61\", NULL },\n+    { SPA_VIDEO_FORMAT_P010_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"P010_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_P010_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"P010_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_IYU2,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"IYU2\", NULL },\n+    { SPA_VIDEO_FORMAT_VYUY,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"VYUY\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_10BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_10BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_10LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_10LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBR_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBR_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_GBRA_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"GBRA_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I420_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I420_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_I422_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"I422_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_12BE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_12BE\", NULL },\n+    { SPA_VIDEO_FORMAT_Y444_12LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"Y444_12LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_F16,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_F16\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_F32,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_F32\", NULL },\n+    { SPA_VIDEO_FORMAT_xRGB_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xRGB_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_xBGR_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"xBGR_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBx_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBx_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRx_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRx_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_ARGB_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ARGB_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_ABGR_210LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"ABGR_210LE\", NULL },\n+    { SPA_VIDEO_FORMAT_RGBA_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"RGBA_102LE\", NULL },\n+    { SPA_VIDEO_FORMAT_BGRA_102LE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FORMAT_BASE \"BGRA_102LE\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_VideoFlags    SPA_TYPE_INFO_FLAGS_BASE \"VideoFlags\"\n+#define SPA_TYPE_INFO_VIDEO_FLAGS_BASE    SPA_TYPE_INFO_VideoFlags \":\"\n+\n+static const struct spa_type_info spa_type_video_flags[] = {\n+\n+    { SPA_VIDEO_FLAG_NONE, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"none\", NULL },\n+    { SPA_VIDEO_FLAG_VARIABLE_FPS, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"variable-fps\", NULL },\n+    { SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"premultiplied-alpha\", NULL },\n+    { SPA_VIDEO_FLAG_MODIFIER, SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_FLAGS_BASE \"modifier\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+#define SPA_TYPE_INFO_VideoInterlaceMode        SPA_TYPE_INFO_ENUM_BASE \"VideoInterlaceMode\"\n+#define SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE        SPA_TYPE_INFO_VideoInterlaceMode \":\"\n+\n+static const struct spa_type_info spa_type_video_interlace_mode[] = {\n+    { SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"progressive\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_INTERLEAVED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"interleaved\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_MIXED,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"mixed\", NULL },\n+    { SPA_VIDEO_INTERLACE_MODE_FIELDS,    SPA_TYPE_Int, SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE \"fields\", NULL },\n+    { 0, 0, NULL, NULL },\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw-types.h","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_UTILS_H\n+#define SPA_VIDEO_RAW_UTILS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/pod\/parser.h>\n+#include <spa\/pod\/builder.h>\n+#include <spa\/param\/video\/raw.h>\n+\n+static inline int\n+spa_format_video_raw_parse(const struct spa_pod *format,\n+               struct spa_video_info_raw *info)\n+{\n+    info->flags = SPA_VIDEO_FLAG_NONE;\n+    if (spa_pod_find_prop (format, NULL, SPA_FORMAT_VIDEO_modifier)) {\n+        info->flags |= SPA_VIDEO_FLAG_MODIFIER;\n+    }\n+\n+    return spa_pod_parse_object(format,\n+        SPA_TYPE_OBJECT_Format, NULL,\n+        SPA_FORMAT_VIDEO_format,        SPA_POD_OPT_Id(&info->format),\n+        SPA_FORMAT_VIDEO_modifier,        SPA_POD_OPT_Long(&info->modifier),\n+        SPA_FORMAT_VIDEO_size,            SPA_POD_OPT_Rectangle(&info->size),\n+        SPA_FORMAT_VIDEO_framerate,        SPA_POD_OPT_Fraction(&info->framerate),\n+        SPA_FORMAT_VIDEO_maxFramerate,        SPA_POD_OPT_Fraction(&info->max_framerate),\n+        SPA_FORMAT_VIDEO_views,            SPA_POD_OPT_Int(&info->views),\n+        SPA_FORMAT_VIDEO_interlaceMode,        SPA_POD_OPT_Id(&info->interlace_mode),\n+        SPA_FORMAT_VIDEO_pixelAspectRatio,    SPA_POD_OPT_Fraction(&info->pixel_aspect_ratio),\n+        SPA_FORMAT_VIDEO_multiviewMode,        SPA_POD_OPT_Id(&info->multiview_mode),\n+        SPA_FORMAT_VIDEO_multiviewFlags,    SPA_POD_OPT_Id(&info->multiview_flags),\n+        SPA_FORMAT_VIDEO_chromaSite,        SPA_POD_OPT_Id(&info->chroma_site),\n+        SPA_FORMAT_VIDEO_colorRange,        SPA_POD_OPT_Id(&info->color_range),\n+        SPA_FORMAT_VIDEO_colorMatrix,        SPA_POD_OPT_Id(&info->color_matrix),\n+        SPA_FORMAT_VIDEO_transferFunction,    SPA_POD_OPT_Id(&info->transfer_function),\n+        SPA_FORMAT_VIDEO_colorPrimaries,    SPA_POD_OPT_Id(&info->color_primaries));\n+}\n+\n+static inline struct spa_pod *\n+spa_format_video_raw_build(struct spa_pod_builder *builder, uint32_t id,\n+               struct spa_video_info_raw *info)\n+{\n+    struct spa_pod_frame f;\n+    spa_pod_builder_push_object(builder, &f, SPA_TYPE_OBJECT_Format, id);\n+    spa_pod_builder_add(builder,\n+            SPA_FORMAT_mediaType,        SPA_POD_Id(SPA_MEDIA_TYPE_video),\n+            SPA_FORMAT_mediaSubtype,    SPA_POD_Id(SPA_MEDIA_SUBTYPE_raw),\n+            0);\n+    if (info->format != SPA_VIDEO_FORMAT_UNKNOWN)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_format,    SPA_POD_Id(info->format), 0);\n+    if (info->size.width != 0 && info->size.height != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_size,        SPA_POD_Rectangle(&info->size), 0);\n+    if (info->framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_framerate,    SPA_POD_Fraction(&info->framerate), 0);\n+    if (info->modifier != 0 || info->flags & SPA_VIDEO_FLAG_MODIFIER)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_modifier,    SPA_POD_Long(info->modifier), 0);\n+    if (info->max_framerate.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_maxFramerate,    SPA_POD_Fraction(info->max_framerate), 0);\n+    if (info->views != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_views,        SPA_POD_Int(info->views), 0);\n+    if (info->interlace_mode != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_interlaceMode,    SPA_POD_Id(info->interlace_mode), 0);\n+    if (info->pixel_aspect_ratio.denom != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_pixelAspectRatio,SPA_POD_Fraction(info->pixel_aspect_ratio), 0);\n+    if (info->multiview_mode != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_multiviewMode,    SPA_POD_Id(info->multiview_mode), 0);\n+    if (info->multiview_flags != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_multiviewFlags,SPA_POD_Id(info->multiview_flags), 0);\n+    if (info->chroma_site != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_chromaSite,    SPA_POD_Id(info->chroma_site), 0);\n+    if (info->color_range != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorRange,    SPA_POD_Id(info->color_range), 0);\n+    if (info->color_matrix != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorMatrix,    SPA_POD_Id(info->color_matrix), 0);\n+    if (info->transfer_function != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_transferFunction,SPA_POD_Id(info->transfer_function), 0);\n+    if (info->color_primaries != 0)\n+        spa_pod_builder_add(builder,\n+            SPA_FORMAT_VIDEO_colorPrimaries,SPA_POD_Id(info->color_primaries), 0);\n+    return (struct spa_pod*)spa_pod_builder_pop(builder, &f);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_UTILS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw-utils.h","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_RAW_H\n+#define SPA_VIDEO_RAW_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\addtogroup spa_param\n+ * \\{\n+ *\/\n+\n+#include <spa\/param\/format.h>\n+#include <spa\/param\/video\/chroma.h>\n+#include <spa\/param\/video\/color.h>\n+#include <spa\/param\/video\/multiview.h>\n+\n+#define SPA_VIDEO_MAX_PLANES 4\n+#define SPA_VIDEO_MAX_COMPONENTS 4\n+\n+\/**\n+ * Video formats\n+ *\n+ * The components are in general described in big-endian order. There are some\n+ * exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n+ *\n+ * Most of the formats are identical to their GStreamer equivalent. See the\n+ * GStreamer video formats documentation for more details:\n+ *\n+ * https:\/\/gstreamer.freedesktop.org\/documentation\/additional\/design\/mediatype-video-raw.html#formats\n+ *\/\n+enum spa_video_format {\n+    SPA_VIDEO_FORMAT_UNKNOWN,\n+    SPA_VIDEO_FORMAT_ENCODED,\n+\n+    SPA_VIDEO_FORMAT_I420,\n+    SPA_VIDEO_FORMAT_YV12,\n+    SPA_VIDEO_FORMAT_YUY2,\n+    SPA_VIDEO_FORMAT_UYVY,\n+    SPA_VIDEO_FORMAT_AYUV,\n+    SPA_VIDEO_FORMAT_RGBx,\n+    SPA_VIDEO_FORMAT_BGRx,\n+    SPA_VIDEO_FORMAT_xRGB,\n+    SPA_VIDEO_FORMAT_xBGR,\n+    SPA_VIDEO_FORMAT_RGBA,\n+    SPA_VIDEO_FORMAT_BGRA,\n+    SPA_VIDEO_FORMAT_ARGB,\n+    SPA_VIDEO_FORMAT_ABGR,\n+    SPA_VIDEO_FORMAT_RGB,\n+    SPA_VIDEO_FORMAT_BGR,\n+    SPA_VIDEO_FORMAT_Y41B,\n+    SPA_VIDEO_FORMAT_Y42B,\n+    SPA_VIDEO_FORMAT_YVYU,\n+    SPA_VIDEO_FORMAT_Y444,\n+    SPA_VIDEO_FORMAT_v210,\n+    SPA_VIDEO_FORMAT_v216,\n+    SPA_VIDEO_FORMAT_NV12,\n+    SPA_VIDEO_FORMAT_NV21,\n+    SPA_VIDEO_FORMAT_GRAY8,\n+    SPA_VIDEO_FORMAT_GRAY16_BE,\n+    SPA_VIDEO_FORMAT_GRAY16_LE,\n+    SPA_VIDEO_FORMAT_v308,\n+    SPA_VIDEO_FORMAT_RGB16,\n+    SPA_VIDEO_FORMAT_BGR16,\n+    SPA_VIDEO_FORMAT_RGB15,\n+    SPA_VIDEO_FORMAT_BGR15,\n+    SPA_VIDEO_FORMAT_UYVP,\n+    SPA_VIDEO_FORMAT_A420,\n+    SPA_VIDEO_FORMAT_RGB8P,\n+    SPA_VIDEO_FORMAT_YUV9,\n+    SPA_VIDEO_FORMAT_YVU9,\n+    SPA_VIDEO_FORMAT_IYU1,\n+    SPA_VIDEO_FORMAT_ARGB64,\n+    SPA_VIDEO_FORMAT_AYUV64,\n+    SPA_VIDEO_FORMAT_r210,\n+    SPA_VIDEO_FORMAT_I420_10BE,\n+    SPA_VIDEO_FORMAT_I420_10LE,\n+    SPA_VIDEO_FORMAT_I422_10BE,\n+    SPA_VIDEO_FORMAT_I422_10LE,\n+    SPA_VIDEO_FORMAT_Y444_10BE,\n+    SPA_VIDEO_FORMAT_Y444_10LE,\n+    SPA_VIDEO_FORMAT_GBR,\n+    SPA_VIDEO_FORMAT_GBR_10BE,\n+    SPA_VIDEO_FORMAT_GBR_10LE,\n+    SPA_VIDEO_FORMAT_NV16,\n+    SPA_VIDEO_FORMAT_NV24,\n+    SPA_VIDEO_FORMAT_NV12_64Z32,\n+    SPA_VIDEO_FORMAT_A420_10BE,\n+    SPA_VIDEO_FORMAT_A420_10LE,\n+    SPA_VIDEO_FORMAT_A422_10BE,\n+    SPA_VIDEO_FORMAT_A422_10LE,\n+    SPA_VIDEO_FORMAT_A444_10BE,\n+    SPA_VIDEO_FORMAT_A444_10LE,\n+    SPA_VIDEO_FORMAT_NV61,\n+    SPA_VIDEO_FORMAT_P010_10BE,\n+    SPA_VIDEO_FORMAT_P010_10LE,\n+    SPA_VIDEO_FORMAT_IYU2,\n+    SPA_VIDEO_FORMAT_VYUY,\n+    SPA_VIDEO_FORMAT_GBRA,\n+    SPA_VIDEO_FORMAT_GBRA_10BE,\n+    SPA_VIDEO_FORMAT_GBRA_10LE,\n+    SPA_VIDEO_FORMAT_GBR_12BE,\n+    SPA_VIDEO_FORMAT_GBR_12LE,\n+    SPA_VIDEO_FORMAT_GBRA_12BE,\n+    SPA_VIDEO_FORMAT_GBRA_12LE,\n+    SPA_VIDEO_FORMAT_I420_12BE,\n+    SPA_VIDEO_FORMAT_I420_12LE,\n+    SPA_VIDEO_FORMAT_I422_12BE,\n+    SPA_VIDEO_FORMAT_I422_12LE,\n+    SPA_VIDEO_FORMAT_Y444_12BE,\n+    SPA_VIDEO_FORMAT_Y444_12LE,\n+\n+    SPA_VIDEO_FORMAT_RGBA_F16,\n+    SPA_VIDEO_FORMAT_RGBA_F32,\n+\n+    SPA_VIDEO_FORMAT_xRGB_210LE,    \/**< 32-bit x:R:G:B 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_xBGR_210LE,    \/**< 32-bit x:B:G:R 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_RGBx_102LE,    \/**< 32-bit R:G:B:x 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_BGRx_102LE,    \/**< 32-bit B:G:R:x 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_ARGB_210LE,    \/**< 32-bit A:R:G:B 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_ABGR_210LE,    \/**< 32-bit A:B:G:R 2:10:10:10 little endian *\/\n+    SPA_VIDEO_FORMAT_RGBA_102LE,    \/**< 32-bit R:G:B:A 10:10:10:2 little endian *\/\n+    SPA_VIDEO_FORMAT_BGRA_102LE,    \/**< 32-bit B:G:R:A 10:10:10:2 little endian *\/\n+\n+    \/* Aliases *\/\n+    SPA_VIDEO_FORMAT_DSP_F32 = SPA_VIDEO_FORMAT_RGBA_F32,\n+};\n+\n+\/**\n+ * Extra video flags\n+ *\/\n+enum spa_video_flags {\n+    SPA_VIDEO_FLAG_NONE = 0,            \/**< no flags *\/\n+    SPA_VIDEO_FLAG_VARIABLE_FPS = (1 << 0),        \/**< a variable fps is selected, fps_n and fps_d\n+                             *   denote the maximum fps of the video *\/\n+    SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA = (1 << 1),  \/**< Each color has been scaled by the alpha value. *\/\n+    SPA_VIDEO_FLAG_MODIFIER = (1 << 2),        \/**< use the format modifier *\/\n+};\n+\n+\/**\n+ * The possible values of the #spa_video_interlace_mode describing the interlace\n+ * mode of the stream.\n+ *\/\n+enum spa_video_interlace_mode {\n+    SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE = 0,    \/**< all frames are progressive *\/\n+    SPA_VIDEO_INTERLACE_MODE_INTERLEAVED,        \/**< 2 fields are interleaved in one video frame.\n+                             * Extra buffer flags describe the field order. *\/\n+    SPA_VIDEO_INTERLACE_MODE_MIXED,            \/**< frames contains both interlaced and progressive\n+                             *   video, the buffer flags describe the frame and\n+                             *   fields. *\/\n+    SPA_VIDEO_INTERLACE_MODE_FIELDS,        \/**< 2 fields are stored in one buffer, use the\n+                             *   frame ID to get access to the required\n+                             *   field. For multiview (the 'views'\n+                             *   property > 1) the fields of view N can\n+                             *   be found at frame ID (N * 2) and (N *\n+                             *   2) + 1. Each field has only half the\n+                             *   amount of lines as noted in the height\n+                             *   property. This mode requires multiple\n+                             *   spa_data to describe the fields. *\/\n+};\n+\n+\/**\n+ *\/\n+struct spa_video_info_raw {\n+    enum spa_video_format format;                \/**< the format *\/\n+    uint32_t flags;                        \/**< extra video flags *\/\n+    uint64_t modifier;                    \/**< format modifier\n+                                  * only used with DMA-BUF *\/\n+    struct spa_rectangle size;                \/**< the frame size of the video *\/\n+    struct spa_fraction framerate;                \/**< the framerate of the video, 0\/1 means variable rate *\/\n+    struct spa_fraction max_framerate;            \/**< the maximum framerate of the video. This is only valid when\n+                                     \\ref framerate is 0\/1 *\/\n+    uint32_t views;                        \/**< the number of views in this video *\/\n+    enum spa_video_interlace_mode interlace_mode;        \/**< the interlace mode *\/\n+    struct spa_fraction pixel_aspect_ratio;            \/**< the pixel aspect ratio *\/\n+    enum spa_video_multiview_mode multiview_mode;        \/**< multiview mode *\/\n+    enum spa_video_multiview_flags multiview_flags;        \/**< multiview flags *\/\n+    enum spa_video_chroma_site chroma_site;            \/**< the chroma siting *\/\n+    enum spa_video_color_range color_range;            \/**< the color range. This is the valid range for the samples.\n+                                 *   It is used to convert the samples to Y'PbPr values. *\/\n+    enum spa_video_color_matrix color_matrix;        \/**< the color matrix. Used to convert between Y'PbPr and\n+                                 *   non-linear RGB (R'G'B') *\/\n+    enum spa_video_transfer_function transfer_function;    \/**< the transfer function. used to convert between R'G'B' and RGB *\/\n+    enum spa_video_color_primaries color_primaries;        \/**< color primaries. used to convert between R'G'B' and CIE XYZ *\/\n+};\n+\n+#define SPA_VIDEO_INFO_RAW_INIT(...)    ((struct spa_video_info_raw) { __VA_ARGS__ })\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_VIDEO_RAW_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/raw.h","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_VIDEO_TYPES_H\n+#define SPA_VIDEO_TYPES_H\n+\n+#include <spa\/param\/video\/raw-types.h>\n+\n+#endif \/* SPA_VIDEO_TYPES_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/param\/video\/type-info.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,681 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_BUILDER_H\n+#define SPA_POD_BUILDER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/** \\defgroup spa_pod POD\n+ * Binary data serialization format\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#include <stdarg.h>\n+\n+#include <spa\/utils\/hook.h>\n+#include <spa\/pod\/iter.h>\n+#include <spa\/pod\/vararg.h>\n+\n+struct spa_pod_builder_state {\n+    uint32_t offset;\n+#define SPA_POD_BUILDER_FLAG_BODY    (1<<0)\n+#define SPA_POD_BUILDER_FLAG_FIRST    (1<<1)\n+    uint32_t flags;\n+    struct spa_pod_frame *frame;\n+};\n+\n+struct spa_pod_builder;\n+\n+struct spa_pod_builder_callbacks {\n+#define SPA_VERSION_POD_BUILDER_CALLBACKS 0\n+    uint32_t version;\n+\n+    int (*overflow) (void *data, uint32_t size);\n+};\n+\n+struct spa_pod_builder {\n+    void *data;\n+    uint32_t size;\n+    uint32_t _padding;\n+    struct spa_pod_builder_state state;\n+    struct spa_callbacks callbacks;\n+};\n+\n+#define SPA_POD_BUILDER_INIT(buffer,size)  ((struct spa_pod_builder){ (buffer), (size), 0, {}, {} })\n+\n+static inline void\n+spa_pod_builder_get_state(struct spa_pod_builder *builder, struct spa_pod_builder_state *state)\n+{\n+    *state = builder->state;\n+}\n+\n+static inline void\n+spa_pod_builder_set_callbacks(struct spa_pod_builder *builder,\n+        const struct spa_pod_builder_callbacks *callbacks, void *data)\n+{\n+    builder->callbacks = SPA_CALLBACKS_INIT(callbacks, data);\n+}\n+\n+static inline void\n+spa_pod_builder_reset(struct spa_pod_builder *builder, struct spa_pod_builder_state *state)\n+{\n+    struct spa_pod_frame *f;\n+    uint32_t size = builder->state.offset - state->offset;\n+    builder->state = *state;\n+    for (f = builder->state.frame; f ; f = f->parent)\n+        f->pod.size -= size;\n+}\n+\n+static inline void spa_pod_builder_init(struct spa_pod_builder *builder, void *data, uint32_t size)\n+{\n+    *builder = SPA_POD_BUILDER_INIT(data, size);\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_builder_deref(struct spa_pod_builder *builder, uint32_t offset)\n+{\n+    uint32_t size = builder->size;\n+    if (offset + 8 <= size) {\n+        struct spa_pod *pod = SPA_PTROFF(builder->data, offset, struct spa_pod);\n+        if (offset + SPA_POD_SIZE(pod) <= size)\n+            return pod;\n+    }\n+    return NULL;\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_builder_frame(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    if (frame->offset + SPA_POD_SIZE(&frame->pod) <= builder->size)\n+        return SPA_PTROFF(builder->data, frame->offset, struct spa_pod);\n+    return NULL;\n+}\n+\n+static inline void\n+spa_pod_builder_push(struct spa_pod_builder *builder,\n+             struct spa_pod_frame *frame,\n+             const struct spa_pod *pod,\n+             uint32_t offset)\n+{\n+    frame->pod = *pod;\n+    frame->offset = offset;\n+    frame->parent = builder->state.frame;\n+    frame->flags = builder->state.flags;\n+    builder->state.frame = frame;\n+\n+    if (frame->pod.type == SPA_TYPE_Array || frame->pod.type == SPA_TYPE_Choice)\n+        builder->state.flags = SPA_POD_BUILDER_FLAG_FIRST | SPA_POD_BUILDER_FLAG_BODY;\n+}\n+\n+static inline int spa_pod_builder_raw(struct spa_pod_builder *builder, const void *data, uint32_t size)\n+{\n+    int res = 0;\n+    struct spa_pod_frame *f;\n+    uint32_t offset = builder->state.offset;\n+\n+    if (offset + size > builder->size) {\n+        res = -ENOSPC;\n+        if (offset <= builder->size)\n+            spa_callbacks_call_res(&builder->callbacks,\n+                    struct spa_pod_builder_callbacks, res,\n+                    overflow, 0, offset + size);\n+    }\n+    if (res == 0 && data)\n+        memcpy(SPA_PTROFF(builder->data, offset, void), data, size);\n+\n+    builder->state.offset += size;\n+\n+    for (f = builder->state.frame; f ; f = f->parent)\n+        f->pod.size += size;\n+\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_pad(struct spa_pod_builder *builder, uint32_t size)\n+{\n+    uint64_t zeroes = 0;\n+    size = SPA_ROUND_UP_N(size, 8) - size;\n+    return size ? spa_pod_builder_raw(builder, &zeroes, size) : 0;\n+}\n+\n+static inline int\n+spa_pod_builder_raw_padded(struct spa_pod_builder *builder, const void *data, uint32_t size)\n+{\n+    int r, res = spa_pod_builder_raw(builder, data, size);\n+    if ((r = spa_pod_builder_pad(builder, size)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline void *spa_pod_builder_pop(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    struct spa_pod *pod;\n+\n+    if (SPA_FLAG_IS_SET(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST)) {\n+        const struct spa_pod p = { 0, SPA_TYPE_None };\n+        spa_pod_builder_raw(builder, &p, sizeof(p));\n+    }\n+    if ((pod = (struct spa_pod*)spa_pod_builder_frame(builder, frame)) != NULL)\n+        *pod = frame->pod;\n+\n+    builder->state.frame = frame->parent;\n+    builder->state.flags = frame->flags;\n+    spa_pod_builder_pad(builder, builder->state.offset);\n+    return pod;\n+}\n+\n+static inline int\n+spa_pod_builder_primitive(struct spa_pod_builder *builder, const struct spa_pod *p)\n+{\n+    const void *data;\n+    uint32_t size;\n+    int r, res;\n+\n+    if (builder->state.flags == SPA_POD_BUILDER_FLAG_BODY) {\n+        data = SPA_POD_BODY_CONST(p);\n+        size = SPA_POD_BODY_SIZE(p);\n+    } else {\n+        data = p;\n+        size = SPA_POD_SIZE(p);\n+        SPA_FLAG_CLEAR(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST);\n+    }\n+    res = spa_pod_builder_raw(builder, data, size);\n+    if (builder->state.flags != SPA_POD_BUILDER_FLAG_BODY)\n+        if ((r = spa_pod_builder_pad(builder, size)) < 0)\n+            res = r;\n+    return res;\n+}\n+\n+#define SPA_POD_INIT(size,type) ((struct spa_pod) { (size), (type) })\n+\n+#define SPA_POD_INIT_None() SPA_POD_INIT(0, SPA_TYPE_None)\n+\n+static inline int spa_pod_builder_none(struct spa_pod_builder *builder)\n+{\n+    const struct spa_pod p = SPA_POD_INIT_None();\n+    return spa_pod_builder_primitive(builder, &p);\n+}\n+\n+static inline int spa_pod_builder_child(struct spa_pod_builder *builder, uint32_t size, uint32_t type)\n+{\n+    const struct spa_pod p = SPA_POD_INIT(size,type);\n+    SPA_FLAG_CLEAR(builder->state.flags, SPA_POD_BUILDER_FLAG_FIRST);\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+#define SPA_POD_INIT_Bool(val) ((struct spa_pod_bool){ { sizeof(uint32_t), SPA_TYPE_Bool }, (val) ? 1 : 0, 0 })\n+\n+static inline int spa_pod_builder_bool(struct spa_pod_builder *builder, bool val)\n+{\n+    const struct spa_pod_bool p = SPA_POD_INIT_Bool(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Id(val) ((struct spa_pod_id){ { sizeof(uint32_t), SPA_TYPE_Id }, (val), 0 })\n+\n+static inline int spa_pod_builder_id(struct spa_pod_builder *builder, uint32_t val)\n+{\n+    const struct spa_pod_id p = SPA_POD_INIT_Id(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Int(val) ((struct spa_pod_int){ { sizeof(int32_t), SPA_TYPE_Int }, (val), 0 })\n+\n+static inline int spa_pod_builder_int(struct spa_pod_builder *builder, int32_t val)\n+{\n+    const struct spa_pod_int p = SPA_POD_INIT_Int(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Long(val) ((struct spa_pod_long){ { sizeof(int64_t), SPA_TYPE_Long }, (val) })\n+\n+static inline int spa_pod_builder_long(struct spa_pod_builder *builder, int64_t val)\n+{\n+    const struct spa_pod_long p = SPA_POD_INIT_Long(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Float(val) ((struct spa_pod_float){ { sizeof(float), SPA_TYPE_Float }, (val), 0 })\n+\n+static inline int spa_pod_builder_float(struct spa_pod_builder *builder, float val)\n+{\n+    const struct spa_pod_float p = SPA_POD_INIT_Float(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Double(val) ((struct spa_pod_double){ { sizeof(double), SPA_TYPE_Double }, (val) })\n+\n+static inline int spa_pod_builder_double(struct spa_pod_builder *builder, double val)\n+{\n+    const struct spa_pod_double p = SPA_POD_INIT_Double(val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_String(len) ((struct spa_pod_string){ { (len), SPA_TYPE_String } })\n+\n+static inline int\n+spa_pod_builder_write_string(struct spa_pod_builder *builder, const char *str, uint32_t len)\n+{\n+    int r, res;\n+    res = spa_pod_builder_raw(builder, str, len);\n+    if ((r = spa_pod_builder_raw(builder, \"\", 1)) < 0)\n+        res = r;\n+    if ((r = spa_pod_builder_pad(builder, builder->state.offset)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline int\n+spa_pod_builder_string_len(struct spa_pod_builder *builder, const char *str, uint32_t len)\n+{\n+    const struct spa_pod_string p = SPA_POD_INIT_String(len+1);\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_write_string(builder, str, len)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_string(struct spa_pod_builder *builder, const char *str)\n+{\n+    uint32_t len = str ? strlen(str) : 0;\n+    return spa_pod_builder_string_len(builder, str ? str : \"\", len);\n+}\n+\n+#define SPA_POD_INIT_Bytes(len) ((struct spa_pod_bytes){ { (len), SPA_TYPE_Bytes } })\n+\n+static inline int\n+spa_pod_builder_bytes(struct spa_pod_builder *builder, const void *bytes, uint32_t len)\n+{\n+    const struct spa_pod_bytes p = SPA_POD_INIT_Bytes(len);\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_raw_padded(builder, bytes, len)) < 0)\n+        res = r;\n+    return res;\n+}\n+static inline void *\n+spa_pod_builder_reserve_bytes(struct spa_pod_builder *builder, uint32_t len)\n+{\n+    uint32_t offset = builder->state.offset;\n+    if (spa_pod_builder_bytes(builder, NULL, len) < 0)\n+        return NULL;\n+    return SPA_POD_BODY(spa_pod_builder_deref(builder, offset));\n+}\n+\n+#define SPA_POD_INIT_Pointer(type,value) ((struct spa_pod_pointer){ { sizeof(struct spa_pod_pointer_body), SPA_TYPE_Pointer }, { (type), 0, (value) } })\n+\n+static inline int\n+spa_pod_builder_pointer(struct spa_pod_builder *builder, uint32_t type, const void *val)\n+{\n+    const struct spa_pod_pointer p = SPA_POD_INIT_Pointer(type, val);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Fd(fd) ((struct spa_pod_fd){ { sizeof(int64_t), SPA_TYPE_Fd }, (fd) })\n+\n+static inline int spa_pod_builder_fd(struct spa_pod_builder *builder, int64_t fd)\n+{\n+    const struct spa_pod_fd p = SPA_POD_INIT_Fd(fd);\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Rectangle(val) ((struct spa_pod_rectangle){ { sizeof(struct spa_rectangle), SPA_TYPE_Rectangle }, (val) })\n+\n+static inline int\n+spa_pod_builder_rectangle(struct spa_pod_builder *builder, uint32_t width, uint32_t height)\n+{\n+    const struct spa_pod_rectangle p = SPA_POD_INIT_Rectangle(SPA_RECTANGLE(width, height));\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+#define SPA_POD_INIT_Fraction(val) ((struct spa_pod_fraction){ { sizeof(struct spa_fraction), SPA_TYPE_Fraction }, (val) })\n+\n+static inline int\n+spa_pod_builder_fraction(struct spa_pod_builder *builder, uint32_t num, uint32_t denom)\n+{\n+    const struct spa_pod_fraction p = SPA_POD_INIT_Fraction(SPA_FRACTION(num, denom));\n+    return spa_pod_builder_primitive(builder, &p.pod);\n+}\n+\n+static inline int\n+spa_pod_builder_push_array(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod_array p =\n+        { {sizeof(struct spa_pod_array_body) - sizeof(struct spa_pod), SPA_TYPE_Array},\n+        {{0, 0}} };\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p) - sizeof(struct spa_pod));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+static inline int\n+spa_pod_builder_array(struct spa_pod_builder *builder,\n+              uint32_t child_size, uint32_t child_type, uint32_t n_elems, const void *elems)\n+{\n+    const struct spa_pod_array p = {\n+        {(uint32_t)(sizeof(struct spa_pod_array_body) + n_elems * child_size), SPA_TYPE_Array},\n+        {{child_size, child_type}}\n+    };\n+    int r, res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    if ((r = spa_pod_builder_raw_padded(builder, elems, child_size * n_elems)) < 0)\n+        res = r;\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_CHOICE_BODY(type, flags, child_size, child_type)                \\\n+    ((struct spa_pod_choice_body) { (type), (flags), { (child_size), (child_type) }})\n+\n+#define SPA_POD_INIT_Choice(type, ctype, child_type, n_vals, ...)                \\\n+    ((struct { struct spa_pod_choice choice; ctype vals[(n_vals)];})            \\\n+    { { { (n_vals) * sizeof(ctype) + sizeof(struct spa_pod_choice_body), SPA_TYPE_Choice },    \\\n+        { (type), 0, { sizeof(ctype), (child_type) } } }, { __VA_ARGS__ } })\n+\n+static inline int\n+spa_pod_builder_push_choice(struct spa_pod_builder *builder, struct spa_pod_frame *frame,\n+        uint32_t type, uint32_t flags)\n+{\n+    const struct spa_pod_choice p =\n+        { {sizeof(struct spa_pod_choice_body) - sizeof(struct spa_pod), SPA_TYPE_Choice},\n+        { type, flags, {0, 0}} };\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p) - sizeof(struct spa_pod));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Struct(size) ((struct spa_pod_struct){ { (size), SPA_TYPE_Struct } })\n+\n+static inline int\n+spa_pod_builder_push_struct(struct spa_pod_builder *builder, struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod_struct p = SPA_POD_INIT_Struct(0);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Object(size,type,id,...)    ((struct spa_pod_object){ { (size), SPA_TYPE_Object }, { (type), (id) }, ##__VA_ARGS__ })\n+\n+static inline int\n+spa_pod_builder_push_object(struct spa_pod_builder *builder, struct spa_pod_frame *frame,\n+        uint32_t type, uint32_t id)\n+{\n+    const struct spa_pod_object p =\n+        SPA_POD_INIT_Object(sizeof(struct spa_pod_object_body), type, id);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+#define SPA_POD_INIT_Prop(key,flags,size,type)    \\\n+    ((struct spa_pod_prop){ (key), (flags), { (size), (type) } })\n+\n+static inline int\n+spa_pod_builder_prop(struct spa_pod_builder *builder, uint32_t key, uint32_t flags)\n+{\n+    const struct { uint32_t key; uint32_t flags; } p = { key, flags };\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+#define SPA_POD_INIT_Sequence(size,unit)    \\\n+    ((struct spa_pod_sequence){ { (size), SPA_TYPE_Sequence}, {(unit), 0 } })\n+\n+static inline int\n+spa_pod_builder_push_sequence(struct spa_pod_builder *builder, struct spa_pod_frame *frame, uint32_t unit)\n+{\n+    const struct spa_pod_sequence p =\n+        SPA_POD_INIT_Sequence(sizeof(struct spa_pod_sequence_body), unit);\n+    uint32_t offset = builder->state.offset;\n+    int res = spa_pod_builder_raw(builder, &p, sizeof(p));\n+    spa_pod_builder_push(builder, frame, &p.pod, offset);\n+    return res;\n+}\n+\n+static inline uint32_t\n+spa_pod_builder_control(struct spa_pod_builder *builder, uint32_t offset, uint32_t type)\n+{\n+    const struct { uint32_t offset; uint32_t type; } p = { offset, type };\n+    return spa_pod_builder_raw(builder, &p, sizeof(p));\n+}\n+\n+static inline uint32_t spa_choice_from_id(char id)\n+{\n+    switch (id) {\n+    case 'r':\n+        return SPA_CHOICE_Range;\n+    case 's':\n+        return SPA_CHOICE_Step;\n+    case 'e':\n+        return SPA_CHOICE_Enum;\n+    case 'f':\n+        return SPA_CHOICE_Flags;\n+    case 'n':\n+    default:\n+        return SPA_CHOICE_None;\n+    }\n+}\n+\n+#define SPA_POD_BUILDER_COLLECT(builder,type,args)                \\\n+do {                                        \\\n+    switch (type) {                                \\\n+    case 'b':                                \\\n+        spa_pod_builder_bool(builder, !!va_arg(args, int));        \\\n+        break;                                \\\n+    case 'I':                                \\\n+        spa_pod_builder_id(builder, va_arg(args, uint32_t));        \\\n+        break;                                \\\n+    case 'i':                                \\\n+        spa_pod_builder_int(builder, va_arg(args, int));        \\\n+        break;                                \\\n+    case 'l':                                \\\n+        spa_pod_builder_long(builder, va_arg(args, int64_t));        \\\n+        break;                                \\\n+    case 'f':                                \\\n+        spa_pod_builder_float(builder, va_arg(args, double));        \\\n+        break;                                \\\n+    case 'd':                                \\\n+        spa_pod_builder_double(builder, va_arg(args, double));        \\\n+        break;                                \\\n+    case 's':                                \\\n+    {                                    \\\n+        char *strval = va_arg(args, char *);                \\\n+        if (strval != NULL) {                        \\\n+            size_t len = strlen(strval);                \\\n+            spa_pod_builder_string_len(builder, strval, len);    \\\n+        }                                \\\n+        else                                \\\n+            spa_pod_builder_none(builder);                \\\n+        break;                                \\\n+    }                                    \\\n+    case 'S':                                \\\n+    {                                    \\\n+        char *strval = va_arg(args, char *);                \\\n+        size_t len = va_arg(args, int);                    \\\n+        spa_pod_builder_string_len(builder, strval, len);        \\\n+        break;                                \\\n+    }                                    \\\n+    case 'y':                                \\\n+    {                                    \\\n+        void *ptr  = va_arg(args, void *);                \\\n+        int len = va_arg(args, int);                    \\\n+        spa_pod_builder_bytes(builder, ptr, len);            \\\n+        break;                                \\\n+    }                                    \\\n+    case 'R':                                \\\n+    {                                    \\\n+        struct spa_rectangle *rectval =                    \\\n+            va_arg(args, struct spa_rectangle *);            \\\n+        spa_pod_builder_rectangle(builder,                \\\n+                rectval->width, rectval->height);        \\\n+        break;                                \\\n+    }                                    \\\n+    case 'F':                                \\\n+    {                                    \\\n+        struct spa_fraction *fracval =                    \\\n+            va_arg(args, struct spa_fraction *);            \\\n+        spa_pod_builder_fraction(builder, fracval->num, fracval->denom);\\\n+        break;                                \\\n+    }                                    \\\n+    case 'a':                                \\\n+    {                                    \\\n+        int child_size = va_arg(args, int);                \\\n+        int child_type = va_arg(args, int);                \\\n+        int n_elems = va_arg(args, int);                \\\n+        void *elems = va_arg(args, void *);                \\\n+        spa_pod_builder_array(builder, child_size,            \\\n+                child_type, n_elems, elems);            \\\n+        break;                                \\\n+    }                                    \\\n+    case 'p':                                \\\n+    {                                    \\\n+        int t = va_arg(args, uint32_t);                    \\\n+        spa_pod_builder_pointer(builder, t, va_arg(args, void *));    \\\n+        break;                                \\\n+    }                                    \\\n+    case 'h':                                \\\n+        spa_pod_builder_fd(builder, va_arg(args, int));            \\\n+        break;                                \\\n+    case 'P':                                \\\n+    case 'O':                                \\\n+    case 'T':                                \\\n+    case 'V':                                \\\n+    {                                    \\\n+        struct spa_pod *pod = va_arg(args, struct spa_pod *);        \\\n+        if (pod == NULL)                        \\\n+            spa_pod_builder_none(builder);                \\\n+        else                                \\\n+            spa_pod_builder_primitive(builder, pod);        \\\n+        break;                                \\\n+    }                                    \\\n+    }                                    \\\n+} while(false)\n+\n+static inline int\n+spa_pod_builder_addv(struct spa_pod_builder *builder, va_list args)\n+{\n+    int res = 0;\n+    struct spa_pod_frame *frame = builder->state.frame;\n+    uint32_t ftype = frame ? frame->pod.type : (uint32_t)SPA_TYPE_None;\n+\n+    do {\n+        const char *format;\n+        int n_values = 1;\n+        struct spa_pod_frame f;\n+        bool choice;\n+\n+        switch (ftype) {\n+        case SPA_TYPE_Object:\n+        {\n+            uint32_t key = va_arg(args, uint32_t);\n+            if (key == 0)\n+                goto exit;\n+            spa_pod_builder_prop(builder, key, 0);\n+            break;\n+        }\n+        case SPA_TYPE_Sequence:\n+        {\n+            uint32_t offset = va_arg(args, uint32_t);\n+            uint32_t type = va_arg(args, uint32_t);\n+            if (type == 0)\n+                goto exit;\n+            spa_pod_builder_control(builder, offset, type);\n+            SPA_FALLTHROUGH\n+        }\n+        default:\n+            break;\n+        }\n+        if ((format = va_arg(args, const char *)) == NULL)\n+            break;\n+\n+        choice = *format == '?';\n+        if (choice) {\n+            uint32_t type = spa_choice_from_id(*++format);\n+            if (*format != '\\0')\n+                format++;\n+\n+            spa_pod_builder_push_choice(builder, &f, type, 0);\n+\n+            n_values = va_arg(args, int);\n+        }\n+        while (n_values-- > 0)\n+            SPA_POD_BUILDER_COLLECT(builder, *format, args);\n+\n+        if (choice)\n+            spa_pod_builder_pop(builder, &f);\n+    } while (true);\n+\n+      exit:\n+    return res;\n+}\n+\n+static inline int spa_pod_builder_add(struct spa_pod_builder *builder, ...)\n+{\n+    int res;\n+    va_list args;\n+\n+    va_start(args, builder);\n+    res = spa_pod_builder_addv(builder, args);\n+    va_end(args);\n+\n+    return res;\n+}\n+\n+#define spa_pod_builder_add_object(b,type,id,...)                \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_object(_b, &_f, type, id);                \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, 0);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+#define spa_pod_builder_add_struct(b,...)                    \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_struct(_b, &_f);                    \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, NULL);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+#define spa_pod_builder_add_sequence(b,unit,...)                \\\n+({                                        \\\n+    struct spa_pod_builder *_b = (b);                    \\\n+    struct spa_pod_frame _f;                        \\\n+    spa_pod_builder_push_sequence(_b, &_f, unit);                \\\n+    spa_pod_builder_add(_b, ##__VA_ARGS__, 0, 0);                \\\n+    spa_pod_builder_pop(_b, &_f);                        \\\n+})\n+\n+\/** Copy a pod structure *\/\n+static inline struct spa_pod *\n+spa_pod_copy(const struct spa_pod *pod)\n+{\n+    size_t size;\n+    struct spa_pod *c;\n+\n+    size = SPA_POD_SIZE(pod);\n+    if ((c = (struct spa_pod *) malloc(size)) == NULL)\n+        return NULL;\n+    return (struct spa_pod *) memcpy(c, pod, size);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_BUILDER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/builder.h","additions":681,"deletions":0,"binary":false,"changes":681,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_COMMAND_H\n+#define SPA_COMMAND_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_command_body {\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_command {\n+    struct spa_pod        pod;\n+    struct spa_command_body body;\n+};\n+\n+#define SPA_COMMAND_TYPE(cmd)        ((cmd)->body.body.type)\n+#define SPA_COMMAND_ID(cmd,type)    (SPA_COMMAND_TYPE(cmd) == (type) ? \\\n+                        (cmd)->body.body.id : SPA_ID_INVALID)\n+\n+#define SPA_COMMAND_INIT_FULL(t,size,type,id,...) ((t)            \\\n+    { { (size), SPA_TYPE_Object },                    \\\n+      { { (type), (id) }, ##__VA_ARGS__ } })\n+\n+#define SPA_COMMAND_INIT(type,id)                    \\\n+    SPA_COMMAND_INIT_FULL(struct spa_command,            \\\n+            sizeof(struct spa_command_body), type, id)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_COMMAND_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/command.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_EVENT_H\n+#define SPA_EVENT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_event_body {\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_event {\n+    struct spa_pod pod;\n+    struct spa_event_body body;\n+};\n+\n+#define SPA_EVENT_TYPE(ev)    ((ev)->body.body.type)\n+#define SPA_EVENT_ID(ev,type)    (SPA_EVENT_TYPE(ev) == (type) ? \\\n+                    (ev)->body.body.id : SPA_ID_INVALID)\n+\n+#define SPA_EVENT_INIT_FULL(t,size,type,id,...) ((t)            \\\n+    { { (size), SPA_TYPE_OBJECT },                    \\\n+      { { (type), (id) }, ##__VA_ARGS__ } })            \\\n+\n+#define SPA_EVENT_INIT(type,id)                        \\\n+    SPA_EVENT_INIT_FULL(struct spa_event,                \\\n+            sizeof(struct spa_event_body), type, id)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_EVENT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/event.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,455 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_ITER_H\n+#define SPA_POD_ITER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <errno.h>\n+#include <sys\/types.h>\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_pod_frame {\n+    struct spa_pod pod;\n+    struct spa_pod_frame *parent;\n+    uint32_t offset;\n+    uint32_t flags;\n+};\n+\n+static inline bool spa_pod_is_inside(const void *pod, uint32_t size, const void *iter)\n+{\n+    return SPA_POD_BODY(iter) <= SPA_PTROFF(pod, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_SIZE(iter), void) <= SPA_PTROFF(pod, size, void);\n+}\n+\n+static inline void *spa_pod_next(const void *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_SIZE(iter), 8), void);\n+}\n+\n+static inline struct spa_pod_prop *spa_pod_prop_first(const struct spa_pod_object_body *body)\n+{\n+    return SPA_PTROFF(body, sizeof(struct spa_pod_object_body), struct spa_pod_prop);\n+}\n+\n+static inline bool spa_pod_prop_is_inside(const struct spa_pod_object_body *body,\n+        uint32_t size, const struct spa_pod_prop *iter)\n+{\n+    return SPA_POD_CONTENTS(struct spa_pod_prop, iter) <= SPA_PTROFF(body, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_PROP_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+}\n+\n+static inline struct spa_pod_prop *spa_pod_prop_next(const struct spa_pod_prop *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_PROP_SIZE(iter), 8), struct spa_pod_prop);\n+}\n+\n+static inline struct spa_pod_control *spa_pod_control_first(const struct spa_pod_sequence_body *body)\n+{\n+    return SPA_PTROFF(body, sizeof(struct spa_pod_sequence_body), struct spa_pod_control);\n+}\n+\n+static inline bool spa_pod_control_is_inside(const struct spa_pod_sequence_body *body,\n+        uint32_t size, const struct spa_pod_control *iter)\n+{\n+    return SPA_POD_CONTENTS(struct spa_pod_control, iter) <= SPA_PTROFF(body, size, void) &&\n+        SPA_PTROFF(iter, SPA_POD_CONTROL_SIZE(iter), void) <= SPA_PTROFF(body, size, void);\n+}\n+\n+static inline struct spa_pod_control *spa_pod_control_next(const struct spa_pod_control *iter)\n+{\n+    return SPA_PTROFF(iter, SPA_ROUND_UP_N(SPA_POD_CONTROL_SIZE(iter), 8), struct spa_pod_control);\n+}\n+\n+#define SPA_POD_ARRAY_BODY_FOREACH(body, _size, iter)                            \\\n+    for ((iter) = (__typeof__(iter))SPA_PTROFF((body), sizeof(struct spa_pod_array_body), void);    \\\n+         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (iter) = (__typeof__(iter))SPA_PTROFF((iter), (body)->child.size, void))\n+\n+#define SPA_POD_ARRAY_FOREACH(obj, iter)                            \\\n+    SPA_POD_ARRAY_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_CHOICE_BODY_FOREACH(body, _size, iter)                            \\\n+    for ((iter) = (__typeof__(iter))SPA_PTROFF((body), sizeof(struct spa_pod_choice_body), void);    \\\n+         (iter) < (__typeof__(iter))SPA_PTROFF((body), (_size), void);                \\\n+         (iter) = (__typeof__(iter))SPA_PTROFF((iter), (body)->child.size, void))\n+\n+#define SPA_POD_CHOICE_FOREACH(obj, iter)                            \\\n+    SPA_POD_CHOICE_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_FOREACH(pod, size, iter)                    \\\n+    for ((iter) = (pod);                            \\\n+         spa_pod_is_inside(pod, size, iter);                \\\n+         (iter) = (__typeof__(iter))spa_pod_next(iter))\n+\n+#define SPA_POD_STRUCT_FOREACH(obj, iter)                            \\\n+    SPA_POD_FOREACH(SPA_POD_BODY(obj), SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_OBJECT_BODY_FOREACH(body, size, iter)                        \\\n+    for ((iter) = spa_pod_prop_first(body);                \\\n+         spa_pod_prop_is_inside(body, size, iter);            \\\n+         (iter) = spa_pod_prop_next(iter))\n+\n+#define SPA_POD_OBJECT_FOREACH(obj, iter)                            \\\n+    SPA_POD_OBJECT_BODY_FOREACH(&(obj)->body, SPA_POD_BODY_SIZE(obj), iter)\n+\n+#define SPA_POD_SEQUENCE_BODY_FOREACH(body, size, iter)                        \\\n+    for ((iter) = spa_pod_control_first(body);                        \\\n+         spa_pod_control_is_inside(body, size, iter);                        \\\n+         (iter) = spa_pod_control_next(iter))\n+\n+#define SPA_POD_SEQUENCE_FOREACH(seq, iter)                            \\\n+    SPA_POD_SEQUENCE_BODY_FOREACH(&(seq)->body, SPA_POD_BODY_SIZE(seq), iter)\n+\n+\n+static inline void *spa_pod_from_data(void *data, size_t maxsize, off_t offset, size_t size)\n+{\n+    void *pod;\n+    if (size < sizeof(struct spa_pod) || offset + size > maxsize)\n+        return NULL;\n+    pod = SPA_PTROFF(data, offset, void);\n+    if (SPA_POD_SIZE(pod) > size)\n+        return NULL;\n+    return pod;\n+}\n+\n+static inline int spa_pod_is_none(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_None);\n+}\n+\n+static inline int spa_pod_is_bool(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Bool && SPA_POD_BODY_SIZE(pod) >= sizeof(int32_t));\n+}\n+\n+static inline int spa_pod_get_bool(const struct spa_pod *pod, bool *value)\n+{\n+    if (!spa_pod_is_bool(pod))\n+        return -EINVAL;\n+    *value = !!SPA_POD_VALUE(struct spa_pod_bool, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_id(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Id && SPA_POD_BODY_SIZE(pod) >= sizeof(uint32_t));\n+}\n+\n+static inline int spa_pod_get_id(const struct spa_pod *pod, uint32_t *value)\n+{\n+    if (!spa_pod_is_id(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_id, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_int(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Int && SPA_POD_BODY_SIZE(pod) >= sizeof(int32_t));\n+}\n+\n+static inline int spa_pod_get_int(const struct spa_pod *pod, int32_t *value)\n+{\n+    if (!spa_pod_is_int(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_int, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_long(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Long && SPA_POD_BODY_SIZE(pod) >= sizeof(int64_t));\n+}\n+\n+static inline int spa_pod_get_long(const struct spa_pod *pod, int64_t *value)\n+{\n+    if (!spa_pod_is_long(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_long, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_float(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Float && SPA_POD_BODY_SIZE(pod) >= sizeof(float));\n+}\n+\n+static inline int spa_pod_get_float(const struct spa_pod *pod, float *value)\n+{\n+    if (!spa_pod_is_float(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_float, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_double(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Double && SPA_POD_BODY_SIZE(pod) >= sizeof(double));\n+}\n+\n+static inline int spa_pod_get_double(const struct spa_pod *pod, double *value)\n+{\n+    if (!spa_pod_is_double(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_double, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_string(const struct spa_pod *pod)\n+{\n+    const char *s = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_String &&\n+            SPA_POD_BODY_SIZE(pod) > 0 &&\n+            s[SPA_POD_BODY_SIZE(pod)-1] == '\\0');\n+}\n+\n+static inline int spa_pod_get_string(const struct spa_pod *pod, const char **value)\n+{\n+    if (!spa_pod_is_string(pod))\n+        return -EINVAL;\n+    *value = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_copy_string(const struct spa_pod *pod, size_t maxlen, char *dest)\n+{\n+    const char *s = (const char *)SPA_POD_CONTENTS(struct spa_pod_string, pod);\n+    if (!spa_pod_is_string(pod) || maxlen < 1)\n+        return -EINVAL;\n+    strncpy(dest, s, maxlen-1);\n+    dest[maxlen-1]= '\\0';\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_bytes(const struct spa_pod *pod)\n+{\n+    return SPA_POD_TYPE(pod) == SPA_TYPE_Bytes;\n+}\n+\n+static inline int spa_pod_get_bytes(const struct spa_pod *pod, const void **value, uint32_t *len)\n+{\n+    if (!spa_pod_is_bytes(pod))\n+        return -EINVAL;\n+    *value = (const void *)SPA_POD_CONTENTS(struct spa_pod_bytes, pod);\n+    *len = SPA_POD_BODY_SIZE(pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_pointer(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Pointer &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_pointer_body));\n+}\n+\n+static inline int spa_pod_get_pointer(const struct spa_pod *pod, uint32_t *type, const void **value)\n+{\n+    if (!spa_pod_is_pointer(pod))\n+        return -EINVAL;\n+    *type = ((struct spa_pod_pointer*)pod)->body.type;\n+    *value = ((struct spa_pod_pointer*)pod)->body.value;\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_fd(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Fd &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(int64_t));\n+}\n+\n+static inline int spa_pod_get_fd(const struct spa_pod *pod, int64_t *value)\n+{\n+    if (!spa_pod_is_fd(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_fd, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_rectangle(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Rectangle &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_rectangle));\n+}\n+\n+static inline int spa_pod_get_rectangle(const struct spa_pod *pod, struct spa_rectangle *value)\n+{\n+    if (!spa_pod_is_rectangle(pod))\n+        return -EINVAL;\n+    *value = SPA_POD_VALUE(struct spa_pod_rectangle, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_fraction(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Fraction &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_fraction));\n+}\n+\n+static inline int spa_pod_get_fraction(const struct spa_pod *pod, struct spa_fraction *value)\n+{\n+    spa_return_val_if_fail(spa_pod_is_fraction(pod), -EINVAL);\n+    *value = SPA_POD_VALUE(struct spa_pod_fraction, pod);\n+    return 0;\n+}\n+\n+static inline int spa_pod_is_bitmap(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Bitmap &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(uint8_t));\n+}\n+\n+static inline int spa_pod_is_array(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Array &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_array_body));\n+}\n+\n+static inline void *spa_pod_get_array(const struct spa_pod *pod, uint32_t *n_values)\n+{\n+    spa_return_val_if_fail(spa_pod_is_array(pod), NULL);\n+    *n_values = SPA_POD_ARRAY_N_VALUES(pod);\n+    return SPA_POD_ARRAY_VALUES(pod);\n+}\n+\n+static inline uint32_t spa_pod_copy_array(const struct spa_pod *pod, uint32_t type,\n+        void *values, uint32_t max_values)\n+{\n+    uint32_t n_values;\n+    void *v = spa_pod_get_array(pod, &n_values);\n+    if (v == NULL || max_values == 0 || SPA_POD_ARRAY_VALUE_TYPE(pod) != type)\n+        return 0;\n+    n_values = SPA_MIN(n_values, max_values);\n+    memcpy(values, v, SPA_POD_ARRAY_VALUE_SIZE(pod) * n_values);\n+    return n_values;\n+}\n+\n+static inline int spa_pod_is_choice(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Choice &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_choice_body));\n+}\n+\n+static inline struct spa_pod *spa_pod_get_values(const struct spa_pod *pod, uint32_t *n_vals, uint32_t *choice)\n+{\n+    if (pod->type == SPA_TYPE_Choice) {\n+        *n_vals = SPA_POD_CHOICE_N_VALUES(pod);\n+        if ((*choice = SPA_POD_CHOICE_TYPE(pod)) == SPA_CHOICE_None)\n+            *n_vals = SPA_MIN(1u, SPA_POD_CHOICE_N_VALUES(pod));\n+        return (struct spa_pod*)SPA_POD_CHOICE_CHILD(pod);\n+    } else {\n+        *n_vals = 1;\n+        *choice = SPA_CHOICE_None;\n+        return (struct spa_pod*)pod;\n+    }\n+}\n+\n+static inline int spa_pod_is_struct(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Struct);\n+}\n+\n+static inline int spa_pod_is_object(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Object &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_object_body));\n+}\n+\n+static inline bool spa_pod_is_object_type(const struct spa_pod *pod, uint32_t type)\n+{\n+    return (pod && spa_pod_is_object(pod) && SPA_POD_OBJECT_TYPE(pod) == type);\n+}\n+\n+static inline bool spa_pod_is_object_id(const struct spa_pod *pod, uint32_t id)\n+{\n+    return (pod && spa_pod_is_object(pod) && SPA_POD_OBJECT_ID(pod) == id);\n+}\n+\n+static inline int spa_pod_is_sequence(const struct spa_pod *pod)\n+{\n+    return (SPA_POD_TYPE(pod) == SPA_TYPE_Sequence &&\n+            SPA_POD_BODY_SIZE(pod) >= sizeof(struct spa_pod_sequence_body));\n+}\n+\n+static inline const struct spa_pod_prop *spa_pod_object_find_prop(const struct spa_pod_object *pod,\n+        const struct spa_pod_prop *start, uint32_t key)\n+{\n+    const struct spa_pod_prop *first, *res;\n+\n+    first = spa_pod_prop_first(&pod->body);\n+    start = start ? spa_pod_prop_next(start) : first;\n+\n+    for (res = start; spa_pod_prop_is_inside(&pod->body, pod->pod.size, res);\n+         res = spa_pod_prop_next(res)) {\n+        if (res->key == key)\n+            return res;\n+    }\n+    for (res = first; res != start; res = spa_pod_prop_next(res)) {\n+        if (res->key == key)\n+            return res;\n+    }\n+    return NULL;\n+}\n+\n+static inline const struct spa_pod_prop *spa_pod_find_prop(const struct spa_pod *pod,\n+        const struct spa_pod_prop *start, uint32_t key)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return NULL;\n+    return spa_pod_object_find_prop((const struct spa_pod_object *)pod, start, key);\n+}\n+\n+static inline int spa_pod_object_fixate(struct spa_pod_object *pod)\n+{\n+    struct spa_pod_prop *res;\n+    SPA_POD_OBJECT_FOREACH(pod, res) {\n+        if (res->value.type == SPA_TYPE_Choice &&\n+            !SPA_FLAG_IS_SET(res->flags, SPA_POD_PROP_FLAG_DONT_FIXATE))\n+            ((struct spa_pod_choice*)&res->value)->body.type = SPA_CHOICE_None;\n+    }\n+    return 0;\n+}\n+\n+static inline int spa_pod_fixate(struct spa_pod *pod)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    return spa_pod_object_fixate((struct spa_pod_object *)pod);\n+}\n+\n+static inline int spa_pod_object_is_fixated(const struct spa_pod_object *pod)\n+{\n+    struct spa_pod_prop *res;\n+    SPA_POD_OBJECT_FOREACH(pod, res) {\n+        if (res->value.type == SPA_TYPE_Choice &&\n+           ((struct spa_pod_choice*)&res->value)->body.type != SPA_CHOICE_None)\n+            return 0;\n+    }\n+    return 1;\n+}\n+\n+static inline int spa_pod_is_fixated(const struct spa_pod *pod)\n+{\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    return spa_pod_object_is_fixated((const struct spa_pod_object *)pod);\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/iter.h","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/* Spa *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_PARSER_H\n+#define SPA_POD_PARSER_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <errno.h>\n+#include <stdarg.h>\n+\n+#include <spa\/pod\/iter.h>\n+#include <spa\/pod\/vararg.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+struct spa_pod_parser_state {\n+    uint32_t offset;\n+    uint32_t flags;\n+    struct spa_pod_frame *frame;\n+};\n+\n+struct spa_pod_parser {\n+    const void *data;\n+    uint32_t size;\n+    uint32_t _padding;\n+    struct spa_pod_parser_state state;\n+};\n+\n+#define SPA_POD_PARSER_INIT(buffer,size)  ((struct spa_pod_parser){ (buffer), (size), 0, {} })\n+\n+static inline void spa_pod_parser_init(struct spa_pod_parser *parser,\n+                       const void *data, uint32_t size)\n+{\n+    *parser = SPA_POD_PARSER_INIT(data, size);\n+}\n+\n+static inline void spa_pod_parser_pod(struct spa_pod_parser *parser,\n+                      const struct spa_pod *pod)\n+{\n+    spa_pod_parser_init(parser, pod, SPA_POD_SIZE(pod));\n+}\n+\n+static inline void\n+spa_pod_parser_get_state(struct spa_pod_parser *parser, struct spa_pod_parser_state *state)\n+{\n+    *state = parser->state;\n+}\n+\n+static inline void\n+spa_pod_parser_reset(struct spa_pod_parser *parser, struct spa_pod_parser_state *state)\n+{\n+    parser->state = *state;\n+}\n+\n+static inline struct spa_pod *\n+spa_pod_parser_deref(struct spa_pod_parser *parser, uint32_t offset, uint32_t size)\n+{\n+    \/* Cast to uint64_t to avoid wraparound.  Add 8 for the pod itself. *\/\n+    const uint64_t long_offset = (uint64_t)offset + 8;\n+    if (long_offset <= size && (offset & 7) == 0) {\n+        \/* Use void* because creating a misaligned pointer is undefined. *\/\n+        void *pod = SPA_PTROFF(parser->data, offset, void);\n+        \/*\n+         * Check that the pointer is aligned and that the size (rounded\n+         * to the next multiple of 8) is in bounds.\n+         *\/\n+        if (SPA_IS_ALIGNED(pod, __alignof__(struct spa_pod)) &&\n+            long_offset + SPA_ROUND_UP_N((uint64_t)SPA_POD_BODY_SIZE(pod), 8) <= size)\n+            return (struct spa_pod *)pod;\n+    }\n+    return NULL;\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_frame(struct spa_pod_parser *parser, struct spa_pod_frame *frame)\n+{\n+    return SPA_PTROFF(parser->data, frame->offset, struct spa_pod);\n+}\n+\n+static inline void spa_pod_parser_push(struct spa_pod_parser *parser,\n+              struct spa_pod_frame *frame, const struct spa_pod *pod, uint32_t offset)\n+{\n+    frame->pod = *pod;\n+    frame->offset = offset;\n+    frame->parent = parser->state.frame;\n+    frame->flags = parser->state.flags;\n+    parser->state.frame = frame;\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_current(struct spa_pod_parser *parser)\n+{\n+    struct spa_pod_frame *f = parser->state.frame;\n+    uint32_t size = f ? f->offset + SPA_POD_SIZE(&f->pod) : parser->size;\n+    return spa_pod_parser_deref(parser, parser->state.offset, size);\n+}\n+\n+static inline void spa_pod_parser_advance(struct spa_pod_parser *parser, const struct spa_pod *pod)\n+{\n+    parser->state.offset += SPA_ROUND_UP_N(SPA_POD_SIZE(pod), 8);\n+}\n+\n+static inline struct spa_pod *spa_pod_parser_next(struct spa_pod_parser *parser)\n+{\n+    struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod)\n+        spa_pod_parser_advance(parser, pod);\n+    return pod;\n+}\n+\n+static inline int spa_pod_parser_pop(struct spa_pod_parser *parser,\n+              struct spa_pod_frame *frame)\n+{\n+    parser->state.frame = frame->parent;\n+    parser->state.offset = frame->offset + SPA_ROUND_UP_N(SPA_POD_SIZE(&frame->pod), 8);\n+    return 0;\n+}\n+\n+static inline int spa_pod_parser_get_bool(struct spa_pod_parser *parser, bool *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_bool(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_id(struct spa_pod_parser *parser, uint32_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_id(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_int(struct spa_pod_parser *parser, int32_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_int(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_long(struct spa_pod_parser *parser, int64_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_long(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_float(struct spa_pod_parser *parser, float *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_float(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_double(struct spa_pod_parser *parser, double *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_double(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_string(struct spa_pod_parser *parser, const char **value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_string(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_bytes(struct spa_pod_parser *parser, const void **value, uint32_t *len)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_bytes(pod, value, len)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_pointer(struct spa_pod_parser *parser, uint32_t *type, const void **value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_pointer(pod, type, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_fd(struct spa_pod_parser *parser, int64_t *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_fd(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_rectangle(struct spa_pod_parser *parser, struct spa_rectangle *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_rectangle(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_fraction(struct spa_pod_parser *parser, struct spa_fraction *value)\n+{\n+    int res = -EPIPE;\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod != NULL && (res = spa_pod_get_fraction(pod, value)) >= 0)\n+        spa_pod_parser_advance(parser, pod);\n+    return res;\n+}\n+\n+static inline int spa_pod_parser_get_pod(struct spa_pod_parser *parser, struct spa_pod **value)\n+{\n+    struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    *value = pod;\n+    spa_pod_parser_advance(parser, pod);\n+    return 0;\n+}\n+static inline int spa_pod_parser_push_struct(struct spa_pod_parser *parser,\n+        struct spa_pod_frame *frame)\n+{\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    if (!spa_pod_is_struct(pod))\n+        return -EINVAL;\n+    spa_pod_parser_push(parser, frame, pod, parser->state.offset);\n+    parser->state.offset += sizeof(struct spa_pod_struct);\n+    return 0;\n+}\n+\n+static inline int spa_pod_parser_push_object(struct spa_pod_parser *parser,\n+        struct spa_pod_frame *frame, uint32_t type, uint32_t *id)\n+{\n+    const struct spa_pod *pod = spa_pod_parser_current(parser);\n+    if (pod == NULL)\n+        return -EPIPE;\n+    if (!spa_pod_is_object(pod))\n+        return -EINVAL;\n+    if (type != SPA_POD_OBJECT_TYPE(pod))\n+        return -EPROTO;\n+    if (id != NULL)\n+        *id = SPA_POD_OBJECT_ID(pod);\n+    spa_pod_parser_push(parser, frame, pod, parser->state.offset);\n+    parser->state.offset = parser->size;\n+    return 0;\n+}\n+\n+static inline bool spa_pod_parser_can_collect(const struct spa_pod *pod, char type)\n+{\n+    if (pod == NULL)\n+        return false;\n+\n+    if (SPA_POD_TYPE(pod) == SPA_TYPE_Choice) {\n+        if (!spa_pod_is_choice(pod))\n+            return false;\n+        if (type == 'V')\n+            return true;\n+        if (SPA_POD_CHOICE_TYPE(pod) != SPA_CHOICE_None)\n+            return false;\n+        pod = SPA_POD_CHOICE_CHILD(pod);\n+    }\n+\n+    switch (type) {\n+    case 'P':\n+        return true;\n+    case 'b':\n+        return spa_pod_is_bool(pod);\n+    case 'I':\n+        return spa_pod_is_id(pod);\n+    case 'i':\n+        return spa_pod_is_int(pod);\n+    case 'l':\n+        return spa_pod_is_long(pod);\n+    case 'f':\n+        return spa_pod_is_float(pod);\n+    case 'd':\n+        return spa_pod_is_double(pod);\n+    case 's':\n+        return spa_pod_is_string(pod) || spa_pod_is_none(pod);\n+    case 'S':\n+        return spa_pod_is_string(pod);\n+    case 'y':\n+        return spa_pod_is_bytes(pod);\n+    case 'R':\n+        return spa_pod_is_rectangle(pod);\n+    case 'F':\n+        return spa_pod_is_fraction(pod);\n+    case 'B':\n+        return spa_pod_is_bitmap(pod);\n+    case 'a':\n+        return spa_pod_is_array(pod);\n+    case 'p':\n+        return spa_pod_is_pointer(pod);\n+    case 'h':\n+        return spa_pod_is_fd(pod);\n+    case 'T':\n+        return spa_pod_is_struct(pod) || spa_pod_is_none(pod);\n+    case 'O':\n+        return spa_pod_is_object(pod) || spa_pod_is_none(pod);\n+    case 'V':\n+    default:\n+        return false;\n+    }\n+}\n+\n+#define SPA_POD_PARSER_COLLECT(pod,_type,args)                        \\\n+do {                                            \\\n+    switch (_type) {                                \\\n+    case 'b':                                    \\\n+        *va_arg(args, bool*) = SPA_POD_VALUE(struct spa_pod_bool, pod);        \\\n+        break;                                    \\\n+    case 'I':                                    \\\n+    case 'i':                                    \\\n+        *va_arg(args, int32_t*) = SPA_POD_VALUE(struct spa_pod_int, pod);    \\\n+        break;                                    \\\n+    case 'l':                                    \\\n+        *va_arg(args, int64_t*) = SPA_POD_VALUE(struct spa_pod_long, pod);    \\\n+        break;                                    \\\n+    case 'f':                                    \\\n+        *va_arg(args, float*) = SPA_POD_VALUE(struct spa_pod_float, pod);    \\\n+        break;                                    \\\n+    case 'd':                                    \\\n+        *va_arg(args, double*) = SPA_POD_VALUE(struct spa_pod_double, pod);    \\\n+        break;                                    \\\n+    case 's':                                    \\\n+        *va_arg(args, char**) =                            \\\n+            ((pod) == NULL || (SPA_POD_TYPE(pod) == SPA_TYPE_None)        \\\n+                ? NULL                            \\\n+                : (char *)SPA_POD_CONTENTS(struct spa_pod_string, pod));    \\\n+        break;                                    \\\n+    case 'S':                                    \\\n+    {                                        \\\n+        char *dest = va_arg(args, char*);                    \\\n+        uint32_t maxlen = va_arg(args, uint32_t);                \\\n+        strncpy(dest, (char *)SPA_POD_CONTENTS(struct spa_pod_string, pod), maxlen-1);    \\\n+        dest[maxlen-1] = '\\0';                            \\\n+        break;                                    \\\n+    }                                        \\\n+    case 'y':                                    \\\n+        *(va_arg(args, void **)) = SPA_POD_CONTENTS(struct spa_pod_bytes, pod);    \\\n+        *(va_arg(args, uint32_t *)) = SPA_POD_BODY_SIZE(pod);            \\\n+        break;                                    \\\n+    case 'R':                                    \\\n+        *va_arg(args, struct spa_rectangle*) =                    \\\n+                SPA_POD_VALUE(struct spa_pod_rectangle, pod);        \\\n+        break;                                    \\\n+    case 'F':                                    \\\n+        *va_arg(args, struct spa_fraction*) =                    \\\n+                SPA_POD_VALUE(struct spa_pod_fraction, pod);        \\\n+        break;                                    \\\n+    case 'B':                                    \\\n+        *va_arg(args, uint32_t **) =                        \\\n+            (uint32_t *) SPA_POD_CONTENTS(struct spa_pod_bitmap, pod);    \\\n+        break;                                    \\\n+    case 'a':                                    \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_VALUE_SIZE(pod);        \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_VALUE_TYPE(pod);        \\\n+        *va_arg(args, uint32_t*) = SPA_POD_ARRAY_N_VALUES(pod);            \\\n+        *va_arg(args, void**) = SPA_POD_ARRAY_VALUES(pod);            \\\n+        break;                                    \\\n+    case 'p':                                    \\\n+    {                                        \\\n+        struct spa_pod_pointer_body *b =                    \\\n+                (struct spa_pod_pointer_body *) SPA_POD_BODY(pod);    \\\n+        *(va_arg(args, uint32_t *)) = b->type;                    \\\n+        *(va_arg(args, const void **)) = b->value;                \\\n+        break;                                    \\\n+    }                                        \\\n+    case 'h':                                    \\\n+        *va_arg(args, int64_t*) = SPA_POD_VALUE(struct spa_pod_fd, pod);    \\\n+        break;                                    \\\n+    case 'P':                                    \\\n+    case 'T':                                    \\\n+    case 'O':                                    \\\n+    case 'V':                                    \\\n+    {                                        \\\n+        const struct spa_pod **d = va_arg(args, const struct spa_pod**);    \\\n+        if (d)                                    \\\n+            *d = ((pod) == NULL || (SPA_POD_TYPE(pod) == SPA_TYPE_None)    \\\n+                ? NULL : (pod));                        \\\n+        break;                                    \\\n+    }                                        \\\n+    default:                                    \\\n+        break;                                    \\\n+    }                                        \\\n+} while(false)\n+\n+#define SPA_POD_PARSER_SKIP(_type,args)                            \\\n+do {                                            \\\n+    switch (_type) {                                \\\n+    case 'S':                                    \\\n+        va_arg(args, char*);                            \\\n+        va_arg(args, uint32_t);                            \\\n+        break;                                    \\\n+    case 'a':                                    \\\n+        va_arg(args, void*);                            \\\n+        va_arg(args, void*);                            \\\n+        SPA_FALLTHROUGH                             \\\n+    case 'p':                                    \\\n+    case 'y':                                    \\\n+        va_arg(args, void*);                            \\\n+        SPA_FALLTHROUGH                             \\\n+    case 'b':                                    \\\n+    case 'I':                                    \\\n+    case 'i':                                    \\\n+    case 'l':                                    \\\n+    case 'f':                                    \\\n+    case 'd':                                    \\\n+    case 's':                                    \\\n+    case 'R':                                    \\\n+    case 'F':                                    \\\n+    case 'B':                                    \\\n+    case 'h':                                    \\\n+    case 'V':                                    \\\n+    case 'P':                                    \\\n+    case 'T':                                    \\\n+    case 'O':                                    \\\n+        va_arg(args, void*);                            \\\n+        break;                                    \\\n+    }                                        \\\n+} while(false)\n+\n+static inline int spa_pod_parser_getv(struct spa_pod_parser *parser, va_list args)\n+{\n+    struct spa_pod_frame *f = parser->state.frame;\n+        uint32_t ftype = f ? f->pod.type : (uint32_t)SPA_TYPE_Struct;\n+    const struct spa_pod_prop *prop = NULL;\n+    int count = 0;\n+\n+    do {\n+        bool optional;\n+        const struct spa_pod *pod = NULL;\n+        const char *format;\n+\n+        if (ftype == SPA_TYPE_Object) {\n+            uint32_t key = va_arg(args, uint32_t);\n+            const struct spa_pod_object *object;\n+\n+            if (key == 0)\n+                break;\n+\n+            object = (const struct spa_pod_object *)spa_pod_parser_frame(parser, f);\n+            prop = spa_pod_object_find_prop(object, prop, key);\n+            pod = prop ? &prop->value : NULL;\n+        }\n+\n+        if ((format = va_arg(args, char *)) == NULL)\n+            break;\n+\n+        if (ftype == SPA_TYPE_Struct)\n+            pod = spa_pod_parser_next(parser);\n+\n+        if ((optional = (*format == '?')))\n+            format++;\n+\n+        if (!spa_pod_parser_can_collect(pod, *format)) {\n+            if (!optional) {\n+                if (pod == NULL)\n+                    return -ESRCH;\n+                else\n+                    return -EPROTO;\n+            }\n+            SPA_POD_PARSER_SKIP(*format, args);\n+        } else {\n+            if (pod->type == SPA_TYPE_Choice && *format != 'V')\n+                pod = SPA_POD_CHOICE_CHILD(pod);\n+\n+            SPA_POD_PARSER_COLLECT(pod, *format, args);\n+            count++;\n+        }\n+    } while (true);\n+\n+    return count;\n+}\n+\n+static inline int spa_pod_parser_get(struct spa_pod_parser *parser, ...)\n+{\n+    int res;\n+    va_list args;\n+\n+    va_start(args, parser);\n+    res = spa_pod_parser_getv(parser, args);\n+    va_end(args);\n+\n+    return res;\n+}\n+\n+#define SPA_POD_OPT_Bool(val)                \"?\" SPA_POD_Bool(val)\n+#define SPA_POD_OPT_Id(val)                \"?\" SPA_POD_Id(val)\n+#define SPA_POD_OPT_Int(val)                \"?\" SPA_POD_Int(val)\n+#define SPA_POD_OPT_Long(val)                \"?\" SPA_POD_Long(val)\n+#define SPA_POD_OPT_Float(val)                \"?\" SPA_POD_Float(val)\n+#define SPA_POD_OPT_Double(val)                \"?\" SPA_POD_Double(val)\n+#define SPA_POD_OPT_String(val)                \"?\" SPA_POD_String(val)\n+#define SPA_POD_OPT_Stringn(val,len)            \"?\" SPA_POD_Stringn(val,len)\n+#define SPA_POD_OPT_Bytes(val,len)            \"?\" SPA_POD_Bytes(val,len)\n+#define SPA_POD_OPT_Rectangle(val)            \"?\" SPA_POD_Rectangle(val)\n+#define SPA_POD_OPT_Fraction(val)            \"?\" SPA_POD_Fraction(val)\n+#define SPA_POD_OPT_Array(csize,ctype,n_vals,vals)    \"?\" SPA_POD_Array(csize,ctype,n_vals,vals)\n+#define SPA_POD_OPT_Pointer(type,val)            \"?\" SPA_POD_Pointer(type,val)\n+#define SPA_POD_OPT_Fd(val)                \"?\" SPA_POD_Fd(val)\n+#define SPA_POD_OPT_Pod(val)                \"?\" SPA_POD_Pod(val)\n+#define SPA_POD_OPT_PodObject(val)            \"?\" SPA_POD_PodObject(val)\n+#define SPA_POD_OPT_PodStruct(val)            \"?\" SPA_POD_PodStruct(val)\n+#define SPA_POD_OPT_PodChoice(val)            \"?\" SPA_POD_PodChoice(val)\n+\n+#define spa_pod_parser_get_object(p,type,id,...)                \\\n+({                                        \\\n+    struct spa_pod_frame _f;                        \\\n+    int _res;                                \\\n+    if ((_res = spa_pod_parser_push_object(p, &_f, type, id)) == 0) {    \\\n+        _res = spa_pod_parser_get(p,##__VA_ARGS__, 0);            \\\n+        spa_pod_parser_pop(p, &_f);                    \\\n+    }                                    \\\n+    _res;                                    \\\n+})\n+\n+#define spa_pod_parser_get_struct(p,...)                \\\n+({                                    \\\n+    struct spa_pod_frame _f;                    \\\n+    int _res;                            \\\n+    if ((_res = spa_pod_parser_push_struct(p, &_f)) == 0) {        \\\n+        _res = spa_pod_parser_get(p,##__VA_ARGS__, NULL);    \\\n+        spa_pod_parser_pop(p, &_f);                \\\n+    }                                \\\n+    _res;                            \\\n+})\n+\n+#define spa_pod_parse_object(pod,type,id,...)            \\\n+({                                \\\n+    struct spa_pod_parser _p;                \\\n+    spa_pod_parser_pod(&_p, pod);                \\\n+    spa_pod_parser_get_object(&_p,type,id,##__VA_ARGS__);    \\\n+})\n+\n+#define spa_pod_parse_struct(pod,...)                \\\n+({                                \\\n+    struct spa_pod_parser _p;                \\\n+    spa_pod_parser_pod(&_p, pod);                \\\n+    spa_pod_parser_get_struct(&_p,##__VA_ARGS__);        \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_PARSER_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/parser.h","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_H\n+#define SPA_POD_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/type.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#define SPA_POD_BODY_SIZE(pod)            (((struct spa_pod*)(pod))->size)\n+#define SPA_POD_TYPE(pod)            (((struct spa_pod*)(pod))->type)\n+#define SPA_POD_SIZE(pod)            ((uint64_t)sizeof(struct spa_pod) + SPA_POD_BODY_SIZE(pod))\n+#define SPA_POD_CONTENTS_SIZE(type,pod)        (SPA_POD_SIZE(pod)-sizeof(type))\n+\n+#define SPA_POD_CONTENTS(type,pod)        SPA_PTROFF((pod),sizeof(type),void)\n+#define SPA_POD_CONTENTS_CONST(type,pod)    SPA_PTROFF((pod),sizeof(type),const void)\n+#define SPA_POD_BODY(pod)            SPA_PTROFF((pod),sizeof(struct spa_pod),void)\n+#define SPA_POD_BODY_CONST(pod)            SPA_PTROFF((pod),sizeof(struct spa_pod),const void)\n+\n+struct spa_pod {\n+    uint32_t size;        \/* size of the body *\/\n+    uint32_t type;        \/* a basic id of enum spa_type *\/\n+};\n+\n+#define SPA_POD_VALUE(type,pod)            (((type*)(pod))->value)\n+\n+struct spa_pod_bool {\n+    struct spa_pod pod;\n+    int32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_id {\n+    struct spa_pod pod;\n+    uint32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_int {\n+    struct spa_pod pod;\n+    int32_t value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_long {\n+    struct spa_pod pod;\n+    int64_t value;\n+};\n+\n+struct spa_pod_float {\n+    struct spa_pod pod;\n+    float value;\n+    int32_t _padding;\n+};\n+\n+struct spa_pod_double {\n+    struct spa_pod pod;\n+    double value;\n+};\n+\n+struct spa_pod_string {\n+    struct spa_pod pod;\n+    \/* value here *\/\n+};\n+\n+struct spa_pod_bytes {\n+    struct spa_pod pod;\n+    \/* value here *\/\n+};\n+\n+struct spa_pod_rectangle {\n+    struct spa_pod pod;\n+    struct spa_rectangle value;\n+};\n+\n+struct spa_pod_fraction {\n+    struct spa_pod pod;\n+    struct spa_fraction value;\n+};\n+\n+struct spa_pod_bitmap {\n+    struct spa_pod pod;\n+    \/* array of uint8_t follows with the bitmap *\/\n+};\n+\n+#define SPA_POD_ARRAY_CHILD(arr)    (&((struct spa_pod_array*)(arr))->body.child)\n+#define SPA_POD_ARRAY_VALUE_TYPE(arr)    (SPA_POD_TYPE(SPA_POD_ARRAY_CHILD(arr)))\n+#define SPA_POD_ARRAY_VALUE_SIZE(arr)    (SPA_POD_BODY_SIZE(SPA_POD_ARRAY_CHILD(arr)))\n+#define SPA_POD_ARRAY_N_VALUES(arr)    (SPA_POD_ARRAY_VALUE_SIZE(arr) ? ((SPA_POD_BODY_SIZE(arr) - sizeof(struct spa_pod_array_body)) \/ SPA_POD_ARRAY_VALUE_SIZE(arr)) : 0)\n+#define SPA_POD_ARRAY_VALUES(arr)    SPA_POD_CONTENTS(struct spa_pod_array, arr)\n+\n+struct spa_pod_array_body {\n+    struct spa_pod child;\n+    \/* array with elements of child.size follows *\/\n+};\n+\n+struct spa_pod_array {\n+    struct spa_pod pod;\n+    struct spa_pod_array_body body;\n+};\n+\n+#define SPA_POD_CHOICE_CHILD(choice)        (&((struct spa_pod_choice*)(choice))->body.child)\n+#define SPA_POD_CHOICE_TYPE(choice)        (((struct spa_pod_choice*)(choice))->body.type)\n+#define SPA_POD_CHOICE_FLAGS(choice)        (((struct spa_pod_choice*)(choice))->body.flags)\n+#define SPA_POD_CHOICE_VALUE_TYPE(choice)    (SPA_POD_TYPE(SPA_POD_CHOICE_CHILD(choice)))\n+#define SPA_POD_CHOICE_VALUE_SIZE(choice)    (SPA_POD_BODY_SIZE(SPA_POD_CHOICE_CHILD(choice)))\n+#define SPA_POD_CHOICE_N_VALUES(choice)        (SPA_POD_CHOICE_VALUE_SIZE(choice) ? ((SPA_POD_BODY_SIZE(choice) - sizeof(struct spa_pod_choice_body)) \/ SPA_POD_CHOICE_VALUE_SIZE(choice)) : 0)\n+#define SPA_POD_CHOICE_VALUES(choice)        (SPA_POD_CONTENTS(struct spa_pod_choice, choice))\n+\n+enum spa_choice_type {\n+    SPA_CHOICE_None,        \/**< no choice, first value is current *\/\n+    SPA_CHOICE_Range,        \/**< range: default, min, max *\/\n+    SPA_CHOICE_Step,        \/**< range with step: default, min, max, step *\/\n+    SPA_CHOICE_Enum,        \/**< list: default, alternative,...  *\/\n+    SPA_CHOICE_Flags,        \/**< flags: default, possible flags,... *\/\n+};\n+\n+struct spa_pod_choice_body {\n+    uint32_t type;            \/**< type of choice, one of enum spa_choice_type *\/\n+    uint32_t flags;            \/**< extra flags *\/\n+    struct spa_pod child;\n+    \/* array with elements of child.size follows. Note that there might be more\n+     * elements than required by \\a type, which should be ignored. *\/\n+};\n+\n+struct spa_pod_choice {\n+    struct spa_pod pod;\n+    struct spa_pod_choice_body body;\n+};\n+\n+struct spa_pod_struct {\n+    struct spa_pod pod;\n+    \/* one or more spa_pod follow *\/\n+};\n+\n+#define SPA_POD_OBJECT_TYPE(obj)    (((struct spa_pod_object*)(obj))->body.type)\n+#define SPA_POD_OBJECT_ID(obj)        (((struct spa_pod_object*)(obj))->body.id)\n+\n+struct spa_pod_object_body {\n+    uint32_t type;        \/**< one of enum spa_type *\/\n+    uint32_t id;        \/**< id of the object, depends on the object type *\/\n+    \/* contents follow, series of spa_pod_prop *\/\n+};\n+\n+struct spa_pod_object {\n+    struct spa_pod pod;\n+    struct spa_pod_object_body body;\n+};\n+\n+struct spa_pod_pointer_body {\n+    uint32_t type;        \/**< pointer id, one of enum spa_type *\/\n+    uint32_t _padding;\n+    const void *value;\n+};\n+\n+struct spa_pod_pointer {\n+    struct spa_pod pod;\n+    struct spa_pod_pointer_body body;\n+};\n+\n+struct spa_pod_fd {\n+    struct spa_pod pod;\n+    int64_t value;\n+};\n+\n+#define SPA_POD_PROP_SIZE(prop)        (sizeof(struct spa_pod_prop) + (prop)->value.size)\n+\n+\/* props can be inside an object *\/\n+struct spa_pod_prop {\n+    uint32_t key;            \/**< key of property, list of valid keys depends on the\n+                      *  object type *\/\n+#define SPA_POD_PROP_FLAG_READONLY    (1u<<0)        \/**< is read-only *\/\n+#define SPA_POD_PROP_FLAG_HARDWARE    (1u<<1)        \/**< some sort of hardware parameter *\/\n+#define SPA_POD_PROP_FLAG_HINT_DICT    (1u<<2)        \/**< contains a dictionary struct as\n+                             *   (Struct(\n+                             *      Int : n_items,\n+                             *      (String : key,\n+                             *       String : value)*)) *\/\n+#define SPA_POD_PROP_FLAG_MANDATORY    (1u<<3)        \/**< is mandatory *\/\n+#define SPA_POD_PROP_FLAG_DONT_FIXATE    (1u<<4)        \/**< choices need no fixation *\/\n+    uint32_t flags;            \/**< flags for property *\/\n+    struct spa_pod value;\n+    \/* value follows *\/\n+};\n+\n+#define SPA_POD_CONTROL_SIZE(ev)    (sizeof(struct spa_pod_control) + (ev)->value.size)\n+\n+\/* controls can be inside a sequence and mark timed values *\/\n+struct spa_pod_control {\n+    uint32_t offset;    \/**< media offset *\/\n+    uint32_t type;        \/**< type of control, enum spa_control_type *\/\n+    struct spa_pod value;    \/**< control value, depends on type *\/\n+    \/* value contents follow *\/\n+};\n+\n+struct spa_pod_sequence_body {\n+    uint32_t unit;\n+    uint32_t pad;\n+    \/* series of struct spa_pod_control follows *\/\n+};\n+\n+\/** a sequence of timed controls *\/\n+struct spa_pod_sequence {\n+    struct spa_pod pod;\n+    struct spa_pod_sequence_body body;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/pod.h","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_POD_VARARG_H\n+#define SPA_POD_VARARG_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+\n+#include <spa\/pod\/pod.h>\n+\n+\/**\n+ * \\addtogroup spa_pod\n+ * \\{\n+ *\/\n+\n+#define SPA_POD_Prop(key,...)                \\\n+    key, ##__VA_ARGS__\n+\n+#define SPA_POD_Control(offset,type,...)        \\\n+    offset, type, ##__VA_ARGS__\n+\n+#define SPA_CHOICE_RANGE(def,min,max)            3,(def),(min),(max)\n+#define SPA_CHOICE_STEP(def,min,max,step)        4,(def),(min),(max),(step)\n+#define SPA_CHOICE_ENUM(n_vals,...)            (n_vals),##__VA_ARGS__\n+#define SPA_CHOICE_FLAGS(flags)                1, (flags)\n+#define SPA_CHOICE_BOOL(def)                3,(def),(def),!(def)\n+\n+#define SPA_POD_Bool(val)                \"b\", val\n+#define SPA_POD_CHOICE_Bool(def)            \"?eb\", SPA_CHOICE_BOOL(def)\n+\n+#define SPA_POD_Id(val)                    \"I\", val\n+#define SPA_POD_CHOICE_ENUM_Id(n_vals,...)        \"?eI\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+\n+#define SPA_POD_Int(val)                \"i\", val\n+#define SPA_POD_CHOICE_ENUM_Int(n_vals,...)        \"?ei\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Int(def,min,max)        \"?ri\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Int(def,min,max,step)    \"?si\", SPA_CHOICE_STEP(def, min, max, step)\n+#define SPA_POD_CHOICE_FLAGS_Int(flags)            \"?fi\", SPA_CHOICE_FLAGS(flags)\n+\n+#define SPA_POD_Long(val)                \"l\", val\n+#define SPA_POD_CHOICE_ENUM_Long(n_vals,...)        \"?el\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Long(def,min,max)        \"?rl\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Long(def,min,max,step)    \"?sl\", SPA_CHOICE_STEP(def, min, max, step)\n+#define SPA_POD_CHOICE_FLAGS_Long(flags)        \"?fl\", SPA_CHOICE_FLAGS(flags)\n+\n+#define SPA_POD_Float(val)                \"f\", val\n+#define SPA_POD_CHOICE_ENUM_Float(n_vals,...)        \"?ef\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Float(def,min,max)        \"?rf\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Float(def,min,max,step)    \"?sf\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_Double(val)                \"d\", val\n+#define SPA_POD_CHOICE_ENUM_Double(n_vals,...)        \"?ed\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Double(def,min,max)    \"?rd\", SPA_CHOICE_RANGE(def, min, max)\n+#define SPA_POD_CHOICE_STEP_Double(def,min,max,step)    \"?sd\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_String(val)                \"s\",val\n+#define SPA_POD_Stringn(val,len)            \"S\",val,len\n+\n+#define SPA_POD_Bytes(val,len)                \"y\",val,len\n+\n+#define SPA_POD_Rectangle(val)                \"R\",val\n+#define SPA_POD_CHOICE_ENUM_Rectangle(n_vals,...)    \"?eR\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Rectangle(def,min,max)    \"?rR\", SPA_CHOICE_RANGE((def),(min),(max))\n+#define SPA_POD_CHOICE_STEP_Rectangle(def,min,max,step)    \"?sR\", SPA_CHOICE_STEP((def),(min),(max),(step))\n+\n+#define SPA_POD_Fraction(val)                \"F\",val\n+#define SPA_POD_CHOICE_ENUM_Fraction(n_vals,...)    \"?eF\", SPA_CHOICE_ENUM(n_vals, __VA_ARGS__)\n+#define SPA_POD_CHOICE_RANGE_Fraction(def,min,max)    \"?rF\", SPA_CHOICE_RANGE((def),(min),(max))\n+#define SPA_POD_CHOICE_STEP_Fraction(def,min,max,step)    \"?sF\", SPA_CHOICE_STEP(def, min, max, step)\n+\n+#define SPA_POD_Array(csize,ctype,n_vals,vals)        \"a\", csize,ctype,n_vals,vals\n+#define SPA_POD_Pointer(type,val)            \"p\", type,val\n+#define SPA_POD_Fd(val)                    \"h\", val\n+#define SPA_POD_None()                    \"P\", NULL\n+#define SPA_POD_Pod(val)                \"P\", val\n+#define SPA_POD_PodObject(val)                \"O\", val\n+#define SPA_POD_PodStruct(val)                \"T\", val\n+#define SPA_POD_PodChoice(val)                \"V\", val\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_POD_VARARG_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/pod\/vararg.h","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_LOOP_H\n+#define SPA_LOOP_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+#include <spa\/support\/system.h>\n+\n+\/** \\defgroup spa_loop Loop\n+ * Event loop interface\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_loop\n+ * \\{\n+ *\/\n+\n+#define SPA_TYPE_INTERFACE_Loop        SPA_TYPE_INFO_INTERFACE_BASE \"Loop\"\n+#define SPA_TYPE_INTERFACE_DataLoop    SPA_TYPE_INFO_INTERFACE_BASE \"DataLoop\"\n+#define SPA_VERSION_LOOP        0\n+struct spa_loop { struct spa_interface iface; };\n+\n+#define SPA_TYPE_INTERFACE_LoopControl    SPA_TYPE_INFO_INTERFACE_BASE \"LoopControl\"\n+#define SPA_VERSION_LOOP_CONTROL    1\n+struct spa_loop_control { struct spa_interface iface; };\n+\n+#define SPA_TYPE_INTERFACE_LoopUtils    SPA_TYPE_INFO_INTERFACE_BASE \"LoopUtils\"\n+#define SPA_VERSION_LOOP_UTILS        0\n+struct spa_loop_utils { struct spa_interface iface; };\n+\n+struct spa_source;\n+\n+typedef void (*spa_source_func_t) (struct spa_source *source);\n+\n+struct spa_source {\n+    struct spa_loop *loop;\n+    spa_source_func_t func;\n+    void *data;\n+    int fd;\n+    uint32_t mask;\n+    uint32_t rmask;\n+    \/* private data for the loop implementer *\/\n+    void *priv;\n+};\n+\n+typedef int (*spa_invoke_func_t) (struct spa_loop *loop,\n+                  bool async,\n+                  uint32_t seq,\n+                  const void *data,\n+                  size_t size,\n+                  void *user_data);\n+\n+\/**\n+ * Register sources and work items to an event loop\n+ *\/\n+struct spa_loop_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_METHODS    0\n+    uint32_t version;\n+\n+    \/** add a source to the loop *\/\n+    int (*add_source) (void *object,\n+               struct spa_source *source);\n+\n+    \/** update the source io mask *\/\n+    int (*update_source) (void *object,\n+            struct spa_source *source);\n+\n+    \/** remove a source from the loop *\/\n+    int (*remove_source) (void *object,\n+            struct spa_source *source);\n+\n+    \/** invoke a function in the context of this loop *\/\n+    int (*invoke) (void *object,\n+               spa_invoke_func_t func,\n+               uint32_t seq,\n+               const void *data,\n+               size_t size,\n+               bool block,\n+               void *user_data);\n+};\n+\n+#define spa_loop_method(o,method,version,...)                \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_methods, _res,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define spa_loop_add_source(l,...)    spa_loop_method(l,add_source,0,##__VA_ARGS__)\n+#define spa_loop_update_source(l,...)    spa_loop_method(l,update_source,0,##__VA_ARGS__)\n+#define spa_loop_remove_source(l,...)    spa_loop_method(l,remove_source,0,##__VA_ARGS__)\n+#define spa_loop_invoke(l,...)        spa_loop_method(l,invoke,0,##__VA_ARGS__)\n+\n+\n+\/** Control hooks. These hooks can't be removed from their\n+ *  callbacks and must be removed from a safe place (when the loop\n+ *  is not running or when it is locked). *\/\n+struct spa_loop_control_hooks {\n+#define SPA_VERSION_LOOP_CONTROL_HOOKS    0\n+    uint32_t version;\n+    \/** Executed right before waiting for events. It is typically used to\n+     * release locks. *\/\n+    void (*before) (void *data);\n+    \/** Executed right after waiting for events. It is typically used to\n+     * reacquire locks. *\/\n+    void (*after) (void *data);\n+};\n+\n+#define spa_loop_control_hook_before(l)                            \\\n+({                                            \\\n+    struct spa_hook_list *_l = l;                            \\\n+    struct spa_hook *_h;                                \\\n+    spa_list_for_each_reverse(_h, &_l->list, link)                    \\\n+        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, before, 0);    \\\n+})\n+\n+#define spa_loop_control_hook_after(l)                            \\\n+({                                            \\\n+    struct spa_hook_list *_l = l;                            \\\n+    struct spa_hook *_h;                                \\\n+    spa_list_for_each(_h, &_l->list, link)                        \\\n+        spa_callbacks_call(&_h->cb, struct spa_loop_control_hooks, after, 0);    \\\n+})\n+\n+\/**\n+ * Control an event loop\n+ *\/\n+struct spa_loop_control_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_CONTROL_METHODS    1\n+    uint32_t version;\n+\n+    int (*get_fd) (void *object);\n+\n+    \/** Add a hook\n+     * \\param ctrl the control to change\n+     * \\param hooks the hooks to add\n+     *\n+     * Adds hooks to the loop controlled by \\a ctrl.\n+     *\/\n+    void (*add_hook) (void *object,\n+              struct spa_hook *hook,\n+              const struct spa_loop_control_hooks *hooks,\n+              void *data);\n+\n+    \/** Enter a loop\n+     * \\param ctrl the control\n+     *\n+     * Start an iteration of the loop. This function should be called\n+     * before calling iterate and is typically used to capture the thread\n+     * that this loop will run in.\n+     *\/\n+    void (*enter) (void *object);\n+    \/** Leave a loop\n+     * \\param ctrl the control\n+     *\n+     * Ends the iteration of a loop. This should be called after calling\n+     * iterate.\n+     *\/\n+    void (*leave) (void *object);\n+\n+    \/** Perform one iteration of the loop.\n+     * \\param ctrl the control\n+     * \\param timeout an optional timeout in milliseconds.\n+     *    0 for no timeout, -1 for infinite timeout.\n+     *\n+     * This function will block\n+     * up to \\a timeout milliseconds and then dispatch the fds with activity.\n+     * The number of dispatched fds is returned.\n+     *\/\n+    int (*iterate) (void *object, int timeout);\n+\n+    \/** Check context of the loop\n+     * \\param ctrl the control\n+     *\n+     * This function will check if the current thread is currently the\n+     * one that did the enter call. Since version 1:1.\n+     *\n+     * returns 1 on success, 0 or negative errno value on error.\n+     *\/\n+    int (*check) (void *object);\n+};\n+\n+#define spa_loop_control_method_v(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_loop_control *_o = o;                \\\n+    spa_interface_call(&_o->iface,                    \\\n+            struct spa_loop_control_methods,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+\n+#define spa_loop_control_method_r(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop_control *_o = o;                \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_control_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+#define spa_loop_control_get_fd(l)        spa_loop_control_method_r(l,get_fd,0)\n+#define spa_loop_control_add_hook(l,...)    spa_loop_control_method_v(l,add_hook,0,__VA_ARGS__)\n+#define spa_loop_control_enter(l)        spa_loop_control_method_v(l,enter,0)\n+#define spa_loop_control_leave(l)        spa_loop_control_method_v(l,leave,0)\n+#define spa_loop_control_iterate(l,...)        spa_loop_control_method_r(l,iterate,0,__VA_ARGS__)\n+#define spa_loop_control_check(l)        spa_loop_control_method_r(l,check,1)\n+\n+typedef void (*spa_source_io_func_t) (void *data, int fd, uint32_t mask);\n+typedef void (*spa_source_idle_func_t) (void *data);\n+typedef void (*spa_source_event_func_t) (void *data, uint64_t count);\n+typedef void (*spa_source_timer_func_t) (void *data, uint64_t expirations);\n+typedef void (*spa_source_signal_func_t) (void *data, int signal_number);\n+\n+\/**\n+ * Create sources for an event loop\n+ *\/\n+struct spa_loop_utils_methods {\n+    \/* the version of this structure. This can be used to expand this\n+     * structure in the future *\/\n+#define SPA_VERSION_LOOP_UTILS_METHODS    0\n+    uint32_t version;\n+\n+    struct spa_source *(*add_io) (void *object,\n+                      int fd,\n+                      uint32_t mask,\n+                      bool close,\n+                      spa_source_io_func_t func, void *data);\n+\n+    int (*update_io) (void *object, struct spa_source *source, uint32_t mask);\n+\n+    struct spa_source *(*add_idle) (void *object,\n+                    bool enabled,\n+                    spa_source_idle_func_t func, void *data);\n+    int (*enable_idle) (void *object, struct spa_source *source, bool enabled);\n+\n+    struct spa_source *(*add_event) (void *object,\n+                     spa_source_event_func_t func, void *data);\n+    int (*signal_event) (void *object, struct spa_source *source);\n+\n+    struct spa_source *(*add_timer) (void *object,\n+                     spa_source_timer_func_t func, void *data);\n+    int (*update_timer) (void *object,\n+                 struct spa_source *source,\n+                 struct timespec *value,\n+                 struct timespec *interval,\n+                 bool absolute);\n+    struct spa_source *(*add_signal) (void *object,\n+                      int signal_number,\n+                      spa_source_signal_func_t func, void *data);\n+\n+    \/** destroy a source allocated with this interface. This function\n+     * should only be called when the loop is not running or from the\n+     * context of the running loop *\/\n+    void (*destroy_source) (void *object, struct spa_source *source);\n+};\n+\n+#define spa_loop_utils_method_v(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call(&_o->iface,                    \\\n+            struct spa_loop_utils_methods,            \\\n+            method, version, ##__VA_ARGS__);        \\\n+})\n+\n+#define spa_loop_utils_method_r(o,method,version,...)            \\\n+({                                    \\\n+    int _res = -ENOTSUP;                        \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_utils_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+#define spa_loop_utils_method_s(o,method,version,...)            \\\n+({                                    \\\n+    struct spa_source *_res = NULL;                    \\\n+    struct spa_loop_utils *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_loop_utils_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\n+#define spa_loop_utils_add_io(l,...)        spa_loop_utils_method_s(l,add_io,0,__VA_ARGS__)\n+#define spa_loop_utils_update_io(l,...)        spa_loop_utils_method_r(l,update_io,0,__VA_ARGS__)\n+#define spa_loop_utils_add_idle(l,...)        spa_loop_utils_method_s(l,add_idle,0,__VA_ARGS__)\n+#define spa_loop_utils_enable_idle(l,...)    spa_loop_utils_method_r(l,enable_idle,0,__VA_ARGS__)\n+#define spa_loop_utils_add_event(l,...)        spa_loop_utils_method_s(l,add_event,0,__VA_ARGS__)\n+#define spa_loop_utils_signal_event(l,...)    spa_loop_utils_method_r(l,signal_event,0,__VA_ARGS__)\n+#define spa_loop_utils_add_timer(l,...)        spa_loop_utils_method_s(l,add_timer,0,__VA_ARGS__)\n+#define spa_loop_utils_update_timer(l,...)    spa_loop_utils_method_r(l,update_timer,0,__VA_ARGS__)\n+#define spa_loop_utils_add_signal(l,...)    spa_loop_utils_method_s(l,add_signal,0,__VA_ARGS__)\n+#define spa_loop_utils_destroy_source(l,...)    spa_loop_utils_method_v(l,destroy_source,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_LOOP_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/support\/loop.h","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2019 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_SYSTEM_H\n+#define SPA_SYSTEM_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct itimerspec;\n+\n+#include <time.h>\n+#include <sys\/types.h>\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/hook.h>\n+\n+\/** \\defgroup spa_system System\n+ * I\/O, clock, polling, timer, and signal interfaces\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_system\n+ * \\{\n+ *\/\n+\n+\/**\n+ * a collection of core system functions\n+ *\/\n+#define SPA_TYPE_INTERFACE_System    SPA_TYPE_INFO_INTERFACE_BASE \"System\"\n+#define SPA_TYPE_INTERFACE_DataSystem    SPA_TYPE_INFO_INTERFACE_BASE \"DataSystem\"\n+\n+#define SPA_VERSION_SYSTEM        0\n+struct spa_system { struct spa_interface iface; };\n+\n+\/* IO events *\/\n+#define SPA_IO_IN    (1 << 0)\n+#define SPA_IO_OUT    (1 << 2)\n+#define SPA_IO_ERR    (1 << 3)\n+#define SPA_IO_HUP    (1 << 4)\n+\n+\/* flags *\/\n+#define SPA_FD_CLOEXEC            (1<<0)\n+#define SPA_FD_NONBLOCK            (1<<1)\n+#define SPA_FD_EVENT_SEMAPHORE        (1<<2)\n+#define SPA_FD_TIMER_ABSTIME        (1<<3)\n+#define SPA_FD_TIMER_CANCEL_ON_SET    (1<<4)\n+\n+struct spa_poll_event {\n+    uint32_t events;\n+    void *data;\n+};\n+\n+struct spa_system_methods {\n+#define SPA_VERSION_SYSTEM_METHODS    0\n+    uint32_t version;\n+\n+    \/* read\/write\/ioctl *\/\n+    ssize_t (*read) (void *object, int fd, void *buf, size_t count);\n+    ssize_t (*write) (void *object, int fd, const void *buf, size_t count);\n+    int (*ioctl) (void *object, int fd, unsigned long request, ...);\n+    int (*close) (void *object, int fd);\n+\n+    \/* clock *\/\n+    int (*clock_gettime) (void *object,\n+            int clockid, struct timespec *value);\n+    int (*clock_getres) (void *object,\n+            int clockid, struct timespec *res);\n+\n+    \/* poll *\/\n+    int (*pollfd_create) (void *object, int flags);\n+    int (*pollfd_add) (void *object, int pfd, int fd, uint32_t events, void *data);\n+    int (*pollfd_mod) (void *object, int pfd, int fd, uint32_t events, void *data);\n+    int (*pollfd_del) (void *object, int pfd, int fd);\n+    int (*pollfd_wait) (void *object, int pfd,\n+            struct spa_poll_event *ev, int n_ev, int timeout);\n+\n+    \/* timers *\/\n+    int (*timerfd_create) (void *object, int clockid, int flags);\n+    int (*timerfd_settime) (void *object,\n+            int fd, int flags,\n+            const struct itimerspec *new_value,\n+            struct itimerspec *old_value);\n+    int (*timerfd_gettime) (void *object,\n+            int fd, struct itimerspec *curr_value);\n+    int (*timerfd_read) (void *object, int fd, uint64_t *expirations);\n+\n+    \/* events *\/\n+    int (*eventfd_create) (void *object, int flags);\n+    int (*eventfd_write) (void *object, int fd, uint64_t count);\n+    int (*eventfd_read) (void *object, int fd, uint64_t *count);\n+\n+    \/* signals *\/\n+    int (*signalfd_create) (void *object, int signal, int flags);\n+    int (*signalfd_read) (void *object, int fd, int *signal);\n+};\n+\n+#define spa_system_method_r(o,method,version,...)            \\\n+({                                    \\\n+    volatile int _res = -ENOTSUP;                    \\\n+    struct spa_system *_o = o;                    \\\n+    spa_interface_call_res(&_o->iface,                \\\n+            struct spa_system_methods, _res,        \\\n+            method, version, ##__VA_ARGS__);        \\\n+    _res;                                \\\n+})\n+\n+\n+#define spa_system_read(s,...)            spa_system_method_r(s,read,0,__VA_ARGS__)\n+#define spa_system_write(s,...)            spa_system_method_r(s,write,0,__VA_ARGS__)\n+#define spa_system_ioctl(s,...)            spa_system_method_r(s,ioctl,0,__VA_ARGS__)\n+#define spa_system_close(s,...)            spa_system_method_r(s,close,0,__VA_ARGS__)\n+\n+#define spa_system_clock_gettime(s,...)        spa_system_method_r(s,clock_gettime,0,__VA_ARGS__)\n+#define spa_system_clock_getres(s,...)        spa_system_method_r(s,clock_getres,0,__VA_ARGS__)\n+\n+#define spa_system_pollfd_create(s,...)        spa_system_method_r(s,pollfd_create,0,__VA_ARGS__)\n+#define spa_system_pollfd_add(s,...)        spa_system_method_r(s,pollfd_add,0,__VA_ARGS__)\n+#define spa_system_pollfd_mod(s,...)        spa_system_method_r(s,pollfd_mod,0,__VA_ARGS__)\n+#define spa_system_pollfd_del(s,...)        spa_system_method_r(s,pollfd_del,0,__VA_ARGS__)\n+#define spa_system_pollfd_wait(s,...)        spa_system_method_r(s,pollfd_wait,0,__VA_ARGS__)\n+\n+#define spa_system_timerfd_create(s,...)    spa_system_method_r(s,timerfd_create,0,__VA_ARGS__)\n+#define spa_system_timerfd_settime(s,...)    spa_system_method_r(s,timerfd_settime,0,__VA_ARGS__)\n+#define spa_system_timerfd_gettime(s,...)    spa_system_method_r(s,timerfd_gettime,0,__VA_ARGS__)\n+#define spa_system_timerfd_read(s,...)        spa_system_method_r(s,timerfd_read,0,__VA_ARGS__)\n+\n+#define spa_system_eventfd_create(s,...)    spa_system_method_r(s,eventfd_create,0,__VA_ARGS__)\n+#define spa_system_eventfd_write(s,...)        spa_system_method_r(s,eventfd_write,0,__VA_ARGS__)\n+#define spa_system_eventfd_read(s,...)        spa_system_method_r(s,eventfd_read,0,__VA_ARGS__)\n+\n+#define spa_system_signalfd_create(s,...)    spa_system_method_r(s,signalfd_create,0,__VA_ARGS__)\n+#define spa_system_signalfd_read(s,...)        spa_system_method_r(s,signalfd_read,0,__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_SYSTEM_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/support\/system.h","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,382 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_UTILS_DEFS_H\n+#define SPA_UTILS_DEFS_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+# if __cplusplus >= 201103L\n+#  define SPA_STATIC_ASSERT_IMPL(expr, msg, ...) static_assert(expr, msg)\n+# endif\n+#else\n+# include <stdbool.h>\n+# if __STDC_VERSION__ >= 201112L\n+#  define SPA_STATIC_ASSERT_IMPL(expr, msg, ...) _Static_assert(expr, msg)\n+# endif\n+#endif\n+#ifndef SPA_STATIC_ASSERT_IMPL\n+#define SPA_STATIC_ASSERT_IMPL(expr, ...) \\\n+    ((void)sizeof(struct { int spa_static_assertion_failed : 2 * !!(expr) - 1; }))\n+#endif\n+\n+#define SPA_STATIC_ASSERT(expr, ...) SPA_STATIC_ASSERT_IMPL(expr, ## __VA_ARGS__, \"`\" #expr \"` evaluated to false\")\n+\n+#include <inttypes.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+\/**\n+ * \\defgroup spa_utils_defs Miscellaneous\n+ * Helper macros and functions\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_utils_defs\n+ * \\{\n+ *\/\n+\n+\/**\n+ * SPA_FALLTHROUGH is an annotation to suppress compiler warnings about switch\n+ * cases that fall through without a break or return statement. SPA_FALLTHROUGH\n+ * is only needed on cases that have code:\n+ *\n+ * switch (foo) {\n+ *   case 1: \/\/ These cases have no code. No fallthrough annotations are needed.\n+ *   case 2:\n+ *   case 3:\n+ *     foo = 4; \/\/ This case has code, so a fallthrough annotation is needed:\n+ *     SPA_FALLTHROUGH;\n+ *   default:\n+ *     return foo;\n+ * }\n+ *\/\n+#if defined(__clang__) && defined(__cplusplus) && __cplusplus >= 201103L\n+   \/* clang's fallthrough annotations are only available starting in C++11. *\/\n+#  define SPA_FALLTHROUGH [[clang::fallthrough]];\n+#elif __GNUC__ >= 7 || __clang_major__ >= 10\n+#  define SPA_FALLTHROUGH __attribute__ ((fallthrough));\n+#else\n+#  define SPA_FALLTHROUGH \/* FALLTHROUGH *\/\n+#endif\n+\n+#define SPA_FLAG_MASK(field,mask,flag)    (((field) & (mask)) == (flag))\n+#define SPA_FLAG_IS_SET(field,flag)    SPA_FLAG_MASK(field, flag, flag)\n+\n+#define SPA_FLAG_SET(field,flag)    ((field) |= (flag))\n+#define SPA_FLAG_CLEAR(field, flag)                    \\\n+({                                    \\\n+    SPA_STATIC_ASSERT(__builtin_constant_p(flag) ?            \\\n+                  (__typeof__(flag))(__typeof__(field))(__typeof__(flag))(flag) == (flag) : \\\n+              sizeof(field) >= sizeof(flag),            \\\n+            \"truncation problem when masking \" #field    \\\n+            \" with ~\" #flag);                \\\n+    ((field) &= ~(__typeof__(field))(flag));            \\\n+})\n+#define SPA_FLAG_UPDATE(field,flag,val)    ((val) ? SPA_FLAG_SET((field),(flag)) : SPA_FLAG_CLEAR((field),(flag)))\n+\n+enum spa_direction {\n+    SPA_DIRECTION_INPUT = 0,\n+    SPA_DIRECTION_OUTPUT = 1,\n+};\n+\n+#define SPA_DIRECTION_REVERSE(d)    ((d) ^ 1)\n+\n+#define SPA_RECTANGLE(width,height) ((struct spa_rectangle){ (width), (height) })\n+struct spa_rectangle {\n+    uint32_t width;\n+    uint32_t height;\n+};\n+\n+#define SPA_POINT(x,y) ((struct spa_point){ (x), (y) })\n+struct spa_point {\n+    int32_t x;\n+    int32_t y;\n+};\n+\n+#define SPA_REGION(x,y,width,height) ((struct spa_region){ SPA_POINT(x,y), SPA_RECTANGLE(width,height) })\n+struct spa_region {\n+    struct spa_point position;\n+    struct spa_rectangle size;\n+};\n+\n+#define SPA_FRACTION(num,denom) ((struct spa_fraction){ (num), (denom) })\n+struct spa_fraction {\n+    uint32_t num;\n+    uint32_t denom;\n+};\n+\n+#define SPA_N_ELEMENTS(arr)  (sizeof(arr) \/ sizeof((arr)[0]))\n+\/**\n+ * Array iterator macro. Usage:\n+ * ```c\n+ * struct foo array[16];\n+ * struct foo *f;\n+ * SPA_FOR_EACH_ELEMENT(array, f) {\n+ *    f->bar = baz;\n+ * }\n+ * ```\n+ *\/\n+#define SPA_FOR_EACH_ELEMENT(arr, ptr) \\\n+    for ((ptr) = arr; (void*)(ptr) < SPA_PTROFF(arr, sizeof(arr), void); (ptr)++)\n+\n+#define SPA_FOR_EACH_ELEMENT_VAR(arr, var) \\\n+    for (__typeof__((arr)[0])* var = arr; (void*)(var) < SPA_PTROFF(arr, sizeof(arr), void); (var)++)\n+\n+#define SPA_ABS(a)            \\\n+({                    \\\n+    __typeof__(a) _a = (a);        \\\n+    SPA_LIKELY(_a >= 0) ? _a : -_a;    \\\n+})\n+#define SPA_MIN(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _min_a = (a);            \\\n+    __typeof__(b) _min_b = (b);            \\\n+    SPA_LIKELY(_min_a <= _min_b) ? _min_a : _min_b;    \\\n+})\n+#define SPA_MAX(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _max_a = (a);            \\\n+    __typeof__(b) _max_b = (b);            \\\n+    SPA_LIKELY(_max_a >= _max_b) ? _max_a : _max_b;    \\\n+})\n+#define SPA_CLAMP(v,low,high)                \\\n+({                            \\\n+    __typeof__(v) _v = (v);                \\\n+    __typeof__(low) _low = (low);            \\\n+    __typeof__(high) _high = (high);        \\\n+    SPA_MIN(SPA_MAX(_v, _low), _high);        \\\n+})\n+\n+#define SPA_CLAMPF(v,low,high)                \\\n+({                            \\\n+    fminf(fmaxf(v, low), high);            \\\n+})\n+\n+\n+#define SPA_SWAP(a,b)                    \\\n+({                            \\\n+    __typeof__(a) _t = (a);                \\\n+    (a) = b; (b) = _t;                \\\n+})\n+\n+#define SPA_TYPECHECK(type,x)        \\\n+({    type _dummy;            \\\n+    typeof(x) _dummy2;        \\\n+    (void)(&_dummy == &_dummy2);    \\\n+    x;                \\\n+})\n+\n+\/**\n+ * Return the address (buffer + offset) as pointer of \\a type\n+ *\/\n+#define SPA_PTROFF(ptr_,offset_,type_) ((type_*)((uintptr_t)(ptr_) + (ptrdiff_t)(offset_)))\n+#define SPA_PTROFF_ALIGN(ptr_,offset_,alignment_,type_) \\\n+   SPA_PTR_ALIGN(SPA_PTROFF(ptr_,offset_,type_),alignment_,type_)\n+\n+\n+\/**\n+ * Deprecated, use SPA_PTROFF and SPA_PTROFF_ALIGN instead\n+ *\/\n+#define SPA_MEMBER(b,o,t) SPA_PTROFF(b,o,t)\n+#define SPA_MEMBER_ALIGN(b,o,a,t) SPA_PTROFF_ALIGN(b,o,a,t)\n+\n+#define SPA_CONTAINER_OF(p,t,m) ((t*)((uintptr_t)(p) - offsetof(t,m)))\n+\n+#define SPA_PTRDIFF(p1,p2) ((intptr_t)(p1) - (intptr_t)(p2))\n+\n+#define SPA_PTR_TO_INT(p) ((int) ((intptr_t) (p)))\n+#define SPA_INT_TO_PTR(u) ((void*) ((intptr_t) (u)))\n+\n+#define SPA_PTR_TO_UINT32(p) ((uint32_t) ((uintptr_t) (p)))\n+#define SPA_UINT32_TO_PTR(u) ((void*) ((uintptr_t) (u)))\n+\n+#define SPA_TIME_INVALID  ((int64_t)INT64_MIN)\n+#define SPA_IDX_INVALID  ((unsigned int)-1)\n+#define SPA_ID_INVALID  ((uint32_t)0xffffffff)\n+\n+#define SPA_NSEC_PER_SEC  (1000000000LL)\n+#define SPA_NSEC_PER_MSEC (1000000ll)\n+#define SPA_NSEC_PER_USEC (1000ll)\n+#define SPA_USEC_PER_SEC  (1000000ll)\n+#define SPA_USEC_PER_MSEC (1000ll)\n+#define SPA_MSEC_PER_SEC  (1000ll)\n+\n+#define SPA_TIMESPEC_TO_NSEC(ts) ((ts)->tv_sec * SPA_NSEC_PER_SEC + (ts)->tv_nsec)\n+#define SPA_TIMESPEC_TO_USEC(ts) ((ts)->tv_sec * SPA_USEC_PER_SEC + (ts)->tv_nsec \/ SPA_NSEC_PER_USEC)\n+#define SPA_TIMEVAL_TO_NSEC(tv)  ((tv)->tv_sec * SPA_NSEC_PER_SEC + (tv)->tv_usec * SPA_NSEC_PER_USEC)\n+#define SPA_TIMEVAL_TO_USEC(tv)  ((tv)->tv_sec * SPA_USEC_PER_SEC + (tv)->tv_usec)\n+\n+#ifdef __GNUC__\n+#define SPA_PRINTF_FUNC(fmt, arg1) __attribute__((format(printf, fmt, arg1)))\n+#define SPA_FORMAT_ARG_FUNC(arg1) __attribute__((format_arg(arg1)))\n+#define SPA_ALIGNED(align) __attribute__((aligned(align)))\n+#define SPA_DEPRECATED __attribute__ ((deprecated))\n+#define SPA_EXPORT __attribute__((visibility(\"default\")))\n+#define SPA_SENTINEL __attribute__((__sentinel__))\n+#define SPA_UNUSED __attribute__ ((unused))\n+#define SPA_NORETURN __attribute__ ((noreturn))\n+#define SPA_WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))\n+#else\n+#define SPA_PRINTF_FUNC(fmt, arg1)\n+#define SPA_FORMAT_ARG_FUNC(arg1)\n+#define SPA_ALIGNED(align)\n+#define SPA_DEPRECATED\n+#define SPA_EXPORT\n+#define SPA_SENTINEL\n+#define SPA_UNUSED\n+#define SPA_NORETURN\n+#define SPA_WARN_UNUSED_RESULT\n+#endif\n+\n+#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n+#define SPA_RESTRICT restrict\n+#elif defined(__GNUC__) && __GNUC__ >= 4\n+#define SPA_RESTRICT __restrict__\n+#else\n+#define SPA_RESTRICT\n+#endif\n+\n+#define SPA_ROUND_DOWN(num,value)        \\\n+({                        \\\n+    __typeof__(num) _num = (num);        \\\n+    ((_num) - ((_num) % (value)));        \\\n+})\n+#define SPA_ROUND_UP(num,value)            \\\n+({                        \\\n+    __typeof__(value) _v = (value);        \\\n+    ((((num) + (_v) - 1) \/ (_v)) * (_v));    \\\n+})\n+\n+#define SPA_ROUND_MASK(num,mask)    ((__typeof__(num))((mask)-1))\n+\n+#define SPA_ROUND_DOWN_N(num,align)    ((num) & ~SPA_ROUND_MASK(num, align))\n+#define SPA_ROUND_UP_N(num,align)    ((((num)-1) | SPA_ROUND_MASK(num, align))+1)\n+\n+#define SPA_SCALE32_UP(val,num,denom)                \\\n+({                                \\\n+    uint64_t _val = (val);                    \\\n+    uint64_t _denom = (denom);                \\\n+    (uint32_t)(((_val) * (num) + (_denom)-1) \/ (_denom));    \\\n+})\n+\n+\n+#define SPA_PTR_ALIGNMENT(p,align)    ((intptr_t)(p) & ((align)-1))\n+#define SPA_IS_ALIGNED(p,align)        (SPA_PTR_ALIGNMENT(p,align) == 0)\n+#define SPA_PTR_ALIGN(p,align,type)    ((type*)SPA_ROUND_UP_N((intptr_t)(p), (intptr_t)(align)))\n+\n+#ifndef SPA_LIKELY\n+#ifdef __GNUC__\n+#define SPA_LIKELY(x) (__builtin_expect(!!(x),1))\n+#define SPA_UNLIKELY(x) (__builtin_expect(!!(x),0))\n+#else\n+#define SPA_LIKELY(x) (x)\n+#define SPA_UNLIKELY(x) (x)\n+#endif\n+#endif\n+\n+#define SPA_STRINGIFY_1(...)    #__VA_ARGS__\n+#define SPA_STRINGIFY(...)    SPA_STRINGIFY_1(__VA_ARGS__)\n+\n+#define spa_return_if_fail(expr)                    \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            return;                        \\\n+        }                            \\\n+    } while(false)\n+\n+#define spa_return_val_if_fail(expr, val)                \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            return (val);                    \\\n+        }                            \\\n+    } while(false)\n+\n+\/* spa_assert_se() is an assert which guarantees side effects of x,\n+ * i.e. is never optimized away, regardless of NDEBUG or FASTPATH. *\/\n+#ifndef __COVERITY__\n+#define spa_assert_se(expr)                        \\\n+    do {                                \\\n+        if (SPA_UNLIKELY(!(expr))) {                \\\n+            fprintf(stderr, \"'%s' failed at %s:%u %s()\\n\",    \\\n+                #expr , __FILE__, __LINE__, __func__);    \\\n+            abort();                    \\\n+        }                            \\\n+    } while (false)\n+#else\n+#define spa_assert_se(expr)                        \\\n+    do {                                \\\n+        int _unique_var = (expr);                \\\n+        if (!_unique_var)                    \\\n+            abort();                    \\\n+        } while (false)\n+#endif\n+\n+\/* Does exactly nothing *\/\n+#define spa_nop() do {} while (false)\n+\n+#ifdef NDEBUG\n+#define spa_assert(expr) spa_nop()\n+#elif defined (FASTPATH)\n+#define spa_assert(expr) spa_assert_se(expr)\n+#else\n+#define spa_assert(expr) spa_assert_se(expr)\n+#endif\n+\n+#ifdef NDEBUG\n+#define spa_assert_not_reached() abort()\n+#else\n+#define spa_assert_not_reached()                        \\\n+    do {                                    \\\n+        fprintf(stderr, \"Code should not be reached at %s:%u %s()\\n\",    \\\n+                __FILE__, __LINE__, __func__);            \\\n+        abort();                            \\\n+    } while (false)\n+#endif\n+\n+#define spa_memzero(x,l) (memset((x), 0, (l)))\n+#define spa_zero(x) (spa_memzero(&(x), sizeof(x)))\n+\n+#ifdef SPA_DEBUG_MEMCPY\n+#define spa_memcpy(d,s,n)                        \\\n+({                                    \\\n+    fprintf(stderr, \"%s:%u %s() memcpy(%p, %p, %zd)\\n\",        \\\n+        __FILE__, __LINE__, __func__, (d), (s), (size_t)(n));    \\\n+    memcpy(d,s,n);                            \\\n+})\n+#define spa_memmove(d,s,n)                        \\\n+({                                    \\\n+    fprintf(stderr, \"%s:%u %s() memmove(%p, %p, %zd)\\n\",        \\\n+        __FILE__, __LINE__, __func__, (d), (s), (size_t)(n));    \\\n+    memmove(d,s,n);                            \\\n+})\n+#else\n+#define spa_memcpy(d,s,n)    memcpy(d,s,n)\n+#define spa_memmove(d,s,n)    memmove(d,s,n)\n+#endif\n+\n+#define spa_aprintf(_fmt, ...)                        \\\n+({                                    \\\n+    char *_strp;                            \\\n+    if (asprintf(&(_strp), (_fmt), ## __VA_ARGS__ ) == -1)        \\\n+        _strp = NULL;                        \\\n+    _strp;                                \\\n+})\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+} \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_UTILS_DEFS_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/defs.h","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_DICT_H\n+#define SPA_DICT_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <string.h>\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\defgroup spa_dict Dictionary\n+ * Dictionary data structure\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_dict\n+ * \\{\n+ *\/\n+\n+struct spa_dict_item {\n+    const char *key;\n+    const char *value;\n+};\n+\n+#define SPA_DICT_ITEM_INIT(key,value) ((struct spa_dict_item) { (key), (value) })\n+\n+struct spa_dict {\n+#define SPA_DICT_FLAG_SORTED    (1<<0)        \/**< items are sorted *\/\n+    uint32_t flags;\n+    uint32_t n_items;\n+    const struct spa_dict_item *items;\n+};\n+\n+#define SPA_DICT_INIT(items,n_items) ((struct spa_dict) { 0, (n_items), (items) })\n+#define SPA_DICT_INIT_ARRAY(items) ((struct spa_dict) { 0, SPA_N_ELEMENTS(items), (items) })\n+\n+#define spa_dict_for_each(item, dict)                \\\n+    for ((item) = (dict)->items;                \\\n+         (item) < &(dict)->items[(dict)->n_items];        \\\n+         (item)++)\n+\n+static inline int spa_dict_item_compare(const void *i1, const void *i2)\n+{\n+    const struct spa_dict_item *it1 = (const struct spa_dict_item *)i1,\n+          *it2 = (const struct spa_dict_item *)i2;\n+    return strcmp(it1->key, it2->key);\n+}\n+\n+static inline void spa_dict_qsort(struct spa_dict *dict)\n+{\n+    if (dict->n_items > 0)\n+        qsort((void*)dict->items, dict->n_items, sizeof(struct spa_dict_item),\n+                spa_dict_item_compare);\n+    SPA_FLAG_SET(dict->flags, SPA_DICT_FLAG_SORTED);\n+}\n+\n+static inline const struct spa_dict_item *spa_dict_lookup_item(const struct spa_dict *dict,\n+                                   const char *key)\n+{\n+    const struct spa_dict_item *item;\n+\n+    if (SPA_FLAG_IS_SET(dict->flags, SPA_DICT_FLAG_SORTED) &&\n+            dict->n_items > 0) {\n+        struct spa_dict_item k = SPA_DICT_ITEM_INIT(key, NULL);\n+        item = (const struct spa_dict_item *)bsearch(&k,\n+                (const void *) dict->items, dict->n_items,\n+                sizeof(struct spa_dict_item),\n+                spa_dict_item_compare);\n+        if (item != NULL)\n+            return item;\n+    } else {\n+        spa_dict_for_each(item, dict) {\n+            if (!strcmp(item->key, key))\n+                return item;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+static inline const char *spa_dict_lookup(const struct spa_dict *dict, const char *key)\n+{\n+    const struct spa_dict_item *item = spa_dict_lookup_item(dict, key);\n+    return item ? item->value : NULL;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_DICT_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/dict.h","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_ENUM_TYPES_H\n+#define SPA_ENUM_TYPES_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/type.h>\n+\n+#define SPA_TYPE_INFO_Direction            SPA_TYPE_INFO_ENUM_BASE \"Direction\"\n+#define SPA_TYPE_INFO_DIRECTION_BASE        SPA_TYPE_INFO_Direction \":\"\n+\n+static const struct spa_type_info spa_type_direction[] = {\n+    { SPA_DIRECTION_INPUT, SPA_TYPE_Int, SPA_TYPE_INFO_DIRECTION_BASE \"Input\", NULL  },\n+    { SPA_DIRECTION_OUTPUT, SPA_TYPE_Int, SPA_TYPE_INFO_DIRECTION_BASE \"Output\", NULL  },\n+    { 0, 0, NULL, NULL }\n+};\n+\n+#include <spa\/pod\/pod.h>\n+\n+#define SPA_TYPE_INFO_Choice            SPA_TYPE_INFO_ENUM_BASE \"Choice\"\n+#define SPA_TYPE_INFO_CHOICE_BASE        SPA_TYPE_INFO_Choice \":\"\n+\n+static const struct spa_type_info spa_type_choice[] = {\n+    { SPA_CHOICE_None, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"None\", NULL  },\n+    { SPA_CHOICE_Range, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Range\", NULL  },\n+    { SPA_CHOICE_Step, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Step\", NULL  },\n+    { SPA_CHOICE_Enum, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Enum\", NULL  },\n+    { SPA_CHOICE_Flags, SPA_TYPE_Int, SPA_TYPE_INFO_CHOICE_BASE \"Flags\", NULL  },\n+    { 0, 0, NULL, NULL }\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/enum-types.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,452 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_HOOK_H\n+#define SPA_HOOK_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+#include <spa\/utils\/list.h>\n+\n+\/** \\defgroup spa_interfaces Interfaces\n+ *\n+ * \\brief Generic implementation of implementation-independent interfaces\n+ *\n+ * A SPA Interface is a generic struct that, together with a few macros,\n+ * provides a generic way of invoking methods on objects without knowing the\n+ * details of the implementation.\n+ *\n+ * The primary interaction with interfaces is through macros that expand into\n+ * the right method call. For the implementation of an interface, we need two\n+ * structs and a macro to invoke the `bar` method:\n+ *\n+ * \\code{.c}\n+ * \/\/ this struct must be public and defines the interface to a\n+ * \/\/ struct foo\n+ * struct foo_methods {\n+ *     uint32_t version;\n+ *     void (*bar)(void *object, const char *msg);\n+ * };\n+ *\n+ * \/\/ this struct does not need to be public\n+ * struct foo {\n+ *     struct spa_interface iface; \/\/ must be first element, see foo_bar()\n+ *     int some_other_field;\n+ *     ...\n+ * };\n+ *\n+ * \/\/ if struct foo is private, we need to cast to a\n+ * \/\/ generic spa_interface object\n+ * #define foo_bar(obj, ...) ({ \\\n+ *     struct foo *f = obj;\n+ *     spa_interface_call((struct spa_interface *)f, \/\/ pointer to spa_interface in foo\n+ *                        struct foo_methods, \/\/ type of callbacks\n+ *                        bar, \/\/ name of methods\n+ *                        0, \/\/ hardcoded version to match foo_methods->version\n+ *                        __VA_ARGS__ \/\/ pass rest of args through\n+ *                        );\/\n+ * })\n+ * \\endcode\n+ *\n+ * The `struct foo_methods` and the invocation macro `foo_bar()` must be\n+ * available to the caller. The implementation of `struct foo` can be private.\n+ *\n+ * \\code{.c}\n+ * void main(void) {\n+ *      struct foo *myfoo = get_foo_from_somewhere();\n+ *      foo_bar(myfoo, \"Invoking bar() on myfoo\");\n+ * }\n+ * \\endcode\n+ * The expansion of `foo_bar()` resolves roughly into this code:\n+ * \\code{.c}\n+ * void main(void) {\n+ *     struct foo *myfoo = get_foo_from_somewhere();\n+ *     \/\/ foo_bar(myfoo, \"Invoking bar() on myfoo\");\n+ *     const struct foo_methods *methods = ((struct spa_interface*)myfoo)->cb;\n+ *     if (0 >= methods->version && \/\/ version check\n+ *         methods->bar) \/\/ compile error if this function does not exist,\n+ *             methods->bar(myfoo, \"Invoking bar() on myfoo\");\n+ * }\n+ * \\endcode\n+ *\n+ * The typecast used in `foo_bar()` allows `struct foo` to be opaque to the\n+ * caller. The implementation may assign the callback methods at object\n+ * instantiation, and the caller will transparently invoke the method on the\n+ * given object. For example, the following code assigns a different `bar()` method on\n+ * Mondays - the caller does not need to know this.\n+ * \\code{.c}\n+ *\n+ * static void bar_stdout(struct foo *f, const char *msg) {\n+ *     printf(msg);\n+ * }\n+ * static void bar_stderr(struct foo *f, const char *msg) {\n+ *     fprintf(stderr, msg);\n+ * }\n+ *\n+ * struct foo* get_foo_from_somewhere() {\n+ *     struct foo *f = calloc(sizeof struct foo);\n+ *     \/\/ illustrative only, use SPA_INTERFACE_INIT()\n+ *     f->iface->cb = (struct foo_methods*) { .bar = bar_stdout };\n+ *     if (today_is_monday)\n+ *         f->iface->cb = (struct foo_methods*) { .bar = bar_stderr };\n+ *     return f;\n+ * }\n+ * \\endcode\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_interfaces\n+ * \\{\n+ *\/\n+\n+\/** \\struct spa_callbacks\n+ * Callbacks, contains the structure with functions and the data passed\n+ * to the functions.  The structure should also contain a version field that\n+ * is checked. *\/\n+struct spa_callbacks {\n+    const void *funcs;\n+    void *data;\n+};\n+\n+\/** Check if a callback \\a c is of at least version \\a v *\/\n+#define SPA_CALLBACK_VERSION_MIN(c,v) ((c) && ((v) == 0 || (c)->version > (v)-1))\n+\n+\/** Check if a callback \\a c has method \\a m of version \\a v *\/\n+#define SPA_CALLBACK_CHECK(c,m,v) (SPA_CALLBACK_VERSION_MIN(c,v) && (c)->m)\n+\n+\/**\n+ * Initialize the set of functions \\a funcs as a \\ref spa_callbacks, together\n+ * with \\a _data.\n+ *\/\n+#define SPA_CALLBACKS_INIT(_funcs,_data) ((struct spa_callbacks){ (_funcs), (_data), })\n+\n+\/** \\struct spa_interface\n+ *\/\n+struct spa_interface {\n+    const char *type;\n+    uint32_t version;\n+    struct spa_callbacks cb;\n+};\n+\n+\/**\n+ * Initialize a \\ref spa_interface.\n+ *\n+ * \\code{.c}\n+ * const static struct foo_methods foo_funcs = {\n+ *    .bar = some_bar_implementation,\n+ * };\n+ *\n+ * struct foo *f = malloc(...);\n+ * f->iface = SPA_INTERFACE_INIT(\"foo type\", 0, foo_funcs, NULL);\n+ * \\endcode\n+ *\n+ *\/\n+#define SPA_INTERFACE_INIT(_type,_version,_funcs,_data) \\\n+    ((struct spa_interface){ (_type), (_version), SPA_CALLBACKS_INIT(_funcs,_data), })\n+\n+\/**\n+ * Invoke method named \\a method in the \\a callbacks.\n+ * The \\a method_type defines the type of the method struct.\n+ * Returns true if the method could be called, false otherwise.\n+ *\/\n+#define spa_callbacks_call(callbacks,type,method,vers,...)            \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    bool _res = SPA_CALLBACK_CHECK(_f,method,vers);                \\\n+    if (SPA_LIKELY(_res))                            \\\n+        _f->method((callbacks)->data, ## __VA_ARGS__);            \\\n+    _res;                                    \\\n+})\n+\n+\/**\n+ * True if the \\a callbacks are of version \\a vers, false otherwise\n+ *\/\n+#define spa_callback_version_min(callbacks,type,vers)                \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    SPA_CALLBACK_VERSION_MIN(_f,vers);                    \\\n+})\n+\n+\/**\n+ * True if the \\a callbacks contains \\a method of version\n+ * \\a vers, false otherwise\n+ *\/\n+#define spa_callback_check(callbacks,type,method,vers)                \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    SPA_CALLBACK_CHECK(_f,method,vers);                    \\\n+})\n+\n+\/**\n+ * Invoke method named \\a method in the \\a callbacks.\n+ * The \\a method_type defines the type of the method struct.\n+ *\n+ * The return value is stored in \\a res.\n+ *\/\n+#define spa_callbacks_call_res(callbacks,type,res,method,vers,...)        \\\n+({                                        \\\n+    const type *_f = (const type *) (callbacks)->funcs;            \\\n+    if (SPA_LIKELY(SPA_CALLBACK_CHECK(_f,method,vers)))            \\\n+        res = _f->method((callbacks)->data, ## __VA_ARGS__);        \\\n+    res;                                    \\\n+})\n+\n+\/**\n+ * True if the \\a iface's callbacks are of version \\a vers, false otherwise\n+ *\/\n+#define spa_interface_callback_version_min(iface,method_type,vers)        \\\n+   spa_callback_version_min(&(iface)->cb, method_type, vers)\n+\n+\/**\n+ * True if the \\a iface's callback \\a method is of version \\a vers\n+ * and exists, false otherwise\n+ *\/\n+#define spa_interface_callback_check(iface,method_type,method,vers)        \\\n+   spa_callback_check(&(iface)->cb, method_type, method, vers)\n+\n+\/**\n+ * Invoke method named \\a method in the callbacks on the given interface object.\n+ * The \\a method_type defines the type of the method struct, not the interface\n+ * itself.\n+ *\/\n+#define spa_interface_call(iface,method_type,method,vers,...)            \\\n+    spa_callbacks_call(&(iface)->cb,method_type,method,vers,##__VA_ARGS__)\n+\n+\/**\n+ * Invoke method named \\a method in the callbacks on the given interface object.\n+ * The \\a method_type defines the type of the method struct, not the interface\n+ * itself.\n+ *\n+ * The return value is stored in \\a res.\n+ *\/\n+#define spa_interface_call_res(iface,method_type,res,method,vers,...)            \\\n+    spa_callbacks_call_res(&(iface)->cb,method_type,res,method,vers,##__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+\/** \\defgroup spa_hooks Hooks\n+ *\n+ * A SPA Hook is a data structure to keep track of callbacks. It is similar to\n+ * the \\ref spa_interfaces and typically used where an implementation allows\n+ * for multiple external callback functions. For example, an implementation may\n+ * use a hook list to implement signals with each caller using a hook to\n+ * register callbacks to be invoked on those signals.\n+ *\n+ * The below (pseudo)code is a minimal example outlining the use of hooks:\n+ * \\code{.c}\n+ * \/\/ the public interface\n+ * #define VERSION_BAR_EVENTS 0 \/\/ version of the vtable\n+ * struct bar_events {\n+ *    uint32_t version; \/\/ NOTE: an integral member named `version`\n+ *                      \/\/       must be present in the vtable\n+ *    void (*boom)(void *data, const char *msg);\n+ * };\n+ *\n+ * \/\/ private implementation\n+ * struct party {\n+ *     struct spa_hook_list bar_list;\n+ * };\n+ *\n+ * void party_add_event_listener(struct party *p, struct spa_hook *listener,\n+ *                               const struct bar_events *events, void *data)\n+ * {\n+ *    spa_hook_list_append(&p->bar_list, listener, events, data);\n+ * }\n+ *\n+ * static void party_on(struct party *p)\n+ * {\n+ *     \/\/ NOTE: this is a macro, it evaluates to an integer,\n+ *     \/\/       which is the number of hooks called\n+ *     spa_hook_list_call(&p->list,\n+ *                        struct bar_events, \/\/ vtable type\n+ *                        boom,              \/\/ function name\n+ *                        0,                 \/\/ hardcoded version,\n+ *                                           \/\/     usually the version in which `boom`\n+ *                                           \/\/     has been added to the vtable\n+ *                        \"party on, wayne\"  \/\/ function argument(s)\n+ *                        );\n+ * }\n+ * \\endcode\n+ *\n+ * In the caller, the hooks can be used like this:\n+ * \\code{.c}\n+ * static void boom_cb(void *data, const char *msg) {\n+ *      \/\/ data is userdata from main()\n+ *      printf(\"%s\", msg);\n+ * }\n+ *\n+ * static const struct bar_events events = {\n+ *    .version = VERSION_BAR_EVENTS, \/\/ version of the implemented interface\n+ *    .boom = boom_cb,\n+ * };\n+ *\n+ * void main(void) {\n+ *      void *userdata = whatever;\n+ *      struct spa_hook hook;\n+ *      struct party *p = start_the_party();\n+ *\n+ *      party_add_event_listener(p, &hook, &events, userdata);\n+ *\n+ *      mainloop();\n+ *      return 0;\n+ * }\n+ *\n+ * \\endcode\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_hooks\n+ * \\{\n+ *\/\n+\n+\/** \\struct spa_hook_list\n+ * A list of hooks. This struct is primarily used by\n+ * implementation that use multiple caller-provided \\ref spa_hook. *\/\n+struct spa_hook_list {\n+    struct spa_list list;\n+};\n+\n+\n+\/** \\struct spa_hook\n+ * A hook, contains the structure with functions and the data passed\n+ * to the functions.\n+ *\n+ * A hook should be treated as opaque by the caller.\n+ *\/\n+struct spa_hook {\n+    struct spa_list link;\n+    struct spa_callbacks cb;\n+    \/** callback and data for the hook list, private to the\n+      * hook_list implementor *\/\n+    void (*removed) (struct spa_hook *hook);\n+    void *priv;\n+};\n+\n+\/** Initialize a hook list to the empty list*\/\n+static inline void spa_hook_list_init(struct spa_hook_list *list)\n+{\n+    spa_list_init(&list->list);\n+}\n+\n+static inline bool spa_hook_list_is_empty(struct spa_hook_list *list)\n+{\n+    return spa_list_is_empty(&list->list);\n+}\n+\n+\/** Append a hook. *\/\n+static inline void spa_hook_list_append(struct spa_hook_list *list,\n+                    struct spa_hook *hook,\n+                    const void *funcs, void *data)\n+{\n+    spa_zero(*hook);\n+    hook->cb = SPA_CALLBACKS_INIT(funcs, data);\n+    spa_list_append(&list->list, &hook->link);\n+}\n+\n+\/** Prepend a hook *\/\n+static inline void spa_hook_list_prepend(struct spa_hook_list *list,\n+                     struct spa_hook *hook,\n+                     const void *funcs, void *data)\n+{\n+    spa_zero(*hook);\n+    hook->cb = SPA_CALLBACKS_INIT(funcs, data);\n+    spa_list_prepend(&list->list, &hook->link);\n+}\n+\n+\/** Remove a hook *\/\n+static inline void spa_hook_remove(struct spa_hook *hook)\n+{\n+    if (spa_list_is_initialized(&hook->link))\n+        spa_list_remove(&hook->link);\n+    if (hook->removed)\n+        hook->removed(hook);\n+}\n+\n+\/** Remove all hooks from the list *\/\n+static inline void spa_hook_list_clean(struct spa_hook_list *list)\n+{\n+    struct spa_hook *h;\n+    spa_list_consume(h, &list->list, link)\n+        spa_hook_remove(h);\n+}\n+\n+static inline void\n+spa_hook_list_isolate(struct spa_hook_list *list,\n+        struct spa_hook_list *save,\n+        struct spa_hook *hook,\n+        const void *funcs, void *data)\n+{\n+    \/* init save list and move hooks to it *\/\n+    spa_hook_list_init(save);\n+    spa_list_insert_list(&save->list, &list->list);\n+    \/* init hooks and add single hook *\/\n+    spa_hook_list_init(list);\n+    spa_hook_list_append(list, hook, funcs, data);\n+}\n+\n+static inline void\n+spa_hook_list_join(struct spa_hook_list *list,\n+        struct spa_hook_list *save)\n+{\n+    spa_list_insert_list(&list->list, &save->list);\n+}\n+\n+#define spa_hook_list_call_simple(l,type,method,vers,...)            \\\n+({                                        \\\n+    struct spa_hook_list *_l = l;                        \\\n+    struct spa_hook *_h, *_t;                        \\\n+    spa_list_for_each_safe(_h, _t, &_l->list, link)                \\\n+        spa_callbacks_call(&_h->cb,type,method,vers, ## __VA_ARGS__);    \\\n+})\n+\n+\/** Call all hooks in a list, starting from the given one and optionally stopping\n+ * after calling the first non-NULL function, returns the number of methods\n+ * called *\/\n+#define spa_hook_list_do_call(l,start,type,method,vers,once,...)        \\\n+({                                        \\\n+    struct spa_hook_list *_list = l;                    \\\n+    struct spa_list *_s = start ? (struct spa_list *)start : &_list->list;    \\\n+    struct spa_hook _cursor = { 0 }, *_ci;                    \\\n+    int _count = 0;                                \\\n+    spa_list_cursor_start(_cursor, _s, link);                \\\n+    spa_list_for_each_cursor(_ci, _cursor, &_list->list, link) {        \\\n+        if (spa_callbacks_call(&_ci->cb,type,method,vers, ## __VA_ARGS__)) {        \\\n+            _count++;                        \\\n+            if (once)                        \\\n+                break;                        \\\n+        }                                \\\n+    }                                    \\\n+    spa_list_cursor_end(_cursor, link);                    \\\n+    _count;                                    \\\n+})\n+\n+\/**\n+ * Call the method named \\a m for each element in list \\a l.\n+ * \\a t specifies the type of the callback struct.\n+ *\/\n+#define spa_hook_list_call(l,t,m,v,...)            spa_hook_list_do_call(l,NULL,t,m,v,false,##__VA_ARGS__)\n+\/**\n+ * Call the method named \\a m for each element in list \\a l, stopping after\n+ * the first invocation.\n+ * \\a t specifies the type of the callback struct.\n+ *\/\n+#define spa_hook_list_call_once(l,t,m,v,...)        spa_hook_list_do_call(l,NULL,t,m,v,true,##__VA_ARGS__)\n+\n+#define spa_hook_list_call_start(l,s,t,m,v,...)        spa_hook_list_do_call(l,s,t,m,v,false,##__VA_ARGS__)\n+#define spa_hook_list_call_once_start(l,s,t,m,v,...)    spa_hook_list_do_call(l,s,t,m,v,true,##__VA_ARGS__)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif \/* SPA_HOOK_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/hook.h","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_LIST_H\n+#define SPA_LIST_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/**\n+ * \\defgroup spa_list List\n+ * Doubly linked list data structure\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_list List\n+ * \\{\n+ *\/\n+\n+struct spa_list {\n+    struct spa_list *next;\n+    struct spa_list *prev;\n+};\n+\n+#define SPA_LIST_INIT(list) ((struct spa_list){ (list), (list) })\n+\n+static inline void spa_list_init(struct spa_list *list)\n+{\n+    *list = SPA_LIST_INIT(list);\n+}\n+\n+static inline int spa_list_is_initialized(struct spa_list *list)\n+{\n+    return !!list->prev;\n+}\n+\n+#define spa_list_is_empty(l)  ((l)->next == (l))\n+\n+static inline void spa_list_insert(struct spa_list *list, struct spa_list *elem)\n+{\n+    elem->prev = list;\n+    elem->next = list->next;\n+    list->next = elem;\n+    elem->next->prev = elem;\n+}\n+\n+static inline void spa_list_insert_list(struct spa_list *list, struct spa_list *other)\n+{\n+    if (spa_list_is_empty(other))\n+        return;\n+    other->next->prev = list;\n+    other->prev->next = list->next;\n+    list->next->prev = other->prev;\n+    list->next = other->next;\n+}\n+\n+static inline void spa_list_remove(struct spa_list *elem)\n+{\n+    elem->prev->next = elem->next;\n+    elem->next->prev = elem->prev;\n+}\n+\n+#define spa_list_first(head, type, member)                \\\n+    SPA_CONTAINER_OF((head)->next, type, member)\n+\n+#define spa_list_last(head, type, member)                \\\n+    SPA_CONTAINER_OF((head)->prev, type, member)\n+\n+#define spa_list_append(list, item)                    \\\n+    spa_list_insert((list)->prev, item)\n+\n+#define spa_list_prepend(list, item)                    \\\n+    spa_list_insert(list, item)\n+\n+#define spa_list_is_end(pos, head, member)                \\\n+    (&(pos)->member == (head))\n+\n+#define spa_list_next(pos, member)                    \\\n+    SPA_CONTAINER_OF((pos)->member.next, __typeof__(*(pos)), member)\n+\n+#define spa_list_prev(pos, member)                    \\\n+    SPA_CONTAINER_OF((pos)->member.prev, __typeof__(*(pos)), member)\n+\n+#define spa_list_consume(pos, head, member)                \\\n+    for ((pos) = spa_list_first(head, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_empty(head);                    \\\n+         (pos) = spa_list_first(head, __typeof__(*(pos)), member))\n+\n+#define spa_list_for_each_next(pos, head, curr, member)            \\\n+    for ((pos) = spa_list_first(curr, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = spa_list_next(pos, member))\n+\n+#define spa_list_for_each_prev(pos, head, curr, member)            \\\n+    for ((pos) = spa_list_last(curr, __typeof__(*(pos)), member);    \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = spa_list_prev(pos, member))\n+\n+#define spa_list_for_each(pos, head, member)                \\\n+    spa_list_for_each_next(pos, head, head, member)\n+\n+#define spa_list_for_each_reverse(pos, head, member)            \\\n+    spa_list_for_each_prev(pos, head, head, member)\n+\n+#define spa_list_for_each_safe_next(pos, tmp, head, curr, member)    \\\n+    for ((pos) = spa_list_first(curr, __typeof__(*(pos)), member);    \\\n+         (tmp) = spa_list_next(pos, member),                \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = (tmp))\n+\n+#define spa_list_for_each_safe_prev(pos, tmp, head, curr, member)    \\\n+    for ((pos) = spa_list_last(curr, __typeof__(*(pos)), member);    \\\n+         (tmp) = spa_list_prev(pos, member),                \\\n+         !spa_list_is_end(pos, head, member);            \\\n+         (pos) = (tmp))\n+\n+#define spa_list_for_each_safe(pos, tmp, head, member)            \\\n+    spa_list_for_each_safe_next(pos, tmp, head, head, member)\n+\n+#define spa_list_for_each_safe_reverse(pos, tmp, head, member)        \\\n+    spa_list_for_each_safe_prev(pos, tmp, head, head, member)\n+\n+#define spa_list_cursor_start(cursor, head, member)                     \\\n+        spa_list_prepend(head, &(cursor).member)\n+\n+#define spa_list_for_each_cursor(pos, cursor, head, member)             \\\n+        for((pos) = spa_list_first(&(cursor).member, __typeof__(*(pos)), member); \\\n+            spa_list_remove(&(pos)->member),                            \\\n+            spa_list_append(&(cursor).member, &(pos)->member),          \\\n+            !spa_list_is_end(pos, head, member);                        \\\n+            (pos) = spa_list_next(&(cursor), member))\n+\n+#define spa_list_cursor_end(cursor, member)                             \\\n+        spa_list_remove(&(cursor).member)\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_LIST_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/list.h","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2021 Red Hat, Inc. *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_UTILS_STRING_H\n+#define SPA_UTILS_STRING_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdarg.h>\n+#include <stdbool.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <locale.h>\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\defgroup spa_string String handling\n+ * String handling utilities\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_string\n+ * \\{\n+ *\/\n+\n+\/**\n+ * \\return true if the two strings are equal, false otherwise\n+ *\n+ * If both \\a a and \\a b are NULL, the two are considered equal.\n+ *\n+ *\/\n+static inline bool spa_streq(const char *s1, const char *s2)\n+{\n+    return SPA_LIKELY(s1 && s2) ? strcmp(s1, s2) == 0 : s1 == s2;\n+}\n+\n+\/**\n+ * \\return true if the two strings are equal, false otherwise\n+ *\n+ * If both \\a a and \\a b are NULL, the two are considered equal.\n+ *\/\n+static inline bool spa_strneq(const char *s1, const char *s2, size_t len)\n+{\n+    return SPA_LIKELY(s1 && s2) ? strncmp(s1, s2, len) == 0 : s1 == s2;\n+}\n+\n+\n+\/**\n+ * \\return true if \\a s starts with the \\a prefix or false otherwise.\n+ * A \\a s is NULL, it never starts with the given \\a prefix. A \\a prefix of\n+ * NULL is a bug in the caller.\n+ *\/\n+static inline bool spa_strstartswith(const char *s, const char *prefix)\n+{\n+    if (SPA_UNLIKELY(s == NULL))\n+        return false;\n+\n+    spa_assert_se(prefix);\n+\n+    return strncmp(s, prefix, strlen(prefix)) == 0;\n+}\n+\n+\n+\/**\n+ * \\return true if \\a s ends with the \\a suffix or false otherwise.\n+ * A \\a s is NULL, it never ends with the given \\a suffix. A \\a suffix of\n+ * NULL is a bug in the caller.\n+ *\/\n+static inline bool spa_strendswith(const char *s, const char *suffix)\n+{\n+    size_t l1, l2;\n+\n+    if (SPA_UNLIKELY(s == NULL))\n+        return false;\n+\n+    spa_assert_se(suffix);\n+\n+    l1 = strlen(s);\n+    l2 = strlen(suffix);\n+    return l1 >= l2 && spa_streq(s + l1 - l2, suffix);\n+}\n+\n+\/**\n+ * Convert \\a str to an int32_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atoi32(const char *str, int32_t *val, int base)\n+{\n+    char *endptr;\n+    long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtol(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    if (v != (int32_t)v)\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an uint32_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atou32(const char *str, uint32_t *val, int base)\n+{\n+    char *endptr;\n+    unsigned long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoull(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    if (v != (uint32_t)v)\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an int64_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atoi64(const char *str, int64_t *val, int base)\n+{\n+    char *endptr;\n+    long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoll(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to an uint64_t with the given \\a base and store the\n+ * result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atou64(const char *str, uint64_t *val, int base)\n+{\n+    char *endptr;\n+    unsigned long long v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = strtoull(str, &endptr, base);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to a boolean. Allowed boolean values are \"true\" and a\n+ * literal \"1\", anything else is false.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atob(const char *str)\n+{\n+    return spa_streq(str, \"true\") || spa_streq(str, \"1\");\n+}\n+\n+\/**\n+ * \"Safe\" version of vsnprintf. Exactly the same as vsnprintf but the\n+ * returned value is clipped to `size - 1` and a negative or zero size\n+ * will abort() the program.\n+ *\n+ * \\return The number of bytes printed, capped to `size-1`, or a negative\n+ * number on error.\n+ *\/\n+SPA_PRINTF_FUNC(3, 0)\n+static inline int spa_vscnprintf(char *buffer, size_t size, const char *format, va_list args)\n+{\n+    int r;\n+\n+    spa_assert_se((ssize_t)size > 0);\n+\n+    r = vsnprintf(buffer, size, format, args);\n+    if (SPA_UNLIKELY(r < 0))\n+        buffer[0] = '\\0';\n+    if (SPA_LIKELY(r < (ssize_t)size))\n+        return r;\n+    return size - 1;\n+}\n+\n+\/**\n+ * \"Safe\" version of snprintf. Exactly the same as snprintf but the\n+ * returned value is clipped to `size - 1` and a negative or zero size\n+ * will abort() the program.\n+ *\n+ * \\return The number of bytes printed, capped to `size-1`, or a negative\n+ * number on error.\n+ *\/\n+SPA_PRINTF_FUNC(3, 4)\n+static inline int spa_scnprintf(char *buffer, size_t size, const char *format, ...)\n+{\n+    int r;\n+    va_list args;\n+\n+    va_start(args, format);\n+    r = spa_vscnprintf(buffer, size, format, args);\n+    va_end(args);\n+\n+    return r;\n+}\n+\n+\/**\n+ * Convert \\a str to a float in the C locale.\n+ *\n+ * If \\a endptr is not NULL, a pointer to the character after the last character\n+ * used in the conversion is stored in the location referenced by endptr.\n+ *\n+ * \\return the result float.\n+ *\/\n+static inline float spa_strtof(const char *str, char **endptr)\n+{\n+#ifndef __LOCALE_C_ONLY\n+    static locale_t locale = NULL;\n+    locale_t prev;\n+#endif\n+    float v;\n+#ifndef __LOCALE_C_ONLY\n+    if (SPA_UNLIKELY(locale == NULL))\n+        locale = newlocale(LC_ALL_MASK, \"C\", NULL);\n+    prev = uselocale(locale);\n+#endif\n+    v = strtof(str, endptr);\n+#ifndef __LOCALE_C_ONLY\n+    uselocale(prev);\n+#endif\n+    return v;\n+}\n+\n+\/**\n+ * Convert \\a str to a float and store the result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atof(const char *str, float *val)\n+{\n+    char *endptr;\n+    float v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+    errno = 0;\n+    v = spa_strtof(str, &endptr);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+\/**\n+ * Convert \\a str to a double in the C locale.\n+ *\n+ * If \\a endptr is not NULL, a pointer to the character after the last character\n+ * used in the conversion is stored in the location referenced by endptr.\n+ *\n+ * \\return the result float.\n+ *\/\n+static inline double spa_strtod(const char *str, char **endptr)\n+{\n+#ifndef __LOCALE_C_ONLY\n+    static locale_t locale = NULL;\n+    locale_t prev;\n+#endif\n+    double v;\n+#ifndef __LOCALE_C_ONLY\n+    if (SPA_UNLIKELY(locale == NULL))\n+        locale = newlocale(LC_ALL_MASK, \"C\", NULL);\n+    prev = uselocale(locale);\n+#endif\n+    v = strtod(str, endptr);\n+#ifndef __LOCALE_C_ONLY\n+    uselocale(prev);\n+#endif\n+    return v;\n+}\n+\n+\/**\n+ * Convert \\a str to a double and store the result in \\a val.\n+ *\n+ * On failure, the value of \\a val is unmodified.\n+ *\n+ * \\return true on success, false otherwise\n+ *\/\n+static inline bool spa_atod(const char *str, double *val)\n+{\n+    char *endptr;\n+    double v;\n+\n+    if (!str || *str =='\\0')\n+        return false;\n+\n+    errno = 0;\n+    v = spa_strtod(str, &endptr);\n+    if (errno != 0 || *endptr != '\\0')\n+        return false;\n+\n+    *val = v;\n+    return true;\n+}\n+\n+static inline char *spa_dtoa(char *str, size_t size, double val)\n+{\n+    int i, l;\n+    l = spa_scnprintf(str, size, \"%f\", val);\n+    for (i = 0; i < l; i++)\n+        if (str[i] == ',')\n+            str[i] = '.';\n+    return str;\n+}\n+\n+struct spa_strbuf {\n+    char *buffer;\n+    size_t maxsize;\n+    size_t pos;\n+};\n+\n+static inline void spa_strbuf_init(struct spa_strbuf *buf, char *buffer, size_t maxsize)\n+{\n+    buf->buffer = buffer;\n+    buf->maxsize = maxsize;\n+    buf->pos = 0;\n+}\n+\n+SPA_PRINTF_FUNC(2, 3)\n+static inline int spa_strbuf_append(struct spa_strbuf *buf, const char *fmt, ...)\n+{\n+    size_t remain = buf->maxsize - buf->pos;\n+    ssize_t written;\n+    va_list args;\n+    va_start(args, fmt);\n+    written = vsnprintf(&buf->buffer[buf->pos], remain, fmt, args);\n+    va_end(args);\n+    if (written > 0)\n+        buf->pos += SPA_MIN(remain, (size_t)written);\n+    return written;\n+}\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_UTILS_STRING_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/string.h","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_TYPE_INFO_H\n+#define SPA_TYPE_INFO_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/**\n+ * \\addtogroup spa_types\n+ * \\{\n+ *\/\n+\n+#ifndef SPA_TYPE_ROOT\n+#define SPA_TYPE_ROOT    spa_types\n+#endif\n+\n+static inline bool spa_type_is_a(const char *type, const char *parent)\n+{\n+    return type != NULL && parent != NULL && strncmp(type, parent, strlen(parent)) == 0;\n+}\n+\n+#include <spa\/utils\/type.h>\n+#include <spa\/utils\/enum-types.h>\n+\n+#include <spa\/monitor\/type-info.h>\n+#include <spa\/node\/type-info.h>\n+#include <spa\/param\/type-info.h>\n+#include <spa\/control\/type-info.h>\n+\n+static const struct spa_type_info spa_types[] = {\n+        \/* Basic types *\/\n+    { SPA_TYPE_START, SPA_TYPE_START, SPA_TYPE_INFO_BASE, NULL },\n+    { SPA_TYPE_None, SPA_TYPE_None, SPA_TYPE_INFO_BASE \"None\", NULL },\n+    { SPA_TYPE_Bool, SPA_TYPE_Bool, SPA_TYPE_INFO_BASE \"Bool\", NULL },\n+    { SPA_TYPE_Id, SPA_TYPE_Int, SPA_TYPE_INFO_BASE \"Id\", NULL },\n+    { SPA_TYPE_Int, SPA_TYPE_Int, SPA_TYPE_INFO_BASE \"Int\", NULL },\n+    { SPA_TYPE_Long, SPA_TYPE_Long, SPA_TYPE_INFO_BASE \"Long\", NULL },\n+    { SPA_TYPE_Float, SPA_TYPE_Float, SPA_TYPE_INFO_BASE \"Float\", NULL },\n+    { SPA_TYPE_Double, SPA_TYPE_Double, SPA_TYPE_INFO_BASE \"Double\", NULL },\n+    { SPA_TYPE_String, SPA_TYPE_String, SPA_TYPE_INFO_BASE \"String\", NULL },\n+    { SPA_TYPE_Bytes, SPA_TYPE_Bytes, SPA_TYPE_INFO_BASE \"Bytes\", NULL },\n+    { SPA_TYPE_Rectangle, SPA_TYPE_Rectangle, SPA_TYPE_INFO_BASE \"Rectangle\", NULL },\n+    { SPA_TYPE_Fraction, SPA_TYPE_Fraction, SPA_TYPE_INFO_BASE \"Fraction\", NULL },\n+    { SPA_TYPE_Bitmap, SPA_TYPE_Bitmap, SPA_TYPE_INFO_BASE \"Bitmap\", NULL },\n+    { SPA_TYPE_Array, SPA_TYPE_Array, SPA_TYPE_INFO_BASE \"Array\", NULL },\n+    { SPA_TYPE_Pod, SPA_TYPE_Pod, SPA_TYPE_INFO_Pod, NULL },\n+    { SPA_TYPE_Struct, SPA_TYPE_Pod, SPA_TYPE_INFO_Struct, NULL },\n+    { SPA_TYPE_Object, SPA_TYPE_Pod, SPA_TYPE_INFO_Object, NULL },\n+    { SPA_TYPE_Sequence, SPA_TYPE_Pod, SPA_TYPE_INFO_POD_BASE \"Sequence\", NULL },\n+    { SPA_TYPE_Pointer, SPA_TYPE_Pointer, SPA_TYPE_INFO_Pointer, NULL },\n+    { SPA_TYPE_Fd, SPA_TYPE_Fd, SPA_TYPE_INFO_BASE \"Fd\", NULL },\n+    { SPA_TYPE_Choice, SPA_TYPE_Pod, SPA_TYPE_INFO_POD_BASE \"Choice\", NULL },\n+\n+    { SPA_TYPE_POINTER_START, SPA_TYPE_Pointer, SPA_TYPE_INFO_Pointer, NULL },\n+    { SPA_TYPE_POINTER_Buffer, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Buffer\", NULL },\n+    { SPA_TYPE_POINTER_Meta, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Meta\", NULL },\n+    { SPA_TYPE_POINTER_Dict, SPA_TYPE_Pointer, SPA_TYPE_INFO_POINTER_BASE \"Dict\", NULL },\n+\n+    { SPA_TYPE_EVENT_START, SPA_TYPE_Object, SPA_TYPE_INFO_Event, NULL },\n+    { SPA_TYPE_EVENT_Device, SPA_TYPE_Object, SPA_TYPE_INFO_EVENT_BASE \"Device\", spa_type_device_event },\n+    { SPA_TYPE_EVENT_Node, SPA_TYPE_Object, SPA_TYPE_INFO_EVENT_BASE \"Node\", spa_type_node_event },\n+\n+    { SPA_TYPE_COMMAND_START, SPA_TYPE_Object, SPA_TYPE_INFO_Command, NULL },\n+    { SPA_TYPE_COMMAND_Device, SPA_TYPE_Object, SPA_TYPE_INFO_COMMAND_BASE \"Device\", NULL },\n+    { SPA_TYPE_COMMAND_Node, SPA_TYPE_Object, SPA_TYPE_INFO_COMMAND_BASE \"Node\", spa_type_node_command },\n+\n+    { SPA_TYPE_OBJECT_START, SPA_TYPE_Object, SPA_TYPE_INFO_Object, NULL },\n+    { SPA_TYPE_OBJECT_PropInfo, SPA_TYPE_Object, SPA_TYPE_INFO_PropInfo, spa_type_prop_info, },\n+    { SPA_TYPE_OBJECT_Props, SPA_TYPE_Object, SPA_TYPE_INFO_Props, spa_type_props },\n+    { SPA_TYPE_OBJECT_Format, SPA_TYPE_Object, SPA_TYPE_INFO_Format, spa_type_format },\n+    { SPA_TYPE_OBJECT_ParamBuffers, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Buffers, spa_type_param_buffers, },\n+    { SPA_TYPE_OBJECT_ParamMeta, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Meta, spa_type_param_meta },\n+    { SPA_TYPE_OBJECT_ParamIO, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_IO, spa_type_param_io },\n+    { SPA_TYPE_OBJECT_ParamProfile, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Profile, spa_type_param_profile },\n+    { SPA_TYPE_OBJECT_ParamPortConfig, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_PortConfig, spa_type_param_port_config },\n+    { SPA_TYPE_OBJECT_ParamRoute, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Route, spa_type_param_route },\n+    { SPA_TYPE_OBJECT_Profiler, SPA_TYPE_Object, SPA_TYPE_INFO_Profiler, spa_type_profiler },\n+    { SPA_TYPE_OBJECT_ParamLatency, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_Latency, spa_type_param_latency },\n+    { SPA_TYPE_OBJECT_ParamProcessLatency, SPA_TYPE_Object, SPA_TYPE_INFO_PARAM_ProcessLatency, spa_type_param_process_latency },\n+\n+    { 0, 0, NULL, NULL }\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_INFO_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/type-info.h","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/* Simple Plugin API *\/\n+\/* SPDX-FileCopyrightText: Copyright © 2018 Wim Taymans *\/\n+\/* SPDX-License-Identifier: MIT *\/\n+\n+#ifndef SPA_TYPE_H\n+#define SPA_TYPE_H\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <spa\/utils\/defs.h>\n+\n+\/** \\defgroup spa_types Types\n+ * Data type information enumerations\n+ *\/\n+\n+\/**\n+ * \\addtogroup spa_types\n+ * \\{\n+ *\/\n+\n+enum {\n+    \/* Basic types *\/\n+    SPA_TYPE_START = 0x00000,\n+    SPA_TYPE_None,\n+    SPA_TYPE_Bool,\n+    SPA_TYPE_Id,\n+    SPA_TYPE_Int,\n+    SPA_TYPE_Long,\n+    SPA_TYPE_Float,\n+    SPA_TYPE_Double,\n+    SPA_TYPE_String,\n+    SPA_TYPE_Bytes,\n+    SPA_TYPE_Rectangle,\n+    SPA_TYPE_Fraction,\n+    SPA_TYPE_Bitmap,\n+    SPA_TYPE_Array,\n+    SPA_TYPE_Struct,\n+    SPA_TYPE_Object,\n+    SPA_TYPE_Sequence,\n+    SPA_TYPE_Pointer,\n+    SPA_TYPE_Fd,\n+    SPA_TYPE_Choice,\n+    SPA_TYPE_Pod,\n+    _SPA_TYPE_LAST,                \/**< not part of ABI *\/\n+\n+    \/* Pointers *\/\n+    SPA_TYPE_POINTER_START = 0x10000,\n+    SPA_TYPE_POINTER_Buffer,\n+    SPA_TYPE_POINTER_Meta,\n+    SPA_TYPE_POINTER_Dict,\n+    _SPA_TYPE_POINTER_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Events *\/\n+    SPA_TYPE_EVENT_START = 0x20000,\n+    SPA_TYPE_EVENT_Device,\n+    SPA_TYPE_EVENT_Node,\n+    _SPA_TYPE_EVENT_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Commands *\/\n+    SPA_TYPE_COMMAND_START = 0x30000,\n+    SPA_TYPE_COMMAND_Device,\n+    SPA_TYPE_COMMAND_Node,\n+    _SPA_TYPE_COMMAND_LAST,            \/**< not part of ABI *\/\n+\n+    \/* Objects *\/\n+    SPA_TYPE_OBJECT_START = 0x40000,\n+    SPA_TYPE_OBJECT_PropInfo,\n+    SPA_TYPE_OBJECT_Props,\n+    SPA_TYPE_OBJECT_Format,\n+    SPA_TYPE_OBJECT_ParamBuffers,\n+    SPA_TYPE_OBJECT_ParamMeta,\n+    SPA_TYPE_OBJECT_ParamIO,\n+    SPA_TYPE_OBJECT_ParamProfile,\n+    SPA_TYPE_OBJECT_ParamPortConfig,\n+    SPA_TYPE_OBJECT_ParamRoute,\n+    SPA_TYPE_OBJECT_Profiler,\n+    SPA_TYPE_OBJECT_ParamLatency,\n+    SPA_TYPE_OBJECT_ParamProcessLatency,\n+    _SPA_TYPE_OBJECT_LAST,            \/**< not part of ABI *\/\n+\n+    \/* vendor extensions *\/\n+    SPA_TYPE_VENDOR_PipeWire    = 0x02000000,\n+\n+    SPA_TYPE_VENDOR_Other        = 0x7f000000,\n+};\n+\n+#define SPA_TYPE_INFO_BASE            \"Spa:\"\n+\n+#define SPA_TYPE_INFO_Flags            SPA_TYPE_INFO_BASE \"Flags\"\n+#define SPA_TYPE_INFO_FLAGS_BASE        SPA_TYPE_INFO_Flags \":\"\n+\n+#define SPA_TYPE_INFO_Enum            SPA_TYPE_INFO_BASE \"Enum\"\n+#define SPA_TYPE_INFO_ENUM_BASE            SPA_TYPE_INFO_Enum \":\"\n+\n+#define SPA_TYPE_INFO_Pod            SPA_TYPE_INFO_BASE \"Pod\"\n+#define SPA_TYPE_INFO_POD_BASE            SPA_TYPE_INFO_Pod \":\"\n+\n+#define SPA_TYPE_INFO_Struct            SPA_TYPE_INFO_POD_BASE \"Struct\"\n+#define SPA_TYPE_INFO_STRUCT_BASE        SPA_TYPE_INFO_Struct \":\"\n+\n+#define SPA_TYPE_INFO_Object            SPA_TYPE_INFO_POD_BASE \"Object\"\n+#define SPA_TYPE_INFO_OBJECT_BASE        SPA_TYPE_INFO_Object \":\"\n+\n+#define SPA_TYPE_INFO_Pointer            SPA_TYPE_INFO_BASE \"Pointer\"\n+#define SPA_TYPE_INFO_POINTER_BASE        SPA_TYPE_INFO_Pointer \":\"\n+\n+#define SPA_TYPE_INFO_Interface            SPA_TYPE_INFO_POINTER_BASE \"Interface\"\n+#define SPA_TYPE_INFO_INTERFACE_BASE        SPA_TYPE_INFO_Interface \":\"\n+\n+#define SPA_TYPE_INFO_Event            SPA_TYPE_INFO_OBJECT_BASE \"Event\"\n+#define SPA_TYPE_INFO_EVENT_BASE        SPA_TYPE_INFO_Event \":\"\n+\n+#define SPA_TYPE_INFO_Command            SPA_TYPE_INFO_OBJECT_BASE \"Command\"\n+#define SPA_TYPE_INFO_COMMAND_BASE        SPA_TYPE_INFO_Command \":\"\n+\n+struct spa_type_info {\n+    uint32_t type;\n+    uint32_t parent;\n+    const char *name;\n+    const struct spa_type_info *values;\n+};\n+\n+\/**\n+ * \\}\n+ *\/\n+\n+#ifdef __cplusplus\n+}  \/* extern \"C\" *\/\n+#endif\n+\n+#endif \/* SPA_TYPE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libpipewire\/include\/spa\/utils\/type.h","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}