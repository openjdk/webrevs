{"files":[{"patch":"@@ -794,0 +794,4 @@\n+                                                                            \\\n+  product(bool, UseStoreStoreForCtor, true, DIAGNOSTIC,                     \\\n+          \"Use StoreStore barrier instead of Release barrier at the end \"   \\\n+          \"of constructors\")                                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1586,1 +1586,0 @@\n-  _is_allocation_MemBar_redundant = false;\n@@ -1602,16 +1601,0 @@\n-void AllocateNode::compute_MemBar_redundancy(ciMethod* initializer)\n-{\n-  assert(initializer != nullptr &&\n-         initializer->is_initializer() &&\n-         !initializer->is_static(),\n-             \"unexpected initializer method\");\n-  BCEscapeAnalyzer* analyzer = initializer->get_bcea();\n-  if (analyzer == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ Allocation node is first parameter in its initializer\n-  if (analyzer->is_arg_stack(0) || analyzer->is_arg_local(0)) {\n-    _is_allocation_MemBar_redundant = true;\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -987,2 +987,0 @@\n-  \/\/ True when MemBar for new is redundant with MemBar at initialzer exit\n-  bool _is_allocation_MemBar_redundant;\n@@ -1050,7 +1048,0 @@\n-  \/\/ If object doesn't escape in <.init> method and there is memory barrier\n-  \/\/ inserted at exit of its <.init>, memory barrier for new is not necessary.\n-  \/\/ Inovke this method when MemBar at exit of initializer and post-dominate\n-  \/\/ allocation node.\n-  void compute_MemBar_redundancy(ciMethod* initializer);\n-  bool is_allocation_MemBar_redundant() { return _is_allocation_MemBar_redundant; }\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -202,1 +202,3 @@\n-        storestore_worklist.append(n->as_MemBarStoreStore());\n+        if (!UseStoreStoreForCtor || n->req() > MemBarNode::Precedent) {\n+          storestore_worklist.append(n->as_MemBarStoreStore());\n+        }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -636,1 +636,4 @@\n-      } else if (reduce_merge_precheck && (use->is_Phi() || use->is_EncodeP() || use->Opcode() == Op_MemBarRelease)) {\n+      } else if (reduce_merge_precheck &&\n+                 (use->is_Phi() || use->is_EncodeP() ||\n+                  use->Opcode() == Op_MemBarRelease ||\n+                  (UseStoreStoreForCtor && use->Opcode() == Op_MemBarStoreStore))) {\n@@ -1604,1 +1607,0 @@\n-    !alloc->is_allocation_MemBar_redundant() &&\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3439,1 +3439,1 @@\n-    } else if (opc == Op_MemBarRelease) {\n+    } else if (opc == Op_MemBarRelease || (UseStoreStoreForCtor && opc == Op_MemBarStoreStore)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,2 +357,0 @@\n-  bool          _wrote_final;   \/\/ Did we write a final field?\n-  bool          _wrote_volatile;     \/\/ Did we write a volatile field?\n@@ -360,2 +358,0 @@\n-  bool          _wrote_fields;       \/\/ Did we write any field?\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n@@ -398,4 +394,0 @@\n-  bool          wrote_final() const   { return _wrote_final; }\n-  void      set_wrote_final(bool z)   { _wrote_final = z; }\n-  bool          wrote_volatile() const { return _wrote_volatile; }\n-  void      set_wrote_volatile(bool z) { _wrote_volatile = z; }\n@@ -404,7 +396,0 @@\n-  bool         wrote_fields() const   { return _wrote_fields; }\n-  void     set_wrote_fields(bool z)   { _wrote_fields = z; }\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n-  }\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -411,2 +411,0 @@\n-  _wrote_final = false;\n-  _wrote_volatile = false;\n@@ -414,2 +412,0 @@\n-  _wrote_fields = false;\n-  _alloc_with_final = nullptr;\n@@ -987,47 +983,0 @@\n-  \/\/ Figure out if we need to emit the trailing barrier. The barrier is only\n-  \/\/ needed in the constructors, and only in three cases:\n-  \/\/\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n-  \/\/    publishes the reference to the newly constructed object. Rather\n-  \/\/    than wait for the publication, we simply block the writes here.\n-  \/\/    Rather than put a barrier on only those writes which are required\n-  \/\/    to complete, we force all writes to complete.\n-  \/\/\n-  \/\/ 2. Experimental VM option is used to force the barrier if any field\n-  \/\/    was written out in the constructor.\n-  \/\/\n-  \/\/ 3. On processors which are not CPU_MULTI_COPY_ATOMIC (e.g. PPC64),\n-  \/\/    support_IRIW_for_not_multiple_copy_atomic_cpu selects that\n-  \/\/    MemBarVolatile is used before volatile load instead of after volatile\n-  \/\/    store, so there's no barrier after the store.\n-  \/\/    We want to guarantee the same behavior as on platforms with total store\n-  \/\/    order, although this is not required by the Java memory model.\n-  \/\/    In this case, we want to enforce visibility of volatile field\n-  \/\/    initializations which are performed in constructors.\n-  \/\/    So as with finals, we add a barrier here.\n-  \/\/\n-  \/\/ \"All bets are off\" unless the first publication occurs after a\n-  \/\/ normal return from the constructor.  We do not attempt to detect\n-  \/\/ such unusual early publications.  But no barrier is needed on\n-  \/\/ exceptional returns, since they cannot publish normally.\n-  \/\/\n-  if (method()->is_initializer() &&\n-       (wrote_final() ||\n-         (AlwaysSafeConstructors && wrote_fields()) ||\n-         (support_IRIW_for_not_multiple_copy_atomic_cpu && wrote_volatile()))) {\n-    _exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());\n-\n-    \/\/ If Memory barrier is created for final fields write\n-    \/\/ and allocation node does not escape the initialize method,\n-    \/\/ then barrier introduced by allocation node can be removed.\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n-      alloc->compute_MemBar_redundancy(method());\n-    }\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -229,26 +229,3 @@\n-  if (is_field) {\n-    \/\/ Remember we wrote a volatile field.\n-    \/\/ For not multiple copy atomic cpu (ppc64) a barrier should be issued\n-    \/\/ in constructors which have such stores. See do_exits() in parse1.cpp.\n-    if (is_vol) {\n-      set_wrote_volatile(true);\n-    }\n-    set_wrote_fields(true);\n-\n-    \/\/ If the field is final, the rules of Java say we are in <init> or <clinit>.\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n-    \/\/ can insert a memory barrier later on to keep the writes from floating\n-    \/\/ out of the constructor.\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n-      if (AllocateNode::Ideal_allocation(obj) != nullptr) {\n-        \/\/ Preserve allocation ptr to create precedent edge to it in membar\n-        \/\/ generated on exit from constructor.\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n-      }\n-    }\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n+  if (is_field && field->is_stable()) {\n+    \/\/ Insert a release barrier after methods that can write a @Stable field.\n+    set_wrote_stable(true);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2013,1 +2013,1 @@\n-    kit.insert_mem_bar(Op_MemBarRelease, result);\n+    kit.insert_mem_bar(UseStoreStoreForCtor ? Op_MemBarStoreStore : Op_MemBarRelease, result);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,551 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8300148\n+ * @summary Test barriers emitted in constructors\n+ * @library \/test\/lib \/\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @run main compiler.c2.irTests.ConstructorBarriers\n+ *\/\n+public class ConstructorBarriers {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainExtendsPlain extends PlainPlain {\n+        long f3;\n+        public PlainExtendsPlain(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class PlainExtendsFinal extends FinalFinal {\n+        long f3;\n+        public PlainExtendsFinal(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class PlainExtendsVolatile extends VolatileVolatile {\n+        long f3;\n+        public PlainExtendsVolatile(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalExtendsPlain extends PlainPlain {\n+        final long f3;\n+        public FinalExtendsPlain(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class FinalExtendsFinal extends FinalFinal {\n+        final long f3;\n+        public FinalExtendsFinal(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class FinalExtendsVolatile extends VolatileVolatile {\n+        final long f3;\n+        public FinalExtendsVolatile(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileExtendsPlain extends PlainPlain {\n+        volatile long f3;\n+        public VolatileExtendsPlain(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class VolatileExtendsFinal extends FinalFinal {\n+        volatile long f3;\n+        public VolatileExtendsFinal(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    private static class VolatileExtendsVolatile extends VolatileVolatile {\n+        volatile long f3;\n+        public VolatileExtendsVolatile(long i) {\n+            super(i);\n+            f3 = i;\n+        }\n+    }\n+\n+    long l = 42;\n+\n+    @DontInline\n+    public void consume(Object o) {}\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainExtendsPlain() {\n+        PlainExtendsPlain c = new PlainExtendsPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainExtendsFinal() {\n+        PlainExtendsFinal c = new PlainExtendsFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"2\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"2\"})\n+    public long escaping_plainExtendsVolatile() {\n+        PlainExtendsVolatile c = new PlainExtendsVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalExtendsPlain() {\n+        FinalExtendsPlain c = new FinalExtendsPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    public long escaping_finalExtendsFinal() {\n+        FinalExtendsFinal c = new FinalExtendsFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"2\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"2\"})\n+    public long escaping_finalExtendsVolatile() {\n+        FinalExtendsVolatile c = new FinalExtendsVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"2\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"2\"})\n+    public long escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatileExtendsPlain() {\n+        VolatileExtendsPlain c = new VolatileExtendsPlain(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatileExtendsFinal() {\n+        VolatileExtendsFinal c = new VolatileExtendsFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"3\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"3\"})\n+    public long escaping_volatileExtendsVolatile() {\n+        VolatileExtendsVolatile c = new VolatileExtendsVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEMBAR_RELEASE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"1\"})\n+    @IR(counts = {IRNode.MEMBAR_VOLATILE, \"1\"})\n+    public long escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainExtendsPlain() {\n+        PlainExtendsPlain c = new PlainExtendsPlain(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainExtendsFinal() {\n+        PlainExtendsFinal c = new PlainExtendsFinal(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"2\"})\n+    public long non_escaping_plainExtendsVolatile() {\n+        PlainExtendsVolatile c = new PlainExtendsVolatile(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalExtendsPlain() {\n+        FinalExtendsPlain c = new FinalExtendsPlain(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR)\n+    public long non_escaping_finalExtendsFinal() {\n+        FinalExtendsFinal c = new FinalExtendsFinal(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"2\"})\n+    public long non_escaping_finalExtendsVolatile() {\n+        FinalExtendsVolatile c = new FinalExtendsVolatile(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"2\"})\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatileExtendsPlain() {\n+        VolatileExtendsPlain c = new VolatileExtendsPlain(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatileExtendsFinal() {\n+        VolatileExtendsFinal c = new VolatileExtendsFinal(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"3\"})\n+    public long non_escaping_volatileExtendsVolatile() {\n+        VolatileExtendsVolatile c = new VolatileExtendsVolatile(l);\n+        return c.f1 + c.f2 + c.f3;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_STORESTORE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_ACQUIRE, \"1\"})\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Setup\n+    Object[] stringBuilderSetup() {\n+        return new Object[] { \"foo\", \"bar\", \"baz\" };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"stringBuilderSetup\")\n+    @IR(failOn = IRNode.MEMBAR_RELEASE)\n+    @IR(failOn = IRNode.MEMBAR_VOLATILE)\n+    @IR(counts = {IRNode.MEMBAR_STORESTORE, \"3\"})\n+    public String stringBuilder(String s1, String s2, String s3) {\n+        return new StringBuilder().append(s1).append(s2).append(s3).toString();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConstructorBarriers.java","additions":551,"deletions":0,"binary":false,"changes":551,"status":"added"},{"patch":"@@ -880,0 +880,10 @@\n+    public static final String MEMBAR_ACQUIRE = PREFIX + \"MEMBAR_ACQUIRE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_ACQUIRE, \"MemBarAcquire\");\n+    }\n+\n+    public static final String MEMBAR_RELEASE = PREFIX + \"MEMBAR_RELEASE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_RELEASE, \"MemBarRelease\");\n+    }\n+\n@@ -885,0 +895,5 @@\n+    public static final String MEMBAR_VOLATILE = PREFIX + \"MEMBAR_VOLATILE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MEMBAR_VOLATILE, \"MemBarVolatile\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xms512m\", \"-Xmx512m\", \"-XX:+AlwaysPreTouch\", \"-XX:+UseParallelGC\"})\n+public class ConstructorBarriers {\n+\n+    \/\/ Checks the barrier coalescing\/optimization around field initializations.\n+    \/\/ Uses long fields to avoid store merging.\n+\n+    public static class PlainPlain {\n+        long f1;\n+        long f2;\n+        public PlainPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalPlain {\n+        final long f1;\n+        long f2;\n+        public FinalPlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainFinal {\n+        long f1;\n+        final long f2;\n+        public PlainFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalFinal {\n+        final long f1;\n+        final long f2;\n+        public FinalFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class PlainVolatile {\n+        long f1;\n+        volatile long f2;\n+        public PlainVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatilePlain {\n+        volatile long f1;\n+        long f2;\n+        public VolatilePlain(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class FinalVolatile {\n+        final long f1;\n+        volatile long f2;\n+        public FinalVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileFinal {\n+        volatile long f1;\n+        final long f2;\n+        public VolatileFinal(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    private static class VolatileVolatile {\n+        volatile long f1;\n+        volatile long f2;\n+        public VolatileVolatile(long i) {\n+            f1 = i;\n+            f2 = i;\n+        }\n+    }\n+\n+    long l = 42;\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainPlain(Blackhole bh) {\n+        PlainPlain c = new PlainPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainFinal(Blackhole bh) {\n+        PlainFinal c = new PlainFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalPlain(Blackhole bh) {\n+        FinalPlain c = new FinalPlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalFinal(Blackhole bh) {\n+        FinalFinal c = new FinalFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_plainVolatile(Blackhole bh) {\n+        PlainVolatile c = new PlainVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatilePlain(Blackhole bh) {\n+        VolatilePlain c = new VolatilePlain(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileVolatile(Blackhole bh) {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_finalVolatile(Blackhole bh) {\n+        FinalVolatile c = new FinalVolatile(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long escaping_volatileFinal(Blackhole bh) {\n+        VolatileFinal c = new VolatileFinal(l);\n+        bh.consume(c);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainPlain() {\n+        PlainPlain c = new PlainPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainFinal() {\n+        PlainFinal c = new PlainFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalPlain() {\n+        FinalPlain c = new FinalPlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalFinal() {\n+        FinalFinal c = new FinalFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_plainVolatile() {\n+        PlainVolatile c = new PlainVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatilePlain() {\n+        VolatilePlain c = new VolatilePlain(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileVolatile() {\n+        VolatileVolatile c = new VolatileVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_finalVolatile() {\n+        FinalVolatile c = new FinalVolatile(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long non_escaping_volatileFinal() {\n+        VolatileFinal c = new VolatileFinal(l);\n+        return c.f1 + c.f2;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ConstructorBarriers.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"}]}