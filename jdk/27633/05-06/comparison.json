{"files":[{"patch":"@@ -24,0 +24,1 @@\n+import java.io.IOException;\n@@ -25,1 +26,0 @@\n-import java.lang.ref.Reference;\n@@ -32,0 +32,1 @@\n+import java.util.function.Consumer;\n@@ -36,0 +37,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -53,0 +56,5 @@\n+    \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n+    \/\/ Here we keep reference to the URLConnection for the duration of each test method.\n+    \/\/ This ensures that any FileInputStream this URLConnection may be retaining, won't be GCed\n+    \/\/ until after the test method has checked for file descriptor leaks.\n+    private URLConnection conn;\n@@ -59,0 +67,4 @@\n+        this.conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(this.conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n@@ -63,0 +75,1 @@\n+        this.conn = null;\n@@ -66,84 +79,10 @@\n-\n-    @Test\n-    void testGetContentEncoding() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getContentEncoding();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n-    }\n-\n-    @Test\n-    void testGetContentLength() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getContentLength();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n-    }\n-\n-    @Test\n-    void testGetContentLengthLong() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getContentLengthLong();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n-    }\n-\n-    @Test\n-    void testGetContentType() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getContentType();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n-    }\n-\n-    @Test\n-    void testGetDate() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getDate();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n+    static List<Consumer<URLConnection>> urlConnOperations() {\n+        return List.of(\n+                URLConnection::getContentEncoding,\n+                URLConnection::getContentLength,\n+                URLConnection::getContentLengthLong,\n+                URLConnection::getContentType,\n+                URLConnection::getDate,\n+                URLConnection::getExpiration,\n+                URLConnection::getLastModified\n+        );\n@@ -152,7 +91,4 @@\n-    @Test\n-    void testGetExpiration() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getExpiration();\n+    @MethodSource(\"urlConnOperations\")\n+    @ParameterizedTest\n+    void testURLConnOps(final Consumer<URLConnection> connConsumer) throws IOException {\n+        connConsumer.accept(this.conn);\n@@ -162,5 +98,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -171,5 +102,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getHeaderField(0);\n+        final var _ = this.conn.getHeaderField(0);\n@@ -179,5 +106,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -188,5 +110,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final String val = conn.getHeaderField(\"foo\");\n+        final String val = this.conn.getHeaderField(\"foo\");\n@@ -197,5 +115,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -206,5 +119,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getHeaderFieldDate(\"bar\", 42);\n+        final var _ = this.conn.getHeaderFieldDate(\"bar\", 42);\n@@ -214,5 +123,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -223,5 +127,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final int val = conn.getHeaderFieldInt(\"hello\", 42);\n+        final int val = this.conn.getHeaderFieldInt(\"hello\", 42);\n@@ -232,5 +132,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -241,5 +136,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final String val = conn.getHeaderFieldKey(42);\n+        final String val = this.conn.getHeaderFieldKey(42);\n@@ -250,5 +141,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -259,5 +145,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final long val = conn.getHeaderFieldLong(\"foo\", 42);\n+        final long val = this.conn.getHeaderFieldLong(\"foo\", 42);\n@@ -268,5 +150,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -277,5 +154,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final Map<String, List<String>> headers = conn.getHeaderFields();\n+        final Map<String, List<String>> headers = this.conn.getHeaderFields();\n@@ -286,22 +159,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n-    }\n-\n-    @Test\n-    void testGetLastModified() throws Exception {\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        final var _ = conn.getLastModified();\n-        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n-        \/\/ of this test file.\n-        Files.delete(this.testFile); \/\/ must not fail\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -312,5 +163,1 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n-        try (final InputStream is = conn.getInputStream()) {\n+        try (final InputStream is = this.conn.getInputStream()) {\n@@ -322,5 +169,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n@@ -331,4 +173,0 @@\n-        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n-        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n-        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n-                \"unexpected URLConnection type\");\n@@ -336,1 +174,1 @@\n-        assertThrows(UnknownServiceException.class, conn::getOutputStream);\n+        assertThrows(UnknownServiceException.class, this.conn::getOutputStream);\n@@ -340,5 +178,0 @@\n-        \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n-        \/\/ Here we add a reachability fence to URLConnection. This ensures that any FileInputStream\n-        \/\/ it may be retaining, won't be GCed until after we have checked for file descriptor\n-        \/\/ leaks on the previous line.\n-        Reference.reachabilityFence(conn);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/FileURLConnStreamLeakTest.java","additions":37,"deletions":204,"binary":false,"changes":241,"status":"modified"}]}