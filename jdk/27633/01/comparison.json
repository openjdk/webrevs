{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-    Map<String, List<String>> headerFields;\n+    private Map<String, List<String>> headerFields;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/URLConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.FileNameMap;\n@@ -30,3 +39,0 @@\n-import java.net.FileNameMap;\n-import java.io.*;\n-import java.text.Collator;\n@@ -34,2 +40,1 @@\n-import sun.net.www.*;\n-import java.util.*;\n+import java.text.Collator;\n@@ -37,0 +42,11 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import sun.net.www.MessageHeader;\n+import sun.net.www.ParseUtil;\n+import sun.net.www.URLConnection;\n@@ -64,0 +80,1 @@\n+    private Map<String, List<String>> headerFields;\n@@ -70,1 +87,22 @@\n-    \/*\n+    \/**\n+     * If already connected, then this method is a no-op.\n+     * If not already connected, then this method does\n+     * readability checks for the File.\n+     * <p>\n+     * If the File is a directory then the readability check\n+     * is done by verifying that File.list() does not return\n+     * null. On the other hand, if the File is not a directory,\n+     * then this method constructs a temporary FileInputStream\n+     * for the File and lets the FileInputStream's constructor\n+     * implementation do the necessary readability checks.\n+     * That temporary FileInputStream is closed before returning\n+     * from this method.\n+     * <p>\n+     * In either case, if the readability checks fail, then\n+     * an IOException is thrown from this method and the\n+     * FileURLConnection stays unconnected.\n+     * <p>\n+     * A normal return from this method implies that the\n+     * FileURLConnection is connected and the readability\n+     * checks have passed for the File.\n+     * <p>\n@@ -76,0 +114,1 @@\n+    @Override\n@@ -78,1 +117,0 @@\n-\n@@ -80,0 +118,1 @@\n+            \/\/ verify readability of the directory or the regular file\n@@ -82,1 +121,1 @@\n-                if (fileList == null)\n+                if (fileList == null) {\n@@ -84,0 +123,1 @@\n+                }\n@@ -86,1 +126,2 @@\n-                is = new BufferedInputStream(new FileInputStream(file.getPath()));\n+                try (var _ = new FileInputStream(file.getPath())) {\n+                }\n@@ -88,1 +129,0 @@\n-\n@@ -138,1 +178,2 @@\n-    public Map<String,List<String>> getHeaderFields() {\n+    @Override\n+    public Map<String, List<String>> getHeaderFields() {\n@@ -140,1 +181,11 @@\n-        return super.getHeaderFields();\n+        if (headerFields == null) {\n+            if (!isReadable()) {\n+                return Collections.emptyMap();\n+            }\n+            if (properties == null) {\n+                headerFields = Collections.emptyMap();\n+            } else {\n+                headerFields = properties.getHeaders();\n+            }\n+        }\n+        return headerFields;\n@@ -143,0 +194,1 @@\n+    @Override\n@@ -145,1 +197,4 @@\n-        return super.getHeaderField(name);\n+        if (!isReadable()) {\n+            return null;\n+        }\n+        return properties == null ? null : properties.findValue(name);\n@@ -148,0 +203,1 @@\n+    @Override\n@@ -150,1 +206,5 @@\n-        return super.getHeaderField(n);\n+        if (!isReadable()) {\n+            return null;\n+        }\n+        MessageHeader props = properties;\n+        return props == null ? null : props.getValue(n);\n@@ -153,0 +213,1 @@\n+    @Override\n@@ -160,0 +221,1 @@\n+    @Override\n@@ -165,0 +227,1 @@\n+    @Override\n@@ -167,1 +230,5 @@\n-        return super.getHeaderFieldKey(n);\n+        if (!isReadable()) {\n+            return null;\n+        }\n+        MessageHeader props = properties;\n+        return props == null ? null : props.getKey(n);\n@@ -170,0 +237,1 @@\n+    @Override\n@@ -175,0 +243,1 @@\n+    @Override\n@@ -180,0 +249,1 @@\n+    @Override\n@@ -184,0 +254,4 @@\n+        \/\/ connect() does the necessary readability checks and is expected to\n+        \/\/ throw IOException if any of those checks fail. A normal completion of connect()\n+        \/\/ must mean that connect succeeded.\n+        assert connected : \"not connected\";\n@@ -185,2 +259,4 @@\n-        if (is == null) {\n-            if (isDirectory) {\n+        \/\/ a FileURLConnection only ever creates and provides a single InputStream\n+        if (is != null) {\n+            return is;\n+        }\n@@ -188,3 +264,4 @@\n-                if (directoryListing == null) {\n-                    throw new FileNotFoundException(file.getPath());\n-                }\n+        if (isDirectory) {\n+            \/\/ a successful connect() implies the directoryListing is non-null\n+            \/\/ if the file is a directory\n+            assert directoryListing != null : \"missing directory listing\";\n@@ -192,1 +269,1 @@\n-                directoryListing.sort(Collator.getInstance());\n+            directoryListing.sort(Collator.getInstance());\n@@ -194,9 +271,4 @@\n-                StringBuilder sb = new StringBuilder();\n-                for (String fileName : directoryListing) {\n-                    sb.append(fileName);\n-                    sb.append(\"\\n\");\n-                }\n-                \/\/ Put it into a (default) locale-specific byte-stream.\n-                is = new ByteArrayInputStream(sb.toString().getBytes());\n-            } else {\n-                throw new FileNotFoundException(file.getPath());\n+            StringBuilder sb = new StringBuilder();\n+            for (String fileName : directoryListing) {\n+                sb.append(fileName);\n+                sb.append(\"\\n\");\n@@ -204,0 +276,4 @@\n+            \/\/ Put it into a (default) locale-specific byte-stream.\n+            is = new ByteArrayInputStream(sb.toString().getBytes());\n+        } else {\n+            is = new BufferedInputStream(new FileInputStream(file.getPath()));\n@@ -208,0 +284,13 @@\n+    private synchronized boolean isReadable() {\n+        try {\n+            \/\/ connect() (if not already connected) does the readability checks\n+            \/\/ and throws an IOException if those checks fail. A successful\n+            \/\/ completion from connect() implies the File is readable.\n+            connect();\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/file\/FileURLConnection.java","additions":119,"deletions":30,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URLConnection;\n+import java.net.UnknownServiceException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8367561\n+ * @summary verify that the implementation of URLConnection APIs for \"file:\"\n+ *          protocol does not leak InputStream(s)\n+ * @run junit\/othervm ${test.main.class}\n+ *\/\n+class FileURLConnStreamLeakTest {\n+\n+    private static final String FILE_URLCONNECTION_CLASSNAME = \"sun.net.www.protocol.file.FileURLConnection\";\n+\n+    private Path testFile;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        final Path file = Files.createTempFile(Path.of(\".\"), \"8367561-\", \".txt\");\n+        Files.writeString(file, String.valueOf(System.currentTimeMillis()));\n+        this.testFile = file;\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws Exception {\n+        Files.deleteIfExists(this.testFile);\n+    }\n+\n+\n+    @Test\n+    void testGetContentEncoding() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getContentEncoding();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetContentLength() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getContentLength();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetContentLengthLong() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getContentLengthLong();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetContentType() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getContentType();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetDate() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getDate();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetExpiration() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getExpiration();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderField() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getHeaderField(0);\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldString() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final String val = conn.getHeaderField(\"foo\");\n+        assertNull(val, \"unexpected header field value: \" + val);\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldDate() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getHeaderFieldDate(\"bar\", 42);\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldInt() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final int val = conn.getHeaderFieldInt(\"hello\", 42);\n+        assertEquals(42, val, \"unexpected header value\");\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldKey() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final String val = conn.getHeaderFieldKey(42);\n+        assertNull(val, \"unexpected header value: \" + val);\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldLong() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final long val = conn.getHeaderFieldLong(\"foo\", 42);\n+        assertEquals(42, val, \"unexpected header value\");\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFields() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final Map<String, List<String>> headers = conn.getHeaderFields();\n+        assertNotNull(headers, \"null headers\");\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetLastModified() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        final var _ = conn.getLastModified();\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetInputStream() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null\");\n+        }\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetOutputStream() throws Exception {\n+        final URLConnection conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+        \/\/ FileURLConnection only supports reading\n+        assertThrows(UnknownServiceException.class, conn::getOutputStream);\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/FileURLConnStreamLeakTest.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.net.URLConnection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.Collator;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verify the behaviour of URLConnection.getInputStream()\n+ *          for \"file:\" protocol\n+ * @run junit ${test.main.class}\n+ *\/\n+class GetInputStreamTest {\n+\n+    \/**\n+     * Calls URLConnection.getInputStream() on the URLConnection for a directory and verifies\n+     * the contents returned by the InputStream.\n+     *\/\n+    @Test\n+    void testDirInputStream() throws Exception {\n+        final Path dir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final int numEntries = 3;\n+        \/\/ write some files into that directory\n+        for (int i = 1; i <= numEntries; i++) {\n+            Files.writeString(dir.resolve(i + \".txt\"), \"\" + i);\n+        }\n+        final String expectedDirListing = getDirListing(dir.toFile(), numEntries);\n+        final URLConnection conn = dir.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + dir);\n+        \/\/ call getInputStream() and verify that the streamed directory\n+        \/\/ listing is the expected one\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"InputStream is null for \" + conn);\n+            final String actual = new BufferedReader(new InputStreamReader(is))\n+                    .readAllAsString();\n+            assertEquals(expectedDirListing, actual,\n+                    \"unexpected content from input stream for dir \" + dir);\n+        }\n+        \/\/ now that we successfully obtained the InputStream, read its content\n+        \/\/ and closed it, call getInputStream() again and verify that it can no longer\n+        \/\/ be used to read any more content.\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            final int readByte = is.read();\n+            assertEquals(-1, readByte, \"expected to have read EOF from the stream\");\n+        }\n+    }\n+\n+    \/**\n+     * Calls URLConnection.getInputStream() on the URLConnection for a regular file and verifies\n+     * the contents returned by the InputStream.\n+     *\/\n+    @Test\n+    void testRegularFileInputStream() throws Exception {\n+        final Path dir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final Path regularFile = dir.resolve(\"foo.txt\");\n+        final String expectedContent = \"bar\";\n+        Files.writeString(regularFile, expectedContent);\n+\n+        final URLConnection conn = regularFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + regularFile);\n+        \/\/ get the input stream and verify the streamed content\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            final String actual = new BufferedReader(new InputStreamReader(is))\n+                    .readAllAsString();\n+            assertEquals(expectedContent, actual,\n+                    \"unexpected content from input stream for file \" + regularFile);\n+        }\n+        \/\/ now that we successfully obtained the InputStream, read its content\n+        \/\/ and closed it, call getInputStream() again and verify that it can no longer\n+        \/\/ be used to read any more content.\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            \/\/ for regular files the FileURLConnection's InputStream throws a IOException\n+            \/\/ when attempting to read after EOF\n+            final IOException thrown = assertThrows(IOException.class, is::read);\n+            final String exMessage = thrown.getMessage();\n+            assertEquals(\"Stream closed\", exMessage, \"unexpected exception message\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that URLConnection.getInputStream() for a non-existent file path\n+     * throws FileNotFoundException.\n+     *\/\n+    @Test\n+    void testNonExistentFile() throws Exception {\n+        final Path existentDir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final Path nonExistent = existentDir.resolve(\"non-existent\");\n+        final URLConnection conn = nonExistent.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + nonExistent);\n+        final FileNotFoundException thrown = assertThrows(FileNotFoundException.class,\n+                conn::getInputStream);\n+        final String exMessage = thrown.getMessage();\n+        assertTrue(exMessage != null && exMessage.contains(nonExistent.getFileName().toString()),\n+                \"unexpected exception message: \" + exMessage);\n+    }\n+\n+    private static String getDirListing(final File dir, final int numExpectedEntries) {\n+        final List<String> dirListing = Arrays.asList(dir.list());\n+        dirListing.sort(Collator.getInstance()); \/\/ same as what FileURLConnection does\n+\n+        assertEquals(numExpectedEntries, dirListing.size(),\n+                dir + \" - expected \" + numExpectedEntries + \" entries but found: \" + dirListing);\n+\n+        final StringBuilder sb = new StringBuilder();\n+        for (String fileName : dirListing) {\n+            sb.append(fileName);\n+            sb.append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/GetInputStreamTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"}]}