{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,12 @@\n+    \/**\n+     * This method is called whenever the headers related methods are called on the\n+     * {@code URLConnection}. This method does any necessary checks and initializations\n+     * to make sure that the headers can be served. If this {@code URLConnection} cannot\n+     * serve the headers, then this method throws an {@code IOException}.\n+     *\n+     * @throws IOException if the headers cannot be served\n+     *\/\n+    protected void ensureCanServeHeaders() throws IOException {\n+        getInputStream();\n+    }\n+\n@@ -106,1 +118,1 @@\n-            getInputStream();\n+            ensureCanServeHeaders();\n@@ -114,1 +126,1 @@\n-    Map<String, List<String>> headerFields;\n+    private Map<String, List<String>> headerFields;\n@@ -120,1 +132,1 @@\n-                getInputStream();\n+                ensureCanServeHeaders();\n@@ -140,1 +152,1 @@\n-            getInputStream();\n+            ensureCanServeHeaders();\n@@ -155,1 +167,1 @@\n-            getInputStream();\n+            ensureCanServeHeaders();\n@@ -224,1 +236,1 @@\n-            getInputStream();\n+            ensureCanServeHeaders();\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/URLConnection.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.FilePermission;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.FileNameMap;\n@@ -30,3 +39,0 @@\n-import java.net.FileNameMap;\n-import java.io.*;\n-import java.text.Collator;\n@@ -34,2 +40,1 @@\n-import sun.net.www.*;\n-import java.util.*;\n+import java.text.Collator;\n@@ -37,0 +42,10 @@\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+import sun.net.www.MessageHeader;\n+import sun.net.www.ParseUtil;\n+import sun.net.www.URLConnection;\n@@ -70,1 +85,22 @@\n-    \/*\n+    \/**\n+     * If already connected, then this method is a no-op.\n+     * If not already connected, then this method does\n+     * readability checks for the File.\n+     * <p>\n+     * If the File is a directory then the readability check\n+     * is done by verifying that File.list() does not return\n+     * null. On the other hand, if the File is not a directory,\n+     * then this method constructs a temporary FileInputStream\n+     * for the File and lets the FileInputStream's constructor\n+     * implementation do the necessary readability checks.\n+     * That temporary FileInputStream is closed before returning\n+     * from this method.\n+     * <p>\n+     * In either case, if the readability checks fail, then\n+     * an IOException is thrown from this method and the\n+     * FileURLConnection stays unconnected.\n+     * <p>\n+     * A normal return from this method implies that the\n+     * FileURLConnection is connected and the readability\n+     * checks have passed for the File.\n+     * <p>\n@@ -76,0 +112,1 @@\n+    @Override\n@@ -78,1 +115,0 @@\n-\n@@ -80,0 +116,1 @@\n+            \/\/ verify readability of the directory or the regular file\n@@ -82,1 +119,1 @@\n-                if (fileList == null)\n+                if (fileList == null) {\n@@ -84,0 +121,1 @@\n+                }\n@@ -86,1 +124,3 @@\n-                is = new BufferedInputStream(new FileInputStream(file.getPath()));\n+                \/\/ let FileInputStream constructor do the necessary readability checks\n+                \/\/ and propagate any failures\n+                new FileInputStream(file.getPath()).close();\n@@ -88,1 +128,0 @@\n-\n@@ -115,1 +154,1 @@\n-                    properties.add(CONTENT_TYPE, contentType);\n+                    properties.set(CONTENT_TYPE, contentType);\n@@ -117,1 +156,1 @@\n-                properties.add(CONTENT_LENGTH, Long.toString(length));\n+                properties.set(CONTENT_LENGTH, Long.toString(length));\n@@ -129,1 +168,1 @@\n-                    properties.add(LAST_MODIFIED, fo.format(date));\n+                    properties.set(LAST_MODIFIED, fo.format(date));\n@@ -132,1 +171,1 @@\n-                properties.add(CONTENT_TYPE, TEXT_PLAIN);\n+                properties.set(CONTENT_TYPE, TEXT_PLAIN);\n@@ -138,1 +177,2 @@\n-    public Map<String,List<String>> getHeaderFields() {\n+    @Override\n+    public Map<String, List<String>> getHeaderFields() {\n@@ -143,0 +183,1 @@\n+    @Override\n@@ -148,0 +189,1 @@\n+    @Override\n@@ -153,0 +195,1 @@\n+    @Override\n@@ -160,0 +203,1 @@\n+    @Override\n@@ -165,0 +209,1 @@\n+    @Override\n@@ -170,0 +215,1 @@\n+    @Override\n@@ -175,0 +221,1 @@\n+    @Override\n@@ -180,0 +227,1 @@\n+    @Override\n@@ -184,0 +232,4 @@\n+        \/\/ connect() does the necessary readability checks and is expected to\n+        \/\/ throw IOException if any of those checks fail. A normal completion of connect()\n+        \/\/ must mean that connect succeeded.\n+        assert connected : \"not connected\";\n@@ -185,2 +237,4 @@\n-        if (is == null) {\n-            if (isDirectory) {\n+        \/\/ a FileURLConnection only ever creates and provides a single InputStream\n+        if (is != null) {\n+            return is;\n+        }\n@@ -188,3 +242,4 @@\n-                if (directoryListing == null) {\n-                    throw new FileNotFoundException(file.getPath());\n-                }\n+        if (isDirectory) {\n+            \/\/ a successful connect() implies the directoryListing is non-null\n+            \/\/ if the file is a directory\n+            assert directoryListing != null : \"missing directory listing\";\n@@ -192,1 +247,1 @@\n-                directoryListing.sort(Collator.getInstance());\n+            directoryListing.sort(Collator.getInstance());\n@@ -194,9 +249,4 @@\n-                StringBuilder sb = new StringBuilder();\n-                for (String fileName : directoryListing) {\n-                    sb.append(fileName);\n-                    sb.append(\"\\n\");\n-                }\n-                \/\/ Put it into a (default) locale-specific byte-stream.\n-                is = new ByteArrayInputStream(sb.toString().getBytes());\n-            } else {\n-                throw new FileNotFoundException(file.getPath());\n+            StringBuilder sb = new StringBuilder();\n+            for (String fileName : directoryListing) {\n+                sb.append(fileName);\n+                sb.append(\"\\n\");\n@@ -204,0 +254,4 @@\n+            \/\/ Put it into a (default) locale-specific byte-stream.\n+            is = new ByteArrayInputStream(sb.toString().getBytes());\n+        } else {\n+            is = new BufferedInputStream(new FileInputStream(file.getPath()));\n@@ -208,0 +262,9 @@\n+    @Override\n+    protected synchronized void ensureCanServeHeaders() throws IOException {\n+        \/\/ connect() (if not already connected) does the readability checks\n+        \/\/ and throws an IOException if those checks fail. A successful\n+        \/\/ completion from connect() implies the File is readable.\n+        connect();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/file\/FileURLConnection.java","additions":93,"deletions":30,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URLConnection;\n+import java.net.UnknownServiceException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8367561\n+ * @summary verify that the implementation of URLConnection APIs for \"file:\"\n+ *          protocol does not leak InputStream(s)\n+ * @run junit\/othervm ${test.main.class}\n+ *\/\n+class FileURLConnStreamLeakTest {\n+\n+    private static final String FILE_URLCONNECTION_CLASSNAME = \"sun.net.www.protocol.file.FileURLConnection\";\n+\n+    private Path testFile;\n+    \/\/ FileInputStream has a Cleaner which closes its underlying file descriptor.\n+    \/\/ Here we keep reference to the URLConnection for the duration of each test method.\n+    \/\/ This ensures that any FileInputStream this URLConnection may be retaining, won't be GCed\n+    \/\/ until after the test method has checked for file descriptor leaks.\n+    private URLConnection conn;\n+\n+    @BeforeEach\n+    void beforeEach() throws Exception {\n+        final Path file = Files.createTempFile(Path.of(\".\"), \"8367561-\", \".txt\");\n+        Files.writeString(file, String.valueOf(System.currentTimeMillis()));\n+        this.testFile = file;\n+        this.conn = this.testFile.toUri().toURL().openConnection();\n+        assertNotNull(this.conn, \"URLConnection for \" + this.testFile + \" is null\");\n+        assertEquals(FILE_URLCONNECTION_CLASSNAME, conn.getClass().getName(),\n+                \"unexpected URLConnection type\");\n+    }\n+\n+    @AfterEach\n+    void afterEach() throws Exception {\n+        this.conn = null;\n+        \/\/ the file should already have been deleted by the test method\n+        Files.deleteIfExists(this.testFile);\n+    }\n+\n+    static List<Consumer<URLConnection>> urlConnOperations() {\n+        return List.of(\n+                URLConnection::getContentEncoding,\n+                URLConnection::getContentLength,\n+                URLConnection::getContentLengthLong,\n+                URLConnection::getContentType,\n+                URLConnection::getDate,\n+                URLConnection::getExpiration,\n+                URLConnection::getLastModified\n+        );\n+    }\n+\n+    @MethodSource(\"urlConnOperations\")\n+    @ParameterizedTest\n+    void testURLConnOps(final Consumer<URLConnection> connConsumer) throws IOException {\n+        connConsumer.accept(this.conn);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderField() throws Exception {\n+        final var _ = this.conn.getHeaderField(0);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldString() throws Exception {\n+        final String val = this.conn.getHeaderField(\"foo\");\n+        assertNull(val, \"unexpected header field value: \" + val);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldDate() throws Exception {\n+        final var _ = this.conn.getHeaderFieldDate(\"bar\", 42);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldInt() throws Exception {\n+        final int val = this.conn.getHeaderFieldInt(\"hello\", 42);\n+        assertEquals(42, val, \"unexpected header value\");\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldKey() throws Exception {\n+        final String val = this.conn.getHeaderFieldKey(42);\n+        assertNull(val, \"unexpected header value: \" + val);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFieldLong() throws Exception {\n+        final long val = this.conn.getHeaderFieldLong(\"foo\", 42);\n+        assertEquals(42, val, \"unexpected header value\");\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetHeaderFields() throws Exception {\n+        final Map<String, List<String>> headers = this.conn.getHeaderFields();\n+        assertNotNull(headers, \"null headers\");\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetInputStream() throws Exception {\n+        try (final InputStream is = this.conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null\");\n+        }\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+\n+    @Test\n+    void testGetOutputStream() throws Exception {\n+        \/\/ FileURLConnection only supports reading\n+        assertThrows(UnknownServiceException.class, this.conn::getOutputStream);\n+        \/\/ verify that the URLConnection isn't holding on to any file descriptors\n+        \/\/ of this test file.\n+        Files.delete(this.testFile); \/\/ must not fail\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/FileURLConnStreamLeakTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.net.URLConnection;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.Collator;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @summary verify the behaviour of URLConnection.getInputStream()\n+ *          for \"file:\" protocol\n+ * @run junit ${test.main.class}\n+ *\/\n+class GetInputStreamTest {\n+\n+    \/**\n+     * Calls URLConnection.getInputStream() on the URLConnection for a directory and verifies\n+     * the contents returned by the InputStream.\n+     *\/\n+    @Test\n+    void testDirInputStream() throws Exception {\n+        final Path dir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final int numEntries = 3;\n+        \/\/ write some files into that directory\n+        for (int i = 1; i <= numEntries; i++) {\n+            Files.writeString(dir.resolve(i + \".txt\"), \"\" + i);\n+        }\n+        final String expectedDirListing = getDirListing(dir.toFile(), numEntries);\n+        final URLConnection conn = dir.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + dir);\n+        \/\/ call getInputStream() and verify that the streamed directory\n+        \/\/ listing is the expected one\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"InputStream is null for \" + conn);\n+            final String actual = new BufferedReader(new InputStreamReader(is))\n+                    .readAllAsString();\n+            assertEquals(expectedDirListing, actual,\n+                    \"unexpected content from input stream for dir \" + dir);\n+        }\n+        \/\/ now that we successfully obtained the InputStream, read its content\n+        \/\/ and closed it, call getInputStream() again and verify that it can no longer\n+        \/\/ be used to read any more content.\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            final int readByte = is.read();\n+            assertEquals(-1, readByte, \"expected to have read EOF from the stream\");\n+        }\n+    }\n+\n+    \/**\n+     * Calls URLConnection.getInputStream() on the URLConnection for a regular file and verifies\n+     * the contents returned by the InputStream.\n+     *\/\n+    @Test\n+    void testRegularFileInputStream() throws Exception {\n+        final Path dir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final Path regularFile = dir.resolve(\"foo.txt\");\n+        final String expectedContent = \"bar\";\n+        Files.writeString(regularFile, expectedContent);\n+\n+        final URLConnection conn = regularFile.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + regularFile);\n+        \/\/ get the input stream and verify the streamed content\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            final String actual = new BufferedReader(new InputStreamReader(is))\n+                    .readAllAsString();\n+            assertEquals(expectedContent, actual,\n+                    \"unexpected content from input stream for file \" + regularFile);\n+        }\n+        \/\/ now that we successfully obtained the InputStream, read its content\n+        \/\/ and closed it, call getInputStream() again and verify that it can no longer\n+        \/\/ be used to read any more content.\n+        try (final InputStream is = conn.getInputStream()) {\n+            assertNotNull(is, \"input stream is null for \" + conn);\n+            \/\/ for regular files the FileURLConnection's InputStream throws a IOException\n+            \/\/ when attempting to read after EOF\n+            final IOException thrown = assertThrows(IOException.class, is::read);\n+            final String exMessage = thrown.getMessage();\n+            assertEquals(\"Stream closed\", exMessage, \"unexpected exception message\");\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that URLConnection.getInputStream() for a non-existent file path\n+     * throws FileNotFoundException.\n+     *\/\n+    @Test\n+    void testNonExistentFile() throws Exception {\n+        final Path existentDir = Files.createTempDirectory(Path.of(\".\"), \"fileurlconn-\");\n+        final Path nonExistent = existentDir.resolve(\"non-existent\");\n+        final URLConnection conn = nonExistent.toUri().toURL().openConnection();\n+        assertNotNull(conn, \"URLConnection is null for \" + nonExistent);\n+        final FileNotFoundException thrown = assertThrows(FileNotFoundException.class,\n+                conn::getInputStream);\n+        final String exMessage = thrown.getMessage();\n+        assertTrue(exMessage != null && exMessage.contains(nonExistent.getFileName().toString()),\n+                \"unexpected exception message: \" + exMessage);\n+    }\n+\n+    private static String getDirListing(final File dir, final int numExpectedEntries) {\n+        final List<String> dirListing = Arrays.asList(dir.list());\n+        dirListing.sort(Collator.getInstance()); \/\/ same as what FileURLConnection does\n+\n+        assertEquals(numExpectedEntries, dirListing.size(),\n+                dir + \" - expected \" + numExpectedEntries + \" entries but found: \" + dirListing);\n+\n+        final StringBuilder sb = new StringBuilder();\n+        for (String fileName : dirListing) {\n+            sb.append(fileName);\n+            sb.append(\"\\n\");\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/file\/GetInputStreamTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"}]}