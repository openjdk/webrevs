{"files":[{"patch":"@@ -15620,1 +15620,1 @@\n-  int size = UseAPX ? 1024 : 256;\n+  int size = UseAPX ? 512 : 256;\n@@ -15675,35 +15675,28 @@\n-    subq(rsp, 32 * wordSize);\n-    movq(Address(rsp, 31 * wordSize), rax);\n-    movq(Address(rsp, 30 * wordSize), rcx);\n-    movq(Address(rsp, 29 * wordSize), rdx);\n-    movq(Address(rsp, 28 * wordSize), rbx);\n-    \/\/ Skip rsp as the value is normally not used. There are a few places where\n-    \/\/ the original value of rsp needs to be known but that can be computed\n-    \/\/ from the value of rsp immediately after pusha (rsp + 32 * wordSize).\n-    movq(Address(rsp, 26 * wordSize), rbp);\n-    movq(Address(rsp, 25 * wordSize), rsi);\n-    movq(Address(rsp, 24 * wordSize), rdi);\n-    movq(Address(rsp, 23 * wordSize), r8);\n-    movq(Address(rsp, 22 * wordSize), r9);\n-    movq(Address(rsp, 21 * wordSize), r10);\n-    movq(Address(rsp, 20 * wordSize), r11);\n-    movq(Address(rsp, 19 * wordSize), r12);\n-    movq(Address(rsp, 18 * wordSize), r13);\n-    movq(Address(rsp, 17 * wordSize), r14);\n-    movq(Address(rsp, 16 * wordSize), r15);\n-    movq(Address(rsp, 15 * wordSize), r16);\n-    movq(Address(rsp, 14 * wordSize), r17);\n-    movq(Address(rsp, 13 * wordSize), r18);\n-    movq(Address(rsp, 12 * wordSize), r19);\n-    movq(Address(rsp, 11 * wordSize), r20);\n-    movq(Address(rsp, 10 * wordSize), r21);\n-    movq(Address(rsp, 9 * wordSize), r22);\n-    movq(Address(rsp, 8 * wordSize), r23);\n-    movq(Address(rsp, 7 * wordSize), r24);\n-    movq(Address(rsp, 6 * wordSize), r25);\n-    movq(Address(rsp, 5 * wordSize), r26);\n-    movq(Address(rsp, 4 * wordSize), r27);\n-    movq(Address(rsp, 3 * wordSize), r28);\n-    movq(Address(rsp, 2 * wordSize), r29);\n-    movq(Address(rsp, wordSize), r30);\n-    movq(Address(rsp, 0), r31);\n+    \/\/ Data being pushed by PUSH2 must be 16B-aligned on the stack, for this push rax upfront\n+    \/\/ and use it as a temporary register for stack alignment.\n+    pushp(rax);\n+    \/\/ Move original stack pointer to RAX and align stack pointer to 16B boundary.\n+    movq(rax, rsp);\n+    andq(rsp, -(StackAlignmentInBytes));\n+    \/\/ Push pair of original stack pointer along with remaining registers\n+    \/\/ at 16B aligned boundary.\n+    push2p(rax, r31);\n+    \/\/ Restore the original contents of RAX register.\n+    movq(rax, Address(rax));\n+    push2p(r30, r29);\n+    push2p(r28, r27);\n+    push2p(r26, r25);\n+    push2p(r24, r23);\n+    push2p(r22, r21);\n+    push2p(r20, r19);\n+    push2p(r18, r17);\n+    push2p(r16, r15);\n+    push2p(r14, r13);\n+    push2p(r12, r11);\n+    push2p(r10, r9);\n+    push2p(r8, rdi);\n+    push2p(rsi, rbp);\n+    push2p(rbx, rdx);\n+    \/\/ To maintain 16 byte alignment after rcx is pushed.\n+    subq(rsp, 8);\n+    pushp(rcx);\n@@ -15741,34 +15734,22 @@\n-    movq(r31, Address(rsp, 0));\n-    movq(r30, Address(rsp, wordSize));\n-    movq(r29, Address(rsp, 2 * wordSize));\n-    movq(r28, Address(rsp, 3 * wordSize));\n-    movq(r27, Address(rsp, 4 * wordSize));\n-    movq(r26, Address(rsp, 5 * wordSize));\n-    movq(r25, Address(rsp, 6 * wordSize));\n-    movq(r24, Address(rsp, 7 * wordSize));\n-    movq(r23, Address(rsp, 8 * wordSize));\n-    movq(r22, Address(rsp, 9 * wordSize));\n-    movq(r21, Address(rsp, 10 * wordSize));\n-    movq(r20, Address(rsp, 11 * wordSize));\n-    movq(r19, Address(rsp, 12 * wordSize));\n-    movq(r18, Address(rsp, 13 * wordSize));\n-    movq(r17, Address(rsp, 14 * wordSize));\n-    movq(r16, Address(rsp, 15 * wordSize));\n-    movq(r15, Address(rsp, 16 * wordSize));\n-    movq(r14, Address(rsp, 17 * wordSize));\n-    movq(r13, Address(rsp, 18 * wordSize));\n-    movq(r12, Address(rsp, 19 * wordSize));\n-    movq(r11, Address(rsp, 20 * wordSize));\n-    movq(r10, Address(rsp, 21 * wordSize));\n-    movq(r9, Address(rsp, 22 * wordSize));\n-    movq(r8, Address(rsp, 23 * wordSize));\n-    movq(rdi, Address(rsp, 24 * wordSize));\n-    movq(rsi, Address(rsp, 25 * wordSize));\n-    movq(rbp, Address(rsp, 26 * wordSize));\n-    \/\/ Skip rsp as it is restored automatically to the value\n-    \/\/ before the corresponding pusha when popa is done.\n-    movq(rbx, Address(rsp, 28 * wordSize));\n-    movq(rdx, Address(rsp, 29 * wordSize));\n-    movq(rcx, Address(rsp, 30 * wordSize));\n-    movq(rax, Address(rsp, 31 * wordSize));\n-    addq(rsp, 32 * wordSize);\n+    popp(rcx);\n+    addq(rsp, 8);\n+    \/\/ Data being popped by POP2 must be 16B-aligned on the stack.\n+    pop2p(rdx, rbx);\n+    pop2p(rbp, rsi);\n+    pop2p(rdi, r8);\n+    pop2p(r9, r10);\n+    pop2p(r11, r12);\n+    pop2p(r13, r14);\n+    pop2p(r15, r16);\n+    pop2p(r17, r18);\n+    pop2p(r19, r20);\n+    pop2p(r21, r22);\n+    pop2p(r23, r24);\n+    pop2p(r25, r26);\n+    pop2p(r27, r28);\n+    pop2p(r29, r30);\n+    \/\/ Popped value in RAX holds original unaligned stack pointer.\n+    pop2p(r31, rax);\n+    \/\/ Reinstantiate original stack pointer.\n+    movq(rsp, rax);\n+    popp(rax);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":51,"deletions":70,"binary":false,"changes":121,"status":"modified"}]}