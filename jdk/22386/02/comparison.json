{"files":[{"patch":"@@ -3110,0 +3110,32 @@\n+\/\/ --------------  Zicond Instruction Definitions  --------------\n+\/\/ Zicond conditional operations extension\n+  private:\n+  enum CZERO_OP : unsigned int {\n+    CZERO_NEZ = 0b111,\n+    CZERO_EQZ = 0b101\n+  };\n+\n+  template <CZERO_OP OP_VALUE>\n+  void czero(Register Rd, Register Rs1, Register Rs2) {\n+    assert_cond(UseZicond);\n+    uint32_t insn = 0;\n+    patch    ((address)&insn,  6,  0, 0b0110011);  \/\/ bits:  7, name: 0x33, attr: ['OP']\n+    patch_reg((address)&insn,      7, Rd);         \/\/ bits:  5, name: 'rd'\n+    patch    ((address)&insn, 14, 12, OP_VALUE);   \/\/ bits:  3, name: 0x7, attr: ['CZERO.NEZ'] \/ 0x5, attr: ['CZERO.EQZ']}\n+    patch_reg((address)&insn,     15, Rs1);        \/\/ bits:  5, name: 'rs1', attr: ['value']\n+    patch_reg((address)&insn,     20, Rs2);        \/\/ bits:  5, name: 'rs2', attr: ['condition']\n+    patch    ((address)&insn, 31, 25, 0b0000111);  \/\/ bits:  7, name: 0x7, attr: ['CZERO']\n+    emit_int32(insn);\n+  }\n+\n+  public:\n+  \/\/ Moves zero to a register rd, if the condition rs2 is equal to zero, otherwise moves rs1 to rd.\n+  void czero_eqz(Register rd, Register rs1_value, Register rs2_condition) {\n+    czero<CZERO_EQZ>(rd, rs1_value, rs2_condition);\n+  }\n+\n+  \/\/ Moves zero to a register rd, if the condition rs2 is nonzero, otherwise moves rs1 to rd.\n+  void czero_nez(Register rd, Register rs1_value, Register rs2_condition) {\n+    czero<CZERO_NEZ>(rd, rs1_value, rs2_condition);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -873,0 +873,1 @@\n+\/\/ Consider using cmov (Zicond)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2006,4 +2006,42 @@\n-  Label L;\n-  cmp_branch(cmpFlag ^ (1 << neg_cond_bits), op1, op2, L);\n-  mv(dst, src);\n-  bind(L);\n+  bool is_unsigned = (cmpFlag & unsigned_branch_mask) == unsigned_branch_mask;\n+  int op_select = cmpFlag & (~unsigned_branch_mask);\n+\n+  switch (op_select) {\n+    case BoolTest::eq:\n+      cmov_eq(op1, op2, dst, src);\n+      break;\n+    case BoolTest::ne:\n+      cmov_ne(op1, op2, dst, src);\n+      break;\n+    case BoolTest::le:\n+      if (is_unsigned) {\n+        cmov_leu(op1, op2, dst, src);\n+      } else {\n+        cmov_le(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::ge:\n+      if (is_unsigned) {\n+        cmov_geu(op1, op2, dst, src);\n+      } else {\n+        cmov_ge(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::lt:\n+      if (is_unsigned) {\n+        cmov_ltu(op1, op2, dst, src);\n+      } else {\n+        cmov_lt(op1, op2, dst, src);\n+      }\n+      break;\n+    case BoolTest::gt:\n+      if (is_unsigned) {\n+        cmov_gtu(op1, op2, dst, src);\n+      } else {\n+        cmov_gt(op1, op2, dst, src);\n+      }\n+      break;\n+    default:\n+      assert(false, \"unsupported compare condition\");\n+      ShouldNotReachHere();\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-  static const int neg_cond_bits = 2;\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  product(bool, UseZicond, false, DIAGNOSTIC, \"Use Zicond instructions\")         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1131,0 +1131,141 @@\n+\/\/ cmov\n+void MacroAssembler::cmov_eq(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    xorr(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bne(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ne(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    xorr(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  beq(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_le(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp2, cmp1);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgt(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_leu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp2, cmp1);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgtu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ge(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  blt(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_geu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp1, cmp2);\n+    czero_eqz(dst, dst, t0);\n+    czero_nez(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bltu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_lt(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bge(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_ltu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp1, cmp2);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bgeu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_gt(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    slt(t0, cmp2, cmp1);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  ble(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n+void MacroAssembler::cmov_gtu(Register cmp1, Register cmp2, Register dst, Register src) {\n+  if (UseZicond) {\n+    sltu(t0, cmp2, cmp1);\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0,  src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  bleu(cmp1, cmp2, no_set);\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -629,0 +629,11 @@\n+  void cmov_eq(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ne(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_le(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_leu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ge(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_geu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_lt(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_ltu(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_gt(Register cmp1, Register cmp2, Register dst, Register src);\n+  void cmov_gtu(Register cmp1, Register cmp2, Register dst, Register src);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  \/\/ Zicond Conditional operations\n+  \/\/\n@@ -167,0 +169,1 @@\n+  decl(ext_Zicond      , \"Zicond\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))      \\\n@@ -226,0 +229,1 @@\n+    RV_ENABLE_EXTENSION(UseZicond)                  \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICOND)) {\n+    VM_Version::ext_Zicond.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#if (defined(RISCV) || defined(RISCV64)) && !defined(ZERO)\n+\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"unittest.hpp\"\n+\n+typedef int64_t (*zicond_func)(int64_t cmp1, int64_t cmp2, int64_t dst, int64_t src);\n+typedef void (MacroAssembler::*cmov_func)(Register cmp1, Register cmp2, Register dst, Register src);\n+\n+class CmovTester {\n+ public:\n+  static void test(cmov_func func, int64_t a0, int64_t a1, int64_t a2, int64_t a3, int64_t result) {\n+    BufferBlob* bb = BufferBlob::create(\"riscvTest\", 128);\n+    CodeBuffer code(bb);\n+    MacroAssembler _masm(&code);\n+    address entry = _masm.pc();\n+    {\n+      ((&_masm)->*func)(c_rarg0, c_rarg1, c_rarg2, c_rarg3);\n+      _masm.mv(c_rarg0, c_rarg2);\n+      _masm.ret();\n+    }\n+    _masm.flush();\n+    OrderAccess::cross_modify_fence();\n+    int64_t ret = ((zicond_func)entry)(a0, a1, a2, a3);\n+    ASSERT_EQ(ret, result);\n+    BufferBlob::free(bb);\n+  }\n+};\n+\n+void run_cmov_tests() {\n+  \/\/ If 42(a0) eq 42(a1): assign dest(a2\/66) the src(a3\/77), expect result: 77\n+  CmovTester::test(&MacroAssembler::cmov_eq, 42, 42, 66, 77, 77);\n+  \/\/ If 41(a0) eq 42(a1): assign dest(a2\/66) the src(a3\/77), expect result: 66\n+  CmovTester::test(&MacroAssembler::cmov_eq, 41, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ne, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ne, 42, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_le, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_le, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_le, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_leu, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_leu, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_leu, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ge, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ge, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ge, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_geu, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_geu, 42, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_geu, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_lt, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_lt, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_lt, 42, -1, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_ltu, 41, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_ltu, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_ltu, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_gt, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_gt, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_gt, -1, 42, 66, 77, 66);\n+\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 43, 42, 66, 77, 77);\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 42, 42, 66, 77, 66);\n+  CmovTester::test(&MacroAssembler::cmov_gtu, 42, -1, 66, 77, 66);\n+}\n+\n+TEST_VM(RiscV, cmov) {\n+  run_cmov_tests();\n+  if (UseZicond) {\n+    UseZicond = false;\n+    run_cmov_tests();\n+    UseZicond = true;\n+  }\n+}\n+\n+#endif  \/\/ RISCV\n","filename":"test\/hotspot\/gtest\/riscv\/test_assembler_riscv.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}