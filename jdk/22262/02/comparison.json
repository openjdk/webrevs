{"files":[{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/access.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/typeArrayKlass.hpp\"\n@@ -65,0 +67,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -2681,1 +2684,6 @@\n-  ClassFileStream* cfs = cpe->open_stream_for_loader(THREAD, file_name, loader_data);\n+  ClassFileStream* cfs;\n+  if (class_loader() != nullptr && !cpe->is_modules_image()) {\n+    cfs = get_stream_from_class_loader(class_loader, cpe, file_name, CHECK_NULL);\n+  } else {\n+    cfs = cpe->open_stream_for_loader(THREAD, file_name, loader_data);\n+  }\n@@ -2688,0 +2696,34 @@\n+ClassFileStream* FileMapInfo::get_stream_from_class_loader(Handle class_loader,\n+                                                           ClassPathEntry* cpe,\n+                                                           const char* file_name,\n+                                                           TRAPS) {\n+  JavaValue result(T_OBJECT);\n+  TempNewSymbol class_name_sym = SymbolTable::new_symbol(file_name);\n+  Handle ext_class_name = java_lang_String::externalize_classname(class_name_sym, CHECK_NULL);\n+\n+  \/\/ InputStream ClassLoader.getResourceAsStream(String name)\n+  JavaCalls::call_virtual(&result,\n+                          class_loader,\n+                          vmClasses::ClassLoader_klass(),\n+                          vmSymbols::getResourceAsByteArray_name(),\n+                          vmSymbols::getResourceAsByteArray_signature(),\n+                          ext_class_name,\n+                          CHECK_NULL);\n+  assert(result.get_type() == T_OBJECT, \"just checking\");\n+  oop obj = result.get_oop();\n+  assert(obj != nullptr, \"ClassLoader.getResourceAsStream should not return null\");\n+\n+  \/\/ The result should be a [B\n+  assert(obj->is_typeArray(), \"just checking\");\n+  assert(TypeArrayKlass::cast(obj->klass())->element_type() == T_BYTE, \"just checking\");\n+\n+  \/\/ copy from byte[] to a buffer\n+  typeArrayOop ba = typeArrayOop(obj);\n+  jint len = ba->length();\n+  u1* buffer = NEW_RESOURCE_ARRAY(u1, len);\n+  ArrayAccess<>::arraycopy_to_native<>(ba, typeArrayOopDesc::element_offset<jbyte>(0), buffer, len);\n+\n+  return new ClassFileStream(buffer,\n+                             len,\n+                             cpe->name());\n+}\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -510,0 +510,4 @@\n+  static ClassFileStream* get_stream_from_class_loader(Handle class_loader,\n+                                                       ClassPathEntry* cpe,\n+                                                       const char* file_name,\n+                                                       TRAPS);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -726,0 +726,2 @@\n+  template(getResourceAsByteArray_name,                     \"getResourceAsByteArray\")                             \\\n+  template(getResourceAsByteArray_signature,                \"(Ljava\/lang\/String;)[B\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1688,0 +1688,13 @@\n+    \/**\n+     * Called by VM for constructing a ClassFileStream.\n+     *\/\n+    private byte[] getResourceAsByteArray(String name) {\n+        Objects.requireNonNull(name);\n+        InputStream is = getResourceAsStream(name);\n+        try {\n+            return is != null ? is.readAllBytes() : null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/CFLH\/ClassFileLoadHook.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/ClassFileLoadHook.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/CFLH\/ClassFileLoadHookTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/ClassFileLoadHookTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test multi-release jar with CFLH\n+ * @requires vm.cds\n+ * @requires vm.jvmti\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run main\/othervm\/native MultiReleaseJars\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.PrintStream;\n+import java.io.IOException;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class MultiReleaseJars {\n+\n+    static final int BASE_VERSION = 9;\n+    static final String BASE_VERSION_STRING = Integer.toString(BASE_VERSION);\n+    static final int MAJOR_VERSION = Runtime.version().major();\n+    static final String MAJOR_VERSION_STRING = String.valueOf(MAJOR_VERSION);\n+\n+    static String getMain() {\n+        String sts = \"\"\"\n+            public class Main {\n+                public static void main(String[] args) throws Exception {\n+                    System.out.println(Class.forName(\\\"Foo\\\"));\n+                    System.out.println(Class.forName(\\\"Bar\\\"));\n+                }\n+            }\n+            \"\"\";\n+        return sts;\n+    }\n+\n+    static String getFoo() {\n+        String sts = \"\"\"\n+            class Foo {\n+                static {\n+                    System.out.println(\"Hello from Foo old version\");\n+                }\n+            }\n+        \"\"\";\n+        return sts;\n+    }\n+\n+    static String getFooNewVersion() {\n+        String sts = \"\"\"\n+            class Foo {\n+                static {\n+                    System.out.println(\"Hello from Foo new version\");\n+                }\n+            }\n+        \"\"\";\n+        return sts;\n+    }\n+\n+    static String getBar() {\n+        String sts = \"\"\"\n+            class Bar {\n+                static {\n+                    System.out.println(\"Hello from Bar\");\n+                }\n+            }\n+        \"\"\";\n+        return sts;\n+    }\n+\n+    static void writeFile(File file, String... contents) throws Exception {\n+        if (contents == null) {\n+            throw new java.lang.RuntimeException(\"No input for writing to file\" + file);\n+        }\n+        try (\n+             FileOutputStream fos = new FileOutputStream(file);\n+             PrintStream ps = new PrintStream(fos)\n+        ) {\n+            for (String str : contents) {\n+                ps.println(str);\n+            }\n+        }\n+    }\n+\n+    \/* version.jar entries and files:\n+     * META-INF\/\n+     * META-INF\/MANIFEST.MF\n+     * Bar.class\n+     * Main.class\n+     * META-INF\/versions\/9\/\n+     * META-INF\/versions\/9\/Bar.class\n+     * META-INF\/versions\/9\/Foo.class\n+     * META-INF\/versions\/24\/\n+     * META-INF\/versions\/24\/Foo.class\n+     *\/\n+    static void createClassFilesAndJar() throws Exception {\n+        String tempDir = CDSTestUtils.getOutputDir();\n+        File baseDir = new File(tempDir + File.separator + \"base\");\n+        File vDir    = new File(tempDir + File.separator + BASE_VERSION_STRING);\n+        File vDir2   = new File(tempDir + File.separator + MAJOR_VERSION_STRING);\n+\n+        baseDir.mkdirs();\n+        vDir.mkdirs();\n+\n+        File fileFoo = TestCommon.getOutputSourceFile(\"Foo.java\");\n+        writeFile(fileFoo, getFoo());\n+        JarBuilder.compile(vDir.getAbsolutePath(), fileFoo.getAbsolutePath(), \"--release\", BASE_VERSION_STRING);\n+\n+        writeFile(fileFoo, getFooNewVersion());\n+        JarBuilder.compile(vDir2.getAbsolutePath(), fileFoo.getAbsolutePath(), \"--release\", MAJOR_VERSION_STRING);\n+\n+        File fileMain = TestCommon.getOutputSourceFile(\"Main.java\");\n+        writeFile(fileMain, getMain());\n+        JarBuilder.compile(baseDir.getAbsolutePath(), fileMain.getAbsolutePath());\n+        File fileBar = TestCommon.getOutputSourceFile(\"Bar.java\");\n+        writeFile(fileBar, getBar());\n+        JarBuilder.compile(baseDir.getAbsolutePath(), fileBar.getAbsolutePath());\n+        JarBuilder.compile(vDir.getAbsolutePath(), fileBar.getAbsolutePath(), \"--release\", BASE_VERSION_STRING);\n+\n+        String[] meta = {\n+            \"Multi-Release: true\",\n+            \"Main-Class: Main\"\n+        };\n+        File metainf = new File(tempDir, \"mf.txt\");\n+        writeFile(metainf, meta);\n+\n+        JarBuilder.build(\"multi-version\", baseDir, metainf.getAbsolutePath(),\n+            \"--release\", BASE_VERSION_STRING, \"-C\", vDir.getAbsolutePath(), \".\",\n+            \"--release\", MAJOR_VERSION_STRING, \"-C\", vDir2.getAbsolutePath(), \".\");\n+\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        \/\/ create multi-version.jar which contains Main.class, Foo.class and Bar.class.\n+        \/\/ Foo.class has two version: base version 9 and current major JDK version.\n+        \/\/ Bar.class has two versions: base version 9 and default version.\n+        \/\/ Since there is no default version for Foo, the class loader will get the\n+        \/\/ highest version (current major JDK version in this case) which is the\n+        \/\/ same or below the current JDK version.\n+        createClassFilesAndJar();\n+\n+        String mainClass    = \"Main\";\n+        String appJar       = TestCommon.getTestJar(\"multi-version.jar\");\n+        String appClasses[] = {\"Foo\", \"Bar\"};\n+\n+        OutputAnalyzer output = TestCommon.dump(appJar, appClasses);\n+        output.shouldContain(\"Loading classes to share: done.\")\n+              .shouldHaveExitValue(0);\n+\n+        String agentCmdArg = \"-agentlib:SimpleClassFileLoadHook=Foo,Hello,HELLO\";\n+        output = TestCommon.execAuto(\"-cp\", appJar,\n+                                     \"-Xlog:cds=info,class+load\",\n+                                     agentCmdArg,\n+                                     mainClass);\n+\n+        output.shouldMatch(\".*Foo.source:.*multi-version.jar\")\n+              \/\/ New version of Foo is loaded from jar since it was modified by CFLH\n+              .shouldContain(\"HELLO from Foo new version\") \/\/ CFLH changed \"Hello\" to \"HELLO\"\n+              .shouldContain(\"class Foo\") \/\/ output from Main\n+              \/\/ Bar is loaded from archive\n+              .shouldContain(\"Bar source: shared objects file\")\n+              .shouldContain(\"Hello from Bar\")\n+              .shouldContain(\"class Bar\"); \/\/ output from Main\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/CFLH\/MultiReleaseJars.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}