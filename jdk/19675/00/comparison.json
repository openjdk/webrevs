{"files":[{"patch":"@@ -63,2 +63,2 @@\n- * To release resources used by this {@code Deflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n+ * To release resources used by this {@code Deflater}, the {@link #close()} method\n+ * should be used. Subclasses are responsible for the cleanup of resources\n@@ -74,1 +74,1 @@\n-public class Deflater {\n+public class Deflater implements AutoCloseable {\n@@ -875,2 +875,4 @@\n-     * being used. Once this method is called, the behavior of the\n-     * Deflater object is undefined.\n+     * being used. Once this method is called, further operations using\n+     * this Deflater may throw an exception.\n+     *\n+     * @see #close()\n@@ -880,0 +882,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -882,0 +888,20 @@\n+            inputArray = null;\n+        }\n+    }\n+\n+    \/**\n+     * Releases resources held by this compressor and discards any unprocessed input.\n+     * This method should be called when the compressor is no longer needed.\n+     *\n+     * @implNote This method calls the {@link #end()} method. This method is a no-op\n+     * if this compressor has already been previously closed, either through {@code close()}\n+     * or {@code end()}\n+     * @since 24\n+     *\/\n+    @Override\n+    public void close() {\n+        synchronized (zsRef) {\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -883,0 +909,1 @@\n+        end();\n@@ -932,1 +959,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -936,0 +963,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n- * To release resources used by this {@code Inflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n+ * To release resources used by this {@code Inflater}, the {@link #close()} method\n+ * should be used. Subclasses are responsible for the cleanup of resources\n@@ -74,1 +74,1 @@\n-public class Inflater {\n+public class Inflater implements AutoCloseable {\n@@ -694,2 +694,4 @@\n-     * being used. Once this method is called, the behavior of the\n-     * Inflater object is undefined.\n+     * being used. Once this method is called, further operations using\n+     * this Inflater may throw an exception.\n+     *\n+     * @see #close()\n@@ -699,0 +701,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -706,0 +712,20 @@\n+    \/**\n+     * Releases resources held by this decompressor and discards any unprocessed input.\n+     * This method should be called when the decompressor is no longer needed.\n+     *\n+     * @implNote This method calls the {@link #end()} method. This method is a no-op\n+     * if this decompressor has already been previously closed, either through {@code close()}\n+     * or {@code end()}\n+     * @since 24\n+     *\/\n+    @Override\n+    public void close() {\n+        synchronized (zsRef) {\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n+        }\n+        end();\n+    }\n+\n@@ -744,1 +770,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -748,0 +774,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-        Deflater compressor = new Deflater();\n-        try {\n+        try (Deflater compressor = new Deflater()) {\n@@ -58,3 +57,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the compressor\n-            compressor.end();\n@@ -64,1 +60,0 @@\n-        Inflater decompressor = new Inflater();\n@@ -66,1 +61,1 @@\n-        try {\n+        try (Inflater decompressor = new Inflater()) {\n@@ -86,3 +81,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the decompressor\n-            decompressor.end();\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/snippet-files\/Snippets.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.Deflater;\n+\n+\/**\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Deflater\n+ *\/\n+public class DeflaterClose {\n+\n+    private static final String data = \"foobarhelloworld!!!!\";\n+\n+    private static ByteBuffer generateDeflatedData(final Deflater deflater) {\n+        final byte[] deflatedData = new byte[100];\n+        deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n+        deflater.finish();\n+        final int numCompressed = deflater.deflate(deflatedData);\n+        if (numCompressed == 0) {\n+            throw new RuntimeException(\"Deflater, unexpectedly, expects more input\");\n+        }\n+        return ByteBuffer.wrap(deflatedData, 0, numCompressed);\n+    }\n+\n+    public static void main(final String[] args) throws Exception {\n+        final DeflaterClose self = new DeflaterClose();\n+        self.testCloseOnce();\n+        self.testCloseMultipleTimes();\n+        self.testCloseThenEnd();\n+        self.testEndThenClose();\n+    }\n+\n+    \/**\n+     * Closes Deflater just once and then expects that the close() was called once and so was end()\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseOnce() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        testCloseOnce(simpleDeflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        testCloseOnce(overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        testCloseOnce(overridenEnd);\n+        \/\/ make sure end was called once\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        testCloseOnce(overridenCloseAndEnd);\n+        \/\/ make sure end and close was called once\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+    \/**\n+     * Closes the Deflater more than once and then expects close() to be called that many times\n+     * but end() just once\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Deflater simpleDeflater = new Deflater();\n+        testCloseMultipleTimes(numTimes, simpleDeflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        testCloseMultipleTimes(numTimes, overridenClose);\n+        \/\/ make sure close was called numTimes\n+        if (overridenClose.numTimesCloseCalled != numTimes) {\n+            throw new Exception(\"close() was expected to be called \" + numTimes + \", but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        testCloseMultipleTimes(numTimes, overridenEnd);\n+        \/\/ make sure end was called *only once*\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        testCloseMultipleTimes(numTimes, overridenCloseAndEnd);\n+        \/\/ make sure end was called only once but close was called numTimes\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != numTimes) {\n+            throw new Exception(\"close() was expected to be called \" + numTimes + \", but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+    \/**\n+     * Closes the Deflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseThenEnd() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        testCloseThenEnd(simpleDeflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        testCloseThenEnd(overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        testCloseThenEnd(overridenEnd);\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        if (overridenEnd.numTimesEndCalled != 2) {\n+            throw new Exception(\"end() was expected to be called twice, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        testCloseThenEnd(overridenCloseAndEnd);\n+        \/\/ make sure end was called twice (once through close and once explicitly) and close was called once\n+        if (overridenCloseAndEnd.numTimesEndCalled != 2) {\n+            throw new Exception(\"end() was expected to be called twice, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+    \/**\n+     * Calls end() on the Deflater first and then calls close(). Verifies that close() was called\n+     * just once and end() too was called just once. This check ensures that the latter call to close()\n+     * doesn't end up calling end() again.\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testEndThenClose() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        testEndThenClose(simpleDeflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        testEndThenClose(overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        testEndThenClose(overridenEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close() didn't call it again\n+        \/\/ internally\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        testEndThenClose(overridenCloseAndEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close() didn't call it again\n+        \/\/ internally\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+\n+    private void testCloseOnce(final Deflater deflater) {\n+        \/\/ use the deflater to compress the data\n+        \/\/ and then let it close()\n+        try (final Deflater compressor = deflater) {\n+            generateDeflatedData(compressor);\n+        }\n+    }\n+\n+    private void testCloseMultipleTimes(final int numTimes, final Deflater deflater) {\n+        generateDeflatedData(deflater);\n+        \/\/ call close()\n+        for (int i = 0; i < numTimes; i++) {\n+            deflater.close();\n+        }\n+    }\n+\n+    private void testCloseThenEnd(final Deflater deflater) {\n+        \/\/ deflate the data, let it close() and then end()\n+        try (final Deflater compressor = deflater) {\n+            generateDeflatedData(compressor);\n+        }\n+        deflater.end();\n+    }\n+\n+    private void testEndThenClose(final Deflater deflater) {\n+        \/\/ inflate the data, let it end() and then close()\n+        try (final Deflater compressor = deflater) {\n+            \/\/ end() it first, before it's (auto)closed by the try-with-resources\n+            compressor.end();\n+        }\n+    }\n+\n+    private static final class OverrideEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Deflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/DeflaterClose.java","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+\/**\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Inflater\n+ *\/\n+public class InflaterClose {\n+\n+    private static final String data = \"foobarhelloworld!!!!\";\n+    private static final ByteBuffer deflatedData = generateDeflatedData();\n+\n+    private static ByteBuffer generateDeflatedData() {\n+        final byte[] deflatedData = new byte[100];\n+        try (final Deflater deflater = new Deflater()) {\n+            deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n+            deflater.finish();\n+            final int numCompressed = deflater.deflate(deflatedData);\n+            if (numCompressed == 0) {\n+                throw new RuntimeException(\"Deflater, unexpectedly, expects more input\");\n+            }\n+            return ByteBuffer.wrap(deflatedData, 0, numCompressed);\n+        }\n+    }\n+\n+    public static void main(final String[] args) throws Exception {\n+        final InflaterClose self = new InflaterClose();\n+        self.testCloseOnce();\n+        self.testCloseMultipleTimes();\n+        self.testCloseThenEnd();\n+        self.testEndThenClose();\n+    }\n+\n+    \/**\n+     * Closes Inflater just once and then expects that the close() was called once and so was end()\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseOnce() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        assertValidInflatedData(testCloseOnce(simpleInflater), simpleInflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        assertValidInflatedData(testCloseOnce(overridenClose), overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        assertValidInflatedData(testCloseOnce(overridenEnd), overridenEnd);\n+        \/\/ make sure end was called once\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        assertValidInflatedData(testCloseOnce(overridenCloseAndEnd), overridenCloseAndEnd);\n+        \/\/ make sure end and close was called once\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+    \/**\n+     * Closes the Inflater more than once and then expects close() to be called that many times\n+     * but end() just once\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Inflater simpleInflater = new Inflater();\n+        assertValidInflatedData(testCloseMultipleTimes(numTimes, simpleInflater), simpleInflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        assertValidInflatedData(testCloseMultipleTimes(numTimes, overridenClose), overridenClose);\n+        \/\/ make sure close was called numTimes\n+        if (overridenClose.numTimesCloseCalled != numTimes) {\n+            throw new Exception(\"close() was expected to be called \" + numTimes + \", but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        assertValidInflatedData(testCloseMultipleTimes(numTimes, overridenEnd), overridenEnd);\n+        \/\/ make sure end was called *only once*\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        assertValidInflatedData(testCloseMultipleTimes(numTimes, overridenCloseAndEnd), overridenCloseAndEnd);\n+        \/\/ make sure end was called only once but close was called numTimes\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != numTimes) {\n+            throw new Exception(\"close() was expected to be called \" + numTimes + \", but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+\n+    }\n+\n+    \/**\n+     * Closes the Inflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testCloseThenEnd() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        assertValidInflatedData(testCloseThenEnd(simpleInflater), simpleInflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        assertValidInflatedData(testCloseThenEnd(overridenClose), overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        assertValidInflatedData(testCloseThenEnd(overridenEnd), overridenEnd);\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        if (overridenEnd.numTimesEndCalled != 2) {\n+            throw new Exception(\"end() was expected to be called twice, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        assertValidInflatedData(testCloseThenEnd(overridenCloseAndEnd), overridenCloseAndEnd);\n+        \/\/ make sure end was called twice (once through close and once explicitly) and close was called once\n+        if (overridenCloseAndEnd.numTimesEndCalled != 2) {\n+            throw new Exception(\"end() was expected to be called twice, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+    \/**\n+     * Calls end() on the Inflater first and then calls close(). Verifies that close() was called\n+     * just once and end() too was called just once. This check ensures that the latter call to close()\n+     * doesn't end up calling end() again.\n+     *\n+     * @throws Exception\n+     *\/\n+    private void testEndThenClose() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        assertValidInflatedData(testEndThenClose(simpleInflater), simpleInflater);\n+\n+        final OverrideClose overridenClose = new OverrideClose();\n+        assertValidInflatedData(testEndThenClose(overridenClose), overridenClose);\n+        \/\/ make sure close was called once\n+        if (overridenClose.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenClose.getClass().getName());\n+        }\n+\n+        final OverrideEnd overridenEnd = new OverrideEnd();\n+        assertValidInflatedData(testEndThenClose(overridenEnd), overridenEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close() didn't call it again\n+        \/\/ internally\n+        if (overridenEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenEnd.numTimesEndCalled + \" time(s) on \" + overridenEnd.getClass().getName());\n+        }\n+\n+        final OverrideCloseAndEnd overridenCloseAndEnd = new OverrideCloseAndEnd();\n+        assertValidInflatedData(testEndThenClose(overridenCloseAndEnd), overridenCloseAndEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close() didn't call it again\n+        \/\/ internally\n+        if (overridenCloseAndEnd.numTimesEndCalled != 1) {\n+            throw new Exception(\"end() was expected to be called once, but was called \"\n+                    + overridenCloseAndEnd.numTimesEndCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+        if (overridenCloseAndEnd.numTimesCloseCalled != 1) {\n+            throw new Exception(\"close() was expected to be called once, but was called \"\n+                    + overridenClose.numTimesCloseCalled + \" time(s) on \" + overridenCloseAndEnd.getClass().getName());\n+        }\n+    }\n+\n+\n+    private String testCloseOnce(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData = new byte[data.getBytes(StandardCharsets.UTF_8).length];\n+        \/\/ use the inflater to inflate the data\n+        \/\/ and then let it close()\n+        try (final Inflater inflt = inflater) {\n+            inflt.setInput(deflatedData.asReadOnlyBuffer());\n+            final int numDecompressed = inflt.inflate(inflatedData);\n+            if (numDecompressed == 0) {\n+                throw new Exception(\"Inflater \" + inflt.getClass().getName()\n+                        + \", unexpectedly, expects more input\");\n+            }\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String testCloseMultipleTimes(final int numTimes, final Inflater inflater) throws Exception {\n+        final byte[] inflatedData = new byte[data.getBytes(StandardCharsets.UTF_8).length];\n+        \/\/ use the inflater to inflate the data\n+        inflater.setInput(deflatedData.asReadOnlyBuffer());\n+        final int numDecompressed = inflater.inflate(inflatedData);\n+        if (numDecompressed == 0) {\n+            throw new Exception(\"Inflater \" + inflater.getClass().getName()\n+                    + \", unexpectedly, expects more input\");\n+        }\n+        \/\/ call close()\n+        for (int i = 0; i < numTimes; i++) {\n+            inflater.close();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String testCloseThenEnd(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData = new byte[data.getBytes(StandardCharsets.UTF_8).length];\n+        \/\/ inflate the data, let it close() and then end()\n+        try (final Inflater inflt = inflater) {\n+            inflt.setInput(deflatedData.asReadOnlyBuffer());\n+            final int numDecompressed = inflt.inflate(inflatedData);\n+            if (numDecompressed == 0) {\n+                throw new Exception(\"Inflater \" + inflt.getClass().getName()\n+                        + \", unexpectedly, expects more input\");\n+            }\n+        }\n+        \/\/ end() the already closed inflater\n+        inflater.end();\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String testEndThenClose(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData = new byte[data.getBytes(StandardCharsets.UTF_8).length];\n+        \/\/ inflate the data, let it end() and then close()\n+        try (final Inflater inflt = inflater) {\n+            inflt.setInput(deflatedData.asReadOnlyBuffer());\n+            final int numDecompressed = inflt.inflate(inflatedData);\n+            if (numDecompressed == 0) {\n+                throw new Exception(\"Inflater \" + inflt.getClass().getName()\n+                        + \", unexpectedly, expects more input\");\n+            }\n+            \/\/ end() it first, before it's (auto)closed by the try-with-resources\n+            inflt.end();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private static void assertValidInflatedData(final String inflatedData,\n+                                                final Inflater inflater) throws Exception {\n+        if (!data.equals(inflatedData)) {\n+            throw new Exception(\"Unexpected inflated data \" + inflatedData + \" generated by \"\n+                    + inflater.getClass().getName());\n+        }\n+    }\n+\n+    private static final class OverrideEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Inflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/InflaterClose.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-import java.io.*;\n+\n@@ -43,2 +43,2 @@\n-         Deflater deflater = new Deflater();\n-         Inflater inflater = new Inflater();\n+         try (final Deflater deflater = new Deflater();\n+            final Inflater inflater = new Inflater()) {\n@@ -46,3 +46,3 @@\n-         byte[] dataIn = new byte[BUF_SIZE];\n-         byte[] dataOut = new byte[BUF_SIZE];\n-         byte[] tmp = new byte[BUF_SIZE];\n+             byte[] dataIn = new byte[BUF_SIZE];\n+             byte[] dataOut = new byte[BUF_SIZE];\n+             byte[] tmp = new byte[BUF_SIZE];\n@@ -50,6 +50,6 @@\n-         Random r = new Random();\n-         r.nextBytes(dataIn);\n-         long bytesReadDef    = 0;\n-         long bytesWrittenDef = 0;\n-         long bytesReadInf    = 0;\n-         long bytesWrittenInf = 0;\n+             Random r = new Random();\n+             r.nextBytes(dataIn);\n+             long bytesReadDef = 0;\n+             long bytesWrittenDef = 0;\n+             long bytesReadInf = 0;\n+             long bytesWrittenInf = 0;\n@@ -57,11 +57,11 @@\n-         deflater.setInput(dataIn, 0, dataIn.length);\n-         while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n-             int len = r.nextInt(BUF_SIZE\/2) + BUF_SIZE \/ 2;\n-             if (deflater.needsInput()) {\n-                 bytesReadDef += dataIn.length;\n-                 check(bytesReadDef == deflater.getBytesRead());\n-                 deflater.setInput(dataIn, 0, dataIn.length);\n-             }\n-             int n = deflater.deflate(tmp, 0, len);\n-             bytesWrittenDef += n;\n-             check(bytesWrittenDef == deflater.getBytesWritten());\n+             deflater.setInput(dataIn, 0, dataIn.length);\n+             while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n+                 int len = r.nextInt(BUF_SIZE \/ 2) + BUF_SIZE \/ 2;\n+                 if (deflater.needsInput()) {\n+                     bytesReadDef += dataIn.length;\n+                     check(bytesReadDef == deflater.getBytesRead());\n+                     deflater.setInput(dataIn, 0, dataIn.length);\n+                 }\n+                 int n = deflater.deflate(tmp, 0, len);\n+                 bytesWrittenDef += n;\n+                 check(bytesWrittenDef == deflater.getBytesWritten());\n@@ -69,5 +69,7 @@\n-             inflater.setInput(tmp, 0, n);\n-             bytesReadInf += n;\n-             while (!inflater.needsInput()) {\n-                 bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n-                 check(bytesWrittenInf == inflater.getBytesWritten());\n+                 inflater.setInput(tmp, 0, n);\n+                 bytesReadInf += n;\n+                 while (!inflater.needsInput()) {\n+                     bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n+                     check(bytesWrittenInf == inflater.getBytesWritten());\n+                 }\n+                 check(bytesReadInf == inflater.getBytesRead());\n@@ -75,1 +77,0 @@\n-             check(bytesReadInf == inflater.getBytesRead());\n","filename":"test\/jdk\/java\/util\/zip\/TotalInOut.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"}]}