{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * The input byte sequence is provided in either byte array or byte buffer,\n+ * The input byte sequence is provided in either a byte array or a {@link ByteBuffer},\n@@ -54,1 +54,1 @@\n- * written to the output byte array or byte buffer passed to the\n+ * written to the output byte array or {@code ByteBuffer} passed to the\n@@ -57,4 +57,2 @@\n- * The following code fragment demonstrates a trivial compression\n- * and decompression of a string using {@code Deflater} and\n- * {@code Inflater}.\n- * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n+ * To release the resources used by a {@code Deflater}, an application must close it\n+ * by invoking its {@link #end()} or {@link #close()} method.\n@@ -63,5 +61,9 @@\n- * To release resources used by this {@code Deflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n- * acquired by the subclass. Subclasses that override {@link #finalize()} in order\n- * to perform cleanup should be modified to use alternative cleanup mechanisms such\n- * as {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.\n+ * This class implements {@link AutoCloseable} to facilitate its usage with\n+ * {@code try}-with-resources statement. The {@linkplain Deflater#close() close() method} simply\n+ * calls {@code end()}. Subclasses should override {@linkplain #end()} to clean up the\n+ * resources acquired by the subclass.\n+ *\n+ * <p>\n+ * The following code fragment demonstrates a trivial compression\n+ * and decompression of a string using {@code Deflater} and {@code Inflater}.\n+ * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n@@ -74,1 +76,1 @@\n-public class Deflater {\n+public class Deflater implements AutoCloseable {\n@@ -272,0 +274,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -290,0 +293,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -308,0 +312,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -440,0 +445,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -459,0 +465,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -479,0 +486,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -534,0 +542,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -660,0 +669,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -786,0 +796,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -805,0 +816,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -815,0 +827,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -835,0 +848,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -845,0 +859,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -857,0 +872,1 @@\n+     * @throws IllegalStateException if the Deflater is closed\n@@ -871,1 +887,4 @@\n-     * Closes the compressor and discards any unprocessed input.\n+     * Closes and releases the resources held by this {@code Deflater}\n+     * and discards any unprocessed input.\n+     * <p>\n+     * If the {@code Deflater} is already closed then invoking this method has no effect.\n@@ -873,3 +892,1 @@\n-     * This method should be called when the compressor is no longer\n-     * being used. Once this method is called, the behavior of the\n-     * Deflater object is undefined.\n+     * @see #close()\n@@ -879,0 +896,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -881,0 +902,1 @@\n+            inputArray = null;\n@@ -884,0 +906,12 @@\n+    \/**\n+     * Closes and releases the resources held by this {@code Deflater}\n+     * and discards any unprocessed input.\n+     *\n+     * @implSpec This method calls the {@link #end()} method.\n+     * @since 25\n+     *\/\n+    @Override\n+    public void close() {\n+        end();\n+    }\n+\n@@ -886,2 +920,3 @@\n-        if (zsRef.address() == 0)\n-            throw new NullPointerException(\"Deflater has been closed\");\n+        if (zsRef.address() == 0) {\n+            throw new IllegalStateException(\"Deflater has been closed\");\n+        }\n@@ -931,1 +966,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -935,0 +970,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":56,"deletions":20,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * sequence is provided in either byte array or byte buffer, via one of the\n+ * sequence is provided in either a byte array or a {@link ByteBuffer}, via one of the\n@@ -54,1 +54,1 @@\n- * output byte array or byte buffer passed to the {@code inflate()} methods.\n+ * output byte array or {@code ByteBuffer} passed to the {@code inflate()} methods.\n@@ -56,4 +56,2 @@\n- * The following code fragment demonstrates a trivial compression\n- * and decompression of a string using {@code Deflater} and\n- * {@code Inflater}.\n- * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n+ * To release the resources used by an {@code Inflater}, an application must close it\n+ * by invoking its {@link #end()} or {@link #close()} method.\n@@ -62,5 +60,9 @@\n- * To release resources used by this {@code Inflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n- * acquired by the subclass. Subclasses that override {@link #finalize()} in order\n- * to perform cleanup should be modified to use alternative cleanup mechanisms such\n- * as {@link java.lang.ref.Cleaner} and remove the overriding {@code finalize} method.\n+ * This class implements {@link AutoCloseable} to facilitate its usage with\n+ * {@code try}-with-resources statement. The {@linkplain Inflater#close() close() method} simply\n+ * calls {@code end()}. Subclasses should override {@linkplain #end()} to clean up the\n+ * resources acquired by the subclass.\n+ *\n+ * <p>\n+ * The following code fragment demonstrates a trivial compression\n+ * and decompression of a string using {@code Deflater} and {@code Inflater}.\n+ * {@snippet id=\"compdecomp\" lang=\"java\" class=\"Snippets\" region=\"DeflaterInflaterExample\"}\n@@ -74,1 +76,1 @@\n-public class Inflater {\n+public class Inflater implements AutoCloseable {\n@@ -195,0 +197,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -213,0 +216,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -230,0 +234,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -334,0 +339,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -440,0 +446,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -477,0 +484,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -603,0 +611,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -622,0 +631,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -632,0 +642,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -652,0 +663,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -662,0 +674,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -673,0 +686,1 @@\n+     * @throws IllegalStateException if the Inflater is closed\n@@ -687,1 +701,4 @@\n-     * Closes the decompressor and discards any unprocessed input.\n+     * Closes and releases the resources held by this {@code Inflater}\n+     * and discards any unprocessed input.\n+     * <p>\n+     * If the {@code Inflater} is already closed then invoking this method has no effect.\n@@ -689,3 +706,1 @@\n-     * This method should be called when the decompressor is no longer\n-     * being used. Once this method is called, the behavior of the\n-     * Inflater object is undefined.\n+     * @see #close()\n@@ -695,0 +710,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -702,0 +721,12 @@\n+    \/**\n+     * Closes and releases the resources held by this {@code Inflater}\n+     * and discards any unprocessed input.\n+     *\n+     * @implSpec This method calls the {@link #end()} method.\n+     * @since 25\n+     *\/\n+    @Override\n+    public void close() {\n+        end();\n+    }\n+\n@@ -704,2 +735,3 @@\n-        if (zsRef.address() == 0)\n-            throw new NullPointerException(\"Inflater has been closed\");\n+        if (zsRef.address() == 0) {\n+            throw new IllegalStateException(\"Inflater has been closed\");\n+        }\n@@ -740,1 +772,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -744,0 +776,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":53,"deletions":20,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-        Deflater compressor = new Deflater();\n-        try {\n+        try (Deflater compressor = new Deflater()) {\n@@ -58,3 +57,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the compressor\n-            compressor.end();\n@@ -64,1 +60,0 @@\n-        Inflater decompressor = new Inflater();\n@@ -66,1 +61,1 @@\n-        try {\n+        try (Inflater decompressor = new Inflater()) {\n@@ -86,3 +81,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the decompressor\n-            decompressor.end();\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/snippet-files\/Snippets.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-        \/\/ Write on a closed GZIPOutputStream, closed Deflater IOException expected\n-        assertThrows(NullPointerException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Write on a closed GZIPOutputStream, closed Deflater IllegalStateException expected\n+        assertThrows(IllegalStateException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n@@ -152,2 +152,2 @@\n-        \/\/ Write on a closed DeflaterOutputStream, 'Deflater has been closed' NPE is expected\n-        assertThrows(NullPointerException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Write on a closed DeflaterOutputStream, IllegalStateException is expected\n+        assertThrows(IllegalStateException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n@@ -205,2 +205,2 @@\n-        \/\/ Write on a closed ZipOutputStream , 'Deflater has been closed' NPE is expected\n-        assertThrows(NullPointerException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Write on a closed ZipOutputStream , IllegalStateException is expected\n+        assertThrows(IllegalStateException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n","filename":"test\/jdk\/java\/util\/zip\/CloseInflaterDeflaterTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.Deflater;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Deflater\n+ * @run junit DeflaterClose\n+ *\/\n+public class DeflaterClose {\n+\n+    private static final String data = \"foobarhelloworld!!!!\";\n+\n+    \/**\n+     * Closes the Deflater multiple times and then expects close() and end() each\n+     * to be called that many times.\n+     *\/\n+    @Test\n+    public void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Deflater simpleDeflater = new Deflater();\n+        closeMultipleTimesAfterCompressing(numTimes, simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenClose);\n+        \/\/ make sure close was called numTimes\n+        assertEquals(numTimes, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called \" + numTimes + \", but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenEnd);\n+        \/\/ make sure end was called called numTimes\n+        assertEquals(numTimes, overriddenEnd.numTimesEndCalled, \"end() was expected to be called \" +\n+                numTimes + \", but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \" +\n+                overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenCloseAndEnd);\n+        \/\/ make sure end was called called numTimes\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called \" +\n+                numTimes + \", but was called\" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected\" +\n+                \" to be called \" + numTimes + \", but was called \" +\n+                overriddenClose.numTimesCloseCalled + \" time(s) on \" +\n+                overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Closes the Deflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\/\n+    @Test\n+    public void testCloseThenEnd() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        compressCloseThenEnd(simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        compressCloseThenEnd(overriddenClose);\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        compressCloseThenEnd(overriddenEnd);\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        compressCloseThenEnd(overriddenCloseAndEnd);\n+        \/\/ make sure end was called twice (once through close and once explicitly)\n+        \/\/ and close was called once\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to\" +\n+                \" be called twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Calls end() on the Deflater first and then calls close(). Verifies that close() was called\n+     * just once and end() twice.\n+     *\/\n+    @Test\n+    public void testEndThenClose() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        compressEndThenClose(simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        compressEndThenClose(overriddenClose);\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        compressEndThenClose(overriddenEnd);\n+        \/\/ make sure end was called twice (once through the explicit end call and\n+        \/\/ once through close())\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called twice,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        compressEndThenClose(overriddenCloseAndEnd);\n+        \/\/ make sure end was called twice (once through the explicit end call and\n+        \/\/ once through close())\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be \" +\n+                \"called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    private void closeMultipleTimesAfterCompressing(final int numTimes, final Deflater deflater) {\n+        compress(deflater);\n+        \/\/ call close() multiple times\n+        for (int i = 0; i < numTimes; i++) {\n+            deflater.close();\n+        }\n+    }\n+\n+    private void compressCloseThenEnd(final Deflater deflater) {\n+        \/\/ compress the data then close() and then end()\n+        try (final Deflater compressor = deflater) {\n+            compress(compressor);\n+        }\n+        deflater.end();\n+    }\n+\n+    private void compressEndThenClose(final Deflater deflater) {\n+        \/\/ compress the data then end() and then close()\n+        try (final Deflater compressor = deflater) {\n+            compress(compressor);\n+            \/\/ end() it first before it's (auto)closed by the try-with-resources\n+            compressor.end();\n+        }\n+    }\n+\n+    private static byte[] compress(final Deflater deflater) {\n+        deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n+        deflater.finish();\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        while (!deflater.finished()) {\n+            final byte[] tmpBuffer = new byte[100];\n+            final int numCompressed = deflater.deflate(tmpBuffer);\n+            compressedBaos.write(tmpBuffer, 0, numCompressed);\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    private static final class OverrideEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Deflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/DeflaterClose.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Inflater\n+ * @run junit InflaterClose\n+ *\/\n+public class InflaterClose {\n+\n+    private static final String originalStr = \"foobarhelloworld!!!!\";\n+    private static final byte[] originalBytes = originalStr.getBytes(US_ASCII);\n+    private static final byte[] compressedData = compress();\n+\n+    \/**\n+     * Closes the Inflater multiple times and then expects close() and end() to be called that\n+     * many times.\n+     *\/\n+    @Test\n+    public void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = closeMultipleTimesAfterInflating(numTimes, simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = closeMultipleTimesAfterInflating(numTimes, overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called numTimes\n+        assertEquals(numTimes, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called \" + numTimes + \", but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = closeMultipleTimesAfterInflating(numTimes, overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called called numTimes\n+        assertEquals(numTimes, overriddenEnd.numTimesEndCalled, \"end() was expected to be called \" +\n+                numTimes + \", but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \" +\n+                overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = closeMultipleTimesAfterInflating(numTimes,\n+                overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called called numTimes\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected\" +\n+                \" to be called \" + numTimes + \", but was called \" +\n+                overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected\" +\n+                \" to be called \" + numTimes + \", but was called \" +\n+                overriddenCloseAndEnd.numTimesCloseCalled + \" time(s) on \" +\n+                overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Closes the Inflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\/\n+    @Test\n+    public void testCloseThenEnd() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = inflateCloseThenEnd(simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = inflateCloseThenEnd(overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled + \" time(s) on \"\n+                + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = inflateCloseThenEnd(overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called twice,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \"\n+                + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = inflateCloseThenEnd(overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called twice (once through close and once explicitly)\n+        \/\/ and close was called once\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled\n+                + \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled\n+                + \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Calls end() on the Inflater first and then calls close(). Verifies that close() was called\n+     * just once and end() twice.\n+     *\/\n+    @Test\n+    public void testEndThenClose() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = inflateThenEndThenClose(simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = inflateThenEndThenClose(overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = inflateThenEndThenClose(overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called twice (once through the explicit end call and\n+        \/\/ once through close())\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called twice,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \"\n+                + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = inflateThenEndThenClose(overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called twice (once through the explicit end call and\n+        \/\/ once through close())\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+\n+    private String closeMultipleTimesAfterInflating(final int numTimes, final Inflater inflater)\n+            throws DataFormatException {\n+        \/\/ inflate() then call close() multiple times\n+        final byte[] inflatedData = inflate(inflater, compressedData);\n+        \/\/ call close()\n+        for (int i = 0; i < numTimes; i++) {\n+            inflater.close();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String inflateCloseThenEnd(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData;\n+        \/\/ inflate then close() and then end()\n+        try (final Inflater inflt = inflater) {\n+            inflatedData = inflate(inflt, compressedData);\n+        }\n+        \/\/ end() the already closed inflater\n+        inflater.end();\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String inflateThenEndThenClose(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData;\n+        \/\/ inflate then end() and then close()\n+        try (final Inflater inflt = inflater) {\n+            inflatedData = inflate(inflt, compressedData);\n+            \/\/ end() it first before it's (auto)closed by the try-with-resources\n+            inflt.end();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private static byte[] inflate(final Inflater inflater, final byte[] compressedData)\n+            throws DataFormatException {\n+        final ByteArrayOutputStream inflatedData = new ByteArrayOutputStream();\n+        inflater.setInput(compressedData);\n+        while (!inflater.finished()) {\n+            byte[] tmpBuffer = new byte[100];\n+            final int numDecompressed = inflater.inflate(tmpBuffer);\n+            inflatedData.write(tmpBuffer, 0, numDecompressed);\n+        }\n+        return inflatedData.toByteArray();\n+    }\n+\n+    private static byte[] compress() {\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        try (final Deflater deflater = new Deflater()) {\n+            deflater.setInput(originalBytes);\n+            deflater.finish();\n+            while (!deflater.finished()) {\n+                final byte[] tmpBuffer = new byte[100];\n+                final int numCompressed = deflater.deflate(tmpBuffer);\n+                compressedBaos.write(tmpBuffer, 0, numCompressed);\n+            }\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    private static void assertValidInflatedData(final String inflatedData,\n+                                                final Class<?> inflaterType) {\n+        assertEquals(originalStr, inflatedData, \"Unexpected inflated data \" + inflatedData\n+                + \" generated by \" + inflaterType.getName() + \", expected \" + originalStr);\n+    }\n+\n+    private static final class OverrideEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Inflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/InflaterClose.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-import java.io.*;\n+\n@@ -43,2 +43,2 @@\n-         Deflater deflater = new Deflater();\n-         Inflater inflater = new Inflater();\n+         try (final Deflater deflater = new Deflater();\n+            final Inflater inflater = new Inflater()) {\n@@ -46,3 +46,3 @@\n-         byte[] dataIn = new byte[BUF_SIZE];\n-         byte[] dataOut = new byte[BUF_SIZE];\n-         byte[] tmp = new byte[BUF_SIZE];\n+             byte[] dataIn = new byte[BUF_SIZE];\n+             byte[] dataOut = new byte[BUF_SIZE];\n+             byte[] tmp = new byte[BUF_SIZE];\n@@ -50,6 +50,6 @@\n-         Random r = new Random();\n-         r.nextBytes(dataIn);\n-         long bytesReadDef    = 0;\n-         long bytesWrittenDef = 0;\n-         long bytesReadInf    = 0;\n-         long bytesWrittenInf = 0;\n+             Random r = new Random();\n+             r.nextBytes(dataIn);\n+             long bytesReadDef = 0;\n+             long bytesWrittenDef = 0;\n+             long bytesReadInf = 0;\n+             long bytesWrittenInf = 0;\n@@ -57,11 +57,11 @@\n-         deflater.setInput(dataIn, 0, dataIn.length);\n-         while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n-             int len = r.nextInt(BUF_SIZE\/2) + BUF_SIZE \/ 2;\n-             if (deflater.needsInput()) {\n-                 bytesReadDef += dataIn.length;\n-                 check(bytesReadDef == deflater.getBytesRead());\n-                 deflater.setInput(dataIn, 0, dataIn.length);\n-             }\n-             int n = deflater.deflate(tmp, 0, len);\n-             bytesWrittenDef += n;\n-             check(bytesWrittenDef == deflater.getBytesWritten());\n+             deflater.setInput(dataIn, 0, dataIn.length);\n+             while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n+                 int len = r.nextInt(BUF_SIZE \/ 2) + BUF_SIZE \/ 2;\n+                 if (deflater.needsInput()) {\n+                     bytesReadDef += dataIn.length;\n+                     check(bytesReadDef == deflater.getBytesRead());\n+                     deflater.setInput(dataIn, 0, dataIn.length);\n+                 }\n+                 int n = deflater.deflate(tmp, 0, len);\n+                 bytesWrittenDef += n;\n+                 check(bytesWrittenDef == deflater.getBytesWritten());\n@@ -69,5 +69,7 @@\n-             inflater.setInput(tmp, 0, n);\n-             bytesReadInf += n;\n-             while (!inflater.needsInput()) {\n-                 bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n-                 check(bytesWrittenInf == inflater.getBytesWritten());\n+                 inflater.setInput(tmp, 0, n);\n+                 bytesReadInf += n;\n+                 while (!inflater.needsInput()) {\n+                     bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n+                     check(bytesWrittenInf == inflater.getBytesWritten());\n+                 }\n+                 check(bytesReadInf == inflater.getBytesRead());\n@@ -75,1 +77,0 @@\n-             check(bytesReadInf == inflater.getBytesRead());\n","filename":"test\/jdk\/java\/util\/zip\/TotalInOut.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"}]}