{"files":[{"patch":"@@ -63,2 +63,2 @@\n- * To release resources used by this {@code Deflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n+ * To release resources used by this {@code Deflater}, the {@link #close()} method\n+ * should be used. Subclasses are responsible for the cleanup of resources\n@@ -74,1 +74,1 @@\n-public class Deflater {\n+public class Deflater implements AutoCloseable {\n@@ -875,2 +875,4 @@\n-     * being used. Once this method is called, the behavior of the\n-     * Deflater object is undefined.\n+     * being used. Once this method is called, further operations using\n+     * this Deflater may throw an exception.\n+     *\n+     * @see #close()\n@@ -880,0 +882,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -882,0 +888,20 @@\n+            inputArray = null;\n+        }\n+    }\n+\n+    \/**\n+     * Releases resources held by this compressor and discards any unprocessed input.\n+     * This method should be called when the compressor is no longer needed.\n+     *\n+     * @implNote This method calls the {@link #end()} method. This method is a no-op\n+     * if this compressor has already been previously closed, either through {@code close()}\n+     * or {@code end()}\n+     * @since 24\n+     *\/\n+    @Override\n+    public void close() {\n+        synchronized (zsRef) {\n+            \/\/ check if we are already closed to avoid calling end() more than once\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -883,0 +909,1 @@\n+        end();\n@@ -932,1 +959,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -936,0 +963,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n- * To release resources used by this {@code Inflater}, the {@link #end()} method\n- * should be called explicitly. Subclasses are responsible for the cleanup of resources\n+ * To release resources used by this {@code Inflater}, the {@link #close()} method\n+ * should be used. Subclasses are responsible for the cleanup of resources\n@@ -74,1 +74,1 @@\n-public class Inflater {\n+public class Inflater implements AutoCloseable {\n@@ -694,2 +694,4 @@\n-     * being used. Once this method is called, the behavior of the\n-     * Inflater object is undefined.\n+     * being used. Once this method is called, further operations using\n+     * this Inflater may throw an exception.\n+     *\n+     * @see #close()\n@@ -699,0 +701,4 @@\n+            \/\/ check if already closed\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n@@ -706,0 +712,20 @@\n+    \/**\n+     * Releases resources held by this decompressor and discards any unprocessed input.\n+     * This method should be called when the decompressor is no longer needed.\n+     *\n+     * @implNote This method calls the {@link #end()} method. This method is a no-op\n+     * if this decompressor has already been previously closed, either through {@code close()}\n+     * or {@code end()}\n+     * @since 24\n+     *\/\n+    @Override\n+    public void close() {\n+        synchronized (zsRef) {\n+            \/\/ check if we are already closed to avoid calling end() more than once\n+            if (zsRef.address() == 0) {\n+                return;\n+            }\n+        }\n+        end();\n+    }\n+\n@@ -744,1 +770,1 @@\n-        private long address;\n+        private long address; \/\/ will be a non-zero value when the native resource is in use\n@@ -748,0 +774,1 @@\n+            assert addr != 0 : \"native address is 0\";\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-        Deflater compressor = new Deflater();\n-        try {\n+        try (Deflater compressor = new Deflater()) {\n@@ -58,3 +57,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the compressor\n-            compressor.end();\n@@ -64,1 +60,0 @@\n-        Inflater decompressor = new Inflater();\n@@ -66,1 +61,1 @@\n-        try {\n+        try (Inflater decompressor = new Inflater()) {\n@@ -86,3 +81,0 @@\n-        } finally {\n-            \/\/ Release the resources held by the decompressor\n-            decompressor.end();\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/snippet-files\/Snippets.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.Deflater;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Deflater\n+ * @run junit DeflaterClose\n+ *\/\n+public class DeflaterClose {\n+\n+    private static final String data = \"foobarhelloworld!!!!\";\n+\n+    \/**\n+     * Closes Deflater just once and then expects that the close() was called once and so was end()\n+     *\/\n+    @Test\n+    public void testCloseOnce() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        closeOnceAfterCompressing(simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        closeOnceAfterCompressing(overriddenClose);\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        closeOnceAfterCompressing(overriddenEnd);\n+        \/\/ make sure end was called once\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be called once,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \" +\n+                overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        closeOnceAfterCompressing(overriddenCloseAndEnd);\n+        \/\/ make sure end and close was called once\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Closes the Deflater more than once and then expects close() to be called that many times\n+     * but end() just once\n+     *\/\n+    @Test\n+    public void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Deflater simpleDeflater = new Deflater();\n+        closeMultipleTimesAfterCompressing(numTimes, simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenClose);\n+        \/\/ make sure close was called numTimes\n+        assertEquals(numTimes, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called \" + numTimes + \", but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenEnd);\n+        \/\/ make sure end was called *only once*\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be called once,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \" +\n+                overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        closeMultipleTimesAfterCompressing(numTimes, overriddenCloseAndEnd);\n+        \/\/ make sure end was called only once but close was called numTimes\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected\" +\n+                \" to be called \" + numTimes + \", but was called \" +\n+                overriddenClose.numTimesCloseCalled + \" time(s) on \" +\n+                overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Closes the Deflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\/\n+    @Test\n+    public void testCloseThenEnd() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        compressCloseThenEnd(simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        compressCloseThenEnd(overriddenClose);\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        compressCloseThenEnd(overriddenEnd);\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        compressCloseThenEnd(overriddenCloseAndEnd);\n+        \/\/ make sure end was called twice (once through close and once explicitly)\n+        \/\/ and close was called once\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to\" +\n+                \" be called twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Calls end() on the Deflater first and then calls close(). Verifies that close() was called\n+     * just once and end() too was called just once. This check ensures that the latter call\n+     * to close() doesn't end up calling end() again.\n+     *\/\n+    @Test\n+    public void testEndThenClose() throws Exception {\n+        final Deflater simpleDeflater = new Deflater();\n+        compressEndThenClose(simpleDeflater);\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        compressEndThenClose(overriddenClose);\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        compressEndThenClose(overriddenEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close()\n+        \/\/ didn't call it again internally\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be called once,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        compressEndThenClose(overriddenCloseAndEnd);\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close()\n+        \/\/ didn't call it again internally\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be \" +\n+                \"called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    private void closeOnceAfterCompressing(final Deflater deflater) {\n+        \/\/ compress the data and then close()\n+        try (final Deflater compressor = deflater) {\n+            compress(compressor);\n+        }\n+    }\n+\n+    private void closeMultipleTimesAfterCompressing(final int numTimes, final Deflater deflater) {\n+        compress(deflater);\n+        \/\/ call close() multiple times\n+        for (int i = 0; i < numTimes; i++) {\n+            deflater.close();\n+        }\n+    }\n+\n+    private void compressCloseThenEnd(final Deflater deflater) {\n+        \/\/ compress the data then close() and then end()\n+        try (final Deflater compressor = deflater) {\n+            compress(compressor);\n+        }\n+        deflater.end();\n+    }\n+\n+    private void compressEndThenClose(final Deflater deflater) {\n+        \/\/ compress the data then end() and then close()\n+        try (final Deflater compressor = deflater) {\n+            compress(compressor);\n+            \/\/ end() it first before it's (auto)closed by the try-with-resources\n+            compressor.end();\n+        }\n+    }\n+\n+    private static byte[] compress(final Deflater deflater) {\n+        deflater.setInput(data.getBytes(StandardCharsets.UTF_8));\n+        deflater.finish();\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        while (!deflater.finished()) {\n+            final byte[] tmpBuffer = new byte[100];\n+            final int numCompressed = deflater.deflate(tmpBuffer);\n+            compressedBaos.write(tmpBuffer, 0, numCompressed);\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    private static final class OverrideEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Deflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Deflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/DeflaterClose.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.DataFormatException;\n+import java.util.zip.Deflater;\n+import java.util.zip.Inflater;\n+\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8225763\n+ * @summary Test that the close() and end() methods on java.util.zip.Inflater\n+ * @run junit InflaterClose\n+ *\/\n+public class InflaterClose {\n+\n+    private static final String originalStr = \"foobarhelloworld!!!!\";\n+    private static final byte[] originalBytes = originalStr.getBytes(US_ASCII);\n+    private static final byte[] compressedData = compress();\n+\n+    \/**\n+     * Closes Inflater just once and then expects that the close() was called once and so was end()\n+     *\/\n+    @Test\n+    public void testCloseOnce() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflated = closeOnceAfterInflating(simpleInflater);\n+        assertValidInflatedData(inflated, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = closeOnceAfterInflating(overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close() was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = closeOnceAfterInflating(overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end() was called once\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be\" +\n+                \" called once, but was called \" + overriddenEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenEnd.getClass());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = closeOnceAfterInflating(overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end() and close() were called once each\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be\" +\n+                \" called once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenCloseAndEnd.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass());\n+    }\n+\n+    \/**\n+     * Closes the Inflater more than once and then expects close() to be called that many times\n+     * but end() just once\n+     *\/\n+    @Test\n+    public void testCloseMultipleTimes() throws Exception {\n+        final int numTimes = 3;\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = closeMultipleTimesAfterInflating(numTimes, simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = closeMultipleTimesAfterInflating(numTimes, overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called numTimes\n+        assertEquals(numTimes, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called \" + numTimes + \", but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = closeMultipleTimesAfterInflating(numTimes, overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called *only once*\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be called once,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \" +\n+                overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = closeMultipleTimesAfterInflating(numTimes,\n+                overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called only once but close was called numTimes\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be\" +\n+                \" called once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(numTimes, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected\" +\n+                \" to be called \" + numTimes + \", but was called \" +\n+                overriddenCloseAndEnd.numTimesCloseCalled + \" time(s) on \" +\n+                overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Closes the Inflater first and then calls end(). Verifies that close() was called\n+     * just once but end() was called twice (once internally through close() and once\n+     * explicitly)\n+     *\/\n+    @Test\n+    public void testCloseThenEnd() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = inflateCloseThenEnd(simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = inflateCloseThenEnd(overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be called\" +\n+                \" once, but was called \" + overriddenClose.numTimesCloseCalled + \" time(s) on \"\n+                + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = inflateCloseThenEnd(overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called twice (once through close() and then explicitly)\n+        assertEquals(2, overriddenEnd.numTimesEndCalled, \"end() was expected to be called twice,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \"\n+                + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = inflateCloseThenEnd(overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called twice (once through close and once explicitly)\n+        \/\/ and close was called once\n+        assertEquals(2, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" twice, but was called \" + overriddenCloseAndEnd.numTimesEndCalled\n+                + \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled\n+                + \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+    \/**\n+     * Calls end() on the Inflater first and then calls close(). Verifies that close() was called\n+     * just once and end() too was called just once. This check ensures that the latter call to\n+     * close() doesn't end up calling end() again.\n+     *\/\n+    @Test\n+    public void testEndThenClose() throws Exception {\n+        final Inflater simpleInflater = new Inflater();\n+        final String inflatedData = inflateThenEndThenClose(simpleInflater);\n+        assertValidInflatedData(inflatedData, simpleInflater.getClass());\n+\n+        final OverrideClose overriddenClose = new OverrideClose();\n+        final String ocInflatedData = inflateThenEndThenClose(overriddenClose);\n+        assertValidInflatedData(ocInflatedData, overriddenClose.getClass());\n+        \/\/ make sure close was called once\n+        assertEquals(1, overriddenClose.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenClose.getClass().getName());\n+\n+        final OverrideEnd overriddenEnd = new OverrideEnd();\n+        final String oeInflatedData = inflateThenEndThenClose(overriddenEnd);\n+        assertValidInflatedData(oeInflatedData, overriddenEnd.getClass());\n+        \/\/ make sure end was called *only once* (through the explicit end call)\n+        \/\/ and close() didn't call it again internally\n+        assertEquals(1, overriddenEnd.numTimesEndCalled, \"end() was expected to be called once,\" +\n+                \" but was called \" + overriddenEnd.numTimesEndCalled + \" time(s) on \"\n+                + overriddenEnd.getClass().getName());\n+\n+        final OverrideCloseAndEnd overriddenCloseAndEnd = new OverrideCloseAndEnd();\n+        final String oceInflatedData = inflateThenEndThenClose(overriddenCloseAndEnd);\n+        assertValidInflatedData(oceInflatedData, overriddenCloseAndEnd.getClass());\n+        \/\/ make sure end was called *only once* (through the explicit end call) and close()\n+        \/\/ didn't call it again internally\n+        assertEquals(1, overriddenCloseAndEnd.numTimesEndCalled, \"end() was expected to be called\" +\n+                \" once, but was called \" + overriddenCloseAndEnd.numTimesEndCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+        assertEquals(1, overriddenCloseAndEnd.numTimesCloseCalled, \"close() was expected to be\" +\n+                \" called once, but was called \" + overriddenClose.numTimesCloseCalled +\n+                \" time(s) on \" + overriddenCloseAndEnd.getClass().getName());\n+    }\n+\n+\n+    private String closeOnceAfterInflating(final Inflater inflater) throws DataFormatException {\n+        final byte[] inflatedData;\n+        \/\/ inflate() then close\n+        try (final Inflater inflt = inflater) {\n+            inflatedData = inflate(inflt, compressedData);\n+        }\n+        return new String(inflatedData, US_ASCII);\n+    }\n+\n+    private String closeMultipleTimesAfterInflating(final int numTimes, final Inflater inflater)\n+            throws DataFormatException {\n+        \/\/ inflate() then call close() multiple times\n+        final byte[] inflatedData = inflate(inflater, compressedData);\n+        \/\/ call close()\n+        for (int i = 0; i < numTimes; i++) {\n+            inflater.close();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String inflateCloseThenEnd(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData;\n+        \/\/ inflate then close() and then end()\n+        try (final Inflater inflt = inflater) {\n+            inflatedData = inflate(inflt, compressedData);\n+        }\n+        \/\/ end() the already closed inflater\n+        inflater.end();\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private String inflateThenEndThenClose(final Inflater inflater) throws Exception {\n+        final byte[] inflatedData;\n+        \/\/ inflate then end() and then close()\n+        try (final Inflater inflt = inflater) {\n+            inflatedData = inflate(inflt, compressedData);\n+            \/\/ end() it first before it's (auto)closed by the try-with-resources\n+            inflt.end();\n+        }\n+        return new String(inflatedData, StandardCharsets.UTF_8);\n+    }\n+\n+    private static byte[] inflate(final Inflater inflater, final byte[] compressedData)\n+            throws DataFormatException {\n+        final ByteArrayOutputStream inflatedData = new ByteArrayOutputStream();\n+        inflater.setInput(compressedData);\n+        while (!inflater.finished()) {\n+            byte[] tmpBuffer = new byte[100];\n+            final int numDecompressed = inflater.inflate(tmpBuffer);\n+            inflatedData.write(tmpBuffer, 0, numDecompressed);\n+        }\n+        return inflatedData.toByteArray();\n+    }\n+\n+    private static byte[] compress() {\n+        final ByteArrayOutputStream compressedBaos = new ByteArrayOutputStream();\n+        try (final Deflater deflater = new Deflater()) {\n+            deflater.setInput(originalBytes);\n+            deflater.finish();\n+            while (!deflater.finished()) {\n+                final byte[] tmpBuffer = new byte[100];\n+                final int numCompressed = deflater.deflate(tmpBuffer);\n+                compressedBaos.write(tmpBuffer, 0, numCompressed);\n+            }\n+        }\n+        return compressedBaos.toByteArray();\n+    }\n+\n+    private static void assertValidInflatedData(final String inflatedData,\n+                                                final Class<?> inflaterType) {\n+        assertEquals(originalStr, inflatedData, \"Unexpected inflated data \" + inflatedData\n+                + \" generated by \" + inflaterType.getName() + \", expected \" + originalStr);\n+    }\n+\n+    private static final class OverrideEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+    }\n+\n+    private static final class OverrideClose extends Inflater {\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+\n+    private static final class OverrideCloseAndEnd extends Inflater {\n+        private int numTimesEndCalled = 0;\n+        private int numTimesCloseCalled = 0;\n+\n+        @Override\n+        public void end() {\n+            this.numTimesEndCalled++;\n+            super.end();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.numTimesCloseCalled++;\n+            super.close();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/InflaterClose.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-import java.io.*;\n+\n@@ -43,2 +43,2 @@\n-         Deflater deflater = new Deflater();\n-         Inflater inflater = new Inflater();\n+         try (final Deflater deflater = new Deflater();\n+            final Inflater inflater = new Inflater()) {\n@@ -46,3 +46,3 @@\n-         byte[] dataIn = new byte[BUF_SIZE];\n-         byte[] dataOut = new byte[BUF_SIZE];\n-         byte[] tmp = new byte[BUF_SIZE];\n+             byte[] dataIn = new byte[BUF_SIZE];\n+             byte[] dataOut = new byte[BUF_SIZE];\n+             byte[] tmp = new byte[BUF_SIZE];\n@@ -50,6 +50,6 @@\n-         Random r = new Random();\n-         r.nextBytes(dataIn);\n-         long bytesReadDef    = 0;\n-         long bytesWrittenDef = 0;\n-         long bytesReadInf    = 0;\n-         long bytesWrittenInf = 0;\n+             Random r = new Random();\n+             r.nextBytes(dataIn);\n+             long bytesReadDef = 0;\n+             long bytesWrittenDef = 0;\n+             long bytesReadInf = 0;\n+             long bytesWrittenInf = 0;\n@@ -57,11 +57,11 @@\n-         deflater.setInput(dataIn, 0, dataIn.length);\n-         while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n-             int len = r.nextInt(BUF_SIZE\/2) + BUF_SIZE \/ 2;\n-             if (deflater.needsInput()) {\n-                 bytesReadDef += dataIn.length;\n-                 check(bytesReadDef == deflater.getBytesRead());\n-                 deflater.setInput(dataIn, 0, dataIn.length);\n-             }\n-             int n = deflater.deflate(tmp, 0, len);\n-             bytesWrittenDef += n;\n-             check(bytesWrittenDef == deflater.getBytesWritten());\n+             deflater.setInput(dataIn, 0, dataIn.length);\n+             while (bytesReadDef < dataSize || bytesWrittenInf < dataSize) {\n+                 int len = r.nextInt(BUF_SIZE \/ 2) + BUF_SIZE \/ 2;\n+                 if (deflater.needsInput()) {\n+                     bytesReadDef += dataIn.length;\n+                     check(bytesReadDef == deflater.getBytesRead());\n+                     deflater.setInput(dataIn, 0, dataIn.length);\n+                 }\n+                 int n = deflater.deflate(tmp, 0, len);\n+                 bytesWrittenDef += n;\n+                 check(bytesWrittenDef == deflater.getBytesWritten());\n@@ -69,5 +69,7 @@\n-             inflater.setInput(tmp, 0, n);\n-             bytesReadInf += n;\n-             while (!inflater.needsInput()) {\n-                 bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n-                 check(bytesWrittenInf == inflater.getBytesWritten());\n+                 inflater.setInput(tmp, 0, n);\n+                 bytesReadInf += n;\n+                 while (!inflater.needsInput()) {\n+                     bytesWrittenInf += inflater.inflate(dataOut, 0, dataOut.length);\n+                     check(bytesWrittenInf == inflater.getBytesWritten());\n+                 }\n+                 check(bytesReadInf == inflater.getBytesRead());\n@@ -75,1 +77,0 @@\n-             check(bytesReadInf == inflater.getBytesRead());\n","filename":"test\/jdk\/java\/util\/zip\/TotalInOut.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"}]}