{"files":[{"patch":"@@ -318,2 +318,1 @@\n-            StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,\n-                                        advance);\n+            StrikeCache.setGlyphXAdvance(ptr, advance);\n@@ -668,2 +667,1 @@\n-                advance = StrikeCache.unsafe.getFloat\n-                    (glyphPtr + StrikeCache.xAdvanceOffset);\n+                advance = StrikeCache.getGlyphXAdvance(glyphPtr);\n@@ -729,2 +727,2 @@\n-        topLeftX = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftXOffset);\n-        topLeftY = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftYOffset);\n+        topLeftX = StrikeCache.getGlyphTopLeftX(ptr);\n+        topLeftY = StrikeCache.getGlyphTopLeftY(ptr);\n@@ -734,4 +732,2 @@\n-        result.width =\n-            StrikeCache.unsafe.getShort(ptr+StrikeCache.widthOffset)  &0x0ffff;\n-        result.height =\n-            StrikeCache.unsafe.getShort(ptr+StrikeCache.heightOffset) &0x0ffff;\n+        result.width = StrikeCache.getGlyphWidth(ptr) & 0x0ffff;\n+        result.height = StrikeCache.getGlyphHeight(ptr) & 0x0ffff;\n@@ -758,4 +754,3 @@\n-        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);\n-        int height = StrikeCache.unsafe.getChar(ptr+StrikeCache.heightOffset);\n-        int rowBytes =\n-            StrikeCache.unsafe.getChar(ptr+StrikeCache.rowBytesOffset);\n+        int width = StrikeCache.getGlyphWidth(ptr);\n+        int height = StrikeCache.getGlyphHeight(ptr);\n+        int rowBytes = StrikeCache.getGlyphRowBytes(ptr);\n@@ -767,4 +762,1 @@\n-        long pixelData =\n-            StrikeCache.unsafe.getAddress(ptr + StrikeCache.pixelDataOffset);\n-\n-        if (pixelData == 0L) {\n+        if (StrikeCache.getGlyphImagePtr(ptr) == 0L) {\n@@ -774,0 +766,1 @@\n+        byte[] pixelData = StrikeCache.getGlyphPixelBytes(ptr);\n@@ -776,1 +769,1 @@\n-                if (StrikeCache.unsafe.getByte(pixelData+y*rowBytes+x) != 0) {\n+                if (pixelData[(y*rowBytes)+x] != 0) {\n@@ -822,4 +815,2 @@\n-            metrics.x = StrikeCache.unsafe.getFloat\n-                (glyphPtr + StrikeCache.xAdvanceOffset);\n-            metrics.y = StrikeCache.unsafe.getFloat\n-                (glyphPtr + StrikeCache.yAdvanceOffset);\n+            metrics.x = StrikeCache.getGlyphXAdvance(glyphPtr);\n+            metrics.y = StrikeCache.getGlyphYAdvance(glyphPtr);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -322,4 +322,3 @@\n-        float gx =\n-            StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftXOffset);\n-        float gy =\n-            StrikeCache.unsafe.getFloat(images[i]+StrikeCache.topLeftYOffset);\n+\n+        float gx = StrikeCache.getGlyphTopLeftX(images[i]);\n+        float gy = StrikeCache.getGlyphTopLeftY(images[i]);\n@@ -334,4 +333,2 @@\n-            gposx += StrikeCache.unsafe.getFloat\n-                (images[i]+StrikeCache.xAdvanceOffset);\n-            gposy += StrikeCache.unsafe.getFloat\n-                (images[i]+StrikeCache.yAdvanceOffset);\n+            gposx += StrikeCache.getGlyphXAdvance(images[i]);\n+            gposy += StrikeCache.getGlyphYAdvance(images[i]);\n@@ -339,6 +336,3 @@\n-        metrics[2] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.widthOffset);\n-        metrics[3] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.heightOffset);\n-        metrics[4] =\n-            StrikeCache.unsafe.getChar(images[i]+StrikeCache.rowBytesOffset);\n+        metrics[2] = StrikeCache.getGlyphWidth(images[i]);\n+        metrics[3] = StrikeCache.getGlyphHeight(images[i]);\n+        metrics[4] = StrikeCache.getGlyphRowBytes(images[i]);\n@@ -363,4 +357,1 @@\n-        long pixelDataAddress =\n-            StrikeCache.unsafe.getAddress(images[glyphindex] +\n-                                          StrikeCache.pixelDataOffset);\n-\n+        long pixelDataAddress = StrikeCache.getGlyphImagePtr(images[glyphindex]);\n@@ -376,3 +367,2 @@\n-        for (int i=0; i<len; i++) {\n-            graybits[i] = StrikeCache.unsafe.getByte(pixelDataAddress+i);\n-        }\n+        byte[] bytes = StrikeCache.getGlyphPixelBytes(images[glyphindex]);\n+        System.arraycopy(bytes, 0, graybits, 0, bytes.length);\n@@ -448,7 +438,0 @@\n-        \/* Faster to access local variables in the for loop? *\/\n-        int xOffset = StrikeCache.topLeftXOffset;\n-        int yOffset = StrikeCache.topLeftYOffset;\n-        int wOffset = StrikeCache.widthOffset;\n-        int hOffset = StrikeCache.heightOffset;\n-        int xAdvOffset = StrikeCache.xAdvanceOffset;\n-        int yAdvOffset = StrikeCache.yAdvanceOffset;\n@@ -474,4 +457,4 @@\n-            gx = StrikeCache.unsafe.getFloat(images[i]+xOffset);\n-            gy = StrikeCache.unsafe.getFloat(images[i]+yOffset);\n-            gw = StrikeCache.unsafe.getChar(images[i]+wOffset);\n-            gh = StrikeCache.unsafe.getChar(images[i]+hOffset);\n+            gx = StrikeCache.getGlyphTopLeftX(images[i]);\n+            gy = StrikeCache.getGlyphTopLeftY(images[i]);\n+            gw = StrikeCache.getGlyphWidth(images[i]);\n+            gh = StrikeCache.getGlyphHeight(images[i]);\n@@ -485,2 +468,2 @@\n-                glx += StrikeCache.unsafe.getFloat(images[i]+xAdvOffset);\n-                gly += StrikeCache.unsafe.getFloat(images[i]+yAdvOffset);\n+                glx += StrikeCache.getGlyphXAdvance(images[i]);\n+                gly += StrikeCache.getGlyphYAdvance(images[i]);\n@@ -509,4 +492,2 @@\n-        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                               StrikeCache.widthOffset);\n-        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                                  StrikeCache.rowBytesOffset);\n+        int width = StrikeCache.getGlyphWidth(images[glyphIndex]);\n+        int rowBytes = StrikeCache.getGlyphRowBytes(images[glyphIndex]);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":19,"deletions":38,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,0 +30,10 @@\n+\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import static java.lang.foreign.MemorySegment.NULL;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n+import static java.lang.foreign.ValueLayout.*;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n@@ -40,1 +50,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -66,2 +75,0 @@\n-    static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n@@ -101,2 +108,3 @@\n-     * Native sizes and offsets for glyph cache\n-     * There are 10 values.\n+     * Native sizes and accessors for glyph cache structure.\n+     * There are 10 values. Also need native address size and a long which\n+     * references a memory address for a \"null\" glyph image.\n@@ -104,31 +112,151 @@\n-    static int nativeAddressSize;\n-    static int glyphInfoSize;\n-    static int xAdvanceOffset;\n-    static int yAdvanceOffset;\n-    static int boundsOffset;\n-    static int widthOffset;\n-    static int heightOffset;\n-    static int rowBytesOffset;\n-    static int topLeftXOffset;\n-    static int topLeftYOffset;\n-    static int pixelDataOffset;\n-    static int cacheCellOffset;\n-    static int managedOffset;\n-    static long invisibleGlyphPtr;\n-\n-    \/* Native method used to return information used for unsafe\n-     * access to native data.\n-     * return values as follows:-\n-     * arr[0] = size of an address\/pointer.\n-     * arr[1] = size of a GlyphInfo\n-     * arr[2] = offset of advanceX\n-     * arr[3] = offset of advanceY\n-     * arr[4] = offset of width\n-     * arr[5] = offset of height\n-     * arr[6] = offset of rowBytes\n-     * arr[7] = offset of topLeftX\n-     * arr[8] = offset of topLeftY\n-     * arr[9] = offset of pixel data.\n-     * arr[10] = address of a GlyphImageRef representing the invisible glyph\n-     *\/\n-    static native void getGlyphCacheDescription(long[] infoArray);\n+    static final int nativeAddressSize = (int)ValueLayout.ADDRESS.byteSize();\n+    static final long invisibleGlyphPtr = getInvisibleGlyphPtr(); \/\/ a singleton.\n+\n+    static native long getInvisibleGlyphPtr();\n+\n+    public static final StructLayout GlyphImageLayout = MemoryLayout.structLayout(\n+        JAVA_FLOAT.withName(\"xAdvance\"), \/\/ 0+4=4,\n+        JAVA_FLOAT.withName(\"yAdvance\"), \/\/ 4+4=8,\n+        JAVA_CHAR.withName(\"width\"),     \/\/ 8+2=10,\n+        JAVA_CHAR.withName(\"height\"),    \/\/ 10+2=12\n+        JAVA_CHAR.withName(\"rowBytes\"),  \/\/ 12+2=14\n+        JAVA_BYTE.withName(\"managed\"),   \/\/ 14+1=15\n+        MemoryLayout.paddingLayout(1),   \/\/ 15+1=16\n+        JAVA_FLOAT.withName(\"topLeftX\"), \/\/ 16+4=20\n+        JAVA_FLOAT.withName(\"topLeftY\"), \/\/ 20+4=24\n+        ADDRESS.withName(\"cellInfo\"),    \/\/ 24+8=32\n+        ADDRESS.withName(\"image\")        \/\/ 32+8=40\n+     );\n+\n+   private static final long GLYPHIMAGESIZE = GlyphImageLayout.byteSize();\n+\n+   private static VarHandle getVarHandle(StructLayout struct, String name) {\n+        VarHandle h = struct.varHandle(PathElement.groupElement(name));\n+        \/* insert 0 offset so don't need to pass arg every time *\/\n+        return MethodHandles.insertCoordinates(h, 1, 0L).withInvokeExactBehavior();\n+    }\n+\n+    private static final VarHandle xAdvanceHandle = getVarHandle(GlyphImageLayout, \"xAdvance\");\n+    private static final VarHandle yAdvanceHandle = getVarHandle(GlyphImageLayout, \"yAdvance\");\n+    private static final VarHandle widthHandle    = getVarHandle(GlyphImageLayout, \"width\");\n+    private static final VarHandle heightHandle   = getVarHandle(GlyphImageLayout, \"height\");\n+    private static final VarHandle rowBytesHandle = getVarHandle(GlyphImageLayout, \"rowBytes\");\n+    private static final VarHandle managedHandle  = getVarHandle(GlyphImageLayout, \"managed\");\n+    private static final VarHandle topLeftXHandle = getVarHandle(GlyphImageLayout, \"topLeftX\");\n+    private static final VarHandle topLeftYHandle = getVarHandle(GlyphImageLayout, \"topLeftY\");\n+    private static final VarHandle cellInfoHandle  = getVarHandle(GlyphImageLayout, \"cellInfo\");\n+    private static final VarHandle imageHandle    = getVarHandle(GlyphImageLayout, \"image\");\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphXAdvance(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)xAdvanceHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final void setGlyphXAdvance(long ptr, float val) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        xAdvanceHandle.set(seg, val);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphYAdvance(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)yAdvanceHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphWidth(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)widthHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphHeight(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)heightHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final char getGlyphRowBytes(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (char)rowBytesHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final byte getGlyphManaged(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (byte)managedHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphTopLeftX(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)topLeftXHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final float getGlyphTopLeftY(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return (float)topLeftYHandle.get(seg);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final long getGlyphCellInfo(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return ((MemorySegment)cellInfoHandle.get(seg)).address();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final void setGlyphCellInfo(long ptr, long val) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        MemorySegment segval = MemorySegment.ofAddress(val);\n+        cellInfoHandle.set(seg, segval);\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final long getGlyphImagePtr(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        return ((MemorySegment)imageHandle.get(seg)).address();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final MemorySegment getGlyphPixelData(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        char hgt = (char)heightHandle.get(seg);\n+        char rb = (char)rowBytesHandle.get(seg);\n+        MemorySegment pixelData = (MemorySegment)imageHandle.get(seg);\n+        pixelData = pixelData.reinterpret(rb * hgt);\n+        return pixelData;\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    static final byte[] getGlyphPixelBytes(long ptr) {\n+        MemorySegment seg = MemorySegment.ofAddress(ptr);\n+        seg = seg.reinterpret(GLYPHIMAGESIZE);\n+        char hgt = (char)heightHandle.get(seg);\n+        char rb = (char)rowBytesHandle.get(seg);\n+        MemorySegment pixelData = (MemorySegment)imageHandle.get(seg);\n+        int sz = rb * hgt;\n+        pixelData = pixelData.reinterpret(sz);\n+        byte[] bytes = new byte[sz];\n+        MemorySegment.copy(pixelData, ValueLayout.JAVA_BYTE, 0, bytes, 0, sz);\n+        return bytes;\n+    }\n+\n+    static final byte getPixelByte(MemorySegment pixelData, long index) {\n+       return pixelData.getAtIndex(JAVA_BYTE, index);\n+    }\n@@ -143,18 +271,0 @@\n-        long[] nativeInfo = new long[13];\n-        getGlyphCacheDescription(nativeInfo);\n-        \/\/Can also get address size from Unsafe class :-\n-        \/\/nativeAddressSize = unsafe.addressSize();\n-        nativeAddressSize = (int)nativeInfo[0];\n-        glyphInfoSize     = (int)nativeInfo[1];\n-        xAdvanceOffset    = (int)nativeInfo[2];\n-        yAdvanceOffset    = (int)nativeInfo[3];\n-        widthOffset       = (int)nativeInfo[4];\n-        heightOffset      = (int)nativeInfo[5];\n-        rowBytesOffset    = (int)nativeInfo[6];\n-        topLeftXOffset    = (int)nativeInfo[7];\n-        topLeftYOffset    = (int)nativeInfo[8];\n-        pixelDataOffset   = (int)nativeInfo[9];\n-        invisibleGlyphPtr = nativeInfo[10];\n-        cacheCellOffset = (int) nativeInfo[11];\n-        managedOffset = (int) nativeInfo[12];\n-\n@@ -327,1 +437,1 @@\n-                    if (glyphPtrs[i] != 0 && unsafe.getByte(glyphPtrs[i] + managedOffset) == 0) {\n+                    if ((glyphPtrs[i] != 0) && getGlyphManaged(glyphPtrs[i]) == 0) {\n@@ -353,2 +463,1 @@\n-                    if (glyphPtrs[i] != 0\n-                            && unsafe.getByte(glyphPtrs[i] + managedOffset) == 0) {\n+                    if ((glyphPtrs[i] != 0) && getGlyphManaged(glyphPtrs[i]) == 0) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":166,"deletions":57,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -303,11 +303,2 @@\n-JNIEXPORT void JNICALL\n-Java_sun_font_StrikeCache_getGlyphCacheDescription\n-  (JNIEnv *env, jclass cls, jlongArray results) {\n-\n-    jlong* nresults;\n-    GlyphInfo *info;\n-    size_t baseAddr;\n-\n-    if ((*env)->GetArrayLength(env, results) < 13) {\n-        return;\n-    }\n+JNIEXPORT jlong JNICALL\n+Java_sun_font_StrikeCache_getInvisibleGlyphPtr(JNIEnv *env, jclass cls) {\n@@ -315,25 +306,2 @@\n-    nresults = (jlong*)(*env)->GetPrimitiveArrayCritical(env, results, NULL);\n-    if (nresults == NULL) {\n-        return;\n-    }\n-    info = (GlyphInfo*) calloc(1, sizeof(GlyphInfo));\n-    if (info == NULL) {\n-        (*env)->ReleasePrimitiveArrayCritical(env, results, nresults, 0);\n-        return;\n-    }\n-    baseAddr = (size_t)info;\n-    nresults[0] = sizeof(void*);\n-    nresults[1] = sizeof(GlyphInfo);\n-    nresults[2] = 0;\n-    nresults[3] = (size_t)&(info->advanceY)-baseAddr;\n-    nresults[4] = (size_t)&(info->width)-baseAddr;\n-    nresults[5] = (size_t)&(info->height)-baseAddr;\n-    nresults[6] = (size_t)&(info->rowBytes)-baseAddr;\n-    nresults[7] = (size_t)&(info->topLeftX)-baseAddr;\n-    nresults[8] = (size_t)&(info->topLeftY)-baseAddr;\n-    nresults[9] = (size_t)&(info->image)-baseAddr;\n-    nresults[10] = (jlong)(uintptr_t)info; \/* invisible glyph *\/\n-    nresults[11] = (size_t)&(info->cellInfo)-baseAddr;\n-    nresults[12] = (size_t)&(info->managed)-baseAddr;\n-\n-    (*env)->ReleasePrimitiveArrayCritical(env, results, nresults, 0);\n+    GlyphInfo *info = (GlyphInfo*) calloc(1, sizeof(GlyphInfo));\n+    return (jlong)(uintptr_t)info; \/* invisible glyph *\/\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":4,"deletions":36,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        \/\/ We need to access the GlyphID with Unsafe.getAddress() because the\n+        \/\/ We need to access the GlyphID as a long because the\n@@ -77,3 +77,2 @@\n-        \/\/ field with Unsafe.getInt().\n-        return (int) StrikeCache.unsafe.getAddress(glyphInfoPtr +\n-                                                   StrikeCache.cacheCellOffset);\n+        \/\/ field as an int.\n+        return (int)StrikeCache.getGlyphCellInfo(glyphInfoPtr);\n@@ -83,1 +82,1 @@\n-        \/\/ We need to access the GlyphID with Unsafe.putAddress() because the\n+        \/\/ We need to access the GlyphID as a long because the\n@@ -85,5 +84,4 @@\n-        \/\/ 'void*' (see field 'cellInfo' of struct 'GlyphInfo' in\n-        \/\/ src\/share\/native\/sun\/font\/fontscalerdefs.h).\n-        \/\/ On 64-bit Big-endian architectures it would be wrong to write this\n-        \/\/ field with Unsafe.putInt() because it is also accessed from native\n-        \/\/ code as a 'long'.\n+        \/\/ 'void*' (see field 'cellInfo' of struct 'GlyphInfo'\n+        \/\/ in src\/share\/native\/sun\/font\/fontscalerdefs.h).\n+        \/\/ On 64-bit Big-endian architectures it would be wrong to access this\n+        \/\/ field as an int\n@@ -91,3 +89,2 @@\n-        \/\/ in src\/solaris\/native\/sun\/java2d\/x11\/XRBackendNative.c\n-        StrikeCache.unsafe.putAddress(glyphInfoPtr +\n-                                      StrikeCache.cacheCellOffset, (long)id);\n+        \/\/ in src\/unix\/native\/sun\/java2d\/x11\/XRBackendNative.c\n+        StrikeCache.setGlyphCellInfo(glyphInfoPtr, (long)id);\n@@ -105,1 +102,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.xAdvanceOffset);\n+        return StrikeCache.getGlyphXAdvance(glyphInfoPtr);\n@@ -109,1 +106,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.yAdvanceOffset);\n+        return StrikeCache.getGlyphYAdvance(glyphInfoPtr);\n@@ -113,1 +110,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.rowBytesOffset);\n+        return StrikeCache.getGlyphRowBytes(glyphInfoPtr);\n@@ -117,1 +114,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.widthOffset);\n+        return StrikeCache.getGlyphWidth(glyphInfoPtr);\n@@ -121,1 +118,1 @@\n-        return StrikeCache.unsafe.getShort(glyphInfoPtr + StrikeCache.heightOffset);\n+        return StrikeCache.getGlyphHeight(glyphInfoPtr);\n@@ -125,3 +122,1 @@\n-        long pixelDataAddress =\n-            StrikeCache.unsafe.getAddress(glyphInfoPtr +\n-                                          StrikeCache.pixelDataOffset);\n+        long pixelDataAddress = StrikeCache.getGlyphImagePtr(glyphInfoPtr);\n@@ -137,0 +132,1 @@\n+        byte[] pixelBytes = StrikeCache.getGlyphPixelBytes(glyphInfoPtr);\n@@ -141,1 +137,1 @@\n-                        os.write(StrikeCache.unsafe.getByte(pixelDataAddress + (line * rowBytes + x)));\n+                        os.write(pixelBytes[(line * rowBytes + x)]);\n@@ -154,6 +150,3 @@\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 2)));\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 1)));\n-                    os.write(StrikeCache.unsafe.getByte\n-                          (pixelDataAddress + (rowStart + srcpix + 0)));\n+                    os.write(pixelBytes[rowStart + srcpix + 2]);\n+                    os.write(pixelBytes[rowStart + srcpix + 1]);\n+                    os.write(pixelBytes[rowStart + srcpix + 0]);\n@@ -168,1 +161,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.topLeftXOffset);\n+        return StrikeCache.getGlyphTopLeftX(glyphInfoPtr);\n@@ -172,1 +165,1 @@\n-        return StrikeCache.unsafe.getFloat(glyphInfoPtr + StrikeCache.topLeftYOffset);\n+        return StrikeCache.getGlyphTopLeftY(glyphInfoPtr);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"}]}