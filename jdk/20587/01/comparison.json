{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,8 +360,0 @@\n-  \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n-  \/\/ so we can go compiled via a i2c. Otherwise initial entry method will always\n-  \/\/ run interpreted.\n-  address entry_point = method->from_interpreted_entry();\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n-    entry_point = method->interpreter_entry();\n-  }\n-\n@@ -401,0 +393,12 @@\n+\n+      address entry_point;\n+      {\n+        \/\/ The enter_interp_only_mode use handshake to set interp_only mode\n+        \/\/ so no safepoint should be allowed between is_interp_only_mode() and call\n+        NoSafepointVerifier nsv;\n+        if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+          entry_point = method->interpreter_entry();\n+        } else {\n+          \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n+          \/\/ so we can go compiled via a i2c.\n+          entry_point = method->from_interpreted_entry();\n@@ -402,10 +406,13 @@\n-      \/\/ Gets the alternative target (if any) that should be called\n-      Handle alternative_target = args->alternative_target();\n-      if (!alternative_target.is_null()) {\n-        \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n-        \/\/ transition in JavaCallWrapper constructor so that it is safe with\n-        \/\/ respect to nmethod sweeping.\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n-        if (verified_entry_point != nullptr) {\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n-          entry_point = method->adapter()->get_i2c_entry();\n+          \/\/ Gets the alternative target (if any) that should be called\n+          Handle alternative_target = args->alternative_target();\n+          if (!alternative_target.is_null()) {\n+            \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n+            \/\/ transition in JavaCallWrapper constructor so that it is safe with\n+            \/\/ respect to nmethod sweeping.\n+            address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+            if (verified_entry_point != nullptr) {\n+              thread->set_jvmci_alternate_call_target(verified_entry_point);\n+              entry_point = method->adapter()->get_i2c_entry();\n+            }\n+          }\n+#endif\n@@ -414,1 +421,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-\n-\/*\n- * @test id=logging\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:setfmodw001 -XX:TraceJVMTI=ec+,+ioe,+s -Xlog:jvmti=trace:file=vm.%p.log nsk.jvmti.SetFieldModificationWatch.setfmodw001\n- *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}