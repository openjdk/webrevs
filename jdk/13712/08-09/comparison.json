{"files":[{"patch":"@@ -1,827 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.launcher;\n-\n-import java.io.BufferedInputStream;\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.URLConnection;\n-import java.net.URLStreamHandler;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.CodeSigner;\n-import java.security.CodeSource;\n-import java.security.ProtectionDomain;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.MissingResourceException;\n-import java.util.NoSuchElementException;\n-import java.util.ResourceBundle;\n-\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.NestingKind;\n-import javax.lang.model.element.TypeElement;\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.StandardLocation;\n-\n-import com.sun.source.util.JavacTask;\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskListener;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.resources.LauncherProperties.Errors;\n-import com.sun.tools.javac.util.JCDiagnostic.Error;\n-\n-import jdk.internal.misc.MethodFinder;\n-import jdk.internal.misc.PreviewFeatures;\n-import jdk.internal.misc.VM;\n-\n-import static javax.tools.JavaFileObject.Kind.SOURCE;\n-\n-\/**\n- * Compiles a source file, and executes the main method it contains.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own\n- * risk.  This code and its internal interfaces are subject to change\n- * or deletion without notice.<\/b><\/p>\n- *\/\n-public class Main {\n-    \/**\n-     * An exception used to report errors.\n-     *\/\n-    public class Fault extends Exception {\n-        private static final long serialVersionUID = 1L;\n-        Fault(Error error) {\n-            super(Main.this.getMessage(error));\n-        }\n-    }\n-\n-    \/**\n-     * Compiles a source file, and executes the main method it contains.\n-     *\n-     * <p>This is normally invoked from the Java launcher, either when\n-     * the {@code --source} option is used, or when the first argument\n-     * that is not part of a runtime option ends in {@code .java}.\n-     *\n-     * <p>The first entry in the {@code args} array is the source file\n-     * to be compiled and run; all subsequent entries are passed as\n-     * arguments to the main method of the first class found in the file.\n-     *\n-     * <p>If any problem occurs before executing the main class, it will\n-     * be reported to the standard error stream, and the JVM will be\n-     * terminated by calling {@code System.exit} with a non-zero return code.\n-     *\n-     * @param args the arguments\n-     * @throws Throwable if the main method throws an exception\n-     *\/\n-    public static void main(String... args) throws Throwable {\n-        try {\n-            new Main(System.err)\n-                    .checkSecurityManager()\n-                    .run(VM.getRuntimeArguments(), args);\n-        } catch (Fault f) {\n-            System.err.println(f.getMessage());\n-            System.exit(1);\n-        } catch (InvocationTargetException e) {\n-            \/\/ leave VM to handle the stacktrace, in the standard manner\n-            throw e.getCause();\n-        }\n-    }\n-\n-    \/** Stream for reporting errors, such as compilation errors. *\/\n-    private PrintWriter out;\n-\n-    \/**\n-     * Creates an instance of this class, providing a stream to which to report\n-     * any errors.\n-     *\n-     * @param out the stream\n-     *\/\n-    public Main(PrintStream out) {\n-        this(new PrintWriter(new OutputStreamWriter(out), true));\n-    }\n-\n-    \/**\n-     * Creates an instance of this class, providing a stream to which to report\n-     * any errors.\n-     *\n-     * @param out the stream\n-     *\/\n-    public Main(PrintWriter out) {\n-        this.out = out;\n-    }\n-\n-    \/**\n-     * Checks if a security manager is present and throws an exception if so.\n-     * @return this object\n-     * @throws Fault if a security manager is present\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private Main checkSecurityManager() throws Fault {\n-        if (System.getSecurityManager() != null) {\n-            throw new Fault(Errors.SecurityManager);\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Compiles a source file, and executes the main method it contains.\n-     *\n-     * <p>The first entry in the {@code args} array is the source file\n-     * to be compiled and run; all subsequent entries are passed as\n-     * arguments to the main method of the first class found in the file.\n-     *\n-     * <p>Options for {@code javac} are obtained by filtering the runtime arguments.\n-     *\n-     * <p>If the main method throws an exception, it will be propagated in an\n-     * {@code InvocationTargetException}. In that case, the stack trace of the\n-     * target exception will be truncated such that the main method will be the\n-     * last entry on the stack. In other words, the stack frames leading up to the\n-     * invocation of the main method will be removed.\n-     *\n-     * @param runtimeArgs the runtime arguments\n-     * @param args the arguments\n-     * @throws Fault if a problem is detected before the main method can be executed\n-     * @throws InvocationTargetException if the main method throws an exception\n-     *\/\n-    public void run(String[] runtimeArgs, String[] args) throws Fault, InvocationTargetException {\n-        Path file = getFile(args);\n-\n-        Context context = new Context(file.toAbsolutePath());\n-        String mainClassName = compile(file, getJavacOpts(runtimeArgs), context);\n-\n-        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n-        execute(mainClassName, mainArgs, context);\n-    }\n-\n-    \/**\n-     * Returns the path for the filename found in the first of an array of arguments.\n-     *\n-     * @param args the array\n-     * @return the path, as given in the array of args\n-     * @throws Fault if there is a problem determining the path, or if the file does not exist\n-     *\/\n-    private Path getFile(String[] args) throws Fault {\n-        if (args.length == 0) {\n-            \/\/ should not happen when invoked from launcher\n-            throw new Fault(Errors.NoArgs);\n-        }\n-        Path file;\n-        try {\n-            file = Paths.get(args[0]);\n-        } catch (InvalidPathException e) {\n-            throw new Fault(Errors.InvalidFilename(args[0]));\n-        }\n-        if (!Files.exists(file)) {\n-            \/\/ should not happen when invoked from launcher\n-            throw new Fault(Errors.FileNotFound(file));\n-        }\n-        return file;\n-    }\n-\n-    \/**\n-     * Reads a source file, ignoring the first line if it is not a Java source file and\n-     * it begins with {@code #!}.\n-     *\n-     * <p>If it is not a Java source file, and if the first two bytes are {@code #!},\n-     * indicating a \"magic number\" of an executable text file, the rest of the first line\n-     * up to but not including the newline is ignored. All characters after the first two are\n-     * read in the {@link Charset#defaultCharset default platform encoding}.\n-     *\n-     * @param file the file\n-     * @return a file object containing the content of the file\n-     * @throws Fault if an error occurs while reading the file\n-     *\/\n-    private JavaFileObject readFile(Path file) throws Fault {\n-        \/\/ use a BufferedInputStream to guarantee that we can use mark and reset.\n-        try (BufferedInputStream in = new BufferedInputStream(Files.newInputStream(file))) {\n-            boolean ignoreFirstLine;\n-            if (file.getFileName().toString().endsWith(\".java\")) {\n-                ignoreFirstLine = false;\n-            } else {\n-                in.mark(2);\n-                ignoreFirstLine = (in.read() == '#') && (in.read() == '!');\n-                if (!ignoreFirstLine) {\n-                    in.reset();\n-                }\n-            }\n-            try (BufferedReader r = new BufferedReader(new InputStreamReader(in, Charset.defaultCharset()))) {\n-                StringBuilder sb = new StringBuilder();\n-                if (ignoreFirstLine) {\n-                    r.readLine();\n-                    sb.append(\"\\n\"); \/\/ preserve line numbers\n-                }\n-                char[] buf = new char[1024];\n-                int n;\n-                while ((n = r.read(buf, 0, buf.length)) != -1)  {\n-                    sb.append(buf, 0, n);\n-                }\n-                return new SimpleJavaFileObject(file.toUri(), SOURCE) {\n-                    @Override\n-                    public String getName() {\n-                        return file.toString();\n-                    }\n-                    @Override\n-                    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                        return sb;\n-                    }\n-                    @Override\n-                    public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {\n-                        \/\/ reject package-info and module-info; accept other names\n-                        return (kind == JavaFileObject.Kind.SOURCE)\n-                                && SourceVersion.isIdentifier(simpleName);\n-                    }\n-                    @Override\n-                    public String toString() {\n-                        return \"JavacSourceLauncher[\" + file + \"]\";\n-                    }\n-                };\n-            }\n-        } catch (IOException e) {\n-            throw new Fault(Errors.CantReadFile(file, e));\n-        }\n-    }\n-\n-    \/**\n-     * Returns the subset of the runtime arguments that are relevant to {@code javac}.\n-     * Generally, the relevant options are those for setting paths and for configuring the\n-     * module system.\n-     *\n-     * @param runtimeArgs the runtime arguments\n-     * @return the subset of the runtime arguments\n-     **\/\n-    private List<String> getJavacOpts(String... runtimeArgs) throws Fault {\n-        List<String> javacOpts = new ArrayList<>();\n-\n-        String sourceOpt = System.getProperty(\"jdk.internal.javac.source\");\n-        if (sourceOpt != null) {\n-            Source source = Source.lookup(sourceOpt);\n-            if (source == null) {\n-                throw new Fault(Errors.InvalidValueForSource(sourceOpt));\n-            }\n-            javacOpts.addAll(List.of(\"--release\", sourceOpt));\n-        }\n-\n-        for (int i = 0; i < runtimeArgs.length; i++) {\n-            String arg = runtimeArgs[i];\n-            String opt = arg, value = null;\n-            if (arg.startsWith(\"--\")) {\n-                int eq = arg.indexOf('=');\n-                if (eq > 0) {\n-                    opt = arg.substring(0, eq);\n-                    value = arg.substring(eq + 1);\n-                }\n-            }\n-            switch (opt) {\n-                \/\/ The following options all expect a value, either in the following\n-                \/\/ position, or after '=', for options beginning \"--\".\n-                case \"--class-path\": case \"-classpath\": case \"-cp\":\n-                case \"--module-path\": case \"-p\":\n-                case \"--add-exports\":\n-                case \"--add-modules\":\n-                case \"--limit-modules\":\n-                case \"--patch-module\":\n-                case \"--upgrade-module-path\":\n-                    if (value == null) {\n-                        if (i== runtimeArgs.length - 1) {\n-                            \/\/ should not happen when invoked from launcher\n-                            throw new Fault(Errors.NoValueForOption(opt));\n-                        }\n-                        value = runtimeArgs[++i];\n-                    }\n-                    if (opt.equals(\"--add-modules\") && value.equals(\"ALL-DEFAULT\")) {\n-                        \/\/ this option is only supported at run time;\n-                        \/\/ it is not required or supported at compile time\n-                        break;\n-                    }\n-                    javacOpts.add(opt);\n-                    javacOpts.add(value);\n-                    break;\n-                case \"--enable-preview\":\n-                    javacOpts.add(opt);\n-                    if (sourceOpt == null) {\n-                        throw new Fault(Errors.EnablePreviewRequiresSource);\n-                    }\n-                    break;\n-                default:\n-                    if (opt.startsWith(\"-agentlib:jdwp=\") || opt.startsWith(\"-Xrunjdwp:\")) {\n-                        javacOpts.add(\"-g\");\n-                    }\n-                    \/\/ ignore all other runtime args\n-            }\n-        }\n-\n-        \/\/ add implicit options\n-        javacOpts.add(\"-proc:none\");\n-        javacOpts.add(\"-Xdiags:verbose\");\n-        javacOpts.add(\"-Xlint:deprecation\");\n-        javacOpts.add(\"-Xlint:unchecked\");\n-        javacOpts.add(\"-Xlint:-options\");\n-        javacOpts.add(\"-XDsourceLauncher\");\n-        return javacOpts;\n-    }\n-\n-    \/**\n-     * Compiles a source file, placing the class files in a map in memory.\n-     * Any messages generated during compilation will be written to the stream\n-     * provided when this object was created.\n-     *\n-     * @param file the source file\n-     * @param javacOpts compilation options for {@code javac}\n-     * @param context the context for the compilation\n-     * @return the name of the first class found in the source file\n-     * @throws Fault if any compilation errors occur, or if no class was found\n-     *\/\n-    private String compile(Path file, List<String> javacOpts, Context context) throws Fault {\n-        JavaFileObject fo = readFile(file);\n-\n-        JavacTool javaCompiler = JavacTool.create();\n-        StandardJavaFileManager stdFileMgr = javaCompiler.getStandardFileManager(null, null, null);\n-        try {\n-            stdFileMgr.setLocation(StandardLocation.SOURCE_PATH, Collections.emptyList());\n-        } catch (IOException e) {\n-            throw new java.lang.Error(\"unexpected exception from file manager\", e);\n-        }\n-        JavaFileManager fm = context.getFileManager(stdFileMgr);\n-        JavacTask t = javaCompiler.getTask(out, fm, null, javacOpts, null, List.of(fo));\n-        MainClassListener l = new MainClassListener(t);\n-        Boolean ok = t.call();\n-        if (!ok) {\n-            throw new Fault(Errors.CompilationFailed);\n-        }\n-        if (l.mainClass == null) {\n-            throw new Fault(Errors.NoClass);\n-        }\n-        TypeElement mainClass = l.mainClass;\n-        String mainClassName = mainClass.getQualifiedName().toString();\n-\n-        return mainClassName;\n-    }\n-\n-    \/**\n-     * Invokes the {@code main} method of a specified class, using a class loader that\n-     * will load recently compiled classes from memory.\n-     *\n-     * @param mainClassName the class to be executed\n-     * @param mainArgs the arguments for the {@code main} method\n-     * @param context the context for the class to be executed\n-     * @throws Fault if there is a problem finding or invoking the {@code main} method\n-     * @throws InvocationTargetException if the {@code main} method throws an exception\n-     *\/\n-    private void execute(String mainClassName, String[] mainArgs, Context context)\n-            throws Fault, InvocationTargetException {\n-        System.setProperty(\"jdk.launcher.sourcefile\", context.file.toString());\n-        ClassLoader cl = context.getClassLoader(ClassLoader.getSystemClassLoader());\n-\n-        Class<?> appClass;\n-        try {\n-            appClass = Class.forName(mainClassName, true, cl);\n-        } catch (ClassNotFoundException e) {\n-            throw new Fault(Errors.CantFindClass(mainClassName));\n-        }\n-\n-        Method mainMethod = MethodFinder.findMainMethod(appClass);\n-\n-        if (mainMethod == null) {\n-            throw new Fault(Errors.CantFindMainMethod(mainClassName));\n-        }\n-\n-        boolean isStatic = Modifier.isStatic(mainMethod.getModifiers());\n-        Object instance = null;\n-\n-        if (!isStatic) {\n-            Constructor<?> constructor;\n-            try {\n-                constructor = appClass.getDeclaredConstructor();\n-            } catch (NoSuchMethodException e) {\n-                throw new Fault(Errors.CantFindConstructor(mainClassName));\n-            }\n-\n-            try {\n-                constructor.setAccessible(true);\n-                instance = constructor.newInstance();\n-            } catch (InstantiationException | IllegalAccessException e) {\n-                throw new Fault(Errors.CantAccessConstructor(mainClassName));\n-            }\n-        }\n-\n-        try {\n-            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n-            \/\/ but duplicated here to prevent additional launcher frames\n-            mainMethod.setAccessible(true);\n-            Object receiver = isStatic ? appClass : instance;\n-\n-            if (mainMethod.getParameterCount() == 0) {\n-                mainMethod.invoke(receiver);\n-            } else {\n-                mainMethod.invoke(receiver, (Object)mainArgs);\n-            }\n-        } catch (IllegalAccessException e) {\n-            throw new Fault(Errors.CantAccessMainMethod(mainClassName));\n-        } catch (InvocationTargetException e) {\n-            \/\/ remove stack frames for source launcher\n-            int invocationFrames = e.getStackTrace().length;\n-            Throwable target = e.getCause();\n-            StackTraceElement[] targetTrace = target.getStackTrace();\n-            target.setStackTrace(Arrays.copyOfRange(targetTrace, 0, targetTrace.length - invocationFrames));\n-            throw e;\n-        }\n-    }\n-\n-    private static final String bundleName = \"com.sun.tools.javac.resources.launcher\";\n-    private ResourceBundle resourceBundle = null;\n-    private String errorPrefix;\n-\n-    \/**\n-     * Returns a localized string from a resource bundle.\n-     *\n-     * @param error the error for which to get the localized text\n-     * @return the localized string\n-     *\/\n-    private String getMessage(Error error) {\n-        String key = error.key();\n-        Object[] args = error.getArgs();\n-        try {\n-            if (resourceBundle == null) {\n-                resourceBundle = ResourceBundle.getBundle(bundleName);\n-                errorPrefix = resourceBundle.getString(\"launcher.error\");\n-            }\n-            String resource = resourceBundle.getString(key);\n-            String message = MessageFormat.format(resource, args);\n-            return errorPrefix + message;\n-        } catch (MissingResourceException e) {\n-            return \"Cannot access resource; \" + key + Arrays.toString(args);\n-        }\n-    }\n-\n-    \/**\n-     * A listener to detect the first class found in a compilation.\n-     *\/\n-    static class MainClassListener implements TaskListener {\n-        TypeElement mainClass;\n-\n-        MainClassListener(JavacTask t) {\n-            t.addTaskListener(this);\n-        }\n-\n-        @Override\n-        public void started(TaskEvent ev) {\n-            if (ev.getKind() == TaskEvent.Kind.ANALYZE && mainClass == null) {\n-                TypeElement te = ev.getTypeElement();\n-                if (te.getNestingKind() == NestingKind.TOP_LEVEL) {\n-                    mainClass = te;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * An object to encapsulate the set of in-memory classes, such that\n-     * they can be written by a file manager and subsequently used by\n-     * a class loader.\n-     *\/\n-    private static class Context {\n-        private final Path file;\n-        private final Map<String, byte[]> inMemoryClasses = new HashMap<>();\n-\n-        Context(Path file) {\n-            this.file = file;\n-        }\n-\n-        JavaFileManager getFileManager(StandardJavaFileManager delegate) {\n-            return new MemoryFileManager(inMemoryClasses, delegate);\n-        }\n-\n-        ClassLoader getClassLoader(ClassLoader parent) {\n-            return new MemoryClassLoader(inMemoryClasses, parent, file);\n-        }\n-    }\n-\n-    \/**\n-     * An in-memory file manager.\n-     *\n-     * <p>Class files (of kind {@link JavaFileObject.Kind#CLASS CLASS} written to\n-     * {@link StandardLocation#CLASS_OUTPUT} will be written to an in-memory cache.\n-     * All other file manager operations will be delegated to a specified file manager.\n-     *\/\n-    private static class MemoryFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n-        private final Map<String, byte[]> map;\n-\n-        MemoryFileManager(Map<String, byte[]> map, JavaFileManager delegate) {\n-            super(delegate);\n-            this.map = map;\n-        }\n-\n-        @Override\n-        public JavaFileObject getJavaFileForOutput(Location location, String className,\n-                JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n-            if (location == StandardLocation.CLASS_OUTPUT && kind == JavaFileObject.Kind.CLASS) {\n-                return createInMemoryClassFile(className);\n-            } else {\n-                return super.getJavaFileForOutput(location, className, kind, sibling);\n-            }\n-        }\n-\n-        private JavaFileObject createInMemoryClassFile(String className) {\n-            URI uri = URI.create(\"memory:\/\/\/\" + className.replace('.', '\/') + \".class\");\n-            return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n-                @Override\n-                public OutputStream openOutputStream() {\n-                    return new ByteArrayOutputStream() {\n-                        @Override\n-                        public void close() throws IOException {\n-                            super.close();\n-                            map.put(className, toByteArray());\n-                        }\n-                    };\n-                }\n-            };\n-        }\n-    }\n-\n-    \/**\n-     * An in-memory classloader, that uses an in-memory cache of classes written by\n-     * {@link MemoryFileManager}.\n-     *\n-     * <p>The classloader inverts the standard parent-delegation model, giving preference\n-     * to classes defined in the source file before classes known to the parent (such\n-     * as any like-named classes that might be found on the application class path.)\n-     *\/\n-    private static class MemoryClassLoader extends ClassLoader {\n-        \/**\n-         * The map of all classes found in the source file, indexed by\n-         * {@link ClassLoader#name binary name}.\n-         *\/\n-        private final Map<String, byte[]> sourceFileClasses;\n-\n-        \/**\n-         * A minimal protection domain, specifying a code source of the source file itself,\n-         * used for classes found in the source file and defined by this loader.\n-         *\/\n-        private final ProtectionDomain domain;\n-\n-        MemoryClassLoader(Map<String, byte[]> sourceFileClasses, ClassLoader parent, Path file) {\n-            super(parent);\n-            this.sourceFileClasses = sourceFileClasses;\n-            CodeSource codeSource;\n-            try {\n-                codeSource = new CodeSource(file.toUri().toURL(), (CodeSigner[]) null);\n-            } catch (MalformedURLException e) {\n-                codeSource = null;\n-            }\n-            domain = new ProtectionDomain(codeSource, null, this, null);\n-        }\n-\n-        \/**\n-         * Override loadClass to check for classes defined in the source file\n-         * before checking for classes in the parent class loader,\n-         * including those on the classpath.\n-         *\n-         * {@code loadClass(String name)} calls this method, and so will have the same behavior.\n-         *\n-         * @param name the name of the class to load\n-         * @param resolve whether or not to resolve the class\n-         * @return the class\n-         * @throws ClassNotFoundException if the class is not found\n-         *\/\n-        @Override\n-        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n-            synchronized (getClassLoadingLock(name)) {\n-                Class<?> c = findLoadedClass(name);\n-                if (c == null) {\n-                    if (sourceFileClasses.containsKey(name)) {\n-                        c = findClass(name);\n-                    } else {\n-                        c = getParent().loadClass(name);\n-                    }\n-                    if (resolve) {\n-                        resolveClass(c);\n-                    }\n-                }\n-                return c;\n-            }\n-        }\n-\n-\n-        \/**\n-         * Override getResource to check for resources (i.e. class files) defined in the\n-         * source file before checking resources in the parent class loader,\n-         * including those on the class path.\n-         *\n-         * {@code getResourceAsStream(String name)} calls this method,\n-         * and so will have the same behavior.\n-         *\n-         * @param name the name of the resource\n-         * @return a URL for the resource, or null if not found\n-         *\/\n-        @Override\n-        public URL getResource(String name) {\n-            if (sourceFileClasses.containsKey(toBinaryName(name))) {\n-                return findResource(name);\n-            } else {\n-                return getParent().getResource(name);\n-            }\n-        }\n-\n-        \/**\n-         * Override getResources to check for resources (i.e. class files) defined in the\n-         * source file before checking resources in the parent class loader,\n-         * including those on the class path.\n-         *\n-         * @param name the name of the resource\n-         * @return an enumeration of the resources in this loader and in the application class loader\n-         *\/\n-        @Override\n-        public Enumeration<URL> getResources(String name) throws IOException {\n-            URL u = findResource(name);\n-            Enumeration<URL> e = getParent().getResources(name);\n-            if (u == null) {\n-                return e;\n-            } else {\n-                List<URL> list = new ArrayList<>();\n-                list.add(u);\n-                while (e.hasMoreElements()) {\n-                    list.add(e.nextElement());\n-                }\n-                return Collections.enumeration(list);\n-            }\n-        }\n-\n-        @Override\n-        protected Class<?> findClass(String name) throws ClassNotFoundException {\n-            byte[] bytes = sourceFileClasses.get(name);\n-            if (bytes == null) {\n-                throw new ClassNotFoundException(name);\n-            }\n-            return defineClass(name, bytes, 0, bytes.length, domain);\n-        }\n-\n-        @Override\n-        public URL findResource(String name) {\n-            String binaryName = toBinaryName(name);\n-            if (binaryName == null || sourceFileClasses.get(binaryName) == null) {\n-                return null;\n-            }\n-\n-            URLStreamHandler handler = this.handler;\n-            if (handler == null) {\n-                this.handler = handler = new MemoryURLStreamHandler();\n-            }\n-\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                var result = new URL(PROTOCOL, null, -1, name, handler);\n-                return result;\n-            } catch (MalformedURLException e) {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public Enumeration<URL> findResources(String name) {\n-            return new Enumeration<URL>() {\n-                private URL next = findResource(name);\n-\n-                @Override\n-                public boolean hasMoreElements() {\n-                    return (next != null);\n-                }\n-\n-                @Override\n-                public URL nextElement() {\n-                    if (next == null) {\n-                        throw new NoSuchElementException();\n-                    }\n-                    URL u = next;\n-                    next = null;\n-                    return u;\n-                }\n-            };\n-        }\n-\n-        \/**\n-         * Converts a \"resource name\" (as used in the getResource* methods)\n-         * to a binary name if the name identifies a class, or null otherwise.\n-         * @param name the resource name\n-         * @return the binary name\n-         *\/\n-        private String toBinaryName(String name) {\n-            if (!name.endsWith(\".class\")) {\n-                return null;\n-            }\n-            return name.substring(0, name.length() - DOT_CLASS_LENGTH).replace('\/', '.');\n-        }\n-\n-        private static final int DOT_CLASS_LENGTH = \".class\".length();\n-        private final String PROTOCOL = \"sourcelauncher-\" + getClass().getSimpleName() + hashCode();\n-        private URLStreamHandler handler;\n-\n-        \/**\n-         * A URLStreamHandler for use with URLs returned by MemoryClassLoader.getResource.\n-         *\/\n-        private class MemoryURLStreamHandler extends URLStreamHandler {\n-            @Override\n-            public URLConnection openConnection(URL u) {\n-                if (!u.getProtocol().equalsIgnoreCase(PROTOCOL)) {\n-                    throw new IllegalArgumentException(u.toString());\n-                }\n-                return new MemoryURLConnection(u, sourceFileClasses.get(toBinaryName(u.getPath())));\n-            }\n-\n-        }\n-\n-        \/**\n-         * A URLConnection for use with URLs returned by MemoryClassLoader.getResource.\n-         *\/\n-        private static class MemoryURLConnection extends URLConnection {\n-            private byte[] bytes;\n-            private InputStream in;\n-\n-            MemoryURLConnection(URL u, byte[] bytes) {\n-                super(u);\n-                this.bytes = bytes;\n-            }\n-\n-            @Override\n-            public void connect() throws IOException {\n-                if (!connected) {\n-                    if (bytes == null) {\n-                        throw new FileNotFoundException(getURL().getPath());\n-                    }\n-                    in = new ByteArrayInputStream(bytes);\n-                    connected = true;\n-                }\n-            }\n-\n-            @Override\n-            public InputStream getInputStream() throws IOException {\n-                connect();\n-                return in;\n-            }\n-\n-            @Override\n-            public long getContentLengthLong() {\n-                return bytes.length;\n-            }\n-\n-            @Override\n-            public String getContentType() {\n-                return \"application\/octet-stream\";\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":0,"deletions":827,"binary":false,"changes":827,"status":"deleted"}]}