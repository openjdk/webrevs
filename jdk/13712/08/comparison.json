{"files":[{"patch":"@@ -102,0 +102,3 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java \\\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryModuleFinder.java \\\n+          $(TOPDIR)\/src\/$1\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+        jdk.compiler,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\\           (to execute a single source-file program)\\n\\n\\\n+\\           (to execute a source-file program)\\n\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-#define SOURCE_LAUNCHER_MAIN_ENTRY \"jdk.compiler\/com.sun.tools.javac.launcher.Main\"\n+#define SOURCE_LAUNCHER_MAIN_ENTRY \"jdk.compiler\/com.sun.tools.javac.launcher.SourceLauncher\"\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,3 +50,0 @@\n-import static com.sun.tools.javac.code.Flags.RECORD;\n-import static com.sun.tools.javac.code.Flags.SEALED;\n-import static com.sun.tools.javac.code.Flags.NON_SEALED;\n@@ -87,1 +84,1 @@\n-    private static final Context.Key<Preview> previewKey = new Context.Key<>();\n+    protected static final Context.Key<Preview> previewKey = new Context.Key<>();\n@@ -97,1 +94,2 @@\n-    Preview(Context context) {\n+    @SuppressWarnings(\"this-escape\")\n+    protected Preview(Context context) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.tools.javac.util.JCDiagnostic.Error;\n+\n+import java.io.Serial;\n+import java.text.MessageFormat;\n+import java.util.Arrays;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+\/**\n+ * A runtime exception used to report errors.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+public final class Fault extends RuntimeException {\n+    @Serial\n+    private static final long serialVersionUID = 2L;\n+\n+    private static final String BUNDLE_NAME = \"com.sun.tools.javac.resources.launcher\";\n+\n+    private static final ResourceBundle RESOURCE_BUNDLE = ResourceBundle.getBundle(BUNDLE_NAME);\n+\n+    private static final String ERROR_PREFIX = RESOURCE_BUNDLE.getString(\"launcher.error\");\n+\n+    \/**\n+     * Returns a localized string from a resource bundle.\n+     *\n+     * @param error the error for which to get the localized text\n+     * @return the localized string\n+     *\/\n+    private static String getMessage(Error error) {\n+        String key = error.key();\n+        Object[] args = error.getArgs();\n+        try {\n+            String resource = RESOURCE_BUNDLE.getString(key);\n+            String message = MessageFormat.format(resource, args);\n+            return ERROR_PREFIX + message;\n+        } catch (MissingResourceException e) {\n+            return \"Cannot access resource; \" + key + Arrays.toString(args);\n+        }\n+    }\n+\n+    Fault(Error error) {\n+        super(getMessage(error));\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Fault.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.module.ModuleDescriptor;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandler;\n+import java.nio.file.Files;\n+import java.security.CodeSigner;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+\/**\n+ * An in-memory classloader, that uses an in-memory cache of classes written by\n+ * {@link MemoryFileManager}.\n+ *\n+ * <p>The classloader inverts the standard parent-delegation model, giving preference\n+ * to classes defined in the source file before classes known to the parent (such\n+ * as any like-named classes that might be found on the application class path.)\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+final class MemoryClassLoader extends ClassLoader {\n+    \/**\n+     * The parent class loader instance.\n+     *\/\n+    private final ClassLoader parentClassLoader;\n+\n+    \/**\n+     * The map of all classes found in the source file, indexed by\n+     * {@link Class#getName()} binary name.\n+     *\/\n+    private final Map<String, byte[]> sourceFileClasses;\n+\n+    \/**\n+     * A minimal protection domain, specifying a code source of the source file itself,\n+     * used for classes found in the source file and defined by this loader.\n+     *\/\n+    private final ProtectionDomain domain;\n+\n+    private final ModuleDescriptor moduleDescriptor;\n+    private final ProgramDescriptor programDescriptor;\n+    private final Function<String, byte[]> compileSourceFile;\n+\n+    MemoryClassLoader(Map<String, byte[]> sourceFileClasses,\n+                      ClassLoader parentClassLoader,\n+                      ModuleDescriptor moduleDescriptor,\n+                      ProgramDescriptor programDescriptor,\n+                      Function<String, byte[]> compileSourceFile) {\n+        super(parentClassLoader);\n+        this.parentClassLoader = parentClassLoader;\n+        this.sourceFileClasses = sourceFileClasses;\n+        CodeSource codeSource;\n+        try {\n+            codeSource = new CodeSource(programDescriptor.fileObject().getFile().toUri().toURL(), (CodeSigner[])null);\n+        } catch (MalformedURLException e) {\n+            codeSource = null;\n+        }\n+        domain = new ProtectionDomain(codeSource, null, this, null);\n+        this.moduleDescriptor = moduleDescriptor;\n+        this.programDescriptor = programDescriptor;\n+        this.compileSourceFile = compileSourceFile;\n+    }\n+\n+    \/**\n+     * Override loadClass to check for classes defined in the source file\n+     * before checking for classes in the parent class loader,\n+     * including those on the classpath.\n+     * <p>\n+     * {@code loadClass(String name)} calls this method, and so will have the same behavior.\n+     *\n+     * @param name    the name of the class to load\n+     * @param resolve whether to resolve the class\n+     * @return the class\n+     * @throws ClassNotFoundException if the class is not found\n+     *\/\n+    @Override\n+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+        synchronized (getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c == null) {\n+                c = findOrCompileClass(name);\n+                if (c == null) {\n+                    c = parentClassLoader.loadClass(name);\n+                }\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Override getResource to check for resources (i.e. class files) defined in the\n+     * source file before checking resources in the parent class loader,\n+     * including those on the class path.\n+     * <p>\n+     * {@code getResourceAsStream(String name)} calls this method,\n+     * and so will have the same behavior.\n+     *\n+     * @param name the name of the resource\n+     * @return a URL for the resource, or null if not found\n+     *\/\n+    @Override\n+    public URL getResource(String name) {\n+        if (sourceFileClasses.containsKey(toBinaryName(name))) {\n+            return findResource(name);\n+        }\n+        var programPath = programDescriptor.sourceRootPath().resolve(name);\n+        if (Files.exists(programPath)) {\n+            try {\n+                return programPath.toUri().toURL();\n+            } catch (MalformedURLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        return parentClassLoader.getResource(name);\n+    }\n+\n+    \/**\n+     * Override getResources to check for resources (i.e. class files) defined in the\n+     * source file before checking resources in the parent class loader,\n+     * including those on the class path.\n+     *\n+     * @param name the name of the resource\n+     * @return an enumeration of the resources in this loader and in the application class loader\n+     *\/\n+    @Override\n+    public Enumeration<URL> getResources(String name) throws IOException {\n+        URL u = findResource(name);\n+        Enumeration<URL> e = parentClassLoader.getResources(name);\n+        if (u == null) {\n+            return e;\n+        } else {\n+            List<URL> list = new ArrayList<>();\n+            list.add(u);\n+            while (e.hasMoreElements()) {\n+                list.add(e.nextElement());\n+            }\n+            return Collections.enumeration(list);\n+        }\n+    }\n+\n+    @Override\n+    protected Class<?> findClass(String name) throws ClassNotFoundException {\n+        var foundOrCompiledClass = findOrCompileClass(name);\n+        if (foundOrCompiledClass == null) {\n+            throw new ClassNotFoundException(name);\n+        }\n+        return foundOrCompiledClass;\n+    }\n+\n+    private Class<?> findOrCompileClass(String name) {\n+        byte[] bytes = sourceFileClasses.get(name);\n+        if (bytes == null) {\n+            bytes = compileSourceFile.apply(name);\n+            if (bytes == null) {\n+                return null;\n+            }\n+        }\n+        return defineClass(name, bytes, 0, bytes.length, domain);\n+    }\n+\n+    @Override\n+    protected URL findResource(String moduleName, String name) throws IOException {\n+        if (moduleName == null) {\n+            return getResource(name);\n+        }\n+        if (moduleDescriptor != null && moduleDescriptor.name().equals(moduleName)) {\n+            return getResource(name);\n+        }\n+        return super.findResource(moduleName, name);\n+    }\n+\n+    @Override\n+    public URL findResource(String name) {\n+        String binaryName = toBinaryName(name);\n+        if (binaryName == null || sourceFileClasses.get(binaryName) == null) {\n+            return null;\n+        }\n+\n+        URLStreamHandler handler = this.handler;\n+        if (handler == null) {\n+            this.handler = handler = new MemoryURLStreamHandler();\n+        }\n+\n+        try {\n+            var uri = new URI(PROTOCOL, name, null);\n+            return URL.of(uri, handler);\n+        } catch (URISyntaxException | MalformedURLException e) {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public Enumeration<URL> findResources(String name) {\n+        return new Enumeration<URL>() {\n+            private URL next = findResource(name);\n+\n+            @Override\n+            public boolean hasMoreElements() {\n+                return (next != null);\n+            }\n+\n+            @Override\n+            public URL nextElement() {\n+                if (next == null) {\n+                    throw new NoSuchElementException();\n+                }\n+                URL u = next;\n+                next = null;\n+                return u;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Converts a \"resource name\" (as used in the getResource* methods)\n+     * to a binary name if the name identifies a class, or null otherwise.\n+     *\n+     * @param name the resource name\n+     * @return the binary name\n+     *\/\n+    private String toBinaryName(String name) {\n+        if (!name.endsWith(\".class\")) {\n+            return null;\n+        }\n+        return name.substring(0, name.length() - DOT_CLASS_LENGTH).replace('\/', '.');\n+    }\n+\n+    private static final int DOT_CLASS_LENGTH = \".class\".length();\n+    private final String PROTOCOL = \"sourcelauncher-\" + getClass().getSimpleName() + hashCode();\n+    private URLStreamHandler handler;\n+\n+    \/**\n+     * A URLStreamHandler for use with URLs returned by MemoryClassLoader.getResource.\n+     *\/\n+    private class MemoryURLStreamHandler extends URLStreamHandler {\n+        @Override\n+        public URLConnection openConnection(URL u) {\n+            if (!u.getProtocol().equalsIgnoreCase(PROTOCOL)) {\n+                throw new IllegalArgumentException(u.toString());\n+            }\n+            return new MemoryURLConnection(u, sourceFileClasses.get(toBinaryName(u.getPath())));\n+        }\n+\n+    }\n+\n+    \/**\n+     * A URLConnection for use with URLs returned by MemoryClassLoader.getResource.\n+     *\/\n+    private static class MemoryURLConnection extends URLConnection {\n+        private final byte[] bytes;\n+        private InputStream in;\n+\n+        MemoryURLConnection(URL u, byte[] bytes) {\n+            super(u);\n+            this.bytes = bytes;\n+        }\n+\n+        @Override\n+        public void connect() throws IOException {\n+            if (!connected) {\n+                if (bytes == null) {\n+                    throw new FileNotFoundException(getURL().getPath());\n+                }\n+                in = new ByteArrayInputStream(bytes);\n+                connected = true;\n+            }\n+        }\n+\n+        @Override\n+        public InputStream getInputStream() throws IOException {\n+            connect();\n+            return in;\n+        }\n+\n+        @Override\n+        public long getContentLengthLong() {\n+            return bytes.length;\n+        }\n+\n+        @Override\n+        public String getContentType() {\n+            return \"application\/octet-stream\";\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryClassLoader.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.tools.javac.api.JavacTool;\n+import com.sun.tools.javac.code.Preview;\n+import com.sun.tools.javac.file.JavacFileManager;\n+import com.sun.tools.javac.resources.LauncherProperties.Errors;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Context.Factory;\n+\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.NestingKind;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\/**\n+ * An object to encapsulate the set of in-memory classes, such that\n+ * they can be written by a file manager and subsequently used by\n+ * a class loader.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+final class MemoryContext {\n+    private final PrintWriter out;\n+    private final ProgramDescriptor descriptor;\n+\n+    private final RelevantJavacOptions options;\n+\n+    private final JavacTool compiler;\n+    private final JavacFileManager standardFileManager;\n+    private final JavaFileManager memoryFileManager;\n+\n+    private final Map<String, byte[]> inMemoryClasses = new HashMap<>();\n+\n+    MemoryContext(PrintWriter out, ProgramDescriptor descriptor, RelevantJavacOptions options) throws Fault {\n+        this.out = out;\n+        this.descriptor = descriptor;\n+        this.options = options;\n+\n+        this.compiler = JavacTool.create();\n+        this.standardFileManager = compiler.getStandardFileManager(null, null, null);\n+        try {\n+            List<File> searchPath = descriptor.fileObject().isFirstLineIgnored() ? List.of() : List.of(descriptor.sourceRootPath().toFile());\n+            standardFileManager.setLocation(StandardLocation.SOURCE_PATH, searchPath);\n+        } catch (IOException e) {\n+            throw new Error(\"unexpected exception from file manager\", e);\n+        }\n+        this.memoryFileManager = new MemoryFileManager(inMemoryClasses, standardFileManager);\n+    }\n+\n+    ProgramDescriptor getProgramDescriptor() {\n+        return descriptor;\n+    }\n+\n+    String getSourceFileAsString() {\n+        return descriptor.fileObject().getFile().toAbsolutePath().toString();\n+    }\n+\n+    Set<String> getNamesOfCompiledClasses() {\n+        return Set.copyOf(inMemoryClasses.keySet());\n+    }\n+\n+    \/**\n+     * Compiles a source file, placing the class files in a map in memory.\n+     * Any messages generated during compilation will be written to the stream\n+     * provided when this object was created.\n+     *\n+     * @return the list of top-level types defined in the source file\n+     * @throws Fault if any compilation errors occur, or if no class was found\n+     *\/\n+    List<String> compileProgram() throws Fault {\n+        var units = new ArrayList<JavaFileObject>();\n+        units.add(descriptor.fileObject());\n+        if (descriptor.isModular()) {\n+            var root = descriptor.sourceRootPath();\n+            units.add(standardFileManager.getJavaFileObject(root.resolve(\"module-info.java\")));\n+        }\n+        var opts = options.forProgramCompilation();\n+        var context = new Context();\n+        MemoryPreview.registerInstance(context);\n+        var task = compiler.getTask(out, memoryFileManager, null, opts, null, units, context);\n+        var fileUri = descriptor.fileObject().toUri();\n+        var names = new ArrayList<String>();\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void started(TaskEvent event) {\n+                if (event.getKind() != TaskEvent.Kind.ANALYZE) return;\n+                TypeElement element = event.getTypeElement();\n+                if (element.getNestingKind() != NestingKind.TOP_LEVEL) return;\n+                JavaFileObject source = event.getSourceFile();\n+                if (source == null) return;\n+                if (!source.toUri().equals(fileUri)) return;\n+                ElementKind kind = element.getKind();\n+                if (kind != ElementKind.CLASS\n+                        && kind != ElementKind.ENUM\n+                        && kind != ElementKind.INTERFACE\n+                        && kind != ElementKind.RECORD)\n+                    return;\n+                var name = element.getQualifiedName().toString();\n+                names.add(name);\n+            }\n+        });\n+        var ok = task.call();\n+        if (!ok) {\n+            throw new Fault(Errors.CompilationFailed);\n+        }\n+        if (names.isEmpty()) {\n+            throw new Fault(Errors.NoClass);\n+        }\n+        return List.copyOf(names);\n+    }\n+\n+    \/**\n+     * Determines a source file from the given class name and compiles it.\n+     * Any messages generated during compilation will be written to the stream\n+     * provided when this object was created.\n+     * <p>\n+     * This method is passed a reference to an instance of {@link MemoryClassLoader},\n+     * that uses it to compile a source file on demand.\n+     *\n+     * @param name the name of the class to be compiled.\n+     * @return the byte code of the compiled class or {@code null}\n+     *         if no source file was found for the given name\n+     *\/\n+    byte[] compileJavaFileByName(String name) {\n+        \/\/ Determine source file from class name.\n+        var firstDollarSign = name.indexOf('$'); \/\/ [package . ] name [ $ enclosed [$ deeper] ]\n+        var packageAndClassName = firstDollarSign == -1 ? name : name.substring(0, firstDollarSign);\n+        var path = packageAndClassName.replace('.', '\/') + \".java\";\n+        var file = descriptor.sourceRootPath().resolve(path);\n+\n+        \/\/ Trivial case: no matching source file exists\n+        if (Files.notExists(file)) return null;\n+\n+        \/\/ Compile source file (unit) with similar options as the program.\n+        var opts = options.forSubsequentCompilations();\n+        var unit = standardFileManager.getJavaFileObject(file);\n+        var task = compiler.getTask(out, memoryFileManager, null, opts, null, List.of(unit));\n+\n+        var ok = task.call();\n+        if (!ok) {\n+            var fault = new Fault(Errors.CompilationFailed);\n+            \/\/ Don't throw fault - fail fast!\n+            out.println(fault.getMessage());\n+            System.exit(2);\n+        }\n+\n+        \/\/ The memory file manager stored bytes in the context map, indexed by the class names.\n+        return inMemoryClasses.get(name);\n+    }\n+\n+    \/**\n+     * Create a new class load for the main entry-point class.\n+     *\n+     * @param parent the class loader to be used as the parent loader\n+     * @param mainClassName the fully-qualified name of the application class to load\n+     * @return class loader object able to find and load the desired class\n+     * @throws ClassNotFoundException if the class cannot be located\n+     * @throws Fault if a modular application class is in the unnamed package\n+     *\/\n+    ClassLoader newClassLoaderFor(ClassLoader parent, String mainClassName) throws ClassNotFoundException, Fault {\n+        var moduleInfoBytes = inMemoryClasses.get(\"module-info\");\n+        if (moduleInfoBytes == null) {\n+            \/\/ Trivial case: no compiled module descriptor available, no extra module layer required\n+            return new MemoryClassLoader(inMemoryClasses, parent, null, descriptor, this::compileJavaFileByName);\n+        }\n+\n+        \/\/ Ensure main class resides in a named package.\n+        var lastDotInMainClassName = mainClassName.lastIndexOf('.');\n+        if (lastDotInMainClassName == -1) {\n+            throw new Fault(Errors.UnnamedPkgNotAllowedNamedModules);\n+        }\n+\n+        var bootLayer = ModuleLayer.boot();\n+        var parentLayer = bootLayer;\n+        var parentLoader = parent;\n+\n+        \/\/ Optionally create module layer for all modules on the module path.\n+        var modulePathFinder = createModuleFinderFromModulePath();\n+        var modulePathModules = modulePathFinder.findAll().stream().map(ModuleReference::descriptor).map(ModuleDescriptor::name).toList();\n+        if (!modulePathModules.isEmpty()) {\n+            var modulePathConfiguration = bootLayer.configuration().resolveAndBind(modulePathFinder, ModuleFinder.of(), Set.copyOf(modulePathModules));\n+            var modulePathLayer = ModuleLayer.defineModulesWithOneLoader(modulePathConfiguration, List.of(bootLayer), parent).layer();\n+            parentLayer = modulePathLayer;\n+            parentLoader = modulePathLayer.findLoader(modulePathModules.getFirst());\n+        }\n+\n+        \/\/ Create in-memory module layer for the modular application.\n+        var applicationModule = ModuleDescriptor.read(ByteBuffer.wrap(moduleInfoBytes), descriptor::computePackageNames);\n+        var memoryFinder = new MemoryModuleFinder(inMemoryClasses, applicationModule, descriptor);\n+        var memoryConfig = parentLayer.configuration().resolveAndBind(memoryFinder, ModuleFinder.of(), Set.of(applicationModule.name()));\n+        var memoryClassLoader = new MemoryClassLoader(inMemoryClasses, parentLoader, applicationModule, descriptor, this::compileJavaFileByName);\n+        var memoryController = ModuleLayer.defineModules(memoryConfig, List.of(parentLayer), __ -> memoryClassLoader);\n+        var memoryLayer = memoryController.layer();\n+\n+        \/\/ Make application class accessible from the calling (unnamed) module, that loaded this class.\n+        var module = memoryLayer.findModule(applicationModule.name()).orElseThrow();\n+        var mainClassNamePackageName = mainClassName.substring(0, lastDotInMainClassName);\n+        memoryController.addOpens(module, mainClassNamePackageName, getClass().getModule());\n+\n+        return memoryLayer.findLoader(applicationModule.name());\n+    }\n+\n+    private static ModuleFinder createModuleFinderFromModulePath() {\n+        var elements = System.getProperty(\"jdk.module.path\");\n+        if (elements == null) {\n+            return ModuleFinder.of();\n+        }\n+        var paths = Arrays.stream(elements.split(File.pathSeparator)).map(Path::of);\n+        return ModuleFinder.of(paths.toArray(Path[]::new));\n+    }\n+\n+    static class MemoryPreview extends Preview {\n+        static void registerInstance(Context context) {\n+            context.put(previewKey, (Factory<Preview>)MemoryPreview::new);\n+        }\n+\n+        MemoryPreview(Context context) {\n+            super(context);\n+        }\n+\n+        @Override\n+        public void reportDeferredDiagnostics() {\n+            \/\/ suppress diagnostics like \"Note: Recompile with -Xlint:preview for details.\"\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardLocation;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.Map;\n+\n+\/**\n+ * An in-memory file manager.\n+ *\n+ * <p>Class files (of kind {@link JavaFileObject.Kind#CLASS CLASS}) written to\n+ * {@link StandardLocation#CLASS_OUTPUT} will be written to an in-memory cache.\n+ * All other file manager operations will be delegated to a specified file manager.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+final class MemoryFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+    private final Map<String, byte[]> map;\n+\n+    MemoryFileManager(Map<String, byte[]> map, JavaFileManager delegate) {\n+        super(delegate);\n+        this.map = map;\n+    }\n+\n+    @Override\n+    public JavaFileObject getJavaFileForOutput(Location location, String className,\n+                                               JavaFileObject.Kind kind, FileObject sibling) throws IOException {\n+        if (location == StandardLocation.CLASS_OUTPUT && kind == JavaFileObject.Kind.CLASS) {\n+            return createInMemoryClassFile(className);\n+        } else {\n+            return super.getJavaFileForOutput(location, className, kind, sibling);\n+        }\n+    }\n+\n+    private JavaFileObject createInMemoryClassFile(String className) {\n+        URI uri = URI.create(\"memory:\/\/\/\" + className.replace('.', '\/') + \".class\");\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n+            @Override\n+            public OutputStream openOutputStream() {\n+                return new ByteArrayOutputStream() {\n+                    @Override\n+                    public void close() throws IOException {\n+                        super.close();\n+                        map.put(className, toByteArray());\n+                    }\n+                };\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public boolean contains(Location location, FileObject fo) throws IOException {\n+        return fo instanceof ProgramFileObject || super.contains(location, fo);\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryFileManager.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileVisitOption;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.module.Resources;\n+\n+\/**\n+ * An in-memory module finder, that uses an in-memory cache of classes written by\n+ * {@link MemoryFileManager}.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+record MemoryModuleFinder(Map<String, byte[]> classes,\n+                          ModuleDescriptor descriptor,\n+                          ProgramDescriptor programDescriptor) implements ModuleFinder {\n+    @Override\n+    public Optional<ModuleReference> find(String name) {\n+        if (name.equals(descriptor.name())) {\n+            return Optional.of(new MemoryModuleReference());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    public Set<ModuleReference> findAll() {\n+        return Set.of(new MemoryModuleReference());\n+    }\n+\n+    class MemoryModuleReference extends ModuleReference {\n+        protected MemoryModuleReference() {\n+            super(descriptor, URI.create(\"memory:\/\/\/\" + descriptor.toNameAndVersion()));\n+        }\n+\n+        @Override\n+        public ModuleReader open() {\n+            return new MemoryModuleReader();\n+        }\n+    }\n+\n+    \/\/ Implementation based on jdk.internal.module.ModuleReferences#ExplodedModuleReader\n+    class MemoryModuleReader implements ModuleReader {\n+        private volatile boolean closed;\n+\n+        private void ensureOpen() throws IOException {\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+        }\n+\n+        public Optional<URI> find(String name) throws IOException {\n+            ensureOpen();\n+            \/\/ Try to find an in-memory compiled class first\n+            if (classes.get(name) != null) {\n+                return Optional.of(URI.create(\"memory:\/\/\/\" + name.replace('.', '\/') + \".class\"));\n+            }\n+            \/\/ Try to find file resource from root path next\n+            Path path = Resources.toFilePath(programDescriptor.sourceRootPath(), name);\n+            if (path != null) {\n+                try {\n+                    return Optional.of(path.toUri());\n+                } catch (IOError error) {\n+                    throw (IOException) error.getCause();\n+                }\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        public Optional<InputStream> open(String name) throws IOException {\n+            ensureOpen();\n+            \/\/ Try to find an in-memory compiled class first\n+            byte[] bytes = classes.get(name);\n+            if (bytes != null) {\n+                return Optional.of(new ByteArrayInputStream(bytes));\n+            }\n+            \/\/ Try to find file resource from root path next\n+            Path path = Resources.toFilePath(programDescriptor.sourceRootPath(), name);\n+            return path != null ? Optional.of(Files.newInputStream(path)) : Optional.empty();\n+        }\n+\n+        public Optional<ByteBuffer> read(String name) throws IOException {\n+            ensureOpen();\n+            \/\/ Try to find an in-memory compiled class first\n+            byte[] bytes = classes.get(name);\n+            if (bytes != null) {\n+                return Optional.of(ByteBuffer.wrap(bytes));\n+            }\n+            \/\/ Try to find file resource from root path next\n+            Path path = Resources.toFilePath(programDescriptor.sourceRootPath(), name);\n+            return path != null ? Optional.of(ByteBuffer.wrap(Files.readAllBytes(path))) : Optional.empty();\n+        }\n+\n+        public Stream<String> list() throws IOException {\n+            ensureOpen();\n+            var root = programDescriptor.sourceRootPath();\n+            var list = new ArrayList<String>();\n+            classes.keySet().stream().map(name -> name.replace('.', '\/') + \".class\").forEach(list::add);\n+            try (var stream = Files.walk(root, Integer.MAX_VALUE, new FileVisitOption[0])) {\n+                  stream\n+                    .map(file -> Resources.toResourceName(root, file))\n+                    .filter(name -> !name.isEmpty())\n+                    .forEach(list::add);\n+            }\n+            Collections.sort(list);\n+            return list.stream();\n+        }\n+\n+        public void close() {\n+            this.closed = true;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryModuleFinder.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.tools.javac.api.JavacTool;\n+import com.sun.tools.javac.resources.LauncherProperties.Errors;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+\/**\n+ * Describes a launch-able Java compilation unit.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+public record ProgramDescriptor(ProgramFileObject fileObject, Optional<String> packageName, Path sourceRootPath) {\n+    static ProgramDescriptor of(ProgramFileObject fileObject) throws Fault {\n+        var file = fileObject.getFile();\n+        try {\n+            var compiler = JavacTool.create();\n+            var standardFileManager = compiler.getStandardFileManager(null, null, null);\n+            var units = List.of(fileObject);\n+            var task = compiler.getTask(null, standardFileManager, diagnostic -> {}, null, null, units);\n+            for (var tree : task.parse()) {\n+                var packageTree = tree.getPackage();\n+                if (packageTree != null) {\n+                    var packageName = packageTree.getPackageName().toString();\n+                    var root = computeSourceRootPath(file, packageName);\n+                    return new ProgramDescriptor(fileObject, Optional.of(packageName), root);\n+                }\n+            }\n+        } catch (IOException ignore) {\n+            \/\/ fall through to let actual compilation determine the error message\n+        }\n+        var root = computeSourceRootPath(file, \"\");\n+        return new ProgramDescriptor(fileObject, Optional.empty(), root);\n+    }\n+\n+    public static Path computeSourceRootPath(Path program, String packageName) {\n+        var absolute = program.normalize().toAbsolutePath();\n+        var absoluteRoot = absolute.getRoot();\n+        assert absoluteRoot != null;\n+        \/\/ unnamed package \"\": program's directory is the root path\n+        if (packageName.isEmpty()) {\n+            var parent = absolute.getParent();\n+            if (parent == null) return absoluteRoot;\n+            return parent;\n+        }\n+        \/\/ named package \"a.b.c\": ensure end of path to program is \"a\/b\/c\"\n+        var packagePath = Path.of(packageName.replace('.', '\/'));\n+        var ending = packagePath.resolve(program.getFileName());\n+        if (absolute.endsWith(ending)) {\n+            var max = absolute.getNameCount() - ending.getNameCount();\n+            if (max == 0) return absoluteRoot;\n+            return absoluteRoot.resolve(absolute.subpath(0, max));\n+        }\n+        throw new Fault(Errors.MismatchEndOfPathAndPackageName(packageName, program));\n+    }\n+\n+    public boolean isModular() {\n+        return Files.exists(sourceRootPath.resolve(\"module-info.java\"));\n+    }\n+\n+    public Set<String> computePackageNames() {\n+        try (var stream = Files.find(sourceRootPath, 99, (path, attr) -> attr.isDirectory())) {\n+            var names = new TreeSet<String>();\n+            stream.filter(ProgramDescriptor::containsAtLeastOneRegularFile)\n+                  .map(sourceRootPath::relativize)\n+                  .map(Path::toString)\n+                  .filter(string -> !string.isEmpty())\n+                  .map(string -> string.replace(File.separatorChar, '.'))\n+                  .forEach(names::add);\n+            return names;\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private static boolean containsAtLeastOneRegularFile(Path directory) {\n+        try (var stream = Files.newDirectoryStream(directory, Files::isRegularFile)) {\n+            return stream.iterator().hasNext();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramDescriptor.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.tools.javac.resources.LauncherProperties.Errors;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static javax.tools.JavaFileObject.Kind.SOURCE;\n+\n+\/**\n+ * The program to launch as Java file object.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+final class ProgramFileObject extends SimpleJavaFileObject {\n+\n+    \/**\n+     * Reads a source file, ignoring the first line if it is not a Java source file and\n+     * it begins with {@code #!}.\n+     *\n+     * <p>If it is not a Java source file, and if the first two bytes are {@code #!},\n+     * indicating a \"magic number\" of an executable text file, the rest of the first line\n+     * up to but not including the newline is ignored. All characters after the first two are\n+     * read in the {@link Charset#defaultCharset()} default platform encoding}.\n+     *\n+     * @param file the file\n+     * @return a file object containing the content of the file\n+     * @throws Fault if an error occurs while reading the file\n+     *\/\n+    static ProgramFileObject of(Path file) throws Fault {\n+        \/\/ use a BufferedInputStream to guarantee that we can use mark and reset.\n+        try (BufferedInputStream in = new BufferedInputStream(Files.newInputStream(file))) {\n+            boolean ignoreFirstLine;\n+            if (file.getFileName().toString().endsWith(\".java\")) {\n+                ignoreFirstLine = false;\n+            } else {\n+                in.mark(2);\n+                ignoreFirstLine = (in.read() == '#') && (in.read() == '!');\n+                if (!ignoreFirstLine) {\n+                    in.reset();\n+                }\n+            }\n+            try (BufferedReader r = new BufferedReader(new InputStreamReader(in, Charset.defaultCharset()))) {\n+                StringBuilder sb = new StringBuilder();\n+                if (ignoreFirstLine) {\n+                    r.readLine();\n+                    sb.append(System.lineSeparator()); \/\/ preserve line numbers\n+                }\n+                char[] buf = new char[1024];\n+                int n;\n+                while ((n = r.read(buf, 0, buf.length)) != -1) {\n+                    sb.append(buf, 0, n);\n+                }\n+                return new ProgramFileObject(file, sb, ignoreFirstLine);\n+            }\n+        } catch (IOException e) {\n+            throw new Fault(Errors.CantReadFile(file, e));\n+        }\n+    }\n+\n+    private final Path file;\n+    private final CharSequence chars;\n+    private final boolean ignoreFirstLine;\n+\n+    ProgramFileObject(Path file, CharSequence chars, boolean ignoreFirstLine) {\n+        super(file.toUri(), SOURCE);\n+        this.file = file;\n+        this.chars = chars;\n+        this.ignoreFirstLine = ignoreFirstLine;\n+    }\n+\n+    public Path getFile() {\n+        return file;\n+    }\n+\n+    public boolean isFirstLineIgnored() {\n+        return ignoreFirstLine;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return file.toString();\n+    }\n+\n+    @Override\n+    public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+        return chars;\n+    }\n+\n+    @Override\n+    public boolean isNameCompatible(String simpleName, JavaFileObject.Kind kind) {\n+        \/\/ reject package-info and module-info; accept other names\n+        return (kind == JavaFileObject.Kind.SOURCE)\n+                && SourceVersion.isIdentifier(simpleName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"JavacSourceLauncher[\" + file + \"]\";\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramFileObject.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.tools.javac.code.Source;\n+import com.sun.tools.javac.main.Option;\n+import com.sun.tools.javac.resources.LauncherProperties.Errors;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Represents runtime arguments that are relevant to {@code javac}.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+record RelevantJavacOptions(List<String> forProgramCompilation,\n+                            List<String> forSubsequentCompilations) {\n+\n+    \/**\n+     * Returns the subset of the runtime arguments that are relevant to {@code javac}.\n+     * Generally, the relevant options are those for setting paths and for configuring the\n+     * module system.\n+     *\n+     * @param program the program descriptor\n+     * @param runtimeArgs the runtime arguments\n+     * @return the subset of the runtime arguments\n+     *\/\n+    static RelevantJavacOptions of(ProgramDescriptor program, String... runtimeArgs) throws Fault {\n+        var programOptions = new ArrayList<String>();\n+        var subsequentOptions = new ArrayList<String>();\n+\n+        String sourceOpt = System.getProperty(\"jdk.internal.javac.source\");\n+        if (sourceOpt != null) {\n+            Source source = Source.lookup(sourceOpt);\n+            if (source == null) {\n+                throw new Fault(Errors.InvalidValueForSource(sourceOpt));\n+            }\n+            programOptions.addAll(List.of(\"--release\", sourceOpt));\n+            subsequentOptions.addAll(List.of(\"--release\", sourceOpt));\n+        }\n+\n+        for (int i = 0; i < runtimeArgs.length; i++) {\n+            String arg = runtimeArgs[i];\n+            String opt = arg, value = null;\n+            if (arg.startsWith(\"--\")) {\n+                int eq = arg.indexOf('=');\n+                if (eq > 0) {\n+                    opt = arg.substring(0, eq);\n+                    value = arg.substring(eq + 1);\n+                }\n+            }\n+\n+            switch (opt) {\n+                \/\/ The following options all expect a value, either in the following\n+                \/\/ position, or after '=', for options beginning \"--\".\n+                case \"--class-path\", \"-classpath\", \"-cp\",\n+                        \"--module-path\", \"-p\",\n+                        \"--add-exports\", \"--add-modules\",\n+                        \"--limit-modules\",\n+                        \"--patch-module\",\n+                        \"--upgrade-module-path\" -> {\n+                    if (value == null) {\n+                        if (i == runtimeArgs.length - 1) {\n+                            \/\/ should not happen when invoked from launcher\n+                            throw new Fault(Errors.NoValueForOption(opt));\n+                        }\n+                        value = runtimeArgs[++i];\n+                    }\n+                    if (opt.equals(\"--add-modules\")) {\n+                        var modules = computeListOfAddModules(program, value);\n+                        if (modules.isEmpty()) {\n+                            break;\n+                        }\n+                        value = String.join(\",\", modules);\n+                    }\n+                    programOptions.add(opt);\n+                    programOptions.add(value);\n+                    var javacOption = Option.lookup(opt);\n+                    if (javacOption != null && javacOption.isInBasicOptionGroup()) {\n+                        subsequentOptions.add(opt);\n+                        subsequentOptions.add(value);\n+                    }\n+                }\n+                case \"--enable-preview\" -> {\n+                    programOptions.add(opt);\n+                    subsequentOptions.add(opt);\n+                    if (sourceOpt == null) {\n+                        throw new Fault(Errors.EnablePreviewRequiresSource);\n+                    }\n+                }\n+                default -> {\n+                    if (opt.startsWith(\"-agentlib:jdwp=\") || opt.startsWith(\"-Xrunjdwp:\")) {\n+                        programOptions.add(\"-g\");\n+                        subsequentOptions.add(\"-g\");\n+                    }\n+                }\n+                \/\/ ignore all other runtime args\n+            }\n+        }\n+\n+        \/\/ add implicit options to both lists\n+        var implicitOptions = \"\"\"\n+                -proc:none\n+                -implicit:none\n+                -Xprefer:source\n+                -Xdiags:verbose\n+                -Xlint:deprecation\n+                -Xlint:unchecked\n+                -Xlint:-options\n+                -XDsourceLauncher\n+                \"\"\";\n+        implicitOptions.lines()\n+                .filter(line -> !line.isBlank())\n+                .forEach(option -> {\n+                    programOptions.add(option);\n+                    subsequentOptions.add(option);\n+                });\n+\n+        return new RelevantJavacOptions(List.copyOf(programOptions), List.copyOf(subsequentOptions));\n+    }\n+\n+    private static List<String> computeListOfAddModules(ProgramDescriptor program, String value) {\n+        var modules = new ArrayList<>(List.of(value.split(\",\")));\n+        \/\/ these options are only supported at run time;\n+        \/\/ they are not required or supported at compile time\n+        modules.remove(\"ALL-DEFAULT\");\n+        modules.remove(\"ALL-SYSTEM\");\n+\n+        \/\/ ALL-MODULE-PATH can only be used when compiling the\n+        \/\/ unnamed module or when compiling in the context of\n+        \/\/ an automatic module\n+        if (program.isModular()) {\n+            modules.remove(\"ALL-MODULE-PATH\");\n+        }\n+        return modules;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/RelevantJavacOptions.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Contains information about the launched program.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\n+ * @param programClass the class instance of the launched program.\n+ * @param classNames the names of classes compiled into memory.\n+ *\/\n+public record Result(Class<?> programClass, Set<String> classNames) {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Result.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.launcher;\n+\n+import com.sun.tools.javac.resources.LauncherProperties.Errors;\n+\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.misc.MethodFinder;\n+import jdk.internal.misc.VM;\n+\n+\/**\n+ * Compiles a source file, and executes the main method it contains.\n+ *\n+ * <p><strong>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own\n+ * risk.  This code and its internal interfaces are subject to change\n+ * or deletion without notice.<\/strong><\/p>\n+ *\/\n+public final class SourceLauncher {\n+    \/**\n+     * Compiles a source file, and executes the main method it contains.\n+     *\n+     * <p>This is normally invoked from the Java launcher, either when\n+     * the {@code --source} option is used, or when the first argument\n+     * that is not part of a runtime option ends in {@code .java}.\n+     *\n+     * <p>The first entry in the {@code args} array is the source file\n+     * to be compiled and run; all subsequent entries are passed as\n+     * arguments to the main method of the first class found in the file.\n+     *\n+     * <p>If any problem occurs before executing the main class, it will\n+     * be reported to the standard error stream, and the JVM will be\n+     * terminated by calling {@code System.exit} with a non-zero return code.\n+     *\n+     * @param args the arguments\n+     * @throws Throwable if the main method throws an exception\n+     *\/\n+    public static void main(String... args) throws Throwable {\n+        try {\n+            new SourceLauncher(System.err)\n+                    .checkSecurityManager()\n+                    .run(VM.getRuntimeArguments(), args);\n+        } catch (Fault f) {\n+            System.err.println(f.getMessage());\n+            System.exit(1);\n+        } catch (InvocationTargetException e) {\n+            \/\/ leave VM to handle the stacktrace, in the standard manner\n+            throw e.getCause();\n+        }\n+    }\n+\n+    \/** Stream for reporting errors, such as compilation errors. *\/\n+    private final PrintWriter out;\n+\n+    \/**\n+     * Creates an instance of this class, providing a stream to which to report\n+     * any errors.\n+     *\n+     * @param out the stream\n+     *\/\n+    public SourceLauncher(PrintStream out) {\n+        this(new PrintWriter(new OutputStreamWriter(out), true));\n+    }\n+\n+    \/**\n+     * Creates an instance of this class, providing a stream to which to report\n+     * any errors.\n+     *\n+     * @param out the stream\n+     *\/\n+    public SourceLauncher(PrintWriter out) {\n+        this.out = out;\n+    }\n+\n+    \/**\n+     * Checks if a security manager is present and throws an exception if so.\n+     * @return this object\n+     * @throws Fault if a security manager is present\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private SourceLauncher checkSecurityManager() throws Fault {\n+        if (System.getSecurityManager() != null) {\n+            throw new Fault(Errors.SecurityManager);\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Compiles a source file, and executes the main method it contains.\n+     *\n+     * <p>The first entry in the {@code args} array is the source file\n+     * to be compiled and run; all subsequent entries are passed as\n+     * arguments to the main method of the first class found in the file.\n+     *\n+     * <p>Options for {@code javac} are obtained by filtering the runtime arguments.\n+     *\n+     * <p>If the main method throws an exception, it will be propagated in an\n+     * {@code InvocationTargetException}. In that case, the stack trace of the\n+     * target exception will be truncated such that the main method will be the\n+     * last entry on the stack. In other words, the stack frames leading up to the\n+     * invocation of the main method will be removed.\n+     *\n+     * @param runtimeArgs the runtime arguments\n+     * @param args the arguments\n+     * @throws Fault if a problem is detected before the main method can be executed\n+     * @throws InvocationTargetException if the main method throws an exception\n+     *\/\n+    public Result run(String[] runtimeArgs, String[] args) throws Fault, InvocationTargetException {\n+        Path file = getFile(args);\n+\n+        ProgramDescriptor program = ProgramDescriptor.of(ProgramFileObject.of(file));\n+        RelevantJavacOptions options = RelevantJavacOptions.of(program, runtimeArgs);\n+        MemoryContext context = new MemoryContext(out, program, options);\n+        List<String> names = context.compileProgram();\n+\n+        String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);\n+        var appClass = execute(names, mainArgs, context);\n+\n+        return new Result(appClass, context.getNamesOfCompiledClasses());\n+    }\n+\n+    \/**\n+     * Returns the path for the filename found in the first of an array of arguments.\n+     *\n+     * @param args the array\n+     * @return the path, as given in the array of args\n+     * @throws Fault if there is a problem determining the path, or if the file does not exist\n+     *\/\n+    private Path getFile(String[] args) throws Fault {\n+        if (args.length == 0) {\n+            \/\/ should not happen when invoked from launcher\n+            throw new Fault(Errors.NoArgs);\n+        }\n+        Path file;\n+        try {\n+            file = Paths.get(args[0]);\n+        } catch (InvalidPathException e) {\n+            throw new Fault(Errors.InvalidFilename(args[0]));\n+        }\n+        if (!Files.exists(file)) {\n+            \/\/ should not happen when invoked from launcher\n+            throw new Fault(Errors.FileNotFound(file));\n+        }\n+        return file;\n+    }\n+\n+    \/**\n+     * Invokes the {@code main} method of a program class, using a class loader that\n+     * will load recently compiled classes from memory.\n+     *\n+     * @param topLevelClassNames the names of classes in the program compilation unit\n+     * @param mainArgs the arguments for the {@code main} method\n+     * @param context the context for the class to be executed\n+     * @throws Fault if there is a problem finding or invoking the {@code main} method\n+     * @throws InvocationTargetException if the {@code main} method throws an exception\n+     *\/\n+    private Class<?> execute(List<String> topLevelClassNames, String[] mainArgs, MemoryContext context)\n+            throws Fault, InvocationTargetException {\n+        System.setProperty(\"jdk.launcher.sourcefile\", context.getSourceFileAsString());\n+        ClassLoader parentLoader = ClassLoader.getSystemClassLoader();\n+\n+        \/\/ 1. Find a main method in the first class and if there is one - invoke it\n+        Class<?> firstClass;\n+        String firstClassName = topLevelClassNames.getFirst();\n+        try {\n+            ClassLoader loader = context.newClassLoaderFor(parentLoader, firstClassName);\n+            firstClass = Class.forName(firstClassName, false, loader);\n+        } catch (ClassNotFoundException e) {\n+            throw new Fault(Errors.CantFindClass(firstClassName));\n+        }\n+\n+        Method mainMethod = MethodFinder.findMainMethod(firstClass);\n+        if (mainMethod == null) {\n+            \/\/ 2. If the first class doesn't have a main method, look for a class with a matching name\n+            var compilationUnitName = context.getProgramDescriptor().fileObject().getFile().getFileName().toString();\n+            assert compilationUnitName.endsWith(\".java\");\n+            var expectedName = compilationUnitName.substring(0, compilationUnitName.length() - 5);\n+            var actualName = topLevelClassNames.stream()\n+                    .filter(name -> name.equals(expectedName))\n+                    .findFirst()\n+                    .orElseThrow(() -> new Fault(Errors.CantFindClass(expectedName)));\n+\n+            Class<?> actualClass;\n+            try {\n+                actualClass = Class.forName(actualName, false, firstClass.getClassLoader());\n+            } catch (ClassNotFoundException ignore) {\n+                throw new Fault(Errors.CantFindClass(actualName));\n+            }\n+            mainMethod = MethodFinder.findMainMethod(actualClass);\n+            if (mainMethod == null) {\n+                throw new Fault(Errors.CantFindMainMethod(actualName));\n+            }\n+        }\n+\n+        \/\/ selected main method instance points back to its declaring class\n+        Class<?> mainClass = mainMethod.getDeclaringClass();\n+        String mainClassName = mainClass.getName();\n+\n+        var isStatic = Modifier.isStatic(mainMethod.getModifiers());\n+\n+        Object instance = null;\n+\n+        if (!isStatic) {\n+            Constructor<?> constructor;\n+            try {\n+                constructor = mainClass.getDeclaredConstructor();\n+            } catch (NoSuchMethodException e) {\n+                throw new Fault(Errors.CantFindConstructor(mainClassName));\n+            }\n+\n+            try {\n+                constructor.setAccessible(true);\n+                instance = constructor.newInstance();\n+            } catch (InstantiationException | IllegalAccessException e) {\n+                throw new Fault(Errors.CantAccessConstructor(mainClassName));\n+            }\n+        }\n+\n+        try {\n+            \/\/ Similar to sun.launcher.LauncherHelper#executeMainClass\n+            \/\/ but duplicated here to prevent additional launcher frames\n+            mainMethod.setAccessible(true);\n+            Object receiver = isStatic ? mainClass : instance;\n+\n+            if (mainMethod.getParameterCount() == 0) {\n+                mainMethod.invoke(receiver);\n+            } else {\n+                mainMethod.invoke(receiver, (Object)mainArgs);\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new Fault(Errors.CantAccessMainMethod(mainClassName));\n+        } catch (InvocationTargetException e) {\n+            \/\/ remove stack frames for source launcher\n+            int invocationFrames = e.getStackTrace().length;\n+            Throwable target = e.getCause();\n+            StackTraceElement[] targetTrace = target.getStackTrace();\n+            target.setStackTrace(Arrays.copyOfRange(targetTrace, 0, targetTrace.length - invocationFrames));\n+            throw e;\n+        }\n+\n+        return mainClass;\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -86,0 +86,4 @@\n+ * <p>A subset of options is relevant to the source launcher implementation\n+ * located in {@link com.sun.tools.javac.launcher} package. When an option is\n+ * added, changed, or removed, also update the {@code RelevantJavacOptions} class\n+ * in the launcher package accordingly.\n@@ -1084,0 +1088,4 @@\n+    public boolean isInBasicOptionGroup() {\n+        return group == BASIC;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,7 @@\n+\n+launcher.err.unnamed.pkg.not.allowed.named.modules=\\\n+    unnamed package is not allowed in named modules\n+\n+# 0: string, 1: path\n+launcher.err.mismatch.end.of.path.and.package.name=\\\n+    end of path to source file does not match its package name {0}: {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-        final int ITERATIONS = 512; \/\/ Total number of compositions is 1 + (iterations*2)\n+        final int ITERATIONS = 128; \/\/ Total number of compositions is 1 + (iterations*2)\n","filename":"test\/jdk\/java\/util\/stream\/GathererTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @bug 8304400\n+ * @summary Test basic features of javac's source-code launcher\n+ * @modules jdk.compiler\/com.sun.tools.javac.launcher\n+ * @run junit BasicSourceLauncherTests\n+ *\/\n+class BasicSourceLauncherTests {\n+    @Test\n+    void launchHelloClassInHelloJavaUnit(@TempDir Path base) throws Exception {\n+        var hello = Files.writeString(base.resolve(\"Hello.java\"),\n+                \"\"\"\n+                public class Hello {\n+                  public static void main(String... args) {\n+                    System.out.println(\"Hi\");\n+                  }\n+                }\n+                \"\"\");\n+\n+        var run = Run.of(hello);\n+        var result = run.result();\n+        assertAll(\"# \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Hi\n+                        \"\"\".lines(), run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()),\n+                () -> assertEquals(Set.of(\"Hello\"), result.classNames()),\n+                () -> assertNotNull(result.programClass().getResource(\"Hello.java\")),\n+                () -> assertNotNull(result.programClass().getResource(\"Hello.class\")));\n+    }\n+\n+    @Test\n+    void launchHelloClassInHalloJavaUnit(@TempDir Path base) throws Exception {\n+        var hallo = Files.writeString(base.resolve(\"Hallo.java\"),\n+                \"\"\"\n+                public class Hello {\n+                  public static void main(String... args) {\n+                    System.out.println(\"Hi!\");\n+                  }\n+                }\n+                \"\"\");\n+\n+        var run = Run.of(hallo);\n+        var result = run.result();\n+        assertAll(\"# \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Hi!\n+                        \"\"\".lines(), run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()),\n+                () -> assertEquals(Set.of(\"Hello\"), result.classNames()),\n+                () -> assertNotNull(result.programClass().getResource(\"Hallo.java\")),\n+                () -> assertNotNull(result.programClass().getResource(\"Hello.class\")));\n+    }\n+\n+    @Test\n+    void launchMinifiedJavaProgram(@TempDir Path base) throws Exception {\n+        var hi = Files.writeString(base.resolve(\"Hi.java\"),\n+                \"\"\"\n+                void main() {\n+                  System.out.println(\"Hi!\");\n+                }\n+                \"\"\");\n+\n+        \/\/ Replace with plain Run.of(hi) once implict classes are out of preview\n+        System.setProperty(\"jdk.internal.javac.source\", String.valueOf(Runtime.version().feature()));\n+        var run = Run.of(hi, List.of(\"--enable-preview\"), List.of());\n+        System.clearProperty(\"jdk.internal.javac.source\");\n+\n+        assertAll(\"# \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Hi!\n+                        \"\"\".lines(), run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/launcher\/BasicSourceLauncherTests.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * The body of this test is in ${test.src}\/src\/CLTest.java,\n+ * The body of this test is in ${test.src}\/src\/p\/q\/CLTest.java,\n@@ -54,1 +54,1 @@\n-        Path file = Paths.get(tb.testSrc).resolve(\"src\").resolve(\"CLTest.java\");\n+        Path file = Paths.get(tb.testSrc).resolve(\"src\/p\/q\").resolve(\"CLTest.java\");\n@@ -57,1 +57,1 @@\n-                    \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\")\n+                       \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\")\n","filename":"test\/langtools\/tools\/javac\/launcher\/GetResourceTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304400\n+ * @summary Test source launcher running Java programs contained in one module\n+ * @modules jdk.compiler\/com.sun.tools.javac.launcher\n+ * @run junit ModuleSourceLauncherTests\n+ *\/\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+\n+class ModuleSourceLauncherTests {\n+    @Test\n+    void testHelloModularWorld(@TempDir Path base) throws Exception {\n+        var packageFolder = Files.createDirectories(base.resolve(\"com\/greetings\"));\n+        var mainFile = Files.writeString(packageFolder.resolve(\"Main.java\"),\n+                \"\"\"\n+                package com.greetings;\n+                public class Main {\n+                  public static void main(String... args) {\n+                    System.out.println(\"Greetings!\");\n+                    System.out.println(\"   module -> \" + Main.class.getModule().getName());\n+                    System.out.println(\"  package -> \" + Main.class.getPackageName());\n+                    System.out.println(\"    class -> \" + Main.class.getSimpleName());\n+                  }\n+                }\n+                \"\"\");\n+        Files.writeString(base.resolve(\"module-info.java\"),\n+                \"\"\"\n+                module com.greetings {}\n+                \"\"\");\n+\n+        var run = Run.of(mainFile);\n+        assertAll(\"Run -> \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Greetings!\n+                           module -> com.greetings\n+                          package -> com.greetings\n+                            class -> Main\n+                        \"\"\".lines(),\n+                        run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception())\n+        );\n+\n+        var module = run.result().programClass().getModule();\n+        assertEquals(\"com.greetings\", module.getName());\n+        var reference = module.getLayer().configuration().findModule(module.getName()).orElseThrow().reference();\n+        try (var reader = reference.open()) {\n+            assertLinesMatch(\n+                    \"\"\"\n+                    com\/\n+                    com\/greetings\/\n+                    com\/greetings\/Main.class\n+                    com\/greetings\/Main.java\n+                    module-info.class\n+                    module-info.java\n+                    \"\"\".lines(),\n+                    reader.list());\n+        }\n+    }\n+\n+    @Test\n+    void testTwoAndHalfPackages(@TempDir Path base) throws Exception {\n+        var fooFolder = Files.createDirectories(base.resolve(\"foo\"));\n+        var program = Files.writeString(fooFolder.resolve(\"Main.java\"),\n+                \"\"\"\n+                package foo;\n+                public class Main {\n+                  public static void main(String... args) throws Exception {\n+                    var module = Main.class.getModule();\n+                    System.out.println(\"To the \" + bar.Bar.class + \" from \" + module);\n+                    try (var stream = module.getResourceAsStream(\"baz\/baz.txt\")) {\n+                      System.out.println(new String(stream.readAllBytes()));\n+                    }\n+                  }\n+                }\n+                \"\"\");\n+        var barFolder = Files.createDirectories(base.resolve(\"bar\"));\n+        Files.writeString(barFolder.resolve(\"Bar.java\"), \"package bar; public record Bar() {}\");\n+        var bazFolder = Files.createDirectories(base.resolve(\"baz\"));\n+        Files.writeString(bazFolder.resolve(\"baz.txt\"), \"baz\");\n+\n+        Files.writeString(base.resolve(\"module-info.java\"),\n+                \"\"\"\n+                module m {\n+                  exports foo;\n+                  exports bar;\n+                  opens baz;\n+                }\n+                \"\"\");\n+\n+        var run = Run.of(program);\n+        var result = run.result();\n+        assertAll(\"Run -> \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        To the class bar.Bar from module m\n+                        baz\n+                        \"\"\".lines(),\n+                        run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()),\n+                () -> assertEquals(Set.of(\"foo\", \"bar\", \"baz\"), result.programClass().getModule().getPackages())\n+        );\n+\n+        var module = run.result().programClass().getModule();\n+        assertEquals(\"m\", module.getName());\n+        var reference = module.getLayer().configuration().findModule(module.getName()).orElseThrow().reference();\n+        try (var reader = reference.open()) {\n+            assertLinesMatch(\n+                    \"\"\"\n+                    bar\/\n+                    bar\/Bar.class\n+                    bar\/Bar.java\n+                    baz\/\n+                    baz\/baz.txt\n+                    foo\/\n+                    foo\/Main.class\n+                    foo\/Main.java\n+                    module-info.class\n+                    module-info.java\n+                    \"\"\".lines(),\n+                    reader.list());\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/launcher\/ModuleSourceLauncherTests.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304400\n+ * @summary Test source launcher running Java programs spanning multiple files\n+ * @modules jdk.compiler\/com.sun.tools.javac.launcher\n+ * @run junit MultiFileSourceLauncherTests\n+ *\/\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import com.sun.tools.javac.launcher.Fault;\n+import java.nio.file.*;\n+import org.junit.jupiter.api.*;\n+import org.junit.jupiter.api.io.*;\n+\n+class MultiFileSourceLauncherTests {\n+    @Test\n+    void testHelloWorldInTwoCompilationUnits(@TempDir Path base) throws Exception {\n+        var hello = Files.writeString(base.resolve(\"Hello.java\"),\n+                \"\"\"\n+                    public class Hello {\n+                      public static void main(String... args) {\n+                        System.out.println(\"Hello \" + new World(\"Terra\"));\n+                        System.out.println(Hello.class.getResource(\"Hello.java\"));\n+                        System.out.println(Hello.class.getResource(\"World.java\"));\n+                      }\n+                    }\n+                    \"\"\");\n+        Files.writeString(base.resolve(\"World.java\"),\n+                \"\"\"\n+                    record World(String name) {}\n+                    \"\"\");\n+\n+        var run = Run.of(hello);\n+        assertLinesMatch(\n+                \"\"\"\n+                Hello World[name=Terra]\n+                \\\\Qfile:\\\\E.+\\\\QHello.java\\\\E\n+                \\\\Qfile:\\\\E.+\\\\QWorld.java\\\\E\n+                \"\"\".lines(),\n+                run.stdOut().lines());\n+        assertTrue(run.stdErr().isEmpty(), run.toString());\n+        assertNull(run.exception(), run.toString());\n+    }\n+\n+    @Test\n+    void testLoadingOfEnclosedTypes(@TempDir Path base) throws Exception {\n+        var hello = Files.writeString(base.resolve(\"Hello.java\"),\n+                \"\"\"\n+                    public class Hello {\n+                      public static void main(String... args) throws Exception {\n+                        System.out.println(Class.forName(\"World$Core\"));\n+                        System.out.println(Class.forName(\"p.q.Unit$First$Second\"));\n+                      }\n+                    }\n+                    \"\"\");\n+        Files.writeString(base.resolve(\"World.java\"),\n+                \"\"\"\n+                    record World(String name) {\n+                      record Core() {}\n+                    }\n+                    \"\"\");\n+        var pq = Files.createDirectories(base.resolve(\"p\/q\"));\n+        Files.writeString(pq.resolve(\"Unit.java\"),\n+                \"\"\"\n+                    package p.q;\n+                    record Unit() {\n+                      record First() {\n+                        record Second() {}\n+                      }\n+                    }\n+                    \"\"\");\n+\n+        var run = Run.of(hello);\n+        assertAll(\"Run -> \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        class World$Core\n+                        class p.q.Unit$First$Second\n+                        \"\"\".lines(),\n+                        run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception())\n+        );\n+    }\n+\n+    @Test\n+    void testMultiplePackages(@TempDir Path base) throws Exception {\n+        var packageA = Files.createDirectories(base.resolve(\"a\"));\n+        var hello = Files.writeString(packageA.resolve(\"Hello.java\"),\n+                \"\"\"\n+                    package a;\n+                    import b.World;\n+                    public class Hello {\n+                      public static void main(String... args) {\n+                        System.out.println(\"Hello \" + new World(\"in package b\"));\n+                      }\n+                    }\n+                    \"\"\");\n+        var packageB = Files.createDirectories(base.resolve(\"b\"));\n+        Files.writeString(packageB.resolve(\"World.java\"),\n+                \"\"\"\n+                    package b;\n+                    public record World(String name) {}\n+                    \"\"\");\n+\n+        var run = Run.of(hello);\n+        assertLinesMatch(\n+                \"\"\"\n+                Hello World[name=in package b]\n+                \"\"\".lines(),\n+                run.stdOut().lines());\n+        assertTrue(run.stdErr().isEmpty(), run.toString());\n+        assertNull(run.exception(), run.toString());\n+    }\n+\n+    @Test\n+    void testMissingSecondUnit(@TempDir Path base) throws Exception {\n+        var program = Files.writeString(base.resolve(\"Program.java\"),\n+                \"\"\"\n+                    public class Program {\n+                      public static void main(String... args) {\n+                        System.out.println(\"Hello \" + new MissingSecondUnit());\n+                      }\n+                    }\n+                    \"\"\");\n+\n+        var run = Run.of(program);\n+        assertTrue(run.stdOut().isEmpty(), run.toString());\n+        assertLinesMatch(\n+                \"\"\"\n+                %s:3: error: cannot find symbol\n+                    System.out.println(\"Hello \" + new MissingSecondUnit());\n+                                                      ^\n+                  symbol:   class MissingSecondUnit\n+                  location: class Program\n+                1 error\n+                \"\"\".formatted(program.toString())\n+                        .lines(),\n+                run.stdErr().lines(),\n+                run.toString());\n+        assertTrue(run.exception() instanceof Fault);\n+    }\n+\n+    @Test\n+    void testSecondUnitWithSyntaxError(@TempDir Path base) throws Exception {\n+        var program = Files.writeString(base.resolve(\"Program.java\"),\n+                \"\"\"\n+                    public class Program {\n+                      public static void main(String... args) {\n+                        System.out.println(\"Hello \" + new BrokenSecondUnit());\n+                      }\n+                    }\n+                    \"\"\");\n+        var broken = Files.writeString(base.resolve(\"BrokenSecondUnit.java\"),\n+                \"\"\"\n+                    record BrokenSecondUnit {}\n+                    \"\"\");\n+\n+        var run = Run.of(program);\n+        assertTrue(run.stdOut().isEmpty(), run.toString());\n+        assertLinesMatch(\n+                \"\"\"\n+                %s:1: error: '(' expected\n+                >> MORE LINES >>\n+                \"\"\".formatted(broken.toString())\n+                   .lines(),\n+                run.stdErr().lines(),\n+                run.toString());\n+        assertTrue(run.exception() instanceof Fault);\n+    }\n+\n+    @Test\n+    void onlyJavaFilesReferencedByTheProgramAreCompiled(@TempDir Path base) throws Exception {\n+        var prog = Files.writeString(base.resolve(\"Prog.java\"),\n+                \"\"\"\n+                    class Prog {\n+                      public static void main(String... args) {\n+                        Helper.run();\n+                      }\n+                    }\n+                    \"\"\");\n+        Files.writeString(base.resolve(\"Helper.java\"),\n+                \"\"\"\n+                    class Helper {\n+                      static void run() {\n+                        System.out.println(\"Hello!\");\n+                      }\n+                    }\n+                    \"\"\");\n+\n+        var old = Files.writeString(base.resolve(\"OldProg.java\"),\n+                \"\"\"\n+                    class OldProg {\n+                      public static void main(String... args) {\n+                        Helper.run()\n+                      }\n+                    }\n+                    \"\"\");\n+\n+        var run = Run.of(prog);\n+        assertAll(\"Run := \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Hello!\n+                        \"\"\".lines(), run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()));\n+\n+        var fail = Run.of(old);\n+        assertAll(\"Run := \" + fail,\n+                () -> assertTrue(fail.stdOut().isEmpty()),\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        %s:3: error: ';' expected\n+                            Helper.run()\n+                                        ^\n+                        1 error\n+                        \"\"\".formatted(old).lines(), fail.stdErr().lines()),\n+                () -> assertNotNull(fail.exception()));\n+    }\n+\n+    @Test\n+    void classesDeclaredInSameFileArePreferredToClassesInOtherFiles(@TempDir Path base) throws Exception {\n+        var prog = Files.writeString(base.resolve(\"Prog.java\"),\n+                \"\"\"\n+                class Helper {\n+                  static void run() {\n+                    System.out.println(\"Same file.\");\n+                  }\n+                }\n+                public class Prog {\n+                  public static void main(String... args) {\n+                    Helper.run();\n+                  }\n+                }\n+                \"\"\");\n+        Files.writeString(base.resolve(\"Helper.java\"),\n+                \"\"\"\n+                class Helper {\n+                  static void run() {\n+                    System.out.println(\"Other file.\");\n+                  }\n+                }\n+                \"\"\");\n+\n+        var run = Run.of(prog);\n+        assertAll(\"Run := \" + run,\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        Same file.\n+                        \"\"\".lines(), run.stdOut().lines()),\n+                () -> assertTrue(run.stdErr().isEmpty()),\n+                () -> assertNull(run.exception()));\n+    }\n+\n+    @Test\n+    void duplicateDeclarationOfClassFails(@TempDir Path base) throws Exception {\n+        var prog = Files.writeString(base.resolve(\"Prog.java\"),\n+                \"\"\"\n+                    class Prog {\n+                      public static void main(String... args) {\n+                        Helper.run();\n+                        Aux.cleanup();\n+                      }\n+                    }\n+                    class Aux {\n+                      static void cleanup() {}\n+                    }\n+                    \"\"\");\n+        var helper = Files.writeString(base.resolve(\"Helper.java\"),\n+                \"\"\"\n+                    class Helper {\n+                      static void run() {}\n+                    }\n+                    class Aux {\n+                      static void cleanup() {}\n+                    }\n+                    \"\"\");\n+\n+\n+        var fail = Run.of(prog);\n+        assertAll(\"Run := \" + fail,\n+                () -> assertTrue(fail.stdOut().isEmpty()),\n+                () -> assertLinesMatch(\n+                        \"\"\"\n+                        %s:4: error: duplicate class: Aux\n+                        class Aux {\n+                        ^\n+                        1 error\n+                        \"\"\".formatted(helper).lines(), fail.stdErr().lines()),\n+                () -> assertNotNull(fail.exception()));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/launcher\/MultiFileSourceLauncherTests.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304400\n+ * @summary Test source root directory computation\n+ * @modules jdk.compiler\/com.sun.tools.javac.launcher\n+ * @run junit ProgramDescriptorTests\n+ *\/\n+\n+import com.sun.tools.javac.launcher.ProgramDescriptor;\n+import java.nio.file.Path;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ProgramDescriptorTests {\n+    @ParameterizedTest\n+    @CsvSource(textBlock =\n+            \"\"\"\n+            '\/', '\/Program.java', ''\n+            '\/', '\/a\/Program.java', 'a',\n+            '\/', '\/a\/b\/Program.java', 'a.b',\n+            '\/', '\/a\/b\/c\/Program.java', 'a.b.c'\n+\n+            '\/a', '\/a\/b\/c\/Program.java', 'b.c'\n+            '\/a\/b', '\/a\/b\/c\/Program.java', 'c'\n+            '\/a\/b\/c', '\/a\/b\/c\/Program.java', ''\n+            \"\"\")\n+    @DisabledOnOs(OS.WINDOWS)\n+    void checkComputeSourceRootPath(Path expected, Path program, String packageName) {\n+        check(expected, program, packageName);\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource(textBlock =\n+            \"\"\"\n+            'C:\\\\', 'C:\\\\Program.java', ''\n+            'C:\\\\', 'C:\\\\a\\\\Program.java', 'a',\n+            'C:\\\\', 'C:\\\\a\\\\b\\\\Program.java', 'a.b',\n+            'C:\\\\', 'C:\\\\a\\\\b\\\\c\\\\Program.java', 'a.b.c'\n+\n+            'C:\\\\a', 'C:\\\\a\\\\b\\\\c\\\\Program.java', 'b.c'\n+            'C:\\\\a\\\\b', 'C:\\\\a\\\\b\\\\c\\\\Program.java', 'c'\n+            'C:\\\\a\\\\b\\\\c', 'C:\\\\a\\\\b\\\\c\\\\Program.java', ''\n+            \"\"\")\n+    @EnabledOnOs(OS.WINDOWS)\n+    void checkComputeSourceRootPathOnWindows(Path expected, Path program, String packageName) {\n+        check(expected, program, packageName);\n+    }\n+\n+    private void check(Path expectedRoot, Path programPath, String packageName) {\n+        assertTrue(expectedRoot.isAbsolute(), \"Expected path not absolute: \" + expectedRoot);\n+        assertTrue(programPath.isAbsolute(), \"Program path not absolute: \" + programPath);\n+\n+        var actual = ProgramDescriptor.computeSourceRootPath(programPath, packageName);\n+        assertEquals(expectedRoot, actual);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/launcher\/ProgramDescriptorTests.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.sun.tools.javac.launcher.SourceLauncher;\n+import com.sun.tools.javac.launcher.Result;\n+\n+record Run(String stdOut, String stdErr, Throwable exception, Result result) {\n+    static Run of(Path file) {\n+        return Run.of(file, List.of(), List.of(\"1\", \"2\", \"3\"));\n+    }\n+\n+    static Run of(Path file, List<String> runtimeArgs, List<String> appArgs) {\n+        List<String> args = new ArrayList<>();\n+        args.add(file.toString());\n+        args.addAll(appArgs);\n+\n+        PrintStream prev = System.out;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (PrintStream out = new PrintStream(baos, true)) {\n+            System.setOut(out);\n+            StringWriter sw = new StringWriter();\n+            try (PrintWriter err = new PrintWriter(sw, true)) {\n+                var launcher = new SourceLauncher(err);\n+                var result = launcher.run(runtimeArgs.toArray(String[]::new), args.toArray(String[]::new));\n+                return new Run(baos.toString(), sw.toString(), null, result);\n+            } catch (Throwable throwable) {\n+                return new Run(baos.toString(), sw.toString(), throwable, null);\n+            }\n+        } finally {\n+            System.setOut(prev);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/launcher\/Run.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,2 @@\n-import com.sun.tools.javac.launcher.Main;\n+import com.sun.tools.javac.launcher.SourceLauncher;\n+import com.sun.tools.javac.launcher.Fault;\n@@ -71,1 +72,0 @@\n-import toolbox.TestRunner.Test;\n@@ -300,2 +300,2 @@\n-        Files.createDirectories(base);\n-        Path file = base.resolve(\"NoClass.java\");\n+        var path = Files.createDirectories(base.resolve(\"p\"));\n+        Path file = path.resolve(\"NoClass.java\");\n@@ -306,0 +306,8 @@\n+    @Test\n+    public void testMismatchOfPathAndPackage(Path base) throws IOException {\n+        Files.createDirectories(base);\n+        Path file = base.resolve(\"MismatchOfPathAndPackage.java\");\n+        Files.write(file, List.of(\"package p;\"));\n+        testError(file, \"\", \"error: end of path to source file does not match its package name p: \" + file);\n+    }\n+\n@@ -626,1 +634,1 @@\n-                .vmOptions(\"--source\", \"8\")\n+                .vmOptions(\"--source\", \"21\")\n@@ -743,1 +751,1 @@\n-                Main m = new Main(err);\n+                SourceLauncher m = new SourceLauncher(err);\n@@ -800,1 +808,1 @@\n-            error(\"No exception thrown; expected Main.Fault\");\n+            error(\"No exception thrown; expected Fault\");\n@@ -802,2 +810,2 @@\n-            if (!(found instanceof Main.Fault)) {\n-                error(\"Unexpected exception; expected Main.Fault\");\n+            if (!(found instanceof Fault)) {\n+                error(\"Unexpected exception; expected Fault\");\n@@ -835,11 +843,1 @@\n-    class Result {\n-        private final String stdOut;\n-        private final String stdErr;\n-        private final Throwable exception;\n-\n-        Result(String stdOut, String stdErr, Throwable exception) {\n-            this.stdOut = stdOut;\n-            this.stdErr = stdErr;\n-            this.exception = exception;\n-        }\n-    }\n+    record Result(String stdOut, String stdErr, Throwable exception) {}\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -7,1 +7,3 @@\n- * published by the Free Software Foundation.\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n@@ -34,1 +36,2 @@\n- *      --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED\n+ *      --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n+ *      --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n","filename":"test\/langtools\/tools\/javac\/launcher\/src\/p\/q\/CLTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"previous_filename":"test\/langtools\/tools\/javac\/launcher\/src\/CLTest.java","status":"renamed"},{"patch":"@@ -98,0 +98,1 @@\n+                                \"java.base\/jdk.internal.module\",\n","filename":"test\/langtools\/tools\/jdeps\/listdeps\/ListModuleDeps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}