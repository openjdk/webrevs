{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -542,1 +542,0 @@\n-          range(64 * K, max_uintx)                                          \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -288,0 +288,6 @@\n+  if (value + MaxHeapSize < MaxHeapSize) {\/\/ overflow\n+    JVMFlag::printError(verbose,\n+                        \"Sum of HeapBaseMinAddress (%zu) and MaxHeapSize (%zu) results in an overflow (%zu)\\n\",\n+                        value , MaxHeapSize, value + MaxHeapSize);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -551,3 +551,2 @@\n-  char* aligned_heap_base_min_address = align_up((char*)HeapBaseMinAddress, alignment);\n-  assert(aligned_heap_base_min_address != 0,\"Should not be 0\");\n-  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n+  uintptr_t aligned_heap_base_min_address = align_up(MAX2(HeapBaseMinAddress, alignment), alignment);\n+  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > OopEncodingHeapMax) ?\n@@ -560,2 +559,2 @@\n-    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, aligned_heap_base_min_address);\n-    if (reserved.base() != aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n+    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, (char *)aligned_heap_base_min_address);\n+    if (reserved.base() != (char *)aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n@@ -581,1 +580,1 @@\n-    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n+    if (aligned_heap_base_min_address + size <= UnscaledOopHeapMax) {\n@@ -585,1 +584,3 @@\n-      char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n+      char* const lowest_start  = align_up((char *)aligned_heap_base_min_address, attach_point_alignment);\n+      assert(lowest_start < highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT ,\n+                                          p2i(lowest_start), p2i(highest_start));\n@@ -587,1 +588,1 @@\n-                                   aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n+                                   (char *)aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n@@ -594,1 +595,1 @@\n-    if (aligned_heap_base_min_address + size <= zerobased_max && \/\/ Zerobased theoretical possible.\n+    if (aligned_heap_base_min_address + size <= (uintptr_t)zerobased_max && \/\/ Zerobased theoretical possible.\n@@ -605,1 +606,1 @@\n-      char *lowest_start = aligned_heap_base_min_address;\n+      char *lowest_start = (char *)aligned_heap_base_min_address;\n@@ -611,0 +612,2 @@\n+      assert(lowest_start < highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT,\n+                                          p2i(lowest_start), p2i(highest_start));\n@@ -612,1 +615,1 @@\n-                                   aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n+                                   (char *)aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n@@ -632,1 +635,1 @@\n-      assert(attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n+      assert((uintptr_t)attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"}]}