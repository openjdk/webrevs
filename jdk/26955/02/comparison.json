{"files":[{"patch":"@@ -288,0 +288,6 @@\n+  if (value + MaxHeapSize < MaxHeapSize) {\/\/ overflow\n+    JVMFlag::printError(verbose,\n+                        \"Sum of HeapBaseMinAddress (%zu) and MaxHeapSize (%zu) results in an overflow (%zu)\\n\",\n+                        value , MaxHeapSize, value + MaxHeapSize);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -551,2 +551,2 @@\n-  char* aligned_heap_base_min_address = align_up((char*)HeapBaseMinAddress, alignment);\n-  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n+  uintptr_t aligned_heap_base_min_address = align_up(MAX2(HeapBaseMinAddress, alignment), alignment);\n+  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > OopEncodingHeapMax) ?\n@@ -559,2 +559,2 @@\n-    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, aligned_heap_base_min_address);\n-    if (reserved.base() != aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n+    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, (char *)aligned_heap_base_min_address);\n+    if (reserved.base() != (char *)aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n@@ -580,1 +580,1 @@\n-    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n+    if (aligned_heap_base_min_address + size <= UnscaledOopHeapMax) {\n@@ -584,1 +584,3 @@\n-      char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n+      char* const lowest_start  = align_up((char *)aligned_heap_base_min_address, attach_point_alignment);\n+      assert(lowest_start <= highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT ,\n+                                          p2i(lowest_start), p2i(highest_start));\n@@ -586,1 +588,1 @@\n-                                   aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n+                                   (char *)aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n@@ -593,1 +595,1 @@\n-    if (aligned_heap_base_min_address + size <= zerobased_max && \/\/ Zerobased theoretical possible.\n+    if (aligned_heap_base_min_address + size <= (uintptr_t)zerobased_max && \/\/ Zerobased theoretical possible.\n@@ -604,1 +606,1 @@\n-      char *lowest_start = aligned_heap_base_min_address;\n+      char *lowest_start = (char *)aligned_heap_base_min_address;\n@@ -610,0 +612,2 @@\n+      assert(lowest_start <= highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT,\n+                                          p2i(lowest_start), p2i(highest_start));\n@@ -611,1 +615,1 @@\n-                                   aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n+                                   (char *)aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n@@ -631,1 +635,1 @@\n-      assert(attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n+      assert((uintptr_t)attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}