{"files":[{"patch":"@@ -288,0 +288,6 @@\n+  if (std::numeric_limits<size_t>::max() - value < MaxHeapSize) { \/\/ overflow\n+    JVMFlag::printError(verbose,\n+                        \"Sum of HeapBaseMinAddress (%zu) and MaxHeapSize (%zu) results in an overflow (%zu)\\n\",\n+                        value , MaxHeapSize, value + MaxHeapSize);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-          size <= (uintptr_t)(upper_bound - reserved.base())) {\n+          size <= (size_t)(upper_bound - reserved.base())) {\n@@ -551,2 +551,2 @@\n-  char* aligned_heap_base_min_address = align_up((char*)HeapBaseMinAddress, alignment);\n-  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > (char*)OopEncodingHeapMax) ?\n+  uintptr_t aligned_heap_base_min_address = align_up(MAX2(HeapBaseMinAddress, alignment), alignment);\n+  size_t noaccess_prefix = ((aligned_heap_base_min_address + size) > OopEncodingHeapMax) ?\n@@ -559,2 +559,2 @@\n-    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, aligned_heap_base_min_address);\n-    if (reserved.base() != aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n+    reserved = try_reserve_memory(size + noaccess_prefix, alignment, page_size, (char*)aligned_heap_base_min_address);\n+    if (reserved.base() != (char*)aligned_heap_base_min_address) { \/\/ Enforce this exact address.\n@@ -580,1 +580,1 @@\n-    if (aligned_heap_base_min_address + size <= (char *)UnscaledOopHeapMax) {\n+    if (aligned_heap_base_min_address + size <= UnscaledOopHeapMax) {\n@@ -583,4 +583,6 @@\n-      char* const highest_start = align_down((char *)UnscaledOopHeapMax - size, attach_point_alignment);\n-      char* const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n-      reserved = try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n-                                   aligned_heap_base_min_address, (char *)UnscaledOopHeapMax, size, alignment, page_size);\n+      uintptr_t const highest_start = align_down(UnscaledOopHeapMax - size, attach_point_alignment);\n+      uintptr_t const lowest_start  = align_up(aligned_heap_base_min_address, attach_point_alignment);\n+      assert(lowest_start <= highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT ,\n+                                          lowest_start, highest_start);\n+      reserved = try_reserve_range((char*)highest_start, (char*)lowest_start, attach_point_alignment,\n+                                   (char*)aligned_heap_base_min_address, (char*)UnscaledOopHeapMax, size, alignment, page_size);\n@@ -590,1 +592,1 @@\n-    char *zerobased_max = (char *)OopEncodingHeapMax;\n+    size_t zerobased_max = OopEncodingHeapMax;\n@@ -595,1 +597,1 @@\n-         (reserved.end() > zerobased_max))) {                    \/\/ Unscaled delivered an arbitrary address.\n+         (reserved.end() > (char*)zerobased_max))) {             \/\/ Unscaled delivered an arbitrary address.\n@@ -601,1 +603,1 @@\n-      char *const highest_start = align_down(zerobased_max - size, attach_point_alignment);\n+      uintptr_t const highest_start = align_down(zerobased_max - size, attach_point_alignment);\n@@ -604,4 +606,3 @@\n-      char *lowest_start = aligned_heap_base_min_address;\n-      uint64_t unscaled_end = UnscaledOopHeapMax - size;\n-      if (unscaled_end < UnscaledOopHeapMax) { \/\/ unscaled_end wrapped if size is large\n-        lowest_start = MAX2(lowest_start, (char*)unscaled_end);\n+      uintptr_t lowest_start = aligned_heap_base_min_address;\n+      if (size < UnscaledOopHeapMax) {\n+        lowest_start = MAX2<uintptr_t>(lowest_start, UnscaledOopHeapMax - size);\n@@ -610,2 +611,4 @@\n-      reserved = try_reserve_range(highest_start, lowest_start, attach_point_alignment,\n-                                   aligned_heap_base_min_address, zerobased_max, size, alignment, page_size);\n+      assert(lowest_start <= highest_start, \"lowest: \" INTPTR_FORMAT \" highest: \" INTPTR_FORMAT,\n+                                          lowest_start, highest_start);\n+      reserved = try_reserve_range((char*)highest_start, (char*)lowest_start, attach_point_alignment,\n+                                   (char*)aligned_heap_base_min_address, (char*)zerobased_max, size, alignment, page_size);\n@@ -621,4 +624,4 @@\n-    while ((addresses[i] != nullptr) &&       \/\/ End of array not yet reached.\n-           ((!reserved.is_reserved()) ||      \/\/ No previous try succeeded.\n-           (reserved.end() > zerobased_max && \/\/ Not zerobased or unscaled address.\n-                                              \/\/ Not disjoint address.\n+    while ((addresses[i] != nullptr) &&              \/\/ End of array not yet reached.\n+           ((!reserved.is_reserved()) ||             \/\/ No previous try succeeded.\n+           (reserved.end() > (char*)zerobased_max && \/\/ Not zerobased or unscaled address.\n+                                                     \/\/ Not disjoint address.\n@@ -631,1 +634,1 @@\n-      assert(attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n+      assert((uintptr_t)attach_point >= aligned_heap_base_min_address, \"Flag support broken\");\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"}]}