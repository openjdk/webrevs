{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import jdk.internal.access.JavaxSecurityAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -85,1 +87,1 @@\n-     * NOTE: this field is reflectively accessed from within X500Name.\n+     * NOTE: this field is accessed using shared secrets from within X500Name.\n@@ -89,0 +91,15 @@\n+    static {\n+        \/\/ Set up JavaxSecurityAccess in SharedSecrets\n+        SharedSecrets.setJavaxSecurityAccess(\n+            new JavaxSecurityAccess() {\n+                @Override\n+                public X500Name asX500Name(X500Principal principal) {\n+                    return principal.thisX500Name;\n+                }\n+                @Override\n+                public X500Principal asX500Principal(X500Name name) {\n+                    return new X500Principal(name);\n+                }\n+        });\n+    }\n+\n@@ -93,2 +110,2 @@\n-     * using privileged reflection from classes in sun.security.*.\n-     * Currently, it is referenced from sun.security.x509.X500Name.asX500Principal().\n+     * using shared secrets from classes in sun.security.*. Currently, it is\n+     * referenced from sun.security.x509.X500Name.asX500Principal().\n","filename":"src\/java.base\/share\/classes\/javax\/security\/auth\/x500\/X500Principal.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import javax.security.auth.x500.X500Principal;\n+import sun.security.x509.X500Name;\n+\n+public interface JavaxSecurityAccess {\n+    X500Name asX500Name(X500Principal p);\n+    X500Principal asX500Principal(X500Name n);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaxSecurityAccess.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import javax.security.auth.x500.X500Principal;\n@@ -92,0 +93,1 @@\n+    private static JavaxSecurityAccess javaxSecurityAccess;\n@@ -520,0 +522,13 @@\n+    public static void setJavaxSecurityAccess(JavaxSecurityAccess jsa) {\n+        javaxSecurityAccess = jsa;\n+    }\n+\n+    public static JavaxSecurityAccess getJavaxSecurityAccess() {\n+        var access = javaxSecurityAccess;\n+        if (access == null) {\n+            ensureClassInitialized(X500Principal.class);\n+            access = javaxSecurityAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,7 +36,0 @@\n-import sun.security.x509.GeneralNames;\n-import sun.security.x509.GeneralNameInterface;\n-import sun.security.x509.GeneralSubtrees;\n-import sun.security.x509.NameConstraintsExtension;\n-import sun.security.x509.SubjectAlternativeNameExtension;\n-import sun.security.x509.X500Name;\n-import sun.security.x509.X509CertImpl;\n@@ -129,240 +122,0 @@\n-    \/**\n-     * get distance of one GeneralName from another\n-     *\n-     * @param base GeneralName at base of subtree\n-     * @param test GeneralName to be tested against base\n-     * @param incomparable the value to return if the names are\n-     *  incomparable\n-     * @return distance of test name from base, where 0\n-     *         means exact match, 1 means test is an immediate\n-     *         child of base, 2 means test is a grandchild, etc.\n-     *         -1 means test is a parent of base, -2 means test\n-     *         is a grandparent, etc.\n-     *\/\n-    static int distance(GeneralNameInterface base,\n-                        GeneralNameInterface test, int incomparable)\n-    {\n-        switch (base.constrains(test)) {\n-        case GeneralNameInterface.NAME_DIFF_TYPE:\n-            if (debug != null) {\n-                debug.println(\"Builder.distance(): Names are different types\");\n-            }\n-            return incomparable;\n-        case GeneralNameInterface.NAME_SAME_TYPE:\n-            if (debug != null) {\n-                debug.println(\"Builder.distance(): Names are same type but \" +\n-                    \"in different subtrees\");\n-            }\n-            return incomparable;\n-        case GeneralNameInterface.NAME_MATCH:\n-            return 0;\n-        case GeneralNameInterface.NAME_WIDENS:\n-        case GeneralNameInterface.NAME_NARROWS:\n-            break;\n-        default: \/\/ should never occur\n-            return incomparable;\n-        }\n-\n-        \/* names are in same subtree *\/\n-        return test.subtreeDepth() - base.subtreeDepth();\n-    }\n-\n-    \/**\n-     * get hop distance of one GeneralName from another in links where\n-     * the names need not have an ancestor\/descendant relationship.\n-     * For example, the hop distance from ou=D,ou=C,o=B,c=US to\n-     * ou=F,ou=E,ou=C,o=B,c=US is 3: D->C, C->E, E->F.  The hop distance\n-     * from ou=C,o=B,c=US to ou=D,ou=C,o=B,c=US is -1: C->D\n-     *\n-     * @param base GeneralName\n-     * @param test GeneralName to be tested against base\n-     * @param incomparable the value to return if the names are\n-     *  incomparable\n-     * @return distance of test name from base measured in hops in the\n-     *         namespace hierarchy, where 0 means exact match.  Result\n-     *         is positive if path is some number of up hops followed by\n-     *         some number of down hops; result is negative if path is\n-     *         some number of down hops.\n-     *\/\n-    static int hops(GeneralNameInterface base, GeneralNameInterface test,\n-                    int incomparable)\n-    {\n-        int baseRtest = base.constrains(test);\n-        switch (baseRtest) {\n-        case GeneralNameInterface.NAME_DIFF_TYPE:\n-            if (debug != null) {\n-                debug.println(\"Builder.hops(): Names are different types\");\n-            }\n-            return incomparable;\n-        case GeneralNameInterface.NAME_SAME_TYPE:\n-            \/* base and test are in different subtrees *\/\n-            break;\n-        case GeneralNameInterface.NAME_MATCH:\n-            \/* base matches test *\/\n-            return 0;\n-        case GeneralNameInterface.NAME_WIDENS:\n-            \/* base is ancestor of test *\/\n-        case GeneralNameInterface.NAME_NARROWS:\n-            \/* base is descendant of test *\/\n-            return test.subtreeDepth() - base.subtreeDepth();\n-        default: \/\/ should never occur\n-            return incomparable;\n-        }\n-\n-        \/* names are in different subtrees *\/\n-        if (base.getType() != GeneralNameInterface.NAME_DIRECTORY) {\n-            if (debug != null) {\n-                debug.println(\"Builder.hops(): hopDistance not implemented \" +\n-                    \"for this name type\");\n-            }\n-            return incomparable;\n-        }\n-        X500Name baseName = (X500Name)base;\n-        X500Name testName = (X500Name)test;\n-        X500Name commonName = baseName.commonAncestor(testName);\n-        if (commonName == null) {\n-            if (debug != null) {\n-                debug.println(\"Builder.hops(): Names are in different \" +\n-                    \"namespaces\");\n-            }\n-            return incomparable;\n-        } else {\n-            int commonDistance = commonName.subtreeDepth();\n-            int baseDistance = baseName.subtreeDepth();\n-            int testDistance = testName.subtreeDepth();\n-            return baseDistance + testDistance - (2 * commonDistance);\n-        }\n-    }\n-\n-    \/**\n-     * Determine how close a given certificate gets you toward\n-     * a given target.\n-     *\n-     * @param constraints Current NameConstraints; if null,\n-     *        then caller must verify NameConstraints\n-     *        independently, realizing that this certificate\n-     *        may not actually lead to the target at all.\n-     * @param cert Candidate certificate for chain\n-     * @param target GeneralNameInterface name of target\n-     * @return distance from this certificate to target:\n-     * <ul>\n-     * <li>-1 means certificate could be CA for target, but\n-     *     there are no NameConstraints limiting how close\n-     * <li> 0 means certificate subject or subjectAltName\n-     *      matches target\n-     * <li> 1 means certificate is permitted to be CA for\n-     *      target.\n-     * <li> 2 means certificate is permitted to be CA for\n-     *      parent of target.\n-     * <li>&gt;0 in general, means certificate is permitted\n-     *     to be a CA for this distance higher in the naming\n-     *     hierarchy than the target, plus 1.\n-     * <\/ul>\n-     * <p>Note that the subject and\/or subjectAltName of the\n-     * candidate cert does not have to be an ancestor of the\n-     * target in order to be a CA that can issue a certificate to\n-     * the target. In these cases, the target distance is calculated\n-     * by inspecting the NameConstraints extension in the candidate\n-     * certificate. For example, suppose the target is an X.500 DN with\n-     * a value of \"CN=mullan,OU=ireland,O=sun,C=us\" and the\n-     * NameConstraints extension in the candidate certificate\n-     * includes a permitted component of \"O=sun,C=us\", which implies\n-     * that the candidate certificate is allowed to issue certs in\n-     * the \"O=sun,C=us\" namespace. The target distance is 3\n-     * ((distance of permitted NC from target) + 1).\n-     * The (+1) is added to distinguish the result from the case\n-     * which returns (0).\n-     * @throws IOException if certificate does not get closer\n-     *\/\n-    static int targetDistance(NameConstraintsExtension constraints,\n-                              X509Certificate cert, GeneralNameInterface target)\n-            throws IOException\n-    {\n-        \/* ensure that certificate satisfies existing name constraints *\/\n-        if (constraints != null && !constraints.verify(cert)) {\n-            throw new IOException(\"certificate does not satisfy existing name \"\n-                + \"constraints\");\n-        }\n-\n-        X509CertImpl certImpl;\n-        try {\n-            certImpl = X509CertImpl.toImpl(cert);\n-        } catch (CertificateException e) {\n-            throw new IOException(\"Invalid certificate\", e);\n-        }\n-        \/* see if certificate subject matches target *\/\n-        X500Name subject = X500Name.asX500Name(certImpl.getSubjectX500Principal());\n-        if (subject.equals(target)) {\n-            \/* match! *\/\n-            return 0;\n-        }\n-\n-        SubjectAlternativeNameExtension altNameExt =\n-            certImpl.getSubjectAlternativeNameExtension();\n-        if (altNameExt != null) {\n-            GeneralNames altNames = altNameExt.getNames();\n-            \/* see if any alternative name matches target *\/\n-            if (altNames != null) {\n-                for (int j = 0, n = altNames.size(); j < n; j++) {\n-                    GeneralNameInterface altName = altNames.get(j).getName();\n-                    if (altName.equals(target)) {\n-                        return 0;\n-                    }\n-                }\n-            }\n-        }\n-\n-\n-        \/* no exact match; see if certificate can get us to target *\/\n-\n-        \/* first, get NameConstraints out of certificate *\/\n-        NameConstraintsExtension ncExt = certImpl.getNameConstraintsExtension();\n-        if (ncExt == null) {\n-            return -1;\n-        }\n-\n-        \/* merge certificate's NameConstraints with current NameConstraints *\/\n-        if (constraints != null) {\n-            constraints.merge(ncExt);\n-        } else {\n-            \/\/ Make sure we do a clone here, because we're probably\n-            \/\/ going to modify this object later, and we don't want to\n-            \/\/ be sharing it with a Certificate object!\n-            constraints = (NameConstraintsExtension) ncExt.clone();\n-        }\n-\n-        if (debug != null) {\n-            debug.println(\"Builder.targetDistance() merged constraints: \"\n-                + constraints);\n-        }\n-        \/* reduce permitted by excluded *\/\n-        GeneralSubtrees permitted = constraints.getPermittedSubtrees();\n-        GeneralSubtrees excluded = constraints.getExcludedSubtrees();\n-        if (permitted != null) {\n-            permitted.reduce(excluded);\n-        }\n-        if (debug != null) {\n-            debug.println(\"Builder.targetDistance() reduced constraints: \"\n-                + permitted);\n-        }\n-        \/* see if new merged constraints allow target *\/\n-        if (!constraints.verify(target)) {\n-            throw new IOException(\"New certificate not allowed to sign \"\n-                + \"certificate for target\");\n-        }\n-        \/* find distance to target, if any, in permitted *\/\n-        if (permitted == null) {\n-            \/* certificate is unconstrained; could sign for anything *\/\n-            return -1;\n-        }\n-        for (int i = 0, n = permitted.size(); i < n; i++) {\n-            GeneralNameInterface perName = permitted.get(i).getName().getName();\n-            int distance = distance(perName, target, -1);\n-            if (distance >= 0) {\n-                return distance + 1;\n-            }\n-        }\n-        \/* no matching type in permitted; cert holder could certify target *\/\n-        return -1;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/Builder.java","additions":1,"deletions":248,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import sun.security.util.ObjectIdentifier;\n@@ -49,0 +50,1 @@\n+import sun.security.x509.AVA;\n@@ -50,0 +52,1 @@\n+import sun.security.x509.RDN;\n@@ -62,1 +65,1 @@\n-final class ForwardBuilder extends Builder {\n+public final class ForwardBuilder extends Builder {\n@@ -395,12 +398,4 @@\n-     * 3) Issuer is a descendant of a trusted subject (in order of\n-     *    number of links to the trusted subject)\n-     *    a) Issuer: ou=E,ou=D,ou=C,o=B,c=A        [links=1]\n-     *    b) Issuer: ou=F,ou=E,ou=D,ou=C,ou=B,c=A  [links=2]\n-     *\n-     * 4) Issuer is an ancestor of a trusted subject (in order of number of\n-     *    links to the trusted subject)\n-     *    a) Issuer: ou=C,o=B,c=A [links=1]\n-     *    b) Issuer: o=B,c=A      [links=2]\n-     *\n-     * 5) Issuer is in the same namespace as a trusted subject (in order of\n-     *    number of links to the trusted subject)\n+     * 3) Issuer is in the same namespace as a trusted subject (in order of\n+     *    number of links to the trusted subject). If the last RDN of the\n+     *    common ancestor is geographical, then it is skipped and the next\n+     *    trusted certificate is checked.\n@@ -409,0 +404,1 @@\n+     *    c) Issuer: ou=H,o=D,c=A\t[skipped, only geographical c=A is same]\n@@ -410,8 +406,1 @@\n-     * 6) Issuer is an ancestor of certificate subject (in order of number\n-     *    of links to the certificate subject)\n-     *    a) Issuer:  ou=K,o=J,c=A\n-     *       Subject: ou=L,ou=K,o=J,c=A\n-     *    b) Issuer:  o=J,c=A\n-     *       Subject: ou=L,ou=K,0=J,c=A\n-     *\n-     * 7) Any other certificates\n+     * 4) Any other certificates\n@@ -454,2 +443,2 @@\n-         * @param oCert1 First X509Certificate to be compared\n-         * @param oCert2 Second X509Certificate to be compared\n+         * @param oCert1 first X509Certificate to be compared\n+         * @param oCert2 second X509Certificate to be compared\n@@ -465,2 +454,0 @@\n-         * @throws ClassCastException if either argument is not of type\n-         * X509Certificate\n@@ -486,7 +473,0 @@\n-            X500Name cIssuer1Name = X500Name.asX500Name(cIssuer1);\n-            X500Name cIssuer2Name = X500Name.asX500Name(cIssuer2);\n-\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" o1 Issuer:  \" + cIssuer1);\n-                debug.println(METHOD_NME + \" o2 Issuer:  \" + cIssuer2);\n-            }\n@@ -498,0 +478,2 @@\n+                debug.println(METHOD_NME + \" o1 Issuer:  \" + cIssuer1);\n+                debug.println(METHOD_NME + \" o2 Issuer:  \" + cIssuer2);\n@@ -501,9 +483,1 @@\n-            boolean m1 = trustedSubjectDNs.contains(cIssuer1);\n-            boolean m2 = trustedSubjectDNs.contains(cIssuer2);\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" m1: \" + m1);\n-                debug.println(METHOD_NME + \" m2: \" + m2);\n-            }\n-            if (m1 && m2) {\n-                return -1;\n-            } else if (m1) {\n+            if (trustedSubjectDNs.contains(cIssuer1)) {\n@@ -511,30 +485,0 @@\n-            } else if (m2) {\n-                return 1;\n-            }\n-\n-            \/* If one cert's issuer is a naming descendant of a trusted subject,\n-             * then it is preferable, in order of increasing naming distance.\n-             *\/\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" NAMING DESCENDANT TEST...\");\n-            }\n-            for (X500Principal tSubject : trustedSubjectDNs) {\n-                X500Name tSubjectName = X500Name.asX500Name(tSubject);\n-                int distanceTto1 =\n-                    Builder.distance(tSubjectName, cIssuer1Name, -1);\n-                int distanceTto2 =\n-                    Builder.distance(tSubjectName, cIssuer2Name, -1);\n-                if (debug != null) {\n-                    debug.println(METHOD_NME +\" distanceTto1: \" + distanceTto1);\n-                    debug.println(METHOD_NME +\" distanceTto2: \" + distanceTto2);\n-                }\n-                if (distanceTto1 > 0 || distanceTto2 > 0) {\n-                    \/\/ at least one is positive\n-                    if (distanceTto2 <= 0) {        \/\/ only d1 is positive\n-                        return -1;\n-                    } else if (distanceTto1 <= 0) { \/\/ only d2 is positive\n-                        return 1;\n-                    } else {                        \/\/ all positive\n-                        return distanceTto1 > distanceTto2 ? 1 : -1;\n-                    }\n-                }\n@@ -542,28 +486,2 @@\n-\n-            \/* If one cert's issuer is a naming ancestor of a trusted subject,\n-             * then it is preferable, in order of increasing naming distance.\n-             *\/\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" NAMING ANCESTOR TEST...\");\n-            }\n-            for (X500Principal tSubject : trustedSubjectDNs) {\n-                X500Name tSubjectName = X500Name.asX500Name(tSubject);\n-\n-                int distanceTto1 = Builder.distance\n-                    (tSubjectName, cIssuer1Name, Integer.MAX_VALUE);\n-                int distanceTto2 = Builder.distance\n-                    (tSubjectName, cIssuer2Name, Integer.MAX_VALUE);\n-                if (debug != null) {\n-                    debug.println(METHOD_NME +\" distanceTto1: \" + distanceTto1);\n-                    debug.println(METHOD_NME +\" distanceTto2: \" + distanceTto2);\n-                }\n-                if (distanceTto1 < 0 || distanceTto2 < 0) {\n-                    \/\/ at least one is negative\n-                    if (distanceTto2 >= 0) {        \/\/ only d1 is negative\n-                        return -1;\n-                    } else if (distanceTto1 >= 0) { \/\/ only d2 is negative\n-                        return 1;\n-                    } else {                        \/\/ all negative\n-                        return distanceTto1 < distanceTto2 ? 1 : -1;\n-                    }\n-                }\n+            if (trustedSubjectDNs.contains(cIssuer2)) {\n+                return 1;\n@@ -579,0 +497,6 @@\n+\n+            X500Name cIssuer1Name = X500Name.asX500Name(cIssuer1);\n+            X500Name cIssuer2Name = X500Name.asX500Name(cIssuer2);\n+            \/\/ Note that we stop searching if we find a trust anchor that\n+            \/\/ has a common non-geographical ancestor on the basis that there\n+            \/\/ is a good chance that this path is the one we want.\n@@ -581,5 +505,6 @@\n-                X500Name tAo1 = tSubjectName.commonAncestor(cIssuer1Name);\n-                X500Name tAo2 = tSubjectName.commonAncestor(cIssuer2Name);\n-                if (debug != null) {\n-                    debug.println(METHOD_NME +\" tAo1: \" + tAo1);\n-                    debug.println(METHOD_NME +\" tAo2: \" + tAo2);\n+                int d1 = distanceToCommonAncestor(tSubjectName, cIssuer1Name);\n+                int d2 = distanceToCommonAncestor(tSubjectName, cIssuer2Name);\n+                if (d1 == -1 && d2 == -1) {\n+                    \/\/ neither cert has a common non-geographical ancestor with\n+                    \/\/ trust anchor, so continue checking other trust anchors\n+                    continue;\n@@ -587,6 +512,5 @@\n-                if (tAo1 != null || tAo2 != null) {\n-                    if (tAo1 != null && tAo2 != null) {\n-                        int hopsTto1 = Builder.hops\n-                            (tSubjectName, cIssuer1Name, Integer.MAX_VALUE);\n-                        int hopsTto2 = Builder.hops\n-                            (tSubjectName, cIssuer2Name, Integer.MAX_VALUE);\n+                if (d1 != -1) {\n+                    if (d2 != -1) {\n+                        \/\/ both certs share a common non-geographical ancestor\n+                        \/\/ with trust anchor. Prefer the one that is closer\n+                        \/\/ to the trust anchor.\n@@ -594,8 +518,2 @@\n-                            debug.println(METHOD_NME +\" hopsTto1: \" + hopsTto1);\n-                            debug.println(METHOD_NME +\" hopsTto2: \" + hopsTto2);\n-                        }\n-                        if (hopsTto1 == hopsTto2) {\n-                        } else if (hopsTto1 > hopsTto2) {\n-                            return 1;\n-                        } else {  \/\/ hopsTto1 < hopsTto2\n-                            return -1;\n+                            debug.println(METHOD_NME +\" cert1 links: \" + d1);\n+                            debug.println(METHOD_NME +\" cert2 links: \" + d2);\n@@ -603,2 +521,1 @@\n-                    } else if (tAo1 == null) {\n-                        return 1;\n+                        return (d1 > d2) ? 1 : -1;\n@@ -606,0 +523,2 @@\n+                        \/\/ cert1 shares a common non-geographical ancestor with\n+                        \/\/ trust anchor, so it is preferred.\n@@ -608,0 +527,4 @@\n+                } else if (d2 != -1) {\n+                    \/\/ cert2 shares a common non-geographical ancestor with\n+                    \/\/ trust anchor, so it is preferred.\n+                    return 1;\n@@ -611,30 +534,0 @@\n-\n-            \/* If one cert's issuer is an ancestor of that cert's subject,\n-             * then it is preferable, in order of increasing naming distance.\n-             *\/\n-            if (debug != null) {\n-                debug.println(METHOD_NME+\" CERT ISSUER\/SUBJECT COMPARISON TEST...\");\n-            }\n-            X500Principal cSubject1 = oCert1.getSubjectX500Principal();\n-            X500Principal cSubject2 = oCert2.getSubjectX500Principal();\n-            X500Name cSubject1Name = X500Name.asX500Name(cSubject1);\n-            X500Name cSubject2Name = X500Name.asX500Name(cSubject2);\n-\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" o1 Subject: \" + cSubject1);\n-                debug.println(METHOD_NME + \" o2 Subject: \" + cSubject2);\n-            }\n-            int distanceStoI1 = Builder.distance\n-                (cSubject1Name, cIssuer1Name, Integer.MAX_VALUE);\n-            int distanceStoI2 = Builder.distance\n-                (cSubject2Name, cIssuer2Name, Integer.MAX_VALUE);\n-            if (debug != null) {\n-                debug.println(METHOD_NME + \" distanceStoI1: \" + distanceStoI1);\n-                debug.println(METHOD_NME + \" distanceStoI2: \" + distanceStoI2);\n-            }\n-            if (distanceStoI2 > distanceStoI1) {\n-                return -1;\n-            } else if (distanceStoI2 < distanceStoI1) {\n-                return 1;\n-            }\n-\n@@ -650,0 +543,45 @@\n+    \/**\n+     * Returns the distance (number of RDNs) from the issuer's DN to the\n+     * common non-geographical ancestor of the trust anchor and issuer's DN.\n+     *\n+     * @param anchor the anchor's DN\n+     * @param issuer the issuer's DN\n+     * @return the distance or -1 if no common ancestor or an attribute of the\n+     *    last RDN of the common ancestor is geographical\n+     *\/\n+    private static int distanceToCommonAncestor(X500Name anchor, X500Name issuer) {\n+        List<RDN> anchorRdns = anchor.rdns();\n+        List<RDN> issuerRdns = issuer.rdns();\n+        int minLen = Math.min(anchorRdns.size(), issuerRdns.size());\n+        if (minLen == 0) {\n+            return -1;\n+        }\n+\n+        \/\/ Compare names from highest RDN down the naming tree.\n+        int i = 0;\n+        for (; i < minLen; i++) {\n+            RDN rdn = anchorRdns.get(i);\n+            if (!rdn.equals(issuerRdns.get(i))) {\n+                if (i == 0) {\n+                    return -1;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        \/\/ check if last RDN is geographical\n+        RDN lastRDN = anchorRdns.get(i - 1);\n+        for (AVA ava : lastRDN.avas()) {\n+            ObjectIdentifier oid = ava.getObjectIdentifier();\n+            if (oid.equals(X500Name.countryName_oid) ||\n+                oid.equals(X500Name.stateName_oid) ||\n+                oid.equals(X500Name.localityName_oid) ||\n+                oid.equals(X500Name.streetAddress_oid)) {\n+                return -1;\n+           }\n+        }\n+\n+        return issuer.size() - anchorRdns.subList(0, i).size();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":89,"deletions":151,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.reflect.*;\n@@ -30,2 +29,0 @@\n-import java.security.PrivilegedExceptionAction;\n-import java.security.AccessController;\n@@ -34,1 +31,1 @@\n-import java.util.StringJoiner;\n+import javax.security.auth.x500.X500Principal;\n@@ -36,0 +33,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -37,1 +35,0 @@\n-import javax.security.auth.x500.X500Principal;\n@@ -1275,83 +1272,0 @@\n-    \/**\n-     * Return lowest common ancestor of this name and other name\n-     *\n-     * @param other another X500Name\n-     * @return X500Name of lowest common ancestor; null if none\n-     *\/\n-    public X500Name commonAncestor(X500Name other) {\n-\n-        if (other == null) {\n-            return null;\n-        }\n-        int otherLen = other.names.length;\n-        int thisLen = this.names.length;\n-        if (thisLen == 0 || otherLen == 0) {\n-            return null;\n-        }\n-        int minLen = Math.min(thisLen, otherLen);\n-\n-        \/\/Compare names from highest RDN down the naming tree\n-        \/\/Note that these are stored in RDN[0]...\n-        int i=0;\n-        for (; i < minLen; i++) {\n-            if (!names[i].equals(other.names[i])) {\n-                if (i == 0) {\n-                    return null;\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/\/Copy matching RDNs into new RDN array\n-        RDN[] ancestor = new RDN[i];\n-        System.arraycopy(names, 0, ancestor, 0, i);\n-\n-        X500Name commonAncestor;\n-        try {\n-            commonAncestor = new X500Name(ancestor);\n-        } catch (IOException ioe) {\n-            return null;\n-        }\n-        return commonAncestor;\n-    }\n-\n-    \/**\n-     * Constructor object for use by asX500Principal().\n-     *\/\n-    private static final Constructor<X500Principal> principalConstructor;\n-\n-    \/**\n-     * Field object for use by asX500Name().\n-     *\/\n-    private static final Field principalField;\n-\n-    \/**\n-     * Retrieve the Constructor and Field we need for reflective access\n-     * and make them accessible.\n-     *\/\n-    static {\n-        PrivilegedExceptionAction<Object[]> pa =\n-                () -> {\n-                    Class<X500Principal> pClass = X500Principal.class;\n-                    Class<?>[] args = new Class<?>[] { X500Name.class };\n-                    Constructor<X500Principal> cons =\n-                        pClass.getDeclaredConstructor(args);\n-                    cons.setAccessible(true);\n-                    Field field = pClass.getDeclaredField(\"thisX500Name\");\n-                    field.setAccessible(true);\n-                    return new Object[] {cons, field};\n-                };\n-        try {\n-            @SuppressWarnings(\"removal\")\n-            Object[] result = AccessController.doPrivileged(pa);\n-            @SuppressWarnings(\"unchecked\")\n-            Constructor<X500Principal> constr =\n-                    (Constructor<X500Principal>)result[0];\n-            principalConstructor = constr;\n-            principalField = (Field)result[1];\n-        } catch (Exception e) {\n-            throw new InternalError(\"Could not obtain X500Principal access\", e);\n-        }\n-    }\n-\n@@ -1360,3 +1274,0 @@\n-     *\n-     * Note that we are using privileged reflection to access the hidden\n-     * package private constructor in X500Principal.\n@@ -1366,6 +1277,2 @@\n-            try {\n-                Object[] args = new Object[] {this};\n-                x500Principal = principalConstructor.newInstance(args);\n-            } catch (Exception e) {\n-                throw new RuntimeException(\"Unexpected exception\", e);\n-            }\n+            x500Principal =\n+                SharedSecrets.getJavaxSecurityAccess().asX500Principal(this);\n@@ -1378,2 +1285,0 @@\n-     *\n-     * Note that the X500Name is retrieved using reflection.\n@@ -1382,7 +1287,1 @@\n-        try {\n-            X500Name name = (X500Name)principalField.get(p);\n-            name.x500Principal = p;\n-            return name;\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Unexpected exception\", e);\n-        }\n+        return SharedSecrets.getJavaxSecurityAccess().asX500Name(p);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X500Name.java","additions":6,"deletions":107,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.time.temporal.ChronoUnit;\n+import java.time.Instant;\n@@ -46,0 +48,1 @@\n+import sun.security.x509.CertificateSerialNumber;\n@@ -502,1 +505,3 @@\n-        SerialNumber sn = new SerialNumber(serialNumber);\n+        CertificateSerialNumber sn = (serialNumber != null) ?\n+            new CertificateSerialNumber(serialNumber) :\n+            CertificateSerialNumber.newRandom64bit(new SecureRandom());\n@@ -519,2 +524,6 @@\n-        valSeq.putUTCTime(notBefore);\n-        valSeq.putUTCTime(notAfter);\n+        Instant now = Instant.now();\n+        Date startDate = (notBefore != null) ? notBefore : Date.from(now);\n+        valSeq.putUTCTime(startDate);\n+        Date endDate = (notAfter != null) ? notAfter :\n+            Date.from(now.plus(90, ChronoUnit.DAYS));\n+        valSeq.putUTCTime(endDate);\n@@ -560,0 +569,4 @@\n+\n+        if (extensions.isEmpty()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/security\/testlibrary\/CertificateBuilder.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317431\n+ * @summary Verify order of PKIXCertComparator sorting algorithm\n+ * @modules java.base\/sun.security.provider.certpath:+open\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib ..\/..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder\n+ * @run main Order\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.cert.X509Certificate;\n+import java.util.Comparator;\n+import java.util.Set;\n+import javax.security.auth.x500.X500Principal;\n+import sun.security.x509.X509CertImpl;\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+public class Order {\n+\n+    private record CertAndKeyPair(X509Certificate cert, KeyPair keyPair) {}\n+\n+    private static KeyPairGenerator kpg;\n+\n+    public static void main(String[] args) throws Exception {\n+        kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        kpg.initialize(2048);\n+\n+        \/\/ Create top-level root CA cert with KIDs (Subject and Auth KeyIds)\n+        CertAndKeyPair rootCA =\n+            createCert(null, \"CN=Root CA, O=Java, C=US\", true, true);\n+        System.out.println(rootCA.cert);\n+\n+        \/\/ Create intermediate CA cert with KIDs, issued by root CA\n+        CertAndKeyPair javaCA =\n+            createCert(rootCA, \"CN=Java CA, O=Java, C=US\", true, true);\n+        System.out.println(javaCA.cert);\n+\n+        \/\/ Create intermediate CA cert without KIDs, issued by root CA.\n+        \/\/ This CA has the same DN\/public key as the CA with KIDs.\n+        CertAndKeyPair javaCAWoKids = createCert(rootCA,\n+            \"CN=Java CA, O=Java, C=US\", true, false, javaCA.keyPair);\n+        System.out.println(javaCAWoKids.cert);\n+\n+        \/\/ Create another intermediate CA cert without KIDs, issued by root CA.\n+        CertAndKeyPair openJDKCAWoKids = createCert(rootCA,\n+                \"CN=OpenJDK CA, O=OpenJDK, C=US\", true, false);\n+        System.out.println(openJDKCAWoKids.cert);\n+\n+        \/\/ Create another intermediate CA with KIDs, issued by Java CA\n+        CertAndKeyPair secCA = createCert(javaCAWoKids,\n+            \"CN=Security CA, OU=Security, O=Java, C=US\", true, true);\n+        System.out.println(secCA.cert);\n+\n+        \/\/ Cross certify Java CA with OpenJDK CA\n+        CertAndKeyPair javaCAIssuedByOpenJDKCA = createCert(openJDKCAWoKids,\n+            \"CN=Java CA, O=Java, C=US\", true, false, javaCA.keyPair);\n+        System.out.println(javaCAIssuedByOpenJDKCA.cert);\n+\n+        \/\/ Cross certify Security CA with OpenJDK CA\n+        CertAndKeyPair secCAIssuedByOpenJDKCA = createCert(openJDKCAWoKids,\n+            \"CN=Security CA, OU=Security, O=Java, C=US\", true, false, secCA.keyPair);\n+        System.out.println(secCAIssuedByOpenJDKCA.cert);\n+\n+        \/\/ Create end entity cert without KIDs issued by Security CA.\n+        CertAndKeyPair ee = createCert(secCA,\n+            \"CN=EE, OU=Security, O=Java, C=US\", false, false);\n+        System.out.println(ee.cert);\n+\n+        \/\/ Create another end entity cert without KIDs issued by Java CA.\n+        \/\/ This EE has the same DN\/public key as the one above.\n+        CertAndKeyPair eeIssuedByJavaCA = createCert(javaCA,\n+            \"CN=EE, OU=Security, O=Java, C=US\", false, false);\n+        System.out.println(eeIssuedByJavaCA.cert);\n+\n+        Constructor ctor = getPKIXCertComparatorCtor();\n+        Set<X500Principal> trustedSubjects =\n+            Set.of(new X500Principal(\"CN=Root CA, O=Java, C=US\"));\n+\n+        System.out.println(\"Test that equal certs are treated the same\");\n+        Comparator c = (Comparator) ctor.newInstance(trustedSubjects,\n+            secCA.cert);\n+        Asserts.assertTrue(c.compare(javaCA.cert, javaCA.cert) == 0);\n+\n+        System.out.println(\"Test that cert with matching kids is preferred\");\n+        Asserts.assertTrue(c.compare(javaCA.cert, javaCAWoKids.cert) == -1);\n+        Asserts.assertTrue(c.compare(javaCAWoKids.cert, javaCA.cert) == 1);\n+\n+        System.out.println(\"Test that cert issued by anchor is preferred\");\n+        Asserts.assertTrue(\n+            c.compare(javaCAWoKids.cert, javaCAIssuedByOpenJDKCA.cert) == -1);\n+        Asserts.assertTrue(\n+            c.compare(javaCAIssuedByOpenJDKCA.cert, javaCAWoKids.cert) == 1);\n+\n+        System.out.println(\n+            \"Test that cert issuer in same namespace as anchor is preferred\");\n+        c = (Comparator) ctor.newInstance(trustedSubjects, ee.cert);\n+        Asserts.assertTrue(\n+            c.compare(secCA.cert, secCAIssuedByOpenJDKCA.cert) == -1);\n+        Asserts.assertTrue(\n+            c.compare(secCAIssuedByOpenJDKCA.cert, secCA.cert) == 1);\n+\n+        System.out.println(\n+            \"Test cert issuer in same namespace closest to root is preferred\");\n+        Asserts.assertTrue(c.compare(eeIssuedByJavaCA.cert, ee.cert) == -1);\n+        Asserts.assertTrue(c.compare(ee.cert, eeIssuedByJavaCA.cert) == 1);\n+    }\n+\n+    private static boolean[] CA_KEY_USAGE =\n+        new boolean[] {true,false,false,false,false,true,true,false,false};\n+    private static boolean[] EE_KEY_USAGE =\n+        new boolean[] {true,false,false,false,false,false,false,false,false};\n+\n+    private static CertAndKeyPair createCert(CertAndKeyPair issuer,\n+        String subjectDn, boolean ca, boolean kids) throws Exception {\n+\n+        KeyPair kp = kpg.generateKeyPair();\n+        return createCert(issuer, subjectDn, ca, kids, kp);\n+    }\n+\n+    private static CertAndKeyPair createCert(CertAndKeyPair issuer,\n+        String subjectDn, boolean ca, boolean kids, KeyPair kp)\n+        throws Exception {\n+\n+        if (issuer == null) {\n+            issuer = new CertAndKeyPair(null, kp);\n+        }\n+        CertificateBuilder cb = new CertificateBuilder()\n+            .setSubjectName(subjectDn)\n+            .setPublicKey(kp.getPublic());\n+\n+        if (ca) {\n+            cb = cb.addBasicConstraintsExt(true, true, -1)\n+                   .addKeyUsageExt(CA_KEY_USAGE);\n+        } else {\n+            cb = cb.addBasicConstraintsExt(true, false, -1)\n+                   .addKeyUsageExt(EE_KEY_USAGE);\n+        }\n+        if (kids) {\n+            cb = cb.addAuthorityKeyIdExt(issuer.keyPair.getPublic())\n+                   .addSubjectKeyIdExt(kp.getPublic());\n+        }\n+        X509Certificate cert =\n+            cb.build(issuer.cert, issuer.keyPair.getPrivate(), \"SHA256withRSA\");\n+        return new CertAndKeyPair(cert, kp);\n+    }\n+\n+    private static Constructor getPKIXCertComparatorCtor() throws Exception {\n+        var cl = Class.forName(\n+            \"sun.security.provider.certpath.ForwardBuilder$PKIXCertComparator\");\n+        var c = cl.getDeclaredConstructor(Set.class, X509CertImpl.class);\n+        c.setAccessible(true);\n+        return c;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/PKIXCertComparator\/Order.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"}]}