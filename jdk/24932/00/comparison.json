{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayDeque;\n@@ -30,1 +29,0 @@\n-import java.util.Comparator;\n@@ -38,1 +36,1 @@\n-import java.util.function.BiPredicate;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -44,0 +42,1 @@\n+import java.util.stream.IntStream;\n@@ -55,1 +54,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -62,2 +60,1 @@\n-import com.sun.tools.javac.util.JCDiagnostic;\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -70,0 +67,1 @@\n+import static com.sun.tools.javac.code.Lint.LintCategory.THIS_ESCAPE;\n@@ -167,1 +165,1 @@\n-    private Env<AttrContext> attrEnv;\n+    private Env<AttrContext> topLevelEnv;\n@@ -188,1 +186,1 @@\n-    private final ArrayList<DiagnosticPosition[]> warningList = new ArrayList<>();\n+    private final ArrayList<Warning> warningList = new ArrayList<>();\n@@ -192,1 +190,1 @@\n-    \/** The declaring class of the \"invoked\" method we're currently analyzing.\n+    \/** The method we're currently analyzing.\n@@ -195,1 +193,1 @@\n-    private JCClassDecl methodClass;\n+    private MethodInfo currentMethod;\n@@ -197,2 +195,3 @@\n-    \/** The current \"call stack\" during our analysis. The first entry is some method\n-     *  invoked from the target constructor; if empty, we're still in the constructor.\n+    \/** The current \"call stack\" during our analysis. The first entry is the initial\n+     *  constructor we started with, and subsequent entries correspond to invoked methods.\n+     *  If we're still in the initial constructor, the list will be empty.\n@@ -200,1 +199,1 @@\n-    private final ArrayDeque<DiagnosticPosition> callStack = new ArrayDeque<>();\n+    private final ArrayList<StackFrame> callStack = new ArrayList<>();\n@@ -206,6 +205,0 @@\n-    \/** Snapshot of {@link #callStack} where a possible 'this' escape occurs.\n-     *  If non-null, a 'this' escape warning has been found in the current\n-     *  constructor statement, initialization block statement, or field initializer.\n-     *\/\n-    private DiagnosticPosition[] pendingWarning;\n-\n@@ -249,0 +242,1 @@\n+        topLevelEnv = env;\n@@ -252,1 +246,1 @@\n-            attrEnv = null;\n+            topLevelEnv = null;\n@@ -257,1 +251,1 @@\n-            methodClass = null;\n+            currentMethod = null;\n@@ -260,1 +254,0 @@\n-            pendingWarning = null;\n@@ -273,1 +266,1 @@\n-        if (!lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+        if (!lint.isEnabled(THIS_ESCAPE))\n@@ -327,1 +320,1 @@\n-                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(THIS_ESCAPE))\n@@ -344,1 +337,1 @@\n-                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(Lint.LintCategory.THIS_ESCAPE))\n+                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(THIS_ESCAPE))\n@@ -347,0 +340,6 @@\n+                    \/\/ Gather some useful info\n+                    boolean constructor = TreeInfo.isConstructor(tree);\n+                    boolean extendableClass = currentClassIsExternallyExtendable();\n+                    boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n+                    boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+\n@@ -348,5 +347,1 @@\n-                    boolean extendable = currentClassIsExternallyExtendable();\n-                    boolean analyzable = extendable &&\n-                        TreeInfo.isConstructor(tree) &&\n-                        (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0 &&\n-                        !suppressed.contains(tree.sym);\n+                    boolean analyzable = extendableClass && constructor && nonPrivate;\n@@ -354,4 +349,2 @@\n-                    \/\/ Determine if this method is \"invokable\" in an analysis (can't be overridden)\n-                    boolean invokable = !extendable ||\n-                        TreeInfo.isConstructor(tree) ||\n-                        (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+                    \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n+                    boolean invokable = !extendableClass || constructor || finalish;\n@@ -359,2 +352,2 @@\n-                    \/\/ Add method or constructor to map\n-                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, analyzable, invokable));\n+                    \/\/ Add this method or constructor to our map\n+                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n@@ -380,31 +373,1 @@\n-        \/\/ Analyze non-static field initializers and initialization blocks,\n-        \/\/ but only for classes having at least one analyzable constructor.\n-        methodMap.values().stream()\n-                .filter(MethodInfo::analyzable)\n-                .map(MethodInfo::declaringClass)\n-                .distinct()\n-                .forEach(klass -> {\n-            for (List<JCTree> defs = klass.defs; defs.nonEmpty(); defs = defs.tail) {\n-\n-                \/\/ Ignore static stuff\n-                if ((TreeInfo.flags(defs.head) & Flags.STATIC) != 0)\n-                    continue;\n-\n-                \/\/ Handle field initializers\n-                if (defs.head instanceof JCVariableDecl vardef) {\n-                    visitTopLevel(env, klass, () -> {\n-                        scan(vardef);\n-                        copyPendingWarning();\n-                    });\n-                    continue;\n-                }\n-\n-                \/\/ Handle initialization blocks\n-                if (defs.head instanceof JCBlock block) {\n-                    visitTopLevel(env, klass, () -> analyzeStatements(block.stats));\n-                    continue;\n-                }\n-            }\n-        });\n-\n-        \/\/ Analyze all of the analyzable constructors we found\n+        \/\/ Analyze the analyzable constructors we found\n@@ -412,11 +375,16 @@\n-                .filter(MethodInfo::analyzable)\n-                .forEach(methodInfo -> {\n-            visitTopLevel(env, methodInfo.declaringClass(),\n-                () -> analyzeStatements(methodInfo.declaration().body.stats));\n-        });\n-\n-        \/\/ Eliminate duplicate warnings. Warning B duplicates warning A if the stack trace of A is a prefix\n-        \/\/ of the stack trace of B. For example, if constructor Foo(int x) has a leak, and constructor\n-        \/\/ Foo() invokes this(0), then emitting a warning for Foo() would be redundant.\n-        BiPredicate<DiagnosticPosition[], DiagnosticPosition[]> extendsAsPrefix = (warning1, warning2) -> {\n-            if (warning2.length < warning1.length)\n+          .filter(MethodInfo::analyzable)\n+          .forEach(this::analyzeConstructor);\n+\n+        \/\/ Manually apply any Lint suppression\n+        filterWarnings(warning -> !warning.isSuppressed());\n+\n+        \/\/ Field intitializers and initialization blocks will generate a separate warning for each primary constructor.\n+        \/\/ Trim off stack frames up through the super() call so these will have identical stacks and get de-duplicated below.\n+        warningList.forEach(Warning::trimInitializerFrames);\n+\n+        \/\/ Sort warnings so redundant warnings immediately follow whatever they are redundant for, then remove them\n+        warningList.sort(Warning::sortByStackFrames);\n+        AtomicReference<Warning> previousRef = new AtomicReference<>();\n+        filterWarnings(warning -> {\n+            Warning previous = previousRef.get();\n+            if (previous != null && warning.isRedundantWith(previous))\n@@ -424,4 +392,1 @@\n-            for (int index = 0; index < warning1.length; index++) {\n-                if (warning2[index].getPreferredPosition() != warning1[index].getPreferredPosition())\n-                    return false;\n-            }\n+            previousRef.set(warning);\n@@ -429,1 +394,1 @@\n-        };\n+        });\n@@ -431,36 +396,9 @@\n-        \/\/ Stack traces are ordered top to bottom, and so duplicates always have the same first element(s).\n-        \/\/ Sort the stack traces lexicographically, so that duplicates immediately follow what they duplicate.\n-        Comparator<DiagnosticPosition[]> ordering = (warning1, warning2) -> {\n-            for (int index1 = 0, index2 = 0; true; index1++, index2++) {\n-                boolean end1 = index1 >= warning1.length;\n-                boolean end2 = index2 >= warning2.length;\n-                if (end1 && end2)\n-                    return 0;\n-                if (end1)\n-                    return -1;\n-                if (end2)\n-                    return 1;\n-                int posn1 = warning1[index1].getPreferredPosition();\n-                int posn2 = warning2[index2].getPreferredPosition();\n-                int diff = Integer.compare(posn1, posn2);\n-                if (diff != 0)\n-                    return diff;\n-            }\n-        };\n-        warningList.sort(ordering);\n-\n-        \/\/ Now emit the warnings, but skipping over duplicates as we go through the list\n-        DiagnosticPosition[] previous = null;\n-        for (DiagnosticPosition[] warning : warningList) {\n-\n-            \/\/ Skip duplicates\n-            if (previous != null && extendsAsPrefix.test(previous, warning))\n-                continue;\n-            previous = warning;\n-\n-            \/\/ Emit warnings showing the entire stack trace\n-            JCDiagnostic.Warning key = LintWarnings.PossibleThisEscape;\n-            int remain = warning.length;\n-            do {\n-                DiagnosticPosition pos = warning[--remain];\n-                log.warning(pos, key);\n+        \/\/ Limit output to one warning per constructor, field initializer, or initializer block\n+        Set<JCTree> thingsWarnedAbout = new HashSet<>();\n+        filterWarnings(warning -> thingsWarnedAbout.add(warning.origin));\n+\n+        \/\/ Emit warnings\n+        for (Warning warning : warningList) {\n+            LintWarning key = LintWarnings.PossibleThisEscape;\n+            for (StackFrame frame : warning.stack) {\n+                log.warning(frame.site.pos(), key);\n@@ -468,1 +406,1 @@\n-            } while (remain > 0);\n+            }\n@@ -470,0 +408,2 @@\n+\n+        \/\/ Done\n@@ -473,6 +413,6 @@\n-    \/\/ Analyze statements, but stop at (and record) the first warning generated\n-    private void analyzeStatements(List<JCStatement> stats) {\n-        for (JCStatement stat : stats) {\n-            scan(stat);\n-            if (copyPendingWarning())\n-                break;\n+    \/\/ Warning list editor (this is slightly more efficient than removeIf())\n+    private void filterWarnings(Predicate<Warning> filter) {\n+        int numRetained = 0;\n+        for (Warning warning : warningList) {\n+            if (filter.test(warning))\n+                warningList.set(numRetained++, warning);\n@@ -480,0 +420,1 @@\n+        warningList.subList(numRetained, warningList.size()).clear();\n@@ -545,4 +486,0 @@\n-        \/\/ Skip if ignoring warnings for this field\n-        if (suppressed.contains(sym))\n-            return;\n-\n@@ -582,2 +519,12 @@\n-        \/\/ If \"super()\": ignore - we don't try to track into superclasses\n-        if (TreeInfo.name(invoke.meth) == names._super)\n+        \/\/ If \"super()\": we don't invoke it (we don't track into superclasses) but we do execute any\n+        \/\/ non-static field initializers and initialization blocks because this is when they happen.\n+        if (TreeInfo.name(invoke.meth) == names._super) {\n+            currentMethod.declaringClass.defs.stream()\n+              .filter(def -> (TreeInfo.flags(def) & Flags.STATIC) == 0)\n+              .forEach(def -> {\n+                switch (def) {\n+                case JCBlock block          -> analyzeInitializer(invoke, block, receiverRefs, () -> visitBlock(block));\n+                case JCVariableDecl varDecl -> analyzeInitializer(invoke, varDecl, receiverRefs, () -> scan(varDecl));\n+                default -> { }\n+                }\n+              });\n@@ -585,0 +532,1 @@\n+        }\n@@ -590,1 +538,16 @@\n-    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n+    \/\/ Analyze a field initializer or initialization block after encountering a super() invocation\n+    private void analyzeInitializer(JCMethodInvocation site, JCTree initializer, RefSet<ThisRef> receiverRefs, Runnable action) {\n+        RefSet<Ref> refsPrev = refs;\n+        refs = RefSet.newEmpty();\n+        int depthPrev = depth;\n+        depth = 0;\n+        callStack.add(new StackFrame(currentMethod, initializer, site));\n+        try {\n+            refs.addAll(receiverRefs);\n+            action.run();\n+        } finally {\n+            callStack.remove(callStack.size() - 1);\n+            depth = depthPrev;\n+            refs = refsPrev;\n+        }\n+    }\n@@ -592,3 +555,1 @@\n-        \/\/ Skip if ignoring warnings for a constructor invoked via 'this()'\n-        if (suppressed.contains(sym))\n-            return;\n+    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n@@ -630,1 +591,1 @@\n-        if (methodInfo != null && methodInfo.invokable())\n+        if (methodInfo != null && methodInfo.invokable)\n@@ -647,3 +608,2 @@\n-    private void invokeInvokable(JCTree site, List<JCExpression> args,\n-            RefSet<ThisRef> receiverRefs, MethodInfo methodInfo) {\n-        Assert.check(methodInfo.invokable());\n+    private void invokeInvokable(JCTree site, List<JCExpression> args, RefSet<ThisRef> receiverRefs, MethodInfo methodInfo) {\n+        Assert.check(methodInfo.invokable);\n@@ -652,1 +612,1 @@\n-        JCMethodDecl method = methodInfo.declaration();\n+        JCMethodDecl method = methodInfo.declaration;\n@@ -666,2 +626,2 @@\n-        JCClassDecl methodClassPrev = methodClass;\n-        methodClass = methodInfo.declaringClass();\n+        MethodInfo currentMethodPrev = currentMethod;\n+        currentMethod = methodInfo;\n@@ -672,1 +632,1 @@\n-        callStack.push(site);\n+        callStack.add(new StackFrame(currentMethodPrev, null, site));\n@@ -709,1 +669,1 @@\n-            callStack.pop();\n+            callStack.remove(callStack.size() - 1);\n@@ -712,1 +672,1 @@\n-            methodClass = methodClassPrev;\n+            currentMethod = currentMethodPrev;\n@@ -758,1 +718,1 @@\n-        if (methodInfo != null && methodInfo.invokable())\n+        if (methodInfo != null && methodInfo.invokable)\n@@ -790,1 +750,2 @@\n-        return tsym != methodClass.sym\n+        ClassSymbol currentClassSym = currentMethod.declaringClass.sym;\n+        return tsym != currentClassSym\n@@ -792,1 +753,1 @@\n-          && tsym.isEnclosedBy(methodClass.sym);\n+          && tsym.isEnclosedBy(currentClassSym);\n@@ -832,1 +793,1 @@\n-            Symbol iteratorSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+            Symbol iteratorSym = rs.resolveQualifiedMethod(tree.expr.pos(), topLevelEnv,\n@@ -836,1 +797,1 @@\n-                Symbol hasNextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                Symbol hasNextSym = rs.resolveQualifiedMethod(tree.expr.pos(), topLevelEnv,\n@@ -838,1 +799,1 @@\n-                Symbol nextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                Symbol nextSym = rs.resolveQualifiedMethod(tree.expr.pos(), topLevelEnv,\n@@ -977,1 +938,1 @@\n-        Type.ClassType currentClassType = (Type.ClassType)methodClass.sym.type;\n+        Type.ClassType currentClassType = (Type.ClassType)currentMethod.declaringClass.sym.type;\n@@ -1062,1 +1023,1 @@\n-            ClassSymbol methodClassSym = methodClass.sym;\n+            ClassSymbol methodClassSym = currentMethod.declaringClass.sym;\n@@ -1246,2 +1207,1 @@\n-    private void visitTopLevel(Env<AttrContext> env, JCClassDecl klass, Runnable action) {\n-        Assert.check(attrEnv == null);\n+    private void analyzeConstructor(MethodInfo constructor) {\n@@ -1249,1 +1209,1 @@\n-        Assert.check(methodClass == null);\n+        Assert.check(currentMethod == null);\n@@ -1252,3 +1212,2 @@\n-        attrEnv = env;\n-        targetClass = klass;\n-        methodClass = klass;\n+        targetClass = constructor.declaringClass;\n+        currentMethod = constructor;\n@@ -1261,2 +1220,2 @@\n-            \/\/ Perform action\n-            this.visitScoped(false, action);\n+            \/\/ Analyze constructor\n+            visitScoped(false, () -> scan(constructor.declaration.body));\n@@ -1265,2 +1224,1 @@\n-            attrEnv = null;\n-            methodClass = null;\n+            currentMethod = null;\n@@ -1273,5 +1231,5 @@\n-    \/\/ We stash any pending warning and the current RefSet, then recurse into the deferred\n-    \/\/ code (still using the current RefSet) to see if it would leak. Then we restore the\n-    \/\/ pending warning and the current RefSet. Finally, if the deferred code would have\n-    \/\/ leaked, we create an indirect ExprRef because it must be holding a 'this' reference.\n-    \/\/ If the deferred code would not leak, then obviously no leak is possible, period.\n+    \/\/ We record the current number of (real) warnings, then recurse into the deferred\n+    \/\/ code (still using the current RefSet) to see if that number increases, i.e., to\n+    \/\/ see if it would leak. Then we discard any new warnings and the lambda's RefSet.\n+    \/\/ Finally, if the deferred code would have leaked, we create an indirect ExprRef\n+    \/\/ because the lambda must be holding a 'this' reference. If not, no leak is possible.\n@@ -1279,2 +1237,1 @@\n-        DiagnosticPosition[] pendingWarningPrev = pendingWarning;\n-        pendingWarning = null;\n+        int numWarningsPrev = warningList.size();\n@@ -1285,1 +1242,1 @@\n-            deferredCodeLeaks = pendingWarning != null;\n+            deferredCodeLeaks = warningList.size() > numWarningsPrev;\n@@ -1292,1 +1249,1 @@\n-            pendingWarning = pendingWarningPrev;\n+            warningList.subList(numWarningsPrev, warningList.size()).clear();\n@@ -1344,18 +1301,3 @@\n-\n-        \/\/ Generate at most one warning per statement\n-        if (pendingWarning != null)\n-            return;\n-\n-        \/\/ Snapshot the current stack trace\n-        callStack.push(tree.pos());\n-        pendingWarning = callStack.toArray(new DiagnosticPosition[0]);\n-        callStack.pop();\n-    }\n-\n-    \/\/ Copy pending warning, if any, to the warning list and reset\n-    private boolean copyPendingWarning() {\n-        if (pendingWarning == null)\n-            return false;\n-        warningList.add(pendingWarning);\n-        pendingWarning = null;\n-        return true;\n+        callStack.add(new StackFrame(currentMethod, null, tree));         \/\/ include the point of leakage in the stack\n+        warningList.add(new Warning(targetClass, new ArrayList<>(callStack)));\n+        callStack.remove(callStack.size() - 1);\n@@ -1401,1 +1343,1 @@\n-            Assert.check(methodClass != null);\n+            Assert.check(currentMethod != null);\n@@ -1412,1 +1354,0 @@\n-            Assert.check(pendingWarning == null);\n@@ -1791,0 +1732,117 @@\n+\/\/ StackFrame\n+\n+    \/\/ Information about one frame on the call stack\n+    private class StackFrame {\n+\n+        final MethodInfo method;                    \/\/ the method containing the statement\n+        final JCTree site;                          \/\/ the call site within the method\n+        final JCTree initializer;                   \/\/ originating field or initialization block, else null\n+        final boolean suppressible;                 \/\/ whether warning can be suppressed at this frame\n+\n+        StackFrame(MethodInfo method, JCTree initializer, JCTree site) {\n+            this.method = method;\n+            this.initializer = initializer;\n+            this.site = site;\n+            this.suppressible = initializer != null || (method.constructor && method.declaringClass == targetClass);\n+        }\n+\n+        boolean isSuppressed() {\n+            return suppressible &&\n+              suppressed.contains(initializer instanceof JCVariableDecl v ? v.sym : method.declaration.sym);\n+        }\n+\n+        int comparePos(StackFrame that) {\n+            return Integer.compare(this.site.pos().getPreferredPosition(), that.site.pos().getPreferredPosition());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"StackFrame\"\n+              + \"[\" + method.declaration.sym + \"@\" + site.pos().getPreferredPosition()\n+              + (initializer != null ? \",init@\" + initializer.pos().getPreferredPosition() : \"\")\n+              + \"]\";\n+        }\n+    }\n+\n+\/\/ Warning\n+\n+    \/\/ Information about one warning we have generated\n+    private class Warning {\n+\n+        final JCClassDecl declaringClass;           \/\/ the class whose instance is leaked\n+        final ArrayList<StackFrame> stack;          \/\/ the call stack where the leak happens\n+        final JCTree origin;                        \/\/ the originating ctor, field, or init block\n+\n+        Warning(JCClassDecl declaringClass, ArrayList<StackFrame> stack) {\n+            this.declaringClass = declaringClass;\n+            this.stack = stack;\n+            this.origin = stack.stream()\n+              .map(frame -> frame.initializer)\n+              .filter(Objects::nonNull)\n+              .findFirst()\n+              .orElseGet(() -> stack.get(0).method.declaration);    \/\/ default to the initial constructor\n+        }\n+\n+        \/\/ Used to eliminate redundant warnings. Warning A is redundant with warning B if the call stack of A includes\n+        \/\/ the call stack of B plus additional initial frame(s). For example, if constructor B = Foo(int x) generates a\n+        \/\/ warning, then generating warning for some other constructor A when it invokes this(123) would be redundant.\n+        boolean isRedundantWith(Warning that) {\n+            int numExtra = this.stack.size() - that.stack.size();\n+            return numExtra >= 0 &&\n+              IntStream.range(0, that.stack.size())\n+                .allMatch(index -> this.stack.get(numExtra + index).comparePos(that.stack.get(index)) == 0);\n+        };\n+\n+        \/\/ Order warnings by their stack frames, lexicographically in reverse calling order, which will cause\n+        \/\/ all warnings that are isRedundantWith() some other warning to immediately follow that warning.\n+        static int sortByStackFrames(Warning warning1, Warning warning2) {\n+            int index1 = warning1.stack.size();\n+            int index2 = warning2.stack.size();\n+            while (true) {\n+                boolean end1 = --index1 < 0;\n+                boolean end2 = --index2 < 0;\n+                if (end1 && end2)\n+                    return 0;\n+                if (end1)\n+                    return -1;\n+                if (end2)\n+                    return 1;\n+                int diff = warning1.stack.get(index1).comparePos(warning2.stack.get(index2));\n+                if (diff != 0)\n+                    return diff;\n+            }\n+        };\n+\n+        \/\/ Determine whether this warning is suppressed. A single \"this-escape\" warning involves multiple source code\n+        \/\/ positions, so we must determine suppression manually. We do this as follows: A warning is suppressed if\n+        \/\/ \"this-escape\" is disabled at any position in the stack where that stack frame corresponds to a constructor\n+        \/\/ or field initializer in the target class. That means, for example, @SuppressWarnings(\"this-escape\") annotations\n+        \/\/ on regular methods are ignored. Here we work our way back up the call stack from the point of the leak until\n+        \/\/ we encounter a suppressible stack frame.\n+        boolean isSuppressed() {\n+            for (int index = stack.size() - 1; index >= 0; index--) {\n+                if (stack.get(index).isSuppressed())\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        \/\/ If this is a field or initializer warning, trim the initial stack frame(s) up through the super() call\n+        void trimInitializerFrames() {\n+            for (int i = 0; i < stack.size(); i++) {\n+                if (stack.get(i).initializer != null) {\n+                    stack.subList(0, i + 1).clear();\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Warning\"\n+              + \"[class=\" + declaringClass.sym.flatname\n+              + \",stack=[\\n    \" + stack.stream().map(StackFrame::toString).collect(Collectors.joining(\"\\n    \")) + \"]\"\n+              + \"]\";\n+        }\n+    }\n+\n@@ -1797,0 +1855,1 @@\n+        boolean constructor,            \/\/ the method is a constructor\n@@ -1804,0 +1863,1 @@\n+              + \",constructor=\" + constructor\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":253,"deletions":193,"binary":false,"changes":446,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8015831\n+ * @bug 8015831 8355753\n@@ -768,0 +768,18 @@\n+\n+    \/\/ JDK-8355753 - @SuppressWarnings(\"this-escape\") not respected for indirect leak via field\n+    public static class SuppressedIndirectLeakViaField {\n+\n+        private final int x = this.mightLeak();     \/\/ this leak should be suppressed\n+\n+        public SuppressedIndirectLeakViaField() {\n+            this(\"\");\n+        }\n+\n+        @SuppressWarnings(\"this-escape\")\n+        private SuppressedIndirectLeakViaField(String s) {\n+        }\n+\n+        public int mightLeak() {\n+            return 0;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}