{"files":[{"patch":"@@ -67,0 +67,1 @@\n+  HOTSPOT_JTREG_EXECUTABLES_JDK_LIBS_exegc_z_TestLinuxVirtualAddressSpace := java.base:libjvm\n@@ -68,0 +69,1 @@\n+  HOTSPOT_JTREG_EXECUTABLES_LIBS_exegc_z_TestLinuxVirtualAddressSpace := -ldl\n@@ -74,1 +76,2 @@\n-      exeinvoke.c exestack-gap.c exestack-tls.c libAsyncGetCallTraceTest.cpp\n+      exeinvoke.c exestack-gap.c exestack-tls.c libAsyncGetCallTraceTest.cpp \\\n+      exegc_z_TestLinuxVirtualAddressSpace.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,82 +24,2 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n-#include \"gc\/z\/zAddress.hpp\"\n-#include \"gc\/z\/zBarrierSetAssembler.hpp\"\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-#ifdef LINUX\n-#include <sys\/mman.h>\n-#endif \/\/ LINUX\n-\n-\/\/ Default value if probing is not implemented for a certain platform\n-\/\/ Max address bit is restricted by implicit assumptions in the code, for instance\n-\/\/ the bit layout of ZForwardingEntry or Partial array entry (see ZMarkStackEntry) in mark stack\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 46;\n-\/\/ Minimum value returned, if probing fail\n-static const size_t MINIMUM_MAX_ADDRESS_BIT = 36;\n-\n-static size_t probe_valid_max_address_bit() {\n-#ifdef LINUX\n-  size_t max_address_bit = 0;\n-  const size_t page_size = os::vm_page_size();\n-  for (size_t i = DEFAULT_MAX_ADDRESS_BIT; i > MINIMUM_MAX_ADDRESS_BIT; --i) {\n-    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n-    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n-      \/\/ msync suceeded, the address is valid, and maybe even already mapped.\n-      max_address_bit = i;\n-      break;\n-    }\n-    if (errno != ENOMEM) {\n-      \/\/ Some error occured. This should never happen, but msync\n-      \/\/ has some undefined behavior, hence ignore this bit.\n-#ifdef ASSERT\n-      fatal(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#else \/\/ ASSERT\n-      log_warning_p(gc)(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#endif \/\/ ASSERT\n-      continue;\n-    }\n-    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n-    \/\/ Try to map it, to see if the address is valid.\n-    void* const result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      munmap(result_addr, page_size);\n-    }\n-    if ((uintptr_t) result_addr == base_addr) {\n-      \/\/ address is valid\n-      max_address_bit = i;\n-      break;\n-    }\n-  }\n-  if (max_address_bit == 0) {\n-    \/\/ probing failed, allocate a very high page and take that bit as the maximum\n-    const uintptr_t high_addr = ((uintptr_t) 1U) << DEFAULT_MAX_ADDRESS_BIT;\n-    void* const result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      max_address_bit = BitsPerSize_t - count_leading_zeros((size_t) result_addr) - 1;\n-      munmap(result_addr, page_size);\n-    }\n-  }\n-  log_info_p(gc, init)(\"Probing address space for the highest valid bit: %zu\", max_address_bit);\n-  return MAX2(max_address_bit, MINIMUM_MAX_ADDRESS_BIT);\n-#else \/\/ LINUX\n-  return DEFAULT_MAX_ADDRESS_BIT;\n-#endif \/\/ LINUX\n-}\n-\n-size_t ZPlatformAddressOffsetBits() {\n-  static const size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n-  const size_t min_address_offset_bits = max_address_offset_bits - 2;\n-  const size_t address_offset = ZGlobalsPointers::min_address_offset_request();\n-  const size_t address_offset_bits = log2i_exact(address_offset);\n-  return clamp(address_offset_bits, min_address_offset_bits, max_address_offset_bits);\n-}\n-\n-size_t ZPlatformAddressHeapBaseShift() {\n-  return ZPlatformAddressOffsetBits();\n-}\n+ #include \"gc\/z\/zAddress.hpp\"\n+ #include \"gc\/z\/zBarrierSetAssembler.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-size_t ZPlatformAddressOffsetBits();\n-size_t ZPlatformAddressHeapBaseShift();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,86 +24,1 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n-#include \"gc\/z\/zAddress.inline.hpp\"\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-#ifdef LINUX\n-#include <sys\/mman.h>\n-#endif \/\/ LINUX\n-\n-\/\/ Default value if probing is not implemented for a certain platform\n-\/\/ Max address bit is restricted by implicit assumptions in the code, for instance\n-\/\/ the bit layout of ZForwardingEntry or Partial array entry (see ZMarkStackEntry) in mark stack\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 46;\n-\/\/ Minimum value returned, if probing fail\n-static const size_t MINIMUM_MAX_ADDRESS_BIT = 36;\n-\n-static size_t probe_valid_max_address_bit() {\n-#ifdef LINUX\n-  size_t max_address_bit = 0;\n-  const size_t page_size = os::vm_page_size();\n-  for (size_t i = DEFAULT_MAX_ADDRESS_BIT; i > MINIMUM_MAX_ADDRESS_BIT; --i) {\n-    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n-    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n-      \/\/ msync suceeded, the address is valid, and maybe even already mapped.\n-      max_address_bit = i;\n-      break;\n-    }\n-    if (errno != ENOMEM) {\n-      \/\/ Some error occured. This should never happen, but msync\n-      \/\/ has some undefined behavior, hence ignore this bit.\n-#ifdef ASSERT\n-      fatal(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#else \/\/ ASSERT\n-      log_warning_p(gc)(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#endif \/\/ ASSERT\n-      continue;\n-    }\n-    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n-    \/\/ Try to map it, to see if the address is valid.\n-    void* const result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      munmap(result_addr, page_size);\n-    }\n-    if ((uintptr_t) result_addr == base_addr) {\n-      \/\/ address is valid\n-      max_address_bit = i;\n-      break;\n-    }\n-  }\n-  if (max_address_bit == 0) {\n-    \/\/ probing failed, allocate a very high page and take that bit as the maximum\n-    const uintptr_t high_addr = ((uintptr_t) 1U) << DEFAULT_MAX_ADDRESS_BIT;\n-    void* const result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      max_address_bit = BitsPerSize_t - count_leading_zeros((size_t) result_addr) - 1;\n-      munmap(result_addr, page_size);\n-    }\n-  }\n-  log_info_p(gc, init)(\"Probing address space for the highest valid bit: %zu\", max_address_bit);\n-  return MAX2(max_address_bit, MINIMUM_MAX_ADDRESS_BIT);\n-#else \/\/ LINUX\n-  return DEFAULT_MAX_ADDRESS_BIT;\n-#endif \/\/ LINUX\n-}\n-\n-size_t ZPlatformAddressOffsetBits() {\n-  static const size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n-#ifdef ADDRESS_SANITIZER\n-  \/\/ The max supported value is 44 because of other internal data structures.\n-  return MIN2(valid_max_address_offset_bits, (size_t)44);\n-#else\n-  const size_t min_address_offset_bits = max_address_offset_bits - 2;\n-  const size_t address_offset = ZGlobalsPointers::min_address_offset_request();\n-  const size_t address_offset_bits = log2i_exact(address_offset);\n-  return clamp(address_offset_bits, min_address_offset_bits, max_address_offset_bits);\n-#endif\n-}\n-\n-size_t ZPlatformAddressHeapBaseShift() {\n-  return ZPlatformAddressOffsetBits();\n-}\n+#include \"gc\/z\/zAddress.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zAddress_ppc.cpp","additions":1,"deletions":86,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-size_t ZPlatformAddressOffsetBits();\n-size_t ZPlatformAddressHeapBaseShift();\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zAddress_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/gcLogPrecious.hpp\"\n@@ -29,78 +27,0 @@\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-#ifdef LINUX\n-#include <sys\/mman.h>\n-#endif \/\/ LINUX\n-\n-\/\/ Default value if probing is not implemented for a certain platform\n-\/\/ Max address bit is restricted by implicit assumptions in the code, for instance\n-\/\/ the bit layout of ZForwardingEntry or Partial array entry (see ZMarkStackEntry) in mark stack\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 46;\n-\/\/ Minimum value returned, if probing fail\n-static const size_t MINIMUM_MAX_ADDRESS_BIT = 36;\n-\n-static size_t probe_valid_max_address_bit() {\n-#ifdef LINUX\n-  size_t max_address_bit = 0;\n-  const size_t page_size = os::vm_page_size();\n-  for (size_t i = DEFAULT_MAX_ADDRESS_BIT; i > MINIMUM_MAX_ADDRESS_BIT; --i) {\n-    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n-    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n-      \/\/ msync suceeded, the address is valid, and maybe even already mapped.\n-      max_address_bit = i;\n-      break;\n-    }\n-    if (errno != ENOMEM) {\n-      \/\/ Some error occured. This should never happen, but msync\n-      \/\/ has some undefined behavior, hence ignore this bit.\n-#ifdef ASSERT\n-      fatal(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#else \/\/ ASSERT\n-      log_warning_p(gc)(\"Received '%s' while probing the address space for the highest valid bit\", os::errno_name(errno));\n-#endif \/\/ ASSERT\n-      continue;\n-    }\n-    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n-    \/\/ Try to map it, to see if the address is valid.\n-    void* const result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      munmap(result_addr, page_size);\n-    }\n-    if ((uintptr_t) result_addr == base_addr) {\n-      \/\/ address is valid\n-      max_address_bit = i;\n-      break;\n-    }\n-  }\n-  if (max_address_bit == 0) {\n-    \/\/ probing failed, allocate a very high page and take that bit as the maximum\n-    const uintptr_t high_addr = ((uintptr_t) 1U) << DEFAULT_MAX_ADDRESS_BIT;\n-    void* const result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n-    if (result_addr != MAP_FAILED) {\n-      max_address_bit = BitsPerSize_t - count_leading_zeros((size_t) result_addr) - 1;\n-      munmap(result_addr, page_size);\n-    }\n-  }\n-  log_info_p(gc, init)(\"Probing address space for the highest valid bit: %zu\", max_address_bit);\n-  return MAX2(max_address_bit, MINIMUM_MAX_ADDRESS_BIT);\n-#else \/\/ LINUX\n-  return DEFAULT_MAX_ADDRESS_BIT;\n-#endif \/\/ LINUX\n-}\n-\n-size_t ZPlatformAddressOffsetBits() {\n-  static const  size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n-  const size_t min_address_offset_bits = max_address_offset_bits - 2;\n-  const size_t address_offset = ZGlobalsPointers::min_address_offset_request();\n-  const size_t address_offset_bits = log2i_exact(address_offset);\n-  return clamp(address_offset_bits, min_address_offset_bits, max_address_offset_bits);\n-}\n-\n-size_t ZPlatformAddressHeapBaseShift() {\n-  return ZPlatformAddressOffsetBits();\n-}\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zAddress_riscv.cpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-size_t ZPlatformAddressOffsetBits();\n-size_t ZPlatformAddressHeapBaseShift();\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zAddress_riscv.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n@@ -26,3 +25,0 @@\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -32,16 +28,0 @@\n-size_t ZPlatformAddressOffsetBits() {\n-#ifdef ADDRESS_SANITIZER\n-  return 44;\n-#else\n-  const size_t min_address_offset_bits = 42; \/\/ 4TB\n-  const size_t max_address_offset_bits = 44; \/\/ 16TB\n-  const size_t address_offset = ZGlobalsPointers::min_address_offset_request();\n-  const size_t address_offset_bits = log2i_exact(address_offset);\n-  return clamp(address_offset_bits, min_address_offset_bits, max_address_offset_bits);\n-#endif\n-}\n-\n-size_t ZPlatformAddressHeapBaseShift() {\n-  return ZPlatformAddressOffsetBits();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zAddress_x86.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-size_t ZPlatformAddressOffsetBits();\n-size_t ZPlatformAddressHeapBaseShift();\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zAddress_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"gc\/z\/zAddress.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#ifdef __APPLE__\n+#include <mach\/vm_param.h>\n+#endif\n+\n+#if defined (__APPLE__) && defined(MACH_VM_MAX_ADDRESS)\n+\/\/ Use the system define if available\n+#define Z_PLATFORM_MAX_HEAP_ADDRESS ((size_t)(MACH_VM_MAX_ADDRESS))\n+#else\n+\/\/ Try using up to 46 bits for the address\n+#define Z_PLATFORM_MAX_HEAP_ADDRESS (size_t(1) << 45)\n+#endif\n+\n+size_t ZPlatformHeapBaseMaxShift() {\n+  return clamp((size_t)log2i(Z_PLATFORM_MAX_HEAP_ADDRESS), ZAddressHeapBaseMinShift,ZAddressHeapBaseMaxShift);\n+}\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zAddress_bsd.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef OS_BSD_GC_Z_ZADDRESS_BSD_HPP\n+#define OS_BSD_GC_Z_ZADDRESS_BSD_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t ZPlatformHeapBaseMaxShift();\n+\n+#endif \/\/ OS_BSD_GC_Z_ZADDRESS_BSD_HPP\n","filename":"src\/hotspot\/os\/bsd\/gc\/z\/zAddress_bsd.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/z\/zAddress.hpp\"\n+#include \"gc\/z\/zErrno.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#include <sys\/mman.h>\n+\n+\/\/ Maximum value where probing starts\n+static constexpr size_t MAXIMUM_MAX_HEAP_BASE_SHIFT = MIN2(ZAddressHeapBaseMaxShift, size_t(47));\n+\/\/ Minimum value returned, if probing fail\n+static constexpr size_t MINIMUM_MAX_HEAP_BASE_SHIFT = ZAddressHeapBaseMinShift;\n+\n+static size_t probe_heap_base_max_shift() {\n+  const size_t page_size = os::vm_page_size();\n+  size_t max_heap_base_shift = 0;\n+\n+  for (size_t i = MAXIMUM_MAX_HEAP_BASE_SHIFT; i > MINIMUM_MAX_HEAP_BASE_SHIFT; --i) {\n+    const uintptr_t base_addr = ((uintptr_t) 1U) << i;\n+    if (msync((void*)base_addr, page_size, MS_ASYNC) == 0) {\n+      \/\/ msync succeeded, the address is valid, and maybe even already mapped.\n+      max_heap_base_shift = i;\n+      break;\n+    }\n+\n+    if (errno != ENOMEM) {\n+      ZErrno err;\n+      \/\/ Some error occurred. This should never happen, but msync\n+      \/\/ has some undefined behavior, hence ignore this shift.\n+      DEBUG_ONLY(fatal(\"Received '%s' while probing the address space for the highest valid shift\", err.to_string());)\n+      log_warning_p(gc)(\"Received '%s' while probing the address space for the highest valid shift\", err.to_string());\n+      continue;\n+    }\n+\n+    \/\/ Since msync failed with ENOMEM, the page might not be mapped.\n+    \/\/ Try to map it, to see if the address is valid.\n+    void* const result_addr = mmap((void*) base_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+    if (result_addr != MAP_FAILED) {\n+      munmap(result_addr, page_size);\n+    }\n+\n+    if ((uintptr_t) result_addr == base_addr) {\n+      \/\/ Address is valid\n+      max_heap_base_shift = i;\n+      break;\n+    }\n+  }\n+\n+  if (max_heap_base_shift == 0) {\n+    \/\/ Probing failed, allocate a very high page and take that shift as the maximum\n+    const uintptr_t high_addr = ((uintptr_t) 1U) << MAXIMUM_MAX_HEAP_BASE_SHIFT;\n+    void* const result_addr = mmap((void*) high_addr, page_size, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);\n+\n+    if (result_addr != MAP_FAILED) {\n+      max_heap_base_shift = (size_t)log2i((uintptr_t)result_addr);\n+      munmap(result_addr, page_size);\n+    }\n+  }\n+\n+  log_debug_p(gc, init)(\"Probing address space for the highest valid shift: %zu\", max_heap_base_shift);\n+\n+  return MAX2(max_heap_base_shift, MINIMUM_MAX_HEAP_BASE_SHIFT);\n+}\n+\n+size_t ZPlatformHeapBaseMaxShift() {\n+  return probe_heap_base_max_shift();\n+}\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zAddress_linux.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef OS_LINUX_GC_Z_ZADDRESS_LINUX_HPP\n+#define OS_LINUX_GC_Z_ZADDRESS_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t ZPlatformHeapBaseMaxShift();\n+\n+#endif \/\/ OS_LINUX_GC_Z_ZADDRESS_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zAddress_linux.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"gc\/z\/zAddress.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t ZPlatformHeapBaseMaxShift() {\n+  \/\/ A 64-bit process on 64-bit Windows has a virtual address space within the\n+  \/\/ 128-terabyte range 0x000'00000000 through 0x7FFF'FFFFFFFF. So the heap base\n+  \/\/ can occupy the 47th bit, resulting in a shift of 46.\n+  return clamp(size_t(46), ZAddressHeapBaseMinShift, ZAddressHeapBaseMaxShift);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zAddress_windows.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef OS_WINDOWS_GC_Z_ZADDRESS_WINDOWS_HPP\n+#define OS_WINDOWS_GC_Z_ZADDRESS_WINDOWS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+size_t ZPlatformHeapBaseMaxShift();\n+\n+#endif \/\/ OS_WINDOWS_GC_Z_ZADDRESS_WINDOWS_HPP\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zAddress_windows.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"logging\/log.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,0 +37,1 @@\n+uintptr_t  ZAddressHeapBase;\n@@ -34,1 +39,2 @@\n-size_t     ZAddressHeapBase;\n+\n+size_t     ZAddressPlatformMaxAddressSpace;\n@@ -105,2 +111,14 @@\n-void ZGlobalsPointers::initialize() {\n-  ZAddressOffsetBits = ZPlatformAddressOffsetBits();\n+void ZGlobalsPointers::set_heap_base(size_t heap_base_shift) {\n+  assert(heap_base_shift <= ZAddressHeapBaseMaxShift, \"Heap base shift to large\");\n+  assert(heap_base_shift <= ZAddressPlatformHeapBaseMaxShift, \"Heap base shift to large\");\n+  assert(heap_base_shift >= ZAddressHeapBaseMinShift, \"Heap base shift to small\");\n+  assert(heap_base_shift >= ZAddressMaxHeapRequiredHeapBaseShift, \"Heap base shift to small\");\n+\n+  \/\/ Setup the heap base\n+  ZAddressHeapBaseShift = heap_base_shift;\n+  ZAddressHeapBase = (uintptr_t)1 << ZAddressHeapBaseShift;\n+\n+  log_trace(gc, init)(\"Set Heap Base: \" PTR_FORMAT, ZAddressHeapBase);\n+\n+  \/\/ Setup the offset\n+  ZAddressOffsetBits = ZAddressHeapBaseShift;\n@@ -109,0 +127,14 @@\n+}\n+\n+size_t ZGlobalsPointers::ZAddressPlatformHeapBaseMaxShift;\n+size_t ZGlobalsPointers::ZAddressMaxHeapRequiredHeapBaseShift;\n+size_t ZGlobalsPointers::ZAddressMaxHeapRecommendedHeapBaseShift;\n+size_t ZGlobalsPointers::ZAddressInitialHeapBaseShift;\n+\n+void ZGlobalsPointers::initialize() {\n+  ZAddressPlatformHeapBaseMaxShift = ZPlatformHeapBaseMaxShift();\n+  ZAddressPlatformMaxAddressSpace = size_t(1) << ZAddressPlatformHeapBaseMaxShift;\n+  const size_t max_supported_heap = MIN2(ZAddressMaxCapacityLimit, ZAddressPlatformMaxAddressSpace);\n+\n+  guarantee(ZAddressPlatformHeapBaseMaxShift <= ZAddressHeapBaseMaxShift, \"Platform max shift must not be more than allowed max shift\");\n+  guarantee(ZAddressPlatformHeapBaseMaxShift >= ZAddressHeapBaseMinShift, \"Platform max shift must not be less than allowed min shift\");\n@@ -111,1 +143,1 @@\n-  if (MaxHeapSize > ZAddressOffsetMax) {\n+  if (MaxHeapSize > max_supported_heap) {\n@@ -114,1 +146,1 @@\n-                ZAddressOffsetMax \/ G));\n+                max_supported_heap \/ G));\n@@ -117,2 +149,8 @@\n-  ZAddressHeapBaseShift = ZPlatformAddressHeapBaseShift();\n-  ZAddressHeapBase = (uintptr_t)1 << ZAddressHeapBaseShift;\n+  \/\/ Set inital heap base\n+  ZAddressMaxHeapRequiredHeapBaseShift = (size_t)log2i_ceil(MaxHeapSize);\n+  const size_t desired_heap_base_shift = ZAddressMaxHeapRequiredHeapBaseShift + (size_t)log2i_exact(ZVirtualToPhysicalRatio);\n+  ZAddressMaxHeapRecommendedHeapBaseShift = MIN2(desired_heap_base_shift, ZAddressPlatformHeapBaseMaxShift);\n+  ZAddressInitialHeapBaseShift = ZForceHighestHeapBase\n+      ? ZAddressPlatformHeapBaseMaxShift\n+      : MAX2(MIN2(ZAddressHeapBaseRecommendInitalMinShift, ZAddressPlatformHeapBaseMaxShift), ZAddressMaxHeapRecommendedHeapBaseShift);\n+  set_heap_base(ZAddressInitialHeapBaseShift);\n@@ -132,0 +170,14 @@\n+bool ZGlobalsPointers::set_next_heap_base() {\n+  const size_t min_heap_base_shift = MAX2(ZAddressMaxHeapRequiredHeapBaseShift, ZAddressHeapBaseMinShift);\n+\n+  const size_t next_heap_base_shift = ZAddressHeapBaseShift == min_heap_base_shift\n+      ? ZAddressPlatformHeapBaseMaxShift\n+      : ZAddressHeapBaseShift - 1;\n+\n+  \/\/ Set next heap base\n+  set_heap_base(next_heap_base_shift);\n+\n+  \/\/ Signal if we have reached the inital heap base\n+  return next_heap_base_shift != ZAddressInitialHeapBaseShift;\n+}\n+\n@@ -153,7 +205,0 @@\n-\n-size_t ZGlobalsPointers::min_address_offset_request() {\n-  \/\/ See ZVirtualMemoryReserver for logic around setting up the heap for NUMA\n-  const size_t desired_for_heap = MaxHeapSize * ZVirtualToPhysicalRatio;\n-  const size_t desired_for_numa_multiplier = ZNUMA::count() > 1 ? 2 : 1;\n-  return round_up_power_of_2(desired_for_heap * desired_for_numa_multiplier);\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.cpp","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include OS_HEADER(gc\/z\/zAddress)\n@@ -33,2 +34,14 @@\n-extern uintptr_t  ZAddressHeapBase;\n-extern uintptr_t  ZAddressHeapBaseShift;\n+extern uintptr_t ZAddressHeapBase;\n+extern size_t    ZAddressHeapBaseShift;\n+\n+\/\/ The min and max shift allowed for the heap base. The max is\n+\/\/ the limit that our ZForwardingEntry encoding can handle.\n+\/\/ The recommended initial min shift is the largest shift which\n+\/\/ allows the smallest ZMarkPartialArrayMinSize.\n+const size_t     ZAddressHeapBaseMaxShift = 44; \/\/ 16TB\n+const size_t     ZAddressHeapBaseRecommendInitalMinShift = 42; \/\/ 4TB\n+const size_t     ZAddressHeapBaseMinShift = 34; \/\/ 16GB\n+\n+\/\/ Max size limits for MaxHeapSize and the platforms available address space.\n+const size_t     ZAddressMaxCapacityLimit = size_t(1) << 44; \/\/ 16TB\n+extern size_t    ZAddressPlatformMaxAddressSpace;\n@@ -315,0 +328,5 @@\n+  static size_t ZAddressPlatformHeapBaseMaxShift;\n+  static size_t ZAddressMaxHeapRequiredHeapBaseShift;\n+  static size_t ZAddressMaxHeapRecommendedHeapBaseShift;\n+  static size_t ZAddressInitialHeapBaseShift;\n+\n@@ -317,0 +335,1 @@\n+  static void set_heap_base(size_t heap_base_shift);\n@@ -320,0 +339,1 @@\n+  static bool set_next_heap_base();\n@@ -325,2 +345,0 @@\n-\n-  static size_t min_address_offset_request();\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"runtime\/globals.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -36,1 +35,1 @@\n-  return align_up(limit, ZGranuleSize);\n+  return MIN2(align_up(limit, ZGranuleSize), ZAddressPlatformMaxAddressSpace);\n","filename":"src\/hotspot\/share\/gc\/z\/zAddressSpaceLimit.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <cstdint>\n@@ -40,0 +43,3 @@\n+  : ZVirtualMemoryReserver(size, size) {}\n+\n+ZVirtualMemoryReserver::ZVirtualMemoryReserver(size_t required_size, size_t desired_size)\n@@ -41,1 +47,1 @@\n-    _reserved(reserve(size)) {}\n+    _reserved(reserve(required_size, desired_size)) {}\n@@ -65,1 +71,2 @@\n-void ZVirtualMemoryReserver::unreserve_all() {\n+size_t ZVirtualMemoryReserver::unreserve_all() {\n+  size_t unreserved = 0;\n@@ -68,0 +75,1 @@\n+    unreserved += vmem.size();\n@@ -69,0 +77,1 @@\n+  return unreserved;\n@@ -204,1 +213,3 @@\n-size_t ZVirtualMemoryReserver::reserve(size_t size) {\n+size_t ZVirtualMemoryReserver::reserve(size_t required_size, size_t desired_size) {\n+  assert(required_size <= desired_size, \"0x%zx <= 0x%zx\", required_size, desired_size);\n+\n@@ -209,1 +220,1 @@\n-\n+  const auto do_reserve = [&](size_t size) {\n@@ -211,3 +222,3 @@\n-  if (ZForceDiscontiguousHeapReservations > 0) {\n-    return force_reserve_discontiguous(size);\n-  }\n+    if (ZForceDiscontiguousHeapReservations > 0) {\n+      return force_reserve_discontiguous(size);\n+    }\n@@ -216,3 +227,29 @@\n-  \/\/ Prefer a contiguous address space\n-  if (reserve_contiguous(size)) {\n-    return size;\n+    \/\/ Prefer a contiguous address space\n+    if (reserve_contiguous(size)) {\n+      return size;\n+    }\n+\n+    \/\/ Fall back to a discontiguous address space\n+    return reserve_discontiguous(size);\n+  };\n+\n+  size_t reserved = 0;\n+  const auto unreserve_all = [&]() {\n+    this->unreserve_all();\n+    reserved = 0;\n+    return true;\n+  };\n+\n+  \/\/ First attempt to get the desired size\n+  do {\n+    if (ZAddressHeapBase >= desired_size) {\n+      \/\/ Only attempt to reserve if the current heap base can accommodate the desired size\n+      reserved = do_reserve(desired_size);\n+    }\n+  } while (reserved < desired_size && unreserve_all() && ZGlobalsPointers::set_next_heap_base());\n+\n+  assert(reserved <= desired_size, \"Should not reserve more than desired\");\n+\n+  if (reserved == desired_size) {\n+    \/\/ The desired size reservation was successful\n+    return reserved;\n@@ -221,2 +258,9 @@\n-  \/\/ Fall back to a discontiguous address space\n-  return reserve_discontiguous(size);\n+  \/\/ Second attempt to get at least the required size\n+  do {\n+    assert(ZAddressHeapBase >= required_size, \"Should not have attempted this heap base: \"\n+          PTR_FORMAT \" >= \" PTR_FORMAT, ZAddressHeapBase, (intptr_t)required_size);\n+    size_t to_reserve = MIN2<size_t>(ZAddressHeapBase, desired_size);\n+    reserved = do_reserve(to_reserve);\n+  } while (reserved < required_size && unreserve_all() && ZGlobalsPointers::set_next_heap_base());\n+\n+  return reserved;\n@@ -231,2 +275,0 @@\n-  assert(max_capacity <= ZAddressOffsetMax, \"Too large max_capacity\");\n-\n@@ -235,1 +277,7 @@\n-  const size_t limit = MIN2(ZAddressOffsetMax, ZAddressSpaceLimit::heap());\n+  const size_t limit = ZAddressSpaceLimit::heap();\n+\n+  if (max_capacity > limit) {\n+    \/\/ Cannot fit the heap within the limit\n+    ZInitialize::error_d(\"Java heap exceeds address space limits (\" EXACTFMT \")\", EXACTFMTARGS(limit));\n+    return;\n+  }\n@@ -244,0 +292,1 @@\n+  const size_t required = max_capacity;\n@@ -246,1 +295,1 @@\n-  ZVirtualMemoryReserver reserver(requested);\n+  ZVirtualMemoryReserver reserver(required, requested);\n@@ -251,2 +300,2 @@\n-  log_debug_p(gc, init)(\"Reserved Space: limit \" EXACTFMT \", desired \" EXACTFMT \", requested \" EXACTFMT,\n-                        EXACTFMTARGS(limit), EXACTFMTARGS(desired), EXACTFMTARGS(requested));\n+  log_debug_p(gc, init)(\"Reserved Space: limit \" EXACTFMT \", required \" EXACTFMT \", desired \" EXACTFMT \", requested \" EXACTFMT,\n+                        EXACTFMTARGS(limit), EXACTFMTARGS(required), EXACTFMTARGS(desired), EXACTFMTARGS(requested));\n@@ -265,1 +314,2 @@\n-  initialize_partitions(&reserver, size_for_partitions);\n+  const zoffset_end max_offset = initialize_partitions(&reserver, size_for_partitions);\n+  size_t unreserved = 0;\n@@ -274,1 +324,4 @@\n-    reserver.unreserve_all();\n+    unreserved = reserver.unreserve_all();\n+\n+    \/\/ Set ZAddressOffsetMax to the highest address end used by initialize_partitions\n+    ZAddressOffsetMax = untype(max_offset);\n@@ -279,0 +332,3 @@\n+  const double heap_ratio = static_cast<double>(reserved) \/ static_cast<double>(max_capacity);\n+  const uintptr_t lowest_offset = untype(lowest_available_address(0));\n+\n@@ -283,1 +339,3 @@\n-  log_info_p(gc, init)(\"Reserved Space Size: \" EXACTFMT, EXACTFMTARGS(reserved));\n+  log_info_p(gc, init)(\"Reserved Space Size: \" EXACTFMT \" (x%.2f Heap Ratio)\", EXACTFMTARGS(reserved - unreserved), heap_ratio);\n+  log_debug_p(gc, init)(\"Reserved Space Span: \" RANGE2EXACTFMT, ZAddressHeapBase + lowest_offset, ZAddressHeapBase + ZAddressOffsetMax,\n+                        EXACTFMTARGS(ZAddressOffsetMax - lowest_offset));\n@@ -289,1 +347,1 @@\n-void ZVirtualMemoryManager::initialize_partitions(ZVirtualMemoryReserver* reserver, size_t size_for_partitions) {\n+zoffset_end ZVirtualMemoryManager::initialize_partitions(ZVirtualMemoryReserver* reserver, size_t size_for_partitions) {\n@@ -299,0 +357,1 @@\n+  zoffset_end max_zoffset_end;\n@@ -311,0 +370,3 @@\n+\n+    \/\/ Keep track of the largest offset used for the partitions\n+    max_zoffset_end = registry->peak_high_address_end();\n@@ -312,0 +374,2 @@\n+\n+  return max_zoffset_end;\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemoryManager.cpp","additions":86,"deletions":22,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  size_t reserve(size_t size);\n+  size_t reserve(size_t required_size, size_t desired_size);\n@@ -63,0 +63,1 @@\n+  ZVirtualMemoryReserver(size_t required_size, size_t desired_size);\n@@ -66,1 +67,1 @@\n-  void unreserve_all();\n+  size_t unreserve_all();\n@@ -89,1 +90,1 @@\n-  void initialize_partitions(ZVirtualMemoryReserver* reserver, size_t size_for_partitions);\n+  zoffset_end initialize_partitions(ZVirtualMemoryReserver* reserver, size_t size_for_partitions);\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemoryManager.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+  develop(bool, ZForceHighestHeapBase, false,                               \\\n+          \"Forces the heap base to occupied the highest supported bit\")     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -394,0 +394,4 @@\n+\/\/ Printing a range (with exact size format), with start and end given\n+#define RANGE2EXACTFMT             \"[\" PTR_FORMAT \" - \" PTR_FORMAT \"), (\" EXACTFMT \")\"\n+#define RANGE2EXACTFMTARGS(p1, p2) p2i(p1), p2i(p2), EXACTFMTARGS(p2u(p2) - p2u(p2))\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test id=BlockUpper\n+ * @summary Tests linux virtual address space and ZGC heap reservation interactions\n+ * @library \/test\/lib\n+ * @requires vm.flagless & vm.gc.Z & os.family == \"linux\"\n+ * @run driver gc.z.TestLinuxVirtualAddressSpace ScenarioBlockUpper\n+ *\/\n+\n+\/*\n+ * @test id=BlockLower\n+ * @summary Tests linux virtual address space and ZGC heap reservation interactions\n+ * @library \/test\/lib\n+ * @requires vm.flagless & vm.gc.Z & os.family == \"linux\"\n+ * @run driver gc.z.TestLinuxVirtualAddressSpace ScenarioBlockLower\n+ *\/\n+\n+\/*\n+ * @test id=ScenarioBlockPreferred\n+ * @summary Tests linux virtual address space and ZGC heap reservation interactions\n+ * @library \/test\/lib\n+ * @requires vm.flagless & vm.gc.Z & os.family == \"linux\"\n+ * @run driver gc.z.TestLinuxVirtualAddressSpace ScenarioBlockPreferred\n+ *\/\n+\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import jtreg.SkippedException;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+public class TestLinuxVirtualAddressSpace {\n+    private static record Range (long start, long end) {\n+        List<String> asArgs() {\n+            if (start >= end) { throw new RuntimeException(\"Bad Range\"); }\n+            return List.of(\"\" + start, \"\" + end);\n+        }\n+    }\n+\n+    private static final long K = 1024;\n+    private static final long M = 1024 * K;\n+    private static final long G = 1024 * M;\n+    private static final long T = 1024 * G;\n+\n+    private static final int SIGKILL = 127;\n+\n+    private static String toXmxFlag(long xmx) {\n+        if (xmx % T == 0) { return \"-Xmx\" + (xmx \/ T) + \"T\"; }\n+        if (xmx % G == 0) { return \"-Xmx\" + (xmx \/ G) + \"G\"; }\n+        if (xmx % M == 0) { return \"-Xmx\" + (xmx \/ M) + \"M\"; }\n+        if (xmx % K == 0) { return \"-Xmx\" + (xmx \/ K) + \"K\"; }\n+        return \"-Xmx\" + xmx;\n+    }\n+\n+    private static abstract class ScenarioBase {\n+        List<Range> ranges;\n+        Optional<Long> xmx;\n+\n+        ScenarioBase(List<Range> ranges) {\n+            this.ranges = ranges;\n+            this.xmx = Optional.empty();\n+        }\n+\n+        ScenarioBase(List<Range> ranges, long xmx) {\n+            this.ranges = ranges;\n+            this.xmx = Optional.of(xmx);\n+        }\n+\n+        private String[] args() {\n+            return Stream.concat(\n+                xmx.stream().map(TestLinuxVirtualAddressSpace::toXmxFlag),\n+                ranges.stream().map(Range::asArgs).flatMap(Collection::stream)\n+            ).toArray(String[]::new);\n+        }\n+\n+        public void run() throws Exception {\n+            var pb = ProcessTools.createNativeTestProcessBuilder(\"gc_z_TestLinuxVirtualAddressSpace\", args());\n+            var oa = new OutputAnalyzer(pb.start());\n+\n+            \/\/ Check for SkippedException conditions\n+            if (oa.getExitValue() == SIGKILL) {\n+                \/\/ OS killed the test process\n+                throw new SkippedException(\"Received a SIGKILL\");\n+            }\n+\n+            if (oa.stdoutContains(\"MAP_FIXED_NOREPLACE unsupported\")) {\n+                \/\/ Old linux kernel\n+                throw new SkippedException(\"MAP_FIXED_NOREPLACE unsupported\");\n+            }\n+\n+            if (oa.stdoutContains(\"ENOMEM restriction encountered\")) {\n+                \/\/ Hit some resource limit\n+                throw new SkippedException(\"ENOMEM restriction encountered\");\n+            }\n+\n+            oa.shouldHaveExitValue(0);\n+\n+            oa.reportDiagnosticSummary();\n+\n+            analyze(oa);\n+        }\n+\n+        void error(String errorMessage) {\n+            throw new RuntimeException(errorMessage);\n+        }\n+\n+        Range parseReservedSpaceSpan(OutputAnalyzer oa) {\n+            String stdout = oa.getStdout();\n+            var pattern = Pattern.compile(\"Reserved Space Span: \\\\[(0x\\\\w+) - (0x\\\\w+)\\\\)\");\n+            var matcher = pattern.matcher(stdout);\n+            if (!matcher.find()) {\n+                error(\"Reserved Space Span string missing from output\");\n+            }\n+            return new Range(Long.decode(matcher.group(1)), Long.decode(matcher.group(2)));\n+        }\n+\n+        abstract void analyze(OutputAnalyzer oa);\n+    }\n+\n+    public static class ScenarioBlockUpper extends ScenarioBase {\n+        static final long top = 1L << 48;\n+        static final long bottom = 1L << 40;\n+\n+        public ScenarioBlockUpper() {\n+            super(List.of(new Range(bottom, top)));\n+        }\n+\n+        void analyze(OutputAnalyzer oa) {\n+            var range = parseReservedSpaceSpan(oa);\n+            if (range.end >= bottom) {\n+                error(\"Reserved Space Span above reserved range.\");\n+            }\n+        }\n+    }\n+\n+    public static class ScenarioBlockLower extends ScenarioBase {\n+        static final long top = 1L << 42;\n+        static final long bottom = 1L << 34;\n+\n+        public ScenarioBlockLower() {\n+            super(List.of(new Range(bottom, top)));\n+        }\n+\n+        void analyze(OutputAnalyzer oa) {\n+            var range = parseReservedSpaceSpan(oa);\n+            if (range.start < top) {\n+                error(\"Reserved Space Span below reserved range.\");\n+            }\n+        }\n+    }\n+\n+    public static class ScenarioBlockPreferred extends ScenarioBase {\n+        static final long xmx = 1L << 40; \/\/ 1 TB\n+        static final long top = 1L << 48;\n+        static final long bottom = 1L << 42;\n+\n+        public ScenarioBlockPreferred() {\n+            super(List.of(new Range(bottom, top)), xmx);\n+        }\n+\n+        void analyze(OutputAnalyzer oa) {\n+            var range = parseReservedSpaceSpan(oa);\n+            if (range.end >= bottom) {\n+                error(\"Reserved Space Span above reserved range.\");\n+            }\n+            oa.shouldMatch(\"Reserved Space Type: \\\\w+\/\\\\w+\/Degraded\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        var scenarioClass = Class.forName(TestLinuxVirtualAddressSpace.class.getCanonicalName() + \"$\" + args[0]);\n+        var scenario = (ScenarioBase)scenarioClass.getConstructor().newInstance();\n+        scenario.run();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestLinuxVirtualAddressSpace.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <jni.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/mman.h>\n+\n+#ifndef MAP_FIXED_NOREPLACE\n+#define MAP_FIXED_NOREPLACE 0x100000\n+#endif\n+\n+#define RESERVE_ALIGNMENT (2 * 1024 * 1024)\n+\n+#define ASSERT_JNI_OK(value)                                                   \\\n+do {                                                                           \\\n+  jint res = (value);                                                          \\\n+  if (res != JNI_OK) {                                                         \\\n+    fprintf(stderr, \"Test Error: \" #value \" failed: %d\\n\", res);               \\\n+    exit(1);                                                                   \\\n+  }                                                                            \\\n+} while (0)\n+#define ASSERT_NOT_NULL(value)                                                 \\\n+do {                                                                           \\\n+  if ((value) == NULL) {                                                       \\\n+    fprintf(stderr, \"Test Error: \" #value \" is NULL\\n\");                       \\\n+    exit(1);                                                                   \\\n+  }                                                                            \\\n+} while (0)\n+#define ASSERT_TRUE(value)                                                     \\\n+do {                                                                           \\\n+  if (!(value)) {                                                              \\\n+    fprintf(stderr, \"Test Error: \" #value \" not TRUE\\n\");                      \\\n+    exit(1);                                                                   \\\n+  }                                                                            \\\n+} while (0)\n+#define ASSERT_ALIGNED(value, alignment)                                       \\\n+do {                                                                           \\\n+  if ((value) % (alignment) != 0) {                                            \\\n+    fprintf(stderr, \"Test Error: \" #value \"[0x%zx] \"                           \\\n+                    \"not aligned to \" #alignment \"[0x%zx]\\n\",                  \\\n+                    (size_t)(value), (size_t)(alignment));                     \\\n+    exit(1);                                                                   \\\n+  }                                                                            \\\n+} while (0)\n+#define ASSERT_POWEROF2(value)                                                 \\\n+do {                                                                           \\\n+  if (((value) & ((value) - 1)) != 0) {                                        \\\n+    fprintf(stderr, \"Test Error: \" #value \"[0x%zx] is not a power of two\\n\",   \\\n+                    (size_t)(value));                                          \\\n+    exit(1);                                                                   \\\n+  }                                                                            \\\n+} while (0)\n+\n+#define OPTION(option) { (char*)option, NULL }\n+#define ARRAY_SIZE(a) sizeof(a)\/sizeof(a[0])\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+JNIEnv* create_vm(JavaVM **jvm, const char* xmx) {\n+  JNIEnv* env;\n+  JavaVMInitArgs args;\n+  JavaVMOption options[] = {\n+    OPTION(\"-XX:+UseZGC\"),\n+    OPTION(\"-Xlog:gc\"),\n+    OPTION(\"-Xlog:gc+init=trace\"),\n+    OPTION(\"-Xms32m\"),\n+    OPTION(xmx),\n+  };\n+  args.version = JNI_VERSION_1_8;\n+  args.nOptions = ARRAY_SIZE(options);\n+  args.options = options;\n+  args.ignoreUnrecognized = 0;\n+\n+  printf(\"Creating VM\\n\");\n+  fflush(stdout);\n+  ASSERT_JNI_OK(JNI_CreateJavaVM(jvm, (void**)&env, &args));\n+\n+  return env;\n+}\n+\n+\/\/ Simulates java --version\n+void run_jvm(const char* xmx) {\n+  \/\/ Create the vm\n+  JavaVM* jvm;\n+  jclass T_class;\n+  jmethodID test_method;\n+  JNIEnv* env = create_vm(&jvm, xmx);\n+  ASSERT_NOT_NULL(env);\n+\n+  \/\/ Simulate java --version via upcall to java.lang.VersionProps.print(false);\n+\n+  printf(\"Loader lookup\\n\");\n+  fflush(stdout);\n+  \/\/ Find the boot class loader\n+  typedef jclass (JNICALL FindClassFromBootLoader_t(JNIEnv *env, const char *name));\n+  FindClassFromBootLoader_t* find_class_from_boot_loader = (FindClassFromBootLoader_t*)dlsym(RTLD_DEFAULT, \"JVM_FindClassFromBootLoader\");\n+  ASSERT_NOT_NULL(find_class_from_boot_loader);\n+\n+  printf(\"Class lookup\\n\");\n+  fflush(stdout);\n+  \/\/ Lookup the java.lang.VersionProps class\n+  jclass ver = find_class_from_boot_loader(env, \"java\/lang\/VersionProps\");\n+  ASSERT_NOT_NULL(ver);\n+\n+  printf(\"Method lookup\\n\");\n+  fflush(stdout);\n+  \/\/ Lookup the java.lang.VersionProps.print(boolean) method\n+  jmethodID print = (*env)->GetStaticMethodID(env, ver, \"print\", \"(Z)V\");\n+  ASSERT_NOT_NULL(print);\n+\n+  printf(\"Method call\\n\");\n+  fflush(stdout);\n+  \/\/ Call java.lang.VersionProps.print(false);\n+  (*env)->CallStaticVoidMethod(env, ver, print, JNI_FALSE);\n+\n+  printf(\"Destroy VM\\n\");\n+  fflush(stdout);\n+  \/\/ Destroy the VM\n+  ASSERT_JNI_OK((*jvm)->DestroyJavaVM(jvm));\n+}\n+\n+uintptr_t str_to_uintptr_t(const char* str) {\n+  char* _;\n+  errno = 0;\n+  uintptr_t ret = strtoumax(str, &_, 10);\n+  if (errno) {\n+    perror(\"Failed to parse uintptr_t\");\n+    exit(1);\n+  }\n+  return ret;\n+}\n+\n+int try_reservation(void* addr, size_t len) {\n+  fflush(stdout);\n+  errno = 0;\n+\n+  \/\/ We reserve with MAP_FIXED_NOREPLACE in case we run on a kernel where the\n+  \/\/ address hint is not even attempted if it is next to a pre-existsing mapping.\n+  const int flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_NORESERVE | MAP_FIXED_NOREPLACE;\n+  void* const res = mmap(addr, len, PROT_NONE, flags, -1, 0);\n+\n+  if (res == MAP_FAILED) {\n+    return FALSE;\n+  }\n+\n+  if (res != addr) {\n+    \/\/ We did not get our fixed address, MAP_FIXED_NOREPLACE was ignored\n+    printf(\"MAP_FIXED_NOREPLACE unsupported\\n\");\n+    exit(0);\n+  }\n+\n+   return TRUE;\n+}\n+\n+size_t align_down(size_t value, size_t alignment) {\n+  ASSERT_POWEROF2(alignment);\n+\n+  const size_t alignment_mask = alignment - 1;\n+  const size_t aligned_value = value & ~alignment_mask;\n+\n+  ASSERT_ALIGNED(aligned_value, alignment);\n+  return aligned_value;\n+}\n+\n+size_t align_up(size_t value, size_t alignment) {\n+  return align_down(value + alignment - 1, alignment);\n+}\n+\n+void reserve_address_space_range(uintptr_t start, uintptr_t end) {\n+  ASSERT_TRUE(start < end);\n+\n+  const size_t min_len = RESERVE_ALIGNMENT;\n+\n+  ASSERT_ALIGNED(start, RESERVE_ALIGNMENT);\n+  ASSERT_ALIGNED(end, RESERVE_ALIGNMENT);\n+\n+  void* const addr = (void*)start;\n+  const size_t len = end - start;\n+\n+  if (try_reservation(addr, len)) {\n+    \/\/ Success\n+    printf(\"Reserved range [0x%zx - 0x%zx]\\n\", start, end);\n+  } else if (errno == EEXIST || errno == EINVAL) {\n+    \/\/ We check for alignment and size, assume EINVAL is either a strange\n+    \/\/ os page size or a too extreme address, treat it as if part of the range\n+    \/\/ is unmappable\n+    if (len > min_len) {\n+      \/\/ Divide and conquer\n+      const size_t half_len = align_up(len \/ 2, RESERVE_ALIGNMENT);\n+      const uintptr_t middle = start + half_len;\n+      if (middle != end) {\n+        reserve_address_space_range(start, middle);\n+        reserve_address_space_range(middle, end);\n+      }\n+    }\n+  } else if (errno == ENOMEM) {\n+    printf(\"ENOMEM restriction encountered\\n\");\n+    exit(0);\n+  } else {\n+    perror(\"Unexpected try_reservation error\");\n+    exit(1);\n+  }\n+}\n+\n+void reserve_address_space(int argc, const char** argv) {\n+  \/\/ We need to be careful to not reserve to close to the thread stack, as the\n+  \/\/ JVM will page fault in the stack space. If we have reserved that space as\n+  \/\/ prot none the kernel will not expand the stack but rather send a SIGSEGV.\n+  const size_t stack_headroom = 2 * RESERVE_ALIGNMENT;\n+  uintptr_t stack_top;\n+  stack_top = align_up((uintptr_t)&stack_top, RESERVE_ALIGNMENT);\n+  const uintptr_t stack_bottom = stack_top - stack_headroom;\n+\n+  for (int i = 2; i < argc; i += 2) {\n+    printf(\"Got range [%s - %s]\\n\", argv[i-1], argv[i]);\n+\n+    const uintptr_t start = str_to_uintptr_t(argv[i-1]);\n+    const uintptr_t end = str_to_uintptr_t(argv[i]);\n+\n+    ASSERT_TRUE(start < end);\n+\n+    if (start >= stack_top || end <= stack_bottom) {\n+      \/\/ No interference with thread stack\n+      reserve_address_space_range(start, end);\n+      continue;\n+    }\n+\n+    printf(\"Interference with stack [0x%zx - 0x%zx]\\n\", stack_bottom, stack_top);\n+\n+    if (start < stack_bottom) {\n+      \/\/ Reservation range below the stack\n+      reserve_address_space_range(start, stack_bottom);\n+    }\n+\n+    if (end > stack_top) {\n+      \/\/ Reservation range above the stack\n+      reserve_address_space_range(stack_top, end);\n+    }\n+  }\n+}\n+\n+int main(int argc, const char** argv) {\n+  printf(\"Started\\n\");\n+\n+  \/\/ Parse potential -Xmx option\n+  const char* xmx = \"-Xmx128m\";\n+  if (argc > 1 && strncmp(argv[1], \"-Xmx\", 4) == 0) {\n+    xmx = argv[1];\n+    argc--;\n+    argv++;\n+  }\n+  printf(\"Size flag: %s\\n\", xmx);\n+\n+  \/\/ Pre-reserve address space\n+  printf(\"Reserving\\n\");\n+  reserve_address_space(argc, argv);\n+\n+  \/\/ Invoke a new JVM\n+  printf(\"Running\\n\");\n+  fflush(stdout);\n+  run_jvm(xmx);\n+\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/exegc_z_TestLinuxVirtualAddressSpace.c","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"}]}