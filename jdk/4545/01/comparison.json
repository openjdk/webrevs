{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=17\n+DEFAULT_VERSION_FEATURE=18\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2021-09-14\n-DEFAULT_VERSION_CLASSFILE_MAJOR=61  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-03-15\n+DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=17\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"16 17 18\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n","filename":"make\/conf\/version-numbers.conf","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/CharArrayReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/Console\n+method name charset descriptor ()Ljava\/nio\/charset\/Charset; flags 1\n+\n+class name java\/io\/FileInputStream\n+method name readAllBytes descriptor ()[B thrownTypes java\/io\/IOException flags 1\n+method name readNBytes descriptor (I)[B thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/InputStreamReader\n+method name read descriptor (Ljava\/nio\/CharBuffer;)I thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/ObjectInputFilter\n+method name allowFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name rejectFilter descriptor (Ljava\/util\/function\/Predicate;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter; flags 9 signature (Ljava\/util\/function\/Predicate<Ljava\/lang\/Class<*>;>;Ljava\/io\/ObjectInputFilter$Status;)Ljava\/io\/ObjectInputFilter;\n+method name merge descriptor (Ljava\/io\/ObjectInputFilter;Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+method name rejectUndecidedClass descriptor (Ljava\/io\/ObjectInputFilter;)Ljava\/io\/ObjectInputFilter; flags 9\n+\n+class name java\/io\/ObjectInputFilter$Config\n+method name getSerialFilterFactory descriptor ()Ljava\/util\/function\/BinaryOperator; flags 9 signature ()Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;\n+method name setSerialFilterFactory descriptor (Ljava\/util\/function\/BinaryOperator;)V flags 9 signature (Ljava\/util\/function\/BinaryOperator<Ljava\/io\/ObjectInputFilter;>;)V\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/io\/WriteAbortedException\n+-field name detail descriptor Ljava\/lang\/Exception;\n+field name detail descriptor Ljava\/lang\/Exception; flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Class\n+-method name isSealed descriptor ()Z\n+-method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class;\n+method name getPermittedSubclasses descriptor ()[Ljava\/lang\/Class; flags 1 signature ()[Ljava\/lang\/Class<*>; runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isSealed descriptor ()Z flags 1\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Process\n+method name inputReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name inputReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor ()Ljava\/io\/BufferedReader; flags 11\n+method name errorReader descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedReader; flags 11\n+method name outputWriter descriptor ()Ljava\/io\/BufferedWriter; flags 11\n+method name outputWriter descriptor (Ljava\/nio\/charset\/Charset;)Ljava\/io\/BufferedWriter; flags 11\n+\n+class name java\/lang\/SecurityManager\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Opens outerClass java\/lang\/module\/ModuleDescriptor innerClassName Opens flags 19\n+innerclass innerClass java\/lang\/module\/ModuleDescriptor$Exports outerClass java\/lang\/module\/ModuleDescriptor innerClassName Exports flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V\n+method name checkMulticast descriptor (Ljava\/net\/InetAddress;B)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.4\")\n+\n+class name java\/lang\/StrictMath\n+-method name toRadians descriptor (D)D\n+-method name toDegrees descriptor (D)D\n+method name toRadians descriptor (D)D flags 9\n+method name toDegrees descriptor (D)D flags 9\n+\n+class name java\/lang\/SuppressWarnings\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;MODULE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)\n+\n+class name java\/lang\/System\n+-method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V\n+-method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager;\n+method name setSecurityManager descriptor (Ljava\/lang\/SecurityManager;)V flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name getSecurityManager descriptor ()Ljava\/lang\/SecurityManager; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/Thread\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/ThreadGroup\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/DynamicConstantDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+innerclass innerClass java\/lang\/Enum$EnumDesc outerClass java\/lang\/Enum innerClassName EnumDesc flags 19\n+innerclass innerClass java\/lang\/invoke\/VarHandle$VarHandleDesc outerClass java\/lang\/invoke\/VarHandle innerClassName VarHandleDesc flags 19\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandles\n+method name tableSwitch descriptor (Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/invoke\/MethodHandle; flags 89\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name <init> descriptor ()V\n+method name <init> descriptor ()V flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/runtime\/SwitchBootstraps\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;)\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name typeSwitch descriptor (Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite; thrownTypes java\/lang\/Throwable flags 89\n+\n+class name java\/net\/DatagramSocket\n+-method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V\n+method name setDatagramSocketImplFactory descriptor (Ljava\/net\/DatagramSocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name joinGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+method name leaveGroup descriptor (Ljava\/net\/SocketAddress;Ljava\/net\/NetworkInterface;)V thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/net\/ServerSocket\n+-method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/Socket\n+-method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V\n+method name setSocketImplFactory descriptor (Ljava\/net\/SocketImplFactory;)V thrownTypes java\/io\/IOException flags 29 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name java\/net\/URLDecoder\n+-method name <init> descriptor ()V\n+\n+class name java\/net\/URLStreamHandler\n+-method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress;\n+method name getHostAddress descriptor (Ljava\/net\/URL;)Ljava\/net\/InetAddress; flags 4\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/MappedByteBuffer\n+method name slice descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name slice descriptor (II)Ljava\/nio\/MappedByteBuffer; flags 401\n+method name duplicate descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/MappedByteBuffer; flags 401\n+method name compact descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/ByteBuffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/ByteBuffer; flags 1041\n+method name duplicate descriptor ()Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor (II)Ljava\/nio\/Buffer; flags 1041\n+method name slice descriptor ()Ljava\/nio\/Buffer; flags 1041\n+\n+class name java\/security\/AccessControlContext\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessControlException\n+header extends java\/lang\/SecurityException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/AccessController\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/DomainCombiner\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Policy\n+header extends java\/lang\/Object nestMembers java\/security\/Policy$Parameters flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/Policy$Parameters\n+header extends java\/lang\/Object nestHost java\/security\/Policy flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+innerclass innerClass java\/security\/Policy$Parameters outerClass java\/security\/Policy innerClassName Parameters flags 609\n+\n+class name java\/security\/PolicySpi\n+header extends java\/lang\/Object flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/security\/SecureRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SecureRandom\",isStochastic=Ztrue)\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+-method name toString descriptor ()Ljava\/lang\/String;\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/Clock\n+header extends java\/lang\/Object implements java\/time\/InstantSource flags 421\n+\n+class name java\/time\/InstantSource\n+header extends java\/lang\/Object flags 601\n+method name system descriptor ()Ljava\/time\/InstantSource; flags 9\n+method name tick descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name fixed descriptor (Ljava\/time\/Instant;)Ljava\/time\/InstantSource; flags 9\n+method name offset descriptor (Ljava\/time\/InstantSource;Ljava\/time\/Duration;)Ljava\/time\/InstantSource; flags 9\n+method name instant descriptor ()Ljava\/time\/Instant; flags 401\n+method name millis descriptor ()J flags 1\n+method name withZone descriptor (Ljava\/time\/ZoneId;)Ljava\/time\/Clock; flags 1\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/HashSet\n+header extends java\/util\/AbstractSet implements java\/util\/Set,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/Set<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/HexFormat\n+header extends java\/lang\/Object flags 31\n+method name of descriptor ()Ljava\/util\/HexFormat; flags 9\n+method name ofDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 9\n+method name withDelimiter descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withPrefix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withSuffix descriptor (Ljava\/lang\/String;)Ljava\/util\/HexFormat; flags 1\n+method name withUpperCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name withLowerCase descriptor ()Ljava\/util\/HexFormat; flags 1\n+method name delimiter descriptor ()Ljava\/lang\/String; flags 1\n+method name prefix descriptor ()Ljava\/lang\/String; flags 1\n+method name suffix descriptor ()Ljava\/lang\/String; flags 1\n+method name isUpperCase descriptor ()Z flags 1\n+method name formatHex descriptor ([B)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor ([BII)Ljava\/lang\/String; flags 1\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[B)TA;\n+method name formatHex descriptor (Ljava\/lang\/Appendable;[BII)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;[BII)TA;\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;)[B flags 1\n+method name parseHex descriptor (Ljava\/lang\/CharSequence;II)[B flags 1\n+method name parseHex descriptor ([CII)[B flags 1\n+method name toLowHexDigit descriptor (I)C flags 1\n+method name toHighHexDigit descriptor (I)C flags 1\n+method name toHexDigits descriptor (Ljava\/lang\/Appendable;B)Ljava\/lang\/Appendable; flags 1 signature <A::Ljava\/lang\/Appendable;>(TA;B)TA;\n+method name toHexDigits descriptor (B)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (C)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (S)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (I)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (J)Ljava\/lang\/String; flags 1\n+method name toHexDigits descriptor (JI)Ljava\/lang\/String; flags 1\n+method name isHexDigit descriptor (I)Z flags 9\n+method name fromHexDigit descriptor (I)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;)I flags 9\n+method name fromHexDigits descriptor (Ljava\/lang\/CharSequence;II)I flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;)J flags 9\n+method name fromHexDigitsToLong descriptor (Ljava\/lang\/CharSequence;II)J flags 9\n+method name equals descriptor (Ljava\/lang\/Object;)Z flags 1\n+method name hashCode descriptor ()I flags 1\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Map$Entry\n+method name copyOf descriptor (Ljava\/util\/Map$Entry;)Ljava\/util\/Map$Entry; flags 9 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>(Ljava\/util\/Map$Entry<+TK;+TV;>;)Ljava\/util\/Map$Entry<TK;TV;>;\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Random\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator,java\/io\/Serializable flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"Random\",i=I48,j=I0,k=I0,equidistribution=I0)\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/util\/SplittableRandom\n+header extends jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator flags 31 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"SplittableRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass jdk\/internal\/util\/random\/RandomSupport$AbstractSplittableGenerator outerClass jdk\/internal\/util\/random\/RandomSupport innerClassName AbstractSplittableGenerator flags 409\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+-method name nextInt descriptor (I)I\n+-method name nextInt descriptor (II)I\n+-method name nextLong descriptor (J)J\n+-method name nextLong descriptor (JJ)J\n+-method name nextDouble descriptor ()D\n+-method name nextDouble descriptor (D)D\n+-method name nextDouble descriptor (DD)D\n+-method name nextBoolean descriptor ()Z\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/SplittableRandom; flags 1\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 1 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 1041\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/Timer\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/ref\/Cleaner$Cleanable outerClass java\/lang\/ref\/Cleaner innerClassName Cleanable flags 609\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/Executors\n+-method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory;\n+-method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+-method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable;\n+method name privilegedThreadFactory descriptor ()Ljava\/util\/concurrent\/ThreadFactory; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallable descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name privilegedCallableUsingCurrentClassLoader descriptor (Ljava\/util\/concurrent\/Callable;)Ljava\/util\/concurrent\/Callable; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljava\/util\/concurrent\/Callable<TT;>;)Ljava\/util\/concurrent\/Callable<TT;>; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/concurrent\/ForkJoinPool\n+header extends java\/util\/concurrent\/AbstractExecutorService nestMembers java\/util\/concurrent\/ForkJoinPool$ManagedBlocker,java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory flags 21\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ForkJoinWorkerThreadFactory outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ForkJoinWorkerThreadFactory flags 609\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name invokeAll descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List; thrownTypes java\/lang\/InterruptedException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/util\/List<Ljava\/util\/concurrent\/Future<TT;>;>;\n+method name invokeAny descriptor (Ljava\/util\/Collection;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;)TT;\n+method name invokeAny descriptor (Ljava\/util\/Collection;JLjava\/util\/concurrent\/TimeUnit;)Ljava\/lang\/Object; thrownTypes java\/lang\/InterruptedException,java\/util\/concurrent\/ExecutionException,java\/util\/concurrent\/TimeoutException flags 1 signature <T:Ljava\/lang\/Object;>(Ljava\/util\/Collection<+Ljava\/util\/concurrent\/Callable<TT;>;>;JLjava\/util\/concurrent\/TimeUnit;)TT;\n+\n+class name java\/util\/concurrent\/ForkJoinWorkerThread\n+header extends java\/lang\/Thread flags 21\n+innerclass innerClass java\/lang\/Thread$UncaughtExceptionHandler outerClass java\/lang\/Thread innerClassName UncaughtExceptionHandler flags 609\n+\n+class name java\/util\/concurrent\/LinkedTransferQueue\n+header extends java\/util\/AbstractQueue implements java\/util\/concurrent\/TransferQueue,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractQueue<TE;>;Ljava\/util\/concurrent\/TransferQueue<TE;>;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/concurrent\/ForkJoinPool$ManagedBlocker outerClass java\/util\/concurrent\/ForkJoinPool innerClassName ManagedBlocker flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ThreadLocalRandom\n+header extends java\/util\/Random flags 21 runtimeAnnotations @Ljdk\/internal\/util\/random\/RandomSupport$RandomGeneratorProperties;(name=\"ThreadLocalRandom\",i=I64,j=I0,k=I0,equidistribution=I1)\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+-method name nextGaussian descriptor ()D\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/random\/RandomGenerator\n+header extends java\/lang\/Object nestMembers java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator,java\/util\/random\/RandomGenerator$LeapableGenerator,java\/util\/random\/RandomGenerator$JumpableGenerator,java\/util\/random\/RandomGenerator$SplittableGenerator,java\/util\/random\/RandomGenerator$StreamableGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator; flags 9\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGenerator; flags 9\n+method name isDeprecated descriptor ()Z flags 1\n+method name doubles descriptor ()Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (DD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (J)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name doubles descriptor (JDD)Ljava\/util\/stream\/DoubleStream; flags 1\n+method name ints descriptor ()Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (II)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (J)Ljava\/util\/stream\/IntStream; flags 1\n+method name ints descriptor (JII)Ljava\/util\/stream\/IntStream; flags 1\n+method name longs descriptor ()Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (J)Ljava\/util\/stream\/LongStream; flags 1\n+method name longs descriptor (JJJ)Ljava\/util\/stream\/LongStream; flags 1\n+method name nextBoolean descriptor ()Z flags 1\n+method name nextBytes descriptor ([B)V flags 1\n+method name nextFloat descriptor ()F flags 1\n+method name nextFloat descriptor (F)F flags 1\n+method name nextFloat descriptor (FF)F flags 1\n+method name nextDouble descriptor ()D flags 1\n+method name nextDouble descriptor (D)D flags 1\n+method name nextDouble descriptor (DD)D flags 1\n+method name nextInt descriptor ()I flags 1\n+method name nextInt descriptor (I)I flags 1\n+method name nextInt descriptor (II)I flags 1\n+method name nextLong descriptor ()J flags 401\n+method name nextLong descriptor (J)J flags 1\n+method name nextLong descriptor (JJ)J flags 1\n+method name nextGaussian descriptor ()D flags 1\n+method name nextGaussian descriptor (DD)D flags 1\n+method name nextExponential descriptor ()D flags 1\n+\n+class name java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$LeapableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 401\n+method name jumpPowerOfTwo descriptor (I)V flags 401\n+method name jump descriptor (D)V flags 401\n+method name jump descriptor ()V flags 1\n+method name jumps descriptor (D)Ljava\/util\/stream\/Stream; flags 1 signature (D)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name jumps descriptor (JD)Ljava\/util\/stream\/Stream; flags 1 signature (JD)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator;>;\n+method name leap descriptor ()V flags 1\n+method name copyAndJump descriptor (D)Ljava\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 1041\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$JumpableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 401\n+method name jump descriptor ()V flags 401\n+method name jumpDistance descriptor ()D flags 401\n+method name jumps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name jumps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name copyAndJump descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1\n+\n+class name java\/util\/random\/RandomGenerator$LeapableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$JumpableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 9\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$LeapableGenerator; flags 401\n+method name leap descriptor ()V flags 401\n+method name leapDistance descriptor ()D flags 401\n+method name leaps descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name leaps descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$JumpableGenerator;>;\n+method name copyAndLeap descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1\n+method name copy descriptor ()Ljava\/util\/random\/RandomGenerator$JumpableGenerator; flags 1041\n+\n+class name java\/util\/random\/RandomGenerator$SplittableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator$StreamableGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 9\n+method name split descriptor ()Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name split descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/random\/RandomGenerator$SplittableGenerator; flags 401\n+method name splits descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (J)Ljava\/util\/stream\/Stream; flags 401 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name splits descriptor (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream; flags 401 signature (JLjava\/util\/random\/RandomGenerator$SplittableGenerator;)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator$SplittableGenerator;>;\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 1 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGenerator$StreamableGenerator\n+header extends java\/lang\/Object implements java\/util\/random\/RandomGenerator nestHost java\/util\/random\/RandomGenerator flags 601\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGenerator$StreamableGenerator; flags 9\n+method name rngs descriptor ()Ljava\/util\/stream\/Stream; flags 401 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+method name rngs descriptor (J)Ljava\/util\/stream\/Stream; flags 1 signature (J)Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGenerator;>;\n+\n+class name java\/util\/random\/RandomGeneratorFactory\n+header extends java\/lang\/Object flags 31 signature <T::Ljava\/util\/random\/RandomGenerator;>Ljava\/lang\/Object;\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$ArbitrarilyJumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName ArbitrarilyJumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$JumpableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName JumpableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$LeapableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName LeapableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$SplittableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName SplittableGenerator flags 609\n+innerclass innerClass java\/util\/random\/RandomGenerator$StreamableGenerator outerClass java\/util\/random\/RandomGenerator innerClassName StreamableGenerator flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name of descriptor (Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature <T::Ljava\/util\/random\/RandomGenerator;>(Ljava\/lang\/String;)Ljava\/util\/random\/RandomGeneratorFactory<TT;>;\n+method name getDefault descriptor ()Ljava\/util\/random\/RandomGeneratorFactory; flags 9 signature ()Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;\n+method name all descriptor ()Ljava\/util\/stream\/Stream; flags 9 signature ()Ljava\/util\/stream\/Stream<Ljava\/util\/random\/RandomGeneratorFactory<Ljava\/util\/random\/RandomGenerator;>;>;\n+method name name descriptor ()Ljava\/lang\/String; flags 1\n+method name group descriptor ()Ljava\/lang\/String; flags 1\n+method name stateBits descriptor ()I flags 1\n+method name equidistribution descriptor ()I flags 1\n+method name period descriptor ()Ljava\/math\/BigInteger; flags 1\n+method name isStatistical descriptor ()Z flags 1\n+method name isStochastic descriptor ()Z flags 1\n+method name isHardware descriptor ()Z flags 1\n+method name isArbitrarilyJumpable descriptor ()Z flags 1\n+method name isJumpable descriptor ()Z flags 1\n+method name isLeapable descriptor ()Z flags 1\n+method name isSplittable descriptor ()Z flags 1\n+method name isStreamable descriptor ()Z flags 1\n+method name isDeprecated descriptor ()Z flags 1\n+method name create descriptor ()Ljava\/util\/random\/RandomGenerator; flags 1 signature ()TT;\n+method name create descriptor (J)Ljava\/util\/random\/RandomGenerator; flags 1 signature (J)TT;\n+method name create descriptor ([B)Ljava\/util\/random\/RandomGenerator; flags 1 signature ([B)TT;\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/SecretKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec,javax\/crypto\/SecretKey flags 21\n+\n+class name javax\/security\/auth\/Subject\n+-method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+-method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object;\n+method name getSubject descriptor (Ljava\/security\/AccessControlContext;)Ljavax\/security\/auth\/Subject; flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+method name doAsPrivileged descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;Ljava\/security\/AccessControlContext;)Ljava\/lang\/Object; thrownTypes java\/security\/PrivilegedActionException flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction<TT;>;Ljava\/security\/AccessControlContext;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name javax\/security\/auth\/SubjectDomainCombiner\n+header extends java\/lang\/Object implements java\/security\/DomainCombiner flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n","filename":"make\/data\/symbols\/java.base-H.sym.txt","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_17 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+-field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+-field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier;\n+field name SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+field name NON_SEALED descriptor Ljavax\/lang\/model\/element\/Modifier; flags 4019\n+\n+class name javax\/lang\/model\/element\/TypeElement\n+-method name getPermittedSubclasses descriptor ()Ljava\/util\/List;\n+method name getPermittedSubclasses descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Ljavax\/lang\/model\/type\/TypeMirror;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name isAutomaticModule descriptor (Ljavax\/lang\/model\/element\/ModuleElement;)Z flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_17;)\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.compiler-H.sym.txt","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/datatransfer\/Clipboard\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/datatransfer\/DataFlavor\n+header extends java\/lang\/Object implements java\/io\/Externalizable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+-field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor;\n+field name selectionHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name fragmentHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+field name allHtmlFlavor descriptor Ljava\/awt\/datatransfer\/DataFlavor; flags 19\n+\n","filename":"make\/data\/symbols\/java.datatransfer-H.sym.txt","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,902 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/applet\/Applet\n+header extends java\/awt\/Panel nestMembers java\/applet\/Applet$AccessibleApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+innerclass innerClass java\/applet\/Applet$AccessibleApplet outerClass java\/applet\/Applet innerClassName AccessibleApplet flags 4\n+\n+class name java\/applet\/AppletContext\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AppletStub\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/applet\/AudioClip\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/GridBagLayoutInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/AppletInitializer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object;\n+method name instantiate descriptor (Ljava\/lang\/ClassLoader;Ljava\/lang\/String;Ljava\/beans\/beancontext\/BeanContext;Ljava\/beans\/AppletInitializer;)Ljava\/lang\/Object; thrownTypes java\/io\/IOException,java\/lang\/ClassNotFoundException flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JApplet\n+header extends java\/applet\/Applet implements javax\/accessibility\/Accessible,javax\/swing\/RootPaneContainer,javax\/swing\/TransferHandler$HasGetTransferHandler nestMembers javax\/swing\/JApplet$AccessibleJApplet flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")@Ljava\/beans\/JavaBean;(defaultProperty=\"JMenuBar\",description=\"Swing's\\u005C;u0020;Applet\\u005C;u0020;subclass.\")@Ljavax\/swing\/SwingContainer;(delegate=\"getContentPane\")\n+innerclass innerClass javax\/swing\/JApplet$AccessibleJApplet outerClass javax\/swing\/JApplet innerClassName AccessibleJApplet flags 4\n+innerclass innerClass javax\/swing\/TransferHandler$HasGetTransferHandler outerClass javax\/swing\/TransferHandler innerClassName HasGetTransferHandler flags 608\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JSlider$AccessibleJSlider\n+header extends javax\/swing\/JComponent$AccessibleJComponent implements javax\/accessibility\/AccessibleValue,javax\/swing\/event\/ChangeListener,javax\/accessibility\/AccessibleAction nestHost javax\/swing\/JSlider flags 21\n+innerclass innerClass javax\/swing\/JSlider$AccessibleJSlider outerClass javax\/swing\/JSlider innerClassName AccessibleJSlider flags 4\n+innerclass innerClass javax\/swing\/JComponent$AccessibleJComponent outerClass javax\/swing\/JComponent innerClassName AccessibleJComponent flags 401\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+method name getAccessibleActionCount descriptor ()I flags 1\n+method name getAccessibleActionDescription descriptor (I)Ljava\/lang\/String; flags 1\n+method name doAccessibleAction descriptor (I)Z flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/RepaintManager\n+-method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V\n+method name addDirtyRegion descriptor (Ljava\/applet\/Applet;IIII)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileSystemView\n+method name getSystemIcon descriptor (Ljava\/io\/File;II)Ljavax\/swing\/Icon; flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicDirectoryModel\n+-method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V\n+-method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z\n+method name intervalAdded descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name intervalRemoved descriptor (Ljavax\/swing\/event\/ListDataEvent;)V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+method name lt descriptor (Ljava\/io\/File;Ljava\/io\/File;)Z flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/MouseInputListener nestHost javax\/swing\/plaf\/basic\/BasicMenuItemUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI$MouseInputHandler outerClass javax\/swing\/plaf\/basic\/BasicMenuItemUI innerClassName MouseInputHandler flags 4\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$HSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName HSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler\n+header extends java\/lang\/Object implements java\/beans\/PropertyChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$PropertyChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName PropertyChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$VSBChangeListener outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName VSBChangeListener flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler\n+header extends java\/lang\/Object implements javax\/swing\/event\/ChangeListener nestHost javax\/swing\/plaf\/basic\/BasicScrollPaneUI flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI$ViewportChangeHandler outerClass javax\/swing\/plaf\/basic\/BasicScrollPaneUI innerClassName ViewportChangeHandler flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarUI\n+-method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame;\n+method name createFloatingFrame descriptor (Ljavax\/swing\/JToolBar;)Ljavax\/swing\/JFrame; flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"17\")\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ListView\n+header extends javax\/swing\/text\/html\/BlockView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$ListPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName ListPainter flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/MinimalHTMLWriter\n+header extends javax\/swing\/text\/AbstractWriter flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 9\n+innerclass innerClass javax\/swing\/text\/AbstractDocument$BranchElement outerClass javax\/swing\/text\/AbstractDocument innerClassName BranchElement flags 1\n+innerclass innerClass javax\/swing\/text\/StyleContext$NamedStyle outerClass javax\/swing\/text\/StyleContext innerClassName NamedStyle flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ParagraphView\n+header extends javax\/swing\/text\/ParagraphView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$BoxPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName BoxPainter flags 9\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.desktop-H.sym.txt","additions":902,"deletions":0,"binary":false,"changes":902,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/instrument\/UnmodifiableModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/java.instrument-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/util\/logging\/ErrorManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/LogManager\n+-method name checkAccess descriptor ()V\n+method name checkAccess descriptor ()V thrownTypes java\/lang\/SecurityException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"17\")\n+\n+class name java\/util\/logging\/LoggingMXBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/logging\/LoggingPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/MemoryHandler\n+header extends java\/util\/logging\/Handler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SimpleFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SocketHandler\n+header extends java\/util\/logging\/StreamHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/XMLFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.logging-H.sym.txt","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management-H.sym.txt","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/management\/remote\/rmi\/RMIConnectorServer\n+header extends javax\/management\/remote\/JMXConnectorServer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/rmi\/RMIIIOPServerImpl\n+header extends javax\/management\/remote\/rmi\/RMIServerImpl flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name javax\/management\/remote\/rmi\/RMIServerImpl\n+header extends java\/lang\/Object implements java\/io\/Closeable,javax\/management\/remote\/rmi\/RMIServer flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management.rmi-H.sym.txt","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Context\n+-field name APPLET descriptor Ljava\/lang\/String;\n+field name APPLET descriptor Ljava\/lang\/String; constantValue java.naming.applet flags 19 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.naming-H.sym.txt","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.rmi\n+header exports java\/rmi,java\/rmi\/dgc,java\/rmi\/registry,java\/rmi\/server,javax\/rmi\/ssl requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;java.logging\\u0020;flags\\u0020;0 uses java\/rmi\/server\/RMIClassLoaderSpi target linux-amd64 flags 8000\n+\n+class name java\/rmi\/RMISecurityManager\n+header extends java\/lang\/SecurityManager flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.8\")\n+\n+class name java\/rmi\/RemoteException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name java\/rmi\/activation\/Activatable\n+\n+-class name java\/rmi\/activation\/ActivateFailedException\n+\n+-class name java\/rmi\/activation\/ActivationDesc\n+\n+-class name java\/rmi\/activation\/ActivationException\n+\n+-class name java\/rmi\/activation\/ActivationGroup\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc\n+\n+-class name java\/rmi\/activation\/ActivationGroupDesc$CommandEnvironment\n+\n+-class name java\/rmi\/activation\/ActivationGroupID\n+\n+-class name java\/rmi\/activation\/ActivationGroup_Stub\n+\n+-class name java\/rmi\/activation\/ActivationID\n+\n+-class name java\/rmi\/activation\/ActivationInstantiator\n+\n+-class name java\/rmi\/activation\/ActivationMonitor\n+\n+-class name java\/rmi\/activation\/ActivationSystem\n+\n+-class name java\/rmi\/activation\/Activator\n+\n+-class name java\/rmi\/activation\/UnknownGroupException\n+\n+-class name java\/rmi\/activation\/UnknownObjectException\n+\n+class name java\/rmi\/dgc\/VMID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ObjID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/RemoteObject\n+header extends java\/lang\/Object implements java\/rmi\/Remote,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ServerCloneException\n+header extends java\/lang\/CloneNotSupportedException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/UID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.rmi-H.sym.txt","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/script\/ScriptException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.scripting-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/auth\/kerberos\/DelegationPermission\n+header extends java\/security\/BasicPermission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/EncryptionKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosCredMessage\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable flags 31\n+innerclass innerClass java\/util\/Base64$Encoder outerClass java\/util\/Base64 innerClassName Encoder flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KerberosTicket\n+header extends java\/lang\/Object implements javax\/security\/auth\/Destroyable,javax\/security\/auth\/Refreshable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/KeyTab\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/security\/auth\/kerberos\/ServicePermission\n+header extends java\/security\/Permission implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/GSSException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/ietf\/jgss\/Oid\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.jgss-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/security\/sasl\/SaslException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.security.sasl-H.sym.txt","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/smartcardio\/ATR\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/Card\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardChannel\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CardException\n+header extends java\/lang\/Exception flags 21\n+\n+class name javax\/smartcardio\/CardNotPresentException\n+header extends javax\/smartcardio\/CardException flags 21\n+\n+class name javax\/smartcardio\/CardPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/CardTerminal\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/smartcardio\/CommandAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/ResponseAPDU\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/smartcardio\/TerminalFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/java.smartcardio-H.sym.txt","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/sql\/BatchUpdateException\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name java\/sql\/ConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/JDBCType\n+header extends java\/lang\/Enum implements java\/sql\/SQLType flags 4031 signature Ljava\/lang\/Enum<Ljava\/sql\/JDBCType;>;Ljava\/sql\/SQLType;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/SQLWarning\n+header extends java\/sql\/SQLException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/sql\/ShardingKey\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/ShardingKeyBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/sql\/Statement\n+header extends java\/lang\/Object implements java\/sql\/Wrapper,java\/lang\/AutoCloseable flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/PooledConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/sql\/XAConnectionBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/java.sql-H.sym.txt","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/sql\/rowset\/BaseRowSet\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialArray\n+header extends java\/lang\/Object implements java\/sql\/Array,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialBlob\n+header extends java\/lang\/Object implements java\/sql\/Blob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialClob\n+header extends java\/lang\/Object implements java\/sql\/Clob,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialDatalink\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialJavaObject\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/sql\/rowset\/serial\/SerialRef\n+header extends java\/lang\/Object implements java\/sql\/Ref,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sql\/rowset\/serial\/SerialStruct\n+header extends java\/lang\/Object implements java\/sql\/Struct,java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.sql.rowset-H.sym.txt","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/catalog\/Catalog\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/xml\/catalog\/CatalogException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name javax\/xml\/catalog\/CatalogManager\n+header extends java\/lang\/Object flags 31\n+\n+class name javax\/xml\/catalog\/CatalogResolver\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,javax\/xml\/stream\/XMLResolver,javax\/xml\/transform\/URIResolver,org\/w3c\/dom\/ls\/LSResourceResolver flags 601\n+\n+class name javax\/xml\/datatype\/DatatypeFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/datatype\/Duration\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/namespace\/QName\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilder\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilderFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParser\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParserFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/stream\/XMLEventReader\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Ljava\/lang\/Object;>;\n+\n+class name javax\/xml\/stream\/XMLInputFactory\n+-method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory;\n+method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory; thrownTypes javax\/xml\/stream\/FactoryConfigurationError flags 9\n+\n+class name javax\/xml\/stream\/XMLStreamException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/Transformer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/TransformerException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/validation\/SchemaFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPath\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/xml\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPathNodes\n+header extends java\/lang\/Object implements java\/lang\/Iterable flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/Iterable<Lorg\/w3c\/dom\/Node;>;\n+\n+class name org\/w3c\/dom\/ElementTraversal\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/xml\/sax\/AttributeList\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/DocumentHandler\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/HandlerBase\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/DocumentHandler,org\/xml\/sax\/ErrorHandler flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/Parser\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/ext\/Attributes2Impl\n+header extends org\/xml\/sax\/helpers\/AttributesImpl implements org\/xml\/sax\/ext\/Attributes2 flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/AttributeListImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/AttributeList flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/AttributesImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/Attributes flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/ParserFactory\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/XMLFilterImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/XMLFilter,org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/ContentHandler,org\/xml\/sax\/ErrorHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/XMLReaderFactory\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml-H.sym.txt","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/crypto\/NodeSetData\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/Data,java\/lang\/Iterable flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/xml\/crypto\/Data;Ljava\/lang\/Iterable<TT;>;\n+\n+class name javax\/xml\/crypto\/dom\/DOMCryptoContext\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/XMLCryptoContext flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/SignatureMethod\n+field name RSA_PSS descriptor Ljava\/lang\/String; constantValue http:\/\/www.w3.org\/2007\/05\/xmldsig-more#rsa-pss flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/XMLSignatureFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/spec\/RSAPSSParameterSpec\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/dsig\/spec\/SignatureMethodParameterSpec flags 31\n+method name <init> descriptor (Ljava\/security\/spec\/PSSParameterSpec;)V flags 1\n+method name getPSSParameterSpec descriptor ()Ljava\/security\/spec\/PSSParameterSpec; flags 1\n+\n","filename":"make\/data\/symbols\/java.xml.crypto-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/java\/accessibility\/util\/AccessibilityListenerList\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/java\/accessibility\/util\/EventID\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/java\/accessibility\/util\/GUIInitializedListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/TopLevelWindowListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/Translator\n+header extends javax\/accessibility\/AccessibleContext implements javax\/accessibility\/Accessible,javax\/accessibility\/AccessibleComponent flags 21\n+\n","filename":"make\/data\/symbols\/jdk.accessibility-H.sym.txt","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/attach\/AgentInitializationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AgentLoadException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachNotSupportedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachOperationFailedException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/tools\/attach\/AttachPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachine\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/VirtualMachineDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/tools\/attach\/spi\/AttachProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.attach-H.sym.txt","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CaseTree\n+method name getLabels descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/CaseLabelTree;>; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+-method name getPermitsClause descriptor ()Ljava\/util\/List;\n+method name getPermitsClause descriptor ()Ljava\/util\/List; flags 1 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/tree\/Tree;>;\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+method name getModule descriptor ()Lcom\/sun\/source\/tree\/ModuleTree; flags 1\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DefaultCaseLabelTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601 classAnnotations @Ljdk\/internal\/javac\/NoPreview;\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/GuardedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+method name getExpression descriptor ()Lcom\/sun\/source\/tree\/ExpressionTree; flags 401\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedPatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/PatternTree flags 601 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name getPattern descriptor ()Lcom\/sun\/source\/tree\/PatternTree; flags 401\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PatternTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree,com\/sun\/source\/tree\/CaseLabelTree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Tree$Kind\n+field name GUARDED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name PARENTHESIZED_PATTERN descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+field name DEFAULT_CASE_LABEL descriptor Lcom\/sun\/source\/tree\/Tree$Kind; flags 4019 classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 401 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/TreeScanner\n+method name visitDefaultCaseLabel descriptor (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/DefaultCaseLabelTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitParenthesizedPattern descriptor (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/ParenthesizedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+method name visitGuardedPattern descriptor (Lcom\/sun\/source\/tree\/GuardedPatternTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/tree\/GuardedPatternTree;TP;)TR; classAnnotations @Ljdk\/internal\/javac\/PreviewFeature;(feature=eLjdk\/internal\/javac\/PreviewFeature$Feature;SWITCH_PATTERN_MATCHING;,reflective=Ztrue)\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.compiler-H.sym.txt","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/dynalink\/CallSiteDescriptor\n+header extends jdk\/dynalink\/SecureLookupSupplier flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/DynamicLinker\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/StackWalker$StackFrame outerClass java\/lang\/StackWalker innerClassName StackFrame flags 609\n+innerclass innerClass java\/lang\/StackWalker$Option outerClass java\/lang\/StackWalker innerClassName Option flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NamedOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/Namespace\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/NamespaceOperation\n+header extends java\/lang\/Object implements jdk\/dynalink\/Operation flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/NoSuchDynamicMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/dynalink\/Operation\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/RelinkableCallSite\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/SecureLookupSupplier\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/StandardNamespace\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Namespace flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardNamespace;>;Ljdk\/dynalink\/Namespace;\n+\n+class name jdk\/dynalink\/StandardOperation\n+header extends java\/lang\/Enum implements jdk\/dynalink\/Operation flags 4031 signature Ljava\/lang\/Enum<Ljdk\/dynalink\/StandardOperation;>;Ljdk\/dynalink\/Operation;\n+\n+class name jdk\/dynalink\/beans\/MissingMemberHandlerFactory\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocation\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/GuardedInvocationTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinker\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/GuardingDynamicLinkerExporter\n+header extends java\/lang\/Object implements java\/util\/function\/Supplier flags 421 signature Ljava\/lang\/Object;Ljava\/util\/function\/Supplier<Ljava\/util\/List<Ljdk\/dynalink\/linker\/GuardingDynamicLinker;>;>;\n+\n+class name jdk\/dynalink\/linker\/GuardingTypeConverterFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/LinkRequest\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/dynalink\/linker\/LinkerServices\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/dynalink\/linker\/ConversionComparator$Comparison outerClass jdk\/dynalink\/linker\/ConversionComparator innerClassName Comparison flags 4019\n+\n+class name jdk\/dynalink\/linker\/MethodHandleTransformer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/MethodTypeConversionStrategy\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+\n+class name jdk\/dynalink\/linker\/TypeBasedGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 601\n+\n+class name jdk\/dynalink\/linker\/support\/CompositeGuardingDynamicLinker\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/GuardingDynamicLinker flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/DefaultInternalObjectFilter\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/MethodHandleTransformer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Guards\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/Lookup\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/linker\/support\/SimpleLinkRequest\n+header extends java\/lang\/Object implements jdk\/dynalink\/linker\/LinkRequest flags 21\n+\n+class name jdk\/dynalink\/linker\/support\/TypeUtilities\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name jdk\/dynalink\/support\/AbstractRelinkableCallSite\n+header extends java\/lang\/invoke\/MutableCallSite implements jdk\/dynalink\/RelinkableCallSite flags 421\n+\n+class name jdk\/dynalink\/support\/ChainedCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/dynalink\/support\/SimpleRelinkableCallSite\n+header extends jdk\/dynalink\/support\/AbstractRelinkableCallSite flags 21\n+\n","filename":"make\/data\/symbols\/jdk.dynalink-H.sym.txt","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/net\/httpserver\/Filter\n+method name beforeHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+method name afterHandler descriptor (Ljava\/lang\/String;Ljava\/util\/function\/Consumer;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/Consumer<Lcom\/sun\/net\/httpserver\/HttpExchange;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+\n+class name com\/sun\/net\/httpserver\/Headers\n+header extends java\/lang\/Object implements java\/util\/Map flags 21 signature Ljava\/lang\/Object;Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name com\/sun\/net\/httpserver\/HttpContext\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/net\/httpserver\/HttpPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/net\/httpserver\/HttpServer\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsConfigurator\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/net\/httpserver\/HttpsExchange\n+header extends com\/sun\/net\/httpserver\/HttpExchange flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsParameters\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsServer\n+header extends com\/sun\/net\/httpserver\/HttpServer flags 421\n+\n+class name com\/sun\/net\/httpserver\/spi\/HttpServerProvider\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.httpserver-H.sym.txt","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/foreign\/CLinker\n+header extends java\/lang\/Object nestMembers jdk\/incubator\/foreign\/CLinker$TypeKind,jdk\/incubator\/foreign\/CLinker$VaList,jdk\/incubator\/foreign\/CLinker$VaList$Builder sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$TypeKind outerClass jdk\/incubator\/foreign\/CLinker innerClassName TypeKind flags 4019\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String;\n+-method name toJavaStringRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String;\n+-method name allocateMemoryRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name freeMemoryRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V\n+method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljdk\/incubator\/foreign\/SegmentAllocator;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name downcallHandle descriptor (Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toCString descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljava\/nio\/charset\/Charset;)Ljava\/lang\/String; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name allocateMemory descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name freeMemory descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name systemLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name copy descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name ofAddressRestricted descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+-method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name vargAsSegment descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljdk\/incubator\/foreign\/CLinker$VaList$Builder;>;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/CLinker$VaList;\n+\n+class name jdk\/incubator\/foreign\/CLinker$VaList$Builder\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/CLinker sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList outerClass jdk\/incubator\/foreign\/CLinker innerClassName VaList flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/CLinker$VaList$Builder outerClass jdk\/incubator\/foreign\/CLinker$VaList innerClassName Builder flags 609\n+\n+class name jdk\/incubator\/foreign\/GroupLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup\n+\n+-class name jdk\/incubator\/foreign\/LibraryLookup$Symbol\n+\n+-class name jdk\/incubator\/foreign\/MappedMemorySegments\n+\n+class name jdk\/incubator\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+-method name asSegmentRestricted descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSegmentRestricted descriptor (JLjava\/lang\/Runnable;Ljava\/lang\/Object;)Ljdk\/incubator\/foreign\/MemorySegment;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name asSegment descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name asSegment descriptor (JLjava\/lang\/Runnable;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name isNative descriptor ()Z flags 401\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers jdk\/incubator\/foreign\/MemoryLayout$PathElement sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name ofPaddingBits descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name ofValueBits descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+-method name ofSequence descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofSequence descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name ofStruct descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+-method name ofUnion descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout;\n+method name sliceHandle descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/MethodHandle; flags 81\n+method name paddingLayout descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 9\n+method name valueLayout descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 9\n+method name sequenceLayout descriptor (JLjdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name sequenceLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/SequenceLayout; flags 9\n+method name structLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+method name unionLayout descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/GroupLayout; flags 89\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/MemoryLayout sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass java\/nio\/channels\/FileChannel$MapMode outerClass java\/nio\/channels\/FileChannel innerClassName MapMode flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name READ descriptor I\n+-field name WRITE descriptor I\n+-field name CLOSE descriptor I\n+-field name HANDOFF descriptor I\n+-field name ALL_ACCESS descriptor I\n+-field name SHARE descriptor I\n+-method name ownerThread descriptor ()Ljava\/lang\/Thread;\n+-method name isAlive descriptor ()Z\n+-method name close descriptor ()V\n+-method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateNative descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name withAccessModes descriptor (I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name hasAccessModes descriptor (I)Z\n+-method name accessModes descriptor ()I\n+-method name spliterator descriptor (Ljdk\/incubator\/foreign\/SequenceLayout;)Ljava\/util\/Spliterator;\n+-method name handoff descriptor (Ljava\/lang\/Thread;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name handoff descriptor (Ljdk\/incubator\/foreign\/NativeScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name share descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name registerCleaner descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name ofNativeRestricted descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name isReadOnly descriptor ()Z flags 401\n+method name spliterator descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/Spliterator<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name elements descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream; flags 401 signature (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljava\/util\/stream\/Stream<Ljdk\/incubator\/foreign\/MemorySegment;>;\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name isNative descriptor ()Z flags 401\n+method name isLoaded descriptor ()Z flags 401\n+method name load descriptor ()V flags 401\n+method name unload descriptor ()V flags 401\n+method name force descriptor ()V flags 401\n+method name allocateNative descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name allocateNative descriptor (JJLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9\n+method name mapFile descriptor (Ljava\/nio\/file\/Path;JJLjava\/nio\/channels\/FileChannel$MapMode;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; thrownTypes java\/io\/IOException flags 9\n+method name globalNativeSegment descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+-class name jdk\/incubator\/foreign\/NativeScope\n+\n+class name jdk\/incubator\/foreign\/ResourceScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable nestMembers jdk\/incubator\/foreign\/ResourceScope$Handle sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name isAlive descriptor ()Z flags 401\n+method name ownerThread descriptor ()Ljava\/lang\/Thread; flags 401\n+method name isImplicit descriptor ()Z flags 401\n+method name close descriptor ()V flags 401\n+method name addCloseAction descriptor (Ljava\/lang\/Runnable;)V flags 401\n+method name acquire descriptor ()Ljdk\/incubator\/foreign\/ResourceScope$Handle; flags 401\n+method name release descriptor (Ljdk\/incubator\/foreign\/ResourceScope$Handle;)V flags 401\n+method name newConfinedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newConfinedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newSharedScope descriptor (Ljava\/lang\/ref\/Cleaner;)Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name newImplicitScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+method name globalScope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 9\n+\n+class name jdk\/incubator\/foreign\/ResourceScope$Handle\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/ResourceScope sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ResourceScope$Handle outerClass jdk\/incubator\/foreign\/ResourceScope innerClassName Handle flags 609\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+\n+class name jdk\/incubator\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (JJ)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name arenaAllocator descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name arenaAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofSegment descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name ofScope descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+\n+class name jdk\/incubator\/foreign\/SequenceLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/incubator\/foreign\/SymbolLookup\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/MemoryAddress;>;\n+method name loaderLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n","filename":"make\/data\/symbols\/jdk.incubator.foreign-H.sym.txt","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/vector\/ByteVector\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[II)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromBooleanArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[ZI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Byte;>;[ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoBooleanArray descriptor ([ZI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([ZI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/ShortVector\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[II)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[II)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name fromCharArray descriptor (Ljdk\/incubator\/vector\/VectorSpecies;[CI[IILjdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 9 signature (Ljdk\/incubator\/vector\/VectorSpecies<Ljava\/lang\/Short;>;[CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[II)V flags 11 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name intoCharArray descriptor ([CI[IILjdk\/incubator\/vector\/VectorMask;)V flags 11 signature ([CI[IILjdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/vector\/VectorOperators\n+field name UNSIGNED_LT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_LE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GT descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+field name UNSIGNED_GE descriptor Ljdk\/incubator\/vector\/VectorOperators$Comparison; flags 19\n+\n","filename":"make\/data\/symbols\/jdk.incubator.vector-H.sym.txt","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/security\/jarsigner\/JarSignerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jartool-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/javadoc\/doclet\/Reporter\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+method name print descriptor (Ljavax\/tools\/Diagnostic$Kind;Ljavax\/tools\/FileObject;IIILjava\/lang\/String;)V flags 401\n+method name getStandardWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+method name getDiagnosticWriter descriptor ()Ljava\/io\/PrintWriter; flags 1\n+\n+class name jdk\/javadoc\/doclet\/StandardDoclet\n+header extends java\/lang\/Object implements jdk\/javadoc\/doclet\/Doclet flags 21\n+innerclass innerClass jdk\/javadoc\/doclet\/Doclet$Option outerClass jdk\/javadoc\/doclet\/Doclet innerClassName Option flags 609\n+method name getLocale descriptor ()Ljava\/util\/Locale; flags 1\n+method name getReporter descriptor ()Ljdk\/javadoc\/doclet\/Reporter; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.javadoc-H.sym.txt","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/tools\/jconsole\/JConsolePlugin\n+header extends java\/lang\/Object flags 421\n+\n","filename":"make\/data\/symbols\/jdk.jconsole-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/jdi\/AbsentInformationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/Accessible\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ArrayReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ArrayType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/BooleanType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/BooleanValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue flags 601\n+\n+class name com\/sun\/jdi\/Bootstrap\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/jdi\/ByteType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ByteValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ByteValue;>;\n+\n+class name com\/sun\/jdi\/CharType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/CharValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/CharValue;>;\n+\n+class name com\/sun\/jdi\/ClassLoaderReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassNotLoadedException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/ClassNotPreparedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ClassObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ClassType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/DoubleType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/DoubleValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/DoubleValue;>;\n+\n+class name com\/sun\/jdi\/Field\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Field;>;\n+\n+class name com\/sun\/jdi\/FloatType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/FloatValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/FloatValue;>;\n+\n+class name com\/sun\/jdi\/IncompatibleThreadStateException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InconsistentDebugInfoException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/IntegerType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/IntegerValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/IntegerValue;>;\n+\n+class name com\/sun\/jdi\/InterfaceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ReferenceType flags 601\n+\n+class name com\/sun\/jdi\/InternalException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidCodeIndexException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidLineNumberException\n+header extends java\/lang\/RuntimeException flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+\n+class name com\/sun\/jdi\/InvalidModuleException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidStackFrameException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/InvalidTypeException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/InvocationException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/JDIPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/jdi\/LocalVariable\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LocalVariable;>;\n+\n+class name com\/sun\/jdi\/Locatable\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/Location\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Location;>;\n+\n+class name com\/sun\/jdi\/LongType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/LongValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/LongValue;>;\n+\n+class name com\/sun\/jdi\/Method\n+header extends java\/lang\/Object implements com\/sun\/jdi\/TypeComponent,com\/sun\/jdi\/Locatable,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/TypeComponent;Lcom\/sun\/jdi\/Locatable;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/Method;>;\n+\n+class name com\/sun\/jdi\/Mirror\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/ModuleReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/MonitorInfo\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/NativeMethodException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectCollectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/ObjectReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/PathSearchingVirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/VirtualMachine flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/PrimitiveValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/ReferenceType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type,java\/lang\/Comparable,com\/sun\/jdi\/Accessible flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Type;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ReferenceType;>;Lcom\/sun\/jdi\/Accessible;\n+\n+class name com\/sun\/jdi\/ShortType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveType flags 601\n+\n+class name com\/sun\/jdi\/ShortValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/PrimitiveValue,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/PrimitiveValue;Ljava\/lang\/Comparable<Lcom\/sun\/jdi\/ShortValue;>;\n+\n+class name com\/sun\/jdi\/StackFrame\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/StringReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadGroupReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/ThreadReference\n+header extends java\/lang\/Object implements com\/sun\/jdi\/ObjectReference flags 601\n+\n+class name com\/sun\/jdi\/Type\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/TypeComponent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,com\/sun\/jdi\/Accessible flags 601\n+\n+class name com\/sun\/jdi\/VMCannotBeModifiedException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+\n+class name com\/sun\/jdi\/VMDisconnectedException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMMismatchException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/VMOutOfMemoryException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/Value\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachine\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/VirtualMachineManager\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/VoidType\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Type flags 601\n+\n+class name com\/sun\/jdi\/VoidValue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Value flags 601\n+\n+class name com\/sun\/jdi\/connect\/AttachingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/IllegalConnectorArgumentsException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/LaunchingConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/ListeningConnector\n+header extends java\/lang\/Object implements com\/sun\/jdi\/connect\/Connector flags 601\n+innerclass innerClass com\/sun\/jdi\/connect\/Connector$Argument outerClass com\/sun\/jdi\/connect\/Connector innerClassName Argument flags 609\n+\n+class name com\/sun\/jdi\/connect\/Transport\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/jdi\/connect\/TransportTimeoutException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/VMStartException\n+header extends java\/lang\/Exception flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/ClosedConnectionException\n+header extends java\/io\/IOException flags 21\n+\n+class name com\/sun\/jdi\/connect\/spi\/Connection\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/jdi\/event\/AccessWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/BreakpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassPrepareEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ClassUnloadEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/Event\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventIterator\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/EventQueue\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/event\/EventSet\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror,java\/util\/Set flags 601 signature Ljava\/lang\/Object;Lcom\/sun\/jdi\/Mirror;Ljava\/util\/Set<Lcom\/sun\/jdi\/event\/Event;>;\n+\n+class name com\/sun\/jdi\/event\/ExceptionEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/LocatableEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodEntryEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MethodExitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ModificationWatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/WatchpointEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnterEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorContendedEnteredEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/MonitorWaitedEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/StepEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/ThreadStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDeathEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMDisconnectEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/VMStartEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/Event flags 601\n+\n+class name com\/sun\/jdi\/event\/WatchpointEvent\n+header extends java\/lang\/Object implements com\/sun\/jdi\/event\/LocatableEvent flags 601\n+\n+class name com\/sun\/jdi\/request\/AccessWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/BreakpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest,com\/sun\/jdi\/Locatable flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassPrepareRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ClassUnloadRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/DuplicateRequestException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/EventRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/EventRequestManager\n+header extends java\/lang\/Object implements com\/sun\/jdi\/Mirror flags 601\n+\n+class name com\/sun\/jdi\/request\/ExceptionRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/InvalidRequestStateException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name com\/sun\/jdi\/request\/MethodEntryRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MethodExitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ModificationWatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/WatchpointRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnterRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorContendedEnteredRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/MonitorWaitedRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/StepRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/ThreadStartRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/VMDeathRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n+class name com\/sun\/jdi\/request\/WatchpointRequest\n+header extends java\/lang\/Object implements com\/sun\/jdi\/request\/EventRequest flags 601\n+\n","filename":"make\/data\/symbols\/jdk.jdi-H.sym.txt","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jfr\/consumer\/RecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/Snippet$SubKind\n+-field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind;\n+field name RECORD_SUBKIND descriptor Ljdk\/jshell\/Snippet$SubKind; flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+method name interactiveTerminal descriptor (Z)Ljdk\/jshell\/tool\/JavaShellToolBuilder; flags 1\n+\n","filename":"make\/data\/symbols\/jdk.jshell-H.sym.txt","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name netscape\/javascript\/JSException\n+header extends java\/lang\/RuntimeException flags 21\n+\n","filename":"make\/data\/symbols\/jdk.jsobject-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/management\/GarbageCollectionNotificationInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/GarbageCollectorMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/GarbageCollectorMXBean flags 601\n+\n+class name com\/sun\/management\/GcInfo\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,javax\/management\/openmbean\/CompositeDataView flags 21\n+\n+class name com\/sun\/management\/HotSpotDiagnosticMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+\n+class name com\/sun\/management\/OperatingSystemMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/OperatingSystemMXBean flags 601\n+\n+class name com\/sun\/management\/ThreadMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/ThreadMXBean flags 601\n+\n+class name com\/sun\/management\/UnixOperatingSystemMXBean\n+header extends java\/lang\/Object implements com\/sun\/management\/OperatingSystemMXBean flags 601\n+\n","filename":"make\/data\/symbols\/jdk.management-H.sym.txt","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/management\/jfr\/RemoteRecordingStream\n+method name dump descriptor (Ljava\/nio\/file\/Path;)V thrownTypes java\/io\/IOException flags 1\n+\n","filename":"make\/data\/symbols\/jdk.management.jfr-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/net\/NetworkPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n","filename":"make\/data\/symbols\/jdk.net-H.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/sctp\/AbstractNotificationHandler\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/NotificationHandler flags 21 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/nio\/sctp\/NotificationHandler<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/Association\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/nio\/sctp\/HandlerResult\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/sctp\/HandlerResult;>;\n+\n+class name com\/sun\/nio\/sctp\/IllegalReceiveException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/IllegalUnbindException\n+header extends java\/lang\/IllegalStateException flags 21\n+\n+class name com\/sun\/nio\/sctp\/InvalidStreamException\n+header extends java\/lang\/IllegalArgumentException flags 21\n+\n+class name com\/sun\/nio\/sctp\/MessageInfo\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/nio\/sctp\/Notification\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/nio\/sctp\/NotificationHandler\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/nio\/sctp\/SctpChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpMultiChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpServerChannel\n+header extends java\/nio\/channels\/spi\/AbstractSelectableChannel flags 421\n+\n+class name com\/sun\/nio\/sctp\/SctpSocketOption\n+header extends java\/lang\/Object implements java\/net\/SocketOption flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/net\/SocketOption<TT;>;\n+\n+class name com\/sun\/nio\/sctp\/SendFailedNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n+class name com\/sun\/nio\/sctp\/ShutdownNotification\n+header extends java\/lang\/Object implements com\/sun\/nio\/sctp\/Notification flags 421\n+\n","filename":"make\/data\/symbols\/jdk.sctp-H.sym.txt","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/auth\/LdapPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/NTDomainPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTNumericCredential\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/NTSid\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidDomainPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidPrimaryGroupPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTSidUserPrincipal\n+header extends com\/sun\/security\/auth\/NTSid flags 21\n+\n+class name com\/sun\/security\/auth\/NTUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/PrincipalComparator\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/security\/auth\/UnixNumericGroupPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixNumericUserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UnixPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+\n+class name com\/sun\/security\/auth\/UserPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 31\n+\n+class name com\/sun\/security\/auth\/callback\/TextCallbackHandler\n+header extends java\/lang\/Object implements javax\/security\/auth\/callback\/CallbackHandler flags 21\n+\n+class name com\/sun\/security\/auth\/login\/ConfigFile\n+header extends javax\/security\/auth\/login\/Configuration flags 21\n+\n+class name com\/sun\/security\/auth\/module\/JndiLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/KeyStoreLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/Krb5LoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/LdapLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/NTSystem\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/auth\/module\/UnixLoginModule\n+header extends java\/lang\/Object implements javax\/security\/auth\/spi\/LoginModule flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/auth\/module\/UnixSystem\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.security.auth-H.sym.txt","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/jgss\/AuthorizationDataEntry\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSContext\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSContext flags 601\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSCredential\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSCredential flags 601\n+\n+class name com\/sun\/security\/jgss\/GSSUtil\n+header extends java\/lang\/Object flags 21\n+-method name <init> descriptor ()V\n+\n+class name com\/sun\/security\/jgss\/InquireSecContextPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n+class name com\/sun\/security\/jgss\/InquireType\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/security\/jgss\/InquireType;>;\n+\n","filename":"make\/data\/symbols\/jdk.security.jgss-H.sym.txt","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/file\/ExtendedCopyOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/CopyOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedCopyOption;>;Ljava\/nio\/file\/CopyOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedOpenOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/OpenOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedOpenOption;>;Ljava\/nio\/file\/OpenOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name com\/sun\/nio\/file\/SensitivityWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/SensitivityWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name sun\/misc\/SignalHandler\n+header extends java\/lang\/Object flags 601 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name sun\/misc\/Unsafe\n+-method name defineAnonymousClass descriptor (Ljava\/lang\/Class;[B[Ljava\/lang\/Object;)Ljava\/lang\/Class;\n+\n+class name sun\/reflect\/ReflectionFactory\n+header extends java\/lang\/Object flags 21 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n","filename":"make\/data\/symbols\/jdk.unsupported-H.sym.txt","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,295 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name org\/w3c\/dom\/css\/CSS2Properties\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSCharsetRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSFontFaceRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSImportRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSMediaRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPageRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSPrimitiveValue\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRule\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSRuleList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleDeclaration\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSStyleSheet\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/StyleSheet flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSUnknownRule\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSRule flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValue\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/CSSValueList\n+header extends java\/lang\/Object implements org\/w3c\/dom\/css\/CSSValue flags 601\n+\n+class name org\/w3c\/dom\/css\/Counter\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/DOMImplementationCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/css\/DocumentCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/stylesheets\/DocumentStyle flags 601\n+\n+class name org\/w3c\/dom\/css\/ElementCSSInlineStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/RGBColor\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/Rect\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/css\/ViewCSS\n+header extends java\/lang\/Object implements org\/w3c\/dom\/views\/AbstractView flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAnchorElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAppletElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBaseFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLBodyElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLButtonElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLCollection\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDOMImplementation\n+header extends java\/lang\/Object implements org\/w3c\/dom\/DOMImplementation flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDirectoryElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDivElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLDocument\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Document flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Element flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFieldSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFontElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFormElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLFrameSetElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHRElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHeadingElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLHtmlElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIFrameElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLImageElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLInputElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLIsIndexElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLIElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLabelElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLegendElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLLinkElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMapElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMenuElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLMetaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLModElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLObjectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptGroupElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLOptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParagraphElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLParamElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLPreElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLQuoteElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLScriptElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLSelectElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLStyleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCaptionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableCellElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableColElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableRowElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTableSectionElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTextAreaElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLTitleElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/html\/HTMLUListElement\n+header extends java\/lang\/Object implements org\/w3c\/dom\/html\/HTMLElement flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/DocumentStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/LinkStyle\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/MediaList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheet\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/stylesheets\/StyleSheetList\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathEvaluator\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name org\/w3c\/dom\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNSResolver\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathNamespace\n+header extends java\/lang\/Object implements org\/w3c\/dom\/Node flags 601\n+\n+class name org\/w3c\/dom\/xpath\/XPathResult\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/jdk.xml.dom-H.sym.txt","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-generate platforms 7:8:9:A:B:C:D:E:F:G\n+generate platforms 7:8:9:A:B:C:D:E:F:G:H\n@@ -43,0 +43,1 @@\n+platform version H base G files java.base-H.sym.txt:java.compiler-H.sym.txt:java.datatransfer-H.sym.txt:java.desktop-H.sym.txt:java.instrument-H.sym.txt:java.logging-H.sym.txt:java.management-H.sym.txt:java.management.rmi-H.sym.txt:java.naming-H.sym.txt:java.rmi-H.sym.txt:java.scripting-H.sym.txt:java.security.jgss-H.sym.txt:java.security.sasl-H.sym.txt:java.smartcardio-H.sym.txt:java.sql-H.sym.txt:java.sql.rowset-H.sym.txt:java.xml-H.sym.txt:java.xml.crypto-H.sym.txt:jdk.accessibility-H.sym.txt:jdk.attach-H.sym.txt:jdk.compiler-H.sym.txt:jdk.dynalink-H.sym.txt:jdk.httpserver-H.sym.txt:jdk.incubator.foreign-H.sym.txt:jdk.incubator.vector-H.sym.txt:jdk.jartool-H.sym.txt:jdk.javadoc-H.sym.txt:jdk.jconsole-H.sym.txt:jdk.jdi-H.sym.txt:jdk.jfr-H.sym.txt:jdk.jshell-H.sym.txt:jdk.jsobject-H.sym.txt:jdk.management-H.sym.txt:jdk.management.jfr-H.sym.txt:jdk.net-H.sym.txt:jdk.sctp-H.sym.txt:jdk.security.auth-H.sym.txt:jdk.security.jgss-H.sym.txt:jdk.unsupported-H.sym.txt:jdk.xml.dom-H.sym.txt\n","filename":"make\/data\/symbols\/symbols","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+ * @author Guy Abossolo Foh\n@@ -285,1 +286,1 @@\n-        String dtd_home = System.getProperty(\"dtd_home\") + File.separator;\n+        String dtd_home = System.getProperty(\"dtd_home\");\n@@ -294,1 +295,1 @@\n-            mapping = new PublicMapping(dtd_home, \"public.map\");\n+            mapping = new PublicMapping(dtd_home + File.separator, \"public.map\");\n@@ -299,1 +300,1 @@\n-            System.err.println(\"Could not open DTD file \"+argv[0]);\n+            System.err.println(\"Could not open DTD file \" + argv[0]);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/dtdbuilder\/DTDBuilder.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,18 +63,0 @@\n-################################################################################\n-\n-ifeq ($(call isTargetOs, windows), true)\n-\n-  $(eval $(call SetupNativeCompilation, BUILD_LIBTIMEOUT_HANDLER, \\\n-        NAME := timeoutHandler, \\\n-        SRC := $(FH_BASEDIR)\/src\/windows\/native\/libtimeoutHandler, \\\n-        OBJECT_DIR := $(FH_SUPPORT)\/libtimeoutHandler, \\\n-        OUTPUT_DIR := $(FH_SUPPORT), \\\n-        CFLAGS := $(CFLAGS_JDKLIB), \\\n-        LDFLAGS := $(LDFLAGS_JDKLIB), \\\n-        OPTIMIZATION := LOW, \\\n-  ))\n-\n-  TARGETS += $(BUILD_LIBTIMEOUT_HANDLER)\n-\n-endif\n-\n@@ -102,4 +84,0 @@\n-# Add the dir of the dll to the path on windows\n-ifeq ($(call isTargetOs, windows), true)\n-  export PATH := $(PATH);$(FH_SUPPORT)\n-endif\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -888,0 +888,9 @@\n+\/\/ For dynamic lookup of SetThreadDescription API\n+typedef HRESULT (WINAPI *SetThreadDescriptionFnPtr)(HANDLE, PCWSTR);\n+typedef HRESULT (WINAPI *GetThreadDescriptionFnPtr)(HANDLE, PWSTR*);\n+static SetThreadDescriptionFnPtr _SetThreadDescription = NULL;\n+DEBUG_ONLY(static GetThreadDescriptionFnPtr _GetThreadDescription = NULL;)\n+\n+\/\/ forward decl.\n+static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path);\n+\n@@ -890,0 +899,45 @@\n+  \/\/ From Windows 10 and Windows 2016 server, we have a direct API\n+  \/\/ for setting the thread name\/description:\n+  \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/processthreadsapi\/nf-processthreadsapi-setthreaddescription\n+\n+  if (_SetThreadDescription != NULL) {\n+    \/\/ SetThreadDescription takes a PCWSTR but we have conversion routines that produce\n+    \/\/ LPWSTR. The only difference is that PCWSTR is a pointer to const WCHAR.\n+    LPWSTR unicode_name;\n+    errno_t err = convert_to_unicode(name, &unicode_name);\n+    if (err == ERROR_SUCCESS) {\n+      HANDLE current = GetCurrentThread();\n+      HRESULT hr = _SetThreadDescription(current, unicode_name);\n+      if (FAILED(hr)) {\n+        log_debug(os, thread)(\"set_native_thread_name: SetThreadDescription failed - falling back to debugger method\");\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+      } else {\n+        log_trace(os, thread)(\"set_native_thread_name: SetThreadDescription succeeded - new name: %s\", name);\n+\n+#ifdef ASSERT\n+        \/\/ For verification purposes in a debug build we read the thread name back and check it.\n+        PWSTR thread_name;\n+        HRESULT hr2 = _GetThreadDescription(current, &thread_name);\n+        if (FAILED(hr2)) {\n+          log_debug(os, thread)(\"set_native_thread_name: GetThreadDescription failed!\");\n+        } else {\n+          int res = CompareStringW(LOCALE_USER_DEFAULT,\n+                                   0, \/\/ no special comparison rules\n+                                   unicode_name,\n+                                   -1, \/\/ null-terminated\n+                                   thread_name,\n+                                   -1  \/\/ null-terminated\n+                                   );\n+          assert(res == CSTR_EQUAL,\n+                 \"Name strings were not the same - set: %ls, but read: %ls\", unicode_name, thread_name);\n+          LocalFree(thread_name);\n+        }\n+#endif\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+        return;\n+      }\n+    } else {\n+      log_debug(os, thread)(\"set_native_thread_name: convert_to_unicode failed - falling back to debugger method\");\n+    }\n+  }\n+\n@@ -898,0 +952,1 @@\n+    log_debug(os, thread)(\"set_native_thread_name: no debugger present so unable to set thread name\");\n@@ -4196,0 +4251,1 @@\n+\n@@ -4314,0 +4370,18 @@\n+  \/\/ Lookup SetThreadDescription - the docs state we must use runtime-linking of\n+  \/\/ kernelbase.dll, so that is what we do.\n+  HINSTANCE _kernelbase = LoadLibrary(TEXT(\"kernelbase.dll\"));\n+  if (_kernelbase != NULL) {\n+    _SetThreadDescription =\n+      reinterpret_cast<SetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"SetThreadDescription\"));\n+#ifdef ASSERT\n+    _GetThreadDescription =\n+      reinterpret_cast<GetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"GetThreadDescription\"));\n+#endif\n+  }\n+  log_info(os, thread)(\"The SetThreadDescription API is%s available.\", _SetThreadDescription == NULL ? \" not\" : \"\");\n+\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -488,16 +488,0 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n@@ -1862,0 +1846,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -1863,11 +1853,0 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n@@ -1875,0 +1854,2 @@\n+  length.load_item();\n+  oobef.load_item();\n@@ -1877,10 +1858,15 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n-    } else {\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+\n+  LIR_Opr len = length.result();\n+  LIR_Opr zero = NULL;\n+  if (type == T_INT) {\n+    zero = LIR_OprFact::intConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::intConst(length.result()->as_jint());\n@@ -1888,1 +1874,0 @@\n-    __ move(index.result(), result);\n@@ -1890,3 +1875,34 @@\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n-  }\n+    assert(type == T_LONG, \"sanity check\");\n+    zero = LIR_OprFact::longConst(0);\n+    if (length.result()->is_constant()){\n+      len = LIR_OprFact::longConst(length.result()->as_jlong());\n+    }\n+  }\n+  \/\/ C1 can not handle the case that comparing index with constant value while condition\n+  \/\/ is neither lir_cond_equal nor lir_cond_notEqual, see LIR_Assembler::comp_op.\n+  LIR_Opr zero_reg = new_register(type);\n+  __ move(zero, zero_reg);\n+#if defined(X86) && !defined(_LP64)\n+  \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+  LIR_Opr index_copy = new_register(index.type());\n+  \/\/ index >= 0\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_less, index_copy, zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ move(index.result(), index_copy);\n+  __ cmp(lir_cond_greaterEqual, index_copy, len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#else\n+  \/\/ index >= 0\n+  __ cmp(lir_cond_less, index.result(), zero_reg);\n+  __ branch(lir_cond_less, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                    Deoptimization::Action_make_not_entrant));\n+  \/\/ index < length\n+  __ cmp(lir_cond_greaterEqual, index.result(), len);\n+  __ branch(lir_cond_greaterEqual, new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                                            Deoptimization::Action_make_not_entrant));\n+#endif\n+  __ move(index.result(), result);\n@@ -1895,1 +1911,0 @@\n-\n@@ -3118,2 +3133,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  void do_NIOCheckIndex(Intrinsic* x);\n+  void do_PreconditionsCheckIndex(Intrinsic* x, BasicType type);\n@@ -351,2 +351,0 @@\n-  \/\/ For java.nio.Buffer.checkIndex\n-  void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n-          \"Intrinsify java.nio.Buffer.checkIndex\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_file) {\n+  if (_file != NULL) {\n@@ -92,0 +92,2 @@\n+  delete _indy_items;\n+  delete _interfaces;\n@@ -467,1 +469,1 @@\n-  bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n+  bool added = SystemDictionaryShared::add_unregistered_class_for_static_archive(THREAD, k);\n@@ -615,1 +617,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name_symbol, CHECK_NULL);\n@@ -617,1 +618,1 @@\n-    Handle ext_class_name = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle ext_class_name = java_lang_String::externalize_classname(class_name_symbol, CHECK_NULL);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-    SystemDictionaryShared::check_excluded_classes();\n@@ -112,0 +111,1 @@\n+    \/\/ Block concurrent class unloading from changing the _dumptime_table\n@@ -113,0 +113,2 @@\n+    SystemDictionaryShared::check_excluded_classes();\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -243,0 +244,1 @@\n+  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n@@ -296,0 +298,1 @@\n+  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -720,1 +723,1 @@\n-\n+  JavaThread* current = JavaThread::current();\n@@ -722,0 +725,1 @@\n+  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n@@ -724,3 +728,14 @@\n-    struct stat st;\n-    if (os::stat(path, &st) == 0) {\n-      path_array->append(path);\n+    if (!non_jar_in_cp) {\n+      struct stat st;\n+      if (os::stat(path, &st) == 0) {\n+        path_array->append(path);\n+      }\n+    } else {\n+      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n+      if (canonical_path != NULL) {\n+        char* error_msg = NULL;\n+        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n+        if (zip != NULL && error_msg == NULL) {\n+          path_array->append(path);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+  bool _has_non_jar_in_classpath;   \/\/ non-jar file entry exists in classpath\n@@ -275,0 +276,1 @@\n+  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -487,3 +487,2 @@\n-  \/\/ At this point, many classes have been loaded.\n-  \/\/ Gather systemDictionary classes in a global array and do everything to\n-  \/\/ that so we don't have to walk the SystemDictionary again.\n+  \/\/ Block concurrent class unloading from changing the _dumptime_table\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n@@ -492,1 +491,0 @@\n-  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -140,0 +140,2 @@\n+#define JAVA_18_VERSION                   62\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+#if INCLUDE_CDS\n+      ClassLoaderExt::set_has_non_jar_in_classpath();\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n@@ -260,0 +259,1 @@\n+  static jzfile* open_zip_file(const char* canonical_path, char** error_msg, JavaThread* thread);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+bool ClassLoaderExt::_has_non_jar_in_classpath = false;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static bool _has_non_jar_in_classpath;\n@@ -110,0 +111,4 @@\n+  static bool has_non_jar_in_classpath() {\n+    return _has_non_jar_in_classpath;\n+  }\n+\n@@ -118,1 +123,4 @@\n-#endif\n+  static void set_has_non_jar_in_classpath() {\n+    _has_non_jar_in_classpath = true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -130,1 +131,2 @@\n-objArrayHandle names, typeArrayHandle enabled, TRAPS) {\n+                                    objArrayHandle names,\n+                                    typeArrayHandle enabled, TRAPS) {\n@@ -138,2 +140,2 @@\n-    Handle s = java_lang_String::create_from_str(p->name(), CHECK);\n-    s = java_lang_String::char_converter(s, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, CHECK);\n+    TempNewSymbol name = SymbolTable::new_symbol(p->name());\n+    Handle s = java_lang_String::externalize_classname(name, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/javaAssertions.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -472,64 +472,3 @@\n-Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {\n-  oop          obj    = java_string();\n-  \/\/ Typical usage is to convert all '\/' to '.' in string.\n-  typeArrayOop value  = java_lang_String::value(obj);\n-  int          length = java_lang_String::length(obj, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(obj);\n-\n-  \/\/ First check if any from_char exist\n-  int index; \/\/ Declared outside, used later\n-  for (index = 0; index < length; index++) {\n-    jchar c = !is_latin1 ? value->char_at(index) :\n-                  ((jchar) value->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      break;\n-    }\n-  }\n-  if (index == length) {\n-    \/\/ No from_char, so do not copy.\n-    return java_string;\n-  }\n-\n-  \/\/ Check if result string will be latin1\n-  bool to_is_latin1 = false;\n-\n-  \/\/ Replacement char must be latin1\n-  if (CompactStrings && UNICODE::is_latin1(to_char)) {\n-    if (is_latin1) {\n-      \/\/ Source string is latin1 as well\n-      to_is_latin1 = true;\n-    } else if (!UNICODE::is_latin1(from_char)) {\n-      \/\/ We are replacing an UTF16 char. Scan string to\n-      \/\/ check if result can be latin1 encoded.\n-      to_is_latin1 = true;\n-      for (index = 0; index < length; index++) {\n-        jchar c = value->char_at(index);\n-        if (c != from_char && !UNICODE::is_latin1(c)) {\n-          to_is_latin1 = false;\n-          break;\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Create new UNICODE (or byte) buffer. Must handlize value because GC\n-  \/\/ may happen during String and char array creation.\n-  typeArrayHandle h_value(THREAD, value);\n-  Handle string = basic_create(length, to_is_latin1, CHECK_NH);\n-  typeArrayOop from_buffer = h_value();\n-  typeArrayOop to_buffer = java_lang_String::value(string());\n-\n-  \/\/ Copy contents\n-  for (index = 0; index < length; index++) {\n-    jchar c = (!is_latin1) ? from_buffer->char_at(index) :\n-                    ((jchar) from_buffer->byte_at(index)) & 0xff;\n-    if (c == from_char) {\n-      c = to_char;\n-    }\n-    if (!to_is_latin1) {\n-      to_buffer->char_at_put(index, c);\n-    } else {\n-      to_buffer->byte_at_put(index, (jbyte) c);\n-    }\n-  }\n-  return string;\n+Handle java_lang_String::externalize_classname(Symbol* java_name, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  return create_from_str(java_name->as_klass_external_name(), THREAD);\n@@ -4650,20 +4589,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":84,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -149,1 +148,0 @@\n-  static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);\n@@ -232,4 +230,2 @@\n-  \/\/ Conversion between '.' and '\/' formats\n-  static Handle externalize_classname(Handle java_string, TRAPS) {\n-    return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);\n-  }\n+  \/\/ Conversion between '.' and '\/' formats, and allocate a String from the result.\n+  static Handle externalize_classname(Symbol* java_name, TRAPS);\n@@ -1587,10 +1583,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-  if (AlwaysLockClassLoader) return false;\n@@ -1312,1 +1311,0 @@\n-    Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);\n@@ -1314,1 +1312,1 @@\n-    Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);\n+    Handle string = java_lang_String::externalize_classname(class_name, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1168,2 +1168,2 @@\n-class LoadedUnregisteredClassesTable : public ResourceHashtable<\n-  Symbol*, bool,\n+class UnregisteredClassesTable : public ResourceHashtable<\n+  Symbol*, InstanceKlass*,\n@@ -1172,1 +1172,1 @@\n-  6661,                             \/\/ prime number\n+  15889, \/\/ prime number\n@@ -1175,1 +1175,1 @@\n-static LoadedUnregisteredClassesTable* _loaded_unregistered_classes = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n@@ -1177,6 +1177,9 @@\n-bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* k) {\n-  \/\/ We don't allow duplicated unregistered classes of the same name.\n-  assert(DumpSharedSpaces, \"only when dumping\");\n-  Symbol* name = k->name();\n-  if (_loaded_unregistered_classes == NULL) {\n-    _loaded_unregistered_classes = new (ResourceObj::C_HEAP, mtClass)LoadedUnregisteredClassesTable();\n+bool SystemDictionaryShared::add_unregistered_class(Thread* current, InstanceKlass* klass) {\n+  \/\/ We don't allow duplicated unregistered classes with the same name.\n+  \/\/ We only archive the first class with that name that succeeds putting\n+  \/\/ itself into the table.\n+  Arguments::assert_is_dumping_archive();\n+  MutexLocker ml(current, UnregisteredClassesTable_lock);\n+  Symbol* name = klass->name();\n+  if (_unregistered_classes_table == NULL) {\n+    _unregistered_classes_table = new (ResourceObj::C_HEAP, mtClass)UnregisteredClassesTable();\n@@ -1184,2 +1187,2 @@\n-  bool created = false;\n-  _loaded_unregistered_classes->put_if_absent(name, true, &created);\n+  bool created;\n+  InstanceKlass** v = _unregistered_classes_table->put_if_absent(name, klass, &created);\n@@ -1187,0 +1190,9 @@\n+    name->increment_refcount();\n+  }\n+  return (klass == *v);\n+}\n+\n+\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n+bool SystemDictionaryShared::add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k) {\n+  assert(DumpSharedSpaces, \"only when dumping\");\n+  if (add_unregistered_class(current, k)) {\n@@ -1189,0 +1201,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -1190,1 +1205,0 @@\n-  return created;\n@@ -1298,0 +1312,15 @@\n+void SystemDictionaryShared::handle_class_unloading(InstanceKlass* klass) {\n+  remove_dumptime_info(klass);\n+\n+  if (_unregistered_classes_table != NULL) {\n+    \/\/ Remove the class from _unregistered_classes_table: keep the entry but\n+    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ added again.\n+    MutexLocker ml(Thread::current(), UnregisteredClassesTable_lock);\n+    InstanceKlass** v = _unregistered_classes_table->get(klass->name());\n+    if (v != NULL) {\n+      *v = NULL;\n+    }\n+  }\n+}\n+\n@@ -1479,0 +1508,42 @@\n+class UnregisteredClassesDuplicationChecker : StackObj {\n+  GrowableArray<InstanceKlass*> _list;\n+  Thread* _thread;\n+public:\n+  UnregisteredClassesDuplicationChecker() : _thread(Thread::current()) {}\n+\n+  bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo& info) {\n+    if (!SystemDictionaryShared::is_builtin(k)) {\n+      _list.append(k);\n+    }\n+    return true;  \/\/ keep on iterating\n+  }\n+\n+  static int compare_by_loader(InstanceKlass** a, InstanceKlass** b) {\n+    ClassLoaderData* loader_a = a[0]->class_loader_data();\n+    ClassLoaderData* loader_b = b[0]->class_loader_data();\n+\n+    if (loader_a != loader_b) {\n+      return intx(loader_a) - intx(loader_b);\n+    } else {\n+      return intx(a[0]) - intx(b[0]);\n+    }\n+  }\n+\n+  void mark_duplicated_classes() {\n+    \/\/ Two loaders may load two identical or similar hierarchies of classes. If we\n+    \/\/ check for duplication in random order, we may end up excluding important base classes\n+    \/\/ in both hierarchies, causing most of the classes to be excluded.\n+    \/\/ We sort the classes by their loaders. This way we're likely to archive\n+    \/\/ all classes in the one of the two hierarchies.\n+    _list.sort(compare_by_loader);\n+    for (int i = 0; i < _list.length(); i++) {\n+      InstanceKlass* k = _list.at(i);\n+      bool i_am_first = SystemDictionaryShared::add_unregistered_class(_thread, k);\n+      if (!i_am_first) {\n+        SystemDictionaryShared::warn_excluded(k, \"Duplicated unregistered class\");\n+        SystemDictionaryShared::set_excluded_locked(k);\n+      }\n+    }\n+  }\n+};\n+\n@@ -1488,0 +1559,12 @@\n+  assert(no_class_loading_should_happen(), \"sanity\");\n+  assert_lock_strong(DumpTimeTable_lock);\n+\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Do this first -- if a base class is excluded due to duplication,\n+    \/\/ all of its subclasses will also be excluded by ExcludeDumpTimeSharedClasses\n+    ResourceMark rm;\n+    UnregisteredClassesDuplicationChecker dup_checker;\n+    _dumptime_table->iterate(&dup_checker);\n+    dup_checker.mark_duplicated_classes();\n+  }\n+\n@@ -1501,0 +1584,9 @@\n+void SystemDictionaryShared::set_excluded_locked(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  Arguments::assert_is_dumping_archive();\n+  DumpTimeSharedClassInfo* info = find_or_allocate_info_for_locked(k);\n+  if (info != NULL) {\n+    info->set_excluded();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":105,"deletions":13,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-  static bool warn_excluded(InstanceKlass* k, const char* reason);\n@@ -235,0 +234,1 @@\n+  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -268,1 +268,1 @@\n-  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n+  static bool add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k);\n@@ -273,1 +273,1 @@\n-  static void remove_dumptime_info(InstanceKlass* k) NOT_CDS_RETURN;\n+  static void handle_class_unloading(InstanceKlass* k) NOT_CDS_RETURN;\n@@ -325,0 +325,1 @@\n+  static bool add_unregistered_class(Thread* current, InstanceKlass* k);\n@@ -330,0 +331,2 @@\n+  static void set_excluded_locked(InstanceKlass* k);\n+  static bool warn_excluded(InstanceKlass* k, const char* reason);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n@@ -470,5 +471,0 @@\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -485,0 +486,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -758,0 +758,11 @@\n+void* Disassembler::dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st) {\n+  int sz = buflen - offset;\n+  int written = jio_snprintf(&buf[offset], sz, \"%s%s\", hsdis_library_name, os::dll_file_extension());\n+  if (written < sz) { \/\/ written successfully, not truncated.\n+    if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n+    return os::dll_load(buf, ebuf, ebuflen);\n+  } else if (Verbose) {\n+    st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n+  }\n+  return NULL;\n+}\n@@ -807,8 +818,1 @@\n-    if (jvm_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-      strcpy(&buf[jvm_offset], hsdis_library_name);\n-      strcat(&buf[jvm_offset], os::dll_file_extension());\n-      if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-      _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-    } else {\n-      if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-    }\n+    _library = dll_load(buf, sizeof buf, jvm_offset, ebuf, sizeof ebuf, st);\n@@ -817,8 +821,1 @@\n-      if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-        strcpy(&buf[lib_offset], hsdis_library_name);\n-        strcat(&buf[lib_offset], os::dll_file_extension());\n-        if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-        _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-      } else {\n-        if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-      }\n+      _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -832,8 +829,1 @@\n-        if (lib_offset + strlen(hsdis_library_name) + strlen(os::dll_file_extension()) < JVM_MAXPATHLEN) {\n-          strcpy(&buf[lib_offset], hsdis_library_name);\n-          strcat(&buf[lib_offset], os::dll_file_extension());\n-          if (Verbose) st->print_cr(\"Trying to load: %s\", buf);\n-          _library = os::dll_load(buf, ebuf, sizeof ebuf);\n-        } else {\n-          if (Verbose) st->print_cr(\"Try to load hsdis library failed: the length of path is beyond the OS limit\");\n-        }\n+        _library = dll_load(buf, sizeof buf, lib_offset, ebuf, sizeof ebuf, st);\n@@ -844,5 +834,1 @@\n-    \/\/ 4. hsdis-<arch>.so  (using LD_LIBRARY_PATH)\n-    strcpy(&buf[0], hsdis_library_name);\n-    strcat(&buf[0], os::dll_file_extension());\n-    if (Verbose) st->print_cr(\"Trying to load: %s via LD_LIBRARY_PATH or equivalent\", buf);\n-    _library = os::dll_load(buf, ebuf, sizeof ebuf);\n+    _library = dll_load(buf, sizeof buf, 0, ebuf, sizeof ebuf, st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static void* dll_load(char* buf, int buflen, int offset, char* ebuf, int ebuflen, outputStream* st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -296,2 +296,1 @@\n-  \/\/ Cast away constness:\n-  ((VirtualSpace)_virtual_space).print_on(st);\n+  _virtual_space.print_on(st);\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -53,2 +55,6 @@\n-  \/\/ The remembered set needs the heap regions set up.\n-  HeapRegionRemSet::setup_remset_size();\n+  SpaceAlignment = HeapRegion::GrainBytes;\n+  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n+\n+  \/\/ We need to initialize card set configuration as soon as heap region size is\n+  \/\/ known as it depends on it and is used really early.\n+  initialize_card_set_configuration();\n@@ -58,1 +64,1 @@\n-    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RSetSparseRegionEntries);\n+    FLAG_SET_ERGO(G1EagerReclaimRemSetThreshold, G1RemSetArrayOfCardsEntries);\n@@ -60,3 +66,0 @@\n-\n-  SpaceAlignment = HeapRegion::GrainBytes;\n-  HeapAlignment = calculate_heap_alignment(SpaceAlignment);\n@@ -93,0 +96,2 @@\n+  } else if (strcmp(type, \"young-evac-fail\") == 0) {\n+    G1HeapVerifier::enable_verification_type(G1HeapVerifier::G1VerifyYoungEvacFail);\n@@ -101,1 +106,1 @@\n-                            \"young-normal, concurrent-start, mixed, remark, cleanup and full\", type);\n+                            \"young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\", type);\n@@ -122,0 +127,34 @@\n+\n+void G1Arguments::initialize_card_set_configuration() {\n+  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  \/\/ Array of Cards card set container globals.\n+  const int LOG_M = 20;\n+  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n+    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n+  }\n+\n+  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n+  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n+  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+\n+  \/\/ Howl card set container globals.\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+                                                                     G1RemSetArrayOfCardsEntries,\n+                                                                     G1RemSetHowlMaxNumBuckets));\n+  }\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n+  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n+    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n+                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n+    vm_exit_during_initialization(buf);\n+  }\n+}\n+\n@@ -199,0 +238,8 @@\n+\n+  \/\/ Verify that the maximum parallelism isn't too high to eventually overflow\n+  \/\/ the refcount in G1CardSetContainer.\n+  uint max_parallel_refinement_threads = G1ConcRefinementThreads + G1DirtyCardQueueSet::num_par_ids();\n+  uint const divisor = 3;  \/\/ Safe divisor; we increment by 2 for each claim, but there is a small initial value.\n+  if (max_parallel_refinement_threads > UINTPTR_MAX \/ divisor) {\n+    vm_exit_during_initialization(\"Too large parallelism for remembered sets.\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":54,"deletions":7,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  static void initialize_card_set_configuration();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,887 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1FromCardCache.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+G1CardSet::CardSetPtr G1CardSet::FullCardSet = (G1CardSet::CardSetPtr)-1;\n+\n+G1CardSetConfiguration::G1CardSetConfiguration() :\n+  _inline_ptr_bits_per_card(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift) {\n+\n+  \/\/ Array of Cards card set container size calculation\n+  _num_cards_in_array = G1RemSetArrayOfCardsEntries;\n+\n+  \/\/ Full card set container size calculation\n+  _max_cards_in_card_set = (uint)HeapRegion::CardsPerRegion;\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+  _cards_in_howl_threshold = _max_cards_in_card_set * (double)G1RemSetCoarsenHowlToFullPercent \/ 100;\n+\n+  \/\/ Howl card set container size calculation.\n+  _num_buckets_in_howl = G1RemSetHowlNumBuckets;\n+\n+  \/\/ Howl Bitmap card set container size calculation.\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * (double)G1RemSetCoarsenHowlBitmapToHowlFullPercent \/ 100;\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+G1CardSetConfiguration::G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                                               uint num_cards_in_array,\n+                                               double cards_in_bitmap_threshold,\n+                                               uint max_buckets_in_howl,\n+                                               double cards_in_howl_threshold,\n+                                               uint max_cards_in_cardset) :\n+  _inline_ptr_bits_per_card(inline_ptr_bits_per_card),\n+  _num_cards_in_array(num_cards_in_array),\n+  _max_cards_in_card_set(max_cards_in_cardset),\n+  _cards_in_howl_threshold(max_cards_in_cardset * cards_in_howl_threshold) {\n+\n+  assert(is_power_of_2(_max_cards_in_card_set),\n+        \"max_cards_in_card_set must be a power of 2: %u\", _max_cards_in_card_set);\n+\n+  _num_buckets_in_howl = G1CardSetHowl::num_buckets(_max_cards_in_card_set, _num_cards_in_array, max_buckets_in_howl);\n+\n+  _num_cards_in_howl_bitmap = G1CardSetHowl::bitmap_size(_max_cards_in_card_set, _num_buckets_in_howl);\n+  _cards_in_howl_bitmap_threshold = _num_cards_in_howl_bitmap * cards_in_bitmap_threshold;\n+  _log2_num_cards_in_howl_bitmap = log2i_exact(_num_cards_in_howl_bitmap);\n+  _bitmap_hash_mask = ~(~(0) << _log2_num_cards_in_howl_bitmap);\n+\n+  log_configuration();\n+}\n+\n+void G1CardSetConfiguration::log_configuration() {\n+  log_debug_p(gc, remset)(\"Card Set container configuration: \"\n+                          \"InlinePtr #elems %u size %zu \"\n+                          \"Array Of Cards #elems %u size %zu \"\n+                          \"Howl #buckets %u coarsen threshold %u \"\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n+                          num_cards_in_inline_ptr(), sizeof(void*),\n+                          num_cards_in_array(), G1CardSetArray::size_in_bytes(num_cards_in_array()),\n+                          num_buckets_in_howl(), cards_in_howl_threshold(),\n+                          num_cards_in_howl_bitmap(), G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), cards_in_howl_bitmap_threshold());\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr() const {\n+  return num_cards_in_inline_ptr(_inline_ptr_bits_per_card);\n+}\n+\n+uint G1CardSetConfiguration::num_cards_in_inline_ptr(uint bits_per_card) {\n+  return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+}\n+\n+G1CardSetAllocOptions* G1CardSetConfiguration::mem_object_alloc_options() {\n+  G1CardSetAllocOptions* result = NEW_C_HEAP_ARRAY(G1CardSetAllocOptions, num_mem_object_types(), mtGC);\n+\n+  result[0] = { (uint)CardSetHash::get_node_size() };\n+  result[1] = { (uint)G1CardSetArray::size_in_bytes(num_cards_in_array()), 2, 256 };\n+  result[2] = { (uint)G1CardSetBitMap::size_in_bytes(num_cards_in_howl_bitmap()), 2, 256 };\n+  result[3] = { (uint)G1CardSetHowl::size_in_bytes(num_buckets_in_howl()), 2, 256 };\n+\n+  return result;\n+}\n+\n+const char* G1CardSetConfiguration::mem_object_type_name_str(uint index) {\n+  const char* names[] = { \"Node\", \"Array\", \"Bitmap\", \"Howl\" };\n+  return names[index];\n+}\n+\n+void G1CardSetCoarsenStats::reset() {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = 0;\n+    _coarsen_collision[i] = 0;\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::subtract_from(G1CardSetCoarsenStats& other) {\n+  STATIC_ASSERT(ARRAY_SIZE(_coarsen_from) == ARRAY_SIZE(_coarsen_collision));\n+  for (uint i = 0; i < ARRAY_SIZE(_coarsen_from); i++) {\n+    _coarsen_from[i] = other._coarsen_from[i] - _coarsen_from[i];\n+    _coarsen_collision[i] = other._coarsen_collision[i] - _coarsen_collision[i];\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::record_coarsening(uint tag, bool collision) {\n+  assert(tag < ARRAY_SIZE(_coarsen_from), \"tag %u out of bounds\", tag);\n+  Atomic::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  if (collision) {\n+    Atomic::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSetCoarsenStats::print_on(outputStream* out) {\n+  out->print_cr(\"Inline->AoC %zu (%zu) \"\n+                \"AoC->Howl %zu (%zu) \"\n+                \"Howl->Full %zu (%zu) \"\n+                \"Inline->AoC %zu (%zu) \"\n+                \"AoC->BitMap %zu (%zu) \"\n+                \"BitMap->Full %zu (%zu) \",\n+                _coarsen_from[0], _coarsen_collision[0],\n+                _coarsen_from[1], _coarsen_collision[1],\n+                \/\/ There is no BitMap at the first level so we can't .\n+                _coarsen_from[3], _coarsen_collision[3],\n+                _coarsen_from[4], _coarsen_collision[4],\n+                _coarsen_from[5], _coarsen_collision[5],\n+                _coarsen_from[6], _coarsen_collision[6]\n+               );\n+}\n+\n+class G1CardSetHashTable : public CHeapObj<mtGCCardSet> {\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  \/\/ Did we insert at least one element in the table?\n+  bool volatile _inserted_elem;\n+\n+  G1CardSetMemoryManager* _mm;\n+  CardSetHash _table;\n+\n+  class G1CardSetHashTableLookUp : public StackObj {\n+    uint _region_idx;\n+  public:\n+    explicit G1CardSetHashTableLookUp(uint region_idx) : _region_idx(region_idx) { }\n+\n+    uintx get_hash() const { return _region_idx; }\n+\n+    bool equals(G1CardSetHashTableValue* value, bool* is_dead) {\n+      *is_dead = false;\n+      return value->_region_idx == _region_idx;\n+    }\n+  };\n+\n+  class G1CardSetHashTableFound : public StackObj {\n+    G1CardSetHashTableValue* _value;\n+  public:\n+    void operator()(G1CardSetHashTableValue* value) {\n+      _value = value;\n+    }\n+\n+    G1CardSetHashTableValue* value() const { return _value; }\n+  };\n+\n+  class G1CardSetHashTableScan : public StackObj {\n+    G1CardSet::G1CardSetPtrIterator* _scan_f;\n+  public:\n+    explicit G1CardSetHashTableScan(G1CardSet::G1CardSetPtrIterator* f) : _scan_f(f) { }\n+\n+    bool operator()(G1CardSetHashTableValue* value) {\n+      _scan_f->do_cardsetptr(value->_region_idx, value->_num_occupied, value->_card_set);\n+      return true;\n+    }\n+  };\n+\n+\n+public:\n+  static const size_t InitialLogTableSize = 2;\n+\n+  G1CardSetHashTable(G1CardSetMemoryManager* mm,\n+                     size_t initial_log_table_size = InitialLogTableSize) :\n+    _inserted_elem(false),\n+    _mm(mm),\n+    _table(mm, initial_log_table_size) {\n+  }\n+\n+  ~G1CardSetHashTable() {\n+    reset();\n+  }\n+\n+  G1CardSetHashTableValue* get_or_add(uint region_idx, bool* should_grow) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value();\n+    }\n+\n+    G1CardSetHashTableValue value(region_idx, G1CardSetInlinePtr());\n+    bool inserted = _table.insert_get(Thread::current(), lookup, value, found, should_grow);\n+\n+    if (!_inserted_elem && inserted) {\n+      \/\/ It does not matter to us who is setting the flag so a regular atomic store\n+      \/\/ is sufficient.\n+      Atomic::store(&_inserted_elem, true);\n+    }\n+\n+    return found.value();\n+  }\n+\n+  CardSetPtr get(uint region_idx) {\n+    G1CardSetHashTableLookUp lookup(region_idx);\n+    G1CardSetHashTableFound found;\n+\n+    if (_table.get(Thread::current(), lookup, found)) {\n+      return found.value()->_card_set;\n+    }\n+    return nullptr;\n+  }\n+\n+  void iterate_safepoint(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_safepoint_scan(cl);\n+  }\n+\n+  void iterate(G1CardSet::G1CardSetPtrIterator* cl2) {\n+    G1CardSetHashTableScan cl(cl2);\n+    _table.do_scan(Thread::current(), cl);\n+  }\n+\n+  void reset() {\n+    if (Atomic::load(&_inserted_elem)) {\n+       _table.unsafe_reset(InitialLogTableSize);\n+      Atomic::store(&_inserted_elem, false);\n+    }\n+  }\n+\n+  void print(outputStream* os) {\n+    os->print(\"TBL \" PTR_FORMAT \" size %zu mem %zu \", p2i(&_table), _table.get_size_log2(Thread::current()), _table.get_mem_size(Thread::current()));\n+  }\n+\n+  void grow() {\n+    size_t new_limit = _table.get_size_log2(Thread::current()) + 1;\n+    _table.grow(Thread::current(), new_limit);\n+  }\n+\n+  size_t mem_size() {\n+    return sizeof(*this) +\n+      _table.get_mem_size(Thread::current()) - sizeof(_table);\n+  }\n+\n+  size_t log_table_size() { return _table.get_size_log2(Thread::current()); }\n+};\n+\n+void* G1CardSetHashTableConfig::allocate_node(void* context, size_t size, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  return mm->allocate_node();\n+}\n+\n+void G1CardSetHashTableConfig::free_node(void* context, void* memory, Value const& value) {\n+  G1CardSetMemoryManager* mm = (G1CardSetMemoryManager*)context;\n+  mm->free_node(memory);\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::_coarsen_stats;\n+G1CardSetCoarsenStats G1CardSet::_last_coarsen_stats;\n+\n+G1CardSet::G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm) :\n+  _mm(mm),\n+  _config(config),\n+  _table(new G1CardSetHashTable(mm)),\n+  _num_occupied(0) {\n+}\n+\n+G1CardSet::~G1CardSet() {\n+  delete _table;\n+  _mm->flush();\n+}\n+\n+uint G1CardSet::card_set_type_to_mem_object_type(uintptr_t type) const {\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not allocate card set type %zu\", type);\n+\n+  return (uint)type;\n+}\n+\n+uint8_t* G1CardSet::allocate_mem_object(uintptr_t type) {\n+  return _mm->allocate(card_set_type_to_mem_object_type(type));\n+}\n+\n+void G1CardSet::free_mem_object(CardSetPtr card_set) {\n+  assert(card_set != G1CardSet::FreeCardSet, \"should not free Free card set\");\n+  assert(card_set != G1CardSet::FullCardSet, \"should not free Full card set\");\n+\n+  uintptr_t type = card_set_type(card_set);\n+  void* value = strip_card_set_type(card_set);\n+\n+  assert(type == G1CardSet::CardSetArrayOfCards ||\n+         type == G1CardSet::CardSetBitMap ||\n+         type == G1CardSet::CardSetHowl, \"should not free card set type %zu\", type);\n+\n+#ifdef ASSERT\n+  if (type == G1CardSet::CardSetArrayOfCards ||\n+      type == G1CardSet::CardSetBitMap ||\n+      type == G1CardSet::CardSetHowl) {\n+    G1CardSetContainer* card_set = (G1CardSetContainer*)value;\n+    assert((card_set->refcount() == 1), \"must be\");\n+  }\n+#endif\n+\n+  _mm->free(card_set_type_to_mem_object_type(type), value);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::acquire_card_set(CardSetPtr volatile* card_set_addr) {\n+  \/\/ Update reference counts under RCU critical section to avoid a\n+  \/\/ use-after-cleapup bug where we increment a reference count for\n+  \/\/ an object whose memory has already been cleaned up and reused.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  while (true) {\n+    \/\/ Get cardsetptr and increment refcount atomically wrt to memory reuse.\n+    CardSetPtr card_set = Atomic::load_acquire(card_set_addr);\n+    uint cs_type = card_set_type(card_set);\n+    if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+      return card_set;\n+    }\n+\n+    G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+\n+    if (card_set_on_heap->try_increment_refcount()) {\n+      assert(card_set_on_heap->refcount() >= 3, \"Smallest value is 3\");\n+      return card_set;\n+    }\n+  }\n+}\n+\n+bool G1CardSet::release_card_set(CardSetPtr card_set) {\n+  uint cs_type = card_set_type(card_set);\n+  if (card_set == FullCardSet || cs_type == CardSetInlinePtr) {\n+    return false;\n+  }\n+\n+  G1CardSetContainer* card_set_on_heap = (G1CardSetContainer*)strip_card_set_type(card_set);\n+  return card_set_on_heap->decrement_refcount() == 1;\n+}\n+\n+void G1CardSet::release_and_maybe_free_card_set(CardSetPtr card_set) {\n+  if (release_card_set(card_set)) {\n+    free_mem_object(card_set);\n+  }\n+}\n+\n+void G1CardSet::release_and_must_free_card_set(CardSetPtr card_set) {\n+  bool should_free = release_card_set(card_set);\n+  assert(should_free, \"should have been the only one having a reference\");\n+  free_mem_object(card_set);\n+}\n+\n+class G1ReleaseCardsets : public StackObj {\n+  G1CardSet* _card_set;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  void coarsen_to_full(CardSetPtr* card_set_addr) {\n+    while (true) {\n+      CardSetPtr cur_card_set = Atomic::load_acquire(card_set_addr);\n+      uint cs_type = G1CardSet::card_set_type(cur_card_set);\n+      if (cur_card_set == G1CardSet::FullCardSet) {\n+        return;\n+      }\n+\n+      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n+\n+      if (old_value == cur_card_set) {\n+        _card_set->release_and_maybe_free_card_set(cur_card_set);\n+        return;\n+      }\n+    }\n+  }\n+\n+public:\n+  explicit G1ReleaseCardsets(G1CardSet* card_set) : _card_set(card_set) { }\n+\n+  void operator ()(CardSetPtr* card_set_addr) {\n+    coarsen_to_full(card_set_addr);\n+  }\n+};\n+\n+G1AddCardResult G1CardSet::add_to_array(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetArray* array = card_set_ptr<G1CardSetArray>(card_set);\n+  return array->add(card_in_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_to_howl(CardSetPtr parent_card_set,\n+                                                uint card_region,\n+                                                uint card_in_region,\n+                                                bool increment_total) {\n+  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  uint bucket = _config->howl_bucket_index(card_in_region);\n+  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n+\n+  while (true) {\n+    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+      return Overflow;\n+    }\n+\n+    card_set = acquire_card_set(bucket_entry);\n+    add_result = add_to_card_set(bucket_entry, card_set, card_region, card_in_region);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(bucket_entry, card_set, card_in_region, true \/* within_howl *\/);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set) + G1CardSetCoarsenStats::CoarsenHowlOffset, !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n+  }\n+\n+  if (to_transfer != nullptr) {\n+    transfer_cards_in_howl(parent_card_set, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+  return add_result;\n+}\n+\n+G1AddCardResult G1CardSet::add_to_bitmap(CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetBitMap* bitmap = card_set_ptr<G1CardSetBitMap>(card_set);\n+  uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+  return bitmap->add(card_offset, _config->cards_in_howl_bitmap_threshold(), _config->num_cards_in_howl_bitmap());\n+}\n+\n+G1AddCardResult G1CardSet::add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region) {\n+  G1CardSetInlinePtr value(card_set_addr, card_set);\n+  return value.add(card_in_region, _config->inline_ptr_bits_per_card(), _config->num_cards_in_inline_ptr());\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::create_coarsened_array_of_cards(uint card_in_region, bool within_howl) {\n+  uint8_t* data = nullptr;\n+  CardSetPtr new_card_set;\n+  if (within_howl) {\n+    uint const size_in_bits = _config->num_cards_in_howl_bitmap();\n+    uint card_offset = _config->howl_bitmap_offset(card_in_region);\n+    data = allocate_mem_object(CardSetBitMap);\n+    new (data) G1CardSetBitMap(card_offset, size_in_bits);\n+    new_card_set = make_card_set_ptr(data, CardSetBitMap);\n+  } else {\n+    data = allocate_mem_object(CardSetHowl);\n+    new (data) G1CardSetHowl(card_in_region, _config);\n+    new_card_set = make_card_set_ptr(data, CardSetHowl);\n+  }\n+  return new_card_set;\n+}\n+\n+bool G1CardSet::coarsen_card_set(volatile CardSetPtr* card_set_addr,\n+                                 CardSetPtr cur_card_set,\n+                                 uint card_in_region,\n+                                 bool within_howl) {\n+  CardSetPtr new_card_set = nullptr;\n+\n+  switch (card_set_type(cur_card_set)) {\n+    case CardSetArrayOfCards : {\n+      new_card_set = create_coarsened_array_of_cards(card_in_region, within_howl);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      new_card_set = FullCardSet;\n+      break;\n+    }\n+    case CardSetInlinePtr: {\n+      uint const size = _config->num_cards_in_array();\n+      uint8_t* data = allocate_mem_object(CardSetArrayOfCards);\n+      new (data) G1CardSetArray(card_in_region, size);\n+      new_card_set = make_card_set_ptr(data, CardSetArrayOfCards);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      new_card_set = FullCardSet; \/\/ anything will do at this point.\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, new_card_set); \/\/ Memory order?\n+  if (old_value == cur_card_set) {\n+    \/\/ Success. Indicate that the cards from the current card set must be transferred\n+    \/\/ by this caller.\n+    \/\/ Release the hash table reference to the card. The caller still holds the\n+    \/\/ reference to this card set, so it can never be released (and we do not need to\n+    \/\/ check its result).\n+    bool should_free = release_card_set(cur_card_set);\n+    assert(!should_free, \"must have had more than one reference\");\n+    \/\/ Free containers if cur_card_set is CardSetHowl\n+    if (card_set_type(cur_card_set) == CardSetHowl) {\n+      G1ReleaseCardsets rel(this);\n+      card_set_ptr<G1CardSetHowl>(cur_card_set)->iterate(rel, _config->num_buckets_in_howl());\n+    }\n+    return true;\n+  } else {\n+    \/\/ Somebody else beat us to coarsening that card set. Exit, but clean up first.\n+    if (new_card_set != FullCardSet) {\n+      assert(new_card_set != nullptr, \"must not be\");\n+      release_and_must_free_card_set(new_card_set);\n+    }\n+    return false;\n+  }\n+}\n+\n+class G1TransferCard : public StackObj {\n+  G1CardSet* _card_set;\n+  uint _region_idx;\n+public:\n+  G1TransferCard(G1CardSet* card_set, uint region_idx) : _card_set(card_set), _region_idx(region_idx) { }\n+\n+  void operator ()(uint card_idx) {\n+    _card_set->add_card(_region_idx, card_idx, false);\n+  }\n+};\n+\n+void G1CardSet::transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region) {\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap. \"Full\" contains all elements anyway.\n+  if (card_set_type(source_card_set) != CardSetHowl) {\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    assert(card_set_type(source_card_set) == CardSetHowl, \"must be\");\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ AoCS before.\n+    Atomic::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+  }\n+}\n+\n+void G1CardSet::transfer_cards_in_howl(CardSetPtr parent_card_set,\n+                                                     CardSetPtr source_card_set,\n+                                                     uint card_region) {\n+  assert(card_set_type(parent_card_set) == CardSetHowl, \"must be\");\n+  assert(source_card_set != FullCardSet, \"Should not need to transfer from full\");\n+  \/\/ Need to transfer old entries unless there is a Full card set in place now, i.e.\n+  \/\/ the old type has been CardSetBitMap.\n+  if (card_set_type(source_card_set) != CardSetBitMap) {\n+    \/\/ We only need to transfer from anything below CardSetBitMap.\n+    G1TransferCard iter(this, card_region);\n+    iterate_cards_during_transfer(source_card_set, iter);\n+  } else {\n+    uint diff = _config->num_cards_in_howl_bitmap() - card_set_ptr<G1CardSetBitMap>(source_card_set)->num_bits_set();\n+\n+    \/\/ Need to correct for that the Full remembered set occupies more cards than the\n+    \/\/ bitmap before.\n+    \/\/ We add 1 element less because the values will be incremented\n+    \/\/ in G1CardSet::add_card for the current addition or where already incremented in\n+    \/\/ G1CardSet::add_to_howl after coarsening.\n+    diff -= 1;\n+\n+    G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+    Atomic::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+\n+    bool should_grow_table = false;\n+    G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+    Atomic::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+\n+    Atomic::add(&_num_occupied, diff, memory_order_relaxed);\n+  }\n+}\n+\n+G1AddCardResult G1CardSet::add_to_card_set(volatile CardSetPtr* card_set_addr, CardSetPtr card_set,  uint card_region, uint card_in_region, bool increment_total) {\n+  assert(card_set_addr != nullptr, \"Cannot add to empty cardset\");\n+\n+  G1AddCardResult add_result;\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      add_result = add_to_inline_ptr(card_set_addr, card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards : {\n+      add_result = add_to_array(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      add_result = add_to_bitmap(card_set, card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      assert(CardSetHowl == card_set_type(FullCardSet), \"must be\");\n+      if (card_set == FullCardSet) {\n+        return Found;\n+      }\n+      add_result = add_to_howl(card_set, card_region, card_in_region, increment_total);\n+      break;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  return add_result;\n+}\n+\n+G1CardSetHashTableValue* G1CardSet::get_or_add_card_set(uint card_region, bool* should_grow_table) {\n+  return _table->get_or_add(card_region, should_grow_table);\n+}\n+\n+G1CardSet::CardSetPtr G1CardSet::get_card_set(uint card_region) {\n+  return _table->get(card_region);\n+}\n+\n+G1AddCardResult G1CardSet::add_card(uint card_region, uint card_in_region, bool increment_total) {\n+  G1AddCardResult add_result;\n+  CardSetPtr to_transfer = nullptr;\n+  CardSetPtr card_set;\n+\n+  bool should_grow_table = false;\n+  G1CardSetHashTableValue* table_entry = get_or_add_card_set(card_region, &should_grow_table);\n+  while (true) {\n+    card_set = acquire_card_set(&table_entry->_card_set);\n+    add_result = add_to_card_set(&table_entry->_card_set, card_set, card_region, card_in_region, increment_total);\n+\n+    if (add_result != Overflow) {\n+      break;\n+    }\n+    \/\/ Card set has overflown. Coarsen or retry.\n+    bool coarsened = coarsen_card_set(&table_entry->_card_set, card_set, card_in_region);\n+    _coarsen_stats.record_coarsening(card_set_type(card_set), !coarsened);\n+    if (coarsened) {\n+      \/\/ We have been the one coarsening this card set (and in the process added that card).\n+      add_result = Added;\n+      to_transfer = card_set;\n+      break;\n+    }\n+    \/\/ Somebody else beat us to coarsening. Retry.\n+    release_and_maybe_free_card_set(card_set);\n+  }\n+\n+  if (increment_total && add_result == Added) {\n+    Atomic::inc(&table_entry->_num_occupied, memory_order_relaxed);\n+    Atomic::inc(&_num_occupied, memory_order_relaxed);\n+  }\n+  if (should_grow_table) {\n+    _table->grow();\n+  }\n+  if (to_transfer != nullptr) {\n+    transfer_cards(table_entry, to_transfer, card_region);\n+  }\n+\n+  release_and_maybe_free_card_set(card_set);\n+\n+  return add_result;\n+}\n+\n+bool G1CardSet::contains_card(uint card_region, uint card_in_region) {\n+  assert(card_in_region < _config->max_cards_in_region(),\n+         \"Card %u is beyond max %u\", card_in_region, _config->max_cards_in_region());\n+\n+  \/\/ Protect the card set from reclamation.\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    return false;\n+  } else if (card_set == FullCardSet) {\n+    \/\/ contains_card() is not a performance critical method so we do not hide that\n+    \/\/ case in the switch below.\n+    return true;\n+  }\n+\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_in_region, _config->inline_ptr_bits_per_card());\n+    }\n+    case CardSetArrayOfCards :  return card_set_ptr<G1CardSetArray>(card_set)->contains(card_in_region);\n+    case CardSetBitMap: return card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_in_region, _config->num_cards_in_howl_bitmap());\n+    case CardSetHowl: {\n+      G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(card_set);\n+\n+      return howling_array->contains(card_in_region, _config);\n+    }\n+  }\n+  ShouldNotReachHere();\n+  return false;\n+}\n+\n+void G1CardSet::print_info(outputStream* st, uint card_region, uint card_in_region) {\n+  CardSetPtr card_set = get_card_set(card_region);\n+  if (card_set == nullptr) {\n+    st->print(\"NULL card set\");\n+    return;\n+  } else if (card_set == FullCardSet) {\n+    st->print(\"FULL card set)\");\n+    return;\n+  }\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      st->print(\"InlinePtr not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetArrayOfCards :  {\n+      st->print(\"AoC not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetBitMap: {\n+      st->print(\"BitMap not containing %u\", card_in_region);\n+      break;\n+    }\n+    case CardSetHowl: {\n+      st->print(\"CardSetHowl not containing %u\", card_in_region);\n+      break;\n+    }\n+    default: st->print(\"Unknown card set type %u\", card_set_type(card_set)); ShouldNotReachHere(); break;\n+  }\n+}\n+\n+template <class CardVisitor>\n+void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found) {\n+  uint type = card_set_type(card_set);\n+  assert(type == CardSetInlinePtr || type == CardSetArrayOfCards,\n+         \"invalid card set type %d to transfer from\",\n+         card_set_type(card_set));\n+\n+  switch (type) {\n+    case CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      return;\n+    }\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void G1CardSet::iterate_containers(G1CardSetPtrIterator* found, bool at_safepoint) {\n+  if (at_safepoint) {\n+    _table->iterate_safepoint(found);\n+  } else {\n+    _table->iterate(found);\n+  }\n+}\n+\n+template <typename Closure>\n+class G1ContainerCards {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCards(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) { return true; }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(_region_idx, card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    for (uint i = 0; i < length; i++) {\n+      _iter.do_card(_region_idx, card_idx);\n+    }\n+  }\n+};\n+\n+void G1CardSet::iterate_cards(G1CardSetCardIterator& iter) {\n+  G1CardSetMergeCardIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n+  iterate_containers(&cl);\n+}\n+\n+bool G1CardSet::occupancy_less_or_equal_to(size_t limit) const {\n+  return occupied() <= limit;\n+}\n+\n+bool G1CardSet::is_empty() const {\n+  return _num_occupied == 0;\n+}\n+\n+size_t G1CardSet::occupied() const {\n+  return _num_occupied;\n+}\n+\n+size_t G1CardSet::num_containers() {\n+  class GetNumberOfContainers : public G1CardSetPtrIterator {\n+  public:\n+    size_t _count;\n+\n+    GetNumberOfContainers() : G1CardSetPtrIterator(), _count(0) { }\n+\n+    void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) override {\n+      _count++;\n+    }\n+  } cl;\n+\n+  iterate_containers(&cl);\n+  return cl._count;\n+}\n+\n+G1CardSetCoarsenStats G1CardSet::coarsen_stats() {\n+  return _coarsen_stats;\n+}\n+\n+void G1CardSet::print_coarsen_stats(outputStream* out) {\n+  _last_coarsen_stats.subtract_from(_coarsen_stats);\n+  out->print(\"Coarsening (recent): \");\n+  _last_coarsen_stats.print_on(out);\n+  out->print(\"Coarsening (all): \");\n+  _coarsen_stats.print_on(out);\n+}\n+\n+size_t G1CardSet::mem_size() const {\n+  return sizeof(*this) +\n+         _table->mem_size() +\n+         _mm->mem_size();\n+}\n+\n+size_t G1CardSet::wasted_mem_size() const {\n+  return _mm->wasted_mem_size();\n+}\n+\n+size_t G1CardSet::static_mem_size() {\n+  return sizeof(FullCardSet) + sizeof(_coarsen_stats);\n+}\n+\n+void G1CardSet::clear() {\n+  _table->reset();\n+  _num_occupied = 0;\n+  _mm->flush();\n+}\n+\n+void G1CardSet::print(outputStream* os) {\n+  _table->print(os);\n+  _mm->print(os);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":887,"deletions":0,"binary":false,"changes":887,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_HPP\n+#define SHARE_GC_G1_G1CARDSET_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/concurrentHashTable.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetAllocOptions;\n+class G1CardSetBufferList;\n+class G1CardSetHashTable;\n+class G1CardSetHashTableValue;\n+class G1CardSetMemoryManager;\n+class Mutex;\n+\n+\/\/ The result of an attempt to add a card to that card set.\n+enum G1AddCardResult {\n+  Overflow,  \/\/ The card set is more than full. The entry may have been added. Need\n+             \/\/ Coarsen and retry.\n+  Found,     \/\/ The card is already in the set.\n+  Added      \/\/ The card has been added to the set by this attempt.\n+};\n+\n+class G1CardSetConfiguration {\n+  uint _inline_ptr_bits_per_card;\n+  uint _num_cards_in_array;\n+  uint _num_cards_in_howl_bitmap;\n+  uint _num_buckets_in_howl;\n+  uint _max_cards_in_card_set;\n+  uint _cards_in_howl_threshold;\n+  uint _cards_in_howl_bitmap_threshold;\n+  uint _log2_num_cards_in_howl_bitmap;\n+  size_t _bitmap_hash_mask;\n+\n+  void log_configuration();\n+public:\n+\n+  \/\/ Initialize card set configuration from globals.\n+  G1CardSetConfiguration();\n+  \/\/ Initialize card set configuration from parameters.\n+  G1CardSetConfiguration(uint inline_ptr_bits_per_card,\n+                         uint num_cards_in_array,\n+                         double cards_in_bitmap_threshold,\n+                         uint max_buckets_in_howl,\n+                         double cards_in_howl_threshold,\n+                         uint max_cards_in_cardset);\n+\n+  \/\/ Inline pointer configuration\n+  uint inline_ptr_bits_per_card() const { return _inline_ptr_bits_per_card; }\n+  uint num_cards_in_inline_ptr() const;\n+  static uint num_cards_in_inline_ptr(uint bits_per_card);\n+\n+  \/\/ Array of Cards configuration\n+  bool use_cards_in_array() const { return _num_cards_in_array != 0; } \/\/ Unused for now\n+  \/\/ Number of cards in \"Array of Cards\" set; 0 to disable.\n+  \/\/ Always coarsen to next level if full, so no specific threshold.\n+  uint num_cards_in_array() const { return _num_cards_in_array; }\n+\n+  \/\/ Bitmap within Howl card set container configuration\n+  bool use_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap != 0; } \/\/ Unused for now\n+  uint num_cards_in_howl_bitmap() const { return _num_cards_in_howl_bitmap; }\n+  \/\/ (Approximate) Number of cards in bitmap to coarsen Howl Bitmap to Howl Full.\n+  uint cards_in_howl_bitmap_threshold() const { return _cards_in_howl_bitmap_threshold; }\n+  uint log2_num_cards_in_howl_bitmap() const {return _log2_num_cards_in_howl_bitmap;}\n+\n+  \/\/ Howl card set container configuration\n+  uint num_buckets_in_howl() const { return _num_buckets_in_howl; }\n+  \/\/ Threshold at which to turn howling arrays into Full.\n+  uint cards_in_howl_threshold() const { return _cards_in_howl_threshold; }\n+  uint howl_bitmap_offset(uint card_idx) const { return card_idx & _bitmap_hash_mask; }\n+  \/\/ Given a card index, return the bucket in the array of card sets.\n+  uint howl_bucket_index(uint card_idx) { return card_idx >> _log2_num_cards_in_howl_bitmap; }\n+\n+  \/\/ Full card configuration\n+  \/\/ Maximum number of cards in a non-full card set for a single region. Card sets\n+  \/\/ with more entries per region are coarsened to Full.\n+  uint max_cards_in_region() const { return _max_cards_in_card_set; }\n+\n+  \/\/ Memory object types configuration\n+  \/\/ Number of distinctly sized memory objects on the card set heap.\n+  \/\/ Currently contains CHT-Nodes, ArrayOfCards, BitMaps, Howl\n+  static constexpr uint num_mem_object_types() { return 4; }\n+  \/\/ Returns the memory allocation options for the memory objects on the card set heap. The returned\n+  \/\/ array must be freed by the caller.\n+  G1CardSetAllocOptions* mem_object_alloc_options();\n+\n+  \/\/ For a given memory object, get a descriptive name.\n+  static const char* mem_object_type_name_str(uint index);\n+};\n+\n+\/\/ Collects coarsening statistics: how many attempts of each kind and how many\n+\/\/ failed due to a competing thread doing the coarsening first.\n+class G1CardSetCoarsenStats {\n+public:\n+  \/\/ Number of entries in the statistics tables: since we index with the source\n+  \/\/ cardset of the coarsening, this is the total number of combinations of\n+  \/\/ card sets - 1.\n+  static constexpr size_t NumCoarsenCategories = 7;\n+  \/\/ Coarsening statistics for the possible CardSetPtr in the Howl card set\n+  \/\/ start from this offset.\n+  static constexpr size_t CoarsenHowlOffset = 4;\n+\n+private:\n+  \/\/ Indices are \"from\" indices.\n+  size_t _coarsen_from[NumCoarsenCategories];\n+  size_t _coarsen_collision[NumCoarsenCategories];\n+\n+public:\n+  G1CardSetCoarsenStats() { reset(); }\n+\n+  void reset();\n+\n+  void subtract_from(G1CardSetCoarsenStats& other);\n+\n+  \/\/ Record a coarsening for the given tag\/category. Collision should be true if\n+  \/\/ this coarsening lost the race to do the coarsening of that category.\n+  void record_coarsening(uint tag, bool collision);\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Sparse set of card indexes comprising a remembered set on the Java heap. Card\n+\/\/ size is assumed to be card table card size.\n+\/\/\n+\/\/ Technically it is implemented using a ConcurrentHashTable that stores a card\n+\/\/ set container for every region containing at least one card.\n+\/\/\n+\/\/ There are in total five different containers, encoded in the ConcurrentHashTable\n+\/\/ node as CardSetPtr. A CardSetPtr may cover the whole region or just a part of\n+\/\/ it.\n+\/\/ See its description below for more information.\n+class G1CardSet : public CHeapObj<mtGCCardSet> {\n+  friend class G1CardSetTest;\n+  friend class G1CardSetMtTestTask;\n+\n+  template <typename Closure, template <typename> class CardorRanges>\n+  friend class G1CardSetMergeCardIterator;\n+\n+  friend class G1TransferCard;\n+\n+  friend class G1ReleaseCardsets;\n+\n+  static G1CardSetCoarsenStats _coarsen_stats; \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats _last_coarsen_stats; \/\/ Coarsening statistics at last GC.\n+public:\n+  \/\/ Two lower bits are used to encode the card storage types\n+  static const uintptr_t CardSetPtrHeaderSize = 2;\n+\n+  \/\/ CardSetPtr represents the card storage type of a given covered area. It encodes\n+  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/\n+  \/\/ Possible encodings:\n+  \/\/\n+  \/\/ 0...00000 free               (Empty, should never happen)\n+  \/\/ 1...11111 full               All card indexes in the whole area this CardSetPtr covers are part of this container.\n+  \/\/ X...XXX00 inline-ptr-cards   A handful of card indexes covered by this CardSetPtr are encoded within the CardSetPtr.\n+  \/\/ X...XXX01 array of cards     The container is a contiguous array of card indexes.\n+  \/\/ X...XXX10 bitmap             The container uses a bitmap to determine whether a given index is part of this set.\n+  \/\/ X...XXX11 howl               This is a card set container containing an array of CardSetPtr, with each CardSetPtr\n+  \/\/                              limited to a sub-range of the original range. Currently only one level of this\n+  \/\/                              container is supported.\n+  typedef void* CardSetPtr;\n+  \/\/ Coarsening happens in the order below:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetHowl -> Full\n+  \/\/ Corsening of containers inside the CardSetHowl happens in the order:\n+  \/\/ CardSetInlinePtr -> CardSetArrayOfCards -> CardSetBitMap -> Full\n+  static const uintptr_t CardSetInlinePtr      = 0x0;\n+  static const uintptr_t CardSetArrayOfCards   = 0x1;\n+  static const uintptr_t CardSetBitMap         = 0x2;\n+  static const uintptr_t CardSetHowl           = 0x3;\n+\n+  \/\/ The special sentinel values\n+  static constexpr CardSetPtr FreeCardSet = nullptr;\n+  \/\/ Unfortunately we can't make (G1CardSet::CardSetPtr)-1 constexpr because\n+  \/\/ reinterpret_casts are forbidden in constexprs. Use a regular static instead.\n+  static CardSetPtr FullCardSet;\n+\n+  static const uintptr_t CardSetPtrTypeMask    = ((uintptr_t)1 << CardSetPtrHeaderSize) - 1;\n+\n+  static CardSetPtr strip_card_set_type(CardSetPtr ptr) { return (CardSetPtr)((uintptr_t)ptr & ~CardSetPtrTypeMask); }\n+\n+  static uint card_set_type(CardSetPtr ptr) { return (uintptr_t)ptr & CardSetPtrTypeMask; }\n+\n+  template <class T>\n+  static T* card_set_ptr(CardSetPtr ptr);\n+\n+private:\n+  G1CardSetMemoryManager* _mm;\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetHashTable* _table;\n+\n+  \/\/ Total number of cards in this card set. This is a best-effort value, i.e. there may\n+  \/\/ be (slightly) more cards in the card set than this value in reality.\n+  size_t _num_occupied;\n+\n+  CardSetPtr make_card_set_ptr(void* value, uintptr_t type);\n+\n+  CardSetPtr acquire_card_set(CardSetPtr volatile* card_set_addr);\n+  \/\/ Returns true if the card set should be released\n+  bool release_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free if needed.\n+  void release_and_maybe_free_card_set(CardSetPtr card_set);\n+  \/\/ Release card set and free (and it must be freeable).\n+  void release_and_must_free_card_set(CardSetPtr card_set);\n+\n+  \/\/ Coarsens the CardSet cur_card_set to the next level; tries to replace the\n+  \/\/ previous CardSet with a new one which includes the given card_in_region.\n+  \/\/ coarsen_card_set does not transfer cards from cur_card_set\n+  \/\/ to the new card_set. Transfer is achieved by transfer_cards.\n+  \/\/ Returns true if this was the thread that coarsened the CardSet (and added the card).\n+  bool coarsen_card_set(CardSetPtr volatile* card_set_addr,\n+                        CardSetPtr cur_card_set,\n+                        uint card_in_region, bool within_howl = false);\n+\n+  CardSetPtr create_coarsened_array_of_cards(uint card_in_region, bool within_howl);\n+\n+  \/\/ Transfer entries from source_card_set to a recently installed coarser storage type\n+  \/\/ We only need to transfer anything finer than CardSetBitMap. \"Full\" contains\n+  \/\/ all elements anyway.\n+  void transfer_cards(G1CardSetHashTableValue* table_entry, CardSetPtr source_card_set, uint card_region);\n+  void transfer_cards_in_howl(CardSetPtr parent_card_set, CardSetPtr source_card_set, uint card_region);\n+\n+  G1AddCardResult add_to_card_set(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_region, uint card, bool increment_total = true);\n+\n+  G1AddCardResult add_to_inline_ptr(CardSetPtr volatile* card_set_addr, CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_array(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_bitmap(CardSetPtr card_set, uint card_in_region);\n+  G1AddCardResult add_to_howl(CardSetPtr parent_card_set, uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  G1CardSetHashTableValue* get_or_add_card_set(uint card_region, bool* should_grow_table);\n+  CardSetPtr get_card_set(uint card_region);\n+\n+  \/\/ Iterate over cards of a card set container during transfer of the cards from\n+  \/\/ one container to another. Executes\n+  \/\/\n+  \/\/     void operator ()(uint card_idx)\n+  \/\/\n+  \/\/ on the given class.\n+  template <class CardVisitor>\n+  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found);\n+\n+  \/\/ Iterate over the container, calling a method on every card or card range contained\n+  \/\/ in the card container.\n+  \/\/ For every container, first calls\n+  \/\/\n+  \/\/   void start_iterate(uint tag, uint region_idx);\n+  \/\/\n+  \/\/ Then for every card or card range it calls\n+  \/\/\n+  \/\/   void do_card(uint card_idx);\n+  \/\/   void do_card_range(uint card_idx, uint length);\n+  \/\/\n+  \/\/ where card_idx is the card index within that region_idx passed before in\n+  \/\/ start_iterate().\n+  \/\/\n+  template <class CardOrRangeVisitor>\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+\n+  uint card_set_type_to_mem_object_type(uintptr_t type) const;\n+  uint8_t* allocate_mem_object(uintptr_t type);\n+  void free_mem_object(CardSetPtr card_set);\n+\n+public:\n+  G1CardSetConfiguration* config() const { return _config; }\n+\n+  \/\/ Create a new remembered set for a particular heap region.\n+  G1CardSet(G1CardSetConfiguration* config, G1CardSetMemoryManager* mm);\n+  virtual ~G1CardSet();\n+\n+  \/\/ Adds the given card to this set, returning an appropriate result. If added,\n+  \/\/ updates the total count.\n+  G1AddCardResult add_card(uint card_region, uint card_in_region, bool increment_total = true);\n+\n+  bool contains_card(uint card_region, uint card_in_region);\n+\n+  void print_info(outputStream* st, uint card_region, uint card_in_region);\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n+  \/\/ that is less or equal to the given occupancy.\n+  bool occupancy_less_or_equal_to(size_t limit) const;\n+\n+  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n+  bool is_empty() const;\n+\n+  \/\/ Returns the number of cards contained in this remembered set.\n+  size_t occupied() const;\n+\n+  size_t num_containers();\n+\n+  static G1CardSetCoarsenStats coarsen_stats();\n+  static void print_coarsen_stats(outputStream* out);\n+\n+  \/\/ Returns size of the actual remembered set containers in bytes.\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+  \/\/ Returns the size of static data in bytes.\n+  static size_t static_mem_size();\n+\n+  \/\/ Clear the entire contents of this remembered set.\n+  void clear();\n+\n+  void print(outputStream* os);\n+\n+  \/\/ Various iterators - should be made inlineable somehow.\n+  class G1CardSetPtrIterator {\n+  public:\n+    virtual void do_cardsetptr(uint region_idx, size_t num_occupied, CardSetPtr card_set) = 0;\n+  };\n+\n+  void iterate_containers(G1CardSetPtrIterator* iter, bool safepoint = false);\n+\n+  class G1CardSetCardIterator {\n+  public:\n+    virtual void do_card(uint region_idx, uint card_idx) = 0;\n+  };\n+\n+  void iterate_cards(G1CardSetCardIterator& iter);\n+\n+  \/\/ Iterate all cards for card set merging. Must be a CardOrRangeVisitor as\n+  \/\/ explained above.\n+  template <class CardOrRangeVisitor>\n+  void iterate_for_merge(CardOrRangeVisitor& cl);\n+};\n+\n+class G1CardSetHashTableValue {\n+public:\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  const uint _region_idx;\n+  uint volatile _num_occupied;\n+  CardSetPtr volatile _card_set;\n+\n+  G1CardSetHashTableValue(uint region_idx, CardSetPtr card_set) : _region_idx(region_idx), _num_occupied(0), _card_set(card_set) { }\n+};\n+\n+class G1CardSetHashTableConfig : public StackObj {\n+public:\n+  using Value = G1CardSetHashTableValue;\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    *is_dead = false;\n+    return value._region_idx;\n+  }\n+  static void* allocate_node(void* context, size_t size, Value const& value);\n+  static void free_node(void* context, void* memory, Value const& value);\n+};\n+\n+typedef ConcurrentHashTable<G1CardSetHashTableConfig, mtGCCardSet> CardSetHash;\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSET_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+template <class T>\n+inline T* G1CardSet::card_set_ptr(CardSetPtr ptr) {\n+  return (T*)strip_card_set_type(ptr);\n+}\n+\n+inline G1CardSet::CardSetPtr G1CardSet::make_card_set_ptr(void* value, uintptr_t type) {\n+  assert(card_set_type(value) == 0, \"Given ptr \" PTR_FORMAT \" already has type bits set\", p2i(value));\n+  return (CardSetPtr)((uintptr_t)value | type);\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found) {\n+  switch (card_set_type(card_set)) {\n+    case CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n+        card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case CardSetBitMap: {\n+      \/\/ There is no first-level bitmap spanning the whole area.\n+      ShouldNotReachHere();\n+      return;\n+    }\n+    case CardSetHowl: {\n+      assert(card_set_type(FullCardSet) == CardSetHowl, \"Must be\");\n+      if (card_set == FullCardSet) {\n+        if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n+          found(0, _config->max_cards_in_region());\n+        }\n+        return;\n+      }\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n+        card_set_ptr<G1CardSetHowl>(card_set)->iterate(found, _config);\n+      }\n+      return;\n+    }\n+  }\n+  log_error(gc)(\"Unkown card set type %u\", card_set_type(card_set));\n+  ShouldNotReachHere();\n+}\n+\n+template <typename Closure>\n+class G1ContainerCardsOrRanges {\n+  Closure& _iter;\n+  uint _region_idx;\n+\n+public:\n+  G1ContainerCardsOrRanges(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+\n+  bool start_iterate(uint tag) {\n+    return _iter.start_iterate(tag, _region_idx);\n+  }\n+\n+  void operator()(uint card_idx) {\n+    _iter.do_card(card_idx);\n+  }\n+\n+  void operator()(uint card_idx, uint length) {\n+    _iter.do_card_range(card_idx, length);\n+  }\n+};\n+\n+template <typename Closure, template <typename> class CardOrRanges>\n+class G1CardSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+  G1CardSet* _card_set;\n+  Closure& _iter;\n+\n+public:\n+\n+  G1CardSetMergeCardIterator(G1CardSet* card_set, Closure& iter) : _card_set(card_set), _iter(iter) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    CardOrRanges<Closure> cl(_iter, region_idx);\n+    _card_set->iterate_cards_or_ranges_in_container(card_set, cl);\n+  }\n+};\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n+  iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+class G1CardSetInlinePtr : public StackObj {\n+  friend class G1CardSetContainersTest;\n+\n+  typedef G1CardSet::CardSetPtr CardSetPtr;\n+\n+  CardSetPtr volatile * _value_addr;\n+  CardSetPtr _value;\n+\n+  static const uint SizeFieldLen = 3;\n+  static const uint SizeFieldPos = 2;\n+  static const uint HeaderSize = G1CardSet::CardSetPtrHeaderSize + SizeFieldLen;\n+\n+  static const uint BitsInValue = sizeof(CardSetPtr) * BitsPerByte;\n+\n+  static const uintptr_t SizeFieldMask = (((uint)1 << SizeFieldLen) - 1) << SizeFieldPos;\n+\n+  static uint8_t card_pos_for(uint const idx, uint const bits_per_card) {\n+    return (idx * bits_per_card + HeaderSize);\n+  }\n+\n+  static CardSetPtr merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card);\n+\n+  static uint card_at(CardSetPtr value, uint const idx, uint const bits_per_card) {\n+    uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+    uint result = ((uintptr_t)value >> card_pos) & (((uintptr_t)1 << bits_per_card) - 1);\n+    return result;\n+  }\n+public:\n+  G1CardSetInlinePtr() : _value_addr(nullptr), _value((CardSetPtr)G1CardSet::CardSetInlinePtr) { }\n+\n+  G1CardSetInlinePtr(CardSetPtr value) : _value_addr(nullptr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1CardSetInlinePtr(CardSetPtr volatile* value_addr, CardSetPtr value) : _value_addr(value_addr), _value(value) {\n+    assert(((uintptr_t)_value & G1CardSet::CardSetInlinePtr) == G1CardSet::CardSetInlinePtr, \"Value \" PTR_FORMAT \" is not a valid G1CardSetInPtr.\", p2i(_value));\n+  }\n+\n+  G1AddCardResult add(uint const card_idx, uint const bits_per_card, uint const max_cards_in_inline_ptr);\n+\n+  bool contains(uint const card_idx, uint const bits_per_card);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, uint const bits_per_card);\n+\n+  operator CardSetPtr () { return _value; }\n+\n+  static uint max_cards_in_inline_ptr(uint bits_per_card) {\n+    return (BitsInValue - HeaderSize) \/ bits_per_card;\n+  }\n+\n+  static uint num_cards_in(CardSetPtr value) {\n+    return ((uintptr_t)value & SizeFieldMask) >> SizeFieldPos;\n+  }\n+};\n+\n+\n+\/\/ Common base class for card set containers where the memory for the entries is\n+\/\/ managed on the (C-)heap. Depending on the current use, one of the two overlapping\n+\/\/ members are used:\n+\/\/\n+\/\/ While such an object is assigned to a card set container, we utilize the\n+\/\/ reference count for memory management.\n+\/\/\n+\/\/ In this case the object is one of three states:\n+\/\/ 1: Live: The object is visible to other threads, thus can\n+\/\/    safely be accessed by other threads (_ref_count >= 3).\n+\/\/ 2: Dead: The object is visible to only a single thread and may be\n+\/\/    safely reclaimed (_ref_count == 1).\n+\/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n+\/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n+\/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\/\/\n+\/\/ When such an object is on a free list, we reuse the same field for linking\n+\/\/ together those free objects.\n+\/\/\n+\/\/ All but inline pointers are of this kind. For those, card entries are stored\n+\/\/ directly in the CardSetPtr of the ConcurrentHashTable node.\n+class G1CardSetContainer {\n+private:\n+  union {\n+    G1CardSetContainer* _next;\n+    uintptr_t _ref_count;\n+  };\n+\n+public:\n+  G1CardSetContainer() : _ref_count(3) { }\n+\n+  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+\n+  bool try_increment_refcount();\n+\n+  \/\/ Decrement refcount potentially while racing increment, so we need\n+  \/\/ to check the value after attempting to decrement.\n+  uintptr_t decrement_refcount();\n+\n+  G1CardSetContainer* next() {\n+    return _next;\n+  }\n+\n+  G1CardSetContainer** next_addr() {\n+    return &_next;\n+  }\n+\n+  void set_next(G1CardSetContainer* next) {\n+    _next = next;\n+  }\n+};\n+\n+class G1CardSetArray : public G1CardSetContainer {\n+public:\n+  typedef uint16_t EntryDataType;\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+private:\n+  EntryCountType _size;\n+  EntryCountType volatile _num_entries;\n+  EntryDataType _data[2];\n+\n+  static const EntryCountType LockBitMask = (EntryCountType)1 << (sizeof(EntryCountType) * BitsPerByte - 1);\n+  static const EntryCountType EntryMask = LockBitMask - 1;\n+\n+  class G1CardSetArrayLocker : public StackObj {\n+    EntryCountType volatile* _value;\n+    EntryCountType volatile _original_value;\n+    bool _success;\n+  public:\n+    G1CardSetArrayLocker(EntryCountType volatile* value);\n+\n+    EntryCountType num_entries() const { return _original_value; }\n+    void inc_num_entries() { _success = true; }\n+\n+    ~G1CardSetArrayLocker() {\n+      assert(((_original_value + _success) & EntryMask) == (EntryCountType)(_original_value + _success), \"precondition!\" );\n+\n+      Atomic::release_store(_value, (EntryCountType)(_original_value + _success));\n+    }\n+  };\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _data);\n+  }\n+\n+public:\n+  G1CardSetArray(uint const card_in_region, EntryCountType num_elems);\n+\n+  G1AddCardResult add(uint card_idx);\n+\n+  bool contains(uint card_idx);\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found);\n+\n+  size_t num_entries() const { return _num_entries & EntryMask; }\n+  size_t max_entries() const { return _size; }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetArray>(); }\n+\n+  static size_t size_in_bytes(size_t num_cards) {\n+    return header_size_in_bytes() + sizeof(EntryDataType) * num_cards;\n+  }\n+};\n+\n+class G1CardSetBitMap : public G1CardSetContainer {\n+  size_t _num_bits_set;\n+  BitMap::bm_word_t _bits[1];\n+\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _bits);\n+  }\n+\n+public:\n+  G1CardSetBitMap(uint const card_in_region, uint const size_in_bits);\n+\n+  G1AddCardResult add(uint card_idx, size_t threshold, size_t size_in_bits);\n+\n+  bool contains(uint card_idx, size_t size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return bm.at(card_idx);\n+  }\n+\n+  uint num_bits_set() const { return (uint)_num_bits_set; }\n+\n+  template <class CardVisitor>\n+  void iterate(CardVisitor& found, size_t const size_in_bits, uint offset);\n+\n+  uint next(uint const idx, size_t const size_in_bits) {\n+    BitMapView bm(_bits, size_in_bits);\n+    return static_cast<uint>(bm.get_next_one_offset(idx));\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetBitMap>(); }\n+\n+  static size_t size_in_bytes(size_t size_in_bits) { return header_size_in_bytes() + BitMap::calc_size_in_words(size_in_bits) * BytesPerWord; }\n+};\n+\n+class G1CardSetHowl : public G1CardSetContainer {\n+public:\n+  typedef uint EntryCountType;\n+  using CardSetPtr = G1CardSet::CardSetPtr;\n+  EntryCountType volatile _num_entries;\n+private:\n+  CardSetPtr _buckets[2];\n+  \/\/ Do not add class member variables beyond this point\n+\n+  template<typename Derived>\n+  static size_t header_size_in_bytes_internal() {\n+    return offset_of(Derived, _buckets);\n+  }\n+\n+  \/\/ Iterates over the given CardSetPtr with at index in this Howl card set,\n+  \/\/ applying a CardOrRangeVisitor on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+public:\n+  G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config);\n+\n+  CardSetPtr* get_card_set_addr(EntryCountType index) {\n+    return &_buckets[index];\n+  }\n+\n+  bool contains(uint card_idx, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set, applying a CardOrRangeVisitor\n+  \/\/ on it.\n+  template <class CardOrRangeVisitor>\n+  void iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config);\n+\n+  \/\/ Iterates over all CardSetPtrs in this Howl card set. Calls\n+  \/\/\n+  \/\/   void operator ()(CardSetPtr* card_set_addr);\n+  \/\/\n+  \/\/ on all of them.\n+  template <class CardSetPtrVisitor>\n+  void iterate(CardSetPtrVisitor& found, uint num_card_sets);\n+\n+  static EntryCountType num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_buckets);\n+\n+  static EntryCountType bitmap_size(size_t size_in_bits, uint num_buckets) {\n+    EntryCountType num_cards = (EntryCountType)size_in_bits \/ num_buckets;\n+    return round_up_power_of_2(num_cards);\n+  }\n+\n+  static size_t header_size_in_bytes() { return header_size_in_bytes_internal<G1CardSetHowl>(); }\n+\n+  static size_t size_in_bytes(size_t num_arrays) {\n+    return header_size_in_bytes() + sizeof(CardSetPtr) * num_arrays;\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n+\n+inline G1CardSetInlinePtr::CardSetPtr G1CardSetInlinePtr::merge(CardSetPtr orig_value, uint card_in_region, uint idx, uint bits_per_card) {\n+  assert((idx & (SizeFieldMask >> SizeFieldPos)) == idx, \"Index %u too large to fit into size field\", idx);\n+  assert(card_in_region < ((uint)1 << bits_per_card), \"Card %u too large to fit into card value field\", card_in_region);\n+\n+  uint8_t card_pos = card_pos_for(idx, bits_per_card);\n+  assert(card_pos + bits_per_card < BitsInValue, \"Putting card at pos %u with %u bits would extend beyond pointer\", card_pos, bits_per_card);\n+\n+  \/\/ Check that we do not touch any fields we do not own.\n+  uintptr_t mask = ((((uintptr_t)1 << bits_per_card) - 1) << card_pos);\n+  assert(((uintptr_t)orig_value & mask) == 0, \"The bits in the new range should be empty; orig_value \" PTR_FORMAT \" mask \" PTR_FORMAT, p2i(orig_value), mask);\n+\n+  uintptr_t value = ((uintptr_t)(idx + 1) << SizeFieldPos) | ((uintptr_t)card_in_region << card_pos);\n+  uintptr_t res = (((uintptr_t)orig_value & ~SizeFieldMask) | value);\n+  return (CardSetPtr)res;\n+}\n+\n+inline G1AddCardResult G1CardSetInlinePtr::add(uint card_idx, uint bits_per_card, uint max_cards_in_inline_ptr) {\n+  assert(_value_addr != nullptr, \"No value address available, cannot add to set.\");\n+\n+  while (true) {\n+    uint num_elems = num_cards_in(_value);\n+    \/\/ Check if the card is already stored in the pointer.\n+    if (contains(card_idx, bits_per_card)) {\n+      return Found;\n+    }\n+    \/\/ Check if there is actually enough space.\n+    if (num_elems >= max_cards_in_inline_ptr) {\n+      return Overflow;\n+    }\n+    CardSetPtr new_value = merge(_value, card_idx, num_elems, bits_per_card);\n+    CardSetPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    if (_value == old_value) {\n+      return Added;\n+    }\n+    \/\/ Update values and retry.\n+    _value = old_value;\n+    \/\/ The value of the pointer may have changed to something different than\n+    \/\/ an inline card set. Exit then instead of overwriting.\n+    if (G1CardSet::card_set_type(_value) != G1CardSet::CardSetInlinePtr) {\n+      return Overflow;\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetInlinePtr::contains(uint card_idx, uint bits_per_card) {\n+  uint num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  \/\/ Check if the card is already stored in the pointer.\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    if ((value & card_mask) == card_idx) {\n+      return true;\n+    }\n+    value >>= bits_per_card;\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetInlinePtr::iterate(CardVisitor& found, uint bits_per_card) {\n+  uint const num_elems = num_cards_in(_value);\n+  uintptr_t const card_mask = (1 << bits_per_card) - 1;\n+\n+  uintptr_t value = ((uintptr_t)_value) >> card_pos_for(0, bits_per_card);\n+  for (uint cur_idx = 0; cur_idx < num_elems; cur_idx++) {\n+    found(value & card_mask);\n+    value >>= bits_per_card;\n+  }\n+}\n+\n+inline bool G1CardSetContainer::try_increment_refcount() {\n+  uintptr_t old_value = refcount();\n+  while (true) {\n+    if (old_value < 3 || (old_value & 0x1) == 0) {  \/\/ reclaimed,  reference counts are odd numbers starting at 3\n+      return false; \/\/ dead, can't revive.\n+    }\n+\n+    uintptr_t new_value = old_value + 2;\n+    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    if (ref_count == old_value) {\n+      return true;\n+    }\n+    old_value = ref_count;\n+  }\n+}\n+\n+inline uintptr_t G1CardSetContainer::decrement_refcount() {\n+  uintptr_t old_value = refcount();\n+  assert((old_value & 0x1) != 0 && old_value >= 3, \"precondition\");\n+  return Atomic::sub(&_ref_count, 2u);\n+}\n+\n+inline G1CardSetArray::G1CardSetArray(uint card_in_region, EntryCountType num_elems) :\n+  G1CardSetContainer(),\n+  _size(num_elems),\n+  _num_entries(1) {\n+  assert(_size > 0, \"CardSetArray of size 0 not supported.\");\n+  assert(_size < LockBitMask, \"Only support CardSetArray of size %u or smaller.\", LockBitMask - 1);\n+  _data[0] = card_in_region;\n+}\n+\n+inline G1CardSetArray::G1CardSetArrayLocker::G1CardSetArrayLocker(EntryCountType volatile* value) :\n+  _value(value),\n+  _success(false) {\n+  SpinYield s;\n+  EntryCountType original_value = (*_value) & EntryMask;\n+  while (true) {\n+    EntryCountType old_value = Atomic::cmpxchg(_value,\n+                                               original_value,\n+                                               (EntryCountType)(original_value | LockBitMask));\n+    if (old_value == original_value) {\n+      \/\/ Succeeded locking the array.\n+      _original_value = original_value;\n+      break;\n+    }\n+    \/\/ Failed. Retry (with the lock bit stripped again).\n+    original_value = old_value & EntryMask;\n+    s.wait();\n+  }\n+}\n+\n+inline G1AddCardResult G1CardSetArray::add(uint card_idx) {\n+  assert(card_idx < (1u << (sizeof(_data[0]) * BitsPerByte)),\n+         \"Card index %u does not fit card element.\", card_idx);\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType idx = 0;\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Since we did not find the card, lock.\n+  G1CardSetArrayLocker x(&_num_entries);\n+\n+  \/\/ Reload number of entries from the G1CardSetArrayLocker as it might have changed.\n+  \/\/ It already read the actual value with the necessary synchronization.\n+  num_entries = x.num_entries();\n+  \/\/ Look if the elements added while waiting for the lock are the same as our card.\n+  for (; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return Found;\n+    }\n+  }\n+\n+  \/\/ Check if there is space left.\n+  if (num_entries == _size) {\n+    return Overflow;\n+  }\n+\n+  _data[num_entries] = card_idx;\n+\n+  x.inc_num_entries();\n+\n+  return Added;\n+}\n+\n+inline bool G1CardSetArray::contains(uint card_idx) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    if (_data[idx] == card_idx) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardVisitor>\n+void G1CardSetArray::iterate(CardVisitor& found) {\n+  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  for (EntryCountType idx = 0; idx < num_entries; idx++) {\n+    found(_data[idx]);\n+  }\n+}\n+\n+inline G1CardSetBitMap::G1CardSetBitMap(uint card_in_region, uint size_in_bits) :\n+  G1CardSetContainer(), _num_bits_set(1) {\n+  assert(size_in_bits % (sizeof(_bits[0]) * BitsPerByte) == 0,\n+         \"Size %u should be aligned to bitmap word size.\", size_in_bits);\n+  BitMapView bm(_bits, size_in_bits);\n+  bm.clear();\n+  bm.set_bit(card_in_region);\n+}\n+\n+inline G1AddCardResult G1CardSetBitMap::add(uint card_idx, size_t threshold, size_t size_in_bits) {\n+  BitMapView bm(_bits, size_in_bits);\n+  if (_num_bits_set >= threshold) {\n+    return bm.at(card_idx) ? Found : Overflow;\n+  }\n+  if (bm.par_set_bit(card_idx)) {\n+    Atomic::inc(&_num_bits_set, memory_order_relaxed);\n+    return Added;\n+  }\n+  return Found;\n+}\n+\n+template <class CardVisitor>\n+inline void G1CardSetBitMap::iterate(CardVisitor& found, size_t size_in_bits, uint offset) {\n+  BitMapView bm(_bits, size_in_bits);\n+  BitMap::idx_t idx = bm.get_next_one_offset(0);\n+  while (idx != size_in_bits) {\n+    found((offset | (uint)idx));\n+    idx = bm.get_next_one_offset(idx + 1);\n+  }\n+}\n+\n+inline G1CardSetHowl::G1CardSetHowl(EntryCountType card_in_region, G1CardSetConfiguration* config) :\n+  G1CardSetContainer(),\n+  _num_entries((config->num_cards_in_array() + 1)) \/* Card Transfer will not increment _num_entries *\/ {\n+  EntryCountType num_buckets = config->num_buckets_in_howl();\n+  EntryCountType bucket = config->howl_bucket_index(card_in_region);\n+  for (uint i = 0; i < num_buckets; ++i) {\n+    _buckets[i] = G1CardSetInlinePtr();\n+    if (i == bucket) {\n+      G1CardSetInlinePtr value(&_buckets[i], _buckets[i]);\n+      value.add(card_in_region, config->inline_ptr_bits_per_card(), config->num_cards_in_inline_ptr());\n+    }\n+  }\n+}\n+\n+inline bool G1CardSetHowl::contains(uint card_idx, G1CardSetConfiguration* config) {\n+  EntryCountType bucket = config->howl_bucket_index(card_idx);\n+  CardSetPtr* array_entry = get_card_set_addr(bucket);\n+  CardSetPtr card_set = Atomic::load_acquire(array_entry);\n+\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetArrayOfCards : {\n+      return G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->contains(card_idx);\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      uint card_offset = config->howl_bitmap_offset(card_idx);\n+      return G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->contains(card_offset, config->num_cards_in_howl_bitmap());\n+    }\n+    case G1CardSet::CardSetInlinePtr: {\n+      G1CardSetInlinePtr ptr(card_set);\n+      return ptr.contains(card_idx, config->inline_ptr_bits_per_card());\n+    }\n+    case G1CardSet::CardSetHowl: {\/\/ Fullcard set entry\n+      assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate(CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  for (uint i = 0; i < config->num_buckets_in_howl(); ++i) {\n+    iterate_cardset(_buckets[i], i, found, config);\n+  }\n+}\n+\n+template <class CardSetPtrVisitor>\n+inline void G1CardSetHowl::iterate(CardSetPtrVisitor& found, uint num_card_sets) {\n+  for (uint i = 0; i < num_card_sets; ++i) {\n+    found(&_buckets[i]);\n+  }\n+}\n+\n+template <class CardOrRangeVisitor>\n+inline void G1CardSetHowl::iterate_cardset(CardSetPtr const card_set, uint index, CardOrRangeVisitor& found, G1CardSetConfiguration* config) {\n+  switch (G1CardSet::card_set_type(card_set)) {\n+    case G1CardSet::CardSetInlinePtr: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlInline)) {\n+        G1CardSetInlinePtr ptr(card_set);\n+        ptr.iterate(found, config->inline_ptr_bits_per_card());\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetArrayOfCards : {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlArrayOfCards)) {\n+        G1CardSet::card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetBitMap: {\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlBitmap)) {\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        G1CardSet::card_set_ptr<G1CardSetBitMap>(card_set)->iterate(found, config->num_cards_in_howl_bitmap(), offset);\n+      }\n+      return;\n+    }\n+    case G1CardSet::CardSetHowl: { \/\/ actually FullCardSet\n+      if (found.start_iterate(G1GCPhaseTimes::MergeRSHowlFull)) {\n+        assert(card_set == G1CardSet::FullCardSet, \"Must be\");\n+        uint offset = index << config->log2_num_cards_in_howl_bitmap();\n+        for (uint i = 0; i < config->max_cards_in_region(); i++) {\n+          found((offset | (uint)i));\n+        }\n+      }\n+      return;\n+    }\n+  }\n+}\n+\n+inline G1CardSetHowl::EntryCountType G1CardSetHowl::num_buckets(size_t size_in_bits, size_t num_cards_in_array, size_t max_num_buckets) {\n+  size_t size_bitmap_bytes = BitMap::calc_size_in_words(size_in_bits) * BytesPerWord;\n+  \/\/ Ensure that in the worst case arrays consume half the memory size\n+  \/\/ of storing the entire bitmap\n+  size_t max_size_arrays_bytes = size_bitmap_bytes \/ 2;\n+  size_t size_array_bytes = num_cards_in_array * sizeof(G1CardSetArray::EntryDataType);\n+  size_t num_arrays = max_size_arrays_bytes \/ size_array_bytes;\n+  \/\/ We use shifts and masks for indexing the array. So round down to the next\n+  \/\/ power of two to not use more than expected memory.\n+  num_arrays = round_down_power_of_2(MAX2((size_t)1, MIN2(num_arrays, max_num_buckets)));\n+  return (EntryCountType)num_arrays;\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETCONTAINERS_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"heapRegionRemSet.hpp\"\n+#include \"ci\/ciUtilities.hpp\"\n+\n+constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n+\n+const char* G1CardSetFreeMemoryTask::get_state_name(State value) const {\n+  return _state_names[static_cast<std::underlying_type_t<State>>(value)];\n+}\n+\n+bool G1CardSetFreeMemoryTask::deadline_exceeded(jlong deadline) {\n+  return os::elapsed_counter() >= deadline;\n+}\n+\n+static size_t keep_size(size_t free, size_t used, double percent) {\n+  size_t to_keep = used * percent;\n+  return MIN2(free, to_keep);\n+}\n+\n+bool G1CardSetFreeMemoryTask::calculate_return_infos(jlong deadline) {\n+  \/\/ Ignore the deadline in this step as it is very short.\n+\n+  G1CardSetMemoryStats used = _total_used;\n+  G1CardSetMemoryStats free = G1CardSetFreePool::free_list_sizes();\n+\n+  _return_info = new G1ReturnMemoryProcessorSet(used.num_pools());\n+  for (uint i = 0; i < used.num_pools(); i++) {\n+    size_t return_to_vm_size = keep_size(free._num_mem_sizes[i],\n+                                         used._num_mem_sizes[i],\n+                                         G1RemSetFreeMemoryKeepExcessRatio);\n+    log_trace(gc, task)(\"Card Set Free Memory: Type %s: Free: %zu (%zu) \"\n+                        \"Used: %zu Keep: %zu\",\n+                        G1CardSetConfiguration::mem_object_type_name_str(i),\n+                        free._num_mem_sizes[i], free._num_buffers[i],\n+                        used._num_mem_sizes[i], return_to_vm_size);\n+\n+    _return_info->append(new G1ReturnMemoryProcessor(return_to_vm_size));\n+  }\n+\n+  G1CardSetFreePool::update_unlink_processors(_return_info);\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_vm(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_vm()) {\n+      if (info->return_to_vm(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::return_memory_to_os(jlong deadline) {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+    G1ReturnMemoryProcessor* info = _return_info->at(i);\n+    if (!info->finished_return_to_os()) {\n+      if (info->return_to_os(deadline)) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::cleanup_return_infos() {\n+  for (int i = 0; i < _return_info->length(); i++) {\n+     G1ReturnMemoryProcessor* info = _return_info->at(i);\n+     delete info;\n+  }\n+  delete _return_info;\n+\n+  _return_info = nullptr;\n+  return false;\n+}\n+\n+bool G1CardSetFreeMemoryTask::free_excess_card_set_memory() {\n+  jlong start = os::elapsed_counter();\n+  jlong end = start +\n+              (os::elapsed_frequency() \/ 1000) * G1RemSetFreeMemoryStepDurationMillis;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step start %1.3f end %1.3f\",\n+                      TimeHelper::counter_to_millis(start), TimeHelper::counter_to_millis(end));\n+\n+  State next_state;\n+\n+  do {\n+    switch (_state) {\n+      case State::CalculateUsed: {\n+        if (calculate_return_infos(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToVM;\n+        break;\n+      }\n+      case State::ReturnToVM: {\n+        if (return_memory_to_vm(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::ReturnToOS;\n+        break;\n+      }\n+      case State::ReturnToOS: {\n+        if (return_memory_to_os(end)) {\n+          next_state = _state;\n+          return true;\n+        }\n+        next_state = State::Cleanup;\n+        break;\n+      }\n+      case State::Cleanup: {\n+        cleanup_return_infos();\n+        next_state = State::Inactive;\n+        break;\n+      }\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n+    }\n+\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Step took %1.3fms, done %s\",\n+                      TimeHelper::counter_to_millis(os::elapsed_counter() - start),\n+                      bool_to_str(_state == State::CalculateUsed));\n+\n+  return is_active();\n+}\n+\n+void G1CardSetFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1CardSetFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n+}\n+\n+jlong G1CardSetFreeMemoryTask::reschedule_delay_ms() const {\n+  return G1RemSetFreeMemoryRescheduleDelayMillis;\n+}\n+\n+G1CardSetFreeMemoryTask::G1CardSetFreeMemoryTask(const char* name) :\n+  G1ServiceTask(name), _state(State::CalculateUsed), _return_info(nullptr) { }\n+\n+void G1CardSetFreeMemoryTask::execute() {\n+  SuspendibleThreadSetJoiner sts;\n+\n+  if (free_excess_card_set_memory()) {\n+    schedule(reschedule_delay_ms());\n+  }\n+}\n+\n+void G1CardSetFreeMemoryTask::notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                                               G1CardSetMemoryStats* collection_set_candidate_stats) {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  _total_used = *young_gen_stats;\n+  _total_used.add(*collection_set_candidate_stats);\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+#define SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n+\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class G1CardSetBuffer;\n+\n+\/\/ Task handling deallocation of free card set memory.\n+class G1CardSetFreeMemoryTask : public G1ServiceTask {\n+\n+  enum class State : uint {\n+    Inactive,\n+    CalculateUsed,\n+    ReturnToVM,\n+    ReturnToOS,\n+    Cleanup\n+  };\n+\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n+  const char* get_state_name(State value) const;\n+\n+  State _state;\n+\n+  \/\/ Current total card set memory usage.\n+  G1CardSetMemoryStats _total_used;\n+\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessor G1ReturnMemoryProcessor;\n+  typedef G1CardSetFreePool::G1ReturnMemoryProcessorSet G1ReturnMemoryProcessorSet;\n+\n+  G1ReturnMemoryProcessorSet* _return_info;\n+\n+  \/\/ Returns whether the given deadline has passed.\n+  bool deadline_exceeded(jlong deadline);\n+\n+  \/\/ Methods for the tasks to be done. They all return true if that step has\n+  \/\/ completed.\n+  bool calculate_return_infos(jlong deadline);\n+  bool return_memory_to_vm(jlong deadline);\n+  bool return_memory_to_os(jlong deadline);\n+  bool cleanup_return_infos();\n+\n+  \/\/ Free excess card set memory, main method. Returns true if there is more work\n+  \/\/ to do.\n+  bool free_excess_card_set_memory();\n+\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n+  \/\/ The delay used to reschedule this task if not all work has been completed.\n+  jlong reschedule_delay_ms() const;\n+\n+public:\n+  explicit G1CardSetFreeMemoryTask(const char* name);\n+\n+  void execute() override;\n+\n+  \/\/ Notify the task of new used remembered set memory statistics for the young\n+  \/\/ generation and the collection set candidate sets.\n+  void notify_new_stats(G1CardSetMemoryStats* young_gen_stats,\n+                        G1CardSetMemoryStats* collection_set_candidate_stats);\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETFREEMEMORYTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+G1CardSetBuffer::G1CardSetBuffer(uint elem_size, uint num_instances, G1CardSetBuffer* next) :\n+    _elem_size(elem_size), _num_elems(num_instances), _next(next), _next_allocate(0) {\n+\n+  _buffer = NEW_C_HEAP_ARRAY(char, (size_t)_num_elems * elem_size, mtGCCardSet);\n+}\n+\n+G1CardSetBuffer::~G1CardSetBuffer() {\n+  FREE_C_HEAP_ARRAY(mtGCCardSet, _buffer);\n+}\n+\n+void* G1CardSetBuffer::get_new_buffer_elem() {\n+  if (_next_allocate >= _num_elems) {\n+    return nullptr;\n+  }\n+  uint result = Atomic::fetch_and_add(&_next_allocate, 1u, memory_order_relaxed);\n+  if (result >= _num_elems) {\n+    return nullptr;\n+  }\n+  void* r = _buffer + (uint)result * _elem_size;\n+  return r;\n+}\n+\n+void G1CardSetBufferList::bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size) {\n+  _list.prepend(first, last);\n+  Atomic::add(&_num_buffers, num, memory_order_relaxed);\n+  Atomic::add(&_mem_size, mem_size, memory_order_relaxed);\n+}\n+\n+void G1CardSetBufferList::print_on(outputStream* out, const char* prefix) {\n+  out->print_cr(\"%s: buffers %zu size %zu\", prefix, Atomic::load(&_num_buffers), Atomic::load(&_mem_size));\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get() {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop();\n+  if (result != nullptr) {\n+    Atomic::dec(&_num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+G1CardSetBuffer* G1CardSetBufferList::get_all(size_t& num_buffers, size_t& mem_size) {\n+  GlobalCounter::CriticalSection cs(Thread::current());\n+\n+  G1CardSetBuffer* result = _list.pop_all();\n+  num_buffers = Atomic::load(&_num_buffers);\n+  mem_size = Atomic::load(&_mem_size);\n+\n+  if (result != nullptr) {\n+    Atomic::sub(&_num_buffers, num_buffers, memory_order_relaxed);\n+    Atomic::sub(&_mem_size, mem_size, memory_order_relaxed);\n+  }\n+  return result;\n+}\n+\n+void G1CardSetBufferList::free_all() {\n+  size_t num_freed = 0;\n+  size_t mem_size_freed = 0;\n+  G1CardSetBuffer* cur;\n+\n+  while ((cur = _list.pop()) != nullptr) {\n+    mem_size_freed += cur->mem_size();\n+    num_freed++;\n+    delete cur;\n+  }\n+\n+  Atomic::sub(&_num_buffers, num_freed, memory_order_relaxed);\n+  Atomic::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n+}\n+\n+template <class Elem>\n+G1CardSetAllocator<Elem>::G1CardSetAllocator(const char* name,\n+                                             const G1CardSetAllocOptions& buffer_options,\n+                                             G1CardSetBufferList* free_buffer_list) :\n+  _alloc_options(buffer_options),\n+  _first(nullptr),\n+  _last(nullptr),\n+  _num_buffers(0),\n+  _mem_size(0),\n+  _free_buffer_list(free_buffer_list),\n+  _transfer_lock(false),\n+  _free_nodes_list(),\n+  _pending_nodes_list(),\n+  _num_pending_nodes(0),\n+  _num_free_nodes(0),\n+  _num_allocated_nodes(0),\n+  _num_available_nodes(0)\n+{\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"Element instance size %u for allocator %s too small\",\n+         elem_size(), name);\n+  assert(_free_buffer_list != nullptr, \"precondition!\");\n+}\n+\n+template <class Elem>\n+bool G1CardSetAllocator<Elem>::try_transfer_pending() {\n+  \/\/ Attempt to claim the lock.\n+  if (Atomic::load_acquire(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+    return false;\n+  }\n+  \/\/ Have the lock; perform the transfer.\n+\n+  \/\/ Claim all the pending nodes.\n+  G1CardSetContainer* first = _pending_nodes_list.pop_all();\n+\n+  if (first != nullptr) {\n+    \/\/ Prepare to add the claimed nodes, and update _num_pending_nodes.\n+    G1CardSetContainer* last = first;\n+    Atomic::load_acquire(&_num_pending_nodes);\n+\n+    uint count = 1;\n+    for (G1CardSetContainer* next = first->next(); next != nullptr; next = next->next()) {\n+      last = next;\n+      ++count;\n+    }\n+\n+    Atomic::sub(&_num_pending_nodes, count);\n+\n+    \/\/ Wait for any in-progress pops to avoid ABA for them.\n+    GlobalCounter::write_synchronize();\n+    \/\/ Add synchronized nodes to _free_node_list.\n+    \/\/ Update count first so there can be no underflow in allocate().\n+    Atomic::add(&_num_free_nodes, count);\n+    _free_nodes_list.prepend(*first, *last);\n+  }\n+  Atomic::release_store(&_transfer_lock, false);\n+  return true;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::free(Elem* elem) {\n+  assert(elem != nullptr, \"precondition\");\n+  assert(elem_size() >= sizeof(G1CardSetContainer), \"size mismatch\");\n+  \/\/ Desired minimum transfer batch size.  There is relatively little\n+  \/\/ importance to the specific number.  It shouldn't be too big, else\n+  \/\/ we're wasting space when the release rate is low.  If the release\n+  \/\/ rate is high, we might accumulate more than this before being\n+  \/\/ able to start a new transfer, but that's okay.  Also note that\n+  \/\/ the allocation rate and the release rate are going to be fairly\n+  \/\/ similar, due to how the buffers are used. - kbarret\n+  uint const trigger_transfer = 10;\n+\n+  uint pending_count = Atomic::add(&_num_pending_nodes, 1u, memory_order_relaxed);\n+\n+  G1CardSetContainer* node =  reinterpret_cast<G1CardSetContainer*>(reinterpret_cast<char*>(elem));\n+\n+  node->set_next(nullptr);\n+  assert(node->next() == nullptr, \"precondition\");\n+\n+  _pending_nodes_list.push(*node);\n+\n+  if (pending_count > trigger_transfer) {\n+    try_transfer_pending();\n+  }\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::drop_all() {\n+  _free_nodes_list.pop_all();\n+  _pending_nodes_list.pop_all();\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+\n+  if (cur != nullptr) {\n+    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+\n+    G1CardSetBuffer* first = cur;\n+#ifdef ASSERT\n+    \/\/ Check list consistency.\n+    G1CardSetBuffer* last = cur;\n+    uint num_buffers = 0;\n+    size_t mem_size = 0;\n+    while (cur != nullptr) {\n+      mem_size += cur->mem_size();\n+      num_buffers++;\n+\n+      G1CardSetBuffer* next = cur->next();\n+      last = cur;\n+      cur = next;\n+    }\n+#endif\n+    assert(num_buffers == _num_buffers, \"Buffer count inconsistent %u %u\", num_buffers, _num_buffers);\n+    assert(mem_size == _mem_size, \"Memory size inconsistent\");\n+    assert(last == _last, \"Inconsistent last element\");\n+\n+    _free_buffer_list->bulk_add(*first, *_last, _num_buffers, _mem_size);\n+  }\n+\n+  _first = nullptr;\n+  _last = nullptr;\n+  _num_available_nodes = 0;\n+  _num_allocated_nodes = 0;\n+  _num_pending_nodes = 0;\n+  _num_buffers = 0;\n+  _mem_size = 0;\n+  _num_free_nodes = 0;\n+}\n+\n+template <class Elem>\n+void G1CardSetAllocator<Elem>::print(outputStream* os) {\n+  os->print(\"MA \" PTR_FORMAT \": %u elems pending (allocated %u available %u) used %.3f highest %u buffers %u size %zu \",\n+                p2i(this), _num_pending_nodes, _num_allocated_nodes, _num_available_nodes, percent_of(_num_allocated_nodes - _num_pending_nodes, _num_available_nodes), _first != nullptr ? _first->num_elems() : 0, _num_buffers, mem_size());\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats(void(*fn)(const void*,uint,size_t&,size_t&), const void* context) {\n+  clear();\n+  for (uint i = 0; i < num_pools(); i++) {\n+    fn(context, i, _num_mem_sizes[i], _num_buffers[i]);\n+  }\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+static void collect_mem_sizes(const void* context, uint i, size_t& mem_size, size_t& num_buffers) {\n+  ((G1CardSetFreePool*)context)->get_size(i, mem_size, num_buffers);\n+}\n+\n+void G1CardSetFreePool::get_size(uint i, size_t& mem_size, size_t& num_buffers) const {\n+  mem_size = _free_lists[i].mem_size();\n+  num_buffers = _free_lists[i].num_buffers();\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  return G1CardSetMemoryStats(collect_mem_sizes, this);\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n+\n+G1CardSetMemoryManager::G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                                               G1CardSetFreePool* free_list_pool) : _config(config) {\n+\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>,\n+                                 _config->num_mem_object_types(),\n+                                 mtGC);\n+  G1CardSetAllocOptions* alloc_options = _config->mem_object_alloc_options();\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainer>(_config->mem_object_type_name_str(i),\n+                                                                 alloc_options[i],\n+                                                                 free_list_pool->free_list(i));\n+  }\n+  FREE_C_HEAP_ARRAY(size_t, alloc_options);\n+}\n+\n+uint G1CardSetMemoryManager::num_mem_object_types() const {\n+  return _config->num_mem_object_types();\n+}\n+\n+\n+G1CardSetMemoryManager::~G1CardSetMemoryManager() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].~G1CardSetAllocator();\n+  }\n+  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainer>, _allocators);\n+}\n+\n+void G1CardSetMemoryManager::free(uint type, void* value) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  _allocators[type].free((G1CardSetContainer*)value);\n+}\n+\n+void G1CardSetMemoryManager::flush() {\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].drop_all();\n+  }\n+}\n+\n+void G1CardSetMemoryManager::print(outputStream* os) {\n+  os->print_cr(\"MM \" PTR_FORMAT \" size %zu\", p2i(this), sizeof(*this));\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    _allocators[i].print(os);\n+  }\n+}\n+\n+size_t G1CardSetMemoryManager::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].mem_size();\n+  }\n+  return sizeof(*this) -\n+    (sizeof(G1CardSetAllocator<G1CardSetContainer>) * num_mem_object_types()) +\n+    result;\n+}\n+\n+size_t G1CardSetMemoryManager::wasted_mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result += _allocators[i].wasted_mem_size();\n+  }\n+  return result;\n+}\n+\n+G1CardSetMemoryStats G1CardSetMemoryManager::memory_stats() const {\n+  G1CardSetMemoryStats result;\n+  for (uint i = 0; i < num_mem_object_types(); i++) {\n+    result._num_mem_sizes[i] += _allocators[i].mem_size();\n+    result._num_buffers[i] += _allocators[i].num_buffers();\n+  }\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+\n+class G1CardSetConfiguration;\n+class outputStream;\n+\n+\/\/ Collects G1CardSetAllocator options\/heuristics. Called by G1CardSetAllocator\n+\/\/ to determine the next size of the allocated G1CardSetBuffer.\n+class G1CardSetAllocOptions {\n+  uint _elem_size;\n+  uint _initial_num_elems;\n+  \/\/ Defines a limit to the number of elements in the buffer\n+  uint _max_num_elems;\n+\n+  uint exponential_expand(uint prev_num_elems) {\n+    return clamp(prev_num_elems * 2, _initial_num_elems, _max_num_elems);\n+  }\n+\n+public:\n+  static const uint BufferAlignment = 8;\n+  static const uint MinimumBufferSize = 8;\n+  static const uint MaximumBufferSize =  UINT_MAX \/ 2;\n+\n+  G1CardSetAllocOptions(uint elem_size, uint initial_num_elems = MinimumBufferSize, uint max_num_elems = MaximumBufferSize) :\n+    _elem_size(align_up(elem_size, BufferAlignment)),\n+    _initial_num_elems(initial_num_elems),\n+    _max_num_elems(max_num_elems) {\n+  }\n+\n+  uint next_num_elems(uint prev_num_elems) {\n+    return exponential_expand(prev_num_elems);\n+  }\n+\n+  uint elem_size () const {return _elem_size;}\n+};\n+\n+\/\/ A single buffer\/arena containing _num_elems blocks of memory of _elem_size.\n+\/\/ G1CardSetBuffers can be linked together using a singly linked list.\n+class G1CardSetBuffer : public CHeapObj<mtGCCardSet> {\n+  uint _elem_size;\n+  uint _num_elems;\n+\n+  G1CardSetBuffer* volatile _next;\n+\n+  char* _buffer;  \/\/ Actual data.\n+\n+  \/\/ Index into the next free block to allocate into. Full if equal (or larger)\n+  \/\/ to _num_elems (can be larger because we atomically increment this value and\n+  \/\/ check only afterwards if the allocation has been successful).\n+  uint volatile _next_allocate;\n+\n+public:\n+  G1CardSetBuffer(uint elem_size, uint num_elems, G1CardSetBuffer* next);\n+  ~G1CardSetBuffer();\n+\n+  G1CardSetBuffer* volatile* next_addr() { return &_next; }\n+\n+  void* get_new_buffer_elem();\n+\n+  uint num_elems() const { return _num_elems; }\n+\n+  G1CardSetBuffer* next() const { return _next; }\n+\n+  void set_next(G1CardSetBuffer* next) {\n+    assert(next != this, \" loop condition\");\n+    _next = next;\n+  }\n+\n+  void reset(G1CardSetBuffer* next) {\n+    _next_allocate = 0;\n+    assert(next != this, \" loop condition\");\n+    set_next(next);\n+    memset((void*)_buffer, 0, (size_t)_num_elems * _elem_size);\n+  }\n+\n+  uint elem_size() const { return _elem_size; }\n+\n+  size_t mem_size() const { return sizeof(*this) + (size_t)_num_elems * _elem_size; }\n+\n+  bool is_full() const { return _next_allocate >= _num_elems; }\n+};\n+\n+\/\/ Set of (free) G1CardSetBuffers. The assumed usage is that allocation\n+\/\/ to it and removal of elements is strictly separate, but every action may be\n+\/\/ performed by multiple threads at the same time.\n+\/\/ Counts and memory usage are current on a best-effort basis if accessed concurrently.\n+class G1CardSetBufferList {\n+  static G1CardSetBuffer* volatile* next_ptr(G1CardSetBuffer& node) {\n+    return node.next_addr();\n+  }\n+  typedef LockFreeStack<G1CardSetBuffer, &next_ptr> NodeStack;\n+\n+  NodeStack _list;\n+\n+  volatile size_t _num_buffers;\n+  volatile size_t _mem_size;\n+\n+public:\n+  G1CardSetBufferList() : _list(), _num_buffers(0), _mem_size(0) { }\n+  ~G1CardSetBufferList() { free_all(); }\n+\n+  void bulk_add(G1CardSetBuffer& first, G1CardSetBuffer& last, size_t num, size_t mem_size);\n+  void add(G1CardSetBuffer& elem) { _list.prepend(elem); }\n+\n+  G1CardSetBuffer* get();\n+  G1CardSetBuffer* get_all(size_t& num_buffers, size_t& mem_size);\n+\n+  \/\/ Give back all memory to the OS.\n+  void free_all();\n+\n+  void print_on(outputStream* out, const char* prefix = \"\");\n+\n+  size_t num_buffers() const { return Atomic::load(&_num_buffers); }\n+  size_t mem_size() const { return Atomic::load(&_mem_size); }\n+};\n+\n+\/\/ Arena-like allocator for (card set) heap memory objects (Elem elements).\n+\/\/\n+\/\/ Actual allocation from the C heap occurs on G1CardSetBuffer basis, i.e. sets\n+\/\/ of elements. The assumed allocation pattern for these G1CardSetBuffer elements\n+\/\/ is assumed to be strictly two-phased:\n+\/\/\n+\/\/ - in the first phase, G1CardSetBuffers are allocated from the C heap (or a free\n+\/\/ list given at initialization time). This allocation may occur in parallel. This\n+\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n+\/\/\n+\/\/ - in the second phase, G1CardSetBuffers are given back in bulk to the free list.\n+\/\/ This is typically done during a GC pause.\n+\/\/\n+\/\/ Some third party is responsible for giving back memory from the free list to\n+\/\/ the operating system.\n+\/\/\n+\/\/ Allocation and deallocation in the first phase on G1CardSetContainer basis\n+\/\/ may occur by multiple threads at once.\n+\/\/\n+\/\/ Allocation occurs from an internal free list of G1CardSetContainers first,\n+\/\/ only then trying to bump-allocate from the current G1CardSetBuffer. If there is\n+\/\/ none, this class allocates a new G1CardSetBuffer (allocated from the C heap,\n+\/\/ asking the G1CardSetAllocOptions instance about sizes etc) and uses that one.\n+\/\/\n+\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainers\n+\/\/ within all G1CardSetBuffer instances allocated so far. It uses a separate\n+\/\/ pending list and global synchronization to avoid the ABA problem when the\n+\/\/ user frees a memory object.\n+\/\/\n+\/\/ The class also manages a few counters for statistics using atomic operations.\n+\/\/ Their values are only consistent within each other with extra global\n+\/\/ synchronization.\n+\/\/\n+\/\/ Since it is expected that every CardSet (and in extension each region) has its\n+\/\/ own set of allocators, there is intentionally no padding between them to save\n+\/\/ memory.\n+template <class Elem>\n+class G1CardSetAllocator {\n+  \/\/ G1CardSetBuffer management.\n+\n+  \/\/ G1CardSetAllocOptions provides parameters for allocation buffer\n+  \/\/ sizing and expansion.\n+  G1CardSetAllocOptions _alloc_options;\n+\n+  G1CardSetBuffer* volatile _first;       \/\/ The (start of the) list of all buffers.\n+  G1CardSetBuffer* _last;                 \/\/ The last element of the list of all buffers.\n+  volatile uint _num_buffers;             \/\/ Number of assigned buffers to this allocator.\n+  volatile size_t _mem_size;              \/\/ Memory used by all buffers.\n+\n+  G1CardSetBufferList* _free_buffer_list; \/\/ The global free buffer list to\n+                                          \/\/ preferentially get new buffers from.\n+\n+  \/\/ G1CardSetContainer node management within the G1CardSetBuffers allocated\n+  \/\/ by this allocator.\n+\n+  static G1CardSetContainer* volatile* next_ptr(G1CardSetContainer& node);\n+  typedef LockFreeStack<G1CardSetContainer, &next_ptr> NodeStack;\n+\n+  volatile bool _transfer_lock;\n+  NodeStack _free_nodes_list;\n+  NodeStack _pending_nodes_list;\n+\n+  volatile uint _num_pending_nodes;   \/\/ Number of nodes in the pending list.\n+  volatile uint _num_free_nodes;      \/\/ Number of nodes in the free list.\n+\n+  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n+  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n+\n+  \/\/ Try to transfer nodes from _pending_nodes_list to _free_nodes_list, with a\n+  \/\/ synchronization delay for any in-progress pops from the _free_nodes_list\n+  \/\/ to solve ABA here.\n+  bool try_transfer_pending();\n+\n+  uint num_free_elems() const;\n+\n+  G1CardSetBuffer* create_new_buffer(G1CardSetBuffer* const prev);\n+\n+  uint elem_size() const { return _alloc_options.elem_size(); }\n+\n+public:\n+  G1CardSetAllocator(const char* name,\n+                     const G1CardSetAllocOptions& buffer_options,\n+                     G1CardSetBufferList* free_buffer_list);\n+  ~G1CardSetAllocator() {\n+    drop_all();\n+  }\n+\n+  Elem* allocate();\n+  void free(Elem* elem);\n+\n+  \/\/ Deallocate all buffers to the free buffer list and reset this allocator. Must\n+  \/\/ be called in a globally synchronized area.\n+  void drop_all();\n+\n+  uint num_buffers() const;\n+\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      num_buffers() * sizeof(G1CardSetBuffer) + (size_t)_num_available_nodes * elem_size();\n+  }\n+\n+  size_t wasted_mem_size() const {\n+    return ((size_t)_num_available_nodes - (_num_allocated_nodes - _num_pending_nodes)) * elem_size();\n+  }\n+\n+  void print(outputStream* os);\n+};\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+  \/\/ For every element in the set (indicated by i), call fn to provide the\n+  \/\/ memory size and number of buffers for that i'th buffer list.\n+  G1CardSetMemoryStats(void (*fn)(const void* context, uint i, size_t& mem_size, size_t& num_buffers), const void* context);\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i) {\n+    assert(i < _num_free_lists, \"must be\");\n+    return &_free_lists[i];\n+  }\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  \/\/ Return sizes for free list i in this free list pool.\n+  void get_size(uint i, size_t& mem_size, size_t& num_buffers) const;\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+class G1CardSetMemoryManager : public CHeapObj<mtGCCardSet> {\n+  G1CardSetConfiguration* _config;\n+\n+  G1CardSetAllocator<G1CardSetContainer>* _allocators;\n+\n+  uint num_mem_object_types() const;\n+public:\n+  G1CardSetMemoryManager(G1CardSetConfiguration* config,\n+                         G1CardSetFreePool* free_list_pool);\n+\n+  virtual ~G1CardSetMemoryManager();\n+\n+  \/\/ Allocate and free a memory object of given type.\n+  inline uint8_t* allocate(uint type);\n+  void free(uint type, void* value);\n+\n+  \/\/ Allocate and free a hash table node.\n+  inline uint8_t* allocate_node();\n+  inline void free_node(void* value);\n+\n+  void flush();\n+\n+  void print(outputStream* os);\n+\n+  size_t mem_size() const;\n+  size_t wasted_mem_size() const;\n+\n+  G1CardSetMemoryStats memory_stats() const;\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+#define SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+template <class Elem>\n+G1CardSetContainer* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainer& node) {\n+  return node.next_addr();\n+}\n+\n+template <class Elem>\n+G1CardSetBuffer* G1CardSetAllocator<Elem>::create_new_buffer(G1CardSetBuffer* const prev) {\n+\n+  \/\/ Take an existing buffer if available.\n+  G1CardSetBuffer* next = _free_buffer_list->get();\n+  if (next == nullptr) {\n+    uint prev_num_elems = (prev != nullptr) ? prev->num_elems() : 0;\n+    uint num_elems = _alloc_options.next_num_elems(prev_num_elems);\n+    next = new G1CardSetBuffer(elem_size(), num_elems, prev);\n+  } else {\n+    assert(elem_size() == next->elem_size() , \"Mismatch %d != %d Elem %zu\", elem_size(), next->elem_size(), sizeof(Elem));\n+    next->reset(prev);\n+  }\n+\n+  \/\/ Install it as current allocation buffer.\n+  G1CardSetBuffer* old = Atomic::cmpxchg(&_first, prev, next);\n+  if (old != prev) {\n+    \/\/ Somebody else installed the buffer, use that one.\n+    delete next;\n+    return old;\n+  } else {\n+    \/\/ Did we install the first element in the list? If so, this is also the last.\n+    if (prev == nullptr) {\n+      _last = next;\n+    }\n+    \/\/ Successfully installed the buffer into the list.\n+    Atomic::inc(&_num_buffers, memory_order_relaxed);\n+    Atomic::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n+    Atomic::add(&_num_available_nodes, next->num_elems(), memory_order_relaxed);\n+    return next;\n+  }\n+}\n+\n+template <class Elem>\n+Elem* G1CardSetAllocator<Elem>::allocate() {\n+  assert(elem_size() > 0, \"instance size not set.\");\n+\n+  if (num_free_elems() > 0) {\n+    \/\/ Pop under critical section to deal with ABA problem\n+    \/\/ Other solutions to the same problem are more complicated (ref counting, HP)\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+\n+    G1CardSetContainer* node = _free_nodes_list.pop();\n+    if (node != nullptr) {\n+      Elem* elem = reinterpret_cast<Elem*>(reinterpret_cast<char*>(node));\n+      Atomic::sub(&_num_free_nodes, 1u);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+  }\n+\n+  G1CardSetBuffer* cur = Atomic::load_acquire(&_first);\n+  if (cur == nullptr) {\n+    cur = create_new_buffer(cur);\n+  }\n+\n+  while (true) {\n+    Elem* elem = (Elem*)cur->get_new_buffer_elem();\n+    if (elem != nullptr) {\n+      Atomic::inc(&_num_allocated_nodes, memory_order_relaxed);\n+      guarantee(is_aligned(elem, 8), \"result \" PTR_FORMAT \" not aligned\", p2i(elem));\n+      return elem;\n+    }\n+    \/\/ The buffer is full. Next round.\n+    assert(cur->is_full(), \"must be\");\n+    cur = create_new_buffer(cur);\n+  }\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate(uint type) {\n+  assert(type < num_mem_object_types(), \"must be\");\n+  return (uint8_t*)_allocators[type].allocate();\n+}\n+\n+inline uint8_t* G1CardSetMemoryManager::allocate_node() {\n+  return allocate(0);\n+}\n+\n+inline void G1CardSetMemoryManager::free_node(void* value) {\n+  free(0, value);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_buffers() const {\n+  return Atomic::load(&_num_buffers);\n+}\n+\n+template <class Elem>\n+inline uint G1CardSetAllocator<Elem>::num_free_elems() const {\n+  return Atomic::load(&_num_free_nodes);\n+}\n+\n+#endif \/\/ SHARE_GC_G1_G1CARDSETMEMORY_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -105,1 +105,1 @@\n-  inline size_t mark_region_dirty(size_t start_card_index, size_t num_cards);\n+  inline size_t mark_range_dirty(size_t start_card_index, size_t num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-inline size_t G1CardTable::mark_region_dirty(size_t start_card_index, size_t num_cards) {\n+inline size_t G1CardTable::mark_range_dirty(size_t start_card_index, size_t num_cards) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTable.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeBlobClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -71,1 +72,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -150,1 +151,1 @@\n-  return new HeapRegion(hrs_index, bot(), mr);\n+  return new HeapRegion(hrs_index, bot(), mr, &_card_set_config);\n@@ -1439,0 +1440,1 @@\n+  _free_card_set_memory_task(NULL),\n@@ -1475,0 +1477,1 @@\n+  _card_set_config(),\n@@ -1480,1 +1483,1 @@\n-  _regions_failed_evacuation(NULL),\n+  _regions_failed_evacuation(mtGC),\n@@ -1744,0 +1747,3 @@\n+  _free_card_set_memory_task = new G1CardSetFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_card_set_memory_task);\n+\n@@ -1773,1 +1779,1 @@\n-  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+  _regions_failed_evacuation.resize(max_regions());\n@@ -2624,0 +2630,3 @@\n+\n+  _free_card_set_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                               &_collection_set_candidates_card_set_stats);\n@@ -2845,0 +2854,3 @@\n+  if (evacuation_failed()) {\n+    type = (G1HeapVerifier::G1VerifyType)(type | G1HeapVerifier::G1VerifyYoungEvacFail);\n+  }\n@@ -2961,1 +2973,0 @@\n-\n@@ -2970,1 +2981,0 @@\n-\n@@ -2975,1 +2985,0 @@\n-\n@@ -3064,6 +3073,0 @@\n-    \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-    \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-    \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-    \/\/ before any GC notifications are raised.\n-    g1mm()->update_sizes();\n-\n@@ -3322,0 +3325,9 @@\n+bool G1CollectedHeap::should_sample_collection_set_candidates() const {\n+  G1CollectionSetCandidates* candidates = G1CollectedHeap::heap()->collection_set()->candidates();\n+  return candidates != NULL && candidates->num_remaining() > 0;\n+}\n+\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1CardSetMemoryStats& stats) {\n+  _collection_set_candidates_card_set_stats = stats;\n+}\n+\n@@ -3329,0 +3341,11 @@\n+    G1CardSetMemoryStats _card_set_stats;\n+\n+    void sample_card_set_size(HeapRegion* hr) {\n+      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n+      \/\/ the policy to give back memory to the OS keep the most recent amount of\n+      \/\/ memory for these regions.\n+      if (hr->is_young() || hr->is_starts_humongous()) {\n+        _card_set_stats.add(hr->rem_set()->card_set_memory_stats());\n+      }\n+    }\n+\n@@ -3401,0 +3424,2 @@\n+      sample_card_set_size(hr);\n+\n@@ -3431,0 +3456,4 @@\n+\n+    G1CardSetMemoryStats card_set_stats() const {\n+      return _card_set_stats;\n+    }\n@@ -3437,0 +3466,3 @@\n+\n+  G1CardSetMemoryStats _all_card_set_stats;\n+\n@@ -3448,0 +3480,3 @@\n+\n+    MutexLocker x(ParGCRareEvent_lock, Mutex::_no_safepoint_check_flag);\n+    _all_card_set_stats.add(cl.card_set_stats());\n@@ -3465,0 +3500,4 @@\n+\n+  G1CardSetMemoryStats all_card_set_stats() const {\n+    return _all_card_set_stats;\n+  }\n@@ -3473,1 +3512,1 @@\n-  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n+  _regions_failed_evacuation.clear();\n@@ -3492,0 +3531,2 @@\n+    _young_gen_card_set_stats = g1_prep_task.all_card_set_stats();\n+\n@@ -3766,0 +3807,1 @@\n+  rem_set()->print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":56,"deletions":14,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetFreeMemoryTask.hpp\"\n@@ -58,0 +60,1 @@\n+#include \"utilities\/bitMap.hpp\"\n@@ -68,0 +71,1 @@\n+class G1CardSetFreeMemoryTask;\n@@ -160,0 +164,1 @@\n+  G1CardSetFreeMemoryTask* _free_card_set_memory_task;\n@@ -175,0 +180,5 @@\n+  \/\/ Young gen memory statistics before GC.\n+  G1CardSetMemoryStats _young_gen_card_set_stats;\n+  \/\/ Collection set candidates memory statistics after GC.\n+  G1CardSetMemoryStats _collection_set_candidates_card_set_stats;\n+\n@@ -269,0 +279,3 @@\n+  bool should_sample_collection_set_candidates() const;\n+  void set_collection_set_candidates_stats(G1CardSetMemoryStats& stats);\n+\n@@ -842,0 +855,2 @@\n+  \/\/ Global card set configuration\n+  G1CardSetConfiguration _card_set_config;\n@@ -871,1 +886,1 @@\n-  volatile bool* _regions_failed_evacuation;\n+  CHeapBitMap _regions_failed_evacuation;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -198,3 +199,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  return Atomic::load(&_regions_failed_evacuation[region_idx]);\n+  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n@@ -208,4 +207,1 @@\n-  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n-\n-  volatile bool* region_failed_addr = &_regions_failed_evacuation[region_idx];\n-  bool result = !Atomic::load(region_failed_addr) && !Atomic::cmpxchg(region_failed_addr, false, true, memory_order_relaxed);\n+  bool result = _regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -42,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -2950,1 +2951,1 @@\n-  _total_remset_bytes += HeapRegionRemSet::fl_mem_size() + HeapRegionRemSet::static_mem_size();\n+  _total_remset_bytes += G1CardSetFreePool::free_list_pool()->mem_size() + HeapRegionRemSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,5 +54,0 @@\n-  \/\/ We must call G1MonitoringSupport::update_sizes() in the same scoping level\n-  \/\/ as an active TraceMemoryManagerStats object (i.e. before the destructor for the\n-  \/\/ TraceMemoryManagerStats is called) so that the G1 memory pools are updated\n-  \/\/ before any GC notifications are raised.\n-  _g1h->g1mm()->update_sizes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+constexpr const char* G1GCPhaseTimes::GCMergeRSWorkItemsStrings[];\n+\n@@ -74,4 +76,3 @@\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[MergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[MergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -80,4 +81,3 @@\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Sparse:\", MergeRSMergedSparse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Fine:\", MergeRSMergedFine);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Merged Coarse:\", MergeRSMergedCoarse);\n-  _gc_par_phases[OptMergeRS]->create_thread_work_items(\"Dirty Cards:\", MergeRSDirtyCards);\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n+    _gc_par_phases[OptMergeRS]->create_thread_work_items(GCMergeRSWorkItemsStrings[i], i);\n+  }\n@@ -137,0 +137,2 @@\n+  _gc_par_phases[SampleCollectionSetCandidates] = new WorkerDataArray<double>(\"SampleCandidates\", \"Sample CSet Candidates (ms):\", max_gc_threads);\n+\n@@ -173,0 +175,1 @@\n+  _recorded_sample_collection_set_candidates_time_ms = 0.0;\n@@ -452,0 +455,1 @@\n+                        _recorded_sample_collection_set_candidates_time_ms +\n@@ -475,0 +479,2 @@\n+  debug_time(\"Sample Collection Set Candidates\", _recorded_sample_collection_set_candidates_time_ms);\n+  trace_phase(_gc_par_phases[RedirtyCards]);\n@@ -488,0 +494,3 @@\n+  if (G1CollectedHeap::heap()->should_sample_collection_set_candidates()) {\n+    debug_phase(_gc_par_phases[SampleCollectionSetCandidates], 1);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    SampleCollectionSetCandidates,\n@@ -100,5 +101,11 @@\n-  enum GCMergeRSWorkTimes {\n-    MergeRSMergedSparse,\n-    MergeRSMergedFine,\n-    MergeRSMergedCoarse,\n-    MergeRSDirtyCards\n+  enum GCMergeRSWorkItems : uint {\n+    MergeRSMergedInline = 0,\n+    MergeRSMergedArrayOfCards,\n+    MergeRSMergedHowl,\n+    MergeRSMergedFull,\n+    MergeRSHowlInline,\n+    MergeRSHowlArrayOfCards,\n+    MergeRSHowlBitmap,\n+    MergeRSHowlFull,\n+    MergeRSDirtyCards,\n+    MergeRSContainersSentinel\n@@ -107,0 +114,5 @@\n+  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersSentinel] =\n+    { \"Merged Inline\", \"Merged ArrayOfCards\", \"Merged Howl\", \"Merged Full\",\n+      \"Merged Howl Inline\", \"Merged Howl ArrayOfCards\", \"Merged Howl BitMap\", \"Merged Howl Full\",\n+      \"Dirty Cards\" };\n+\n@@ -176,0 +188,2 @@\n+  double _recorded_sample_collection_set_candidates_time_ms;\n+\n@@ -332,0 +346,4 @@\n+  void record_sample_collection_set_candidates_time_ms(double time_ms) {\n+    _recorded_sample_collection_set_candidates_time_ms = time_ms;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return (_enabled_verification_types & type) == type;\n+  return (_enabled_verification_types & type) != 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-    G1VerifyRemark          =  8, \/\/ -XX:VerifyGCType=remark\n-    G1VerifyCleanup         = 16, \/\/ -XX:VerifyGCType=cleanup\n-    G1VerifyFull            = 32, \/\/ -XX:VerifyGCType=full\n+    G1VerifyYoungEvacFail   =  8, \/\/ -XX:VerifyGCType=young-evac-fail\n+    G1VerifyRemark          = 16, \/\/ -XX:VerifyGCType=remark\n+    G1VerifyCleanup         = 32, \/\/ -XX:VerifyGCType=cleanup\n+    G1VerifyFull            = 64, \/\/ -XX:VerifyGCType=full\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+  _g1mm(g1mm),\n@@ -350,0 +351,4 @@\n+\n+G1MonitoringScope::~G1MonitoringScope() {\n+  _g1mm->update_sizes();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  G1MonitoringSupport* _g1mm;\n@@ -245,0 +246,1 @@\n+  ~G1MonitoringScope();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -53,0 +53,2 @@\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -384,3 +384,1 @@\n-    if (!_region_scan_chunks[chunk_idx]) {\n-      _region_scan_chunks[chunk_idx] = true;\n-    }\n+    _region_scan_chunks[chunk_idx] = true;\n@@ -1064,1 +1062,1 @@\n-\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ Small ring buffer used for prefetching cards for write from the card\n@@ -1066,1 +1064,1 @@\n-template <class T, bool for_write>\n+template <class T>\n@@ -1099,5 +1097,1 @@\n-    if (for_write) {\n-      Prefetch::write(elem, 0);\n-    } else {\n-      Prefetch::read(elem, 0);\n-    }\n+    Prefetch::write(elem, 0);\n@@ -1114,1 +1108,27 @@\n-  \/\/ Visitor for remembered sets, dropping entries onto the card table.\n+  class G1MergeCardSetStats {\n+    size_t _merged[G1GCPhaseTimes::MergeRSContainersSentinel];\n+\n+  public:\n+    G1MergeCardSetStats() {\n+      for (uint i = 0; i < ARRAY_SIZE(_merged); i++) {\n+        _merged[i] = 0;\n+      }\n+    }\n+\n+    void inc_card_set_merged(uint tag) {\n+      assert(tag < ARRAY_SIZE(_merged), \"tag out of bounds %u\", tag);\n+      _merged[tag]++;\n+    }\n+\n+    void inc_cards_dirty(size_t increment = 1) {\n+      _merged[G1GCPhaseTimes::MergeRSDirtyCards] += increment;\n+    }\n+\n+    size_t merged(uint i) const { return _merged[i]; }\n+  };\n+\n+  \/\/ Visitor for remembered sets. Several methods of it are called by a region's\n+  \/\/ card set iterator to drop card set remembered set entries onto the card.\n+  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ all region's remembered sets.\n+  \/\/\n@@ -1124,5 +1144,1 @@\n-    uint _merged_sparse;\n-    uint _merged_fine;\n-    uint _merged_coarse;\n-\n-    size_t _cards_dirty;\n+    G1MergeCardSetStats _stats;\n@@ -1134,1 +1150,1 @@\n-    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue> {\n@@ -1141,1 +1157,1 @@\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue>(G1CardTable::dirty_card_val()),\n@@ -1163,1 +1179,1 @@\n-        _cards_dirty++;\n+        _stats.inc_cards_dirty();\n@@ -1168,4 +1184,0 @@\n-    void start_iterate(uint const region_idx) {\n-      _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n-    }\n-\n@@ -1173,0 +1185,1 @@\n+\n@@ -1176,4 +1189,1 @@\n-      _merged_sparse(0),\n-      _merged_fine(0),\n-      _merged_coarse(0),\n-      _cards_dirty(0),\n+      _stats(),\n@@ -1181,2 +1191,1 @@\n-      _merge_card_set_cache(this) {\n-    }\n+      _merge_card_set_cache(this) { }\n@@ -1191,24 +1200,7 @@\n-    void next_coarse_prt(uint const region_idx) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_coarse++;\n-\n-      start_iterate(region_idx);\n-      _cards_dirty += _ct->mark_region_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n-      _scan_state->set_chunk_region_dirty(_region_base_idx);\n-    }\n-\n-    void next_fine_prt(uint const region_idx, BitMap* bm) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_fine++;\n-\n-      start_iterate(region_idx);\n-      BitMap::idx_t cur = bm->get_next_one_offset(0);\n-      while (cur != bm->size()) {\n-        do_card((uint)cur);\n-        cur = bm->get_next_one_offset(cur + 1);\n+    \/\/ Returns whether the given region actually needs iteration.\n+    bool start_iterate(uint const tag, uint const region_idx) {\n+      assert(tag < G1GCPhaseTimes::MergeRSDirtyCards, \"invalid tag %u\", tag);\n+      if (remember_if_interesting(region_idx)) {\n+        _region_base_idx = (size_t)region_idx << HeapRegion::LogCardsPerRegion;\n+        _stats.inc_card_set_merged(tag);\n+        return true;\n@@ -1216,0 +1208,1 @@\n+      return false;\n@@ -1218,11 +1211,6 @@\n-    void next_sparse_prt(uint const region_idx, SparsePRTEntry::card_elem_t* cards, uint const num_cards) {\n-      if (!remember_if_interesting(region_idx)) {\n-        return;\n-      }\n-\n-      _merged_sparse++;\n-\n-      start_iterate(region_idx);\n-      for (uint i = 0; i < num_cards; i++) {\n-        do_card(cards[i]);\n-      }\n+    void do_card_range(uint const start_card_idx, uint const length) {\n+      assert(start_card_idx == 0, \"must be\");\n+      assert(length == HeapRegion::CardsPerRegion, \"must be\");\n+      size_t num_dirtied = _ct->mark_range_dirty(_region_base_idx, HeapRegion::CardsPerRegion);\n+      _stats.inc_cards_dirty(num_dirtied);\n+      _scan_state->set_chunk_region_dirty(_region_base_idx);\n@@ -1231,1 +1219,1 @@\n-    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ Helper to merge the cards in the card set for the given region onto the card\n@@ -1245,1 +1233,1 @@\n-    void dump_rem_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(HeapRegion* r) {\n@@ -1250,1 +1238,1 @@\n-        rem_set->iterate_prts(*this);\n+        rem_set->iterate_for_merge(*this);\n@@ -1258,1 +1246,1 @@\n-      dump_rem_set_for_region(r);\n+      merge_card_set_for_region(r);\n@@ -1263,5 +1251,1 @@\n-    size_t merged_sparse() const { return _merged_sparse; }\n-    size_t merged_fine() const { return _merged_fine; }\n-    size_t merged_coarse() const { return _merged_coarse; }\n-\n-    size_t cards_dirty() const { return _cards_dirty; }\n+    G1MergeCardSetStats stats() const { return _stats; }\n@@ -1273,1 +1257,2 @@\n-    G1MergeCardSetClosure _cl;\n+    G1RemSetScanState* _scan_state;\n+    G1MergeCardSetStats _merge_stats;\n@@ -1276,1 +1261,1 @@\n-    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _cl(scan_state) { }\n+    G1FlushHumongousCandidateRemSets(G1RemSetScanState* scan_state) : _scan_state(scan_state), _merge_stats() { }\n@@ -1290,1 +1275,6 @@\n-      _cl.dump_rem_set_for_region(r);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        cl.merge_card_set_for_region(r);\n+        stats = cl.stats();\n+      }\n@@ -1310,5 +1300,1 @@\n-    size_t merged_sparse() const { return _cl.merged_sparse(); }\n-    size_t merged_fine() const { return _cl.merged_fine(); }\n-    size_t merged_coarse() const { return _cl.merged_coarse(); }\n-\n-    size_t cards_dirty() const { return _cl.cards_dirty(); }\n+    size_t merged(uint i) const { return _merge_stats.merged(i); }\n@@ -1319,1 +1305,0 @@\n-    friend class G1MergeLogBufferCardsCache;\n@@ -1327,17 +1312,0 @@\n-    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n-      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n-\n-    public:\n-      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n-        \/\/ Initially set dummy card value to Clean to avoid any actual work if we\n-        \/\/ try to process it.\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n-        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n-\n-      ~G1MergeLogBufferCardsCache() {\n-        for (uint i = 0; i < CacheSize; i++) {\n-          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n-        }\n-      }\n-    } _merge_log_buffer_cache;\n-\n@@ -1358,2 +1326,1 @@\n-      _cards_skipped(0),\n-      _merge_log_buffer_cache(this)\n+      _cards_skipped(0)\n@@ -1376,2 +1343,1 @@\n-        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n-        process_card(to_process);\n+        process_card(card_ptr);\n@@ -1445,4 +1411,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged(i), i);\n+      }\n@@ -1454,2 +1419,6 @@\n-      G1MergeCardSetClosure cl(_scan_state);\n-      g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+      G1MergeCardSetStats stats;\n+      {\n+        G1MergeCardSetClosure cl(_scan_state);\n+        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n+        stats = cl.stats();\n+      }\n@@ -1457,4 +1426,3 @@\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_sparse(), G1GCPhaseTimes::MergeRSMergedSparse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_fine(), G1GCPhaseTimes::MergeRSMergedFine);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.merged_coarse(), G1GCPhaseTimes::MergeRSMergedCoarse);\n-      p->record_or_add_thread_work_item(merge_remset_phase, worker_id, cl.cards_dirty(), G1GCPhaseTimes::MergeRSDirtyCards);\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n+        p->record_or_add_thread_work_item(merge_remset_phase, worker_id, stats.merged(i), i);\n+      }\n@@ -1489,1 +1457,3 @@\n-  size_t num_visited_cards = _scan_state->num_visited_cards();\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1491,1 +1461,1 @@\n-  size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+    size_t num_visited_cards = _scan_state->num_visited_cards();\n@@ -1493,10 +1463,13 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  size_t total_old_region_cards =\n-    (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n-\n-  log_debug(gc,remset)(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n-                       num_visited_cards,\n-                       total_dirty_region_cards,\n-                       percent_of(num_visited_cards, total_dirty_region_cards),\n-                       total_old_region_cards,\n-                       percent_of(num_visited_cards, total_old_region_cards));\n+    size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    size_t total_old_region_cards =\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+\n+    ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n+                num_visited_cards,\n+                total_dirty_region_cards,\n+                percent_of(num_visited_cards, total_dirty_region_cards),\n+                total_old_region_cards,\n+                percent_of(num_visited_cards, total_old_region_cards));\n+  }\n@@ -1534,3 +1507,1 @@\n-  if (log_is_enabled(Debug, gc, remset)) {\n-    print_merge_heap_roots_stats();\n-  }\n+  print_merge_heap_roots_stats();\n@@ -1551,0 +1522,9 @@\n+void G1RemSet::print_coarsen_stats() {\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+\n+    G1CardSet::print_coarsen_stats(&ls);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":109,"deletions":129,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -110,0 +110,4 @@\n+  \/\/ Cleans the card table from temporary duplicate detection information.\n+  void cleanup_after_scan_heap_roots();\n+  \/\/ Print coarsening stats.\n+  void print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -34,1 +35,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -51,0 +52,1 @@\n+\n@@ -53,1 +55,1 @@\n-  _num_coarsenings = HeapRegionRemSet::n_coarsenings();\n+  _coarsenings = HeapRegionRemSet::coarsen_stats();\n@@ -71,1 +73,1 @@\n-  _num_coarsenings(0),\n+  _coarsenings(),\n@@ -91,1 +93,1 @@\n-  _num_coarsenings = other->num_coarsenings();\n+  _coarsenings = other->_coarsenings;\n@@ -102,1 +104,1 @@\n-  _num_coarsenings = other->num_coarsenings() - _num_coarsenings;\n+  _coarsenings.subtract_from(other->_coarsenings);\n@@ -115,0 +117,1 @@\n+  size_t _rs_wasted_mem_size;\n@@ -118,0 +121,1 @@\n+  size_t _amount_tracked;\n@@ -139,0 +143,1 @@\n+  size_t amount_tracked() const { return _amount_tracked; }\n@@ -142,2 +147,2 @@\n-  RegionTypeCounter(const char* name) : _name(name), _rs_mem_size(0), _cards_occupied(0),\n-    _amount(0), _code_root_mem_size(0), _code_root_elems(0) { }\n+  RegionTypeCounter(const char* name) : _name(name), _rs_wasted_mem_size(0), _rs_mem_size(0), _cards_occupied(0),\n+    _amount(0), _amount_tracked(0), _code_root_mem_size(0), _code_root_elems(0) { }\n@@ -145,2 +150,3 @@\n-  void add(size_t rs_mem_size, size_t cards_occupied, size_t code_root_mem_size,\n-    size_t code_root_elems) {\n+  void add(size_t rs_wasted_mem_size, size_t rs_mem_size, size_t cards_occupied,\n+           size_t code_root_mem_size, size_t code_root_elems, bool tracked) {\n+    _rs_wasted_mem_size += rs_wasted_mem_size;\n@@ -152,0 +158,1 @@\n+    _amount_tracked += tracked ? 1 : 0;\n@@ -154,0 +161,1 @@\n+  size_t rs_wasted_mem_size() const { return _rs_wasted_mem_size; }\n@@ -161,4 +169,5 @@\n-    out->print_cr(\"    \" SIZE_FORMAT_W(8) \"%s (%5.1f%%) by \" SIZE_FORMAT \" %s regions\",\n-        byte_size_in_proper_unit(rs_mem_size()),\n-        proper_unit_for_byte_size(rs_mem_size()),\n-        rs_mem_size_percent_of(total), amount(), _name);\n+    out->print_cr(\"    \" SIZE_FORMAT_W(8) \" (%5.1f%%) by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions wasted \" SIZE_FORMAT,\n+                  rs_mem_size(), rs_mem_size_percent_of(total),\n+                  amount_tracked(), amount(),\n+                  _name, rs_wasted_mem_size());\n@@ -168,2 +177,4 @@\n-    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" %s regions\",\n-        cards_occupied(), cards_occupied_percent_of(total), amount(), _name);\n+    out->print_cr(\"     \" SIZE_FORMAT_W(8) \" (%5.1f%%) entries by \" SIZE_FORMAT \" \"\n+                  \"(\" SIZE_FORMAT \") %s regions\",\n+                  cards_occupied(), cards_occupied_percent_of(total),\n+                  amount_tracked(), amount(), _name);\n@@ -198,0 +209,1 @@\n+  size_t total_rs_wasted_mem_sz() const     { return _all.rs_wasted_mem_size(); }\n@@ -225,0 +237,1 @@\n+    size_t rs_wasted_mem_sz = hrrs->wasted_mem_size();\n@@ -252,2 +265,4 @@\n-    current->add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n-    _all.add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);\n+    current->add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+                 code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n+    _all.add(rs_wasted_mem_sz, rs_mem_sz, occupied_cards,\n+             code_root_mem_sz, code_root_elems, r->rem_set()->is_tracked());\n@@ -262,6 +277,5 @@\n-    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT \"%s.\"\n-                  \" Max = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(total_rs_mem_sz()),\n-                  proper_unit_for_byte_size(total_rs_mem_sz()),\n-                  byte_size_in_proper_unit(max_rs_mem_sz()),\n-                  proper_unit_for_byte_size(max_rs_mem_sz()));\n+    out->print_cr(\"  Total per region rem sets sizes = \" SIZE_FORMAT\n+                  \" Max = \" SIZE_FORMAT \" wasted = \" SIZE_FORMAT,\n+                  total_rs_mem_sz(),\n+                  max_rs_mem_sz(),\n+                  total_rs_wasted_mem_sz());\n@@ -272,7 +286,0 @@\n-    out->print_cr(\"   Static structures = \" SIZE_FORMAT \"%s,\"\n-                  \" free_lists = \" SIZE_FORMAT \"%s.\",\n-                  byte_size_in_proper_unit(HeapRegionRemSet::static_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::static_mem_size()),\n-                  byte_size_in_proper_unit(HeapRegionRemSet::fl_mem_size()),\n-                  proper_unit_for_byte_size(HeapRegionRemSet::fl_mem_size()));\n-\n@@ -288,1 +295,1 @@\n-                  \"size = \" SIZE_FORMAT \"%s, occupied = \" SIZE_FORMAT \"%s.\",\n+                  \"size = \" SIZE_FORMAT \" occupied = \" SIZE_FORMAT,\n@@ -290,4 +297,6 @@\n-                  byte_size_in_proper_unit(rem_set->mem_size()),\n-                  proper_unit_for_byte_size(rem_set->mem_size()),\n-                  byte_size_in_proper_unit(rem_set->occupied()),\n-                  proper_unit_for_byte_size(rem_set->occupied()));\n+                  rem_set->mem_size(),\n+                  rem_set->occupied());\n+\n+    HeapRegionRemSet::print_static_mem_size(out);\n+    G1CardSetFreePool::free_list_pool()->print_on(out);\n+\n@@ -322,1 +331,2 @@\n-  out->print_cr(\"  Did \" SIZE_FORMAT \" coarsenings.\", num_coarsenings());\n+  out->print(\"Coarsening: \");\n+  _coarsenings.print_on(out);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n@@ -36,1 +37,1 @@\n-  size_t _num_coarsenings;\n+  G1CardSetCoarsenStats _coarsenings;\n@@ -68,4 +69,0 @@\n-\n-  size_t num_coarsenings() const {\n-    return _num_coarsenings;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n@@ -44,0 +46,3 @@\n+  if (SampleCollectionSetCandidatesTask::should_execute()) {\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n+  }\n@@ -67,0 +72,26 @@\n+bool G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::should_execute() {\n+  return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n+}\n+\n+double G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::worker_cost() const {\n+  return should_execute() ? 1.0 : AlmostNoWork;\n+}\n+\n+class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+public:\n+  G1CardSetMemoryStats _total;\n+\n+  bool do_heap_region(HeapRegion* r) override {\n+    _total.add(r->rem_set()->card_set_memory_stats());\n+    return false;\n+  }\n+};\n+\n+void G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::do_work(uint worker_id) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+  G1SampleCollectionSetCandidatesClosure cl;\n+  g1h->collection_set()->candidates()->iterate(&cl);\n+  g1h->set_collection_set_candidates_stats(cl._total);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+\/\/ - Sample Collection Set Candidates (s)\n@@ -46,0 +47,1 @@\n+  class SampleCollectionSetCandidatesTask;\n@@ -71,0 +73,10 @@\n+class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n+public:\n+  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n+\n+  static bool should_execute();\n+\n+  double worker_cost() const override;\n+  void do_work(uint worker_id) override;\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,2 +133,2 @@\n-          \"Each time the rset update queue increases by this amount \"       \\\n-          \"activate the next refinement thread if available. \"              \\\n+          \"Each time the remembered set update queue increases by this \"    \\\n+          \"amount activate the next refinement thread if available. \"       \\\n@@ -141,1 +141,2 @@\n-          \"process RS update buffers during the collection pause.\")         \\\n+          \"processing remembered set update buffers during the collection \" \\\n+          \"pause.\")                                                         \\\n@@ -156,20 +157,34 @@\n-  develop(intx, G1RSetRegionEntriesBase, 256,                               \\\n-          \"Max number of regions in a fine-grain table per MB.\")            \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetRegionEntries, 0,                                     \\\n-          \"Max number of regions for which we keep bitmaps.\"                \\\n-          \"Will be set ergonomically by default\")                           \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \\\n-                                                                            \\\n-  develop(intx, G1RSetSparseRegionEntriesBase, 4,                           \\\n-          \"Max number of entries per region in a sparse table \"             \\\n-          \"per MB.\")                                                        \\\n-          range(1, max_jint\/wordSize)                                       \\\n-                                                                            \\\n-  product(intx, G1RSetSparseRegionEntries, 0,                               \\\n-          \"Max number of entries per region in a sparse table.\"             \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \\\n+  develop(uint, G1RemSetArrayOfCardsEntriesBase, 4,                         \\\n+          \"Maximum number of entries per region in the Array of Cards \"     \\\n+          \"card set container per MB of a heap region.\")                    \\\n+          range(1, 65536)                                                   \\\n+                                                                            \\\n+  product(uint, G1RemSetArrayOfCardsEntries, 0,  EXPERIMENTAL,              \\\n+          \"Maximum number of entries per Array of Cards card set \"          \\\n+          \"container. Will be set ergonomically by default.\")               \\\n+          range(0, 65536)                                                   \\\n+          constraint(G1RemSetArrayOfCardsEntriesConstraintFunc,AfterErgo)   \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlMaxNumBuckets, 8, EXPERIMENTAL,                 \\\n+          \"Maximum number of buckets per Howl card set container. The \"     \\\n+          \"default gives at worst bitmaps of size 8k. This showed to be a \" \\\n+          \"good tradeoff between bitmap size (waste) and cacheability of \"  \\\n+          \"the bucket array. Must be a power of two.\")                      \\\n+          range(1, 1024)                                                    \\\n+          constraint(G1RemSetHowlMaxNumBucketsConstraintFunc,AfterErgo)     \\\n+                                                                            \\\n+  product(uint, G1RemSetHowlNumBuckets, 0, EXPERIMENTAL,                    \\\n+          \"Number of buckets per Howl card set container. Must be a power \" \\\n+          \"of two. Will be set ergonomically by default.\")                  \\\n+          range(0, 1024)                                                    \\\n+          constraint(G1RemSetHowlNumBucketsConstraintFunc,AfterErgo)        \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlBitmapToHowlFullPercent, 90, EXPERIMENTAL, \\\n+          \"Percentage at which to coarsen a Howl bitmap to Howl full card \" \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1RemSetCoarsenHowlToFullPercent, 90, EXPERIMENTAL,         \\\n+          \"Percentage at which to coarsen a Howl card set to Full card \"    \\\n+          \"set container.\")                                                 \\\n+          range(1, 100)                                                     \\\n@@ -193,1 +208,1 @@\n-          \"The number of parallel rem set update threads. \"                 \\\n+          \"The number of parallel remembered set update threads. \"          \\\n@@ -312,1 +327,17 @@\n-  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                       \\\n+  product(uint, G1RemSetFreeMemoryRescheduleDelayMillis, 10, EXPERIMENTAL,  \\\n+          \"Time after which the card set free memory task reschedules \"     \\\n+          \"itself if there is work remaining.\")                             \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryStepDurationMillis, 1, EXPERIMENTAL,    \\\n+          \"The amount of time that the free memory task should spend \"      \\\n+          \"before a pause of G1RemSetFreeMemoryRescheduleDelayMillis \"      \\\n+          \"length.\")                                                        \\\n+          range(1e-3, 1e+6)                                                 \\\n+                                                                            \\\n+  product(double, G1RemSetFreeMemoryKeepExcessRatio, 0.1, EXPERIMENTAL,     \\\n+          \"The percentage of free card set memory that G1 should keep as \"  \\\n+          \"percentage of the currently used memory.\")                       \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n+  product(bool, G1AllowPreventiveGC, true, DIAGNOSTIC,                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":57,"deletions":26,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n@@ -229,1 +229,2 @@\n-                       MemRegion mr) :\n+                       MemRegion mr,\n+                       G1CardSetConfiguration* config) :\n@@ -255,1 +256,1 @@\n-  _rem_set = new HeapRegionRemSet(bot, this);\n+  _rem_set = new HeapRegionRemSet(this, config);\n@@ -613,0 +614,2 @@\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -617,1 +620,0 @@\n-          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+class G1CardSetConfiguration;\n+class G1CardSetMemoryManager;\n@@ -284,1 +286,4 @@\n-  HeapRegion(uint hrm_index, G1BlockOffsetTable* bot, MemRegion mr);\n+  HeapRegion(uint hrm_index,\n+             G1BlockOffsetTable* bot,\n+             MemRegion mr,\n+             G1CardSetConfiguration* config);\n@@ -448,0 +453,1 @@\n+  void set_rem_set(HeapRegionRemSet* rem_set) { _rem_set = rem_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include <cstdio>\n+\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.inline.hpp\"\n@@ -47,346 +48,8 @@\n-PerRegionTable* PerRegionTable::alloc(HeapRegion* hr) {\n-  PerRegionTable* fl = _free_list;\n-  while (fl != NULL) {\n-    PerRegionTable* nxt = fl->next();\n-    PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, nxt);\n-    if (res == fl) {\n-      fl->init(hr, true);\n-      return fl;\n-    } else {\n-      fl = _free_list;\n-    }\n-  }\n-  assert(fl == NULL, \"Loop condition.\");\n-  return new PerRegionTable(hr);\n-}\n-\n-PerRegionTable* volatile PerRegionTable::_free_list = NULL;\n-\n-size_t OtherRegionsTable::_max_fine_entries = 0;\n-size_t OtherRegionsTable::_mod_max_fine_entries_mask = 0;\n-size_t OtherRegionsTable::_fine_eviction_stride = 0;\n-size_t OtherRegionsTable::_fine_eviction_sample_size = 0;\n-\n-OtherRegionsTable::OtherRegionsTable(Mutex* m) :\n-  _g1h(G1CollectedHeap::heap()),\n-  _m(m),\n-  _num_occupied(0),\n-  _coarse_map(mtGC),\n-  _has_coarse_entries(false),\n-  _fine_grain_regions(NULL),\n-  _n_fine_entries(0),\n-  _first_all_fine_prts(NULL),\n-  _last_all_fine_prts(NULL),\n-  _fine_eviction_start(0),\n-  _sparse_table()\n-{\n-  typedef PerRegionTable* PerRegionTablePtr;\n-\n-  if (_max_fine_entries == 0) {\n-    assert(_mod_max_fine_entries_mask == 0, \"Both or none.\");\n-    size_t max_entries_log = (size_t)log2i(G1RSetRegionEntries);\n-    _max_fine_entries = (size_t)1 << max_entries_log;\n-    _mod_max_fine_entries_mask = _max_fine_entries - 1;\n-\n-    assert(_fine_eviction_sample_size == 0\n-           && _fine_eviction_stride == 0, \"All init at same time.\");\n-    _fine_eviction_sample_size = MAX2((size_t)4, max_entries_log);\n-    _fine_eviction_stride = _max_fine_entries \/ _fine_eviction_sample_size;\n-  }\n-\n-  _fine_grain_regions = NEW_C_HEAP_ARRAY(PerRegionTablePtr, _max_fine_entries, mtGC);\n-  for (size_t i = 0; i < _max_fine_entries; i++) {\n-    _fine_grain_regions[i] = NULL;\n-  }\n-}\n-\n-void OtherRegionsTable::link_to_all(PerRegionTable* prt) {\n-  \/\/ We always append to the beginning of the list for convenience;\n-  \/\/ the order of entries in this list does not matter.\n-  if (_first_all_fine_prts != NULL) {\n-    prt->set_next(_first_all_fine_prts);\n-  } else {\n-    \/\/ this is the first element we insert. Adjust the \"last\" pointer\n-    _last_all_fine_prts = prt;\n-    assert(prt->next() == NULL, \"just checking\");\n-  }\n-  _first_all_fine_prts = prt;\n-\n-  assert(_first_all_fine_prts == prt, \"just checking\");\n-  assert((_first_all_fine_prts == NULL && _last_all_fine_prts == NULL) ||\n-         (_first_all_fine_prts != NULL && _last_all_fine_prts != NULL),\n-         \"just checking\");\n-  assert(_last_all_fine_prts == NULL || _last_all_fine_prts->next() == NULL,\n-         \"just checking\");\n-}\n-\n-CardIdx_t OtherRegionsTable::card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr) {\n-  assert(hr->is_in_reserved(within_region),\n-         \"HeapWord \" PTR_FORMAT \" is outside of region %u [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-         p2i(within_region), hr->hrm_index(), p2i(hr->bottom()), p2i(hr->end()));\n-  CardIdx_t result = (CardIdx_t)(pointer_delta((HeapWord*)within_region, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n-  return result;\n-}\n-\n-void OtherRegionsTable::add_reference(OopOrNarrowOopStar from, uint tid) {\n-  \/\/ Note that this may be a continued H region.\n-  HeapRegion* from_hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t from_hrm_ind = (RegionIdx_t) from_hr->hrm_index();\n-\n-  \/\/ If the region is already coarsened, return.\n-  if (is_region_coarsened(from_hrm_ind)) {\n-    assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-    return;\n-  }\n-\n-  size_t num_added_by_coarsening = 0;\n-  \/\/ Otherwise find a per-region table to add it to.\n-  size_t ind = from_hrm_ind & _mod_max_fine_entries_mask;\n-  PerRegionTable* prt = find_region_table(ind, from_hr);\n-  if (prt == NULL) {\n-    MutexLocker x(_m, Mutex::_no_safepoint_check_flag);\n-\n-    \/\/ Rechecking if the region is coarsened, while holding the lock.\n-    if (is_region_coarsened(from_hrm_ind)) {\n-      assert(contains_reference_locked(from), \"We just found \" PTR_FORMAT \" in the Coarse table\", p2i(from));\n-      return;\n-    }\n-\n-    \/\/ Confirm that it's really not there...\n-    prt = find_region_table(ind, from_hr);\n-    if (prt == NULL) {\n-\n-      CardIdx_t card_index = card_within_region(from, from_hr);\n-\n-      SparsePRT::AddCardResult result = _sparse_table.add_card(from_hrm_ind, card_index);\n-      if (result != SparsePRT::overflow) {\n-        if (result == SparsePRT::added) {\n-          Atomic::inc(&_num_occupied, memory_order_relaxed);\n-        }\n-        assert(contains_reference_locked(from), \"We just added \" PTR_FORMAT \" to the Sparse table\", p2i(from));\n-        return;\n-      }\n-\n-      \/\/ Sparse PRT returned overflow (sparse table is full)\n-\n-      if (_n_fine_entries == _max_fine_entries) {\n-        prt = delete_region_table(num_added_by_coarsening);\n-        \/\/ There is no need to clear the links to the 'all' list here:\n-        \/\/ prt will be reused immediately, i.e. remain in the 'all' list.\n-        prt->init(from_hr, false \/* clear_links_to_all_list *\/);\n-      } else {\n-        prt = PerRegionTable::alloc(from_hr);\n-        link_to_all(prt);\n-      }\n-\n-      PerRegionTable* first_prt = _fine_grain_regions[ind];\n-      prt->set_collision_list_next(first_prt);\n-      \/\/ The assignment into _fine_grain_regions allows the prt to\n-      \/\/ start being used concurrently. In addition to\n-      \/\/ collision_list_next which must be visible (else concurrent\n-      \/\/ parsing of the list, if any, may fail to see other entries),\n-      \/\/ the content of the prt must be visible (else for instance\n-      \/\/ some mark bits may not yet seem cleared or a 'later' update\n-      \/\/ performed by a concurrent thread could be undone when the\n-      \/\/ zeroing becomes visible). This requires store ordering.\n-      Atomic::release_store(&_fine_grain_regions[ind], prt);\n-      _n_fine_entries++;\n-\n-      \/\/ Transfer from sparse to fine-grain. The cards from the sparse table\n-      \/\/ were already added to the total in _num_occupied.\n-      SparsePRTEntry *sprt_entry = _sparse_table.get_entry(from_hrm_ind);\n-      assert(sprt_entry != NULL, \"There should have been an entry\");\n-      for (int i = 0; i < sprt_entry->num_valid_cards(); i++) {\n-        CardIdx_t c = sprt_entry->card(i);\n-        prt->add_card(c);\n-      }\n-      \/\/ Now we can delete the sparse entry.\n-      bool res = _sparse_table.delete_entry(from_hrm_ind);\n-      assert(res, \"It should have been there.\");\n-    }\n-    assert(prt != NULL && prt->hr() == from_hr, \"consequence\");\n-  }\n-  \/\/ Note that we can't assert \"prt->hr() == from_hr\", because of the\n-  \/\/ possibility of concurrent reuse.  But see head comment of\n-  \/\/ OtherRegionsTable for why this is OK.\n-  assert(prt != NULL, \"Inv\");\n-\n-  if (prt->add_reference(from)) {\n-    num_added_by_coarsening++;\n-  }\n-  Atomic::add(&_num_occupied, num_added_by_coarsening, memory_order_relaxed);\n-  assert(contains_reference(from), \"We just added \" PTR_FORMAT \" to the PRT (%d)\", p2i(from), prt->contains_reference(from));\n-}\n-\n-PerRegionTable*\n-OtherRegionsTable::find_region_table(size_t ind, HeapRegion* hr) const {\n-  assert(ind < _max_fine_entries, \"Preconditions.\");\n-  PerRegionTable* prt = _fine_grain_regions[ind];\n-  while (prt != NULL && prt->hr() != hr) {\n-    prt = prt->collision_list_next();\n-  }\n-  \/\/ Loop postcondition is the method postcondition.\n-  return prt;\n-}\n-\n-jint OtherRegionsTable::_n_coarsenings = 0;\n-\n-PerRegionTable* OtherRegionsTable::delete_region_table(size_t& added_by_deleted) {\n-  assert(_m->owned_by_self(), \"Precondition\");\n-  assert(_n_fine_entries == _max_fine_entries, \"Precondition\");\n-  PerRegionTable* max = NULL;\n-  jint max_occ = 0;\n-  PerRegionTable** max_prev = NULL;\n-\n-  size_t i = _fine_eviction_start;\n-  for (size_t k = 0; k < _fine_eviction_sample_size; k++) {\n-    size_t ii = i;\n-    \/\/ Make sure we get a non-NULL sample.\n-    while (_fine_grain_regions[ii] == NULL) {\n-      ii++;\n-      if (ii == _max_fine_entries) ii = 0;\n-      guarantee(ii != i, \"We must find one.\");\n-    }\n-    PerRegionTable** prev = &_fine_grain_regions[ii];\n-    PerRegionTable* cur = *prev;\n-    while (cur != NULL) {\n-      jint cur_occ = cur->occupied();\n-      if (max == NULL || cur_occ > max_occ) {\n-        max = cur;\n-        max_prev = prev;\n-        max_occ = cur_occ;\n-      }\n-      prev = cur->collision_list_next_addr();\n-      cur = cur->collision_list_next();\n-    }\n-    i = i + _fine_eviction_stride;\n-    if (i >= _n_fine_entries) i = i - _n_fine_entries;\n-  }\n-\n-  _fine_eviction_start++;\n-\n-  if (_fine_eviction_start >= _n_fine_entries) {\n-    _fine_eviction_start -= _n_fine_entries;\n-  }\n-\n-  guarantee(max != NULL, \"Since _n_fine_entries > 0\");\n-  guarantee(max_prev != NULL, \"Since max != NULL.\");\n-\n-  \/\/ Ensure the corresponding coarse bit is set.\n-  size_t max_hrm_index = (size_t) max->hr()->hrm_index();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.at_put(max_hrm_index, true);\n-  } else {\n-    \/\/ This will lazily initialize an uninitialized bitmap\n-    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_reserved_regions());\n-    assert(!_coarse_map.at(max_hrm_index), \"No coarse entries\");\n-    _coarse_map.at_put(max_hrm_index, true);\n-    \/\/ Release store guarantees that the bitmap has initialized before any\n-    \/\/ concurrent reader will ever see _has_coarse_entries is true\n-    \/\/ (when read with load_acquire)\n-    Atomic::release_store(&_has_coarse_entries, true);\n-  }\n-\n-  added_by_deleted = HeapRegion::CardsPerRegion - max_occ;\n-  \/\/ Unsplice.\n-  *max_prev = max->collision_list_next();\n-  Atomic::inc(&_n_coarsenings);\n-  _n_fine_entries--;\n-  return max;\n-}\n-\n-bool OtherRegionsTable::occupancy_less_or_equal_than(size_t limit) const {\n-  return occupied() <= limit;\n-}\n-\n-bool OtherRegionsTable::is_empty() const {\n-  return occupied() == 0;\n-}\n-\n-size_t OtherRegionsTable::occupied() const {\n-  return _num_occupied;\n-}\n-\n-size_t OtherRegionsTable::mem_size() const {\n-  size_t sum = 0;\n-  \/\/ all PRTs are of the same size so it is sufficient to query only one of them.\n-  if (_first_all_fine_prts != NULL) {\n-    assert(_last_all_fine_prts != NULL &&\n-      _first_all_fine_prts->mem_size() == _last_all_fine_prts->mem_size(), \"check that mem_size() is constant\");\n-    sum += _first_all_fine_prts->mem_size() * _n_fine_entries;\n-  }\n-  sum += (sizeof(PerRegionTable*) * _max_fine_entries);\n-  sum += (_coarse_map.size_in_words() * HeapWordSize);\n-  sum += (_sparse_table.mem_size());\n-  sum += sizeof(OtherRegionsTable) - sizeof(_sparse_table); \/\/ Avoid double counting above.\n-  return sum;\n-}\n-\n-size_t OtherRegionsTable::static_mem_size() {\n-  return G1FromCardCache::static_mem_size();\n-}\n-\n-size_t OtherRegionsTable::fl_mem_size() {\n-  return PerRegionTable::fl_mem_size();\n-}\n-\n-void OtherRegionsTable::clear() {\n-  \/\/ if there are no entries, skip this step\n-  if (_first_all_fine_prts != NULL) {\n-    guarantee(_first_all_fine_prts != NULL && _last_all_fine_prts != NULL, \"just checking\");\n-    PerRegionTable::bulk_free(_first_all_fine_prts, _last_all_fine_prts);\n-    memset(_fine_grain_regions, 0, _max_fine_entries * sizeof(_fine_grain_regions[0]));\n-  } else {\n-    guarantee(_first_all_fine_prts == NULL && _last_all_fine_prts == NULL, \"just checking\");\n-  }\n-\n-  _first_all_fine_prts = _last_all_fine_prts = NULL;\n-  _sparse_table.clear();\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    _coarse_map.clear();\n-  }\n-  _n_fine_entries = 0;\n-  Atomic::store(&_has_coarse_entries, false);\n-\n-  _num_occupied = 0;\n-}\n-\n-bool OtherRegionsTable::contains_reference(OopOrNarrowOopStar from) const {\n-  \/\/ Cast away const in this case.\n-  MutexLocker x((Mutex*)_m, Mutex::_no_safepoint_check_flag);\n-  return contains_reference_locked(from);\n-}\n-\n-bool OtherRegionsTable::contains_reference_locked(OopOrNarrowOopStar from) const {\n-  HeapRegion* hr = _g1h->heap_region_containing(from);\n-  RegionIdx_t hr_ind = (RegionIdx_t) hr->hrm_index();\n-  \/\/ Is this region in the coarse map?\n-  if (is_region_coarsened(hr_ind)) return true;\n-\n-  PerRegionTable* prt = find_region_table(hr_ind & _mod_max_fine_entries_mask,\n-                                          hr);\n-  if (prt != NULL) {\n-    return prt->contains_reference(from);\n-  } else {\n-    CardIdx_t card_index = card_within_region(from, hr);\n-    return _sparse_table.contains_card(hr_ind, card_index);\n-  }\n-}\n-\n-\/\/ A load_acquire on _has_coarse_entries - coupled with the release_store in\n-\/\/ delete_region_table - guarantees we don't access _coarse_map before\n-\/\/ it's been properly initialized.\n-bool OtherRegionsTable::is_region_coarsened(RegionIdx_t from_hrm_ind) const {\n-  return Atomic::load_acquire(&_has_coarse_entries) && _coarse_map.at(from_hrm_ind);\n-}\n-\n-HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetTable* bot,\n-                                   HeapRegion* hr)\n-  : _bot(bot),\n-    _code_roots(),\n-    _m(Mutex::leaf, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Mutex::_safepoint_check_never),\n-    _other_regions(&_m),\n-    _hr(hr),\n-    _state(Untracked)\n-{\n-}\n+HeapRegionRemSet::HeapRegionRemSet(HeapRegion* hr,\n+                                   G1CardSetConfiguration* config) :\n+  _m(Mutex::leaf + 1, FormatBuffer<128>(\"HeapRegionRemSet lock #%u\", hr->hrm_index()), true, Monitor::_safepoint_check_never),\n+  _code_roots(),\n+  _card_set_mm(config, G1CardSetFreePool::free_list_pool()),\n+  _card_set(config, &_card_set_mm),\n+  _hr(hr),\n+  _state(Untracked) { }\n@@ -398,14 +61,0 @@\n-void HeapRegionRemSet::setup_remset_size() {\n-  const int LOG_M = 20;\n-  guarantee(HeapRegion::LogOfHRGrainBytes >= LOG_M, \"Code assumes the region size >= 1M, but is \" SIZE_FORMAT \"B\", HeapRegion::GrainBytes);\n-\n-  int region_size_log_mb = HeapRegion::LogOfHRGrainBytes - LOG_M;\n-  if (FLAG_IS_DEFAULT(G1RSetSparseRegionEntries)) {\n-    G1RSetSparseRegionEntries = G1RSetSparseRegionEntriesBase * ((size_t)1 << (region_size_log_mb + 1));\n-  }\n-  if (FLAG_IS_DEFAULT(G1RSetRegionEntries)) {\n-    G1RSetRegionEntries = G1RSetRegionEntriesBase * (region_size_log_mb + 1);\n-  }\n-  guarantee(G1RSetSparseRegionEntries > 0 && G1RSetRegionEntries > 0 , \"Sanity\");\n-}\n-\n@@ -422,1 +71,1 @@\n-  _other_regions.clear();\n+  _card_set.clear();\n@@ -427,0 +76,4 @@\n+void HeapRegionRemSet::print_static_mem_size(outputStream* out) {\n+  out->print_cr(\"  Static structures = \" SIZE_FORMAT, HeapRegionRemSet::static_mem_size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":15,"deletions":362,"binary":false,"changes":377,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -34,240 +36,1 @@\n-\/\/ Remembered set for a heap region.  Represent a set of \"cards\" that\n-\/\/ contain pointers into the owner heap region.  Cards are defined somewhat\n-\/\/ abstractly, in terms of what the \"BlockOffsetTable\" in use can parse.\n-\n-class G1CollectedHeap;\n-class G1BlockOffsetTable;\n-class G1CardLiveData;\n-class HeapRegion;\n-class PerRegionTable;\n-class SparsePRT;\n-class nmethod;\n-\n-\/\/ The \"_coarse_map\" is a bitmap with one bit for each region, where set\n-\/\/ bits indicate that the corresponding region may contain some pointer\n-\/\/ into the owning region.\n-\n-\/\/ The \"_fine_grain_entries\" array is an open hash table of PerRegionTables\n-\/\/ (PRTs), indicating regions for which we're keeping the RS as a set of\n-\/\/ cards.  The strategy is to cap the size of the fine-grain table,\n-\/\/ deleting an entry and setting the corresponding coarse-grained bit when\n-\/\/ we would overflow this cap.\n-\n-\/\/ We use a mixture of locking and lock-free techniques here.  We allow\n-\/\/ threads to locate PRTs without locking, but threads attempting to alter\n-\/\/ a bucket list obtain a lock.  This means that any failing attempt to\n-\/\/ find a PRT must be retried with the lock.  It might seem dangerous that\n-\/\/ a read can find a PRT that is concurrently deleted.  This is all right,\n-\/\/ because:\n-\/\/\n-\/\/   1) We only actually free PRT's at safe points (though we reuse them at\n-\/\/      other times).\n-\/\/   2) We find PRT's in an attempt to add entries.  If a PRT is deleted,\n-\/\/      it's _coarse_map bit is set, so the that we were attempting to add\n-\/\/      is represented.  If a deleted PRT is re-used, a thread adding a bit,\n-\/\/      thinking the PRT is for a different region, does no harm.\n-\n-class OtherRegionsTable {\n-  G1CollectedHeap* _g1h;\n-  Mutex*           _m;\n-\n-  size_t volatile _num_occupied;\n-\n-  \/\/ These are protected by \"_m\".\n-  CHeapBitMap   _coarse_map;\n-  bool volatile _has_coarse_entries;\n-  static jint   _n_coarsenings;\n-\n-  PerRegionTable** _fine_grain_regions;\n-  size_t           _n_fine_entries;\n-\n-  \/\/ The fine grain remembered sets are linked together using\n-  \/\/ their 'next' fields.\n-  \/\/ This allows fast bulk freeing of all the fine grain remembered\n-  \/\/ set entries, and fast finding of all of them without iterating\n-  \/\/ over the _fine_grain_regions table.\n-  PerRegionTable * _first_all_fine_prts;\n-  PerRegionTable * _last_all_fine_prts;\n-\n-  \/\/ Used to sample a subset of the fine grain PRTs to determine which\n-  \/\/ PRT to evict and coarsen.\n-  size_t        _fine_eviction_start;\n-  static size_t _fine_eviction_stride;\n-  static size_t _fine_eviction_sample_size;\n-\n-  SparsePRT   _sparse_table;\n-\n-  \/\/ These are static after init.\n-  static size_t _max_fine_entries;\n-  static size_t _mod_max_fine_entries_mask;\n-\n-  \/\/ Requires \"prt\" to be the first element of the bucket list appropriate\n-  \/\/ for \"hr\".  If this list contains an entry for \"hr\", return it,\n-  \/\/ otherwise return \"NULL\".\n-  PerRegionTable* find_region_table(size_t ind, HeapRegion* hr) const;\n-\n-  \/\/ Find, delete, and return a candidate PerRegionTable, if any exists,\n-  \/\/ adding the deleted region to the coarse bitmap.  Requires the caller\n-  \/\/ to hold _m, and the fine-grain table to be full.\n-  PerRegionTable* delete_region_table(size_t& added_by_deleted);\n-\n-  \/\/ link\/add the given fine grain remembered set into the \"all\" list\n-  void link_to_all(PerRegionTable * prt);\n-\n-  bool contains_reference_locked(OopOrNarrowOopStar from) const;\n-\n-public:\n-  \/\/ Create a new remembered set. The given mutex is used to ensure consistency.\n-  OtherRegionsTable(Mutex* m);\n-\n-  template <class Closure>\n-  void iterate(Closure& v);\n-\n-  \/\/ Returns the card index of the given within_region pointer relative to the bottom\n-  \/\/ of the given heap region.\n-  static CardIdx_t card_within_region(OopOrNarrowOopStar within_region, HeapRegion* hr);\n-  \/\/ Adds the reference from \"from to this remembered set.\n-  void add_reference(OopOrNarrowOopStar from, uint tid);\n-\n-  \/\/ Returns whether the remembered set contains the given reference.\n-  bool contains_reference(OopOrNarrowOopStar from) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) have an occupancy\n-  \/\/ that is less or equal than the given occupancy.\n-  bool occupancy_less_or_equal_than(size_t limit) const;\n-\n-  \/\/ Returns whether this remembered set (and all sub-sets) does not contain any entry.\n-  bool is_empty() const;\n-\n-  \/\/ Returns the number of cards contained in this remembered set.\n-  size_t occupied() const;\n-\n-  static jint n_coarsenings() { return _n_coarsenings; }\n-\n-  \/\/ Returns size of the actual remembered set containers in bytes.\n-  size_t mem_size() const;\n-  \/\/ Returns the size of static data in bytes.\n-  static size_t static_mem_size();\n-  \/\/ Returns the size of the free list content in bytes.\n-  static size_t fl_mem_size();\n-\n-  \/\/ Clear the entire contents of this remembered set.\n-  void clear();\n-\n-  \/\/ Safe for use by concurrent readers outside _m\n-  bool is_region_coarsened(RegionIdx_t from_hrm_ind) const;\n-};\n-\n-class PerRegionTable: public CHeapObj<mtGC> {\n-  friend class OtherRegionsTable;\n-\n-  HeapRegion*     _hr;\n-  CHeapBitMap     _bm;\n-  jint            _occupied;\n-\n-  \/\/ next pointer for free\/allocated 'all' list\n-  PerRegionTable* _next;\n-\n-  \/\/ next pointer in collision list\n-  PerRegionTable * _collision_list_next;\n-\n-  \/\/ Global free list of PRTs\n-  static PerRegionTable* volatile _free_list;\n-\n-protected:\n-  PerRegionTable(HeapRegion* hr) :\n-    _hr(hr),\n-    _bm(HeapRegion::CardsPerRegion, mtGC),\n-    _occupied(0),\n-    _next(NULL),\n-    _collision_list_next(NULL)\n-  {}\n-\n-public:\n-  \/\/ We need access in order to union things into the base table.\n-  BitMap* bm() { return &_bm; }\n-\n-  HeapRegion* hr() const { return Atomic::load_acquire(&_hr); }\n-\n-  jint occupied() const {\n-    return _occupied;\n-  }\n-\n-  void init(HeapRegion* hr, bool clear_links_to_all_list);\n-\n-  inline bool add_reference(OopOrNarrowOopStar from);\n-\n-  inline bool add_card(CardIdx_t from_card_index);\n-\n-  \/\/ (Destructively) union the bitmap of the current table into the given\n-  \/\/ bitmap (which is assumed to be of the same size.)\n-  void union_bitmap_into(BitMap* bm) {\n-    bm->set_union(_bm);\n-  }\n-\n-  \/\/ Mem size in bytes.\n-  size_t mem_size() const {\n-    return sizeof(PerRegionTable) + _bm.size_in_words() * HeapWordSize;\n-  }\n-\n-  \/\/ Requires \"from\" to be in \"hr()\".\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    assert(hr()->is_in_reserved(from), \"Precondition.\");\n-    size_t card_ind = pointer_delta(from, hr()->bottom(),\n-                                    G1CardTable::card_size);\n-    return _bm.at(card_ind);\n-  }\n-\n-  \/\/ Bulk-free the PRTs from prt to last, assumes that they are\n-  \/\/ linked together using their _next field.\n-  static void bulk_free(PerRegionTable* prt, PerRegionTable* last) {\n-    while (true) {\n-      PerRegionTable* fl = _free_list;\n-      last->set_next(fl);\n-      PerRegionTable* res = Atomic::cmpxchg(&_free_list, fl, prt);\n-      if (res == fl) {\n-        return;\n-      }\n-    }\n-    ShouldNotReachHere();\n-  }\n-\n-  static void free(PerRegionTable* prt) {\n-    bulk_free(prt, prt);\n-  }\n-\n-  \/\/ Returns an initialized PerRegionTable instance.\n-  static PerRegionTable* alloc(HeapRegion* hr);\n-\n-  PerRegionTable* next() const { return _next; }\n-  void set_next(PerRegionTable* next) { _next = next; }\n-\n-  \/\/ Accessor and Modification routines for the pointer for the\n-  \/\/ singly linked collision list that links the PRTs within the\n-  \/\/ OtherRegionsTable::_fine_grain_regions hash table.\n-  \/\/\n-\n-  PerRegionTable* collision_list_next() const {\n-    return _collision_list_next;\n-  }\n-\n-  void set_collision_list_next(PerRegionTable* next) {\n-    _collision_list_next = next;\n-  }\n-\n-  PerRegionTable** collision_list_next_addr() {\n-    return &_collision_list_next;\n-  }\n-\n-  static size_t fl_mem_size() {\n-    PerRegionTable* cur = _free_list;\n-    size_t res = 0;\n-    while (cur != NULL) {\n-      res += cur->mem_size();\n-      cur = cur->next();\n-    }\n-    return res;\n-  }\n-\n-  static void test_fl_mem_size();\n-};\n+class outputStream;\n@@ -278,3 +41,1 @@\n-private:\n-  G1BlockOffsetTable* _bot;\n-\n+  Mutex _m;\n@@ -285,1 +46,1 @@\n-  Mutex _m;\n+  G1CardSetMemoryManager _card_set_mm;\n@@ -287,1 +48,2 @@\n-  OtherRegionsTable _other_regions;\n+  \/\/ The set of cards in the Java heap\n+  G1CardSet _card_set;\n@@ -291,0 +53,1 @@\n+  inline void split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const;\n@@ -294,1 +57,1 @@\n-  HeapRegionRemSet(G1BlockOffsetTable* bot, HeapRegion* hr);\n+  HeapRegionRemSet(HeapRegion* hr, G1CardSetConfiguration* config);\n@@ -297,1 +60,3 @@\n-  static void setup_remset_size();\n+  bool cardset_is_empty() const {\n+    return _card_set.is_empty();\n+  }\n@@ -300,1 +65,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.is_empty();\n+    return (strong_code_roots_list_length() == 0) && cardset_is_empty();\n@@ -304,1 +69,1 @@\n-    return (strong_code_roots_list_length() == 0) && _other_regions.occupancy_less_or_equal_than(occ);\n+    return (strong_code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n@@ -307,8 +72,5 @@\n-  \/\/ For each PRT in the card (remembered) set call one of the following methods\n-  \/\/ of the given closure:\n-  \/\/\n-  \/\/ set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs\n-  \/\/ set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs\n-  \/\/ set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs\n-  template <class Closure>\n-  inline void iterate_prts(Closure& cl);\n+  \/\/ Iterate the card based remembered set for merging them into the card table.\n+  \/\/ The passed closure must be a CardOrRangeVisitor; we use a template parameter\n+  \/\/ to pass it in to facilitate inlining as much as possible.\n+  template <class CardOrRangeVisitor>\n+  inline void iterate_for_merge(CardOrRangeVisitor& cl);\n@@ -317,1 +79,1 @@\n-    return _other_regions.occupied();\n+    return _card_set.occupied();\n@@ -320,1 +82,2 @@\n-  static jint n_coarsenings() { return OtherRegionsTable::n_coarsenings(); }\n+  \/\/ Coarsening statistics since VM start.\n+  static G1CardSetCoarsenStats coarsen_stats() { return G1CardSet::coarsen_stats(); }\n@@ -342,8 +105,3 @@\n-  void set_state_empty() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(), \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n-    if (_state == Untracked) {\n-      return;\n-    }\n-    clear_fcc();\n-    _state = Untracked;\n-  }\n+  inline void set_state_empty();\n+  inline void set_state_updating();\n+  inline void set_state_complete();\n@@ -351,27 +109,1 @@\n-  void set_state_updating() {\n-    guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(), \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n-    clear_fcc();\n-    _state = Updating;\n-  }\n-\n-  void set_state_complete() {\n-    clear_fcc();\n-    _state = Complete;\n-  }\n-\n-  void add_reference(OopOrNarrowOopStar from, uint tid) {\n-    RemSetState state = _state;\n-    if (state == Untracked) {\n-      return;\n-    }\n-\n-    uint cur_idx = _hr->hrm_index();\n-    uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n-\n-    if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n-      assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n-      return;\n-    }\n-\n-    _other_regions.add_reference(from, tid);\n-  }\n+  inline void add_reference(OopOrNarrowOopStar from, uint tid);\n@@ -384,2 +116,4 @@\n-  \/\/ The actual # of bytes this hr_remset takes up.\n-  \/\/ Note also includes the strong code root set.\n+  G1CardSetMemoryStats card_set_memory_stats() const { return _card_set_mm.memory_stats(); }\n+\n+  \/\/ The actual # of bytes this hr_remset takes up. Also includes the strong code\n+  \/\/ root set.\n@@ -387,5 +121,2 @@\n-    MutexLocker x(&_m, Mutex::_no_safepoint_check_flag);\n-    return _other_regions.mem_size()\n-      \/\/ This correction is necessary because the above includes the second\n-      \/\/ part.\n-      + (sizeof(HeapRegionRemSet) - sizeof(OtherRegionsTable))\n+    return _card_set.mem_size()\n+      + (sizeof(HeapRegionRemSet) - sizeof(G1CardSet)) \/\/ Avoid double-counting G1CardSet.\n@@ -395,0 +126,4 @@\n+  size_t wasted_mem_size() {\n+    return _card_set.wasted_mem_size();\n+  }\n+\n@@ -398,1 +133,1 @@\n-    return OtherRegionsTable::static_mem_size() + G1CodeRootSet::static_mem_size();\n+    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size() + sizeof(G1CardSetFreePool);\n@@ -401,5 +136,1 @@\n-  \/\/ Returns the memory occupancy of all free_list data structures associated\n-  \/\/ with remembered sets.\n-  static size_t fl_mem_size() {\n-    return OtherRegionsTable::fl_mem_size();\n-  }\n+  static void print_static_mem_size(outputStream* out);\n@@ -407,3 +138,3 @@\n-  bool contains_reference(OopOrNarrowOopStar from) const {\n-    return _other_regions.contains_reference(from);\n-  }\n+  inline bool contains_reference(OopOrNarrowOopStar from);\n+\n+  inline void print_info(outputStream* st, OopOrNarrowOopStar from);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":43,"deletions":312,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"gc\/g1\/sparsePRT.hpp\"\n@@ -35,3 +36,8 @@\n-template <class Closure>\n-inline void HeapRegionRemSet::iterate_prts(Closure& cl) {\n-  _other_regions.iterate(cl);\n+void HeapRegionRemSet::set_state_empty() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() || !is_tracked(),\n+            \"Should only set to Untracked during safepoint but is %s.\", get_state_str());\n+  if (_state == Untracked) {\n+    return;\n+  }\n+  clear_fcc();\n+  _state = Untracked;\n@@ -40,6 +46,5 @@\n-inline bool PerRegionTable::add_card(CardIdx_t from_card_index) {\n-  if (_bm.par_set_bit(from_card_index)) {\n-    Atomic::inc(&_occupied, memory_order_relaxed);\n-    return true;\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_updating() {\n+  guarantee(SafepointSynchronize::is_at_safepoint() && !is_tracked(),\n+            \"Should only set to Updating from Untracked during safepoint but is %s\", get_state_str());\n+  clear_fcc();\n+  _state = Updating;\n@@ -48,13 +53,3 @@\n-inline bool PerRegionTable::add_reference(OopOrNarrowOopStar from) {\n-  \/\/ Must make this robust in case \"from\" is not in \"_hr\", because of\n-  \/\/ concurrency.\n-\n-  HeapRegion* loc_hr = hr();\n-  \/\/ If the test below fails, then this table was reused concurrently\n-  \/\/ with this operation.  This is OK, since the old table was coarsened,\n-  \/\/ and adding a bit to the new table is never incorrect.\n-  if (loc_hr->is_in_reserved(from)) {\n-    CardIdx_t from_card = OtherRegionsTable::card_within_region(from, loc_hr);\n-    return add_card(from_card);\n-  }\n-  return false;\n+void HeapRegionRemSet::set_state_complete() {\n+  clear_fcc();\n+  _state = Complete;\n@@ -63,10 +58,4 @@\n-inline void PerRegionTable::init(HeapRegion* hr, bool clear_links_to_all_list) {\n-  if (clear_links_to_all_list) {\n-    set_next(NULL);\n-  }\n-  _collision_list_next = NULL;\n-  _occupied = 0;\n-  _bm.clear();\n-  \/\/ Make sure that the bitmap clearing above has been finished before publishing\n-  \/\/ this PRT to concurrent threads.\n-  Atomic::release_store(&_hr, hr);\n+\n+template <class CardOrRangeVisitor>\n+inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  _card_set.iterate_for_merge(cl);\n@@ -75,15 +64,10 @@\n-template <class Closure>\n-void OtherRegionsTable::iterate(Closure& cl) {\n-  if (Atomic::load(&_has_coarse_entries)) {\n-    BitMap::idx_t cur = _coarse_map.get_next_one_offset(0);\n-    while (cur != _coarse_map.size()) {\n-      cl.next_coarse_prt((uint)cur);\n-      cur = _coarse_map.get_next_one_offset(cur + 1);\n-    }\n-  }\n-  {\n-    PerRegionTable* cur = _first_all_fine_prts;\n-    while (cur != NULL) {\n-      cl.next_fine_prt(cur->hr()->hrm_index(), cur->bm());\n-      cur = cur->next();\n-    }\n+void HeapRegionRemSet::split_card(OopOrNarrowOopStar from, uint& card_region, uint& card_within_region) const {\n+  HeapRegion* hr = G1CollectedHeap::heap()->heap_region_containing(from);\n+  card_region = hr->hrm_index();\n+  card_within_region = (uint)(pointer_delta((HeapWord*)from, hr->bottom()) >> (CardTable::card_shift - LogHeapWordSize));\n+}\n+\n+void HeapRegionRemSet::add_reference(OopOrNarrowOopStar from, uint tid) {\n+  RemSetState state = _state;\n+  if (state == Untracked) {\n+    return;\n@@ -91,6 +75,9 @@\n-  {\n-    SparsePRTBucketIter iter(&_sparse_table);\n-    SparsePRTEntry* cur;\n-    while (iter.has_next(cur)) {\n-      cl.next_sparse_prt(cur->r_ind(), cur->cards(), cur->num_valid_cards());\n-    }\n+\n+  uint cur_idx = _hr->hrm_index();\n+  uintptr_t from_card = uintptr_t(from) >> CardTable::card_shift;\n+\n+  if (G1FromCardCache::contains_or_replace(tid, cur_idx, from_card)) {\n+    \/\/ We can't check whether the card is in the remembered set - the card container\n+    \/\/ may be coarsened just now.\n+    \/\/assert(contains_reference(from), \"We just found \" PTR_FORMAT \" in the FromCardCache\", p2i(from));\n+   return;\n@@ -98,0 +85,25 @@\n+\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.add_card(card_region, card_within_region);\n+}\n+\n+bool HeapRegionRemSet::contains_reference(OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  return _card_set.contains_card(card_region, card_within_region);\n+}\n+\n+void HeapRegionRemSet::print_info(outputStream* st, OopOrNarrowOopStar from) {\n+  uint card_region;\n+  uint card_within_region;\n+\n+  split_card(from, card_region, card_within_region);\n+\n+  _card_set.print_info(st, card_region, card_within_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":67,"deletions":55,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetArrayOfCardsEntriesConstraintFunc(uint value, bool verbose) {\n@@ -34,1 +34,1 @@\n-  \/\/ Default value of G1RSetRegionEntries=0 means will be set ergonomically.\n+  \/\/ Default value of G1RemSetArrayOfCardsEntries=0 means will be set ergonomically.\n@@ -36,1 +36,1 @@\n-  if (FLAG_IS_CMDLINE(G1RSetRegionEntries) && (value < 1)) {\n+  if (FLAG_IS_CMDLINE(G1RemSetArrayOfCardsEntries) && (value < 1)) {\n@@ -38,2 +38,2 @@\n-                        \"G1RSetRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetArrayOfCardsEntries (%u) must be \"\n+                        \"greater than or equal to 1.\\n\",\n@@ -47,1 +47,1 @@\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error G1RemSetHowlNumBucketsConstraintFunc(uint value, bool verbose) {\n@@ -50,3 +50,4 @@\n-  \/\/ Default value of G1RSetSparseRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetSparseRegionEntries) && (value < 1)) {\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlNumBuckets)) {\n+    return JVMFlag::SUCCESS;\n+  }\n+  if (value == 0 || !is_power_of_2(G1RemSetHowlNumBuckets)) {\n@@ -54,2 +55,2 @@\n-                        \"G1RSetSparseRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n+                        \"G1RemSetHowlNumBuckets (%u) must be a power of two \"\n+                        \"and greater than or equal to 1.\\n\",\n@@ -58,1 +59,8 @@\n-  } else {\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1RemSetHowlMaxNumBucketsConstraintFunc(uint value, bool verbose) {\n+  if (!UseG1GC) return JVMFlag::SUCCESS;\n+\n+  if (!FLAG_IS_CMDLINE(G1RemSetHowlMaxNumBuckets)) {\n@@ -61,0 +69,7 @@\n+  if (!is_power_of_2(G1RemSetHowlMaxNumBuckets)) {\n+    JVMFlag::printError(verbose,\n+                        \"G1RemSetMaxHowlNumBuckets (%u) must be a power of two.\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -33,3 +33,6 @@\n-  \/* G1 Flag Constraints *\/                           \\\n-  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n-  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n+  \/* G1 Remembered Sets Constraints *\/                \\\n+  f(uint,   G1RemSetArrayOfCardsEntriesConstraintFunc)\\\n+  f(uint,   G1RemSetHowlMaxNumBucketsConstraintFunc)  \\\n+  f(uint,   G1RemSetHowlNumBucketsConstraintFunc)     \\\n+                                                      \\\n+  \/* G1 Heap Size Constraints *\/                      \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/g1\/sparsePRT.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-\n-\/\/ Check that the size of the SparsePRTEntry is evenly divisible by the maximum\n-\/\/ member type to avoid SIGBUS when accessing them.\n-STATIC_ASSERT(sizeof(SparsePRTEntry) % sizeof(int) == 0);\n-\n-void SparsePRTEntry::init(RegionIdx_t region_ind) {\n-  \/\/ Check that the card array element type can represent all cards in the region.\n-  \/\/ Choose a large SparsePRTEntry::card_elem_t (e.g. CardIdx_t) if required.\n-  assert(((size_t)1 << (sizeof(SparsePRTEntry::card_elem_t) * BitsPerByte)) *\n-         G1CardTable::card_size >= HeapRegionBounds::max_size(), \"precondition\");\n-  assert(G1RSetSparseRegionEntries > 0, \"precondition\");\n-  _region_ind = region_ind;\n-  _next_index = RSHashTable::NullEntry;\n-  _next_null = 0;\n-}\n-\n-bool SparsePRTEntry::contains_card(CardIdx_t card_index) const {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-SparsePRT::AddCardResult SparsePRTEntry::add_card(CardIdx_t card_index) {\n-  for (int i = 0; i < num_valid_cards(); i++) {\n-    if (card(i) == card_index) {\n-      return SparsePRT::found;\n-    }\n-  }\n-  if (num_valid_cards() < cards_num() - 1) {\n-    _cards[_next_null] = (card_elem_t)card_index;\n-    _next_null++;\n-    return SparsePRT::added;\n-   }\n-  \/\/ Otherwise, we're full.\n-  return SparsePRT::overflow;\n-}\n-\n-void SparsePRTEntry::copy_cards(card_elem_t* cards) const {\n-  memcpy(cards, _cards, cards_num() * sizeof(card_elem_t));\n-}\n-\n-void SparsePRTEntry::copy_cards(SparsePRTEntry* e) const {\n-  copy_cards(e->_cards);\n-  assert(_next_null >= 0, \"invariant\");\n-  assert(_next_null <= cards_num(), \"invariant\");\n-  e->_next_null = _next_null;\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-float RSHashTable::TableOccupancyFactor = 0.5f;\n-\n-\/\/ The empty table can't hold any entries and is effectively immutable\n-\/\/ This means it can be used as an initial sentinel value\n-static int empty_buckets[] = { RSHashTable::NullEntry };\n-RSHashTable RSHashTable::empty_table;\n-\n-RSHashTable::RSHashTable() :\n-  _num_entries(0),\n-  _capacity(0),\n-  _capacity_mask(0),\n-  _occupied_entries(0),\n-  _entries(NULL),\n-  _buckets(empty_buckets),\n-  _free_region(0),\n-  _free_list(NullEntry) { }\n-\n-RSHashTable::RSHashTable(size_t capacity) :\n-  _num_entries((capacity * TableOccupancyFactor) + 1),\n-  _capacity(capacity),\n-  _capacity_mask(capacity - 1),\n-  _occupied_entries(0),\n-  _entries((SparsePRTEntry*)NEW_C_HEAP_ARRAY(char, _num_entries * SparsePRTEntry::size(), mtGC)),\n-  _buckets(NEW_C_HEAP_ARRAY(int, capacity, mtGC)),\n-  _free_region(0),\n-  _free_list(NullEntry)\n-{\n-  clear();\n-}\n-\n-RSHashTable::~RSHashTable() {\n-  \/\/ Nothing to free for empty RSHashTable\n-  if (_buckets != empty_buckets) {\n-    assert(_entries != NULL, \"invariant\");\n-    FREE_C_HEAP_ARRAY(SparsePRTEntry, _entries);\n-    FREE_C_HEAP_ARRAY(int, _buckets);\n-  }\n-}\n-\n-void RSHashTable::clear() {\n-  assert(_buckets != empty_buckets, \"Shouldn't call this for the empty_table\");\n-  _occupied_entries = 0;\n-  guarantee(_entries != NULL, \"invariant\");\n-  guarantee(_buckets != NULL, \"invariant\");\n-\n-  guarantee(_capacity <= ((size_t)1 << (sizeof(int)*BitsPerByte-1)) - 1,\n-                \"_capacity too large\");\n-\n-  \/\/ This will put -1 == NullEntry in the key field of all entries.\n-  memset((void*)_entries, NullEntry, _num_entries * SparsePRTEntry::size());\n-  memset((void*)_buckets, NullEntry, _capacity * sizeof(int));\n-  _free_list = NullEntry;\n-  _free_region = 0;\n-}\n-\n-SparsePRT::AddCardResult RSHashTable::add_card(RegionIdx_t region_ind, CardIdx_t card_index) {\n-  assert(this != &empty_table, \"can't add a card to the empty table\");\n-  SparsePRTEntry* e = entry_for_region_ind_create(region_ind);\n-  assert(e != NULL && e->r_ind() == region_ind,\n-         \"Postcondition of call above.\");\n-  SparsePRT::AddCardResult res = e->add_card(card_index);\n-  assert(e->num_valid_cards() > 0, \"Postcondition\");\n-  return res;\n-}\n-\n-SparsePRTEntry* RSHashTable::get_entry(RegionIdx_t region_ind) const {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int cur_ind = _buckets[ind];\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    cur_ind = cur->next_index();\n-  }\n-\n-  if (cur_ind == NullEntry) return NULL;\n-  \/\/ Otherwise...\n-  assert(cur->r_ind() == region_ind, \"Postcondition of loop + test above.\");\n-  assert(cur->num_valid_cards() > 0, \"Inv\");\n-  return cur;\n-}\n-\n-bool RSHashTable::delete_entry(RegionIdx_t region_ind) {\n-  int ind = (int) (region_ind & capacity_mask());\n-  int* prev_loc = &_buckets[ind];\n-  int cur_ind = *prev_loc;\n-  SparsePRTEntry* cur;\n-  while (cur_ind != NullEntry &&\n-         (cur = entry(cur_ind))->r_ind() != region_ind) {\n-    prev_loc = cur->next_index_addr();\n-    cur_ind = *prev_loc;\n-  }\n-\n-  if (cur_ind == NullEntry) return false;\n-  \/\/ Otherwise, splice out \"cur\".\n-  *prev_loc = cur->next_index();\n-  free_entry(cur_ind);\n-  _occupied_entries--;\n-  return true;\n-}\n-\n-SparsePRTEntry*\n-RSHashTable::entry_for_region_ind_create(RegionIdx_t region_ind) {\n-  SparsePRTEntry* res = get_entry(region_ind);\n-  if (res == NULL) {\n-    int new_ind = alloc_entry();\n-    res = entry(new_ind);\n-    res->init(region_ind);\n-    \/\/ Insert at front.\n-    int ind = (int) (region_ind & capacity_mask());\n-    res->set_next_index(_buckets[ind]);\n-    _buckets[ind] = new_ind;\n-    _occupied_entries++;\n-  }\n-  return res;\n-}\n-\n-int RSHashTable::alloc_entry() {\n-  int res;\n-  if (_free_list != NullEntry) {\n-    res = _free_list;\n-    _free_list = entry(res)->next_index();\n-    return res;\n-  } else if ((size_t)_free_region < _num_entries) {\n-    res = _free_region;\n-    _free_region++;\n-    return res;\n-  } else {\n-    return NullEntry;\n-  }\n-}\n-\n-void RSHashTable::free_entry(int fi) {\n-  entry(fi)->set_next_index(_free_list);\n-  _free_list = fi;\n-}\n-\n-void RSHashTable::add_entry(SparsePRTEntry* e) {\n-  assert(e->num_valid_cards() > 0, \"Precondition.\");\n-  SparsePRTEntry* e2 = entry_for_region_ind_create(e->r_ind());\n-  e->copy_cards(e2);\n-  assert(e2->num_valid_cards() > 0, \"Postcondition.\");\n-}\n-\n-bool RSHashTableBucketIter::has_next(SparsePRTEntry*& entry) {\n-  while (_bl_ind == RSHashTable::NullEntry)  {\n-    if (_tbl_ind + 1 >= _rsht->capacity()) {\n-      return false;\n-    }\n-    _tbl_ind++;\n-    _bl_ind = _rsht->_buckets[_tbl_ind];\n-  }\n-  entry = _rsht->entry(_bl_ind);\n-  _bl_ind = entry->next_index();\n-  return true;\n-}\n-\n-bool RSHashTable::contains_card(RegionIdx_t region_index, CardIdx_t card_index) const {\n-  SparsePRTEntry* e = get_entry(region_index);\n-  return (e != NULL && e->contains_card(card_index));\n-}\n-\n-size_t RSHashTable::mem_size() const {\n-  return sizeof(RSHashTable) +\n-    _num_entries * (SparsePRTEntry::size() + sizeof(int));\n-}\n-\n-\/\/ ----------------------------------------------------------------------\n-\n-SparsePRT::SparsePRT() :\n-  _table(&RSHashTable::empty_table) {\n-}\n-\n-\n-SparsePRT::~SparsePRT() {\n-  if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-  }\n-}\n-\n-\n-size_t SparsePRT::mem_size() const {\n-  \/\/ We ignore \"_cur\" here, because it either = _next, or else it is\n-  \/\/ on the deleted list.\n-  return sizeof(SparsePRT) + _table->mem_size();\n-}\n-\n-SparsePRT::AddCardResult SparsePRT::add_card(RegionIdx_t region_id, CardIdx_t card_index) {\n-  if (_table->should_expand()) {\n-    expand();\n-  }\n-  return _table->add_card(region_id, card_index);\n-}\n-\n-SparsePRTEntry* SparsePRT::get_entry(RegionIdx_t region_id) {\n-  return _table->get_entry(region_id);\n-}\n-\n-bool SparsePRT::delete_entry(RegionIdx_t region_id) {\n-  return _table->delete_entry(region_id);\n-}\n-\n-void SparsePRT::clear() {\n-  \/\/ If the entry table not at initial capacity, just reset to the empty table.\n-  if (_table->capacity() == InitialCapacity) {\n-    _table->clear();\n-  } else if (_table != &RSHashTable::empty_table) {\n-    delete _table;\n-    _table = &RSHashTable::empty_table;\n-  }\n-}\n-\n-void SparsePRT::expand() {\n-  RSHashTable* last = _table;\n-  if (last != &RSHashTable::empty_table) {\n-    _table = new RSHashTable(last->capacity() * 2);\n-    for (size_t i = 0; i < last->num_entries(); i++) {\n-      SparsePRTEntry* e = last->entry((int)i);\n-      if (e->valid_entry()) {\n-        _table->add_entry(e);\n-      }\n-    }\n-    delete last;\n-  } else {\n-    _table = new RSHashTable(InitialCapacity);\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.cpp","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_SPARSEPRT_HPP\n-#define SHARE_GC_G1_SPARSEPRT_HPP\n-\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/shared\/cardTableBarrierSet.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class RSHashTable;\n-class SparsePRTEntry;\n-\n-\/\/ Sparse remembered set for a heap region (the \"owning\" region).  Maps\n-\/\/ indices of other regions to short sequences of cards in the other region\n-\/\/ that might contain pointers into the owner region.\n-\/\/ Concurrent access to a SparsePRT must be serialized by some external mutex.\n-class SparsePRT {\n-  friend class SparsePRTBucketIter;\n-\n-  RSHashTable* _table;\n-\n-  static const size_t InitialCapacity = 8;\n-\n-  void expand();\n-\n-public:\n-  SparsePRT();\n-  ~SparsePRT();\n-\n-  size_t mem_size() const;\n-\n-  enum AddCardResult {\n-    overflow, \/\/ The table is full, could not add the card to the table.\n-    found,    \/\/ The card is already in the PRT.\n-    added     \/\/ The card has been added.\n-  };\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  \/\/ Return the pointer to the entry associated with the given region.\n-  SparsePRTEntry* get_entry(RegionIdx_t region_ind);\n-\n-  \/\/ If there is an entry for \"region_ind\", removes it and return \"true\";\n-  \/\/ otherwise returns \"false.\"\n-  bool delete_entry(RegionIdx_t region_ind);\n-\n-  \/\/ Clear the table, and reinitialize to initial capacity.\n-  void clear();\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-};\n-\n-class SparsePRTEntry: public CHeapObj<mtGC> {\n-public:\n-  \/\/ The type of a card entry.\n-  typedef uint16_t card_elem_t;\n-\n-private:\n-  \/\/ We need to make sizeof(SparsePRTEntry) an even multiple of maximum member size,\n-  \/\/ in order to force correct alignment that could otherwise cause SIGBUS errors\n-  \/\/ when reading the member variables. This calculates the minimum number of card\n-  \/\/ array elements required to get that alignment.\n-  static const size_t card_array_alignment = sizeof(int) \/ sizeof(card_elem_t);\n-\n-  RegionIdx_t _region_ind;\n-  int         _next_index;\n-  int         _next_null;\n-  \/\/ The actual cards stored in this array.\n-  \/\/ WARNING: Don't put any data members beyond this line. Card array has, in fact, variable length.\n-  \/\/ It should always be the last data member.\n-  card_elem_t _cards[card_array_alignment];\n-\n-  \/\/ Copy the current entry's cards into \"cards\".\n-  inline void copy_cards(card_elem_t* cards) const;\n-public:\n-  \/\/ Returns the size of the entry, used for entry allocation.\n-  static size_t size() { return sizeof(SparsePRTEntry) + sizeof(card_elem_t) * (cards_num() - card_array_alignment); }\n-  \/\/ Returns the size of the card array.\n-  static int cards_num() {\n-    return align_up((int)G1RSetSparseRegionEntries, (int)card_array_alignment);\n-  }\n-\n-  \/\/ Set the region_ind to the given value, and delete all cards.\n-  inline void init(RegionIdx_t region_ind);\n-\n-  RegionIdx_t r_ind() const { return _region_ind; }\n-  bool valid_entry() const { return r_ind() >= 0; }\n-\n-  int next_index() const { return _next_index; }\n-  int* next_index_addr() { return &_next_index; }\n-  void set_next_index(int ni) { _next_index = ni; }\n-\n-  \/\/ Returns \"true\" iff the entry contains the given card index.\n-  inline bool contains_card(CardIdx_t card_index) const;\n-\n-  \/\/ Returns the number of non-NULL card entries.\n-  inline int num_valid_cards() const { return _next_null; }\n-\n-  inline SparsePRT::AddCardResult add_card(CardIdx_t card_index);\n-\n-  \/\/ Copy the current entry's cards into the \"_card\" array of \"e.\"\n-  inline void copy_cards(SparsePRTEntry* e) const;\n-\n-  card_elem_t* cards() { return _cards; }\n-\n-  inline CardIdx_t card(int i) const {\n-    assert(i >= 0, \"must be nonnegative\");\n-    assert(i < cards_num(), \"range checking\");\n-    return (CardIdx_t)_cards[i];\n-  }\n-};\n-\n-class RSHashTable : public CHeapObj<mtGC> {\n-\n-  friend class RSHashTableBucketIter;\n-\n-  \/\/ Inverse maximum hash table occupancy used.\n-  static float TableOccupancyFactor;\n-\n-  size_t _num_entries;\n-\n-  size_t _capacity;\n-  size_t _capacity_mask;\n-  size_t _occupied_entries;\n-\n-  SparsePRTEntry* _entries;\n-  int* _buckets;\n-  int  _free_region;\n-  int  _free_list;\n-\n-  \/\/ Requires that the caller hold a lock preventing parallel modifying\n-  \/\/ operations, and that the the table be less than completely full.  If\n-  \/\/ an entry for \"region_ind\" is already in the table, finds it and\n-  \/\/ returns its address; otherwise allocates, initializes, inserts and\n-  \/\/ returns a new entry for \"region_ind\".\n-  SparsePRTEntry* entry_for_region_ind_create(RegionIdx_t region_ind);\n-\n-  \/\/ Returns the index of the next free entry in \"_entries\".\n-  int alloc_entry();\n-  \/\/ Declares the entry \"fi\" to be free.  (It must have already been\n-  \/\/ deleted from any bucket lists.\n-  void free_entry(int fi);\n-\n-  \/\/ For the empty sentinel created at static initialization time\n-  RSHashTable();\n-\n-public:\n-  RSHashTable(size_t capacity);\n-  ~RSHashTable();\n-\n-  static const int NullEntry = -1;\n-  static RSHashTable empty_table;\n-\n-  bool should_expand() const { return _occupied_entries == _num_entries; }\n-\n-  \/\/ Attempts to ensure that the given card_index in the given region is in\n-  \/\/ the sparse table.  If successful (because the card was already\n-  \/\/ present, or because it was successfully added) returns \"true\".\n-  \/\/ Otherwise, returns \"false\" to indicate that the addition would\n-  \/\/ overflow the entry for the region.  The caller must transfer these\n-  \/\/ entries to a larger-capacity representation.\n-  SparsePRT::AddCardResult add_card(RegionIdx_t region_id, CardIdx_t card_index);\n-\n-  bool delete_entry(RegionIdx_t region_id);\n-\n-  bool contains_card(RegionIdx_t region_id, CardIdx_t card_index) const;\n-\n-  void add_entry(SparsePRTEntry* e);\n-\n-  SparsePRTEntry* get_entry(RegionIdx_t region_id) const;\n-\n-  void clear();\n-\n-  size_t capacity() const      { return _capacity; }\n-  size_t capacity_mask() const { return _capacity_mask;  }\n-  size_t mem_size() const;\n-  \/\/ The number of SparsePRTEntry instances available.\n-  size_t num_entries() const { return _num_entries; }\n-\n-  SparsePRTEntry* entry(int i) const {\n-    assert(i >= 0 && (size_t)i < _num_entries, \"precondition\");\n-    return (SparsePRTEntry*)((char*)_entries + SparsePRTEntry::size() * i);\n-  }\n-\n-  void print();\n-};\n-\n-\/\/ This is embedded in HRRS iterator.\n-class RSHashTableBucketIter {\n-  uint _tbl_ind;        \/\/ [0.._rsht->_capacity)\n-  int  _bl_ind;         \/\/ [-1, 0.._rsht->_capacity)\n-\n-  RSHashTable* _rsht;\n-\n-public:\n-  RSHashTableBucketIter(RSHashTable* rsht) :\n-    _tbl_ind(0),\n-    _bl_ind(rsht->_buckets[_tbl_ind]),\n-    _rsht(rsht) { }\n-\n-  bool has_next(SparsePRTEntry*& entry);\n-};\n-\n-class SparsePRTBucketIter: public RSHashTableBucketIter {\n-public:\n-  SparsePRTBucketIter(const SparsePRT* sprt) :\n-    RSHashTableBucketIter(sprt->_table) {}\n-\n-  bool has_next(SparsePRTEntry*& entry) {\n-    return RSHashTableBucketIter::has_next(entry);\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_SPARSEPRT_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/sparsePRT.hpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -498,3 +498,1 @@\n-HeapWord* DefNewGeneration::expand_and_allocate(size_t size,\n-                                                bool   is_tlab,\n-                                                bool   parallel) {\n+HeapWord* DefNewGeneration::expand_and_allocate(size_t size, bool is_tlab) {\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -311,3 +311,2 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,3 +191,1 @@\n-TenuredGeneration::expand_and_allocate(size_t word_size,\n-                                       bool is_tlab,\n-                                       bool parallel) {\n+TenuredGeneration::expand_and_allocate(size_t word_size, bool is_tlab) {\n@@ -195,24 +193,2 @@\n-  if (parallel) {\n-    MutexLocker x(ParGCRareEvent_lock);\n-    HeapWord* result = NULL;\n-    size_t byte_size = word_size * HeapWordSize;\n-    while (true) {\n-      expand(byte_size, _min_heap_delta_bytes);\n-      if (GCExpandToAllocateDelayMillis > 0) {\n-        os::naked_sleep(GCExpandToAllocateDelayMillis);\n-      }\n-      result = _the_space->par_allocate(word_size);\n-      if ( result != NULL) {\n-        return result;\n-      } else {\n-        \/\/ If there's not enough expansion space available, give up.\n-        if (_virtual_space.uncommitted_size() < byte_size) {\n-          return NULL;\n-        }\n-        \/\/ else try again\n-      }\n-    }\n-  } else {\n-    expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n-    return _the_space->allocate(word_size);\n-  }\n+  expand(word_size*HeapWordSize, _min_heap_delta_bytes);\n+  return _the_space->allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":4,"deletions":28,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,3 +96,1 @@\n-  HeapWord* expand_and_allocate(size_t size,\n-                                bool is_tlab,\n-                                bool parallel = false);\n+  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  static CardValue clean_card_val()          { return clean_card; }\n-  static CardValue dirty_card_val()          { return dirty_card; }\n+  static constexpr CardValue clean_card_val()          { return clean_card; }\n+  static constexpr CardValue dirty_card_val()          { return dirty_card; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -336,3 +336,1 @@\n-  virtual HeapWord* expand_and_allocate(size_t word_size,\n-                                        bool is_tlab,\n-                                        bool parallel = false) = 0;\n+  virtual HeapWord* expand_and_allocate(size_t word_size, bool is_tlab) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -400,1 +400,0 @@\n-  void set_atomic_discovery(bool atomic) { _discovery_is_atomic = atomic; }\n@@ -564,21 +563,0 @@\n-\/\/ A utility class to temporarily change the disposition\n-\/\/ of the \"discovery_is_atomic\" field of the\n-\/\/ given ReferenceProcessor in the scope that contains it.\n-class ReferenceProcessorAtomicMutator: StackObj {\n- private:\n-  ReferenceProcessor* _rp;\n-  bool                _saved_atomic_discovery;\n-\n- public:\n-  ReferenceProcessorAtomicMutator(ReferenceProcessor* rp,\n-                                  bool atomic):\n-    _rp(rp) {\n-    _saved_atomic_discovery = _rp->discovery_is_atomic();\n-    _rp->set_atomic_discovery(atomic);\n-  }\n-\n-  ~ReferenceProcessorAtomicMutator() {\n-    _rp->set_atomic_discovery(_saved_atomic_discovery);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static const uint MaxThreadWorkItems = 6;\n+  static const uint MaxThreadWorkItems = 9;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-  bool is_Named_thread() const override { return true; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  f(mtGCCardSet,      \"GCCardSet\")   \/* G1 card set remembered set                *\/ \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-void VirtualSpace::print_on(outputStream* out) {\n+void VirtualSpace::print_on(outputStream* out) const {\n@@ -1049,1 +1049,1 @@\n-void VirtualSpace::print() {\n+void VirtualSpace::print() const {\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,2 +243,2 @@\n-  void print_on(outputStream* out) PRODUCT_RETURN;\n-  void print();\n+  void print_on(outputStream* out) const PRODUCT_RETURN;\n+  void print() const;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -686,1 +686,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(this);\n+    SystemDictionaryShared::handle_class_unloading(this);\n@@ -2616,1 +2616,1 @@\n-    SystemDictionaryShared::remove_dumptime_info(ik);\n+    SystemDictionaryShared::handle_class_unloading(ik);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,2 +528,7 @@\n-  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+\n+  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n+  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n@@ -531,0 +536,2 @@\n+  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -540,9 +547,0 @@\n-\n-  \/\/ --- Deprecated alias flags (see also aliased_jvm_flags) - sorted by obsolete_in then expired_in:\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"CreateMinidumpOnCrash\",        JDK_Version::jdk(9),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"TLABStats\",                    JDK_Version::jdk(12), JDK_Version::undefined(), JDK_Version::undefined() },\n-\n-  \/\/ -------------- Obsolete Flags - sorted by expired_in --------------\n-  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n-  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -550,1 +548,1 @@\n-  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::undefined() },\n+  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -680,5 +680,0 @@\n-  product(bool, AlwaysLockClassLoader, false,                               \\\n-          \"(Deprecated) Require the VM to acquire the class loader lock \"   \\\n-          \"before calling loadClass() even for class loaders registering \"  \\\n-          \"as parallel capable\")                                            \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+Mutex*   UnregisteredClassesTable_lock= NULL;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+extern Mutex*   UnregisteredClassesTable_lock;   \/\/ UnregisteredClassesTableTable\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -649,1 +649,3 @@\n-  else                                { st->print(\"Thread\"); }\n+  else if (this == AsyncLogWriter::instance()) {\n+    st->print(\"%s\", this->name());\n+  } else                                { st->print(\"Thread\"); }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-          st->print(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n+          st->print_cr(\"\\t- eliminated <owner is scalar replaced> (a %s)\", k->external_name());\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,0 +192,4 @@\n+\n+    size_t get_mem_size() {\n+      return sizeof(*this) + _size * sizeof(Bucket);\n+    }\n@@ -387,0 +391,2 @@\n+  size_t get_mem_size(Thread* thread);\n+\n@@ -388,1 +394,1 @@\n-  size_t get_node_size() const { return sizeof(Node); }\n+  static size_t get_node_size() { return sizeof(Node); }\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-\/\/ 2^5  = 32 buckets\n-#define SIZE_SMALL_LOG2 5\n+\/\/ 2^2  = 4 buckets\n+#define SIZE_SMALL_LOG2 2\n@@ -820,4 +820,1 @@\n-\n-  if (_new_table->_log2_size == _log2_size_limit) {\n-    _size_limit_reached = true;\n-  }\n+  _size_limit_reached = _new_table->_log2_size == _log2_size_limit;\n@@ -957,0 +954,1 @@\n+    Prefetch::read(current_node->next(), 0);\n@@ -1035,0 +1033,8 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline size_t ConcurrentHashTable<CONFIG, F>::\n+  get_mem_size(Thread* thread)\n+{\n+  ScopedCS cs(thread, this);\n+  return sizeof(*this) + _table->get_mem_size();\n+}\n+\n@@ -1138,2 +1144,0 @@\n-  assert(Thread::current()->is_VM_thread(),\n-         \"should be in vm thread\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -245,0 +245,5 @@\n+  \/\/ The following method is not MT-safe and must be done under lock.\n+  KVHashtableEntry** bucket_addr(int i) {\n+    return (KVHashtableEntry**)BasicHashtable<F>::bucket_addr(i);\n+  }\n+\n@@ -252,0 +257,4 @@\n+  void free_entry(KVHashtableEntry* entry) {\n+    BasicHashtable<F>::free_entry(entry);\n+  }\n+\n@@ -254,0 +263,11 @@\n+  ~KVHashtable() {\n+    KVHashtableEntry* probe = NULL;\n+    for (int index = 0; index < table_size(); index++) {\n+      for (KVHashtableEntry** p = bucket_addr(index); *p != NULL; ) {\n+        probe = *p;\n+        *p = probe->next();\n+        free_entry(probe);\n+      }\n+    }\n+    assert(BasicHashtable<F>::number_of_entries() == 0, \"should have removed all entries\");\n+  }\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -40,0 +39,1 @@\n+import java.util.Objects;\n@@ -740,1 +740,0 @@\n-    @IntrinsicCandidate\n@@ -742,3 +741,1 @@\n-        if ((i < 0) || (i >= limit))\n-            throw new IndexOutOfBoundsException();\n-        return i;\n+        return Objects.checkIndex(i, limit);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+    int V18 = 0 << 16 | 62;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -506,0 +506,3 @@\n+        if (!arrayType.isArray()) {\n+            return parseUnknownArray(length, buf);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,9 @@\n-    RELEASE_17;\n+    RELEASE_17,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @since 18\n+     *\/\n+    RELEASE_18;\n@@ -249,1 +257,1 @@\n-        return RELEASE_17;\n+        return RELEASE_18;\n@@ -264,1 +272,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(17, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(18, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_17)\n+@SupportedSourceVersion(RELEASE_18)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -63,0 +64,1 @@\n+    private AtomicReference<Throwable> printErrorRef = new AtomicReference<>();\n@@ -326,0 +328,1 @@\n+            printErrorRef.set(null);\n@@ -384,0 +387,9 @@\n+\n+            Throwable printError = printErrorRef.getAndSet(null);\n+            if (printError != null) {\n+                if (printError instanceof PrinterException) {\n+                    throw (PrinterException) printError;\n+                }\n+                throw (PrinterException)\n+                    new PrinterException().initCause(printError);\n+            }\n@@ -789,5 +801,13 @@\n-        Runnable r = new Runnable() { public void run() { synchronized(ret) {\n-            try {\n-                int pageResult = printable.print(graphics, pageFormat, pageIndex);\n-                if (pageResult != Printable.NO_SUCH_PAGE) {\n-                    ret[0] = getPageFormatArea(pageFormat);\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                synchronized (ret) {\n+                    try {\n+                        int pageResult = printable.print(\n+                            graphics, pageFormat, pageIndex);\n+                        if (pageResult != Printable.NO_SUCH_PAGE) {\n+                            ret[0] = getPageFormatArea(pageFormat);\n+                        }\n+                    } catch (Throwable t) {\n+                        printErrorRef.compareAndSet(null, t);\n+                    }\n@@ -795,2 +815,2 @@\n-            } catch (Exception e) {} \/\/ Original code bailed on any exception\n-        }}};\n+            }\n+        };\n@@ -799,1 +819,5 @@\n-            try { EventQueue.invokeAndWait(r); } catch (Exception e) { e.printStackTrace(); }\n+            try {\n+                EventQueue.invokeAndWait(r);\n+            } catch (Throwable t) {\n+                printErrorRef.compareAndSet(null, t);\n+            }\n@@ -804,1 +828,3 @@\n-        synchronized(ret) { return ret[0]; }\n+        synchronized (ret) {\n+            return ret[0];\n+        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-final class HttpClientFacade extends HttpClient implements Trackable {\n+public final class HttpClientFacade extends HttpClient implements Trackable {\n@@ -113,0 +113,4 @@\n+    public Executor theExecutor() {\n+        return impl.theExecutor();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+    private final boolean server;\n+    private int maskingKey;\n@@ -65,0 +67,4 @@\n+        this(output, false);\n+    }\n+\n+    MessageDecoder(MessageStreamConsumer output, boolean server) {\n@@ -66,0 +72,1 @@\n+        this.server = server;\n@@ -146,1 +153,1 @@\n-        if (value) {\n+        if (value && !server) {\n@@ -149,0 +156,3 @@\n+        if (!value && server) {\n+            throw new FailWebSocketException(\"Masked frame expected\");\n+        }\n@@ -178,1 +188,3 @@\n-        throw new InternalError();\n+        if (!server)\n+            throw new InternalError();\n+        maskingKey = value;\n@@ -207,1 +219,5 @@\n-                output.onBinary(data.slice(), last);\n+                ByteBuffer slice = data.slice();\n+                if (server) {\n+                    unMask(slice);\n+                }\n+                output.onBinary(slice, last);\n@@ -211,0 +227,3 @@\n+                if (server) {\n+                    unMask(data);\n+                }\n@@ -228,0 +247,11 @@\n+    private void unMask(ByteBuffer src) {\n+        int pos = src.position();\n+        int size = src.remaining();\n+        ByteBuffer temp = ByteBuffer.allocate(size);\n+        Frame.Masker.transferMasking(src, temp, maskingKey);\n+        temp.flip();\n+        src.position(pos);\n+        src.put(temp);\n+        src.position(pos).limit(pos+size);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageDecoder.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -84,0 +84,9 @@\n+    private final boolean server;\n+\n+    MessageEncoder() {\n+        this(false);\n+    }\n+\n+    MessageEncoder(boolean isServer) {\n+        this.server = isServer;\n+    }\n@@ -372,2 +381,9 @@\n-        int mask = maskingKeySource.nextInt();\n-        headerWriter.fin(fin)\n+        \/\/ for server setting mask to 0 disables masking (xor)\n+        int mask = this.server ? 0 : maskingKeySource.nextInt();\n+        if (mask == 0) {\n+            headerWriter.fin(fin)\n+                    .opcode(opcode)\n+                    .payloadLen(payloadLen)\n+                    .write(headerBuffer);\n+        } else {\n+            headerWriter.fin(fin)\n@@ -378,0 +394,1 @@\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/MessageEncoder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.net.http.HttpClientFacade;\n@@ -40,0 +41,1 @@\n+import java.net.http.HttpClient;\n@@ -47,0 +49,1 @@\n+import java.util.concurrent.Executor;\n@@ -118,0 +121,1 @@\n+    private final Executor clientExecutor;\n@@ -122,0 +126,1 @@\n+                                       b.getClient(),\n@@ -143,0 +148,1 @@\n+                                     HttpClient client,\n@@ -146,1 +152,1 @@\n-        WebSocketImpl ws = new WebSocketImpl(uri, subprotocol, listener, transport);\n+        WebSocketImpl ws = new WebSocketImpl(uri, client, subprotocol, listener, transport);\n@@ -154,0 +160,1 @@\n+                          HttpClient client,\n@@ -158,0 +165,1 @@\n+        this.clientExecutor = ((HttpClientFacade)client).theExecutor();\n@@ -359,1 +367,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n@@ -401,1 +409,1 @@\n-     *       x --(1)--> IDLE --(2)--> y (otherwise we're loosing events, or\n+     *       x --(1)--> IDLE --(2)--> y (otherwise we're losing events, or\n@@ -705,1 +713,1 @@\n-        receiveScheduler.runOrSchedule();\n+        receiveScheduler.runOrSchedule(clientExecutor);\n@@ -837,1 +845,1 @@\n-                receiveScheduler.runOrSchedule();\n+                receiveScheduler.runOrSchedule(clientExecutor);\n@@ -853,1 +861,1 @@\n-            receiveScheduler.runOrSchedule();\n+            receiveScheduler.runOrSchedule(clientExecutor);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/WebSocketImpl.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -115,1 +115,6 @@\n-    JDK17(\"17\");\n+    JDK17(\"17\"),\n+\n+    \/**\n+      * 18, tbd\n+      *\/\n+    JDK18(\"18\");\n@@ -167,0 +172,1 @@\n+        case JDK18  -> Target.JDK1_18;\n@@ -309,0 +315,1 @@\n+        case JDK18  -> RELEASE_18;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-        V61(61, 0);   \/\/ JDK 17\n+        V61(61, 0),   \/\/ JDK 17\n+        V62(62, 0);   \/\/ JDK 18\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,4 @@\n-    JDK1_17(\"17\", 61, 0);\n+    JDK1_17(\"17\", 61, 0),\n+\n+    \/** JDK 18. *\/\n+    JDK1_18(\"18\", 62, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.source.tree.AnnotatedTypeTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.TreeScanner;\n@@ -196,0 +199,3 @@\n+        if (new TypeAnnotationFinder().scan(paramTypes, null) != null)\n+            throw new ParseException(\"dc.ref.annotations.not.allowed\");\n+\n@@ -198,1 +204,13 @@\n-}\n+\n+    static class TypeAnnotationFinder extends TreeScanner<Tree, Void> {\n+        @Override\n+        public Tree visitAnnotatedType(AnnotatedTypeTree t, Void ignore) {\n+            return t;\n+        }\n+\n+        @Override\n+        public Tree reduce(Tree t1, Tree t2) {\n+            return t1 != null ? t1 : t2;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_17)\n+@SupportedSourceVersion(SourceVersion.RELEASE_18)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3269,0 +3269,3 @@\n+compiler.err.dc.ref.annotations.not.allowed=\\\n+    annotations not allowed\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,24 +78,30 @@\n-        HashMap<String,List<String>> map;\n-\n-       \/**\n-        * Creates an empty instance of {@code Headers}.\n-        *\/\n-        public Headers () {map = new HashMap<String,List<String>>(32);}\n-\n-        \/**\n-         * Normalize the key by converting to following form.\n-         * First {@code char} upper case, rest lower case.\n-         * key is presumed to be {@code ASCII}.\n-         *\/\n-        private String normalize (String key) {\n-            if (key == null) {\n-                return null;\n-            }\n-            int len = key.length();\n-            if (len == 0) {\n-                return key;\n-            }\n-            char[] b = key.toCharArray();\n-            if (b[0] >= 'a' && b[0] <= 'z') {\n-                b[0] = (char)(b[0] - ('a' - 'A'));\n-            } else if (b[0] == '\\r' || b[0] == '\\n')\n+    HashMap<String,List<String>> map;\n+\n+    \/**\n+     * Creates an empty instance of {@code Headers}.\n+     *\/\n+    public Headers() {map = new HashMap<>(32);}\n+\n+    \/**\n+     * Normalize the key by converting to following form.\n+     * First {@code char} upper case, rest lower case.\n+     * key is presumed to be {@code ASCII}.\n+     *\/\n+    private String normalize(String key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n+        }\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n@@ -103,8 +109,0 @@\n-\n-            for (int i=1; i<len; i++) {\n-                if (b[i] >= 'A' && b[i] <= 'Z') {\n-                    b[i] = (char) (b[i] + ('a' - 'A'));\n-                } else if (b[i] == '\\r' || b[i] == '\\n')\n-                    throw new IllegalArgumentException(\"illegal character in key\");\n-            }\n-            return new String(b);\n@@ -112,0 +110,2 @@\n+        return new String(b);\n+    }\n@@ -113,1 +113,1 @@\n-        public int size() {return map.size();}\n+    public int size() {return map.size();}\n@@ -115,1 +115,1 @@\n-        public boolean isEmpty() {return map.isEmpty();}\n+    public boolean isEmpty() {return map.isEmpty();}\n@@ -117,8 +117,3 @@\n-        public boolean containsKey(Object key) {\n-            if (key == null) {\n-                return false;\n-            }\n-            if (!(key instanceof String)) {\n-                return false;\n-            }\n-            return map.containsKey (normalize((String)key));\n+    public boolean containsKey(Object key) {\n+        if (key == null) {\n+            return false;\n@@ -126,3 +121,2 @@\n-\n-        public boolean containsValue(Object value) {\n-            return map.containsValue(value);\n+        if (!(key instanceof String)) {\n+            return false;\n@@ -130,0 +124,2 @@\n+        return map.containsKey(normalize((String)key));\n+    }\n@@ -131,3 +127,3 @@\n-        public List<String> get(Object key) {\n-            return map.get(normalize((String)key));\n-        }\n+    public boolean containsValue(Object value) {\n+        return map.containsValue(value);\n+    }\n@@ -135,14 +131,3 @@\n-        \/**\n-         * Returns the first value from the {@link List} of {@code String}\n-         * values for the given key (if at least one exists).\n-         *\n-         * @param key the key to search for\n-         * @return the first {@code String} value associated with the key\n-         *\/\n-        public String getFirst (String key) {\n-            List<String> l = map.get(normalize(key));\n-            if (l == null) {\n-                return null;\n-            }\n-            return l.get(0);\n-        }\n+    public List<String> get(Object key) {\n+        return map.get(normalize((String)key));\n+    }\n@@ -150,4 +135,11 @@\n-        public List<String> put(String key, List<String> value) {\n-            for (String v : value)\n-                checkValue(v);\n-            return map.put (normalize(key), value);\n+    \/**\n+     * Returns the first value from the {@link List} of {@code String}\n+     * values for the given key (if at least one exists).\n+     *\n+     * @param key the key to search for\n+     * @return the first {@code String} value associated with the key\n+     *\/\n+    public String getFirst(String key) {\n+        List<String> l = map.get(normalize(key));\n+        if (l == null) {\n+            return null;\n@@ -155,0 +147,2 @@\n+        return l.get(0);\n+    }\n@@ -156,16 +150,20 @@\n-        \/**\n-         * Adds the given value to the list of headers for the given key. If\n-         * the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the value to add to the header\n-         *\/\n-        public void add (String key, String value) {\n-            checkValue(value);\n-            String k = normalize(key);\n-            List<String> l = map.get(k);\n-            if (l == null) {\n-                l = new LinkedList<String>();\n-                map.put(k,l);\n-            }\n-            l.add (value);\n+    public List<String> put(String key, List<String> value) {\n+        for (String v : value)\n+            checkValue(v);\n+        return map.put(normalize(key), value);\n+    }\n+\n+    \/**\n+     * Adds the given value to the list of headers for the given key. If\n+     * the mapping does not already exist, then it is created.\n+     *\n+     * @param key the header name\n+     * @param value the value to add to the header\n+     *\/\n+    public void add(String key, String value) {\n+        checkValue(value);\n+        String k = normalize(key);\n+        List<String> l = map.get(k);\n+        if (l == null) {\n+            l = new LinkedList<>();\n+            map.put(k,l);\n@@ -173,0 +171,2 @@\n+        l.add(value);\n+    }\n@@ -174,20 +174,13 @@\n-        private static void checkValue(String value) {\n-            int len = value.length();\n-            for (int i=0; i<len; i++) {\n-                char c = value.charAt(i);\n-                if (c == '\\r') {\n-                    \/\/ is allowed if it is followed by \\n and a whitespace char\n-                    if (i >= len - 2) {\n-                        throw new IllegalArgumentException(\"Illegal CR found in header\");\n-                    }\n-                    char c1 = value.charAt(i+1);\n-                    char c2 = value.charAt(i+2);\n-                    if (c1 != '\\n') {\n-                        throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n-                    }\n-                    if (c2 != ' ' && c2 != '\\t') {\n-                        throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n-                    }\n-                    i+=2;\n-                } else if (c == '\\n') {\n-                    throw new IllegalArgumentException(\"Illegal LF found in header\");\n+    private static void checkValue(String value) {\n+        int len = value.length();\n+        for (int i=0; i<len; i++) {\n+            char c = value.charAt(i);\n+            if (c == '\\r') {\n+                \/\/ is allowed if it is followed by \\n and a whitespace char\n+                if (i >= len - 2) {\n+                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n+                }\n+                char c1 = value.charAt(i+1);\n+                char c2 = value.charAt(i+2);\n+                if (c1 != '\\n') {\n+                    throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n@@ -195,0 +188,6 @@\n+                if (c2 != ' ' && c2 != '\\t') {\n+                    throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n+                }\n+                i+=2;\n+            } else if (c == '\\n') {\n+                throw new IllegalArgumentException(\"Illegal LF found in header\");\n@@ -197,0 +196,1 @@\n+    }\n@@ -198,13 +198,12 @@\n-        \/**\n-         * Sets the given value as the sole header value for the given\n-         * key. If the mapping does not already exist, then it is created.\n-         *\n-         * @param key the header name\n-         * @param value the header value to set\n-         *\/\n-        public void set (String key, String value) {\n-            LinkedList<String> l = new LinkedList<String>();\n-            l.add (value);\n-            put (key, l);\n-        }\n-\n+    \/**\n+     * Sets the given value as the sole header value for the given\n+     * key. If the mapping does not already exist, then it is created.\n+     *\n+     * @param key the header name\n+     * @param value the header value to set\n+     *\/\n+    public void set(String key, String value) {\n+        LinkedList<String> l = new LinkedList<>();\n+        l.add(value);\n+        put(key, l);\n+    }\n@@ -212,3 +211,3 @@\n-        public List<String> remove(Object key) {\n-            return map.remove(normalize((String)key));\n-        }\n+    public List<String> remove(Object key) {\n+        return map.remove(normalize((String)key));\n+    }\n@@ -216,3 +215,3 @@\n-        public void putAll(Map<? extends String,? extends List<String>> t)  {\n-            map.putAll (t);\n-        }\n+    public void putAll(Map<? extends String,? extends List<String>> t)  {\n+        map.putAll(t);\n+    }\n@@ -220,1 +219,1 @@\n-        public void clear() {map.clear();}\n+    public void clear() {map.clear();}\n@@ -222,1 +221,1 @@\n-        public Set<String> keySet() {return map.keySet();}\n+    public Set<String> keySet() {return map.keySet();}\n@@ -224,1 +223,1 @@\n-        public Collection<List<String>> values() {return map.values();}\n+    public Collection<List<String>> values() {return map.values();}\n@@ -226,3 +225,3 @@\n-        public Set<Map.Entry<String, List<String>>> entrySet() {\n-            return map.entrySet();\n-        }\n+    public Set<Map.Entry<String, List<String>>> entrySet() {\n+        return map.entrySet();\n+    }\n@@ -230,1 +229,1 @@\n-        public boolean equals(Object o) {return map.equals(o);}\n+    public boolean equals(Object o) {return map.equals(o);}\n@@ -232,2 +231,2 @@\n-        public int hashCode() {return map.hashCode();}\n-    }\n+    public int hashCode() {return map.hashCode();}\n+}\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":130,"deletions":131,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -66,2 +66,7 @@\n-static void next_line(FILE *f) {\n-    while (fgetc(f) != '\\n');\n+static int next_line(FILE *f) {\n+    int c;\n+    do {\n+        c = fgetc(f);\n+    } while (c != '\\n' && c != EOF);\n+\n+    return c;\n@@ -96,1 +101,4 @@\n-    next_line(fh);\n+    if (next_line(fh) == EOF) {\n+        fclose(fh);\n+        return -2;\n+    }\n@@ -109,1 +117,4 @@\n-            next_line(fh);\n+            if (next_line(fh) == EOF) {\n+                fclose(fh);\n+                return -2;\n+            }\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-JAVA_RELEASE = 7\n+JAVA_RELEASE = 15\n@@ -56,1 +56,0 @@\n-CC := \"cl.exe\"\n@@ -61,8 +60,0 @@\n-native: require_env\n-ifeq (\"${OS_NAME}\", \"Cygwin\")\n-\t\"${CC}\" src\/windows\/native\/jdk\/test\/failurehandler\/jtreg\/*.c        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\")\"                        \\\n-\t-I\"$(shell cygpath -w \"${JAVA_HOME}\/include\/win32\")\"                  \\\n-\t\/link \/DLL \/OUT:timeoutHandler.dll\n-endif\n-\n@@ -115,1 +106,1 @@\n-build: classes native\n+build: classes\n@@ -117,1 +108,1 @@\n-.PHONY: all build classes native test require_env clean\n+.PHONY: all build classes test require_env clean\n@@ -119,1 +110,0 @@\n-\n","filename":"test\/failure_handler\/Makefile","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-The library requires jtreg 4b13+ and JDK 7+.\n+The library requires jtreg 4b13+ and JDK 15+.\n@@ -105,1 +105,0 @@\n-\n","filename":"test\/failure_handler\/README","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.failurehandler;\n+\n+import java.nio.file.Path;\n+\n+public interface CoreInfoGatherer {\n+    void gatherCoreInfo(HtmlSection section, Path core);\n+}\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/CoreInfoGatherer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,4 @@\n+    public CoreInfoGatherer getCoreInfoGatherer() {\n+        return create();\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/GathererFactory.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -30,0 +31,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +38,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +40,1 @@\n-public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer {\n+public class ToolKit implements EnvironmentInfoGatherer, ProcessInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +43,1 @@\n+    private final PrintWriter log;\n@@ -42,0 +47,1 @@\n+        this.log = log;\n@@ -54,0 +60,21 @@\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        if (core.getFileName().toString().endsWith(\".gz\")) {\n+            Path unpackedCore = Path.of(core.toString().replace(\".gz\", \"\"));\n+            try (GZIPInputStream gzis = new GZIPInputStream(Files.newInputStream(core))) {\n+                Files.copy(gzis, unpackedCore);\n+                for (ActionSet set : actions) {\n+                    set.gatherCoreInfo(section, unpackedCore);\n+                }\n+                Files.delete(unpackedCore);\n+            } catch (IOException ioe) {\n+                log.printf(\"Unexpected exception whilc opening %s\", core.getFileName().toString());\n+                ioe.printStackTrace(log);\n+            }\n+        } else {\n+            for (ActionSet set : actions) {\n+                set.gatherCoreInfo(section, core);\n+            }\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/ToolKit.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import com.sun.tools.attach.VirtualMachine;\n-import com.sun.tools.attach.VirtualMachineDescriptor;\n@@ -137,1 +135,1 @@\n-    private File findApp(String app) {\n+    public File findApp(String app) {\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionHelper.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.test.failurehandler.CoreInfoGatherer;\n@@ -31,0 +32,1 @@\n+import java.io.IOException;\n@@ -32,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -35,0 +39,1 @@\n+import java.util.zip.GZIPInputStream;\n@@ -36,1 +41,1 @@\n-public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer {\n+public class ActionSet implements ProcessInfoGatherer, EnvironmentInfoGatherer, CoreInfoGatherer {\n@@ -39,0 +44,2 @@\n+    private static final String CORES_PROPERTY = \"cores\";\n+\n@@ -49,0 +56,1 @@\n+    private final List<PatternAction> coreActions;\n@@ -58,0 +66,1 @@\n+        coreActions = getPatternActions(log, p, CORES_PROPERTY);\n@@ -126,0 +135,7 @@\n+\n+    @Override\n+    public void gatherCoreInfo(HtmlSection section, Path core) {\n+        for (PatternAction action : coreActions) {\n+            helper.runPatternAction(action, section, core.toString());\n+        }\n+    }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/ActionSet.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+        for (int i = 0, n = args.length; i < n; ++i) {\n+            args[i] = args[i].replace(\"%java\", helper.findApp(\"java\").getAbsolutePath());\n+        }\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/action\/PatternAction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -38,2 +39,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -48,0 +47,2 @@\n+    public static final String CORES_OUTPUT = \"cores.html\";\n+\n@@ -67,1 +68,1 @@\n-        PrintWriter log;\n+        PrintWriter log1;\n@@ -70,1 +71,1 @@\n-            log = new PrintWriter(new FileWriter(\n+            log1 = new PrintWriter(new FileWriter(\n@@ -74,2 +75,2 @@\n-            log = new PrintWriter(System.out);\n-            log.printf(\"ERROR: %s cannot open log file %s\", name,\n+            log1 = new PrintWriter(System.out);\n+            log1.printf(\"ERROR: %s cannot open log file %s\", name,\n@@ -77,1 +78,1 @@\n-            e.printStackTrace(log);\n+            e.printStackTrace(log1);\n@@ -79,0 +80,1 @@\n+        final PrintWriter log = log1;\n@@ -86,0 +88,5 @@\n+            Files.walk(workDir)\n+                    .filter(Files::isRegularFile)\n+                    .filter(f -> (f.getFileName().toString().contains(\"core\") || f.getFileName().toString().contains(\"mdmp\")))\n+                    .forEach(core -> gatherCoreInfo(workDir, name,\n+                            core, log, gathererFactory.getCoreInfoGatherer()));\n@@ -99,0 +106,16 @@\n+    private void gatherCoreInfo(Path workDir, String name, Path core, PrintWriter log,\n+                               CoreInfoGatherer gatherer) {\n+        File output = workDir.resolve(CORES_OUTPUT).toFile();\n+        try (HtmlPage html = new HtmlPage(new PrintWriter(\n+                new FileWriter(output, true), true))) {\n+            try (ElapsedTimePrinter timePrinter\n+                         = new ElapsedTimePrinter(new Stopwatch(), name, log)) {\n+                gatherer.gatherCoreInfo(html.getRootSection(), core);\n+            }\n+        } catch (Throwable e) {\n+            log.printf(\"ERROR: exception in observer on getting environment \"\n+                    + \"information %s:\", name);\n+            e.printStackTrace(log);\n+        }\n+    }\n+\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherDiagnosticInfoObserver.java","additions":31,"deletions":8,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Field;\n@@ -105,27 +104,0 @@\n-    @Override\n-    protected long getProcessId(Process process) {\n-        long result = super.getProcessId(process);\n-        if (result == 0L) {\n-            \/* jtreg didn't find pid, most probably we are on JDK < 9\n-               there is no Process::getPid *\/\n-            if (HAS_NATIVE_LIBRARY && \"windows\".equals(OS.current().family)) {\n-                try {\n-                    Field field = process.getClass().getDeclaredField(\"handle\");\n-                    boolean old = field.canAccess(process);\n-                    try {\n-                        field.setAccessible(true);\n-                        long handle = field.getLong(process);\n-                        result = getWin32Pid(handle);\n-                    } finally {\n-                        field.setAccessible(old);\n-                    }\n-                } catch (ReflectiveOperationException e) {\n-                    e.printStackTrace(log);\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    private native long getWin32Pid(long handle);\n-\n","filename":"test\/failure_handler\/src\/share\/classes\/jdk\/test\/failurehandler\/jtreg\/GatherProcessInfoTimeoutHandler.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  jstack\n+  jstack jhsdb.jstack\n@@ -54,0 +54,1 @@\n+jcmd.vm.info.args=%p VM.info\n@@ -63,0 +64,9 @@\n+jhsdb.app=jhsdb\n+jhsdb.jstack.args=jstack --mixed --pid %p\n+jhsdb.jstack.params.repeat=6\n+\n+cores=jhsdb.jstack\n+jhsdb.jstack.app=jhsdb\n+# Assume that java standard laucher has been used\n+jhsdb.jstack.args=jstack --mixed --core %p --exe %java\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -58,0 +59,7 @@\n+\n+cores=native.gdb\n+native.gdb.app=gdb\n+# Assume that java standard laucher has been used\n+native.gdb.args=%java\\0-c\\0%p\\0-batch\\0-ex\\0thread apply all backtrace\n+native.gdb.args.delimiter=\\0\n+\n@@ -131,1 +139,0 @@\n-\n","filename":"test\/failure_handler\/src\/share\/conf\/linux.properties","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+cores=native.lldb\n+native.lldb.app=lldb\n+native.lldb.delimiter=\\0\n+# Assume that java standard laucher has been used\n+native.lldb.args=--core\\0%p\\0%java\\0-o\\0thread backtrace all\\0-o\\0quit\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/mac.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <windows.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-JNIEXPORT jlong JNICALL Java_jdk_test_failurehandler_jtreg_GatherProcessInfoTimeoutHandler_getWin32Pid\n-        (JNIEnv* env, jobject o, jlong handle) {\n-    return GetProcessId((HANDLE) handle);\n-}\n-#ifdef __cplusplus\n-}\n-#endif\n","filename":"test\/failure_handler\/src\/windows\/native\/libtimeoutHandler\/GatherProcessInfoTimeoutHandler.c","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -63,5 +63,8 @@\n-  HeapRegion hr0(0, &bot, mr0);\n-  HeapRegion hr1(1, &bot, mr1);\n-  HeapRegion hr2(2, &bot, mr2);\n-  HeapRegion hr3(3, &bot, mr3);\n-  HeapRegion hr4(4, &bot, mr4);\n+  G1CardSetConfiguration config;\n+\n+  HeapRegion hr0(0, &bot, mr0, &config);\n+  HeapRegion hr1(1, &bot, mr1, &config);\n+  HeapRegion hr2(2, &bot, mr2, &config);\n+  HeapRegion hr3(3, &bot, mr3, &config);\n+  HeapRegion hr4(4, &bot, mr4, &config);\n+\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSet.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/workgroup.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+class G1CardSetTest : public ::testing::Test {\n+\n+  class G1CountCardsClosure : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    size_t _num_cards;\n+\n+    G1CountCardsClosure() : _num_cards(0) { }\n+    void do_card(uint region_idx, uint card_idx) override {\n+      _num_cards++;\n+    }\n+  };\n+\n+  static WorkGang* _workers;\n+  static uint _max_workers;\n+\n+  static WorkGang* workers() {\n+    if (_workers == NULL) {\n+      _max_workers = os::processor_count();\n+      _workers = new WorkGang(\"G1CardSetTest Work Gang\", _max_workers, false, false);\n+      _workers->initialize_workers();\n+      _workers->update_active_workers(_max_workers);\n+    }\n+    return _workers;\n+  }\n+\n+  \/\/ Check whether iteration agrees with the expected number of entries. If the\n+  \/\/ add has been single-threaded, we can also check whether the occupied()\n+  \/\/ (which is an estimate in that case) agrees.\n+  static void check_iteration(G1CardSet* card_set,\n+                              const size_t expected,\n+                              const bool add_was_single_threaded = true);\n+\n+public:\n+  G1CardSetTest() { }\n+  ~G1CardSetTest() { }\n+\n+  static uint next_random(uint& seed, uint i) {\n+    \/\/ ParkMiller random number generator\n+    seed = (seed * 279470273u) % 0xfffffffb;\n+    return (seed % i);\n+  }\n+\n+  static void cardset_basic_test();\n+  static void cardset_mt_test();\n+\n+  static void add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results);\n+  static void contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards);\n+\n+  static void translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards);\n+\n+  static void iterate_cards(G1CardSet* card_set, G1CardSet::G1CardSetCardIterator* cl);\n+};\n+\n+WorkGang* G1CardSetTest::_workers = NULL;\n+uint G1CardSetTest::_max_workers = 0;\n+\n+void G1CardSetTest::add_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards, G1AddCardResult* results) {\n+  for (uint i = 0; i < num_cards; i++) {\n+\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    G1AddCardResult res = card_set->add_card(region_idx, card_idx);\n+    if (results != NULL) {\n+      ASSERT_TRUE(res == results[i]);\n+    }\n+  }\n+}\n+\n+class G1CheckCardClosure : public G1CardSet::G1CardSetCardIterator {\n+  G1CardSet* _card_set;\n+\n+  uint _cards_per_region;\n+  uint* _cards_to_expect;\n+  uint _num_cards;\n+\n+  bool _wrong_region_idx;\n+\n+public:\n+  G1CheckCardClosure(G1CardSet* card_set, uint cards_per_region, uint* cards_to_expect, uint num_cards) :\n+    _card_set(card_set),\n+    _cards_per_region(cards_per_region),\n+    _cards_to_expect(cards_to_expect),\n+    _num_cards(num_cards),\n+    _wrong_region_idx(false) {\n+  }\n+\n+  void do_card(uint region_idx, uint card_idx) override {\n+    uint card = _cards_per_region * region_idx + card_idx;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] == card) {\n+        _cards_to_expect[i] = (uint)-1;\n+      }\n+    }\n+  }\n+\n+  bool all_found() const {\n+    bool all_good = true;\n+    for (uint i = 0; i < _num_cards; i++) {\n+      if (_cards_to_expect[i] != (uint)-1) {\n+        log_error(gc)(\"Could not find card %u in region %u\",\n+                      _cards_to_expect[i] % _cards_per_region,\n+                      _cards_to_expect[i] \/ _cards_per_region);\n+        all_good = false;\n+      }\n+    }\n+    return all_good;\n+  }\n+};\n+\n+void G1CardSetTest::contains_cards(G1CardSet* card_set, uint cards_per_region, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    uint region_idx = cards[i] \/ cards_per_region;\n+    uint card_idx = cards[i] % cards_per_region;\n+\n+    ASSERT_TRUE(card_set->contains_card(region_idx, card_idx));\n+  }\n+\n+  G1CheckCardClosure cl(card_set, cards_per_region, cards, num_cards);\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(cl.all_found());\n+}\n+\n+\/\/ Offsets the card indexes in the cards array by the region_idx.\n+void G1CardSetTest::translate_cards(uint cards_per_region, uint region_idx, uint* cards, uint num_cards) {\n+  for (uint i = 0; i < num_cards; i++) {\n+    cards[i] = cards_per_region * region_idx + cards[i];\n+  }\n+}\n+\n+class G1CountCardsOccupied : public G1CardSet::G1CardSetPtrIterator {\n+  size_t _num_occupied;\n+\n+public:\n+  G1CountCardsOccupied() : _num_occupied(0) { }\n+\n+  void do_cardsetptr(uint region_idx, size_t num_occupied, G1CardSet::CardSetPtr card_set) override {\n+    _num_occupied += num_occupied;\n+  }\n+\n+  size_t num_occupied() const { return _num_occupied; }\n+};\n+\n+void G1CardSetTest::check_iteration(G1CardSet* card_set, const size_t expected, const bool single_threaded) {\n+\n+  class CheckIterator : public G1CardSet::G1CardSetCardIterator {\n+  public:\n+    G1CardSet* _card_set;\n+    size_t _num_found;\n+\n+    CheckIterator(G1CardSet* card_set) : _card_set(card_set), _num_found(0) { }\n+\n+    void do_card(uint region_idx, uint card_idx) override {\n+      ASSERT_TRUE(_card_set->contains_card(region_idx, card_idx));\n+      _num_found++;\n+    }\n+  } cl(card_set);\n+\n+  card_set->iterate_cards(cl);\n+\n+  ASSERT_TRUE(expected == cl._num_found);\n+  \/\/ We can assert this only if we are single-threaded.\n+  if (single_threaded) {\n+    ASSERT_EQ(card_set->occupied(), cl._num_found);\n+  }\n+}\n+\n+void G1CardSetTest::cardset_basic_test() {\n+\n+  const uint CardsPerRegion = 2048;\n+  const double FullCardSetThreshold = 0.8;\n+  const double BitmapCoarsenThreshold = 0.9;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 28, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 1, 2, 3 };\n+    G1AddCardResult results1[] = { Added, Added, Added };\n+    translate_cards(CardsPerRegion, 99, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+\n+    check_iteration(&card_set, 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 17 };\n+    G1AddCardResult results1[] = { Added, Added, Added, Found };\n+    translate_cards(CardsPerRegion, 100, cards1, ARRAY_SIZE(cards1));\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), results1);\n+    \/\/ -1 because of the duplicate at the end.\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1) - 1);\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1) - 1);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1) - 1);\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[] = { 0, 2047, 17, 18 \/* for region 100 *\/,\n+                      1,  128, 35, 17 \/* for region 990 *\/\n+                    };\n+    translate_cards(CardsPerRegion, 100, &cards1[0], 4);\n+    translate_cards(CardsPerRegion, 990, &cards1[4], 4);\n+\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint cards1[100];\n+    for (uint i = 0; i < ARRAY_SIZE(cards1); i++) {\n+      cards1[i] = i + 3;\n+      translate_cards(CardsPerRegion, i, &cards1[i], 1);\n+    }\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    contains_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1));\n+\n+    ASSERT_TRUE(card_set.num_containers() == ARRAY_SIZE(cards1));\n+    ASSERT_TRUE(card_set.occupied() == ARRAY_SIZE(cards1));\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == ARRAY_SIZE(cards1));\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+\n+  {\n+    G1CardSet card_set(&config, &mm);\n+\n+    \/\/ Generate non-prime numbers from 1 to 1000\n+    uint count = 0;\n+    for (uint i = 2; i < 33; i++) {\n+      if (!card_set.contains_card(100, i)) {\n+        for (uint j = i * i; j < 1000; j += i) {\n+          G1AddCardResult res = card_set.add_card(100, j);\n+          count += (res == Added);\n+        }\n+      }\n+    }\n+\n+    G1CountCardsOccupied cl;\n+    card_set.iterate_containers(&cl);\n+\n+    ASSERT_TRUE(count == card_set.occupied());\n+    ASSERT_TRUE(card_set.occupied() == cl.num_occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+  { \/\/ Test coarsening to full\n+    G1CardSet card_set(&config, &mm);\n+\n+    uint count = 0;\n+    uint i = 10;\n+    uint bitmap_threshold = config.cards_in_howl_bitmap_threshold();\n+    for (; i <  bitmap_threshold + 10; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    G1AddCardResult res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 1);\n+    \/\/ Adding above card should have coarsened Bitmap -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(config.num_cards_in_howl_bitmap() == card_set.occupied());\n+\n+    res = card_set.add_card(99, config.num_cards_in_howl_bitmap() - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    uint threshold = config.cards_in_howl_threshold();\n+    uint adjusted_threshold = config.cards_in_howl_bitmap_threshold() * config.num_buckets_in_howl();\n+    i = config.num_cards_in_howl_bitmap();\n+    count = i;\n+    for (; i <  threshold; i++) {\n+      G1AddCardResult res = card_set.add_card(99, i);\n+      ASSERT_TRUE(res == Added);\n+      count++;\n+      ASSERT_TRUE(count == card_set.occupied());\n+    }\n+\n+    res = card_set.add_card(99, CardsPerRegion - 1);\n+    \/\/ Adding above card should have coarsened Howl -> Full.\n+    ASSERT_TRUE(res == Added);\n+    ASSERT_TRUE(CardsPerRegion == card_set.occupied());\n+\n+    check_iteration(&card_set, card_set.occupied());\n+\n+    res = card_set.add_card(99, CardsPerRegion - 2);\n+    ASSERT_TRUE(res == Found);\n+\n+    G1CountCardsClosure count_cards;\n+    card_set.iterate_cards(count_cards);\n+    ASSERT_TRUE(count_cards._num_cards == config.max_cards_in_region());\n+\n+    card_set.clear();\n+    ASSERT_TRUE(card_set.occupied() == 0);\n+  }\n+}\n+\n+class G1CardSetMtTestTask : public AbstractGangTask {\n+  G1CardSet* _card_set;\n+\n+  size_t _added;\n+  size_t _found;\n+\n+public:\n+  G1CardSetMtTestTask(G1CardSet* card_set) :\n+    AbstractGangTask(\"\"),\n+    _card_set(card_set),\n+    _added(0),\n+    _found(0) { }\n+\n+  void work(uint worker_id) {\n+    uint seed = worker_id;\n+    size_t added = 0;\n+    size_t found = 0;\n+\n+    for (uint i = 0; i < 100000; i++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      G1AddCardResult res = _card_set->add_card(region, card);\n+\n+      ASSERT_TRUE(res == Added || res == Found);\n+      if (res == Added) {\n+        added++;\n+      } else if (res == Found) {\n+        found++;\n+      }\n+    }\n+    Atomic::add(&_added, added);\n+    Atomic::add(&_found, found);\n+  }\n+\n+  size_t added() const { return _added; }\n+  size_t found() const { return _found; }\n+};\n+\n+void G1CardSetTest::cardset_mt_test() {\n+  const uint CardsPerRegion = 16384;\n+  const double FullCardSetThreshold = 1.0;\n+  const uint BitmapCoarsenThreshold = 1.0;\n+\n+  G1CardSetConfiguration config(log2i_exact(CardsPerRegion), 120, BitmapCoarsenThreshold, 8, FullCardSetThreshold, CardsPerRegion);\n+  G1CardSetFreePool free_pool(config.num_mem_object_types());\n+  G1CardSetMemoryManager mm(&config, &free_pool);\n+\n+  G1CardSet card_set(&config, &mm);\n+\n+  const uint num_workers = workers()->active_workers();\n+\n+  G1CardSetMtTestTask cl(&card_set);\n+\n+  {\n+    GCTraceTime(Error, gc) x(\"Cardset test\");\n+    _workers->run_task(&cl, num_workers);\n+  }\n+\n+  size_t num_found = 0;\n+  \/\/ Now check the contents of the card set.\n+  for (uint i = 0; i < num_workers; i++) {\n+    uint seed = i;\n+\n+    for (uint j = 0; j < 100000; j++) {\n+      uint region = G1CardSetTest::next_random(seed, 1000);\n+      uint card = G1CardSetTest::next_random(seed, 10000);\n+\n+      bool contains = card_set.contains_card(region, card);\n+      ASSERT_TRUE(contains);\n+\n+      num_found += contains;\n+    }\n+  }\n+\n+  ASSERT_TRUE(num_found == cl.added() + cl.found());\n+\n+  G1CountCardsClosure count_cards;\n+  card_set.iterate_cards(count_cards);\n+\n+  check_iteration(&card_set, count_cards._num_cards, false \/* add_was_single_threaded *\/);\n+\n+  \/\/ During coarsening we try to unblock concurrent threads as soon as possible,\n+  \/\/ so we do not add the cards from the smaller CardSetContainer to the larger\n+  \/\/ one immediately, allowing addition by concurrent threads after allocating\n+  \/\/ the space immediately. So the amount of \"successfully added\" results may be\n+  \/\/ (and in case of many threads typically is) higher than the number of unique\n+  \/\/ cards.\n+  ASSERT_TRUE(count_cards._num_cards <= cl.added());\n+}\n+\n+TEST_VM(G1CardSetTest, basic_cardset_test) {\n+  G1CardSetTest::cardset_basic_test();\n+}\n+\n+TEST_VM(G1CardSetTest, mt_cardset_test) {\n+  G1CardSetTest::cardset_mt_test();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,263 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"gc\/g1\/heapRegionBounds.inline.hpp\"\n+#include \"gc\/shared\/cardTable.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CardSetContainersTest : public ::testing::Test {\n+public:\n+  G1CardSetContainersTest() { }\n+  ~G1CardSetContainersTest() { }\n+\n+  static uint cards_per_inlineptr_set(uint bits_per_card) {\n+    return G1CardSetInlinePtr::max_cards_in_inline_ptr(bits_per_card);\n+  }\n+\n+  static void cardset_inlineptr_test(uint bits_per_card);\n+  static void cardset_array_test(uint cards_per_array);\n+  static void cardset_bitmap_test(uint threshold, uint size_in_bits);\n+};\n+\n+class G1FindCardsInRange : public StackObj {\n+  uint _num_cards;\n+  uint _range_min;\n+  bool* _cards_found;\n+public:\n+  G1FindCardsInRange(uint range_min, uint range_max) :\n+    _num_cards(range_max - range_min + 1),\n+    _range_min(range_min),\n+    _cards_found(NEW_C_HEAP_ARRAY(bool, _num_cards, mtGC)) {\n+    for (uint i = 0; i < _num_cards; i++) {\n+      _cards_found[i] = false;\n+    }\n+  }\n+\n+  void verify_all_found() {\n+    verify_part_found(_num_cards);\n+  }\n+\n+  void verify_part_found(uint num) {\n+    for (uint i = 0; i < num; i++) {\n+      ASSERT_TRUE(_cards_found[i]);\n+    }\n+  }\n+\n+  ~G1FindCardsInRange() {\n+    FREE_C_HEAP_ARRAY(mtGC, _cards_found);\n+  }\n+  void operator()(uint card) {\n+    ASSERT_TRUE((card - _range_min) < _num_cards);\n+    ASSERT_FALSE(_cards_found[card - _range_min]); \/\/ Must not have been found yet.\n+    _cards_found[card - _range_min] = true;\n+  }\n+};\n+\n+void G1CardSetContainersTest::cardset_inlineptr_test(uint bits_per_card) {\n+  const uint CardsPerSet = cards_per_inlineptr_set(bits_per_card);\n+\n+  G1AddCardResult res;\n+\n+  G1CardSet::CardSetPtr value = G1CardSetInlinePtr();\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+      ASSERT_TRUE(res == Added);\n+    }\n+    {\n+      G1CardSetInlinePtr cards(&value, value);\n+      ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+    }\n+  }\n+\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(i + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    G1CardSetInlinePtr cards(&value, value);\n+    res = cards.add(CardsPerSet + 1, bits_per_card, CardsPerSet);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < CardsPerSet; i++) {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(cards.contains(i + 1, bits_per_card));\n+  }\n+\n+  \/\/ Boundary cards should not be in the set.\n+  {\n+    G1CardSetInlinePtr cards(value);\n+    ASSERT_TRUE(!cards.contains(0, bits_per_card));\n+    ASSERT_TRUE(!cards.contains(CardsPerSet + 1, bits_per_card));\n+  }\n+\n+  \/\/ Verify iteration finds all cards too and only those.\n+  {\n+    G1FindCardsInRange found(1, CardsPerSet);\n+    G1CardSetInlinePtr cards(value);\n+    cards.iterate(found, bits_per_card);\n+    found.verify_all_found();\n+  }\n+}\n+\n+void G1CardSetContainersTest::cardset_array_test(uint cards_per_array) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetArray::size_in_bytes(cards_per_array), mtGC);\n+  G1CardSetArray* cards = new (cardset_data) G1CardSetArray(1, cards_per_array);\n+\n+  ASSERT_TRUE(cards->contains(1)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_entries() == 1); \/\/ Check it's the only one.\n+\n+  G1AddCardResult res;\n+\n+  \/\/ Add some elements\n+  for (uint i = 1; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  \/\/ Check they are in the container.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    res = cards->add(i + 1);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(cards_per_array + 1);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < cards_per_array; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0));\n+  ASSERT_TRUE(!cards->contains(cards_per_array + 1));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, cards_per_array);\n+    cards->iterate(found);\n+    found.verify_all_found();\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+void G1CardSetContainersTest::cardset_bitmap_test(uint threshold, uint size_in_bits) {\n+  uint8_t* cardset_data = NEW_C_HEAP_ARRAY(uint8_t, G1CardSetBitMap::size_in_bytes(size_in_bits), mtGC);\n+  G1CardSetBitMap* cards = new (cardset_data) G1CardSetBitMap(1, size_in_bits);\n+\n+  ASSERT_TRUE(cards->contains(1, size_in_bits)); \/\/ Added during initialization\n+  ASSERT_TRUE(cards->num_bits_set() == 1); \/\/ Should be the only one.\n+\n+  G1AddCardResult res;\n+\n+  for (uint i = 1; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Added);\n+  }\n+\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  \/\/ Try to add again, should all return that the card had been added.\n+  for (uint i = 0; i < threshold; i++) {\n+    res = cards->add(i + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Found);\n+  }\n+\n+  \/\/ Should be no more space in set.\n+  {\n+    res = cards->add(threshold + 1, threshold, size_in_bits);\n+    ASSERT_TRUE(res == Overflow);\n+  }\n+\n+  \/\/ Cards should still be in the set.\n+  for (uint i = 0; i < threshold; i++) {\n+    ASSERT_TRUE(cards->contains(i + 1, size_in_bits));\n+  }\n+\n+  ASSERT_TRUE(!cards->contains(0, size_in_bits));\n+\n+  \/\/ Verify iteration finds all cards too.\n+  {\n+    G1FindCardsInRange found(1, threshold + 1);\n+    cards->iterate(found, size_in_bits, 0);\n+    found.verify_part_found(threshold);\n+  }\n+\n+  FREE_C_HEAP_ARRAY(mtGC, cardset_data);\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_inptr_test) {\n+  uint const min = (uint)log2i(HeapRegionBounds::min_size());\n+  uint const max = (uint)log2i(HeapRegionBounds::max_size());\n+\n+  for (uint i = min; i <= max; i++) {\n+    G1CardSetContainersTest::cardset_inlineptr_test(i - CardTable::card_shift);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_array_test) {\n+  uint array_sizes[] = { 5, 9, 63, 77, 127 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(array_sizes); i++) {\n+    size_t const max_cards_in_set = ARRAY_SIZE(array_sizes);\n+    G1CardSetContainersTest::cardset_array_test(max_cards_in_set);\n+  }\n+}\n+\n+TEST_VM_F(G1CardSetContainersTest, basic_cardset_bitmap_test) {\n+  uint bit_sizes[] = { 64, 2048 };\n+  uint threshold_sizes[] = { 17, 330 };\n+\n+  for (uint i = 0; i < ARRAY_SIZE(bit_sizes); i++) {\n+    G1CardSetContainersTest::cardset_bitmap_test(threshold_sizes[i], bit_sizes[i]);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSetContainers.cpp","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -44,1 +44,0 @@\n-  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -48,0 +47,1 @@\n+  ASSERT_TRUE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -54,1 +54,0 @@\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n@@ -58,0 +57,1 @@\n+  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyYoungEvacFail));\n@@ -82,3 +82,0 @@\n-\n-  \/\/ Enabling all is not the same as G1VerifyAll\n-  ASSERT_FALSE(G1HeapVerifier::should_verify(G1HeapVerifier::G1VerifyAll));\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1HeapVerifier.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+serviceability\/sa\/ClhsdbJstackXcompStress.java 8268570 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,5 @@\n-serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062 macosx-x64\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 8239062,8268570 generic-all\n+serviceability\/attach\/RemovingUnixDomainSocketTest.java 8268570 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 8268570 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 8268570 generic-all\n+\n@@ -138,0 +142,1 @@\n+vmTestbase\/nsk\/jdi\/HiddenClass\/events\/events001.java                 8257705 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @author Yi Yang\n+ * @bug 8265518\n+ * @summary C1 intrinsic support for jdk.internal.util.Preconditions.checkIndex\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*TestCheckIndexC1Intrinsic.check*\n+ *                   -XX:CompileCommand=compileonly,*TestCheckIndexC1Intrinsic.check*\n+ *                   compiler.c1.TestCheckIndexC1Intrinsic\n+ *\/\n+\n+package compiler.c1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.util.Preconditions;\n+\n+public class TestCheckIndexC1Intrinsic {\n+    static int limit = 100;\n+\n+    private static class MyException extends RuntimeException {\n+        public MyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    static void check0() {\n+        long res = Preconditions.checkIndex(0, 1, null);\n+        Asserts.assertEquals((int)res, 0);\n+        try {\n+            Preconditions.checkIndex(1, 1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, -1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, Integer.MIN_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Long.MAX_VALUE, Long.MAX_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        res = Preconditions.checkIndex(Long.MAX_VALUE - 1, Long.MAX_VALUE, null);\n+        Asserts.assertEquals(res, Long.MAX_VALUE - 1);\n+\n+        try {\n+            \/\/ read fields\n+            Preconditions.checkIndex(limit + 1, limit, (s, integers) -> new MyException(\"Reason:\" + s + \"::\" + integers));\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch(MyException e){\n+            \/\/ got it!\n+        }\n+    }\n+\n+    static void check1(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check2(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check3(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            Asserts.assertTrue(i == 9999);\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check4(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check5(int i) {\n+        Preconditions.checkIndex(i, 99999, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check6(long i) {\n+        Preconditions.checkIndex(i, 99999L, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check7(int i) {\n+        Preconditions.checkIndex(i, 99999, null);\n+    }\n+\n+    static void check8(long i) {\n+        Preconditions.checkIndex(i, 99999L, null);\n+    }\n+\n+    static void check9(int i) {\n+        Preconditions.checkIndex(i, i + 1, null);\n+    }\n+\n+    static void check10(long i) {\n+        Preconditions.checkIndex(i, i + 1L, null);\n+    }\n+\n+    public static void main(String... args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            check0();\n+\n+            check1(i);\n+            check2((long) i);\n+            check3(i);\n+            check4((long) i);\n+\n+            check5(i);\n+            check6((long) i);\n+            check7(i);\n+            check8((long) i);\n+\n+            check9(i);\n+            check10((long)i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestCheckIndexC1Intrinsic.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,8 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8001183\n+ * @summary incorrect results of char vectors right shift operation\n+ * @requires vm.compiler2.enabled | vm.graal.enabled\n+ *\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect2.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.arguments;\n+\n+\/*\n+ * @test TestG1RemSetFlags\n+ * @requires vm.gc.G1\n+ * @summary Verify that the remembered set flags are updated as expected\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.management\/sun.management\n+ * @library \/test\/lib\n+ * @library \/\n+ * @run driver gc.arguments.TestG1RemSetFlags\n+ *\/\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestG1RemSetFlags {\n+\n+  private static void checkG1RemSetFlags(String[] flags, int exitValue) throws Exception {\n+    ArrayList<String> flagList = new ArrayList<String>();\n+    flagList.addAll(Arrays.asList(flags));\n+    flagList.add(\"-XX:+UseG1GC\");\n+    flagList.add(\"-XX:+PrintFlagsFinal\");\n+    flagList.add(\"-version\");\n+\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(flagList);\n+    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+    output.shouldHaveExitValue(exitValue);\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=8\", \"-XX:G1RemSetHowlMaxNumBuckets=16\"  },  0);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=16\", \"-XX:G1RemSetHowlMaxNumBuckets=8\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlNumBuckets=7\"  },  1);\n+    checkG1RemSetFlags(new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1RemSetHowlMaxNumBuckets=7\"  },  1);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestG1RemSetFlags.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -104,3 +104,8 @@\n-        new LogMessageWithLevel(\"Merged Sparse\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Fine\", Level.DEBUG),\n-        new LogMessageWithLevel(\"Merged Coarse\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Full\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Inline\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl ArrayOfCards\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl BitMap\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Merged Howl Full\", Level.DEBUG),\n@@ -138,0 +143,1 @@\n+        new LogMessageWithLevel(\"Sample Collection Set Candidates\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:G1RSetSparseRegionEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xlog:gc,gc+humongous=debug -XX:+UseG1GC -XX:MaxTenuringThreshold=0 -XX:+UnlockExperimentalVMOptions -XX:G1RemSetArrayOfCardsEntries=32 -XX:G1HeapRegionSize=1m -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.g1.TestNoEagerReclaimOfHumongousRegions\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestNoEagerReclaimOfHumongousRegions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Platform;\n@@ -55,0 +56,3 @@\n+        if (Platform.isDebugBuild()) {\n+            testYoungEvacFail();\n+        }\n@@ -118,0 +122,20 @@\n+    private static void testYoungEvacFail() throws Exception {\n+        OutputAnalyzer output;\n+        output = testWithVerificationType(new String[] {\"young-evac-fail\"},\n+                                          new String[] {\"-XX:+G1EvacuationFailureALot\",\n+                                                        \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                        \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                        \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                        \"-XX:-G1AllowPreventiveGC\"});\n+        output.shouldHaveExitValue(0);\n+\n+        verifyCollection(\"Pause Young (Normal)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Concurrent Start)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Young (Prepare Mixed)\", false, false, true, output.getStdout());\n+        verifyCollection(\"Pause Remark\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Cleanup\", false, false, false, output.getStdout());\n+        verifyCollection(\"Pause Full\", false, false, false, output.getStdout());\n+    }\n+\n+\n@@ -124,1 +148,1 @@\n-        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, concurrent-start, mixed, remark, cleanup and full\");\n+        output.shouldMatch(\"VerifyGCType: '.*' is unknown. Available types are: young-normal, young-evac-fail, concurrent-start, mixed, remark, cleanup and full\");\n@@ -134,1 +158,1 @@\n-    private static OutputAnalyzer testWithVerificationType(String[] types) throws Exception {\n+    private static OutputAnalyzer testWithVerificationType(String[] types, String... extraOpts) throws Exception {\n@@ -154,0 +178,2 @@\n+        Collections.addAll(basicOpts, extraOpts);\n+\n@@ -158,0 +184,1 @@\n+\n@@ -231,0 +258,3 @@\n+\n+        \/\/ This class triggers GCs; we need to make sure that in all of the young gcs\n+        \/\/ at least some objects survive so that evacuation failure can happen.\n@@ -244,0 +274,2 @@\n+\n+            used = alloc1M();\n@@ -245,0 +277,1 @@\n+            partialFree(used);\n@@ -252,0 +285,1 @@\n+            used = alloc1M();\n@@ -253,0 +287,3 @@\n+            partialFree(used);\n+\n+            used = alloc1M();\n@@ -254,0 +291,1 @@\n+            partialFree(used);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @requires vm.gc.Shenandoah\n+ * @bug 8268127\n+ * @summary when heap is too small for regions to align to large page size, should fallback to regular page size\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+\/*\n+ * @test id=lp\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+\/*\n+ * @test id=thp\n+ * @requires vm.gc.Shenandoah\n+ * @requires os.family == \"linux\"\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+public class TestLargePagesWithSmallHeap {\n+    public static void main(String[] args) {\n+        \/\/ Everything is checked on initialization\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestLargePagesWithSmallHeap.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -105,0 +105,2 @@\n+    private static final int CARDSIZE = 512; \/\/ Card size in bytes.\n+\n@@ -232,2 +234,2 @@\n-        \/\/ threshold for sparce -> fine\n-        final int FINE = WB.getIntxVMFlag(\"G1RSetSparseRegionEntries\").intValue();\n+        \/\/ Threshold for Array of Cards -> Howl\n+        final int ARRAY_TO_HOWL_THRESHOLD = WB.getUintVMFlag(\"G1RemSetArrayOfCardsEntries\").intValue();\n@@ -235,2 +237,4 @@\n-        \/\/ threshold for fine -> coarse\n-        final int COARSE = WB.getIntxVMFlag(\"G1RSetRegionEntries\").intValue();\n+        \/\/ Threshold for Howl -> Full\n+        int coarsenHowlToFullPercent = WB.getUintVMFlag(\"G1RemSetCoarsenHowlToFullPercent\").intValue();\n+        int cardsPerRegion = WB.getSizeTVMFlag(\"G1HeapRegionSize\").intValue() \/ CARDSIZE;\n+        final int HOWL_TO_FULL_THRESHOLD = (cardsPerRegion * coarsenHowlToFullPercent) \/ 100;\n@@ -244,2 +248,7 @@\n-        int[] regToRegRefCounts = {0, FINE \/ 2, 0, FINE, (FINE + COARSE) \/ 2, 0,\n-            COARSE, COARSE + 10, FINE + 1, FINE \/ 2, 0};\n+        int[] regToRegRefCounts = {\n+            0, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0, ARRAY_TO_HOWL_THRESHOLD,\n+            (ARRAY_TO_HOWL_THRESHOLD + HOWL_TO_FULL_THRESHOLD) \/ 2, 0,\n+            HOWL_TO_FULL_THRESHOLD, HOWL_TO_FULL_THRESHOLD + 10,\n+            ARRAY_TO_HOWL_THRESHOLD + 1, ARRAY_TO_HOWL_THRESHOLD \/ 2,\n+            0};\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-        excludeTestMaxRange(\"G1RSetRegionEntries\");\n-        excludeTestMaxRange(\"G1RSetSparseRegionEntries\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n@@ -62,1 +62,1 @@\n-        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 8 \/* mtInternal *\/ );\n+        addr = wb.NMTMallocWithPseudoStackAndType(2 * 1024, pc, 9 \/* mtInternal *\/ );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocSiteTypeChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Non jar file in the classpath will be skipped during dump time and runtime.\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @compile test-classes\/Hello.java\n+ * @compile test-classes\/HelloMore.java\n+ * @run driver NonJarInClasspath\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class NonJarInClasspath {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String appJar2 = JarBuilder.build(\"hellomore\", \"HelloMore\");\n+\n+        String outDir = CDSTestUtils.getOutputDir();\n+        String newFile = \"non-exist.jar\";\n+        String nonJarPath = outDir + File.separator + newFile;\n+        String classPath = appJar + File.pathSeparator + nonJarPath + File.pathSeparator + appJar2;\n+        File nonJar = new File(outDir, newFile);\n+        nonJar.createNewFile();\n+\n+        TestCommon.testDump(classPath, TestCommon.list(\"Hello\", \"HelloMore\"));\n+\n+        TestCommon.run(\n+            \"-cp\", classPath,\n+            \"-Xlog:class+load\",\n+            \"Hello\")\n+          .assertNormalExit(out -> {\n+              out.shouldContain(\"Hello source: shared objects file\");\n+          });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonJarInClasspath.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Handling of duplicated classes in dynamic archive with custom loader\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build DuplicatedCustomApp CustomLoadee CustomLoadee2 CustomLoadee3 CustomLoadee3Child\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar DuplicatedCustomApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar custom.jar CustomLoadee\n+ *                  CustomLoadee2 CustomInterface2_ia CustomInterface2_ib\n+ *                  CustomLoadee3 CustomLoadee3Child\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar DuplicatedCustomTest\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class DuplicatedCustomTest extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(DuplicatedCustomTest::testDefaultBase);\n+    }\n+\n+    private static void testDefaultBase() throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+        String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"custom.jar\");\n+        String mainAppClass = \"DuplicatedCustomApp\";\n+        String numberOfLoops = \"2\";\n+\n+        dump(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Written dynamic archive 0x\")\n+                      .shouldContain(\"Skipping CustomLoadee: Duplicated unregistered class\")\n+                      .shouldHaveExitValue(0);\n+                });\n+\n+        run(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds=debug\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, numberOfLoops)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"DuplicatedCustomApp source: shared objects file (top)\")\n+                      .shouldContain(\"CustomLoadee source: shared objects file (top)\")\n+                      .shouldHaveExitValue(0);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DuplicatedCustomTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import sun.hotspot.WhiteBox;\n+\n+public class DuplicatedCustomApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static URLClassLoader loaders[];\n+\n+    \/\/ If DuplicatedCustomApp.class is loaded from JAR file, it means we are dumping the\n+    \/\/ dynamic archive.\n+    static boolean is_dynamic_dumping = !wb.isSharedClass(DuplicatedCustomApp.class);\n+    static boolean is_running_with_dynamic_archive = !is_dynamic_dumping;\n+\n+    public static void main(String args[]) throws Exception {\n+        String path = args[0];\n+        URL url = new File(path).toURI().toURL();\n+        URL[] urls = new URL[] {url};\n+        System.out.println(path);\n+        System.out.println(url);\n+\n+        int num_loops = 1;\n+        if (args.length > 1) {\n+            num_loops = Integer.parseInt(args[1]);\n+        }\n+        loaders = new URLClassLoader[num_loops];\n+        for (int i = 0; i < num_loops; i++) {\n+            loaders[i] = new URLClassLoader(urls);\n+        }\n+\n+        if (is_dynamic_dumping) {\n+            \/\/ Try to load the super interfaces of CustomLoadee2 in different orders\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 1) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ia\");\n+            }\n+            for (int i = 0; i < num_loops; i++) {\n+                int a = (i + 2) % num_loops;\n+                loaders[a].loadClass(\"CustomInterface2_ib\");\n+            }\n+        }\n+\n+        for (int i = 0; i < num_loops; i++) {\n+            System.out.println(\"============================ LOOP = \" + i);\n+            URLClassLoader urlClassLoader = loaders[i];\n+            test(i, urlClassLoader, \"CustomLoadee\");\n+            test(i, urlClassLoader, \"CustomInterface2_ia\");\n+            test(i, urlClassLoader, \"CustomInterface2_ib\");\n+            test(i, urlClassLoader, \"CustomLoadee2\");\n+            test(i, urlClassLoader, \"CustomLoadee3\");\n+            test(i, urlClassLoader, \"CustomLoadee3Child\");\n+        }\n+    }\n+\n+    private static void test(int i, URLClassLoader urlClassLoader, String name) throws Exception {\n+        Class c = urlClassLoader.loadClass(name);\n+        try {\n+            c.newInstance(); \/\/ make sure the class is linked so it can be archived\n+        } catch (Throwable t) {}\n+        boolean is_shared = wb.isSharedClass(c);\n+\n+        System.out.println(\"Class = \" + c + \", loaded from \" + (is_shared ? \"CDS\" : \"Jar\"));\n+        System.out.println(\"Loader = \" + c.getClassLoader());\n+\n+        \/\/ [1] Check that the loaded class is defined by the correct loader\n+        if (c.getClassLoader() != urlClassLoader) {\n+            throw new RuntimeException(\"c.getClassLoader() == \" + c.getClassLoader() +\n+                                       \", expected == \" + urlClassLoader);\n+        }\n+\n+        if (is_running_with_dynamic_archive) {\n+            \/\/ There's only one copy of the shared class of <name> in the\n+            \/\/ CDS archive.\n+            if (i == 0) {\n+                \/\/ The first time we must be able to load it from CDS.\n+                if (!is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from CDS\");\n+                }\n+            } else {\n+                \/\/ All subsequent times, we must load this from JAR file.\n+                if (is_shared) {\n+                    throw new RuntimeException(\"Must be loaded from JAR\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/DuplicatedCustomApp.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -65,1 +65,1 @@\n-\n+        output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ThreadLoggingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+            frame.setVisible(false);\n@@ -52,0 +53,1 @@\n+                Thread.yield();\n","filename":"test\/jdk\/java\/awt\/Robot\/InfiniteLoopException.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8262731\n+   @key headful printer\n+   @summary Verify that \"PrinterJob.print\" throws the expected exception,\n+            if \"Printable.print\" throws an exception.\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN PE\n+   @run main ExceptionFromPrintableIsIgnoredTest MAIN RE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT PE\n+   @run main ExceptionFromPrintableIsIgnoredTest EDT RE\n+ *\/\n+\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.SwingUtilities;\n+\n+public class ExceptionFromPrintableIsIgnoredTest {\n+    private enum TestThreadType {MAIN, EDT}\n+    private enum TestExceptionType {PE, RE}\n+\n+    private volatile Throwable printError;\n+\n+    public static void main(String[] args) {\n+        if (args.length < 2) {\n+            throw new RuntimeException(\"Two arguments are expected:\"\n+                    + \" test thread type and test exception type.\");\n+        }\n+\n+        new ExceptionFromPrintableIsIgnoredTest(\n+            TestThreadType.valueOf(args[0]),\n+            TestExceptionType.valueOf(args[1]));\n+    }\n+\n+    public ExceptionFromPrintableIsIgnoredTest(\n+            final TestThreadType threadType,\n+            final TestExceptionType exceptionType) {\n+        System.out.println(String.format(\n+                \"Test started. threadType='%s', exceptionType='%s'\",\n+                threadType, exceptionType));\n+\n+        String osName = System.getProperty(\"os.name\");\n+        boolean isOSX = osName.toLowerCase().startsWith(\"mac\");\n+        if ((exceptionType == TestExceptionType.RE) && !isOSX) {\n+            System.out.println(\n+                \"Currently this test scenario can be verified only on macOS.\");\n+            return;\n+        }\n+\n+        printError = null;\n+\n+        if (threadType == TestThreadType.MAIN) {\n+            runTest(exceptionType);\n+        } else if (threadType == TestThreadType.EDT) {\n+            try {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        runTest(exceptionType);\n+                    }\n+                });\n+            } catch (InterruptedException | InvocationTargetException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        if (printError == null) {\n+            throw new RuntimeException(\"No exception was thrown.\");\n+        } else if (!(printError instanceof PrinterException)) {\n+            throw new RuntimeException(\"Unexpected exception was thrown.\");\n+        }\n+        System.out.println(\"Test passed.\");\n+    }\n+\n+    private void runTest(final TestExceptionType exceptionType) {\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        if (job.getPrintService() == null) {\n+            System.out.println(\"No printers are available.\");\n+            return;\n+        }\n+\n+        job.setPrintable(new Printable() {\n+            @Override\n+            public int print(Graphics graphics, PageFormat pageFormat,\n+                    int pageIndex) throws PrinterException {\n+                if (pageIndex > 1) {\n+                    return NO_SUCH_PAGE;\n+                }\n+                if (exceptionType == TestExceptionType.PE) {\n+                    throw new PrinterException(\n+                        \"Exception from 'Printable.print'.\");\n+                } else if (exceptionType == TestExceptionType.RE) {\n+                    throw new RuntimeException(\n+                        \"Exception from 'Printable.print'.\");\n+                }\n+                return PAGE_EXISTS;\n+            }\n+        });\n+\n+        try {\n+            job.print();\n+        } catch (Throwable t) {\n+            printError = t;\n+\n+            System.out.println(\"'PrinterJob.print' threw the exception:\");\n+            t.printStackTrace(System.out);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/ExceptionFromPrintableIsIgnoredTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266791\n+ * @summary Annotation property which is compiled as an array property but\n+ *          changed observed as a singular element should throw an\n+ *          AnnotationTypeMismatchException\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @run main ArityTypeMismatchTest\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+\n+import java.lang.annotation.AnnotationTypeMismatchException;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+public class ArityTypeMismatchTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/*\n+         * This test creates an annotation with a member with a non-array type where the annotation\n+         * defines an array property of this type. This can happen if the annotation class is recompiled\n+         * without recompiling the code that declares an annotation of this type. In the example, a\n+         * class is defined to be annotated as\n+         *\n+         * @AnAnnotation(value = {\"v\"}) \/\/ should no longer be an array\n+         * class Carrier { }\n+         *\n+         * where @AnAnnotation expects a singular value.\n+         *\/\n+        ClassWriter writer = new ClassWriter(0);\n+        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n+        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n+        AnnotationVisitor v2 = v.visitArray(\"value\");\n+        v2.visit(null, \"v\");\n+        v2.visitEnd();\n+        v.visitEnd();\n+        writer.visitEnd();\n+        byte[] b = writer.toByteArray();\n+        ByteArrayClassLoader cl = new ByteArrayClassLoader(ArityTypeMismatchTest.class.getClassLoader());\n+        cl.init(b);\n+        AnAnnotation sample = cl.loadClass(\"sample.Carrier\").getAnnotation(AnAnnotation.class);\n+        try {\n+            String value = sample.value();\n+            throw new IllegalStateException(\"Found value: \" + value);\n+        } catch (AnnotationTypeMismatchException e) {\n+            if (!e.element().getName().equals(\"value\")) {\n+                throw new IllegalStateException(\"Unexpected element: \" + e.element());\n+            } else if (!e.foundType().equals(\"Array with component tag: s\")) {\n+                throw new IllegalStateException(\"Unexpected type: \" + e.foundType());\n+            }\n+        }\n+    }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface AnAnnotation {\n+        String value();\n+    }\n+\n+    public static class ByteArrayClassLoader extends ClassLoader {\n+\n+        public ByteArrayClassLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        public void init(byte[] b) {\n+            defineClass(\"sample.Carrier\", b, 0, b.length);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArityTypeMismatchTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+                { 62,   0,  Set.of() },                      \/\/ JDK 18\n@@ -107,1 +108,5 @@\n-                { 62,   0,  Set.of()},                       \/\/ JDK 18\n+                { 62,   0,  Set.of(STATIC) },                \/\/ JDK 18\n+                { 62,   0,  Set.of(TRANSITIVE) },\n+                { 62,   0,  Set.of(STATIC, TRANSITIVE) },\n+\n+                { 63,   0,  Set.of()},                       \/\/ JDK 19\n","filename":"test\/jdk\/java\/lang\/module\/ClassFileVersionsTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268294\n+ * @modules java.net.http\/jdk.internal.net.http.websocket:open jdk.httpserver\n+ * @run main\/othervm\n+ *      --add-reads java.net.http=ALL-UNNAMED\n+ *      --add-reads java.net.http=jdk.httpserver\n+ *      java.net.http\/jdk.internal.net.http.websocket.WebSocketAndHttpTest\n+ *\/\n+public final class WebSocketServerDriver { }\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketServerDriver.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.nio.ByteBuffer;\n+\n+\/**\n+ * No implementation provided for onInit() because that must always be\n+ * implemented by user\n+ *\/\n+abstract class DefaultMessageStreamHandler implements MessageStreamHandler {\n+\n+    public void onText(CharSequence data, boolean last) {}\n+\n+    public void onBinary(ByteBuffer data, boolean last) {}\n+\n+    public void onPing(ByteBuffer data) {}\n+\n+    public void onPong(ByteBuffer data) {}\n+\n+    public void onClose(int statusCode, CharSequence reason) {}\n+\n+    public void onComplete() {}\n+\n+    public void onError(Throwable e) {}\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/DefaultMessageStreamHandler.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+\/**\n+ * WebSocket server listener interface, which is the same as the client API\n+ * in java.net.http. See MessageStreamResponder for how listener methods\n+ * can send response messages back to the client\n+ *\n+ * All MessageStreamConsumer methods must be implemented (plus the handler method\n+ * declared here). DefaultMessageStreamHandler provides empty implementations of all\n+ * that can be extended, except for onInit() which must always be implemented.\n+ *\n+ *    void onText(CharSequence data, boolean last);\n+ *\n+ *    void onBinary(ByteBuffer data, boolean last);\n+ *\n+ *    void onPing(ByteBuffer data);\n+ *\n+ *    void onPong(ByteBuffer data);\n+ *\n+ *    void onClose(int statusCode, CharSequence reason);\n+ *\n+ *    void onComplete();\n+ *\n+ *    void onError(Throwable e);\n+ *\/\n+interface MessageStreamHandler extends MessageStreamConsumer {\n+\n+    \/**\n+     * called before any of the methods above to supply a\n+     * MessageStreamResponder for any new connection, which can be used to send replies\n+     * sendText(), sendBinary(), sendClose() etc\n+     *\/\n+    void onInit(MessageStreamResponder responder);\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamHandler.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.util.List;\n+\n+\/**\n+ * One of these supplied for each incoming client connection for use\n+ * by user written MessageStreamConsumer.\n+ *\/\n+interface MessageStreamResponder {\n+\n+    public void sendText(CharBuffer src, boolean last) throws IOException;\n+\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException;\n+\n+    public void sendPing(ByteBuffer src) throws IOException;\n+\n+    public void sendPong(ByteBuffer src) throws IOException;\n+\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException;\n+\n+    public void close();\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/MessageStreamResponder.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.WebSocket;\n+import java.util.Optional;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * This is the client side of the test invoked from WebSocketAndHttpTest:\n+ *\n+ * The two args are the addresses of a (local) Websocket and Http server\n+ *\n+ * The test first sends a request to the WS server and in the listener\n+ * which handles the response, it tries to send a request to the http\n+ * server. This hangs if the listener was invoked from the selector\n+ * manager thread. If invoked from a different thread then the http\n+ * response is received and the response string is mapped to string\n+ * \"succeeded\"\n+ *\/\n+public class WebSocketAndHttpClient {\n+\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+        HttpClient httpClient = HttpClient.newBuilder().executor(executorService).build();\n+\n+        WebSocketTest wsTest = new WebSocketTest(httpClient, args[0]);\n+        HttpTest httpTest = new HttpTest(httpClient, args[1]);\n+\n+        final CompletableFuture<String> result = new CompletableFuture<>();\n+\n+        wsTest.listen(message -> {\n+            try {\n+                String r = httpTest.getData(message);\n+                result.complete(r);\n+            } catch (Exception e) {\n+                result.completeExceptionally(e);\n+            }\n+        });\n+\n+        wsTest.sendData(\"TEST_DATA\");\n+\n+        System.out.println(\"Wait for result\");\n+        try {\n+            result.join();\n+            System.out.println(\"Result: success\");\n+        } finally {\n+            executorService.shutdownNow();\n+        }\n+    }\n+\n+    static class WebSocketTest {\n+        final HttpClient httpClient;\n+        final String server;\n+        volatile WebSocket webSocket;\n+\n+        WebSocketTest(HttpClient httpClient, String server) {\n+            this.httpClient = httpClient;\n+            this.server = server;\n+        }\n+\n+        public void listen(Consumer<String> consumer) {\n+            URI uri = URI.create(server);\n+            System.out.println(\"WS API client - Connecting to \" + uri.toString());\n+            CompletableFuture<WebSocket> cf = httpClient.newWebSocketBuilder()\n+                .buildAsync(uri, new WebSocket.Listener() {\n+                    @Override\n+                    public CompletionStage<?> onText(WebSocket webSocket, CharSequence data, boolean last) {\n+                        System.out.println(\"WS API client - received data: \" + data);\n+                        consumer.accept(data.toString());\n+                        return null;\n+                    }\n+                    public void onError(WebSocket webSocket, Throwable error) {\n+                        System.out.println(\"WS API client - error\");\n+                        error.printStackTrace();\n+                    }\n+                });\n+            System.out.println(\"CF created\");\n+            webSocket = cf.join();\n+            System.out.println(\"Websocket created\");\n+        }\n+\n+        void sendData(String data) {\n+            System.out.println(\"WS API client - sending data via WebSocket: {}\" + data);\n+            webSocket.sendText(data, true).join();\n+        }\n+    }\n+\n+    static class HttpTest {\n+        final HttpClient httpClient;\n+        final String baseUrl;\n+\n+        HttpTest(HttpClient httpClient, String baseUrl) {\n+            this.httpClient = httpClient;\n+            this.baseUrl = baseUrl;\n+        }\n+\n+        private String getData(String data) throws Exception {\n+            URI uri = URI.create(baseUrl + \"?param=\" + data);\n+            HttpRequest request = HttpRequest.newBuilder().GET().uri(uri).build();\n+            System.out.println(\"Http API Client - send HTTP GET request with parameter {}\" + data);\n+            HttpResponse<String> send = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            return send.body();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpClient.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.net.*;\n+import java.nio.CharBuffer;\n+import java.io.*;\n+\n+import com.sun.net.httpserver.*;\n+\n+public class WebSocketAndHttpTest {\n+    static class WHandler extends DefaultMessageStreamHandler {\n+        volatile MessageStreamResponder responder;\n+\n+        public void onText(CharSequence data, boolean last) {\n+            System.out.println(\"onText: \" + data);\n+            System.out.println(\"onText: \" + Thread.currentThread());\n+            try {\n+                responder.sendText(CharBuffer.wrap(data), true);\n+                System.out.println(\"onText: send ok\");\n+            } catch (IOException e) {\n+                System.out.println(\"onText: \" + e);\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        public void onInit(MessageStreamResponder responder) {\n+            System.out.println(\"onInit\");\n+            this.responder = responder;\n+        }\n+    }\n+\n+    static HttpHandler httpHandler = (ex) -> ex.sendResponseHeaders(200, -1);\n+\n+    public static void main(String[] args) throws Exception {\n+        HttpServer hserver = null;\n+        try {\n+            WebSocketServer server = new WebSocketServer(new WHandler());\n+            server.open();\n+            URI uri = server.getURI();\n+\n+            hserver = HttpServer.create(new InetSocketAddress(0), 4);\n+            hserver.createContext(\"\/\", httpHandler);\n+            hserver.start();\n+\n+            int port = hserver.getAddress().getPort();\n+            URI huri = new URI(\"http:\/\/127.0.0.1:\" + port + \"\/foo\");\n+\n+            WebSocketAndHttpClient.main(new String[]{uri.toString(), huri.toString()});\n+        } finally {\n+            hserver.stop(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketAndHttpTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+\n+public class WebSocketResponder implements MessageStreamResponder {\n+\n+    final MessageStreamConsumer consumer;\n+    final LinkedList<ByteBuffer> queue;\n+    volatile boolean closed = false;\n+\n+    final MessageEncoder encoder;\n+    final MessageDecoder decoder;\n+\n+    static final int BUF_SIZE = 1024;\n+\n+    public WebSocketResponder(MessageStreamConsumer consumer) {\n+        this.consumer = consumer;\n+        this.queue = new LinkedList<>();\n+        this.decoder = new MessageDecoder(consumer, true);\n+        this.encoder = new MessageEncoder(true);\n+    }\n+\n+    \/\/ own thread\n+    public void readLoop(SocketChannel chan) throws IOException {\n+        chan.configureBlocking(true);\n+        boolean eof = false;\n+        ByteBuffer buf = ByteBuffer.allocate(8 * 1024);\n+        Frame.Reader reader = new Frame.Reader();\n+        try {\n+            while (!eof) {\n+                int count;\n+                buf.clear();\n+                eof = ((count=chan.read(buf)) == -1);\n+                if (!eof) {\n+                    buf.flip();\n+                    reader.readFrame(buf, decoder);\n+                }\n+            }\n+        } catch (IOException e) {\n+            if (!closed)\n+                throw e;\n+        }\n+    }\n+\n+    \/\/ own thread\n+    public void writeLoop(SocketChannel chan) throws IOException {\n+        \/\/ read queue and send data\n+        while (true) {\n+            ByteBuffer buf;\n+            synchronized(queue) {\n+                while (queue.isEmpty()) {\n+                    try {\n+                        queue.wait();\n+                    } catch (InterruptedException e) {\n+                        throw new IOException(e);\n+                    }\n+                    if (queue.isEmpty() && closed) {\n+                        chan.close();\n+                        return;\n+                    }\n+                }\n+                buf = queue.remove(0);\n+            }\n+            chan.write(buf);\n+        }\n+    }\n+\n+    \/**\n+     * Public methods below used y MessageStreamHandler to send replies\n+     * to client.\n+     *\/\n+    @Override\n+    public void sendText(CharBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeText(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendBinary(ByteBuffer src, boolean last) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeBinary(src, last, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPing(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePing(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendPong(ByteBuffer src) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodePong(src, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+    }\n+\n+    @Override\n+    public void sendClose(int statusCode, CharBuffer reason) throws IOException {\n+        ByteBuffer buf = ByteBuffer.allocate(BUF_SIZE);\n+        LinkedList<ByteBuffer> bufs = new LinkedList<>();\n+        boolean done = false;\n+        do {\n+            buf.clear();\n+            done = encoder.encodeClose(statusCode, reason, buf);\n+            buf.flip();\n+            bufs.add(buf);\n+        } while (!done);\n+        sendMessage(bufs);\n+        close();\n+    }\n+\n+    private void sendMessage(List<ByteBuffer> bufs) throws IOException {\n+        if (closed)\n+            throw new IOException(\"closed\");\n+        synchronized(queue) {\n+            queue.addAll(bufs);\n+            queue.notify();\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        synchronized(queue) {\n+            closed = true;\n+            queue.notify();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketResponder.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,435 @@\n+\/*\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.websocket;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.StandardSocketOptions;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.CharacterCodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static java.lang.System.err;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * WebSocket Server. This is a copy of the DummyWebSocketServer test class\n+ * but which also supports sending and receiving of websocket messages\n+ * using a simple API once the connection has been established\n+ *\n+ * MessageStreamHandler is the \"listener\" API to be implemented for handling\n+ * incoming messages. MessageStreamResponder is used by that handler to send\n+ * responses back to the client.\n+ *\n+ * Performs simpler version of the WebSocket Opening Handshake over HTTP (i.e.\n+ * no proxying, cookies, etc.) Supports sequential connections, one at a time,\n+ * i.e. in order for a client to connect to the server the previous client must\n+ * disconnect first.\n+ *\n+ * Expected client request:\n+ *\n+ *     GET \/chat HTTP\/1.1\n+ *     Host: server.example.com\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n+ *     Origin: http:\/\/example.com\n+ *     Sec-WebSocket-Protocol: chat, superchat\n+ *     Sec-WebSocket-Version: 13\n+ *\n+ * This server response:\n+ *\n+ *     HTTP\/1.1 101 Switching Protocols\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n+ *     Sec-WebSocket-Protocol: chat\n+ *\/\n+public class WebSocketServer implements Closeable {\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private final Thread thread;\n+    private volatile ServerSocketChannel ssc;\n+    private volatile InetSocketAddress address;\n+    private ByteBuffer read = ByteBuffer.allocate(16384);\n+    private final CountDownLatch readReady = new CountDownLatch(1);\n+    private final MessageStreamHandler handler;\n+    private final WebSocketResponder responder;\n+    private volatile int receiveBufferSize;\n+\n+    private static class Credentials {\n+        private final String name;\n+        private final String password;\n+        private Credentials(String name, String password) {\n+            this.name = name;\n+            this.password = password;\n+        }\n+        public String name() { return name; }\n+        public String password() { return password; }\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler) {\n+        this(handler, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer() {\n+        this(null, defaultMapping(), null, null);\n+    }\n+\n+    public WebSocketServer(String username, String password) {\n+        this(null, defaultMapping(), username, password);\n+    }\n+\n+    public WebSocketServer(MessageStreamHandler handler,\n+                           BiFunction<List<String>,Credentials,List<String>> mapping,\n+                           String username, String password) {\n+        requireNonNull(mapping);\n+        this.handler = handler;\n+        if (handler == null) {\n+            this.responder = null;\n+        } else {\n+            this.responder = new WebSocketResponder(handler);\n+            handler.onInit(this.responder);\n+        }\n+        Credentials credentials = username != null ?\n+                new Credentials(username, password) : null;\n+\n+        thread = new Thread(() -> {\n+            try {\n+                while (!Thread.currentThread().isInterrupted()) {\n+                    err.println(\"Accepting next connection at: \" + ssc);\n+                    SocketChannel channel = ssc.accept();\n+                    err.println(\"Accepted: \" + channel);\n+                    try {\n+                        channel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                        channel.configureBlocking(true);\n+                        while (true) {\n+                            StringBuilder request = new StringBuilder();\n+                            if (!readRequest(channel, request)) {\n+                                throw new IOException(\"Bad request:[\" + request + \"]\");\n+                            }\n+                            List<String> strings = asList(request.toString().split(\"\\r\\n\"));\n+                            List<String> response = mapping.apply(strings, credentials);\n+                            writeResponse(channel, response);\n+\n+                            if (response.get(0).startsWith(\"HTTP\/1.1 401\")) {\n+                                err.println(\"Sent 401 Authentication response \" + channel);\n+                                continue;\n+                            } else {\n+                                serve(channel);\n+                                break;\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        err.println(\"Error in connection: \" + channel + \", \" + e);\n+                    } finally {\n+                        err.println(\"Closed: \" + channel);\n+                        close(channel);\n+                        readReady.countDown();\n+                    }\n+                }\n+            } catch (ClosedByInterruptException ignored) {\n+            } catch (Exception e) {\n+                e.printStackTrace(err);\n+            } finally {\n+                close(ssc);\n+                err.println(\"Stopped at: \" + getURI());\n+            }\n+        });\n+        thread.setName(\"WebSocketServer\");\n+        thread.setDaemon(false);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void read(SocketChannel ch) throws IOException {\n+        responder.readLoop(ch);\n+    }\n+\n+    \/\/ runs in own thread. Override to implement different behavior\n+    protected void write(SocketChannel ch) throws IOException {\n+        responder.writeLoop(ch);\n+    }\n+\n+    protected final void serve(SocketChannel channel)\n+            throws InterruptedException\n+    {\n+        Thread reader = new Thread(() -> {\n+            try {\n+                read(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        Thread writer = new Thread(() -> {\n+            try {\n+                write(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        reader.start();\n+        writer.start();\n+        try {\n+            reader.join();\n+        } finally {\n+            reader.interrupt();\n+            try {\n+                writer.join();\n+            } finally {\n+                writer.interrupt();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer read() throws InterruptedException {\n+        readReady.await();\n+        return read.duplicate().asReadOnlyBuffer().flip();\n+    }\n+\n+    public void setReceiveBufferSize(int bufsize) {\n+        assert ssc == null : \"Must configure before calling open()\";\n+        this.receiveBufferSize = bufsize;\n+    }\n+\n+    public void open() throws IOException {\n+        err.println(\"Starting\");\n+        if (!started.compareAndSet(false, true)) {\n+            throw new IllegalStateException(\"Already started\");\n+        }\n+        ssc = ServerSocketChannel.open();\n+        try {\n+            ssc.configureBlocking(true);\n+            var bufsize = receiveBufferSize;\n+            if (bufsize > 0) {\n+                err.printf(\"Configuring receive buffer size to %d%n\", bufsize);\n+                try {\n+                    ssc.setOption(StandardSocketOptions.SO_RCVBUF, bufsize);\n+                } catch (IOException x) {\n+                    err.printf(\"Failed to configure receive buffer size to %d%n\", bufsize);\n+                }\n+            }\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            address = (InetSocketAddress) ssc.getLocalAddress();\n+            thread.start();\n+        } catch (IOException e) {\n+            close(ssc);\n+            throw e;\n+        }\n+        err.println(\"Started at: \" + getURI());\n+    }\n+\n+    @Override\n+    public void close() {\n+        err.println(\"Stopping: \" + getURI());\n+        thread.interrupt();\n+        close(ssc);\n+    }\n+\n+    URI getURI() {\n+        if (!started.get()) {\n+            throw new IllegalStateException(\"Not yet started\");\n+        }\n+        return URI.create(\"ws:\/\/localhost:\" + address.getPort());\n+    }\n+\n+    private boolean readRequest(SocketChannel channel, StringBuilder request)\n+            throws IOException\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(512);\n+        while (channel.read(buffer) != -1) {\n+            \/\/ read the complete HTTP request headers, there should be no body\n+            CharBuffer decoded;\n+            buffer.flip();\n+            try {\n+                decoded = ISO_8859_1.newDecoder().decode(buffer);\n+            } catch (CharacterCodingException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            request.append(decoded);\n+            if (Pattern.compile(\"\\r\\n\\r\\n\").matcher(request).find())\n+                return true;\n+            buffer.clear();\n+        }\n+        return false;\n+    }\n+\n+    private void writeResponse(SocketChannel channel, List<String> response)\n+            throws IOException\n+    {\n+        String s = response.stream().collect(Collectors.joining(\"\\r\\n\"))\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuffer encoded;\n+        try {\n+            encoded = ISO_8859_1.newEncoder().encode(CharBuffer.wrap(s));\n+        } catch (CharacterCodingException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        while (encoded.hasRemaining()) {\n+            channel.write(encoded);\n+        }\n+    }\n+\n+    private static BiFunction<List<String>,Credentials,List<String>> defaultMapping() {\n+        return (request, credentials) -> {\n+            List<String> response = new LinkedList<>();\n+            Iterator<String> iterator = request.iterator();\n+            if (!iterator.hasNext()) {\n+                throw new IllegalStateException(\"The request is empty\");\n+            }\n+            String statusLine = iterator.next();\n+            if (!(statusLine.startsWith(\"GET \/\") && statusLine.endsWith(\" HTTP\/1.1\"))) {\n+                throw new IllegalStateException\n+                        (\"Unexpected status line: \" + request.get(0));\n+            }\n+            response.add(\"HTTP\/1.1 101 Switching Protocols\");\n+            Map<String, List<String>> requestHeaders = new HashMap<>();\n+            while (iterator.hasNext()) {\n+                String header = iterator.next();\n+                String[] split = header.split(\": \");\n+                if (split.length != 2) {\n+                    throw new IllegalStateException\n+                            (\"Unexpected header: \" + header\n+                                     + \", split=\" + Arrays.toString(split));\n+                }\n+                requestHeaders.computeIfAbsent(split[0], k -> new ArrayList<>()).add(split[1]);\n+\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Protocol\")) {\n+                throw new IllegalStateException(\"Subprotocols are not expected\");\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Extensions\")) {\n+                throw new IllegalStateException(\"Extensions are not expected\");\n+            }\n+            expectHeader(requestHeaders, \"Connection\", \"Upgrade\");\n+            response.add(\"Connection: Upgrade\");\n+            expectHeader(requestHeaders, \"Upgrade\", \"websocket\");\n+            response.add(\"Upgrade: websocket\");\n+            expectHeader(requestHeaders, \"Sec-WebSocket-Version\", \"13\");\n+            List<String> key = requestHeaders.get(\"Sec-WebSocket-Key\");\n+            if (key == null || key.isEmpty()) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key is missing\");\n+            }\n+            if (key.size() != 1) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key has too many values : \" + key);\n+            }\n+            MessageDigest sha1 = null;\n+            try {\n+                sha1 = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new InternalError(e);\n+            }\n+            String x = key.get(0) + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n+            sha1.update(x.getBytes(ISO_8859_1));\n+            String v = Base64.getEncoder().encodeToString(sha1.digest());\n+            response.add(\"Sec-WebSocket-Accept: \" + v);\n+\n+            \/\/ check authorization credentials, if required by the server\n+            if (credentials != null && !authorized(credentials, requestHeaders)) {\n+                response.clear();\n+                response.add(\"HTTP\/1.1 401 Unauthorized\");\n+                response.add(\"Content-Length: 0\");\n+                response.add(\"WWW-Authenticate: Basic realm=\\\"dummy server realm\\\"\");\n+            }\n+\n+            return response;\n+        };\n+    }\n+\n+    \/\/ Checks credentials in the request against those allowable by the server.\n+    private static boolean authorized(Credentials credentials,\n+                                      Map<String,List<String>> requestHeaders) {\n+        List<String> authorization = requestHeaders.get(\"Authorization\");\n+        if (authorization == null)\n+            return false;\n+\n+        if (authorization.size() != 1) {\n+            throw new IllegalStateException(\"Authorization unexpected count:\" + authorization);\n+        }\n+        String header = authorization.get(0);\n+        if (!header.startsWith(\"Basic \"))\n+            throw new IllegalStateException(\"Authorization not Basic: \" + header);\n+\n+        header = header.substring(\"Basic \".length());\n+        String values = new String(Base64.getDecoder().decode(header), UTF_8);\n+        int sep = values.indexOf(':');\n+        if (sep < 1) {\n+            throw new IllegalStateException(\"Authorization not colon: \" +  values);\n+        }\n+        String name = values.substring(0, sep);\n+        String password = values.substring(sep + 1);\n+\n+        if (name.equals(credentials.name()) && password.equals(credentials.password()))\n+            return true;\n+\n+        return false;\n+    }\n+\n+    protected static String expectHeader(Map<String, List<String>> headers,\n+                                         String name,\n+                                         String value) {\n+        List<String> v = headers.get(name);\n+        if (v == null) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s' header, not present in %s\",\n+                           name, headers));\n+        }\n+        if (!v.contains(value)) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s: %s', actual: '%s: %s'\",\n+                           name, value, name, v)\n+            );\n+        }\n+        return value;\n+    }\n+\n+    private static void close(AutoCloseable... acs) {\n+        for (AutoCloseable ac : acs) {\n+            try {\n+                ac.close();\n+            } catch (Exception ignored) { }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/java.net.http\/jdk\/internal\/net\/http\/websocket\/WebSocketServer.java","additions":435,"deletions":0,"binary":false,"changes":435,"status":"added"},{"patch":"@@ -118,1 +118,2 @@\n-            \"RebuildFreeList\"\n+            \"RebuildFreeList\",\n+            \"SampleCandidates\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8266082\n+ * @summary javac should not crash when seeing type annotations in links\n+ * @compile\/fail\/ref=CrashInAnnotateTest.out -Xdoclint -XDrawDiagnostics CrashInAnnotateTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+\/** {@link #equals(@Deprecated Object)}\n+ *  {@link java.util.Map.@Deprecated Entry#getKey()}\n+ *\/\n+class CrashInAnnotateTest {\n+}\n+\n+\/** {@link #compare(Object, List<List<@Deprecated Object>>)} *\/\n+class CrashInAnnotateTest2 {\n+    void compare(Object o, List<List<Object>> l) {}\n+}\n+\n+\/** {@link @Deprecated java.lang.Object#hashCode()} *\/\n+class CrashInAnnotateTest3 { }\n+\n+\/** {@link CrashInAnnotateTest4.@java.lang.Deprecated Inner#aField}\n+ *  {@link java.util.Map.@Deprecated#getKey()}\n+ *\/\n+class CrashInAnnotateTest4 {\n+    class Inner {\n+        Object aField;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+CrashInAnnotateTest.java:10:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:11:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:16:5: compiler.err.proc.messager: annotations not allowed\n+CrashInAnnotateTest.java:18:10: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:21:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:24:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:25:5: compiler.err.proc.messager: syntax error in reference\n+CrashInAnnotateTest.java:28:5: compiler.warn.proc.messager: no comment\n+CrashInAnnotateTest.java:29:16: compiler.warn.proc.messager: no comment\n+6 errors\n+3 warnings\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/doclint\/CrashInAnnotateTest.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ *                                      RELEASE_18\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-        SEVENTEEN(\"17\", 61);\n+        SEVENTEEN(\"17\", 61),\n+        EIGHTEEN(\"18\", 62);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.dc.ref.annotations.not.allowed\n+\/\/ key: compiler.note.note\n+\/\/ key: compiler.note.proc.messager\n+\/\/ run: backdoor\n+\/\/ options: -processor DocCommentProcessor -proc:only\n+\n+\/** {@link #equals(@Deprecated Object)} *\/\n+class NoAnnotationsInLink {\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NoAnnotationsInLink.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -124,1 +124,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -134,1 +134,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -144,1 +144,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -165,1 +165,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -184,1 +184,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -205,1 +205,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -226,1 +226,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n@@ -247,1 +247,1 @@\n-    @SupportedSourceVersion(RELEASE_17)\n+    @SupportedSourceVersion(RELEASE_18)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 17\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 17\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 18\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,2 @@\n-        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\");\n+        Set.of(\"1.7\", \"1.8\", \"1.9\", \"1.10\", \"11\", \"12\", \"13\", \"14\",\n+               \"15\", \"16\", \"17\", \"18\");\n@@ -75,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"61.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"62.0\";\n@@ -88,1 +89,2 @@\n-        SEVENTEEN(false,  \"61.0\", \"17\", Versions::checksrc17);\n+        SEVENTEEN(false, \"61.0\", \"17\", Versions::checksrc17),\n+        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18);\n@@ -304,1 +306,1 @@\n-       \/\/ Add expectedFail after new language features added in a later release.\n+        expectedFail(args, List.of(\"New17.java\"));\n@@ -310,1 +312,8 @@\n-                                  \"New14.java\", \"New15.java\", \"New16.java\"));\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n+       \/\/ Add expectedFail after new language features added in a later release.\n+    }\n+\n+   protected void checksrc18(List<String> args) {\n+       printargs(\"checksrc18\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n@@ -538,0 +547,15 @@\n+\n+        \/*\n+         * Create a file with a new feature in 17, not in 16 : sealed classes\n+         *\/\n+        writeSourceFile(\"New17.java\",\n+            \"\"\"\n+            public class New17 {\n+                public static sealed class Seal {}\n+\n+                public static final class Pinniped extends Seal {}\n+                public static final class TaperedThread extends Seal {}\n+                public static final class Wax extends Seal {}\n+            }\n+            \"\"\"\n+        );\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"}]}