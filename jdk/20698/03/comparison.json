{"files":[{"patch":"@@ -1388,0 +1388,8 @@\n+void Assembler::eaddl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n+\n@@ -1438,0 +1446,9 @@\n+void Assembler::eaddl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x01);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -1443,0 +1460,6 @@\n+void Assembler::eaddl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC0, src, imm32);\n+}\n+\n@@ -1450,0 +1473,9 @@\n+void Assembler::eaddl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x03);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -1455,0 +1487,7 @@\n+void Assembler::eaddl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x01, 0xC0, src1, src2);\n+}\n+\n@@ -1646,0 +1685,8 @@\n+void Assembler::eandl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rsp, src, imm32);\n+}\n+\n@@ -1651,0 +1698,6 @@\n+void Assembler::eandl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE0, src, imm32);\n+}\n+\n@@ -1665,0 +1718,9 @@\n+void Assembler::eandl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x23);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -1670,0 +1732,7 @@\n+void Assembler::eandl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x21, 0xC0, src1, src2);\n+}\n+\n@@ -1817,0 +1886,6 @@\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}\n+\n@@ -1825,0 +1900,9 @@\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Address src2) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int8((0x40 | cc));\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -2443,0 +2527,9 @@\n+void Assembler::edecl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rcx, src, 0);\n+}\n+\n@@ -2488,0 +2581,6 @@\n+void Assembler::eidivl(Register src, bool no_flags) { \/\/ Signed\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n+}\n+\n@@ -2493,0 +2592,6 @@\n+void Assembler::edivl(Register src, bool no_flags) { \/\/ Unsigned\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n@@ -2498,0 +2603,6 @@\n+void Assembler::eimull(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE8 | encode));\n+}\n+\n@@ -2503,0 +2614,6 @@\n+void Assembler::eimull(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n@@ -2517,0 +2634,16 @@\n+void Assembler::eimull(Register dst, Address src, int32_t value, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int8((unsigned char)0x6B);\n+    emit_operand(dst, src, 1);\n+    emit_int8(value);\n+  } else {\n+    emit_int8((unsigned char)0x69);\n+    emit_operand(dst, src, 4);\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -2527,0 +2660,11 @@\n+void Assembler::eimull(Register dst, Register src, int value, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int24(0x6B, (0xC0 | encode), value & 0xFF);\n+  } else {\n+    emit_int16(0x69, (0xC0 | encode));\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -2534,0 +2678,8 @@\n+void Assembler::eimull(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(src1, src2, 0);\n+}\n@@ -2543,0 +2695,10 @@\n+void Assembler::eincl(Register dst, Address src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::increment() instead.\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rax, src, 0);\n+}\n+\n@@ -2710,0 +2872,7 @@\n+void Assembler::elzcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -2719,0 +2888,10 @@\n+void Assembler::elzcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -3869,0 +4048,9 @@\n+void Assembler::emull(Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(rsp, src, 0);\n+}\n+\n@@ -3874,0 +4062,6 @@\n+void Assembler::emull(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE0 | encode));\n+}\n+\n@@ -3915,0 +4109,6 @@\n+void Assembler::enegl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xD8 | encode));\n+}\n+\n@@ -3922,0 +4122,9 @@\n+void Assembler::enegl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(3), src, 0);\n+}\n+\n@@ -4233,0 +4442,6 @@\n+void Assembler::enotl(Register dst, Register src) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xD0 | encode));\n+}\n+\n@@ -4238,0 +4453,6 @@\n+void Assembler::eorw(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x0B, 0xC0, src1, src2);\n+}\n+\n@@ -4244,0 +4465,8 @@\n+void Assembler::eorl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rcx, src, imm32);\n+}\n+\n@@ -4249,0 +4478,6 @@\n+void Assembler::eorl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -4256,0 +4491,9 @@\n+void Assembler::eorl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x0B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -4261,0 +4505,7 @@\n+void Assembler::eorl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x09, 0xC0, src1, src2);\n+}\n+\n@@ -4268,0 +4519,9 @@\n+void Assembler::eorl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x09);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -4276,0 +4536,10 @@\n+void Assembler::eorb(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0x80);\n+  emit_operand(rcx, src, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -4283,0 +4553,9 @@\n+void Assembler::eorb(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x08);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -5403,0 +5682,10 @@\n+void Assembler::epopcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0x88);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -5410,0 +5699,7 @@\n+void Assembler::epopcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n@@ -5998,0 +6294,11 @@\n+void Assembler::ercll(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);\n+  }\n+}\n+\n@@ -6078,0 +6385,11 @@\n+void Assembler::eroll(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC0 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc0 | encode), imm8);\n+   }\n+}\n+\n@@ -6083,0 +6401,6 @@\n+void Assembler::eroll(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC0 | encode));\n+}\n+\n@@ -6093,0 +6417,11 @@\n+void Assembler::erorl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC8 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);\n+   }\n+}\n+\n@@ -6098,0 +6433,6 @@\n+void Assembler::erorl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC8 | encode));\n+}\n+\n@@ -6104,0 +6445,6 @@\n+void Assembler::erorq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC8 | encode));\n+}\n+\n@@ -6114,0 +6461,11 @@\n+void Assembler::erorq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC8 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xC8 | encode), imm8);\n+   }\n+}\n+\n@@ -6119,0 +6477,6 @@\n+void Assembler::erolq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC0 | encode));\n+}\n+\n@@ -6128,0 +6492,11 @@\n+\n+void Assembler::erolq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC0 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc0 | encode), imm8);\n+   }\n+ }\n@@ -6153,0 +6528,17 @@\n+void Assembler::esall(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(4), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(4), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -6160,5 +6552,25 @@\n-void Assembler::sall(Register dst, int imm8) {\n-  assert(isShiftCount(imm8), \"illegal shift count\");\n-  int encode = prefix_and_encode(dst->encoding());\n-  if (imm8 == 1) {\n-    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+void Assembler::esall(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(4), src, 0);\n+}\n+\n+void Assembler::sall(Register dst, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  int encode = prefix_and_encode(dst->encoding());\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n+void Assembler::esall(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n@@ -6175,0 +6587,6 @@\n+void Assembler::esall(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -6190,0 +6608,17 @@\n+void Assembler::esarl(Register dst, Address src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(7), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(7), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -6197,0 +6632,9 @@\n+void Assembler::esarl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(7), src, 0);\n+}\n+\n@@ -6207,0 +6651,11 @@\n+void Assembler::esarl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xF8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);\n+  }\n+}\n+\n@@ -6212,0 +6667,6 @@\n+void Assembler::esarl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xF8 | encode));\n+}\n+\n@@ -6223,1 +6684,0 @@\n-\n@@ -6316,1 +6776,0 @@\n-\n@@ -6327,0 +6786,11 @@\n+void Assembler::eshll(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1 ) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -6332,0 +6802,6 @@\n+void Assembler::eshll(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -6343,0 +6819,12 @@\n+void Assembler::eshrl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE8 | encode));\n+  }\n+  else {\n+    emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);\n+  }\n+}\n+\n@@ -6348,0 +6836,6 @@\n+void Assembler::eshrl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE8 | encode));\n+}\n+\n@@ -6355,0 +6849,9 @@\n+void Assembler::eshrl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(5), src, 0);\n+}\n+\n@@ -6370,0 +6873,16 @@\n+void Assembler::eshrl(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(5), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(5), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n@@ -6376,0 +6895,6 @@\n+void Assembler::eshldl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16(0xA5, (0xC0 | encode));\n+}\n+\n@@ -6381,0 +6906,6 @@\n+void Assembler::eshldl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x24, (0xC0 | encode), imm8);\n+}\n+\n@@ -6386,0 +6917,6 @@\n+void Assembler::eshrdl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16(0xAD, (0xC0 | encode));\n+}\n+\n@@ -6391,0 +6928,6 @@\n+void Assembler::eshrdl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x2C, (0xC0 | encode), imm8);\n+}\n+\n@@ -6397,0 +6940,6 @@\n+void Assembler::eshldq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x24, (0xC0 | encode), imm8);\n+}\n+\n@@ -6401,0 +6950,6 @@\n+\n+void Assembler::eshrdq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x2C, (0xC0 | encode), imm8);\n+}\n@@ -6491,0 +7046,8 @@\n+void Assembler::esubl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rbp, src, imm32);\n+}\n+\n@@ -6498,0 +7061,9 @@\n+void Assembler::esubl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x29);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -6503,0 +7075,6 @@\n+void Assembler::esubl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -6509,0 +7087,6 @@\n+void Assembler::esubl_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -6516,0 +7100,9 @@\n+void Assembler::esubl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x2B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6521,0 +7114,7 @@\n+void Assembler::esubl(Register dst, Register src2, Register src1, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x29, 0xC0, src1, src2);\n+}\n+\n@@ -6624,0 +7224,7 @@\n+void Assembler::etzcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF4, (0xC0 | encode));\n+}\n+\n@@ -6633,0 +7240,10 @@\n+void Assembler::etzcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF4);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -6640,0 +7257,7 @@\n+void Assembler::etzcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF4, (0xC0 | encode));\n+}\n+\n@@ -6649,0 +7273,10 @@\n+void Assembler::etzcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF4);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -6768,0 +7402,8 @@\n+void Assembler::exorl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(6), src, imm32);\n+}\n+\n@@ -6773,0 +7415,6 @@\n+void Assembler::exorl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xF0, src, imm32);\n+}\n+\n@@ -6780,0 +7428,9 @@\n+void Assembler::exorl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6785,0 +7442,7 @@\n+void Assembler::exorl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x31, 0xC0, src1, src2);\n+}\n+\n@@ -6792,0 +7456,9 @@\n+void Assembler::exorl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x31);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -6799,0 +7472,9 @@\n+void Assembler::exorb(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x32);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6806,0 +7488,9 @@\n+void Assembler::exorb(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x30);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -6811,0 +7502,6 @@\n+void Assembler::exorw(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x33, 0xC0, src1, src2);\n+}\n+\n@@ -6819,0 +7516,10 @@\n+void Assembler::exorw(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -11402,0 +12109,6 @@\n+void Assembler::edecl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x48 | src->encoding());\n+}\n+\n@@ -11840,1 +12553,1 @@\n-                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc, bool no_flags) {\n@@ -11866,5 +12579,11 @@\n-  \/\/ P2: byte 4 as zL'Lbv'aaa\n-  \/\/ kregs are implemented in the low 3 bits as aaa\n-  int byte4 = (_attributes->is_no_reg_mask()) ?\n-              0 :\n-              _attributes->get_embedded_opmask_register_specifier();\n+  \/\/ P2: byte 4 as zL'Lbv'aaa or 00LXVF00 where V = V4, X(extended context) = ND and F = NF (no flags)\n+  int byte4 = 0;\n+  if (no_flags) {\n+    assert(_attributes->is_no_reg_mask(), \"mask register not supported with no_flags\");\n+    byte4 |= 0x4;\n+  } else {\n+    \/\/ kregs are implemented in the low 3 bits as aaa\n+    byte4 = (_attributes->is_no_reg_mask()) ?\n+                0 :\n+                _attributes->get_embedded_opmask_register_specifier();\n+  }\n@@ -11885,2 +12604,2 @@\n-void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {\n-  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool nds_is_ndd, bool no_flags) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || nds_is_ndd || no_flags) {\n@@ -11889,1 +12608,2 @@\n-  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16;\n+  if (nds_is_ndd) attributes->set_extended_context();\n+  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16 || nds_is_ndd;\n@@ -11932,1 +12652,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, eevex_b, evex_v, eevex_x, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, eevex_b, evex_v, eevex_x, nds_enc, pre, opc, no_flags);\n@@ -11941,2 +12661,12 @@\n-int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n-  if (src_is_gpr && src_enc >= 16) {\n+void Assembler::evex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  vex_prefix(adr, ndd_enc, xreg_enc, pre, opc, attributes, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+void Assembler::evex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  vex_prefix(adr, ndd_enc, xreg_enc, pre, opc, attributes, \/* nds_is_ndd *\/ false, no_flags);\n+}\n+\n+int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr, bool nds_is_ndd, bool no_flags) {\n+  if (nds_is_ndd || no_flags || (src_is_gpr && src_enc >= 16)) {\n@@ -11945,0 +12675,1 @@\n+  if (nds_is_ndd) attributes->set_extended_context();\n@@ -11986,1 +12717,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc, no_flags);\n@@ -11998,0 +12729,12 @@\n+int Assembler::evex_prefix_and_encode_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                           InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+int Assembler::evex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                           InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n+}\n+\n@@ -12842,0 +13585,6 @@\n+void Assembler::eincl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x40 | src->encoding());\n+}\n+\n@@ -13466,0 +14215,8 @@\n+void Assembler::eaddq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n+\n@@ -13472,0 +14229,9 @@\n+void Assembler::eaddq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x01);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -13477,0 +14243,6 @@\n+void Assembler::eaddq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC0, src, imm32);\n+}\n+\n@@ -13483,0 +14255,9 @@\n+void Assembler::eaddq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x03);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13488,2 +14269,9 @@\n-void Assembler::adcxq(Register dst, Register src) {\n-  \/\/assert(VM_Version::supports_adx(), \"adx instructions not supported\");\n+void Assembler::eaddq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x01, 0xC0, src1, src2);\n+}\n+\n+void Assembler::adcxq(Register dst, Register src) {\n+  \/\/assert(VM_Version::supports_adx(), \"adx instructions not supported\");\n@@ -13504,0 +14292,6 @@\n+void Assembler::eadcxq(Register dst, Register src1, Register src2) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+}\n+\n@@ -13519,0 +14313,7 @@\n+\n+void Assembler::eadoxq(Register dst, Register src1, Register src2) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+}\n+\n@@ -13525,0 +14326,8 @@\n+void Assembler::eandq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(4), src, imm32);\n+}\n+\n@@ -13530,0 +14339,6 @@\n+void Assembler::eandq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE0, src, imm32);\n+}\n+\n@@ -13536,0 +14351,9 @@\n+void Assembler::eandq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x23);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13541,0 +14365,7 @@\n+void Assembler::eandq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x21, 0xC0, src1, src2);\n+}\n+\n@@ -13547,0 +14378,9 @@\n+void Assembler::eandq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x21);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -13680,0 +14520,6 @@\n+void Assembler::ecmovq(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}\n+\n@@ -13687,0 +14533,9 @@\n+void Assembler::ecmovq(Condition cc, Register dst, Register src1, Address src2) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int8((0x40 | cc));\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13788,0 +14643,6 @@\n+void Assembler::edecl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC8 | encode));\n+}\n+\n@@ -13795,0 +14656,6 @@\n+void Assembler::edecq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC8 | encode));\n+}\n+\n@@ -13802,0 +14669,9 @@\n+void Assembler::edecq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rcx, src, 0);\n+}\n+\n@@ -13835,0 +14711,6 @@\n+void Assembler::eidivq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n+}\n+\n@@ -13840,0 +14722,6 @@\n+void Assembler::edivq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n@@ -13845,0 +14733,12 @@\n+void Assembler::eimulq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n+void Assembler::eimulq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n@@ -13850,0 +14750,6 @@\n+void Assembler::eimulq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE8 | encode));\n+}\n+\n@@ -13864,0 +14770,16 @@\n+void Assembler::eimulq(Register dst, Address src, int32_t value, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int8((unsigned char)0x6B);\n+    emit_operand(dst, src, 1);\n+    emit_int8(value);\n+  } else {\n+    emit_int8((unsigned char)0x69);\n+    emit_operand(dst, src, 4);\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -13874,0 +14796,11 @@\n+void Assembler::eimulq(Register dst, Register src, int value, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n+  if (is8bit(value)) {\n+    emit_int24(0x6B, (0xC0 | encode), (value & 0xFF));\n+  } else {\n+    emit_int16(0x69, (0xC0 | encode));\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -13881,0 +14814,17 @@\n+void Assembler::eimulq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes, \/* nds_is_ndd *\/ false, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::eimulq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13888,0 +14838,9 @@\n+void Assembler::eincl(Register dst, Register src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementl() instead.\n+  \/\/ Use two-byte form (one-byte from is a REX prefix in 64-bit mode)\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  \/\/ int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC0 | encode));\n+}\n+\n@@ -13895,0 +14854,8 @@\n+void Assembler::eincq(Register dst, Register src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementq() instead.\n+  \/\/ Use two-byte form (one-byte from is a REX prefix in 64-bit mode)\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC0 | encode));\n+}\n+\n@@ -13902,0 +14869,10 @@\n+void Assembler::eincq(Register dst, Address src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementq() instead.\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char) 0xFF);\n+  emit_operand(rax, src, 0);\n+}\n+\n@@ -13970,0 +14947,7 @@\n+void Assembler::elzcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13979,0 +14963,10 @@\n+void Assembler::elzcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14101,0 +15095,9 @@\n+void Assembler::emulq(Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0xF7);\n+  emit_operand(rsp, src, 0);\n+}\n+\n@@ -14106,0 +15109,6 @@\n+void Assembler::emulq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE0 | encode));\n+}\n+\n@@ -14118,0 +15127,6 @@\n+void Assembler::enegq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xD8 | encode));\n+}\n+\n@@ -14124,0 +15139,9 @@\n+void Assembler::enegq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(3), src, 0);\n+}\n+\n@@ -14129,0 +15153,6 @@\n+void Assembler::enotq(Register dst, Register src) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xD0 | encode));\n+}\n+\n@@ -14165,0 +15195,8 @@\n+void Assembler::eorq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(1), src, imm32);\n+}\n+\n@@ -14171,0 +15209,9 @@\n+void Assembler::eorq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x09);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -14176,0 +15223,6 @@\n+void Assembler::eorq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -14181,0 +15234,6 @@\n+void Assembler::eorq_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -14187,0 +15246,9 @@\n+void Assembler::eorq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x0B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14192,0 +15260,7 @@\n+void Assembler::eorq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x09, 0xC0, src1, src2);\n+}\n+\n@@ -14200,0 +15275,10 @@\n+void Assembler::epopcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char) 0x88);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14207,0 +15292,7 @@\n+void Assembler::epopcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n@@ -14425,0 +15517,11 @@\n+void Assembler::erclq(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);\n+  }\n+}\n+\n@@ -14435,0 +15538,11 @@\n+void Assembler::ercrq(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);\n+  }\n+}\n+\n@@ -14486,0 +15600,17 @@\n+void Assembler::esalq(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(4), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(4), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14492,0 +15623,9 @@\n+void Assembler::esalq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(4), src, 0);\n+}\n+\n@@ -14502,0 +15642,11 @@\n+void Assembler::esalq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -14507,0 +15658,6 @@\n+void Assembler::esalq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -14521,0 +15678,17 @@\n+void Assembler::esarq(Register dst, Address src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(7), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(7), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14527,0 +15701,9 @@\n+void Assembler::esarq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(7), src, 0);\n+}\n+\n@@ -14537,0 +15720,10 @@\n+void Assembler::esarq(Register dst, Register src, int imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xF8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);\n+  }\n+}\n+\n@@ -14541,0 +15734,6 @@\n+\n+void Assembler::esarq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xF8 | encode));\n+}\n@@ -14575,0 +15774,11 @@\n+void Assembler::eshlq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1 ) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -14580,0 +15790,6 @@\n+void Assembler::eshlq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -14591,0 +15807,12 @@\n+void Assembler::eshrq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE8 | encode));\n+  }\n+  else {\n+    emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);\n+  }\n+}\n+\n@@ -14596,0 +15824,6 @@\n+void Assembler::eshrq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE8 | encode));\n+}\n+\n@@ -14602,0 +15836,9 @@\n+void Assembler::eshrq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(5), src, 0);\n+}\n+\n@@ -14616,0 +15859,17 @@\n+void Assembler::eshrq(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(5), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(5), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14622,0 +15882,8 @@\n+void Assembler::esubq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rbp, src, imm32);\n+}\n+\n@@ -14628,0 +15896,9 @@\n+void Assembler::esubq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x29);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -14633,0 +15910,6 @@\n+void Assembler::esubq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -14639,0 +15922,6 @@\n+void Assembler::esubq_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -14645,0 +15934,9 @@\n+void Assembler::esubq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x2B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14650,0 +15948,7 @@\n+void Assembler::esubq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x29, 0xC0, src1, src2);\n+}\n+\n@@ -14707,0 +16012,7 @@\n+void Assembler::exorq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x31, 0xC0, src1, src2);\n+}\n+\n@@ -14713,0 +16025,9 @@\n+void Assembler::exorq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14718,0 +16039,6 @@\n+void Assembler::exorq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xF0, src, imm32);\n+}\n+\n@@ -14724,0 +16051,8 @@\n+void Assembler::exorq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(6), src, imm32);\n+}\n+\n@@ -14730,0 +16065,9 @@\n+void Assembler::exorq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x31);\n+  emit_operand(src2, src1, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1366,"deletions":22,"binary":false,"changes":1388,"status":"modified"},{"patch":"@@ -792,1 +792,5 @@\n-                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc, bool no_flags = false);\n+\n+  void evex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags = false);\n+\n+  void evex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags = false);\n@@ -795,1 +799,1 @@\n-                  InstructionAttr *attributes);\n+                  InstructionAttr *attributes, bool nds_is_ndd = false, bool no_flags = false);\n@@ -799,1 +803,7 @@\n-                             InstructionAttr *attributes, bool src_is_gpr = false);\n+                             InstructionAttr *attributes, bool src_is_gpr = false, bool nds_is_ndd = false, bool no_flags = false);\n+\n+  int  evex_prefix_and_encode_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                  InstructionAttr *attributes, bool no_flags = false);\n+\n+  int  evex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                 InstructionAttr *attributes, bool no_flags = false);\n@@ -944,0 +954,1 @@\n+  void edecl(Register dst, Register src, bool no_flags);\n@@ -945,0 +956,1 @@\n+  void edecl(Register dst, Address src, bool no_flags);\n@@ -946,0 +958,1 @@\n+  void edecq(Register dst, Address src, bool no_flags);\n@@ -948,0 +961,1 @@\n+  void eincl(Register dst, Register src, bool no_flags);\n@@ -949,0 +963,1 @@\n+  void eincl(Register dst, Address src, bool no_flags);\n@@ -950,0 +965,1 @@\n+  void eincq(Register dst, Register src, bool no_flags);\n@@ -951,0 +967,1 @@\n+  void eincq(Register dst, Address src, bool no_flags);\n@@ -1034,0 +1051,1 @@\n+  void edecq(Register dst, Register src, bool no_flags);\n@@ -1076,0 +1094,1 @@\n+  void eaddl(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -1077,0 +1096,1 @@\n+  void eaddl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1078,0 +1098,1 @@\n+  void eaddl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1079,0 +1100,1 @@\n+  void eaddl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1080,0 +1102,1 @@\n+  void eaddl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1082,0 +1105,1 @@\n+  void eaddq(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -1083,0 +1107,1 @@\n+  void eaddq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1084,0 +1109,1 @@\n+  void eaddq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1085,0 +1111,1 @@\n+  void eaddq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1086,0 +1113,1 @@\n+  void eaddq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1090,0 +1118,1 @@\n+  void eadcxq(Register dst, Register src1, Register src2);\n@@ -1093,0 +1122,1 @@\n+  void eadoxq(Register dst, Register src1, Register src2);\n@@ -1127,0 +1157,1 @@\n+  void eandl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1128,0 +1159,1 @@\n+  void eandl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1129,0 +1161,1 @@\n+  void eandl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1130,0 +1163,1 @@\n+  void eandl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1133,0 +1167,1 @@\n+  void eandq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1134,0 +1169,1 @@\n+  void eandq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1135,0 +1171,1 @@\n+  void eandq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1136,0 +1173,1 @@\n+  void eandq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1137,0 +1175,1 @@\n+  void eandq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1187,0 +1226,1 @@\n+  void ecmovl(Condition cc, Register dst, Register src1, Register src2);\n@@ -1188,0 +1228,1 @@\n+  void ecmovl(Condition cc, Register dst, Register src1, Address src2);\n@@ -1190,0 +1231,1 @@\n+  void ecmovq(Condition cc, Register dst, Register src1, Register src2);\n@@ -1191,0 +1233,1 @@\n+  void ecmovq(Condition cc, Register dst, Register src1, Address src2);\n@@ -1493,0 +1536,1 @@\n+  void eidivl(Register src, bool no_flags);\n@@ -1494,0 +1538,1 @@\n+  void edivl(Register src, bool no_flags); \/\/ Unsigned division\n@@ -1497,0 +1542,1 @@\n+  void eidivq(Register src, bool no_flags);\n@@ -1498,0 +1544,1 @@\n+  void edivq(Register src, bool no_flags); \/\/ Unsigned division\n@@ -1501,0 +1548,1 @@\n+  void eimull(Register src, bool no_flags);\n@@ -1502,0 +1550,1 @@\n+  void eimull(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1503,0 +1552,1 @@\n+  void eimull(Register dst, Register src, int value, bool no_flags);\n@@ -1504,0 +1554,1 @@\n+  void eimull(Register dst, Address src, int value, bool no_flags);\n@@ -1505,0 +1556,1 @@\n+  void eimull(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1508,0 +1560,2 @@\n+  void eimulq(Register dst, Register src, bool no_flags);\n+  void eimulq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1509,0 +1563,1 @@\n+  void eimulq(Register dst, Register src, int value, bool no_flags);\n@@ -1510,0 +1565,1 @@\n+  void eimulq(Register dst, Address src, int value, bool no_flags);\n@@ -1511,0 +1567,2 @@\n+  void eimulq(Register dst, Address src, bool no_flags);\n+  void eimulq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1512,0 +1570,1 @@\n+  void eimulq(Register dst, bool no_flags);\n@@ -1570,0 +1629,1 @@\n+  void elzcntl(Register dst, Register src, bool no_flags);\n@@ -1571,0 +1631,1 @@\n+  void elzcntl(Register dst, Address src, bool no_flags);\n@@ -1574,0 +1635,1 @@\n+  void elzcntq(Register dst, Register src, bool no_flags);\n@@ -1575,0 +1637,1 @@\n+  void elzcntq(Register dst, Address src, bool no_flags);\n@@ -1790,0 +1853,1 @@\n+  void emull(Address src, bool no_flags);\n@@ -1791,0 +1855,1 @@\n+  void emull(Register src, bool no_flags);\n@@ -1794,0 +1859,1 @@\n+  void emulq(Address src, bool no_flags);\n@@ -1795,0 +1861,1 @@\n+  void emulq(Register src, bool no_flags);\n@@ -1807,0 +1874,1 @@\n+  void enegl(Register dst, Register src, bool no_flags);\n@@ -1808,0 +1876,1 @@\n+  void enegl(Register dst, Address src, bool no_flags);\n@@ -1811,0 +1880,1 @@\n+  void enegq(Register dst, Register src, bool no_flags);\n@@ -1812,0 +1882,1 @@\n+  void enegq(Register dst, Address src, bool no_flags);\n@@ -1817,0 +1888,1 @@\n+  void enotl(Register dst, Register src);\n@@ -1820,0 +1892,1 @@\n+  void enotq(Register dst, Register src);\n@@ -1828,0 +1901,1 @@\n+  void eorw(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1830,0 +1904,1 @@\n+  void eorl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1831,0 +1906,1 @@\n+  void eorl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1832,0 +1908,1 @@\n+  void eorl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1833,0 +1910,1 @@\n+  void eorl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1834,0 +1912,1 @@\n+  void eorl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1836,0 +1915,1 @@\n+  void eorb(Register dst, Address  src, int imm8, bool no_flags);\n@@ -1837,0 +1917,1 @@\n+  void eorb(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1839,0 +1920,1 @@\n+  void eorq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1840,0 +1922,1 @@\n+  void eorq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1841,0 +1924,1 @@\n+  void eorq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1842,0 +1926,1 @@\n+  void eorq_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1843,0 +1928,1 @@\n+  void eorq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1844,0 +1930,1 @@\n+  void eorq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2029,0 +2116,1 @@\n+  void epopcntl(Register dst, Address src, bool no_flags);\n@@ -2030,0 +2118,1 @@\n+  void epopcntl(Register dst, Register src, bool no_flags);\n@@ -2038,0 +2127,1 @@\n+  void epopcntq(Register dst, Address src, bool no_flags);\n@@ -2039,0 +2129,1 @@\n+  void epopcntq(Register dst, Register src, bool no_flags);\n@@ -2138,0 +2229,1 @@\n+  void ercll(Register dst, Register src, int imm8);\n@@ -2140,0 +2232,1 @@\n+  void erclq(Register dst, Register src, int imm8);\n@@ -2142,0 +2235,1 @@\n+  void ercrq(Register dst, Register src, int imm8);\n@@ -2152,0 +2246,1 @@\n+  void eroll(Register dst, Register src, bool no_flags);\n@@ -2154,0 +2249,1 @@\n+  void eroll(Register dst, Register src, int imm8, bool no_flags);\n@@ -2156,0 +2252,1 @@\n+  void erorl(Register dst, Register src, bool no_flags);\n@@ -2158,0 +2255,1 @@\n+  void erorl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2161,0 +2259,1 @@\n+  void erolq(Register dst, Register src, bool no_flags);\n@@ -2162,0 +2261,1 @@\n+  void erolq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2163,0 +2263,1 @@\n+  void erorq(Register dst, Register src, bool no_flags);\n@@ -2164,0 +2265,1 @@\n+  void erorq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2173,0 +2275,1 @@\n+  void esall(Register dst, Register src, int imm8, bool no_flags);\n@@ -2174,0 +2277,1 @@\n+  void esall(Register dst, Register src, bool no_flags);\n@@ -2175,0 +2279,1 @@\n+  void esall(Register dst, Address src, int imm8, bool no_flags);\n@@ -2176,0 +2281,1 @@\n+  void esall(Register dst, Address src, bool no_flags);\n@@ -2178,0 +2284,1 @@\n+  void esarl(Register dst, Address src, int imm8, bool no_flags);\n@@ -2179,0 +2286,1 @@\n+  void esarl(Register dst, Address src, bool no_flags);\n@@ -2180,0 +2288,1 @@\n+  void esarl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2181,0 +2290,1 @@\n+  void esarl(Register dst, Register src, bool no_flags);\n@@ -2184,0 +2294,1 @@\n+  void esalq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2185,0 +2296,1 @@\n+  void esalq(Register dst, Register src, bool no_flags);\n@@ -2186,0 +2298,1 @@\n+  void esalq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2187,0 +2300,1 @@\n+  void esalq(Register dst, Address src, bool no_flags);\n@@ -2189,0 +2303,1 @@\n+  void esarq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2190,0 +2305,1 @@\n+  void esarq(Register dst, Address src, bool no_flags);\n@@ -2191,0 +2307,1 @@\n+  void esarq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2192,0 +2309,1 @@\n+  void esarq(Register dst, Register src, bool no_flags);\n@@ -2223,0 +2341,1 @@\n+  void eshldl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2224,0 +2343,1 @@\n+  void eshldl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2225,0 +2345,1 @@\n+  void eshrdl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2226,0 +2347,1 @@\n+  void eshrdl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2228,0 +2350,1 @@\n+  void eshldq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2229,0 +2352,1 @@\n+  void eshrdq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2232,0 +2356,1 @@\n+  void eshll(Register dst, Register src, int imm8, bool no_flags);\n@@ -2233,0 +2358,1 @@\n+  void eshll(Register dst, Register src, bool no_flags);\n@@ -2235,0 +2361,1 @@\n+  void eshlq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2236,0 +2363,1 @@\n+  void eshlq(Register dst, Register src, bool no_flags);\n@@ -2238,0 +2366,1 @@\n+  void eshrl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2239,0 +2368,1 @@\n+  void eshrl(Register dst, Register src, bool no_flags);\n@@ -2240,0 +2370,1 @@\n+  void eshrl(Register dst, Address src, bool no_flags);\n@@ -2241,0 +2372,1 @@\n+  void eshrl(Register dst, Address src, int imm8, bool no_flags);\n@@ -2243,0 +2375,1 @@\n+  void eshrq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2244,0 +2377,1 @@\n+  void eshrq(Register dst, Register src, bool no_flags);\n@@ -2245,0 +2379,1 @@\n+  void eshrq(Register dst, Address src, bool no_flags);\n@@ -2246,0 +2381,1 @@\n+  void eshrq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2265,0 +2401,1 @@\n+  void esubl(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -2266,0 +2403,1 @@\n+  void esubl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2267,0 +2405,1 @@\n+  void esubl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2268,0 +2407,1 @@\n+  void esubl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2269,0 +2409,1 @@\n+  void esubl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2271,0 +2412,1 @@\n+  void esubq(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -2272,0 +2414,1 @@\n+  void esubq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2273,0 +2416,1 @@\n+  void esubq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2274,0 +2418,1 @@\n+  void esubq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2275,0 +2420,1 @@\n+  void esubq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2278,0 +2424,1 @@\n+  void esubl_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2279,0 +2426,1 @@\n+  void esubq_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2303,0 +2451,1 @@\n+  void etzcntl(Register dst, Register src, bool no_flags);\n@@ -2304,0 +2453,1 @@\n+  void etzcntl(Register dst, Address src, bool no_flags);\n@@ -2305,0 +2455,1 @@\n+  void etzcntq(Register dst, Register src, bool no_flags);\n@@ -2306,0 +2457,1 @@\n+  void etzcntq(Register dst, Address src, bool no_flags);\n@@ -2338,0 +2490,1 @@\n+  void exorl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2339,0 +2492,1 @@\n+  void exorl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -2340,0 +2494,1 @@\n+  void exorl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2341,0 +2496,1 @@\n+  void exorl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2342,0 +2498,1 @@\n+  void exorl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2344,0 +2501,1 @@\n+  void exorb(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2345,0 +2503,1 @@\n+  void exorb(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2346,0 +2505,1 @@\n+  void exorw(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2347,0 +2507,1 @@\n+  void exorw(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2349,0 +2510,1 @@\n+  void exorq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2350,0 +2512,1 @@\n+  void exorq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -2351,0 +2514,1 @@\n+  void exorq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2352,0 +2516,1 @@\n+  void exorq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2353,0 +2518,1 @@\n+  void exorq(Register dst, Address src1, Register src2, bool no_flags);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":169,"deletions":3,"binary":false,"changes":172,"status":"modified"}]}