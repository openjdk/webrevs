{"files":[{"patch":"@@ -1388,0 +1388,8 @@\n+void Assembler::eaddl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n+\n@@ -1432,0 +1440,9 @@\n+void Assembler::eaddl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x01);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -1437,0 +1454,6 @@\n+void Assembler::eaddl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC0, src, imm32);\n+}\n+\n@@ -1444,0 +1467,9 @@\n+void Assembler::eaddl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x03);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -1449,0 +1481,7 @@\n+void Assembler::eaddl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x01, 0xC0, src1, src2);\n+}\n+\n@@ -1635,0 +1674,8 @@\n+void Assembler::eandl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rsp, src, imm32);\n+}\n+\n@@ -1640,0 +1687,6 @@\n+void Assembler::eandl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE0, src, imm32);\n+}\n+\n@@ -1654,0 +1707,9 @@\n+void Assembler::eandl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x23);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -1659,0 +1721,7 @@\n+void Assembler::eandl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x21, 0xC0, src1, src2);\n+}\n+\n@@ -1806,0 +1875,6 @@\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}\n+\n@@ -1814,0 +1889,9 @@\n+void Assembler::ecmovl(Condition cc, Register dst, Register src1, Address src2) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int8((0x40 | cc));\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -2432,0 +2516,9 @@\n+void Assembler::edecl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rcx, src, 0);\n+}\n+\n@@ -2477,0 +2570,6 @@\n+void Assembler::eidivl(Register src, bool no_flags) { \/\/ Signed\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n+}\n+\n@@ -2482,0 +2581,6 @@\n+void Assembler::edivl(Register src, bool no_flags) { \/\/ Unsigned\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n@@ -2487,0 +2592,6 @@\n+void Assembler::eimull(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE8 | encode));\n+}\n+\n@@ -2492,0 +2603,6 @@\n+void Assembler::eimull(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n@@ -2506,0 +2623,16 @@\n+void Assembler::eimull(Register dst, Address src, int32_t value, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int8((unsigned char)0x6B);\n+    emit_operand(dst, src, 1);\n+    emit_int8(value);\n+  } else {\n+    emit_int8((unsigned char)0x69);\n+    emit_operand(dst, src, 4);\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -2516,0 +2649,11 @@\n+void Assembler::eimull(Register dst, Register src, int value, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int24(0x6B, (0xC0 | encode), value & 0xFF);\n+  } else {\n+    emit_int16(0x69, (0xC0 | encode));\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -2523,0 +2667,8 @@\n+void Assembler::eimull(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(src1, src2, 0);\n+}\n@@ -2532,0 +2684,10 @@\n+void Assembler::eincl(Register dst, Address src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::increment() instead.\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rax, src, 0);\n+}\n+\n@@ -2699,0 +2861,7 @@\n+void Assembler::elzcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -2708,0 +2877,10 @@\n+void Assembler::elzcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -3858,0 +4037,9 @@\n+void Assembler::emull(Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(rsp, src, 0);\n+}\n+\n@@ -3863,0 +4051,6 @@\n+void Assembler::emull(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE0 | encode));\n+}\n+\n@@ -3904,0 +4098,6 @@\n+void Assembler::enegl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xD8 | encode));\n+}\n+\n@@ -3911,0 +4111,9 @@\n+void Assembler::enegl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(3), src, 0);\n+}\n+\n@@ -4222,0 +4431,17 @@\n+void Assembler::enotl(Register dst, Register src) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xD0 | encode));\n+}\n+\n+void Assembler::orw(Register dst, Register src) {\n+  (void)prefix_and_encode(dst->encoding(), src->encoding());\n+  emit_arith(0x0B, 0xC0, dst, src);\n+}\n+\n+void Assembler::eorw(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x0B, 0xC0, src1, src2);\n+}\n+\n@@ -4228,0 +4454,8 @@\n+void Assembler::eorl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rcx, src, imm32);\n+}\n+\n@@ -4233,0 +4467,6 @@\n+void Assembler::eorl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -4240,0 +4480,9 @@\n+void Assembler::eorl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x0B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -4245,0 +4494,7 @@\n+void Assembler::eorl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x09, 0xC0, src1, src2);\n+}\n+\n@@ -4252,0 +4508,9 @@\n+void Assembler::eorl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x09);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -4260,0 +4525,10 @@\n+void Assembler::eorb(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0x80);\n+  emit_operand(rcx, src, 1);\n+  emit_int8(imm8);\n+}\n+\n@@ -4267,0 +4542,9 @@\n+void Assembler::eorb(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x08);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -5387,0 +5671,10 @@\n+void Assembler::epopcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0x88);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -5394,0 +5688,7 @@\n+void Assembler::epopcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n@@ -5982,0 +6283,11 @@\n+void Assembler::ercll(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);\n+  }\n+}\n+\n@@ -6062,0 +6374,11 @@\n+void Assembler::eroll(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC0 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc0 | encode), imm8);\n+   }\n+}\n+\n@@ -6067,0 +6390,6 @@\n+void Assembler::eroll(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC0 | encode));\n+}\n+\n@@ -6077,0 +6406,11 @@\n+void Assembler::erorl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC8 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);\n+   }\n+}\n+\n@@ -6082,0 +6422,6 @@\n+void Assembler::erorl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC8 | encode));\n+}\n+\n@@ -6088,0 +6434,6 @@\n+void Assembler::erorq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC8 | encode));\n+}\n+\n@@ -6098,0 +6450,11 @@\n+void Assembler::erorq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC8 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xC8 | encode), imm8);\n+   }\n+}\n+\n@@ -6103,0 +6466,6 @@\n+void Assembler::erolq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xC0 | encode));\n+}\n+\n@@ -6112,0 +6481,11 @@\n+\n+void Assembler::erolq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+     emit_int16((unsigned char)0xD1, (0xC0 | encode));\n+   } else {\n+     emit_int24((unsigned char)0xC1, (0xc0 | encode), imm8);\n+   }\n+ }\n@@ -6137,0 +6517,17 @@\n+void Assembler::esall(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(4), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(4), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -6144,2 +6541,11 @@\n-void Assembler::sall(Register dst, int imm8) {\n-  assert(isShiftCount(imm8), \"illegal shift count\");\n+void Assembler::esall(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(4), src, 0);\n+}\n+\n+void Assembler::sall(Register dst, int imm8) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n@@ -6154,0 +6560,11 @@\n+void Assembler::esall(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -6159,0 +6576,6 @@\n+void Assembler::esall(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -6174,0 +6597,17 @@\n+void Assembler::esarl(Register dst, Address src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(7), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(7), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -6181,0 +6621,9 @@\n+void Assembler::esarl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(7), src, 0);\n+}\n+\n@@ -6191,0 +6640,11 @@\n+void Assembler::esarl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xF8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);\n+  }\n+}\n+\n@@ -6196,0 +6656,6 @@\n+void Assembler::esarl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xF8 | encode));\n+}\n+\n@@ -6207,1 +6673,0 @@\n-\n@@ -6300,1 +6765,0 @@\n-\n@@ -6311,0 +6775,11 @@\n+void Assembler::eshll(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1 ) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -6316,0 +6791,6 @@\n+void Assembler::eshll(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -6327,0 +6808,12 @@\n+void Assembler::eshrl(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE8 | encode));\n+  }\n+  else {\n+    emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);\n+  }\n+}\n+\n@@ -6332,0 +6825,6 @@\n+void Assembler::eshrl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE8 | encode));\n+}\n+\n@@ -6339,0 +6838,9 @@\n+void Assembler::eshrl(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(5), src, 0);\n+}\n+\n@@ -6354,0 +6862,16 @@\n+void Assembler::eshrl(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(5), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(5), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n@@ -6360,0 +6884,6 @@\n+void Assembler::eshldl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16(0xA5, (0xC0 | encode));\n+}\n+\n@@ -6365,0 +6895,6 @@\n+void Assembler::eshldl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x24, (0xC0 | encode), imm8);\n+}\n+\n@@ -6370,0 +6906,6 @@\n+void Assembler::eshrdl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16(0xAD, (0xC0 | encode));\n+}\n+\n@@ -6375,0 +6917,6 @@\n+void Assembler::eshrdl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x2C, (0xC0 | encode), imm8);\n+}\n+\n@@ -6381,0 +6929,6 @@\n+void Assembler::eshldq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x24, (0xC0 | encode), imm8);\n+}\n+\n@@ -6385,0 +6939,6 @@\n+\n+void Assembler::eshrdq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int24(0x2C, (0xC0 | encode), imm8);\n+}\n@@ -6475,0 +7035,8 @@\n+void Assembler::esubl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rbp, src, imm32);\n+}\n+\n@@ -6482,0 +7050,9 @@\n+void Assembler::esubl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x29);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -6487,0 +7064,6 @@\n+void Assembler::esubl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -6493,0 +7076,6 @@\n+void Assembler::esubl_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -6500,0 +7089,9 @@\n+void Assembler::esubl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x2B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6505,0 +7103,7 @@\n+void Assembler::esubl(Register dst, Register src2, Register src1, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x29, 0xC0, src1, src2);\n+}\n+\n@@ -6608,0 +7213,7 @@\n+void Assembler::etzcntl(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF4, (0xC0 | encode));\n+}\n+\n@@ -6617,0 +7229,10 @@\n+void Assembler::etzcntl(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF4);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -6624,0 +7246,7 @@\n+void Assembler::etzcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF4, (0xC0 | encode));\n+}\n+\n@@ -6633,0 +7262,10 @@\n+void Assembler::etzcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_bmi1(), \"tzcnt instruction not supported\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF4);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -6752,0 +7391,8 @@\n+void Assembler::exorl(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(6), src, imm32);\n+}\n+\n@@ -6757,0 +7404,6 @@\n+void Assembler::exorl(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xF0, src, imm32);\n+}\n+\n@@ -6764,0 +7417,9 @@\n+void Assembler::exorl(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6769,0 +7431,7 @@\n+void Assembler::exorl(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x31, 0xC0, src1, src2);\n+}\n+\n@@ -6776,0 +7445,9 @@\n+void Assembler::exorl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x31);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -6783,0 +7461,9 @@\n+void Assembler::exorb(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x32);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -6790,0 +7477,20 @@\n+void Assembler::exorb(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x30);\n+  emit_operand(src2, src1, 0);\n+}\n+\n+void Assembler::xorw(Register dst, Register src) {\n+  (void)prefix_and_encode(dst->encoding(), src->encoding());\n+  emit_arith(0x33, 0xC0, dst, src);\n+}\n+\n+void Assembler::exorw(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x33, 0xC0, src1, src2);\n+}\n+\n@@ -6798,0 +7505,10 @@\n+void Assembler::exorw(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  emit_int8(0x66);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -11381,0 +12098,6 @@\n+void Assembler::edecl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x48 | src->encoding());\n+}\n+\n@@ -11819,1 +12542,1 @@\n-                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc, bool no_flags) {\n@@ -11845,5 +12568,11 @@\n-  \/\/ P2: byte 4 as zL'Lbv'aaa\n-  \/\/ kregs are implemented in the low 3 bits as aaa\n-  int byte4 = (_attributes->is_no_reg_mask()) ?\n-              0 :\n-              _attributes->get_embedded_opmask_register_specifier();\n+  \/\/ P2: byte 4 as zL'Lbv'aaa or 00LXVF00 where V = V4, X(extended context) = ND and F = NF (no flags)\n+  int byte4 = 0;\n+  if (no_flags) {\n+    assert(_attributes->is_no_reg_mask(), \"mask register not supported with no_flags\");\n+    byte4 |= 0x4;\n+  } else {\n+    \/\/ kregs are implemented in the low 3 bits as aaa\n+    byte4 = (_attributes->is_no_reg_mask()) ?\n+                0 :\n+                _attributes->get_embedded_opmask_register_specifier();\n+  }\n@@ -11864,2 +12593,2 @@\n-void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {\n-  if (adr.base_needs_rex2() || adr.index_needs_rex2()) {\n+void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool nds_is_ndd, bool no_flags) {\n+  if (adr.base_needs_rex2() || adr.index_needs_rex2() || nds_is_ndd || no_flags) {\n@@ -11868,1 +12597,2 @@\n-  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16;\n+  if (nds_is_ndd) attributes->set_extended_context();\n+  bool is_extended = adr.base_needs_rex2() || adr.index_needs_rex2() || nds_enc >= 16 || xreg_enc >= 16 || nds_is_ndd;\n@@ -11911,1 +12641,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, eevex_b, evex_v, eevex_x, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, eevex_b, evex_v, eevex_x, nds_enc, pre, opc, no_flags);\n@@ -11920,2 +12650,12 @@\n-int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr) {\n-  if (src_is_gpr && src_enc >= 16) {\n+void Assembler::evex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  vex_prefix(adr, ndd_enc, xreg_enc, pre, opc, attributes, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+void Assembler::evex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  vex_prefix(adr, ndd_enc, xreg_enc, pre, opc, attributes, \/* nds_is_ndd *\/ false, no_flags);\n+}\n+\n+int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool src_is_gpr, bool nds_is_ndd, bool no_flags) {\n+  if (nds_is_ndd || no_flags || (src_is_gpr && src_enc >= 16)) {\n@@ -11924,0 +12664,1 @@\n+  if (nds_is_ndd) attributes->set_extended_context();\n@@ -11965,1 +12706,1 @@\n-    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc);\n+    evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_b, evex_v, false \/*eevex_x*\/, nds_enc, pre, opc, no_flags);\n@@ -11977,0 +12718,12 @@\n+int Assembler::evex_prefix_and_encode_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                           InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ true, no_flags);\n+}\n+\n+int Assembler::evex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                           InstructionAttr *attributes, bool no_flags) {\n+  attributes->set_is_evex_instruction();\n+  return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n+}\n+\n@@ -12821,0 +13574,6 @@\n+void Assembler::eincl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x40 | src->encoding());\n+}\n+\n@@ -13445,0 +14204,8 @@\n+void Assembler::eaddq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rax, src, imm32);\n+}\n+\n@@ -13451,0 +14218,9 @@\n+void Assembler::eaddq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x01);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -13456,0 +14232,6 @@\n+void Assembler::eaddq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC0, src, imm32);\n+}\n+\n@@ -13462,0 +14244,9 @@\n+void Assembler::eaddq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x03);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13467,2 +14258,9 @@\n-void Assembler::adcxq(Register dst, Register src) {\n-  \/\/assert(VM_Version::supports_adx(), \"adx instructions not supported\");\n+void Assembler::eaddq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x01, 0xC0, src1, src2);\n+}\n+\n+void Assembler::adcxq(Register dst, Register src) {\n+  \/\/assert(VM_Version::supports_adx(), \"adx instructions not supported\");\n@@ -13483,0 +14281,6 @@\n+void Assembler::eadcxq(Register dst, Register src1, Register src2) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+}\n+\n@@ -13498,0 +14302,7 @@\n+\n+void Assembler::eadoxq(Register dst, Register src1, Register src2) {\n+    InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_3C, &attributes);\n+    emit_int16((unsigned char)0x66, (0xC0 | encode));\n+}\n+\n@@ -13504,0 +14315,8 @@\n+void Assembler::eandq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(4), src, imm32);\n+}\n+\n@@ -13509,0 +14328,6 @@\n+void Assembler::eandq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE0, src, imm32);\n+}\n+\n@@ -13515,0 +14340,9 @@\n+void Assembler::eandq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x23);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13520,0 +14354,7 @@\n+void Assembler::eandq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x21, 0xC0, src1, src2);\n+}\n+\n@@ -13526,0 +14367,9 @@\n+void Assembler::eandq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x21);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -13659,0 +14509,6 @@\n+void Assembler::ecmovq(Condition cc, Register dst, Register src1, Register src2) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((0x40 | cc), (0xC0 | encode));\n+}\n+\n@@ -13666,0 +14522,9 @@\n+void Assembler::ecmovq(Condition cc, Register dst, Register src1, Address src2) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int8((0x40 | cc));\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13767,0 +14632,6 @@\n+void Assembler::edecl(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC8 | encode));\n+}\n+\n@@ -13774,0 +14645,6 @@\n+void Assembler::edecq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC8 | encode));\n+}\n+\n@@ -13781,0 +14658,9 @@\n+void Assembler::edecq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xFF);\n+  emit_operand(rcx, src, 0);\n+}\n+\n@@ -13814,0 +14700,6 @@\n+void Assembler::eidivq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF8 | encode));\n+}\n+\n@@ -13819,0 +14711,6 @@\n+void Assembler::edivq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n@@ -13824,0 +14722,12 @@\n+void Assembler::eimulq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n+void Assembler::eimulq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xAF, (0xC0 | encode));\n+}\n+\n@@ -13829,0 +14739,6 @@\n+void Assembler::eimulq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE8 | encode));\n+}\n+\n@@ -13843,0 +14759,16 @@\n+void Assembler::eimulq(Register dst, Address src, int32_t value, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (is8bit(value)) {\n+    emit_int8((unsigned char)0x6B);\n+    emit_operand(dst, src, 1);\n+    emit_int8(value);\n+  } else {\n+    emit_int8((unsigned char)0x69);\n+    emit_operand(dst, src, 4);\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -13853,0 +14785,11 @@\n+void Assembler::eimulq(Register dst, Register src, int value, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, \/* src_is_gpr *\/ true, \/* nds_is_ndd *\/ false, no_flags);\n+  if (is8bit(value)) {\n+    emit_int24(0x6B, (0xC0 | encode), (value & 0xFF));\n+  } else {\n+    emit_int16(0x69, (0xC0 | encode));\n+    emit_int32(value);\n+  }\n+}\n+\n@@ -13860,0 +14803,17 @@\n+void Assembler::eimulq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes, \/* nds_is_ndd *\/ false, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::eimulq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xAF);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -13867,0 +14827,9 @@\n+void Assembler::eincl(Register dst, Register src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementl() instead.\n+  \/\/ Use two-byte form (one-byte from is a REX prefix in 64-bit mode)\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  \/\/ int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC0 | encode));\n+}\n+\n@@ -13874,0 +14843,8 @@\n+void Assembler::eincq(Register dst, Register src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementq() instead.\n+  \/\/ Use two-byte form (one-byte from is a REX prefix in 64-bit mode)\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xFF, (0xC0 | encode));\n+}\n+\n@@ -13881,0 +14858,10 @@\n+void Assembler::eincq(Register dst, Address src, bool no_flags) {\n+  \/\/ Don't use it directly. Use MacroAssembler::incrementq() instead.\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char) 0xFF);\n+  emit_operand(rax, src, 0);\n+}\n+\n@@ -13949,0 +14936,7 @@\n+void Assembler::elzcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n@@ -13958,0 +14952,10 @@\n+void Assembler::elzcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_lzcnt(), \"encoding is treated as BSR\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF5);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14080,0 +15084,9 @@\n+void Assembler::emulq(Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0xF7);\n+  emit_operand(rsp, src, 0);\n+}\n+\n@@ -14085,0 +15098,6 @@\n+void Assembler::emulq(Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(0, 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xE0 | encode));\n+}\n+\n@@ -14097,0 +15116,6 @@\n+void Assembler::enegq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xF7, (0xD8 | encode));\n+}\n+\n@@ -14103,0 +15128,9 @@\n+void Assembler::enegq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xF7);\n+  emit_operand(as_Register(3), src, 0);\n+}\n+\n@@ -14108,0 +15142,6 @@\n+void Assembler::enotq(Register dst, Register src) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  emit_int16((unsigned char)0xF7, (0xD0 | encode));\n+}\n+\n@@ -14144,0 +15184,8 @@\n+void Assembler::eorq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(1), src, imm32);\n+}\n+\n@@ -14150,0 +15198,9 @@\n+void Assembler::eorq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x09);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -14155,0 +15212,6 @@\n+void Assembler::eorq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -14160,0 +15223,6 @@\n+void Assembler::eorq_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xC8, src, imm32);\n+}\n+\n@@ -14166,0 +15235,9 @@\n+void Assembler::eorq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x0B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14171,0 +15249,7 @@\n+void Assembler::eorq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x09, 0xC0, src1, src2);\n+}\n+\n@@ -14179,0 +15264,10 @@\n+void Assembler::epopcntq(Register dst, Address src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_nf(src, 0, dst->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char) 0x88);\n+  emit_operand(dst, src, 0);\n+}\n+\n@@ -14186,0 +15281,7 @@\n+void Assembler::epopcntq(Register dst, Register src, bool no_flags) {\n+  assert(VM_Version::supports_popcnt(), \"must support\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_nf(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n@@ -14404,0 +15506,11 @@\n+void Assembler::erclq(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);\n+  }\n+}\n+\n@@ -14414,0 +15527,11 @@\n+void Assembler::ercrq(Register dst, Register src, int imm8) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode =  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xD8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);\n+  }\n+}\n+\n@@ -14465,0 +15589,17 @@\n+void Assembler::esalq(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(4), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(4), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14471,0 +15612,9 @@\n+void Assembler::esalq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(4), src, 0);\n+}\n+\n@@ -14481,0 +15631,11 @@\n+void Assembler::esalq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -14486,0 +15647,6 @@\n+void Assembler::esalq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -14500,0 +15667,17 @@\n+void Assembler::esarq(Register dst, Address src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(7), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(7), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14506,0 +15690,9 @@\n+void Assembler::esarq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(7), src, 0);\n+}\n+\n@@ -14516,0 +15709,10 @@\n+void Assembler::esarq(Register dst, Register src, int imm8, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xF8 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);\n+  }\n+}\n+\n@@ -14520,0 +15723,6 @@\n+\n+void Assembler::esarq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xF8 | encode));\n+}\n@@ -14554,0 +15763,11 @@\n+void Assembler::eshlq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1 ) {\n+    emit_int16((unsigned char)0xD1, (0xE0 | encode));\n+  } else {\n+    emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);\n+  }\n+}\n+\n@@ -14559,0 +15779,6 @@\n+void Assembler::eshlq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE0 | encode));\n+}\n+\n@@ -14570,0 +15796,12 @@\n+void Assembler::eshrq(Register dst, Register src, int imm8, bool no_flags) {\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int16((unsigned char)0xD1, (0xE8 | encode));\n+  }\n+  else {\n+    emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);\n+  }\n+}\n+\n@@ -14575,0 +15813,6 @@\n+void Assembler::eshrq(Register dst, Register src, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int16((unsigned char)0xD3, (0xE8 | encode));\n+}\n+\n@@ -14581,0 +15825,9 @@\n+void Assembler::eshrq(Register dst, Address src, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8((unsigned char)0xD3);\n+  emit_operand(as_Register(5), src, 0);\n+}\n+\n@@ -14595,0 +15848,17 @@\n+void Assembler::eshrq(Register dst, Address src, int imm8, bool no_flags) {\n+  InstructionMark im(this);\n+  assert(isShiftCount(imm8 >> 1), \"illegal shift count\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  if (imm8 == 1) {\n+    emit_int8((unsigned char)0xD1);\n+    emit_operand(as_Register(5), src, 0);\n+  }\n+  else {\n+    emit_int8((unsigned char)0xC1);\n+    emit_operand(as_Register(5), src, 1);\n+    emit_int8(imm8);\n+  }\n+}\n+\n@@ -14601,0 +15871,8 @@\n+void Assembler::esubq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, rbp, src, imm32);\n+}\n+\n@@ -14607,0 +15885,9 @@\n+void Assembler::esubq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x29);\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -14612,0 +15899,6 @@\n+void Assembler::esubq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -14618,0 +15911,6 @@\n+void Assembler::esubq_imm32(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_imm32(0x81, 0xE8, src, imm32);\n+}\n+\n@@ -14624,0 +15923,9 @@\n+void Assembler::esubq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x2B);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14629,0 +15937,7 @@\n+void Assembler::esubq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x29, 0xC0, src1, src2);\n+}\n+\n@@ -14686,0 +16001,7 @@\n+void Assembler::exorq(Register dst, Register src1, Register src2, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  (void) evex_prefix_and_encode_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  \/\/ opcode matches gcc\n+  emit_arith(0x31, 0xC0, src1, src2);\n+}\n+\n@@ -14692,0 +16014,9 @@\n+void Assembler::exorq(Register dst, Register src1, Address src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src2, dst->encoding(), src1->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x33);\n+  emit_operand(src1, src2, 0);\n+}\n+\n@@ -14697,0 +16028,6 @@\n+void Assembler::exorq(Register dst, Register src, int32_t imm32, bool no_flags) {\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  evex_prefix_and_encode_ndd(0, dst->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith(0x81, 0xF0, src, imm32);\n+}\n+\n@@ -14703,0 +16040,8 @@\n+void Assembler::exorq(Register dst, Address src, int32_t imm32, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src, dst->encoding(), 0, VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_arith_operand(0x81, as_Register(6), src, imm32);\n+}\n+\n@@ -14709,0 +16054,9 @@\n+void Assembler::exorq(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n+  evex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C, &attributes, no_flags);\n+  emit_int8(0x31);\n+  emit_operand(src2, src1, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1373,"deletions":19,"binary":false,"changes":1392,"status":"modified"},{"patch":"@@ -792,1 +792,5 @@\n-                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);\n+                       bool eevex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc, bool no_flags = false);\n+\n+  void evex_prefix_ndd(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags = false);\n+\n+  void evex_prefix_nf(Address adr, int ndd_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes, bool no_flags = false);\n@@ -795,1 +799,1 @@\n-                  InstructionAttr *attributes);\n+                  InstructionAttr *attributes, bool nds_is_ndd = false, bool no_flags = false);\n@@ -799,1 +803,7 @@\n-                             InstructionAttr *attributes, bool src_is_gpr = false);\n+                             InstructionAttr *attributes, bool src_is_gpr = false, bool nds_is_ndd = false, bool no_flags = false);\n+\n+  int  evex_prefix_and_encode_ndd(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                  InstructionAttr *attributes, bool no_flags = false);\n+\n+  int  evex_prefix_and_encode_nf(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc,\n+                                 InstructionAttr *attributes, bool no_flags = false);\n@@ -944,0 +954,1 @@\n+  void edecl(Register dst, Register src, bool no_flags);\n@@ -945,0 +956,1 @@\n+  void edecl(Register dst, Address src, bool no_flags);\n@@ -946,0 +958,1 @@\n+  void edecq(Register dst, Address src, bool no_flags);\n@@ -948,0 +961,1 @@\n+  void eincl(Register dst, Register src, bool no_flags);\n@@ -949,0 +963,1 @@\n+  void eincl(Register dst, Address src, bool no_flags);\n@@ -950,0 +965,1 @@\n+  void eincq(Register dst, Register src, bool no_flags);\n@@ -951,0 +967,1 @@\n+  void eincq(Register dst, Address src, bool no_flags);\n@@ -1034,0 +1051,1 @@\n+  void edecq(Register dst, Register src, bool no_flags);\n@@ -1075,0 +1093,1 @@\n+  void eaddl(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -1076,0 +1095,1 @@\n+  void eaddl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1077,0 +1097,1 @@\n+  void eaddl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1078,0 +1099,1 @@\n+  void eaddl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1079,0 +1101,1 @@\n+  void eaddl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1081,0 +1104,1 @@\n+  void eaddq(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -1082,0 +1106,1 @@\n+  void eaddq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1083,0 +1108,1 @@\n+  void eaddq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1084,0 +1110,1 @@\n+  void eaddq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1085,0 +1112,1 @@\n+  void eaddq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1089,0 +1117,1 @@\n+  void eadcxq(Register dst, Register src1, Register src2);\n@@ -1092,0 +1121,1 @@\n+  void eadoxq(Register dst, Register src1, Register src2);\n@@ -1125,0 +1155,1 @@\n+  void eandl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1126,0 +1157,1 @@\n+  void eandl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1127,0 +1159,1 @@\n+  void eandl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1128,0 +1161,1 @@\n+  void eandl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1131,0 +1165,1 @@\n+  void eandq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1132,0 +1167,1 @@\n+  void eandq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1133,0 +1169,1 @@\n+  void eandq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1134,0 +1171,1 @@\n+  void eandq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1135,0 +1173,1 @@\n+  void eandq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1185,0 +1224,1 @@\n+  void ecmovl(Condition cc, Register dst, Register src1, Register src2);\n@@ -1186,0 +1226,1 @@\n+  void ecmovl(Condition cc, Register dst, Register src1, Address src2);\n@@ -1188,0 +1229,1 @@\n+  void ecmovq(Condition cc, Register dst, Register src1, Register src2);\n@@ -1189,0 +1231,1 @@\n+  void ecmovq(Condition cc, Register dst, Register src1, Address src2);\n@@ -1491,0 +1534,1 @@\n+  void eidivl(Register src, bool no_flags);\n@@ -1492,0 +1536,1 @@\n+  void edivl(Register src, bool no_flags); \/\/ Unsigned division\n@@ -1495,0 +1540,1 @@\n+  void eidivq(Register src, bool no_flags);\n@@ -1496,0 +1542,1 @@\n+  void edivq(Register src, bool no_flags); \/\/ Unsigned division\n@@ -1499,0 +1546,1 @@\n+  void eimull(Register src, bool no_flags);\n@@ -1500,0 +1548,1 @@\n+  void eimull(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1501,0 +1550,1 @@\n+  void eimull(Register dst, Register src, int value, bool no_flags);\n@@ -1502,0 +1552,1 @@\n+  void eimull(Register dst, Address src, int value, bool no_flags);\n@@ -1503,0 +1554,1 @@\n+  void eimull(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1506,0 +1558,2 @@\n+  void eimulq(Register dst, Register src, bool no_flags);\n+  void eimulq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1507,0 +1561,1 @@\n+  void eimulq(Register dst, Register src, int value, bool no_flags);\n@@ -1508,0 +1563,1 @@\n+  void eimulq(Register dst, Address src, int value, bool no_flags);\n@@ -1509,0 +1565,2 @@\n+  void eimulq(Register dst, Address src, bool no_flags);\n+  void eimulq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1510,0 +1568,1 @@\n+  void eimulq(Register dst, bool no_flags);\n@@ -1568,0 +1627,1 @@\n+  void elzcntl(Register dst, Register src, bool no_flags);\n@@ -1569,0 +1629,1 @@\n+  void elzcntl(Register dst, Address src, bool no_flags);\n@@ -1572,0 +1633,1 @@\n+  void elzcntq(Register dst, Register src, bool no_flags);\n@@ -1573,0 +1635,1 @@\n+  void elzcntq(Register dst, Address src, bool no_flags);\n@@ -1788,0 +1851,1 @@\n+  void emull(Address src, bool no_flags);\n@@ -1789,0 +1853,1 @@\n+  void emull(Register src, bool no_flags);\n@@ -1792,0 +1857,1 @@\n+  void emulq(Address src, bool no_flags);\n@@ -1793,0 +1859,1 @@\n+  void emulq(Register src, bool no_flags);\n@@ -1805,0 +1872,1 @@\n+  void enegl(Register dst, Register src, bool no_flags);\n@@ -1806,0 +1874,1 @@\n+  void enegl(Register dst, Address src, bool no_flags);\n@@ -1809,0 +1878,1 @@\n+  void enegq(Register dst, Register src, bool no_flags);\n@@ -1810,0 +1880,1 @@\n+  void enegq(Register dst, Address src, bool no_flags);\n@@ -1815,0 +1886,1 @@\n+  void enotl(Register dst, Register src);\n@@ -1818,0 +1890,1 @@\n+  void enotq(Register dst, Register src);\n@@ -1825,0 +1898,3 @@\n+  void orw(Register dst, Register src);\n+  void eorw(Register dst, Register src1, Register src2, bool no_flags);\n+\n@@ -1826,0 +1902,1 @@\n+  void eorl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1827,0 +1904,1 @@\n+  void eorl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1828,0 +1906,1 @@\n+  void eorl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1829,0 +1908,1 @@\n+  void eorl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -1830,0 +1910,1 @@\n+  void eorl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1832,0 +1913,1 @@\n+  void eorb(Register dst, Address  src, int imm8, bool no_flags);\n@@ -1833,0 +1915,1 @@\n+  void eorb(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1835,0 +1918,1 @@\n+  void eorq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -1836,0 +1920,1 @@\n+  void eorq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -1837,0 +1922,1 @@\n+  void eorq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1838,0 +1924,1 @@\n+  void eorq_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -1839,0 +1926,1 @@\n+  void eorq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -1840,0 +1928,1 @@\n+  void eorq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2025,0 +2114,1 @@\n+  void epopcntl(Register dst, Address src, bool no_flags);\n@@ -2026,0 +2116,1 @@\n+  void epopcntl(Register dst, Register src, bool no_flags);\n@@ -2034,0 +2125,1 @@\n+  void epopcntq(Register dst, Address src, bool no_flags);\n@@ -2035,0 +2127,1 @@\n+  void epopcntq(Register dst, Register src, bool no_flags);\n@@ -2134,0 +2227,1 @@\n+  void ercll(Register dst, Register src, int imm8);\n@@ -2136,0 +2230,1 @@\n+  void erclq(Register dst, Register src, int imm8);\n@@ -2138,0 +2233,1 @@\n+  void ercrq(Register dst, Register src, int imm8);\n@@ -2148,0 +2244,1 @@\n+  void eroll(Register dst, Register src, bool no_flags);\n@@ -2150,0 +2247,1 @@\n+  void eroll(Register dst, Register src, int imm8, bool no_flags);\n@@ -2152,0 +2250,1 @@\n+  void erorl(Register dst, Register src, bool no_flags);\n@@ -2154,0 +2253,1 @@\n+  void erorl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2157,0 +2257,1 @@\n+  void erolq(Register dst, Register src, bool no_flags);\n@@ -2158,0 +2259,1 @@\n+  void erolq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2159,0 +2261,1 @@\n+  void erorq(Register dst, Register src, bool no_flags);\n@@ -2160,0 +2263,1 @@\n+  void erorq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2169,0 +2273,1 @@\n+  void esall(Register dst, Register src, int imm8, bool no_flags);\n@@ -2170,0 +2275,1 @@\n+  void esall(Register dst, Register src, bool no_flags);\n@@ -2171,0 +2277,1 @@\n+  void esall(Register dst, Address src, int imm8, bool no_flags);\n@@ -2172,0 +2279,1 @@\n+  void esall(Register dst, Address src, bool no_flags);\n@@ -2174,0 +2282,1 @@\n+  void esarl(Register dst, Address src, int imm8, bool no_flags);\n@@ -2175,0 +2284,1 @@\n+  void esarl(Register dst, Address src, bool no_flags);\n@@ -2176,0 +2286,1 @@\n+  void esarl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2177,0 +2288,1 @@\n+  void esarl(Register dst, Register src, bool no_flags);\n@@ -2180,0 +2292,1 @@\n+  void esalq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2181,0 +2294,1 @@\n+  void esalq(Register dst, Register src, bool no_flags);\n@@ -2182,0 +2296,1 @@\n+  void esalq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2183,0 +2298,1 @@\n+  void esalq(Register dst, Address src, bool no_flags);\n@@ -2185,0 +2301,1 @@\n+  void esarq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2186,0 +2303,1 @@\n+  void esarq(Register dst, Address src, bool no_flags);\n@@ -2187,0 +2305,1 @@\n+  void esarq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2188,0 +2307,1 @@\n+  void esarq(Register dst, Register src, bool no_flags);\n@@ -2219,0 +2339,1 @@\n+  void eshldl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2220,0 +2341,1 @@\n+  void eshldl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2221,0 +2343,1 @@\n+  void eshrdl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2222,0 +2345,1 @@\n+  void eshrdl(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2224,0 +2348,1 @@\n+  void eshldq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2225,0 +2350,1 @@\n+  void eshrdq(Register dst, Register src1, Register src2, int8_t imm8, bool no_flags);\n@@ -2228,0 +2354,1 @@\n+  void eshll(Register dst, Register src, int imm8, bool no_flags);\n@@ -2229,0 +2356,1 @@\n+  void eshll(Register dst, Register src, bool no_flags);\n@@ -2231,0 +2359,1 @@\n+  void eshlq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2232,0 +2361,1 @@\n+  void eshlq(Register dst, Register src, bool no_flags);\n@@ -2234,0 +2364,1 @@\n+  void eshrl(Register dst, Register src, int imm8, bool no_flags);\n@@ -2235,0 +2366,1 @@\n+  void eshrl(Register dst, Register src, bool no_flags);\n@@ -2236,0 +2368,1 @@\n+  void eshrl(Register dst, Address src, bool no_flags);\n@@ -2237,0 +2370,1 @@\n+  void eshrl(Register dst, Address src, int imm8, bool no_flags);\n@@ -2239,0 +2373,1 @@\n+  void eshrq(Register dst, Register src, int imm8, bool no_flags);\n@@ -2240,0 +2375,1 @@\n+  void eshrq(Register dst, Register src, bool no_flags);\n@@ -2241,0 +2377,1 @@\n+  void eshrq(Register dst, Address src, bool no_flags);\n@@ -2242,0 +2379,1 @@\n+  void eshrq(Register dst, Address src, int imm8, bool no_flags);\n@@ -2261,0 +2399,1 @@\n+  void esubl(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -2262,0 +2401,1 @@\n+  void esubl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2263,0 +2403,1 @@\n+  void esubl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2264,0 +2405,1 @@\n+  void esubl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2265,0 +2407,1 @@\n+  void esubl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2267,0 +2410,1 @@\n+  void esubq(Register dst, Address src, int32_t imm32, bool no_flags);\n@@ -2268,0 +2412,1 @@\n+  void esubq(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2269,0 +2414,1 @@\n+  void esubq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2270,0 +2416,1 @@\n+  void esubq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2271,0 +2418,1 @@\n+  void esubq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2274,0 +2422,1 @@\n+  void esubl_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2275,0 +2424,1 @@\n+  void esubq_imm32(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2299,0 +2449,1 @@\n+  void etzcntl(Register dst, Register src, bool no_flags);\n@@ -2300,0 +2451,1 @@\n+  void etzcntl(Register dst, Address src, bool no_flags);\n@@ -2301,0 +2453,1 @@\n+  void etzcntq(Register dst, Register src, bool no_flags);\n@@ -2302,0 +2455,1 @@\n+  void etzcntq(Register dst, Address src, bool no_flags);\n@@ -2334,0 +2488,1 @@\n+  void exorl(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2335,0 +2490,1 @@\n+  void exorl(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -2336,0 +2492,1 @@\n+  void exorl(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2337,0 +2494,1 @@\n+  void exorl(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2338,0 +2496,1 @@\n+  void exorl(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2340,0 +2499,1 @@\n+  void exorb(Register dst, Address src1, Register src2, bool no_flags);\n@@ -2341,0 +2501,3 @@\n+  void exorb(Register dst, Register src1, Address src2, bool no_flags);\n+  void xorw(Register dst, Register src);\n+  void exorw(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2342,0 +2505,1 @@\n+  void exorw(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2344,0 +2508,1 @@\n+  void exorq(Register dst, Register src1, Address src2, bool no_flags);\n@@ -2345,0 +2510,1 @@\n+  void exorq(Register dst, Address  src, int32_t imm32, bool no_flags);\n@@ -2346,0 +2512,1 @@\n+  void exorq(Register dst, Register src1, Register src2, bool no_flags);\n@@ -2347,0 +2514,1 @@\n+  void exorq(Register dst, Register src, int32_t imm32, bool no_flags);\n@@ -2348,0 +2516,1 @@\n+  void exorq(Register dst, Address src1, Register src2, bool no_flags);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":172,"deletions":3,"binary":false,"changes":175,"status":"modified"}]}