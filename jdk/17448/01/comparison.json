{"files":[{"patch":"@@ -424,2 +424,5 @@\n-    remove_range_check(ai);\n-    return;\n+    \/\/ Guard against underflow\/overflow (see 'range_cond' check in RangeCheckEliminator::in_block_motion)\n+    if (aii->_max < 0 || (aii->_max + min_jint) <= aii->_min) {\n+      remove_range_check(ai);\n+      return;\n+    }\n@@ -468,1 +471,1 @@\n-        int last_integer = 0;\n+        jint last_integer = 0;\n@@ -470,1 +473,1 @@\n-        int base = 0;\n+        jint base = 0;\n@@ -482,1 +485,1 @@\n-            int value = c->type()->as_IntConstant()->value();\n+            jint value = c->type()->as_IntConstant()->value();\n@@ -487,1 +490,1 @@\n-              base += value;\n+              base = java_add(base, value);\n@@ -509,1 +512,1 @@\n-        \/\/ length-1 and if min < 0, min + idx may overflow and be >=\n+        \/\/ length-1 and if min < 0, min + idx may underflow\/overflow and be >=\n@@ -514,1 +517,1 @@\n-        bool range_cond = (info->_max < 0 || info->_max + min_jint <= info->_min);\n+        bool range_cond = (info->_max < 0 || (info->_max + min_jint) <= info->_min);\n@@ -862,1 +865,1 @@\n-    } else if (_optimistic && loop_header) {\n+    } else if (false && _optimistic && loop_header) {\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2260,2 +2260,2 @@\n-    keys = high - low + 1;\n-    if (keys < 0) {\n+    int64_t keys64 = ((int64_t)high - low) + 1;\n+    if (keys64 > 65535) {  \/\/ Max code length\n@@ -2265,0 +2265,1 @@\n+    keys = (int)keys64;\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-      \/\/ Promote calculation to 64 bits to do range checks, used by the verifier.\n+      \/\/ Promote calculation to signed 64 bits to do range checks, used by the verifier.\n@@ -392,3 +392,8 @@\n-      \/\/ only return len if it can be represented as a positive int;\n-      \/\/ return -1 otherwise\n-      return (len > 0 && len == (int)len) ? (int)len : -1;\n+      \/\/ Only return len if it can be represented as a positive int and lo <= hi.\n+      \/\/ The caller checks for bytecode stream overflow.\n+      if (lo <= hi && len == (int)len) {\n+        assert(len > 0, \"must be\");\n+        return (int)len;\n+      } else {\n+        return -1;\n+      }\n@@ -407,3 +412,7 @@\n-      \/\/ only return len if it can be represented as a positive int;\n-      \/\/ return -1 otherwise\n-      return (len > 0 && len == (int)len) ? (int)len : -1;\n+      \/\/ Only return len if it can be represented as a positive int and npairs >= 0.\n+      if (npairs >= 0 && len == (int)len) {\n+        assert(len > 0, \"must be\");\n+        return (int)len;\n+      } else {\n+        return -1;\n+      }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1901,0 +1901,40 @@\n+    \/\/\n+    \/\/ Example:\n+    \/\/ a[i+x] \/\/ (1) 1 < x < 6\n+    \/\/ a[i+3] \/\/ (2)\n+    \/\/ a[i+4] \/\/ (3)\n+    \/\/ a[i+6] \/\/ max = max of all constants\n+    \/\/ a[i+2]\n+    \/\/ a[i+1] \/\/ min = min of all constants\n+    \/\/\n+    \/\/ If x < 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+max] = a[i+6]: i+x < i+3 <= i+6  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+min] = a[i+1]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ If x >= 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+min] = a[i+1]: i+1 < i+3 <= i+x  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+max] = a[i+6]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ We only need the top 2 range checks if x is the min or max of all constants.\n+    \/\/\n+    \/\/ This, however, only works if the interval [i+min,i+max] is not larger than max_int (i.e. abs(max - min) < max_int):\n+    \/\/ The theoretical max size of an array is max_int with:\n+    \/\/ - Valid index space: [0,max_int-1]\n+    \/\/ - Invalid index space: [max_int,-1] \/\/ max_int, min_int, min_int - 1 ..., -1\n+    \/\/\n+    \/\/ The size of the consecutive valid index space is smaller than the size of the consecutive invalid index space.\n+    \/\/ If we choose min and max in such a way that:\n+    \/\/ - abs(max - min) < max_int\n+    \/\/ - i+max and i+min are inside the valid index space\n+    \/\/ then all indices [i+min,i+max] must be in the valid index space. Otherwise, the invalid index space must be\n+    \/\/ smaller than the valid index space which is never the case for any array size.\n+    \/\/\n+    \/\/ Choosing a smaller array size only makes the valid index space smaller and the invalid index space larger and\n+    \/\/ the argument above still holds.\n+    \/\/\n+    \/\/ Note that the same optimization with the same maximal accepted interval size can also be found in C1.\n+    const jlong maximum_number_of_min_max_interval_indices = (jlong)max_jint;\n@@ -1935,7 +1975,12 @@\n-          \/\/ Gather expanded bounds\n-          off_lo = MIN2(off_lo,offset2);\n-          off_hi = MAX2(off_hi,offset2);\n-          \/\/ Record top NRC range checks\n-          prev_checks[nb_checks%NRC].ctl = prev_dom->as_IfProj();\n-          prev_checks[nb_checks%NRC].off = offset2;\n-          nb_checks++;\n+\n+          \/\/ \"x - y\" -> must add one to the difference for number of elements in [x,y]\n+          const jlong diff = (jlong)MIN2(offset2, off_lo) - (jlong)MAX2(offset2, off_hi);\n+          if (ABS(diff) < maximum_number_of_min_max_interval_indices) {\n+            \/\/ Gather expanded bounds\n+            off_lo = MIN2(off_lo, offset2);\n+            off_hi = MAX2(off_hi, offset2);\n+            \/\/ Record top NRC range checks\n+            prev_checks[nb_checks % NRC].ctl = prev_dom->as_IfProj();\n+            prev_checks[nb_checks % NRC].off = offset2;\n+            nb_checks++;\n+          }\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -853,2 +853,2 @@\n-    idx_type = (TypeInt*)mul->mul_ring(idx_type, scale_type);\n-    if (overflow || TypeInt::INT->higher_equal(idx_type)) {\n+\n+    if (overflow || MulINode::does_overflow(idx_type, scale_type)) {\n@@ -856,0 +856,1 @@\n+      idx_type = TypeInt::INT;\n@@ -868,0 +869,1 @@\n+      idx_type = (TypeInt*)mul->mul_ring(idx_type, scale_type);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -494,3 +494,3 @@\n-static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n-  if (stride_con > 0) {\n-    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n+static int check_stride_overflow(jlong final_correction, const TypeInteger* limit_t, BasicType bt) {\n+  if (final_correction > 0) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -499,1 +499,1 @@\n-    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - final_correction)) {\n@@ -503,1 +503,1 @@\n-    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -506,1 +506,1 @@\n-    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - final_correction)) {\n@@ -1776,2 +1776,109 @@\n-  \/\/ Generate loop limit check to avoid integer overflow\n-  \/\/ in cases like next (cyclic loops):\n+  \/\/ We can only convert this loop to a counted loop if we can guarantee that the iv phi will never overflow at runtime.\n+  \/\/ This is an implicit assumption taken by some loop optimizations. We therefore must ensure this property at all cost.\n+  \/\/ At this point, we've already excluded some trivial cases where an overflow could have been proven statically.\n+  \/\/ But even though we cannot prove that an overflow will *not* happen, we still want to speculatively convert this loop\n+  \/\/ to a counted loop. This can be achieved by adding additional iv phi overflow checks before the loop. If they fail,\n+  \/\/ we trap and resume execution before the loop without having executed any iteration of the loop, yet.\n+  \/\/\n+  \/\/ These additional iv phi overflow checks can be inserted as Loop Limit Check Predicates above the Loop Limit Check\n+  \/\/ Parse Predicate which captures a JVM state just before the entry of the loop. If there is no such Parse Predicate,\n+  \/\/ we cannot generate a Loop Limit Check Predicate and thus cannot speculatively convert the loop to a counted loop.\n+  \/\/\n+  \/\/ In the following, we only focus on int loops with stride > 0 to keep things simple. The argumentation and proof\n+  \/\/ for stride < 0 is analogously. For long loops, we would replace max_int with max_long.\n+  \/\/\n+  \/\/\n+  \/\/ The loop to be converted does not always need to have the often used shape:\n+  \/\/\n+  \/\/                                                 i = init\n+  \/\/     i = init                                loop:\n+  \/\/     do {                                        ...\n+  \/\/         \/\/ ...               equivalent         i+=stride\n+  \/\/         i+=stride               <==>            if (i < limit)\n+  \/\/     } while (i < limit);                          goto loop\n+  \/\/                                             exit:\n+  \/\/                                                 ...\n+  \/\/\n+  \/\/ where the loop exit check uses the post-incremented iv phi and a '<'-operator.\n+  \/\/\n+  \/\/ We could also have '<='-operator (or '>='-operator for negative strides) or use the pre-incremented iv phi value\n+  \/\/ in the loop exit check:\n+  \/\/\n+  \/\/         i = init\n+  \/\/     loop:\n+  \/\/         ...\n+  \/\/         if (i <= limit)\n+  \/\/             i+=stride\n+  \/\/             goto loop\n+  \/\/     exit:\n+  \/\/         ...\n+  \/\/\n+  \/\/ Let's define the following terms:\n+  \/\/ - iv_pre_i: The pre-incremented iv phi before the i-th iteration.\n+  \/\/ - iv_post_i: The post-incremented iv phi after the i-th iteration.\n+  \/\/\n+  \/\/ The iv_pre_i and iv_post_i have the following relation:\n+  \/\/      iv_pre_i + stride = iv_post_i\n+  \/\/\n+  \/\/ When converting a loop to a counted loop, we want to have a canonicalized loop exit check of the form:\n+  \/\/     iv_post_i < adjusted_limit\n+  \/\/\n+  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n+  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+  \/\/           -> adjusted_limit = limit.\n+  \/\/ (LE2) iv_post_i <= limit:\n+  \/\/           iv_post_i < limit + 1\n+  \/\/           -> adjusted limit = limit + 1\n+  \/\/ (LE3) iv_pre_i < limit:\n+  \/\/           iv_pre_i + stride < limit + stride\n+  \/\/           iv_post_i < limit + stride\n+  \/\/           -> adjusted_limit = limit + stride\n+  \/\/ (LE4) iv_pre_i <= limit:\n+  \/\/           iv_pre_i < limit + 1\n+  \/\/           iv_pre_i + stride < limit + stride + 1\n+  \/\/           iv_post_i < limit + stride + 1\n+  \/\/           -> adjusted_limit = limit + stride + 1\n+  \/\/\n+  \/\/ Note that:\n+  \/\/     (AL) limit <= adjusted_limit.\n+  \/\/\n+  \/\/ The following loop invariant has to hold for counted loops with n iterations (i.e. loop exit check true after n-th\n+  \/\/ loop iteration) and a canonicalized loop exit check to guarantee that no iv_post_i over- or underflows:\n+  \/\/ (INV) For i = 1..n, min_int <= iv_post_i <= max_int\n+  \/\/\n+  \/\/ To prove (INV), we require the following two conditions\/assumptions:\n+  \/\/ (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/ (ii): init < limit\n+  \/\/\n+  \/\/ If we can prove (INV), we know that there can be no over- or underflow of any iv phi value. We prove (INV) by\n+  \/\/ induction by assuming (i) and (ii).\n+  \/\/\n+  \/\/ Proof by Induction\n+  \/\/ ------------------\n+  \/\/ > Base case (i = 1): We show that (INV) holds after the first iteration:\n+  \/\/     min_int <= iv_post_1 = init + stride <= max_int\n+  \/\/ Proof:\n+  \/\/     First, we note that (ii) implies\n+  \/\/         (iii) init <= limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride   [using (i)]\n+  \/\/             >= limit - 1 + stride            [using (AL)]\n+  \/\/             >= init + stride                 [using (iii)]\n+  \/\/             >= min_int                       [using stride > 0, no underflow]\n+  \/\/ Thus, no overflow happens after the first iteration and (INV) holds for i = 1.\n+  \/\/\n+  \/\/ Note that to prove the base case we need (i) and (ii).\n+  \/\/\n+  \/\/ > Induction Hypothesis (i = j, j > 1): Assume that (INV) holds after the j-th iteration:\n+  \/\/     min_int <= iv_post_j <= max_int\n+  \/\/ > Step case (i = j + 1): We show that (INV) also holds after the j+1-th iteration:\n+  \/\/     min_int <= iv_post_{j+1} = iv_post_j + stride <= max_int\n+  \/\/ Proof:\n+  \/\/ If iv_post_j >= adjusted_limit:\n+  \/\/     We exit the loop after the j-th iteration, and we don't execute the j+1-th iteration anymore. Thus, there is\n+  \/\/     also no iv_{j+1}. Since (INV) holds for iv_j, there is nothing left to prove.\n+  \/\/ If iv_post_j < adjusted_limit:\n+  \/\/     First, we note that:\n+  \/\/         (iv) iv_post_j <= adjusted_limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride    [using (i)]\n+  \/\/             >= iv_post_j + stride             [using (iv)]\n+  \/\/             >= min_int                        [using stride > 0, no underflow]\n@@ -1779,2 +1886,1 @@\n-  \/\/ for (i=0; i <= max_jint; i++) {}\n-  \/\/ for (i=0; i <  max_jint; i+=2) {}\n+  \/\/ Note that to prove the step case we only need (i).\n@@ -1782,0 +1888,1 @@\n+  \/\/ Thus, by assuming (i) and (ii), we proved (INV).\n@@ -1783,1 +1890,0 @@\n-  \/\/ Limit check predicate depends on the loop test:\n@@ -1785,3 +1891,1 @@\n-  \/\/ for(;i != limit; i++)       --> limit <= (max_jint)\n-  \/\/ for(;i <  limit; i+=stride) --> limit <= (max_jint - stride + 1)\n-  \/\/ for(;i <= limit; i+=stride) --> limit <= (max_jint - stride    )\n+  \/\/ It is therefore enough to add the following two Loop Limit Check Predicates to check assumptions (i) and (ii):\n@@ -1789,0 +1893,52 @@\n+  \/\/ (1) Loop Limit Check Predicate for (i):\n+  \/\/     Using (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/\n+  \/\/     This condition is now restated to use limit instead of adjusted_limit:\n+  \/\/\n+  \/\/     To prevent an overflow of adjusted_limit -1 + stride itself, we rewrite this check to\n+  \/\/         max_int - stride + 1 >= adjusted_limit\n+  \/\/     We can merge the two constants into\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     which gives us\n+  \/\/        max_int - canonicalized_correction >= adjusted_limit\n+  \/\/\n+  \/\/     To directly use limit instead of adjusted_limit in the predicate condition, we split adjusted_limit into:\n+  \/\/         adjusted_limit = limit + limit_correction\n+  \/\/     Since stride > 0 and limit_correction <= stride + 1, we can restate this with no over- or underflow into:\n+  \/\/         max_int - canonicalized_correction - limit_correction >= limit\n+  \/\/     Since canonicalized_correction and limit_correction are both constants, we can replace them with a new constant:\n+  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/     which gives us:\n+  \/\/\n+  \/\/     Final predicate condition:\n+  \/\/         max_int - final_correction >= limit\n+  \/\/\n+  \/\/ (2) Loop Limit Check Predicate for (ii):\n+  \/\/     Using (ii): init < limit\n+  \/\/\n+  \/\/     This Loop Limit Check Predicate is not required if we can prove at compile time that either:\n+  \/\/        (2.1) type(init) < type(limit)\n+  \/\/             In this case, we know:\n+  \/\/                 all possible values of init < all possible values of limit\n+  \/\/             and we can skip the predicate.\n+  \/\/\n+  \/\/        (2.2) init < limit is already checked before (i.e. found as a dominating check)\n+  \/\/            In this case, we do not need to re-check the condition and can skip the predicate.\n+  \/\/            This is often found for while- and for-loops which have the following shape:\n+  \/\/\n+  \/\/                if (init < limit) { \/\/ Dominating test. Do not need the Loop Limit Check Predicate below.\n+  \/\/                    i = init;\n+  \/\/                    if (init >= limit) { trap(); } \/\/ Here we would insert the Loop Limit Check Predicate\n+  \/\/                    do {\n+  \/\/                        i += stride;\n+  \/\/                    } while (i < limit);\n+  \/\/                }\n+  \/\/\n+  \/\/        (2.3) init + stride <= max_int\n+  \/\/            In this case, there is no overflow of the iv phi after the first loop iteration.\n+  \/\/            In the proof of the base case above we showed that init + stride <= max_int by using assumption (ii):\n+  \/\/                init < limit\n+  \/\/            In the proof of the step case above, we did not need (ii) anymore. Therefore, if we already know at\n+  \/\/            compile time that init + stride <= max_int then we have trivially proven the base case and that\n+  \/\/            there is no overflow of the iv phi after the first iteration. In this case, we don't need to check (ii)\n+  \/\/            again and can skip the predicate.\n@@ -1790,3 +1946,0 @@\n-  \/\/ Check if limit is excluded to do more precise int overflow check.\n-  bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n-  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n@@ -1794,8 +1947,2 @@\n-  \/\/ If compare points directly to the phi we need to adjust\n-  \/\/ the compare so that it points to the incr. Limit have\n-  \/\/ to be adjusted to keep trip count the same and the\n-  \/\/ adjusted limit should be checked for int overflow.\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != nullptr) {\n-    stride_m  += stride_con;\n-  }\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != nullptr) ? stride_con : 0;\n@@ -1803,1 +1950,10 @@\n-  Node *init_control = x->in(LoopNode::EntryControl);\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n+  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+  const jlong final_correction = canonicalized_correction + limit_correction;\n+\n+  int sov = check_stride_overflow(final_correction, limit_t, iv_bt);\n+  Node* init_control = x->in(LoopNode::EntryControl);\n@@ -1805,1 +1961,0 @@\n-  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1812,0 +1967,2 @@\n+    \/\/ (1) Loop Limit Check Predicate is required because we could not statically prove that\n+    \/\/     limit + final_correction = adjusted_limit - 1 + stride <= max_int\n@@ -1813,2 +1970,0 @@\n-    \/\/ Generate loop's limit check.\n-    \/\/ Loop limit check predicate should be near the loop.\n@@ -1818,1 +1973,1 @@\n-      \/\/ The limit check predicate is not generated if this method trapped here before.\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n@@ -1838,1 +1993,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1841,1 +1996,1 @@\n-      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - stride_m, iv_bt), iv_bt);\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_signed_integer(iv_bt) - final_correction, iv_bt), iv_bt);\n@@ -1848,14 +2003,24 @@\n-  \/\/ Now we need to canonicalize loop condition.\n-  if (bt == BoolTest::ne) {\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only\");\n-    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n-      \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-      bt = BoolTest::lt;\n-    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n-      \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-      bt = BoolTest::gt;\n-    } else {\n-      const Predicates predicates(init_control);\n-      const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n-      if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n-        \/\/ The limit check predicate is not generated if this method trapped here before.\n+  \/\/ (2.3)\n+  const bool init_plus_stride_could_overflow =\n+          (stride_con > 0 && init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) ||\n+          (stride_con < 0 && init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con);\n+  \/\/ (2.1)\n+  const bool init_gte_limit = (stride_con > 0 && init_t->hi_as_long() >= limit_t->lo_as_long()) ||\n+                              (stride_con < 0 && init_t->lo_as_long() <= limit_t->hi_as_long());\n+\n+  if (init_gte_limit && \/\/ (2.1)\n+     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      !has_dominating_loop_limit_check(init_trip, limit, stride_con, iv_bt, init_control))) { \/\/ (2.2)\n+    \/\/ (2) Iteration Loop Limit Check Predicate is required because neither (2.1), (2.2), nor (2.3) holds.\n+    \/\/ We use the following condition:\n+    \/\/ - stride > 0: init < limit\n+    \/\/ - stride < 0: init > limit\n+    \/\/\n+    \/\/ This predicate is always required if we have a non-equal-operator in the loop exit check (where stride = 1 is\n+    \/\/ a requirement). We transform the loop exit check by using a less-than-operator. By doing so, we must always\n+    \/\/ check that init < limit. Otherwise, we could have a different number of iterations at runtime.\n+\n+    const Predicates predicates(init_control);\n+    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n@@ -1863,7 +2028,4 @@\n-        if (TraceLoopLimitCheck) {\n-          tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n-          loop->dump_head();\n-          x->dump(1);\n-        }\n-#endif\n-        return false;\n+      if (TraceLoopLimitCheck) {\n+        tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n+        loop->dump_head();\n+        x->dump(1);\n@@ -1871,0 +2033,3 @@\n+#endif\n+      return false;\n+    }\n@@ -1872,6 +2037,6 @@\n-      ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n-      Node* parse_predicate_entry = loop_limit_check_parse_predicate->in(0);\n-      if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n-          !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n-        return false;\n-      }\n+    ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n+    Node* parse_predicate_entry = loop_limit_check_parse_predicate->in(0);\n+    if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n+        !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n+      return false;\n+    }\n@@ -1879,2 +2044,2 @@\n-      Node* cmp_limit;\n-      Node* bol;\n+    Node* cmp_limit;\n+    Node* bol;\n@@ -1882,7 +2047,7 @@\n-      if (stride_con > 0) {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::lt);\n-      } else {\n-        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n-        bol = new BoolNode(cmp_limit, BoolTest::gt);\n-      }\n+    if (stride_con > 0) {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::lt);\n+    } else {\n+      cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n+      bol = new BoolNode(cmp_limit, BoolTest::gt);\n+    }\n@@ -1890,1 +2055,2 @@\n-      insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n+  }\n@@ -1892,7 +2058,10 @@\n-      if (stride_con > 0) {\n-        \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-        bt = BoolTest::lt;\n-      } else if (stride_con < 0) {\n-        \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-        bt = BoolTest::gt;\n-      }\n+  if (bt == BoolTest::ne) {\n+    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n+    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n+    if (stride_con > 0) {\n+      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::lt;\n+    } else {\n+      assert(stride_con < 0, \"must be\");\n+      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::gt;\n@@ -1943,0 +2112,1 @@\n+  Node* adjusted_limit = limit;\n@@ -1956,1 +2126,1 @@\n-  if (incl_limit) {\n+  if (includes_limit) {\n@@ -2137,0 +2307,31 @@\n+\/\/ Check if there is a dominating loop limit check of the form 'init < limit' starting at the loop entry.\n+\/\/ If there is one, then we do not need to create an additional Loop Limit Check Predicate.\n+bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const jlong stride_con,\n+                                                     const BasicType iv_bt, Node* loop_entry) {\n+  \/\/ Eagerly call transform() on the Cmp and Bool node to common them up if possible. This is required in order to\n+  \/\/ successfully find a dominated test with the If node below.\n+  Node* cmp_limit;\n+  Node* bol;\n+  if (stride_con > 0) {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::lt));\n+  } else {\n+    cmp_limit = _igvn.transform(CmpNode::make(init_trip, limit, iv_bt));\n+    bol = _igvn.transform(new BoolNode(cmp_limit, BoolTest::gt));\n+  }\n+\n+  \/\/ Check if there is already a dominating init < limit check. If so, we do not need a Loop Limit Check Predicate.\n+  IfNode* iff = new IfNode(loop_entry, bol, PROB_MIN, COUNT_UNKNOWN);\n+  \/\/ Also add fake IfProj nodes in order to call transform() on the newly created IfNode.\n+  IfFalseNode* if_false = new IfFalseNode(iff);\n+  IfTrueNode* if_true = new IfTrueNode(iff);\n+  Node* dominated_iff = _igvn.transform(iff);\n+  \/\/ ConI node? Found dominating test (IfNode::dominated_by() returns a ConI node).\n+  const bool found_dominating_test = dominated_iff != nullptr && dominated_iff->is_ConI();\n+\n+  \/\/ Kill the If with its projections again in the next IGVN round by cutting it off from the graph.\n+  _igvn.replace_input_of(iff, 0, C->top());\n+  _igvn.replace_input_of(iff, 1, C->top());\n+  return found_dominating_test;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":278,"deletions":77,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -1349,0 +1349,2 @@\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, jlong stride_con, BasicType iv_bt,\n+                                       Node* loop_entry);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,2 @@\n-\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/ This template class performs type multiplication for MulI\/MulLNode. NativeType is either jint or jlong.\n+\/\/ In this class, the inputs of the MulNodes are named left and right with types [left_lo,left_hi] and [right_lo,right_hi].\n@@ -286,4 +287,4 @@\n-\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n-\/\/ Without overflow\/underflow:\n-\/\/ Product is positive? High signed multiplication result: 0\n-\/\/ Product is negative? High signed multiplication result: -1\n+\/\/ In general, the multiplication of two x-bit values could produce a result that consumes up to 2x bits if there is\n+\/\/ enough space to hold them all. We can therefore distinguish the following two cases for the product:\n+\/\/ - no overflow (i.e. product fits into x bits)\n+\/\/ - overflow (i.e. product does not fit into x bits)\n@@ -291,8 +292,55 @@\n-\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n-\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n-\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n-\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n-\/\/ the min und max of all computed cross products as type of this Mul node.\n-template<typename IntegerType>\n-class IntegerMulRing {\n-  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\/\/ When multiplying the two x-bit inputs 'left' and 'right' with their x-bit types [left_lo,left_hi] and [right_lo,right_hi]\n+\/\/ we need to find the minimum and maximum of all possible products to define a new type. To do that, we compute the\n+\/\/ cross product of [left_lo,left_hi] and [right_lo,right_hi] in 2x-bit space where no over- or underflow can happen.\n+\/\/ The cross product consists of the following four multiplications with 2x-bit results:\n+\/\/ (1) left_lo * right_lo\n+\/\/ (2) left_lo * right_hi\n+\/\/ (3) left_hi * right_lo\n+\/\/ (4) left_hi * right_hi\n+\/\/\n+\/\/ Let's define the following two functions:\n+\/\/ - Lx(i): Returns the lower x bits of the 2x-bit number i.\n+\/\/ - Ux(i): Returns the upper x bits of the 2x-bit number i.\n+\/\/\n+\/\/ Let's first assume all products are positive where only overflows are possible but no underflows. If there is no\n+\/\/ overflow for a product p, then the upper x bits of the 2x-bit result p are all zero:\n+\/\/     Ux(p) = 0\n+\/\/     Lx(p) = p\n+\/\/\n+\/\/ If none of the multiplications (1)-(4) overflow, we can truncate the upper x bits and use the following result type\n+\/\/ with x bits:\n+\/\/      [result_lo,result_hi] = [MIN(Lx(1),Lx(2),Lx(3),Lx(4)),MAX(Lx(1),Lx(2),Lx(3),Lx(4))]\n+\/\/\n+\/\/ If any of these multiplications overflows, we could pessimistically take the bottom type for the x bit result\n+\/\/ (i.e. all values in the x-bit space could be possible):\n+\/\/      [result_lo,result_hi] = [NativeType_min,NativeType_max]\n+\/\/\n+\/\/ However, in case of any overflow, we can do better by analyzing the upper x bits of all multiplications (1)-(4) with\n+\/\/ 2x-bit results. The upper x bits tell us something about how many times a multiplication has overflown the lower\n+\/\/ x bits. If the upper x bits of (1)-(4) are all equal, then we know that all of these multiplications overflowed\n+\/\/ the lower x bits the same number of times:\n+\/\/     Ux((1)) = Ux((2)) = Ux((3)) = Ux((4))\n+\/\/\n+\/\/ If all upper x bits are equal, we can conclude:\n+\/\/     Lx(MIN((1),(2),(3),(4))) = MIN(Lx(1),Lx(2),Lx(3),Lx(4)))\n+\/\/     Lx(MAX((1),(2),(3),(4))) = MAX(Lx(1),Lx(2),Lx(3),Lx(4)))\n+\/\/\n+\/\/ Therefore, we can use the same precise x-bit result type as for the no-overflow case:\n+\/\/     [result_lo,result_hi] = [(MIN(Lx(1),Lx(2),Lx(3),Lx(4))),MAX(Lx(1),Lx(2),Lx(3),Lx(4)))]\n+\/\/\n+\/\/\n+\/\/ Now let's assume that (1)-(4) are signed multiplications where over- and underflow could occur:\n+\/\/ Negative numbers are all sign extend with ones. Therefore, if a negative product does not underflow, then the\n+\/\/ upper x bits of the 2x-bit result are all set to ones which is minus one in two's complement. If there is an underflow,\n+\/\/ the upper x bits are decremented by the number of times an underflow occurred. The smallest possible negative product\n+\/\/ is NativeType_min*NativeType_max, where the upper x bits are set to NativeType_min \/ 2 (b11...0). It is therefore\n+\/\/ impossible to underflow the upper x bits. Thus, when having all ones (i.e. minus one) in the upper x bits, we know\n+\/\/ that there is no underflow.\n+\/\/\n+\/\/ To be able to compare the number of over-\/underflows of positive and negative products, respectively, we normalize\n+\/\/ the upper x bits of negative 2x-bit products by adding one. This way a product has no over- or underflow if the\n+\/\/ normalized upper x bits are zero. Now we can use the same improved type as for strictly positive products because we\n+\/\/ can compare the upper x bits in a unified way with N() being the normalization function:\n+\/\/     N(Ux((1))) = N(Ux((2))) = N(Ux((3)) = N(Ux((4)))\n+template<typename NativeType>\n+class IntegerTypeMultiplication {\n@@ -304,4 +352,0 @@\n-  NativeType _lo_lo_product;\n-  NativeType _lo_hi_product;\n-  NativeType _hi_lo_product;\n-  NativeType _hi_hi_product;\n@@ -312,8 +356,5 @@\n-  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n-\n-  \/\/ Pre-compute cross products which are used at several places\n-  void compute_cross_products() {\n-    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n-    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n-    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n-    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  static NativeType multiply_high(NativeType x, NativeType y);\n+  const Type* create_type(NativeType lo, NativeType hi) const;\n+\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y) {\n+    return normalize_overflow_value(x, y, multiply_high(x, y));\n@@ -322,1 +363,1 @@\n-  bool cross_products_not_same_overflow() const {\n+  bool cross_product_not_same_overflow_value() const {\n@@ -332,0 +373,4 @@\n+  bool does_product_overflow(NativeType x, NativeType y) const {\n+    return multiply_high_signed_overflow_value(x, y) != 0;\n+  }\n+\n@@ -337,4 +382,5 @@\n-  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n-    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n-    compute_cross_products();\n-  }\n+  template<class IntegerType>\n+  IntegerTypeMultiplication(const IntegerType* left, const IntegerType* right)\n+      : _lo_left(left->_lo), _lo_right(right->_lo),\n+        _hi_left(left->_hi), _hi_right(right->_hi),\n+        _widen_left(left->_widen), _widen_right(right->_widen)  {}\n@@ -347,1 +393,1 @@\n-    if (cross_products_not_same_overflow()) {\n+    if (cross_product_not_same_overflow_value()) {\n@@ -350,3 +396,8 @@\n-    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n-    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n-    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n+\n+    NativeType lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    NativeType lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    NativeType hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    NativeType hi_hi_product = java_multiply(_hi_left, _hi_right);\n+    const NativeType min = MIN4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    const NativeType max = MAX4(lo_lo_product, lo_hi_product, hi_lo_product, hi_hi_product);\n+    return create_type(min, max);\n@@ -354,1 +405,0 @@\n-};\n@@ -356,0 +406,7 @@\n+  bool does_overflow() const {\n+    return does_product_overflow(_lo_left, _lo_right) ||\n+           does_product_overflow(_lo_left, _hi_right) ||\n+           does_product_overflow(_hi_left, _lo_right) ||\n+           does_product_overflow(_hi_left, _hi_right);\n+  }\n+};\n@@ -358,1 +415,1 @@\n-const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+const Type* IntegerTypeMultiplication<jint>::overflow_type() {\n@@ -363,1 +420,1 @@\n-jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+jint IntegerTypeMultiplication<jint>::multiply_high(const jint x, const jint y) {\n@@ -367,2 +424,1 @@\n-  const jint result = (jint)((uint64_t)product >> 32u);\n-  return normalize_overflow_value(x, y, result);\n+  return (jint)((uint64_t)product >> 32u);\n@@ -372,1 +428,6 @@\n-const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+const Type* IntegerTypeMultiplication<jint>::create_type(jint lo, jint hi) const {\n+  return TypeInt::make(lo, hi, MAX2(_widen_left, _widen_right));\n+}\n+\n+template <>\n+const Type* IntegerTypeMultiplication<jlong>::overflow_type() {\n@@ -377,3 +438,7 @@\n-jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n-  const jlong result = multiply_high_signed(x, y);\n-  return normalize_overflow_value(x, y, result);\n+jlong IntegerTypeMultiplication<jlong>::multiply_high(const jlong x, const jlong y) {\n+  return multiply_high_signed(x, y);\n+}\n+\n+template <>\n+const Type* IntegerTypeMultiplication<jlong>::create_type(jlong lo, jlong hi) const {\n+  return TypeLong::make(lo, hi, MAX2(_widen_left, _widen_right));\n@@ -384,2 +449,7 @@\n-  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n-  return integer_mul_ring.compute();\n+  const IntegerTypeMultiplication<jint> integer_multiplication(type_left->is_int(), type_right->is_int());\n+  return integer_multiplication.compute();\n+}\n+\n+bool MulINode::does_overflow(const TypeInt* type_left, const TypeInt* type_right) {\n+  const IntegerTypeMultiplication<jint> integer_multiplication(type_left, type_right);\n+  return integer_multiplication.does_overflow();\n@@ -390,2 +460,2 @@\n-  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n-  return integer_mul_ring.compute();\n+  const IntegerTypeMultiplication<jlong> integer_multiplication(type_left->is_long(), type_right->is_long());\n+  return integer_multiplication.compute();\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":117,"deletions":47,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  static bool does_overflow(const TypeInt* type_left, const TypeInt* type_right);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    private boolean forTlsPremasterSecret = false;\n@@ -289,0 +290,1 @@\n+                forTlsPremasterSecret = true;\n@@ -380,1 +382,1 @@\n-                if (result == null) {\n+                if (result == null && !forTlsPremasterSecret) {\n@@ -469,1 +471,0 @@\n-        Exception failover = null;\n@@ -475,8 +476,5 @@\n-        } catch (BadPaddingException e) {\n-            if (isTlsRsaPremasterSecret) {\n-                failover = e;\n-            } else {\n-                throw new InvalidKeyException(\"Unwrapping failed\", e);\n-            }\n-        } catch (IllegalBlockSizeException e) {\n-            \/\/ should not occur, handled with length check above\n+        } catch (BadPaddingException | IllegalBlockSizeException e) {\n+            \/\/ BadPaddingException cannot happen for TLS RSA unwrap.\n+            \/\/ In that case, padding error is indicated by returning null.\n+            \/\/ IllegalBlockSizeException cannot happen in any case,\n+            \/\/ because of the length check above.\n@@ -488,1 +486,1 @@\n-                if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n+                if (!forTlsPremasterSecret) {\n@@ -497,1 +495,1 @@\n-                        random, encoded, (failover != null));\n+                        random, encoded, encoded == null);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipher.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.internal.misc.ThreadTracker;\n@@ -74,0 +75,4 @@\n+    private static class ThreadTrackerHolder {\n+        static final ThreadTracker AIA_TRACKER = new ThreadTracker();\n+    }\n+\n@@ -339,1 +344,1 @@\n-     * Download Certificates from the given AIA and add them to the\n+     * Download certificates from the given AIA and add them to the\n@@ -351,0 +356,1 @@\n+\n@@ -356,10 +362,27 @@\n-        boolean add = false;\n-        for (AccessDescription ad : adList) {\n-            CertStore cs = URICertStore.getInstance(ad);\n-            if (cs != null) {\n-                try {\n-                    if (certs.addAll((Collection<X509Certificate>)\n-                        cs.getCertificates(caSelector))) {\n-                        add = true;\n-                        if (!searchAllCertStores) {\n-                            return true;\n+        Object key = ThreadTrackerHolder.AIA_TRACKER.tryBegin();\n+        if (key == null) {\n+            \/\/ Avoid recursive fetching of certificates\n+            if (debug != null) {\n+                debug.println(\"Recursive fetching of certs via the AIA \" +\n+                    \"extension detected\");\n+            }\n+            return false;\n+        }\n+\n+        try {\n+            boolean add = false;\n+            for (AccessDescription ad : adList) {\n+                CertStore cs = URICertStore.getInstance(ad);\n+                if (cs != null) {\n+                    try {\n+                        if (certs.addAll((Collection<X509Certificate>)\n+                            cs.getCertificates(caSelector))) {\n+                            add = true;\n+                            if (!searchAllCertStores) {\n+                                return true;\n+                            }\n+                        }\n+                    } catch (CertStoreException cse) {\n+                        if (debug != null) {\n+                            debug.println(\"exception getting certs from CertStore:\");\n+                            cse.printStackTrace();\n@@ -367,5 +390,0 @@\n-                    }\n-                } catch (CertStoreException cse) {\n-                    if (debug != null) {\n-                        debug.println(\"exception getting certs from CertStore:\");\n-                        cse.printStackTrace();\n@@ -375,0 +393,3 @@\n+            return add;\n+        } finally {\n+            ThreadTrackerHolder.AIA_TRACKER.end(key);\n@@ -376,1 +397,0 @@\n-        return add;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":37,"deletions":17,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -294,2 +294,1 @@\n-     * @param  isFailOver whether the previous decryption of the\n-     *         encrypted PreMasterSecret message run into problem\n+     * @param  failure true if encoded is incorrect according to previous checks\n@@ -300,1 +299,3 @@\n-            byte[] encoded, boolean isFailOver) {\n+            byte[] encoded, boolean failure) {\n+\n+        byte[] tmp;\n@@ -308,17 +309,5 @@\n-        if (!isFailOver && (encoded != null)) {\n-            \/\/ check the length\n-            if (encoded.length != 48) {\n-                \/\/ private, don't need to clone the byte array.\n-                return replacer;\n-            }\n-\n-            int encodedVersion =\n-                    ((encoded[0] & 0xFF) << 8) | (encoded[1] & 0xFF);\n-            if (clientVersion != encodedVersion) {\n-                if (clientVersion > 0x0301 ||               \/\/ 0x0301: TLSv1\n-                       serverVersion != encodedVersion) {\n-                    encoded = replacer;\n-                }   \/\/ Otherwise, For compatibility, we maintain the behavior\n-                    \/\/ that the version in pre_master_secret can be the\n-                    \/\/ negotiated version for TLS v1.0 and SSL v3.0.\n-            }\n+        if (failure) {\n+            tmp = replacer;\n+        } else {\n+            tmp = encoded;\n+        }\n@@ -326,0 +315,7 @@\n+        if (tmp == null) {\n+            encoded = replacer;\n+        } else {\n+            encoded = tmp;\n+        }\n+        \/\/ check the length\n+        if (encoded.length != 48) {\n@@ -327,1 +323,3 @@\n-            return encoded;\n+            tmp = replacer;\n+        } else {\n+            tmp = encoded;\n@@ -330,2 +328,13 @@\n-        \/\/ private, don't need to clone the byte array.\n-        return replacer;\n+        int encodedVersion =\n+                ((tmp[0] & 0xFF) << 8) | (tmp[1] & 0xFF);\n+        int check1 = 0;\n+        int check2 = 0;\n+        int check3 = 0;\n+        if (clientVersion != encodedVersion) check1 = 1;\n+        if (clientVersion > 0x0301) check2 = 1;\n+        if (serverVersion != encodedVersion) check3 = 1;\n+        if ((check1 & (check2 | check3)) == 1) {\n+            return replacer;\n+        } else {\n+            return tmp;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":32,"deletions":23,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,1 @@\n+#include <stdint.h>\n@@ -1198,1 +1199,1 @@\n-            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;\n+            keys = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]) + 1;\n@@ -1680,1 +1681,1 @@\n-            int index;\n+            int64_t low, high, index;\n@@ -1684,1 +1685,4 @@\n-            index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);\n+            low  = _ck_ntohl(lpc[1]);\n+            high = _ck_ntohl(lpc[2]);\n+            index = high - low;\n+            \/\/ The value of low must be less than or equal to high - i.e. index >= 0\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Arrays;\n@@ -64,0 +65,3 @@\n+    private static final int ERROR_INVALID_PARAMETER = 0x57;\n+    private static final int NTE_INVALID_PARAMETER = 0x80090027;\n+\n@@ -104,0 +108,2 @@\n+    private boolean forTlsPremasterSecret = false;\n+\n@@ -174,0 +180,3 @@\n+            this.forTlsPremasterSecret = true;\n+        } else {\n+            this.forTlsPremasterSecret = false;\n@@ -281,2 +290,1 @@\n-    private byte[] doFinal() throws BadPaddingException,\n-            IllegalBlockSizeException {\n+    private byte[] doFinal() throws IllegalBlockSizeException {\n@@ -311,1 +319,1 @@\n-        } catch (KeyException e) {\n+        } catch (KeyException | BadPaddingException e) {\n@@ -334,1 +342,1 @@\n-            throws BadPaddingException, IllegalBlockSizeException {\n+            throws IllegalBlockSizeException {\n@@ -341,1 +349,1 @@\n-            int outOfs) throws ShortBufferException, BadPaddingException,\n+            int outOfs) throws ShortBufferException,\n@@ -357,0 +365,1 @@\n+\n@@ -365,6 +374,1 @@\n-        try {\n-            return doFinal();\n-        } catch (BadPaddingException e) {\n-            \/\/ should not occur\n-            throw new InvalidKeyException(\"Wrapping failed\", e);\n-        }\n+        return doFinal();\n@@ -391,6 +395,0 @@\n-        } catch (BadPaddingException e) {\n-            if (isTlsRsaPremasterSecret) {\n-                failover = e;\n-            } else {\n-                throw new InvalidKeyException(\"Unwrapping failed\", e);\n-            }\n@@ -402,4 +400,12 @@\n-        if (isTlsRsaPremasterSecret) {\n-            if (!(spec instanceof TlsRsaPremasterSecretParameterSpec)) {\n-                throw new IllegalStateException(\n-                        \"No TlsRsaPremasterSecretParameterSpec specified\");\n+        try {\n+            if (isTlsRsaPremasterSecret) {\n+                if (!forTlsPremasterSecret) {\n+                    throw new IllegalStateException(\n+                            \"No TlsRsaPremasterSecretParameterSpec specified\");\n+                }\n+\n+                \/\/ polish the TLS premaster secret\n+                encoded = KeyUtil.checkTlsPreMasterSecretKey(\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getClientVersion(),\n+                        ((TlsRsaPremasterSecretParameterSpec) spec).getServerVersion(),\n+                        random, encoded, encoded == null);\n@@ -408,5 +414,5 @@\n-            \/\/ polish the TLS premaster secret\n-            encoded = KeyUtil.checkTlsPreMasterSecretKey(\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getClientVersion(),\n-                ((TlsRsaPremasterSecretParameterSpec)spec).getServerVersion(),\n-                random, encoded, (failover != null));\n+            return constructKey(encoded, algorithm, type);\n+        } finally {\n+            if (encoded != null) {\n+                Arrays.fill(encoded, (byte) 0);\n+            }\n@@ -414,2 +420,0 @@\n-\n-        return constructKey(encoded, algorithm, type);\n@@ -499,2 +503,4 @@\n-    private static byte[] encryptDecrypt(byte[] data, int dataSize,\n-            CKey key, boolean doEncrypt) throws KeyException {\n+    private byte[] encryptDecrypt(byte[] data, int dataSize,\n+            CKey key, boolean doEncrypt) throws KeyException, BadPaddingException {\n+        int[] returnStatus = new int[1];\n+        byte[] result;\n@@ -502,1 +508,1 @@\n-            return encryptDecrypt(data, dataSize, key.getHCryptKey(), doEncrypt);\n+            result = encryptDecrypt(returnStatus, data, dataSize, key.getHCryptKey(), doEncrypt);\n@@ -504,1 +510,1 @@\n-            return cngEncryptDecrypt(data, dataSize, key.getHCryptProvider(), doEncrypt);\n+            result = cngEncryptDecrypt(returnStatus, data, dataSize, key.getHCryptProvider(), doEncrypt);\n@@ -506,0 +512,11 @@\n+        if ((returnStatus[0] == ERROR_INVALID_PARAMETER) || (returnStatus[0] == NTE_INVALID_PARAMETER)) {\n+            if (forTlsPremasterSecret) {\n+                result = null;\n+            } else {\n+                throw new BadPaddingException(\"Error \" + returnStatus[0] + \" returned by MSCAPI\");\n+            }\n+        } else if (returnStatus[0] != 0) {\n+            throw new KeyException(\"Error \" + returnStatus[0] + \" returned by MSCAPI\");\n+        }\n+\n+        return result;\n@@ -508,1 +525,1 @@\n-    private static native byte[] encryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] encryptDecrypt(int[] returnStatus, byte[] data, int dataSize,\n@@ -510,1 +527,1 @@\n-    private static native byte[] cngEncryptDecrypt(byte[] data, int dataSize,\n+    private static native byte[] cngEncryptDecrypt(int[] returnStatus, byte[] data, int dataSize,\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/CRSACipher.java","additions":52,"deletions":35,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1908,1 +1908,1 @@\n- * Signature: ([BIJZ)[B\n+ * Signature: ([I[BIJZ)[B\n@@ -1911,1 +1911,1 @@\n-  (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,\n+  (JNIEnv *env, jclass clazz, jintArray jResultStatus, jbyteArray jData, jint jDataSize, jlong hKey,\n@@ -1916,0 +1916,1 @@\n+    jbyte* resultData = NULL;\n@@ -1920,0 +1921,6 @@\n+    BOOL success;\n+    DWORD ss = ERROR_SUCCESS;\n+    DWORD lastError = ERROR_SUCCESS;\n+    DWORD resultLen = 0;\n+    DWORD pmsLen = 48;\n+    jbyte pmsArr[48] = {0};\n@@ -1946,0 +1953,2 @@\n+            resultData = pData;\n+            resultLen = dwBufLen;\n@@ -1955,5 +1964,11 @@\n-            if (! ::CryptDecrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, \/\/deprecated\n-                &dwBufLen)) {\n-\n-                ThrowException(env, KEY_EXCEPTION, GetLastError());\n-                __leave;\n+            success = ::CryptDecrypt((HCRYPTKEY) hKey, 0, TRUE, 0, (BYTE *)pData, \/\/deprecated\n+                &dwBufLen);\n+            lastError = GetLastError();\n+            if (success) {\n+                ss = ERROR_SUCCESS;\n+                resultData = pData;\n+                resultLen = dwBufLen;\n+            } else {\n+                ss = lastError;\n+                resultData = pmsArr;\n+                resultLen = pmsLen;\n@@ -1961,0 +1976,1 @@\n+            env->SetIntArrayRegion(jResultStatus, 0, 1, (jint*) &ss);\n@@ -1963,2 +1979,2 @@\n-        \/\/ Create new byte array\n-        if ((result = env->NewByteArray(dwBufLen)) == NULL) {\n+            \/\/ Create new byte array\n+        if ((result = env->NewByteArray(resultLen)) == NULL) {\n@@ -1969,1 +1985,1 @@\n-        env->SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);\n+        env->SetByteArrayRegion(result, 0, resultLen, (jbyte*) resultData);\n@@ -1983,1 +1999,1 @@\n- * Signature: ([BIJZ)[B\n+ * Signature: ([I[BIJZ)[B\n@@ -1986,1 +2002,1 @@\n-  (JNIEnv *env, jclass clazz, jbyteArray jData, jint jDataSize, jlong hKey,\n+  (JNIEnv *env, jclass clazz, jintArray jResultStatus, jbyteArray jData, jint jDataSize, jlong hKey,\n@@ -1992,0 +2008,1 @@\n+    jbyte* resultData = NULL;\n@@ -1994,0 +2011,4 @@\n+    DWORD resultLen = 0;\n+    DWORD pmsLen = 48;\n+    jbyte pmsArr[48] = {0};\n+\n@@ -2013,0 +2034,3 @@\n+            } else {\n+                resultLen = dwBufLen;\n+                resultData = pData;\n@@ -2021,3 +2045,7 @@\n-            if (ss != ERROR_SUCCESS) {\n-                ThrowException(env, KEY_EXCEPTION, ss);\n-                __leave;\n+            env->SetIntArrayRegion(jResultStatus, 0, 1, (jint*) &ss);\n+            if (ss == ERROR_SUCCESS) {\n+                resultLen = dwBufLen;\n+                resultData = pData;\n+            } else {\n+                resultLen = pmsLen;\n+                resultData = pmsArr;\n@@ -2025,1 +2053,1 @@\n-        }\n+       }\n@@ -2027,1 +2055,1 @@\n-        if ((result = env->NewByteArray(dwBufLen)) == NULL) {\n+        if ((result = env->NewByteArray(resultLen)) == NULL) {\n@@ -2032,1 +2060,1 @@\n-        env->SetByteArrayRegion(result, 0, dwBufLen, (jbyte*) pData);\n+        env->SetByteArrayRegion(result, 0, resultLen, (jbyte*) resultData);\n","filename":"src\/jdk.crypto.mscapi\/windows\/native\/libsunmscapi\/security.cpp","additions":46,"deletions":18,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+compiler\/c2\/irTests\/TestDuplicateBackedge.java 8318904 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}