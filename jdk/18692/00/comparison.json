{"files":[{"patch":"@@ -872,1 +872,1 @@\n-    if (r->is_old_or_humongous() && !r->is_collection_set_candidate()) {\n+    if (r->is_old_or_humongous() && !r->is_collection_set_candidate() && !r->in_collection_set()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -487,7 +487,2 @@\n-\n-  \/\/ Must be before collection set calculation, requires collection set to not\n-  \/\/ be calculated yet.\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    concurrent_mark()->pre_concurrent_start(_gc_cause);\n-  }\n-\n+  \/\/ Flush various data in thread-local buffers to be able to determine the collection\n+  \/\/ set\n@@ -504,0 +499,4 @@\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    concurrent_mark()->pre_concurrent_start(_gc_cause);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\/\/ - Flush pin count cache (Java threads)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Check that TAMSes are correctly updated for regions dropped from\n+ *          the retained collection set candidates during a Concurrent Start pause.\n+ * @requires vm.gc.G1\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+                     -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -Xmx32m -XX:G1NumCollectionsKeepPinned=1\n+                     -XX:+VerifyBeforeGC -XX:+VerifyAfterGC -XX:G1MixedGCLiveThresholdPercent=100\n+                     -XX:G1HeapWastePercent=0 -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestDroppedRetainedTAMS\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDroppedRetainedTAMS {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static final char[] dummy = new char[100];\n+\n+    public static void main(String[] args) {\n+        wb.fullGC(); \/\/ Move the target dummy object to old gen.\n+\n+        wb.pinObject(dummy);\n+\n+        \/\/ After this concurrent cycle the pinned region will be in the the (marking)\n+        \/\/ collection set candidates.\n+        wb.g1RunConcurrentGC();\n+\n+        \/\/ Pass the Prepare mixed gc which will not do anything about the marking\n+        \/\/ candidates.\n+        wb.youngGC();\n+        \/\/ Mixed GC. Will complete. That pinned region is now retained. The mixed gcs\n+        \/\/ will end here.\n+        wb.youngGC();\n+\n+        \/\/ The pinned region will be dropped from the retained candidates during the\n+        \/\/ Concurrent Start GC, leaving that region's TAMS broken.\n+        wb.g1RunConcurrentGC();\n+\n+        \/\/ Verification will find a lot of broken objects.\n+        wb.youngGC();\n+        System.out.println(dummy);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestDroppedRetainedTAMS.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}