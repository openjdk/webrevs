{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,16 +268,0 @@\n-###############################################################################\n-# Check if the feature 'jfr' is available on this platform.\n-#\n-AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JFR],\n-[\n-  JVM_FEATURES_CHECK_AVAILABILITY(jfr, [\n-    AC_MSG_CHECKING([if platform is supported by JFR])\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n-      AVAILABLE=false\n-    else\n-      AC_MSG_RESULT([yes])\n-    fi\n-  ])\n-])\n-\n@@ -403,1 +387,0 @@\n-  JVM_FEATURES_CHECK_JFR\n@@ -409,6 +392,0 @@\n-  # Filter out features by default for all variants on certain platforms.\n-  # Make sure to just add to JVM_FEATURES_PLATFORM_FILTER, since it could\n-  # have a value already from custom extensions.\n-  if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n-    JVM_FEATURES_PLATFORM_FILTER=\"$JVM_FEATURES_PLATFORM_FILTER jfr\"\n-  fi\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3,0 +4,1 @@\n+ * Copyright (c) 2022, IBM Corp.\n@@ -33,0 +35,3 @@\n+typedef int (*fun_perfstat_cpu_t) (perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n+\n@@ -39,0 +44,7 @@\n+typedef int (*fun_perfstat_netinterface_t) (perfstat_id_t *name, perfstat_netinterface_t* userbuff,\n+                                            int sizeof_userbuff, int desired_number);\n+\n+typedef int (*fun_perfstat_process_t) (perfstat_id_t *name,\n+                                       PERFSTAT_PROCESS_T_LATEST* userbuff, int sizeof_userbuff,\n+                                       int desired_number);\n+\n@@ -51,2 +63,4 @@\n-static fun_perfstat_cpu_total_t     g_fun_perfstat_cpu_total = NULL;\n-static fun_perfstat_memory_total_t  g_fun_perfstat_memory_total = NULL;\n+static fun_perfstat_cpu_total_t       g_fun_perfstat_cpu_total       = NULL;\n+static fun_perfstat_cpu_t             g_fun_perfstat_cpu             = NULL;\n+static fun_perfstat_memory_total_t    g_fun_perfstat_memory_total    = NULL;\n+static fun_perfstat_netinterface_t    g_fun_perfstat_netinterface    = NULL;\n@@ -54,3 +68,4 @@\n-static fun_perfstat_wpar_total_t    g_fun_perfstat_wpar_total = NULL;\n-static fun_perfstat_reset_t         g_fun_perfstat_reset = NULL;\n-static fun_wpar_getcid_t            g_fun_wpar_getcid = NULL;\n+static fun_perfstat_process_t         g_fun_perfstat_process         = NULL;\n+static fun_perfstat_wpar_total_t      g_fun_perfstat_wpar_total      = NULL;\n+static fun_perfstat_reset_t           g_fun_perfstat_reset           = NULL;\n+static fun_wpar_getcid_t              g_fun_wpar_getcid              = NULL;\n@@ -87,0 +102,1 @@\n+  RESOLVE_FUN(perfstat_cpu);\n@@ -88,0 +104,2 @@\n+  RESOLVE_FUN(perfstat_netinterface);\n+  RESOLVE_FUN(perfstat_process);\n@@ -111,0 +129,16 @@\n+int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n+                                    int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu_total == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n+int libperfstat::perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_cpu == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_cpu(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n@@ -120,3 +154,4 @@\n-int libperfstat::perfstat_cpu_total(perfstat_id_t *name, PERFSTAT_CPU_TOTAL_T_LATEST* userbuff,\n-                                    int sizeof_userbuff, int desired_number) {\n-  if (g_fun_perfstat_cpu_total == NULL) {\n+int libperfstat::perfstat_netinterface(perfstat_id_t *name,\n+                                       perfstat_netinterface_t* userbuff,\n+                                       int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_netinterface == NULL) {\n@@ -125,1 +160,1 @@\n-  return g_fun_perfstat_cpu_total(name, userbuff, sizeof_userbuff, desired_number);\n+  return g_fun_perfstat_netinterface(name, userbuff, sizeof_userbuff, desired_number);\n@@ -136,0 +171,8 @@\n+int libperfstat::perfstat_process(perfstat_id_t *name, perfstat_process_t* userbuff,\n+                                  int sizeof_userbuff, int desired_number) {\n+  if (g_fun_perfstat_process == NULL) {\n+    return -1;\n+  }\n+  return g_fun_perfstat_process(name, userbuff, sizeof_userbuff, desired_number);\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.cpp","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -3,0 +4,1 @@\n+ * Copyright (c) 2022, IBM Corp.\n@@ -50,1 +52,3 @@\n-#define IDENTIFIER_LENGTH 64    \/* length of strings included in the structures *\/\n+#define IDENTIFIER_LENGTH  64    \/* length of strings included in the structures *\/\n+#define FIRST_CPU          \"\"    \/* pseudo-name for fist CPU *\/\n+#define FIRST_NETINTERFACE \"\"    \/* pseudo-name for first NETINTERFACE *\/\n@@ -442,0 +446,96 @@\n+typedef struct { \/* component perfstat_cpu_t from AIX 7.2 documentation *\/\n+  char name [IDENTIFIER_LENGTH];            \/* Logical processor name (processor0, processor1,.). *\/\n+  ulong_t state;                            \/* Specifies whether the CPU is offline or online.\n+                                             * (NOTE: The type of 'state' is not specified in the documentation, but\n+                                             * ulong_t is the correct length) *\/\n+  u_longlong_t user;                        \/* Raw number of clock ticks spent in user mode. *\/\n+  u_longlong_t sys;                         \/* Raw number of clock ticks spent in system mode. *\/\n+  u_longlong_t idle;                        \/* Raw number of clock ticks spent idle. *\/\n+  u_longlong_t wait;                        \/* Raw number of clock ticks spent waiting for I\/O. *\/\n+  u_longlong_t pswitch;                     \/* Number of context switches (changes of currently running process). *\/\n+  u_longlong_t syscall;                     \/* Number of system calls executed. *\/\n+  u_longlong_t sysread;                     \/* Number of read system calls executed. *\/\n+  u_longlong_t syswrite;                    \/* Number of write system calls executed. *\/\n+  u_longlong_t sysfork;                     \/* Number of fork system call executed. *\/\n+  u_longlong_t sysexec;                     \/* Number of exec system call executed. *\/\n+  u_longlong_t readch;                      \/* Number of characters transferred with read system call. *\/\n+  u_longlong_t writech;                     \/* Number of characters transferred with write system call. *\/\n+  u_longlong_t bread;                       \/* Number of block reads. *\/\n+  u_longlong_t bwrite;                      \/* Number of block writes. *\/\n+  u_longlong_t lread;                       \/* Number of logical read requests. *\/\n+  u_longlong_t lwrite;                      \/* Number of logical write requests. *\/\n+  u_longlong_t phread;                      \/* Number of physical reads (reads on raw device). *\/\n+  u_longlong_t phwrite;                     \/* Number of physical writes (writes on raw device). *\/\n+  u_longlong_t iget;                        \/* Number of inode lookups. *\/\n+  u_longlong_t namei;                       \/* Number of vnode lookup from a path name. *\/\n+  u_longlong_t dirblk;                      \/* Number of 512-byte blocks reads by the directory search routine to locate an entry for a file. *\/\n+  u_longlong_t msg;                         \/* Number of interprocess communication (IPC) message operations. *\/\n+  u_longlong_t sema;                        \/* Number of IPC semaphore operations. *\/\n+  u_longlong_t minfaults;                   \/* Number of page faults with no I\/O. *\/\n+  u_longlong_t majfaults;                   \/* Number of page faults with disk I\/O. *\/\n+  u_longlong_t puser;                       \/* Raw number of physical processor ticks in user mode. *\/\n+  u_longlong_t psys;                        \/* Raw number of physical processor ticks in system mode. *\/\n+  u_longlong_t pidle;                       \/* Raw number of physical processor ticks idle. *\/\n+  u_longlong_t pwait;                       \/* Raw number of physical processor ticks waiting for I\/O. *\/\n+  u_longlong_t redisp_sd0;                  \/* Number of thread redispatches within the scheduler affinity domain 0. *\/\n+  u_longlong_t redisp_sd1;                  \/* Number of thread redispatches within the scheduler affinity domain 1. *\/\n+  u_longlong_t redisp_sd2;                  \/* Number of thread redispatches within the scheduler affinity domain 2. *\/\n+  u_longlong_t redisp_sd3;                  \/* Number of thread redispatches within the scheduler affinity domain 3. *\/\n+  u_longlong_t redisp_sd4;                  \/* Number of thread redispatches within the scheduler affinity domain 4. *\/\n+  u_longlong_t redisp_sd5;                  \/* Number of thread redispatches within the scheduler affinity domain 5. *\/\n+  u_longlong_t migration_push;              \/* Number of thread migrations from the local runque to another queue due to starvation load balancing. *\/\n+  u_longlong_t migration_S3grq;             \/* Number of thread migrations from the global runque to the local runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t migration_S3pull;            \/* Number of thread migrations from another processor's runque resulting in a move across scheduling domain 3. *\/\n+  u_longlong_t invol_cswitch;               \/* Number of involuntary thread context switches. *\/\n+  u_longlong_t vol_cswitch;                 \/* Number of voluntary thread context switches. *\/\n+  u_longlong_t runque;                      \/* Number of threads on the runque. *\/\n+  u_longlong_t bound;                       \/* Number of bound threads. *\/\n+  u_longlong_t decrintrs;                   \/* Number of decrementer interrupts. *\/\n+  u_longlong_t mpcrintrs;                   \/* Number of received interrupts for MPC. *\/\n+  u_longlong_t mpcsintrs;                   \/* Number of sent interrupts for MPC. *\/\n+  u_longlong_t devintrs;                    \/* Number of device interrupts. *\/\n+  u_longlong_t softintrs;                   \/* Number of offlevel handlers called. *\/\n+  u_longlong_t phantintrs;                  \/* Number of phantom interrupts. *\/\n+  u_longlong_t idle_donated_purr;           \/* Number of idle cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_donated_spurr;          \/* Number of idle spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_purr;           \/* Number of busy cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t busy_donated_spurr;          \/* Number of busy spurr cycles donated by a dedicated partition enabled for donation. *\/\n+  u_longlong_t idle_stolen_purr;            \/* Number of idle cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t idle_stolen_spurr;           \/* Number of idle spurr cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_purr;            \/* Number of busy cycles stolen by the hypervisor from a dedicated partition. *\/\n+  u_longlong_t busy_stolen_spurr;           \/* Number of busy spurr cycles stolen by the hypervisor from a dedicated partition.*\/\n+  u_longlong_t shcpus_in_sys;               \/* Number of physical processors allocated for shared processor use, across all shared processors pools. *\/\n+  u_longlong_t entitled_pool_capacity;      \/* Entitled processor capacity of partitionâ€™s pool. *\/\n+  u_longlong_t pool_max_time;               \/* Summation of maximum time that can be consumed by the pool (nanoseconds). *\/\n+  u_longlong_t pool_busy_time;              \/* Summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t pool_scaled_busy_time;       \/* Scaled summation of busy (nonidle) time accumulated across all partitions in the pool (nanoseconds). *\/\n+  u_longlong_t shcpu_tot_time;              \/* Summation of total time across all physical processors allocated for shared processor use (nanoseconds). *\/\n+  u_longlong_t shcpu_busy_time;             \/* Summation of busy (nonidle) time accumulated across all shared processor partitions (nanoseconds). *\/\n+  u_longlong_t shcpu_scaled_busy_time;      \/* Scaled summation of busy time accumulated across all shared processor partitions (nanoseconds). *\/\n+  int ams_pool_id;                          \/* AMS pool ID of the pool the LPAR belongs to. *\/\n+  int var_mem_weight;                       \/* Variable memory capacity weight. *\/\n+  u_longlong_t iome;                        \/* I\/O memory entitlement of the partition in bytes. *\/\n+  u_longlong_t pmem;                        \/* Physical memory currently backing the partition's logical memory in bytes. *\/\n+  u_longlong_t hpi;                         \/* Number of hypervisor page-ins. *\/\n+  u_longlong_t hpit;                        \/* Time spent in hypervisor page-ins (in nanoseconds). *\/\n+  u_longlong_t hypv_pagesize;               \/* Hypervisor page size in KB. *\/\n+  uint online_lcpus;                        \/* Number of online logical processors. *\/\n+  uint smt_thrds;                           \/* Number of SMT threads. *\/\n+} perfstat_cpu_t;\n+\n+typedef struct {\n+  char name[IDENTIFIER_LENGTH];             \/* Name of the interface. *\/\n+  char description[IDENTIFIER_LENGTH];      \/* Interface description (from ODM, similar to lscfg output). *\/\n+  uchar type;                               \/* Ethernet, token ring, and so on. Interpretation can be done using the \/usr\/include\/net\/if_types.h file. *\/\n+  u_longlong_t mtu;                         \/* Network frame size. *\/\n+  u_longlong_t ipacets;                     \/* Number of packets received on interface. *\/\n+  u_longlong_t ibytes;                      \/* Number of bytes received on interface. *\/\n+  u_longlong_t ierrors;                     \/* Number of input errors on interface. *\/\n+  u_longlong_t opackets;                    \/* Number of packets sent on interface. *\/\n+  u_longlong_t obytes;                      \/* Number of bytes sent on interface. *\/\n+  u_longlong_t oerrors;                     \/* Number of output errors on interface. *\/\n+  u_longlong_t collisions;                  \/* Number of collisions on csma interface. *\/\n+  u_longlong_t bitrate;                     \/* Adapter rating in bit per second. *\/\n+  u_longlong_t if_iqdrops;                  \/* Dropped on input, this interface. *\/\n+  u_longlong_t if_arpdrops;                 \/* Dropped because no arp response. *\/\n+} perfstat_netinterface_t;\n@@ -800,0 +900,32 @@\n+typedef struct {\n+        u_longlong_t version;                 \/* Version number of the data structure. *\/\n+        u_longlong_t pid;                     \/* Process ID. *\/\n+        char proc_name[64];                   \/* Name of the process. *\/\n+        int proc_priority;                    \/* Process priority. *\/\n+        u_longlong_t num_threads;             \/* Thread count. *\/\n+        u_longlong_t proc_uid;                \/* Owner information. *\/\n+        u_longlong_t proc_classid;            \/* WLM class name. *\/\n+        u_longlong_t proc_size;               \/* Virtual size of the process (exclusive usage, leaving all shared library text & shared file pages, shared memory, and memory mapped). *\/\n+        u_longlong_t proc_real_mem_data;      \/* Real memory used for data in KB. *\/\n+        u_longlong_t proc_real_mem_text;      \/* Real memory used for text in KB. *\/\n+        u_longlong_t proc_virt_mem_data;      \/* Virtual memory used for data in KB. *\/\n+        u_longlong_t proc_virt_mem_text;      \/* Virtual memory used for text in KB. *\/\n+        u_longlong_t shared_lib_data_size;    \/* Data size from shared library in KB. *\/\n+        u_longlong_t heap_size;               \/* Heap size in KB. *\/\n+        u_longlong_t real_inuse;              \/* The Real memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t virt_inuse;              \/* The virtual memory (in KB) in use by the process including all kind of segments (excluding system segments). This includes text, data, shared library text, shared library data, file pages, shared memory, and memory mapped. *\/\n+        u_longlong_t pinned;                  \/* Pinned memory (in KB) for this process inclusive of all segments. *\/\n+        u_longlong_t pgsp_inuse;              \/* Paging space used (in KB) inclusive of all segments. *\/\n+        u_longlong_t filepages;               \/* File pages used (in KB) including shared pages. *\/\n+        u_longlong_t real_inuse_map;          \/* Real memory used (in KB) for shared memory and memory mapped regions *\/\n+        u_longlong_t virt_inuse_map;          \/* Virtual memory used (in KB) for shared memory and memory mapped regions. *\/\n+        u_longlong_t pinned_inuse_map;        \/* Pinned memory used (in KB) for shared memory and memory mapped regions. *\/\n+        double ucpu_time;                     \/* User mode CPU time is in percentage or milliseconds, which is based on, whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        double scpu_time;                     \/* System mode CPU time is in percentage or milliseconds, which is based on whether it is filled by perfstat_process_util or perfstat_process respectively. *\/\n+        u_longlong_t last_timebase;           \/* Timebase counter. *\/\n+        u_longlong_t inBytes;                 \/* Bytes written to disk. *\/\n+        u_longlong_t outBytes;                \/* Bytes read from disk. *\/\n+        u_longlong_t inOps;                   \/* In operations from disk. *\/\n+        u_longlong_t outOps;                  \/* Out operations from disk *\/\n+} perfstat_process_t;\n+\n@@ -857,3 +989,8 @@\n-#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1\/* latest perfstat_partition_total_t structure *\/\n-#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72             \/* latest perfstat_cpu_total_t structure *\/\n-#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71           \/* latest perfstat_wpar_total_t structure *\/\n+#define PERFSTAT_PARTITON_TOTAL_T_LATEST perfstat_partition_total_t_71_1 \/* latest perfstat_partition_total_t structure *\/\n+#define PERFSTAT_PROCESS_T_LATEST perfstat_process_t                     \/* latest perfstat_process_t structure *\/\n+#define PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t_72              \/* latest perfstat_cpu_total_t structure *\/\n+#define PERFSTAT_CPU_T_LATEST perfstat_cpu_t                             \/* latest perfstat_cpu_t structure *\/\n+#define PERFSTAT_NETINTERFACE_T_LATEST perfstat_netinterface_t           \/* latest perfstat_netinterface_t structure *\/\n+#define PERFSTAT_WPAR_TOTAL_T_LATEST perfstat_wpar_total_t_71            \/* latest perfstat_wpar_total_t structure *\/\n+\n+typedef PERFSTAT_CPU_TOTAL_T_LATEST perfstat_cpu_total_t;\n@@ -889,0 +1026,8 @@\n+  static int perfstat_cpu(perfstat_id_t *name, PERFSTAT_CPU_T_LATEST* userbuff,\n+                          int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_process(perfstat_id_t *name, PERFSTAT_PROCESS_T_LATEST* userbuff,\n+                              int sizeof_userbuff, int desired_number);\n+\n+  static int perfstat_netinterface(perfstat_id_t *name, PERFSTAT_NETINTERFACE_T_LATEST* userbuff,\n+                                   int sizeof_userbuff, int desired_number);\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.hpp","additions":149,"deletions":4,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2022, IBM Corp.\n@@ -113,7 +114,1 @@\n-struct entry_t {\n-  entry_t* next;\n-  loaded_module_t info;\n-};\n-\n-static void print_entry(const entry_t* e, outputStream* os) {\n-  const loaded_module_t* const lm = &(e->info);\n+static void print_entry(const loaded_module_t* lm, outputStream* os) {\n@@ -132,1 +127,1 @@\n-static entry_t* g_first = NULL;\n+static loaded_module_t* g_first = NULL;\n@@ -134,5 +129,5 @@\n-static entry_t* find_entry_for_text_address(const void* p) {\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    if ((uintptr_t)p >= (uintptr_t)e->info.text &&\n-        (uintptr_t)p < ((uintptr_t)e->info.text + e->info.text_len)) {\n-      return e;\n+static loaded_module_t* find_entry_for_text_address(const void* p) {\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    if ((uintptr_t)p >= (uintptr_t)lm->text &&\n+        (uintptr_t)p < ((uintptr_t)lm->text + lm->text_len)) {\n+      return lm;\n@@ -144,5 +139,5 @@\n-static entry_t* find_entry_for_data_address(const void* p) {\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    if ((uintptr_t)p >= (uintptr_t)e->info.data &&\n-        (uintptr_t)p < ((uintptr_t)e->info.data + e->info.data_len)) {\n-      return e;\n+static loaded_module_t* find_entry_for_data_address(const void* p) {\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    if ((uintptr_t)p >= (uintptr_t)lm->data &&\n+        (uintptr_t)p < ((uintptr_t)lm->data + lm->data_len)) {\n+      return lm;\n@@ -155,6 +150,6 @@\n-static void add_entry_to_list(entry_t* e, entry_t** start) {\n-  entry_t* last = NULL;\n-  entry_t* e2 = *start;\n-  while (e2 && e2->info.text < e->info.text) {\n-    last = e2;\n-    e2 = e2->next;\n+static void add_entry_to_list(loaded_module_t* lm, loaded_module_t** start) {\n+  loaded_module_t* last = NULL;\n+  loaded_module_t* lm2 = *start;\n+  while (lm2 && lm2->text < lm->text) {\n+    last = lm2;\n+    lm2 = lm2->next;\n@@ -163,1 +158,1 @@\n-    last->next = e;\n+    last->next = lm;\n@@ -165,1 +160,1 @@\n-    *start = e;\n+    *start = lm;\n@@ -167,1 +162,1 @@\n-  e->next = e2;\n+  lm->next = lm2;\n@@ -170,6 +165,6 @@\n-static void free_entry_list(entry_t** start) {\n-  entry_t* e = *start;\n-  while (e) {\n-    entry_t* const e2 = e->next;\n-    ::free(e);\n-    e = e2;\n+static void free_entry_list(loaded_module_t** start) {\n+  loaded_module_t* lm = *start;\n+  while (lm) {\n+    loaded_module_t* const lm2 = lm->next;\n+    ::free(lm);\n+    lm = lm2;\n@@ -189,1 +184,1 @@\n-  entry_t* new_list = NULL;\n+  loaded_module_t* new_list = NULL;\n@@ -217,2 +212,2 @@\n-    entry_t* e = (entry_t*) ::malloc(sizeof(entry_t));\n-    if (!e) {\n+    loaded_module_t* lm = (loaded_module_t*) ::malloc(sizeof(loaded_module_t));\n+    if (!lm) {\n@@ -223,1 +218,1 @@\n-    memset(e, 0, sizeof(entry_t));\n+    memset(lm, 0, sizeof(loaded_module_t));\n@@ -225,4 +220,4 @@\n-    e->info.text = ldi->ldinfo_textorg;\n-    e->info.text_len = ldi->ldinfo_textsize;\n-    e->info.data = ldi->ldinfo_dataorg;\n-    e->info.data_len = ldi->ldinfo_datasize;\n+    lm->text     = ldi->ldinfo_textorg;\n+    lm->text_len = ldi->ldinfo_textsize;\n+    lm->data     = ldi->ldinfo_dataorg;\n+    lm->data_len = ldi->ldinfo_datasize;\n@@ -230,2 +225,2 @@\n-    e->info.path = g_stringlist.add(ldi->ldinfo_filename);\n-    if (!e->info.path) {\n+    lm->path = g_stringlist.add(ldi->ldinfo_filename);\n+    if (!lm->path) {\n@@ -238,1 +233,1 @@\n-      const char* p = strrchr(e->info.path, '\/');\n+      const char* p = strrchr(lm->path, '\/');\n@@ -241,1 +236,1 @@\n-        e->info.shortname = p;\n+        lm->shortname = p;\n@@ -243,1 +238,1 @@\n-        e->info.shortname = e->info.path;\n+        lm->shortname = lm->path;\n@@ -251,2 +246,2 @@\n-      e->info.member = g_stringlist.add(p_mbr_name);\n-      if (!e->info.member) {\n+      lm->member = g_stringlist.add(p_mbr_name);\n+      if (!lm->member) {\n@@ -257,1 +252,1 @@\n-      e->info.member = NULL;\n+      lm->member = NULL;\n@@ -260,1 +255,1 @@\n-    if (strcmp(e->info.shortname, \"libjvm.so\") == 0) {\n+    if (strcmp(lm->shortname, \"libjvm.so\") == 0) {\n@@ -264,1 +259,1 @@\n-      e->info.is_in_vm = true;\n+      lm->is_in_vm = true;\n@@ -268,5 +263,5 @@\n-      e->info.text, e->info.text_len,\n-      e->info.data, e->info.data_len,\n-      e->info.path, e->info.shortname,\n-      (e->info.member ? e->info.member : \"NULL\"),\n-      e->info.is_in_vm\n+      lm->text, lm->text_len,\n+      lm->data, lm->data_len,\n+      lm->path, lm->shortname,\n+      (lm->member ? lm->member : \"NULL\"),\n+      lm->is_in_vm\n@@ -276,1 +271,1 @@\n-    add_entry_to_list(e, &new_list);\n+    add_entry_to_list(lm, &new_list);\n@@ -307,0 +302,17 @@\n+\/\/ Callback for loaded module information (from os.hpp)\n+\/\/ Input parameters:\n+\/\/    char*     module_file_name,\n+\/\/    address   module_base_addr,\n+\/\/    address   module_top_addr,\n+\/\/    void*     param\n+static bool for_each_internal(os::LoadedModulesCallbackFunc cb, void* param) {\n+\n+  for (const loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    (*cb)(lm->shortname,\n+          (address) lm->text,\n+          (address) lm->text + lm->text_len,\n+          param);\n+  }\n+\n+  return true;\n+}\n@@ -325,2 +337,2 @@\n-  for (entry_t* e = g_first; e; e = e->next) {\n-    print_entry(e, os);\n+  for (loaded_module_t* lm = g_first; lm; lm = lm->next) {\n+    print_entry(lm, os);\n@@ -337,6 +349,4 @@\n-  const entry_t* const e = find_entry_for_text_address(p);\n-  if (e) {\n-    if (info) {\n-      *info = e->info;\n-    }\n-    return true;\n+\n+  const loaded_module_t* const lm = find_entry_for_text_address(p);\n+  if (!lm) {\n+    return false;\n@@ -344,1 +354,6 @@\n-  return false;\n+\n+  if (info) {\n+    memcpy(info, lm, sizeof(loaded_module_t));\n+    info->next = nullptr;\n+  }\n+  return true;\n@@ -356,4 +371,21 @@\n-  const entry_t* const e = find_entry_for_data_address(p);\n-  if (e) {\n-    if (info) {\n-      *info = e->info;\n+\n+  const loaded_module_t* const lm = find_entry_for_data_address(p);\n+  if (!lm) {\n+    return false;\n+  }\n+\n+  if (info) {\n+    memcpy(info, lm, sizeof(loaded_module_t));\n+    info->next = nullptr;\n+  }\n+  return true;\n+}\n+\n+bool LoadedLibraries::for_each(os::LoadedModulesCallbackFunc cb, void* param) {\n+  MiscUtils::AutoCritSect lck(&g_cs);\n+\n+  if (!g_first) {\n+    if (!reload_table()) {\n+      \/\/ If the table is not loaded and cannot be initialized,\n+      \/\/ then we must quit.\n+      return false;\n@@ -361,1 +393,0 @@\n-    return true;\n@@ -363,1 +394,2 @@\n-  return false;\n+\n+  return for_each_internal(cb, param);\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":105,"deletions":73,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +36,3 @@\n+#include \"misc_aix.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n@@ -69,0 +73,3 @@\n+  \/\/ Next item in the list, or NULL if no such item exits\n+  loaded_module_t* next;\n+\n@@ -102,0 +109,4 @@\n+    \/\/ Apply the callback to each loaded_module_t in the list\n+    \/\/ Return false if module table is empty and cannot be loaded.\n+    static bool for_each(os::LoadedModulesCallbackFunc cb, void* param);\n+\n@@ -104,0 +115,1 @@\n+\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1134,1 +1134,5 @@\n-  \/\/ Not yet implemented.\n+\n+  if (!LoadedLibraries::for_each(callback, param)) {\n+    return -1;\n+  }\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, IBM Corp.\n@@ -27,0 +28,1 @@\n+#include \"libperfstat_aix.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -32,0 +35,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -34,3 +38,2 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <unistd.h>\n+#include <dirent.h>\n+#include <dlfcn.h>\n@@ -38,0 +41,4 @@\n+#include <limits.h>\n+#include <pthread.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n@@ -39,0 +46,1 @@\n+#include <sys\/procfs.h>\n@@ -40,1 +48,0 @@\n-#include <sys\/types.h>\n@@ -42,1 +49,1 @@\n-#include <dirent.h>\n+#include <sys\/types.h>\n@@ -44,163 +51,1 @@\n-#include <dlfcn.h>\n-#include <pthread.h>\n-#include <limits.h>\n-\n-\/**\n-   \/proc\/[number]\/stat\n-              Status information about the process.  This is used by ps(1).  It is defined in \/usr\/src\/linux\/fs\/proc\/array.c.\n-\n-              The fields, in order, with their proper scanf(3) format specifiers, are:\n-\n-              1. pid %d The process id.\n-\n-              2. comm %s\n-                     The filename of the executable, in parentheses.  This is visible whether or not the executable is swapped out.\n-\n-              3. state %c\n-                     One  character  from  the  string \"RSDZTW\" where R is running, S is sleeping in an interruptible wait, D is waiting in uninterruptible disk\n-                     sleep, Z is zombie, T is traced or stopped (on a signal), and W is paging.\n-\n-              4. ppid %d\n-                     The PID of the parent.\n-\n-              5. pgrp %d\n-                     The process group ID of the process.\n-\n-              6. session %d\n-                     The session ID of the process.\n-\n-              7. tty_nr %d\n-                     The tty the process uses.\n-\n-              8. tpgid %d\n-                     The process group ID of the process which currently owns the tty that the process is connected to.\n-\n-              9. flags %lu\n-                     The flags of the process.  The math bit is decimal 4, and the traced bit is decimal 10.\n-\n-              10. minflt %lu\n-                     The number of minor faults the process has made which have not required loading a memory page from disk.\n-\n-              11. cminflt %lu\n-                     The number of minor faults that the process's waited-for children have made.\n-\n-              12. majflt %lu\n-                     The number of major faults the process has made which have required loading a memory page from disk.\n-\n-              13. cmajflt %lu\n-                     The number of major faults that the process's waited-for children have made.\n-\n-              14. utime %lu\n-                     The number of jiffies that this process has been scheduled in user mode.\n-\n-              15. stime %lu\n-                     The number of jiffies that this process has been scheduled in kernel mode.\n-\n-              16. cutime %ld\n-                     The number of jiffies that this process's waited-for children have been scheduled in user mode. (See also times(2).)\n-\n-              17. cstime %ld\n-                     The number of jiffies that this process' waited-for children have been scheduled in kernel mode.\n-\n-              18. priority %ld\n-                     The standard nice value, plus fifteen.  The value is never negative in the kernel.\n-\n-              19. nice %ld\n-                     The nice value ranges from 19 (nicest) to -19 (not nice to others).\n-\n-              20. 0 %ld  This value is hard coded to 0 as a placeholder for a removed field.\n-\n-              21. itrealvalue %ld\n-                     The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.\n-\n-              22. starttime %lu\n-                     The time in jiffies the process started after system boot.\n-\n-              23. vsize %lu\n-                     Virtual memory size in bytes.\n-\n-              24. rss %ld\n-                     Resident Set Size: number of pages the process has in real memory, minus 3 for administrative purposes. This is just the pages which  count\n-                     towards text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.\n-\n-              25. rlim %lu\n-                     Current limit in bytes on the rss of the process (usually 4294967295 on i386).\n-\n-              26. startcode %lu\n-                     The address above which program text can run.\n-\n-              27. endcode %lu\n-                     The address below which program text can run.\n-\n-              28. startstack %lu\n-                     The address of the start of the stack.\n-\n-              29. kstkesp %lu\n-                     The current value of esp (stack pointer), as found in the kernel stack page for the process.\n-\n-              30. kstkeip %lu\n-                     The current EIP (instruction pointer).\n-\n-              31. signal %lu\n-                     The bitmap of pending signals (usually 0).\n-\n-              32. blocked %lu\n-                     The bitmap of blocked signals (usually 0, 2 for shells).\n-\n-              33. sigignore %lu\n-                     The bitmap of ignored signals.\n-\n-              34. sigcatch %lu\n-                     The bitmap of catched signals.\n-\n-              35. wchan %lu\n-                     This  is the \"channel\" in which the process is waiting.  It is the address of a system call, and can be looked up in a namelist if you need\n-                     a textual name.  (If you have an up-to-date \/etc\/psdatabase, then try ps -l to see the WCHAN field in action.)\n-\n-              36. nswap %lu\n-                     Number of pages swapped - not maintained.\n-\n-              37. cnswap %lu\n-                     Cumulative nswap for child processes.\n-\n-              38. exit_signal %d\n-                     Signal to be sent to parent when we die.\n-\n-              39. processor %d\n-                     CPU number last executed on.\n-\n-\n-\n- \/\/\/\/\/ SSCANF FORMAT STRING. Copy and use.\n-\n-field:        1  2  3  4  5  6  7  8  9   10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 39\n-format:       %d %s %c %d %d %d %d %d %lu %lu %lu %lu %lu %lu %lu %ld %ld %ld %ld %ld %ld %lu %lu %ld %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %d %d\n-\n-\n-*\/\n-\n-\/**\n- * For platforms that have them, when declaring\n- * a printf-style function,\n- *   formatSpec is the parameter number (starting at 1)\n- *       that is the format argument (\"%d pid %s\")\n- *   params is the parameter number where the actual args to\n- *       the format starts. If the args are in a va_list, this\n- *       should be 0.\n- *\/\n-#ifndef PRINTF_ARGS\n-#  define PRINTF_ARGS(formatSpec,  params) ATTRIBUTE_PRINTF(formatSpec, params)\n-#endif\n-\n-#ifndef SCANF_ARGS\n-#  define SCANF_ARGS(formatSpec,   params) ATTRIBUTE_SCANF(formatSpec, params)\n-#endif\n-\n-#ifndef _PRINTFMT_\n-#  define _PRINTFMT_\n-#endif\n-\n-#ifndef _SCANFMT_\n-#  define _SCANFMT_\n-#endif\n-\n+#include <unistd.h>\n@@ -208,5 +53,6 @@\n-struct CPUPerfTicks {\n-  uint64_t  used;\n-  uint64_t  usedKernel;\n-  uint64_t  total;\n-};\n+typedef struct {\n+  u_longlong_t  user;\n+  u_longlong_t  sys;\n+  u_longlong_t  idle;\n+  u_longlong_t  wait;\n+} cpu_tick_store_t;\n@@ -214,4 +60,4 @@\n-typedef enum {\n-  CPU_LOAD_VM_ONLY,\n-  CPU_LOAD_GLOBAL,\n-} CpuLoadTarget;\n+typedef struct {\n+  double utime;\n+  double stime;\n+} jvm_time_store_t;\n@@ -226,10 +72,2 @@\n-struct CPUPerfCounters {\n-  int   nProcs;\n-  CPUPerfTicks jvmTicks;\n-  CPUPerfTicks* cpus;\n-};\n-\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target);\n-\n-\/** reads \/proc\/<pid>\/stat data, with some checks and some skips.\n- *  Ensure that 'fmt' does _NOT_ contain the first two \"%d %s\"\n+\/**\n+ * Get info for requested PID from \/proc\/<pid>\/psinfo file\n@@ -237,23 +75,2 @@\n-static int SCANF_ARGS(2, 0) vread_statdata(const char* procfile, _SCANFMT_ const char* fmt, va_list args) {\n-  FILE*f;\n-  int n;\n-  char buf[2048];\n-\n-  if ((f = os::fopen(procfile, \"r\")) == NULL) {\n-    return -1;\n-  }\n-\n-  if ((n = fread(buf, 1, sizeof(buf), f)) != -1) {\n-    char *tmp;\n-\n-    buf[n-1] = '\\0';\n-    \/** skip through pid and exec name. *\/\n-    if ((tmp = strrchr(buf, ')')) != NULL) {\n-      \/\/ skip the ')' and the following space\n-      \/\/ but check that buffer is long enough\n-      tmp += 2;\n-      if (tmp < buf + n) {\n-        n = vsscanf(tmp, fmt, args);\n-      }\n-    }\n-  }\n+static bool read_psinfo(const u_longlong_t& pid, psinfo_t& psinfo) {\n+  static size_t BUF_LENGTH = 32 + sizeof(u_longlong_t);\n@@ -261,1 +78,3 @@\n-  fclose(f);\n+  FILE* fp;\n+  char buf[BUF_LENGTH];\n+  int len;\n@@ -263,2 +82,2 @@\n-  return n;\n-}\n+  jio_snprintf(buf, BUF_LENGTH, \"\/proc\/%llu\/psinfo\", pid);\n+  fp = fopen(buf, \"r\");\n@@ -266,3 +85,3 @@\n-static int SCANF_ARGS(2, 3) read_statdata(const char* procfile, _SCANFMT_ const char* fmt, ...) {\n-  int   n;\n-  va_list args;\n+  if (!fp) {\n+    return false;\n+  }\n@@ -270,4 +89,2 @@\n-  va_start(args, fmt);\n-  n = vread_statdata(procfile, fmt, args);\n-  va_end(args);\n-  return n;\n+  len = fread(&psinfo, 1, sizeof(psinfo_t), fp);\n+  return len == sizeof(psinfo_t);\n@@ -277,2 +94,1 @@\n- * on Linux we got the ticks related information from \/proc\/stat\n- * this does not work on AIX, libperfstat might be an alternative\n+ * Get and set ticks for the specified lcpu\n@@ -280,3 +96,2 @@\n-static OSReturn get_total_ticks(int which_logical_cpu, CPUPerfTicks* pticks) {\n-  return OS_ERR;\n-}\n+static OSReturn get_lcpu_ticks(perfstat_id_t* lcpu_name, cpu_tick_store_t* pticks) {\n+  perfstat_cpu_t lcpu_stats;\n@@ -284,5 +99,3 @@\n-\/** read user and system ticks from a named procfile, assumed to be in 'stat' format then. *\/\n-static int read_ticks(const char* procfile, uint64_t* userTicks, uint64_t* systemTicks) {\n-  return read_statdata(procfile, \"%*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u \" UINT64_FORMAT \" \" UINT64_FORMAT,\n-    userTicks, systemTicks);\n-}\n+  if (!pticks) {\n+    return OS_ERR;\n+  }\n@@ -290,6 +103,12 @@\n-\/**\n- * Return the number of ticks spent in any of the processes belonging\n- * to the JVM on any CPU.\n- *\/\n-static OSReturn get_jvm_ticks(CPUPerfTicks* pticks) {\n-  return OS_ERR;\n+  \/\/ populate cpu_stats\n+  if (libperfstat::perfstat_cpu(lcpu_name, &lcpu_stats, sizeof(perfstat_cpu_t), 1) < 1) {\n+    memset(pticks, 0, sizeof(cpu_tick_store_t));\n+    return OS_ERR;\n+  }\n+\n+  pticks->user = lcpu_stats.user;\n+  pticks->sys  = lcpu_stats.sys;\n+  pticks->idle = lcpu_stats.idle;\n+  pticks->wait = lcpu_stats.wait;\n+\n+  return OS_OK;\n@@ -299,5 +118,1 @@\n- * Return the load of the CPU as a double. 1.0 means the CPU process uses all\n- * available time for user or system processes, 0.0 means the CPU uses all time\n- * being idle.\n- *\n- * Returns a negative value if there is a problem in determining the CPU load.\n+ * Return CPU load caused by the currently executing process (the jvm).\n@@ -305,5 +120,3 @@\n-static double get_cpu_load(int which_logical_cpu, CPUPerfCounters* counters, double* pkernelLoad, CpuLoadTarget target) {\n-  uint64_t udiff, kdiff, tdiff;\n-  CPUPerfTicks* pticks;\n-  CPUPerfTicks  tmp;\n-  double user_load;\n+static OSReturn get_jvm_load(double* jvm_uload, double* jvm_sload) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n+  static u_longlong_t last_timebase = 0;\n@@ -311,1 +124,3 @@\n-  *pkernelLoad = 0.0;\n+  perfstat_process_t jvm_stats;\n+  perfstat_id_t name_holder;\n+  u_longlong_t timebase_diff;\n@@ -313,6 +128,3 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    pticks = &counters->jvmTicks;\n-  } else if (-1 == which_logical_cpu) {\n-    pticks = &counters->cpus[counters->nProcs];\n-  } else {\n-    pticks = &counters->cpus[which_logical_cpu];\n+  jio_snprintf(name_holder.name, IDENTIFIER_LENGTH, \"%d\", getpid());\n+  if (libperfstat::perfstat_process(&name_holder, &jvm_stats, sizeof(perfstat_process_t), 1) < 1) {\n+    return OS_ERR;\n@@ -321,1 +133,3 @@\n-  tmp = *pticks;\n+  \/\/ Update timebase\n+  timebase_diff = jvm_stats.last_timebase - last_timebase;\n+  last_timebase = jvm_stats.last_timebase;\n@@ -323,6 +137,5 @@\n-  if (target == CPU_LOAD_VM_ONLY) {\n-    if (get_jvm_ticks(pticks) != OS_OK) {\n-      return -1.0;\n-    }\n-  } else if (get_total_ticks(which_logical_cpu, pticks) != OS_OK) {\n-    return -1.0;\n+  if (jvm_uload) {\n+    *jvm_uload = jvm_stats.ucpu_time \/ timebase_diff;\n+  }\n+  if (jvm_sload) {\n+    *jvm_sload = jvm_stats.scpu_time \/ timebase_diff;\n@@ -331,6 +144,6 @@\n-  \/\/ seems like we sometimes end up with less kernel ticks when\n-  \/\/ reading \/proc\/self\/stat a second time, timing issue between cpus?\n-  if (pticks->usedKernel < tmp.usedKernel) {\n-    kdiff = 0;\n-  } else {\n-    kdiff = pticks->usedKernel - tmp.usedKernel;\n+  return OS_OK;\n+}\n+\n+static void update_prev_time(jvm_time_store_t* from, jvm_time_store_t* to) {\n+  if (from && to) {\n+    memcpy(to, from, sizeof(jvm_time_store_t));\n@@ -338,2 +151,1 @@\n-  tdiff = pticks->total - tmp.total;\n-  udiff = pticks->used - tmp.used;\n+}\n@@ -341,4 +153,3 @@\n-  if (tdiff == 0) {\n-    return 0.0;\n-  } else if (tdiff < (udiff + kdiff)) {\n-    tdiff = udiff + kdiff;\n+static void update_prev_ticks(cpu_tick_store_t* from, cpu_tick_store_t* to) {\n+  if (from && to) {\n+    memcpy(to, from, sizeof(cpu_tick_store_t));\n@@ -346,4 +157,1 @@\n-  *pkernelLoad = (kdiff \/ (double)tdiff);\n-  \/\/ BUG9044876, normalize return values to sane values\n-  *pkernelLoad = MAX2<double>(*pkernelLoad, 0.0);\n-  *pkernelLoad = MIN2<double>(*pkernelLoad, 1.0);\n+}\n@@ -351,3 +159,5 @@\n-  user_load = (udiff \/ (double)tdiff);\n-  user_load = MAX2<double>(user_load, 0.0);\n-  user_load = MIN2<double>(user_load, 1.0);\n+\/**\n+ * Calculate the current system load from current ticks using previous ticks as a starting point.\n+ *\/\n+static void calculate_updated_load(cpu_tick_store_t* update, cpu_tick_store_t* prev, double* load) {\n+  cpu_tick_store_t diff;\n@@ -355,2 +165,5 @@\n-  return user_load;\n-}\n+  if (update && prev && load) {\n+    diff.user = update->user - prev->user;\n+    diff.sys  = update->sys  - prev->sys;\n+    diff.idle = update->idle - prev->idle;\n+    diff.wait = update->wait - prev->wait;\n@@ -358,2 +171,2 @@\n-static int SCANF_ARGS(1, 2) parse_stat(_SCANFMT_ const char* fmt, ...) {\n-  return OS_ERR;\n+    *load = 1.0 - diff.idle\/(diff.sys + diff.user + diff.idle + diff.wait);\n+  }\n@@ -362,3 +175,8 @@\n-static int get_noof_context_switches(uint64_t* switches) {\n-  return parse_stat(\"ctxt \" UINT64_FORMAT \"\\n\", switches);\n-}\n+\/**\n+ * Look up lcpu names for later re-use.\n+ *\/\n+static bool populate_lcpu_names(int ncpus, perfstat_id_t* lcpu_names) {\n+  ResourceMark rm;\n+  perfstat_cpu_t* all_lcpu_stats;\n+  perfstat_cpu_t* lcpu_stats;\n+  perfstat_id_t   name_holder;\n@@ -366,4 +184,1 @@\n-\/** returns boot time in _seconds_ since epoch *\/\n-static int get_boot_time(uint64_t* time) {\n-  return parse_stat(\"btime \" UINT64_FORMAT \"\\n\", time);\n-}\n+  assert(lcpu_names, \"Names pointer NULL\");\n@@ -371,6 +186,1 @@\n-static int perf_context_switch_rate(double* rate) {\n-  static pthread_mutex_t contextSwitchLock = PTHREAD_MUTEX_INITIALIZER;\n-  static uint64_t      bootTime;\n-  static uint64_t      lastTimeNanos;\n-  static uint64_t      lastSwitches;\n-  static double        lastRate;\n+  strncpy(name_holder.name, FIRST_CPU, IDENTIFIER_LENGTH);\n@@ -378,2 +188,1 @@\n-  uint64_t bt = 0;\n-  int res = 0;\n+  all_lcpu_stats = NEW_RESOURCE_ARRAY(perfstat_cpu_t, ncpus);\n@@ -381,7 +190,3 @@\n-  \/\/ First time through bootTime will be zero.\n-  if (bootTime == 0) {\n-    uint64_t tmp;\n-    if (get_boot_time(&tmp) < 0) {\n-      return OS_ERR;\n-    }\n-    bt = tmp * 1000;\n+  \/\/ If perfstat_cpu does not return the expected number of names, signal error to caller\n+  if (ncpus != libperfstat::perfstat_cpu(&name_holder, all_lcpu_stats, sizeof(perfstat_cpu_t), ncpus)) {\n+    return false;\n@@ -390,1 +195,3 @@\n-  res = OS_OK;\n+  for (int n = 0; n < ncpus; n++) {\n+    strncpy(lcpu_names[n].name, all_lcpu_stats[n].name, IDENTIFIER_LENGTH);\n+  }\n@@ -392,2 +199,2 @@\n-  pthread_mutex_lock(&contextSwitchLock);\n-  {\n+  return true;\n+}\n@@ -395,2 +202,6 @@\n-    uint64_t sw;\n-    s8 t, d;\n+\/**\n+ * Calculates the context switch rate.\n+ * (Context Switches \/ Tick) * (Tick \/ s) = Context Switches per second\n+ *\/\n+static OSReturn perf_context_switch_rate(double* rate) {\n+  static clock_t ticks_per_sec = sysconf(_SC_CLK_TCK);\n@@ -398,13 +209,2 @@\n-    if (bootTime == 0) {\n-      \/\/ First interval is measured from boot time which is\n-      \/\/ seconds since the epoch. Thereafter we measure the\n-      \/\/ elapsed time using javaTimeNanos as it is monotonic-\n-      \/\/ non-decreasing.\n-      lastTimeNanos = os::javaTimeNanos();\n-      t = os::javaTimeMillis();\n-      d = t - bt;\n-      \/\/ keep bootTime zero for now to use as a first-time-through flag\n-    } else {\n-      t = os::javaTimeNanos();\n-      d = nanos_to_millis(t - lastTimeNanos);\n-    }\n+  u_longlong_t ticks;\n+  perfstat_cpu_total_t cpu_stats;\n@@ -412,17 +212,3 @@\n-    if (d == 0) {\n-      *rate = lastRate;\n-    } else if (get_noof_context_switches(&sw) == 0) {\n-      *rate      = ( (double)(sw - lastSwitches) \/ d ) * 1000;\n-      lastRate     = *rate;\n-      lastSwitches = sw;\n-      if (bootTime != 0) {\n-        lastTimeNanos = t;\n-      }\n-    } else {\n-      *rate = 0;\n-      res   = OS_ERR;\n-    }\n-    if (*rate <= 0) {\n-      *rate = 0;\n-      lastRate = 0;\n-    }\n+   if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+     return OS_ERR;\n+   }\n@@ -430,5 +216,2 @@\n-    if (bootTime == 0) {\n-      bootTime = bt;\n-    }\n-  }\n-  pthread_mutex_unlock(&contextSwitchLock);\n+   ticks = cpu_stats.user + cpu_stats.sys + cpu_stats.idle + cpu_stats.wait;\n+   *rate = (cpu_stats.pswitch \/ ticks) * ticks_per_sec;\n@@ -436,1 +219,1 @@\n-  return res;\n+   return OS_OK;\n@@ -440,1 +223,0 @@\n-  friend class CPUPerformanceInterface;\n@@ -442,6 +224,3 @@\n-  CPUPerfCounters _counters;\n-\n-  int cpu_load(int which_logical_cpu, double* cpu_load);\n-  int context_switch_rate(double* rate);\n-  int cpu_load_total_process(double* cpu_load);\n-  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n+  int _ncpus;\n+  perfstat_id_t* _lcpu_names;\n+  cpu_tick_store_t* _prev_ticks;\n@@ -453,0 +232,5 @@\n+\n+  int cpu_load(int which_logical_cpu, double* cpu_load);\n+  int context_switch_rate(double* rate);\n+  int cpu_load_total_process(double* cpu_load);\n+  int cpu_loads_process(double* pjvmUserLoad, double* pjvmKernelLoad, double* psystemTotalLoad);\n@@ -455,4 +239,4 @@\n-CPUPerformanceInterface::CPUPerformance::CPUPerformance() {\n-  _counters.nProcs = os::active_processor_count();\n-  _counters.cpus = NULL;\n-}\n+CPUPerformanceInterface::CPUPerformance::CPUPerformance():\n+  _ncpus(0),\n+  _lcpu_names(NULL),\n+  _prev_ticks(NULL) {}\n@@ -461,3 +245,1 @@\n-  size_t array_entry_count = _counters.nProcs + 1;\n-  _counters.cpus = NEW_C_HEAP_ARRAY(CPUPerfTicks, array_entry_count, mtInternal);\n-  memset(_counters.cpus, 0, array_entry_count * sizeof(*_counters.cpus));\n+  perfstat_cpu_total_t cpu_stats;\n@@ -465,6 +247,5 @@\n-  \/\/ For the CPU load total\n-  get_total_ticks(-1, &_counters.cpus[_counters.nProcs]);\n-\n-  \/\/ For each CPU\n-  for (int i = 0; i < _counters.nProcs; i++) {\n-    get_total_ticks(i, &_counters.cpus[i]);\n+  if (libperfstat::perfstat_cpu_total(NULL, &cpu_stats, sizeof(perfstat_cpu_total_t), 1) < 0) {\n+    return false;\n+  }\n+  if (cpu_stats.ncpus <= 0) {\n+    return false;\n@@ -472,2 +253,0 @@\n-  \/\/ For JVM load\n-  get_jvm_ticks(&_counters.jvmTicks);\n@@ -475,4 +254,10 @@\n-  \/\/ initialize context switch system\n-  \/\/ the double is only for init\n-  double init_ctx_switch_rate;\n-  perf_context_switch_rate(&init_ctx_switch_rate);\n+  _ncpus = cpu_stats.ncpus;\n+  _lcpu_names = NEW_C_HEAP_ARRAY(perfstat_id_t, _ncpus, mtInternal);\n+\n+  _prev_ticks = NEW_C_HEAP_ARRAY(cpu_tick_store_t, _ncpus, mtInternal);\n+  \/\/ Set all prev-tick values to 0\n+  memset(_prev_ticks, 0, _ncpus*sizeof(cpu_tick_store_t));\n+\n+  if (!populate_lcpu_names(_ncpus, _lcpu_names)) {\n+    return false;\n+  }\n@@ -484,2 +269,5 @@\n-  if (_counters.cpus != NULL) {\n-    FREE_C_HEAP_ARRAY(char, _counters.cpus);\n+  if (_lcpu_names) {\n+    FREE_C_HEAP_ARRAY(perfstat_id_t, _lcpu_names);\n+  }\n+  if (_prev_ticks) {\n+    FREE_C_HEAP_ARRAY(cpu_tick_store_t, _prev_ticks);\n@@ -489,5 +277,11 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load(int which_logical_cpu, double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(which_logical_cpu, &_counters, &s, CPU_LOAD_GLOBAL);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n+\/**\n+ * Get CPU load for all processes on specified logical CPU.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load(int lcpu_number, double* lcpu_load) {\n+  cpu_tick_store_t ticks;\n+\n+  assert(lcpu_load != NULL, \"NULL pointer passed to cpu_load\");\n+  assert(lcpu_number < _ncpus, \"Invalid lcpu passed to cpu_load\");\n+\n+  if (get_lcpu_ticks(&_lcpu_names[lcpu_number], &ticks) == OS_ERR) {\n+    *lcpu_load = -1.0;\n@@ -496,2 +290,4 @@\n-  \/\/ Cap total systemload to 1.0\n-  *cpu_load = MIN2<double>((u + s), 1.0);\n+\n+  calculate_updated_load(&ticks, &_prev_ticks[lcpu_number], lcpu_load);\n+  update_prev_ticks(&ticks, &_prev_ticks[lcpu_number]);\n+\n@@ -501,6 +297,31 @@\n-int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* cpu_load) {\n-  double u, s;\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *cpu_load = 0.0;\n-    return OS_ERR;\n+\/**\n+ * Get CPU load for all processes on all CPUs.\n+ *\/\n+int CPUPerformanceInterface::CPUPerformance::cpu_load_total_process(double* total_load) {\n+  cpu_tick_store_t total_ticks;\n+  cpu_tick_store_t prev_total_ticks;\n+\n+  assert(total_load != NULL, \"NULL pointer passed to cpu_load_total_process\");\n+\n+  memset(&total_ticks, 0, sizeof(cpu_tick_store_t));\n+  memset(&prev_total_ticks, 0, sizeof(cpu_tick_store_t));\n+\n+  for (int lcpu = 0; lcpu < _ncpus; lcpu++) {\n+    cpu_tick_store_t lcpu_ticks;\n+\n+    if (get_lcpu_ticks(&_lcpu_names[lcpu], &lcpu_ticks) == OS_ERR) {\n+      *total_load = -1.0;\n+      return OS_ERR;\n+    }\n+\n+    total_ticks.user = lcpu_ticks.user;\n+    total_ticks.sys  = lcpu_ticks.sys;\n+    total_ticks.idle = lcpu_ticks.idle;\n+    total_ticks.wait = lcpu_ticks.wait;\n+\n+    prev_total_ticks.user += _prev_ticks[lcpu].user;\n+    prev_total_ticks.sys  += _prev_ticks[lcpu].sys;\n+    prev_total_ticks.idle += _prev_ticks[lcpu].idle;\n+    prev_total_ticks.wait += _prev_ticks[lcpu].wait;\n+\n+    update_prev_ticks(&lcpu_ticks, &_prev_ticks[lcpu]);\n@@ -508,1 +329,3 @@\n-  *cpu_load = u + s;\n+\n+  calculate_updated_load(&total_ticks, &prev_total_ticks, total_load);\n+\n@@ -512,0 +335,11 @@\n+\/**\n+ * Get CPU load for all CPUs.\n+ *\n+ * Set values for:\n+ * - pjvmUserLoad:     CPU load due to jvm process in user mode. Jvm process assumed to be self process\n+ * - pjvmKernelLoad:   CPU load due to jvm process in kernel mode. Jvm process assumed to be self process\n+ * - psystemTotalLoad: Total CPU load from all process on all logical CPUs\n+ *\n+ * Note: If any of the above loads cannot be calculated, this procedure returns OS_ERR and any load that could not be calculated is set to -1\n+ *\n+ *\/\n@@ -513,1 +347,1 @@\n-  double u, s, t;\n+  double u, k, t;\n@@ -515,10 +349,3 @@\n-  assert(pjvmUserLoad != NULL, \"pjvmUserLoad not inited\");\n-  assert(pjvmKernelLoad != NULL, \"pjvmKernelLoad not inited\");\n-  assert(psystemTotalLoad != NULL, \"psystemTotalLoad not inited\");\n-\n-  u = get_cpu_load(-1, &_counters, &s, CPU_LOAD_VM_ONLY);\n-  if (u < 0) {\n-    *pjvmUserLoad = 0.0;\n-    *pjvmKernelLoad = 0.0;\n-    *psystemTotalLoad = 0.0;\n-    return OS_ERR;\n+  int retval = OS_OK;\n+  if (get_jvm_load(&u, &k) == OS_ERR || cpu_load_total_process(&t) == OS_ERR) {\n+    retval = OS_ERR;\n@@ -527,4 +354,8 @@\n-  cpu_load(-1, &t);\n-  \/\/ clamp at user+system and 1.0\n-  if (u + s > t) {\n-    t = MIN2<double>(u + s, 1.0);\n+  if (pjvmUserLoad) {\n+    *pjvmUserLoad = u;\n+  }\n+  if (pjvmKernelLoad) {\n+    *pjvmKernelLoad = k;\n+  }\n+  if (psystemTotalLoad) {\n+    *psystemTotalLoad = t;\n@@ -533,5 +364,1 @@\n-  *pjvmUserLoad = u;\n-  *pjvmKernelLoad = s;\n-  *psystemTotalLoad = t;\n-\n-  return OS_OK;\n+  return retval;\n@@ -576,30 +403,4 @@\n-  friend class SystemProcessInterface;\n- private:\n-  class ProcessIterator : public CHeapObj<mtInternal> {\n-    friend class SystemProcessInterface::SystemProcesses;\n-   private:\n-    DIR*           _dir;\n-    struct dirent* _entry;\n-    bool           _valid;\n-    char           _exeName[PATH_MAX];\n-    char           _exePath[PATH_MAX];\n-\n-    ProcessIterator();\n-    ~ProcessIterator();\n-    bool initialize();\n-\n-    bool is_valid() const { return _valid; }\n-    bool is_valid_entry(struct dirent* entry) const;\n-    bool is_dir(const char* name) const;\n-    int  fsize(const char* name, uint64_t& size) const;\n-\n-    char* allocate_string(const char* str) const;\n-    void  get_exe_name();\n-    char* get_exe_path();\n-    char* get_cmdline();\n-\n-    int current(SystemProcess* process_info);\n-    int next_process();\n-  };\n-\n-  ProcessIterator* _iterator;\n+  private:\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -609,2 +410,0 @@\n-\n-  \/\/information about system processes\n@@ -614,69 +413,1 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_dir(const char* name) const {\n-  struct stat mystat;\n-  int ret_val = 0;\n-\n-  ret_val = stat(name, &mystat);\n-  if (ret_val < 0) {\n-    return false;\n-  }\n-  ret_val = S_ISDIR(mystat.st_mode);\n-  return ret_val > 0;\n-}\n-\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::fsize(const char* name, uint64_t& size) const {\n-  assert(name != NULL, \"name pointer is NULL!\");\n-  size = 0;\n-  struct stat fbuf;\n-\n-  if (stat(name, &fbuf) < 0) {\n-    return OS_ERR;\n-  }\n-  size = fbuf.st_size;\n-  return OS_OK;\n-}\n-\n-\/\/ if it has a numeric name, is a directory and has a 'stat' file in it\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::is_valid_entry(struct dirent* entry) const {\n-  char buffer[PATH_MAX];\n-  uint64_t size = 0;\n-\n-  if (atoi(entry->d_name) != 0) {\n-    jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\", entry->d_name);\n-    buffer[PATH_MAX - 1] = '\\0';\n-\n-    if (is_dir(buffer)) {\n-      jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", entry->d_name);\n-      buffer[PATH_MAX - 1] = '\\0';\n-      if (fsize(buffer, size) != OS_ERR) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ get exe-name from \/proc\/<pid>\/stat\n-void SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_name() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/stat\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n-    if (fgets(buffer, PATH_MAX, fp) != NULL) {\n-      char* start, *end;\n-      \/\/ exe-name is between the first pair of ( and )\n-      start = strchr(buffer, '(');\n-      if (start != NULL && start[1] != '\\0') {\n-        start++;\n-        end = strrchr(start, ')');\n-        if (end != NULL) {\n-          size_t len;\n-          len = MIN2<size_t>(end - start, sizeof(_exeName) - 1);\n-          memcpy(_exeName, start, len);\n-          _exeName[len] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n+SystemProcessInterface::SystemProcesses::SystemProcesses() {\n@@ -685,35 +416,2 @@\n-\/\/ get command line from \/proc\/<pid>\/cmdline\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_cmdline() {\n-  FILE* fp;\n-  char  buffer[PATH_MAX];\n-  char* cmdline = NULL;\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/cmdline\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  if ((fp = os::fopen(buffer, \"r\")) != NULL) {\n-    size_t size = 0;\n-    char   dummy;\n-\n-    \/\/ find out how long the file is (stat always returns 0)\n-    while (fread(&dummy, 1, 1, fp) == 1) {\n-      size++;\n-    }\n-    if (size > 0) {\n-      cmdline = NEW_C_HEAP_ARRAY(char, size + 1, mtInternal);\n-      cmdline[0] = '\\0';\n-      if (fseek(fp, 0, SEEK_SET) == 0) {\n-        if (fread(cmdline, 1, size, fp) == size) {\n-          \/\/ the file has the arguments separated by '\\0',\n-          \/\/ so we translate '\\0' to ' '\n-          for (size_t i = 0; i < size; i++) {\n-            if (cmdline[i] == '\\0') {\n-              cmdline[i] = ' ';\n-            }\n-          }\n-          cmdline[size] = '\\0';\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-  return cmdline;\n+bool SystemProcessInterface::SystemProcesses::initialize() {\n+  return true;\n@@ -722,7 +420,1 @@\n-\/\/ get full path to exe from \/proc\/<pid>\/exe symlink\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::get_exe_path() {\n-  char buffer[PATH_MAX];\n-\n-  jio_snprintf(buffer, PATH_MAX, \"\/proc\/%s\/exe\", _entry->d_name);\n-  buffer[PATH_MAX - 1] = '\\0';\n-  return realpath(buffer, _exePath);\n+SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n@@ -731,1 +423,1 @@\n-char* SystemProcessInterface::SystemProcesses::ProcessIterator::allocate_string(const char* str) const {\n+char* SystemProcessInterface::SystemProcesses::allocate_string(const char* str) const {\n@@ -738,9 +430,6 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::current(SystemProcess* process_info) {\n-  if (!is_valid()) {\n-    return OS_ERR;\n-  }\n-\n-  process_info->set_pid(atoi(_entry->d_name));\n-\n-  get_exe_name();\n-  process_info->set_name(allocate_string(_exeName));\n+int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* nprocs) const {\n+  ResourceMark rm;\n+  perfstat_process_t* proc_stats;\n+  SystemProcess* head;\n+  perfstat_id_t name_holder;\n+  int records_allocated = 0;\n@@ -748,10 +437,1 @@\n-  if (get_exe_path() != NULL) {\n-     process_info->set_path(allocate_string(_exePath));\n-  }\n-\n-  char* cmdline = NULL;\n-  cmdline = get_cmdline();\n-  if (cmdline != NULL) {\n-    process_info->set_command_line(allocate_string(cmdline));\n-    FREE_C_HEAP_ARRAY(char, cmdline);\n-  }\n+  assert(nprocs != NULL, \"system_processes counter pointers is NULL!\");\n@@ -759,2 +439,3 @@\n-  return OS_OK;\n-}\n+  head = NULL;\n+  *nprocs = 0;\n+  strncpy(name_holder.name, \"\", IDENTIFIER_LENGTH);\n@@ -762,2 +443,4 @@\n-int SystemProcessInterface::SystemProcesses::ProcessIterator::next_process() {\n-  if (!is_valid()) {\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  *nprocs = libperfstat::perfstat_process(NULL, NULL, sizeof(perfstat_process_t), 0);\n+  if(*nprocs < 1) {\n+    \/\/ expect at least 1 process\n@@ -767,18 +450,2 @@\n-  do {\n-    _entry = os::readdir(_dir);\n-    if (_entry == NULL) {\n-      \/\/ Error or reached end.  Could use errno to distinguish those cases.\n-      _valid = false;\n-      return OS_ERR;\n-    }\n-  } while(!is_valid_entry(_entry));\n-\n-  _valid = true;\n-  return OS_OK;\n-}\n-\n-SystemProcessInterface::SystemProcesses::ProcessIterator::ProcessIterator() {\n-  _dir = NULL;\n-  _entry = NULL;\n-  _valid = false;\n-}\n+  records_allocated = *nprocs;\n+  proc_stats = NEW_RESOURCE_ARRAY(perfstat_process_t, records_allocated);\n@@ -786,4 +453,3 @@\n-bool SystemProcessInterface::SystemProcesses::ProcessIterator::initialize() {\n-  \/\/ Not yet implemented.\n-  return false;\n-}\n+  \/\/ populate stats && set the actual number of procs that have been populated\n+  \/\/ should never be higher than requested, but may be lower due to process death\n+  *nprocs = libperfstat::perfstat_process(&name_holder, proc_stats, sizeof(perfstat_process_t), records_allocated);\n@@ -791,5 +457,6 @@\n-SystemProcessInterface::SystemProcesses::ProcessIterator::~ProcessIterator() {\n-  if (_dir != NULL) {\n-    os::closedir(_dir);\n-  }\n-}\n+  for (int n = 0; n < *nprocs; n++) {\n+    psinfo_t psinfo;\n+    \/\/ Note: SystemProcess with free these in its dtor.\n+    char* name     = NEW_C_HEAP_ARRAY(char, IDENTIFIER_LENGTH, mtInternal);\n+    char* exe_name = NEW_C_HEAP_ARRAY(char, PRFNSZ, mtInternal);\n+    char* cmd_line = NEW_C_HEAP_ARRAY(char, PRARGSZ, mtInternal);\n@@ -797,3 +464,1 @@\n-SystemProcessInterface::SystemProcesses::SystemProcesses() {\n-  _iterator = NULL;\n-}\n+    strncpy(name, proc_stats[n].proc_name, IDENTIFIER_LENGTH);\n@@ -801,4 +466,4 @@\n-bool SystemProcessInterface::SystemProcesses::initialize() {\n-  _iterator = new SystemProcessInterface::SystemProcesses::ProcessIterator();\n-  return _iterator->initialize();\n-}\n+    if (read_psinfo(proc_stats[n].pid, psinfo)) {\n+      strncpy(exe_name, psinfo.pr_fname, PRFNSZ);\n+      strncpy(cmd_line, psinfo.pr_psargs, PRARGSZ);\n+    }\n@@ -806,3 +471,8 @@\n-SystemProcessInterface::SystemProcesses::~SystemProcesses() {\n-  if (_iterator != NULL) {\n-    delete _iterator;\n+    \/\/ create a new SystemProcess with next pointing to current head.\n+    SystemProcess* sp = new SystemProcess(proc_stats[n].pid,\n+                                          name,\n+                                          exe_name,\n+                                          cmd_line,\n+                                          head);\n+    \/\/ update head.\n+    head = sp;\n@@ -810,10 +480,0 @@\n-}\n-\n-int SystemProcessInterface::SystemProcesses::system_processes(SystemProcess** system_processes, int* no_of_sys_processes) const {\n-  assert(system_processes != NULL, \"system_processes pointer is NULL!\");\n-  assert(no_of_sys_processes != NULL, \"system_processes counter pointers is NULL!\");\n-  assert(_iterator != NULL, \"iterator is NULL!\");\n-\n-  \/\/ initialize pointers\n-  *no_of_sys_processes = 0;\n-  *system_processes = NULL;\n@@ -821,16 +481,1 @@\n-  while (_iterator->is_valid()) {\n-    SystemProcess* tmp = new SystemProcess();\n-    _iterator->current(tmp);\n-\n-    \/\/if already existing head\n-    if (*system_processes != NULL) {\n-      \/\/move \"first to second\"\n-      tmp->set_next(*system_processes);\n-    }\n-    \/\/ new head\n-    *system_processes = tmp;\n-    \/\/ increment\n-    (*no_of_sys_processes)++;\n-    \/\/ step forward\n-    _iterator->next_process();\n-  }\n+  *system_processes = head;\n@@ -900,1 +545,2 @@\n-  friend class NetworkPerformanceInterface;\n+  NONCOPYABLE(NetworkPerformance);\n+\n@@ -902,0 +548,3 @@\n+  char* allocate_string(const char* str) const;\n+\n+  public:\n@@ -903,1 +552,0 @@\n-  NONCOPYABLE(NetworkPerformance);\n@@ -909,3 +557,1 @@\n-NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {\n-\n-}\n+NetworkPerformanceInterface::NetworkPerformance::NetworkPerformance() {}\n@@ -917,2 +563,17 @@\n-NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {\n-}\n+NetworkPerformanceInterface::NetworkPerformance::~NetworkPerformance() {}\n+\n+int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const {\n+  int n_records = 0;\n+  perfstat_netinterface_t* net_stats;\n+  perfstat_id_t name_holder;\n+  int records_allocated = 0;\n+\n+  assert(network_interfaces != NULL, \"network_interfaces is NULL\");\n+\n+  *network_interfaces = NULL;\n+  strncpy(name_holder.name , FIRST_NETINTERFACE, IDENTIFIER_LENGTH);\n+\n+  \/\/ calling perfstat_<subsystem>(NULL, NULL, _, 0) returns number of available records\n+  if ((n_records = libperfstat::perfstat_netinterface(NULL, NULL, sizeof(perfstat_netinterface_t), 0)) < 0) {\n+    return OS_ERR;\n+  }\n@@ -920,3 +581,26 @@\n-int NetworkPerformanceInterface::NetworkPerformance::network_utilization(NetworkInterface** network_interfaces) const\n-{\n-  return FUNCTIONALITY_NOT_IMPLEMENTED;\n+  records_allocated = n_records;\n+  net_stats = NEW_C_HEAP_ARRAY(perfstat_netinterface_t, records_allocated, mtInternal);\n+\n+  n_records = libperfstat::perfstat_netinterface(&name_holder, net_stats, sizeof(perfstat_netinterface_t), n_records);\n+\n+  \/\/ check for error\n+  if (n_records < 0) {\n+    FREE_C_HEAP_ARRAY(perfstat_netinterface_t, net_stats);\n+    return OS_ERR;\n+  }\n+\n+  for (int i = 0; i < n_records; i++) {\n+    \/\/ Create new Network interface *with current head as next node*\n+    \/\/ Note: NetworkInterface makes copies of these string values into RA memory\n+    \/\/ this means:\n+    \/\/ (1) we are free to clean our values upon exiting this proc\n+    \/\/ (2) we avoid using RA-alloced memory here (ie. do not use NEW_RESOURCE_ARRAY)\n+    NetworkInterface* new_interface = new NetworkInterface(net_stats[i].name,\n+                                                           net_stats[i].ibytes,\n+                                                           net_stats[i].obytes,\n+                                                           *network_interfaces);\n+    *network_interfaces = new_interface;\n+  }\n+\n+  FREE_C_HEAP_ARRAY(perfstat_netinterface_t, net_stats);\n+  return OS_OK;\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":333,"deletions":649,"binary":false,"changes":982,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2022, IBM Corp.\n@@ -27,0 +28,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -37,0 +39,2 @@\n+  \/\/ Assume spill slot for link register contains a suitable pc.\n+  \/\/ Should have been filled by method entry code.\n@@ -44,4 +48,60 @@\n-  ucontext_t* uc = (ucontext_t*) ucontext;\n-  *fr_addr = frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/],\n-                   (address)uc->uc_mcontext.jmp_context.iar);\n-  return true;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than ucontext info.\n+  if (has_last_Java_frame() && frame_anchor()->walkable()) {\n+    *fr_addr = pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+    address pc = (address)uc->uc_mcontext.jmp_context.iar;\n+\n+    if (pc == NULL) {\n+      \/\/ ucontext wasn't useful\n+      return false;\n+    }\n+\n+    frame ret_frame((intptr_t*)uc->uc_mcontext.jmp_context.gpr[1\/*REG_SP*\/], pc);\n+\n+    if (ret_frame.fp() == NULL) {\n+      \/\/ The found frame does not have a valid frame pointer.\n+      \/\/ Bail out because this will create big trouble later on, either\n+      \/\/  - when using istate, calculated as (NULL - ijava_state_size) or\n+      \/\/  - when using fp() directly in safe_for_sender()\n+      \/\/\n+      \/\/ There is no conclusive description (yet) how this could happen, but it does.\n+      \/\/ For more details on what was observed, see thread_linux_s390.cpp\n+      return false;\n+    }\n+\n+    if (ret_frame.is_interpreted_frame()) {\n+      frame::ijava_state *istate = ret_frame.get_ijava_state();\n+      const Method *m = (const Method*)(istate->method);\n+      if (!Method::is_valid_method(m)) return false;\n+      if (!Metaspace::contains(m->constMethod())) return false;\n+\n+      uint64_t reg_bcp = uc->uc_mcontext.jmp_context.gpr[14\/*R14_bcp*\/];\n+      uint64_t istate_bcp = istate->bcp;\n+      uint64_t code_start = (uint64_t)(m->code_base());\n+      uint64_t code_end = (uint64_t)(m->code_base() + m->code_size());\n+      if (istate_bcp >= code_start && istate_bcp < code_end) {\n+        \/\/ we have a valid bcp, don't touch it, do nothing\n+      } else if (reg_bcp >= code_start && reg_bcp < code_end) {\n+        istate->bcp = reg_bcp;\n+      } else {\n+        return false;\n+      }\n+    }\n+    if (!ret_frame.safe_for_sender(this)) {\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+  \/\/ nothing else to try\n+  return false;\n@@ -50,1 +110,1 @@\n-\/\/ Forte Analyzer AsyncGetCallTrace profiling support is not implemented on Aix\/PPC.\n+\/\/ Forte Analyzer AsyncGetCallTrace profiling support.\n@@ -52,2 +112,1 @@\n-  Unimplemented();\n-  return false;\n+  return pd_get_top_frame_for_profiling(fr_addr, ucontext, isInJava);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/thread_aix_ppc.cpp","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 generic-all\n+jdk\/jfr\/event\/runtime\/TestNetworkUtilizationEvent.java          8228990 macosx-all,linux-all,windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,2 @@\n+        } else if (Platform.isAix()) {\n+            libTemplate = \"lib%s.so\";\n@@ -81,0 +83,1 @@\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestNativeLibrariesEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}