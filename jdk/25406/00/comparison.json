{"files":[{"patch":"@@ -60,7 +60,0 @@\n-void G1BiasedMappedArrayBase::verify_biased_index_inclusive_end(idx_t biased_index) const {\n-  guarantee(_biased_base != nullptr, \"Array not initialized\");\n-  guarantee(biased_index >= bias() && biased_index <= (bias() + length()),\n-            \"Biased index out of inclusive bounds, index: %zu bias: %zu length: %zu\",\n-            biased_index, bias(), length());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,13 +41,0 @@\n-public:\n-  typedef size_t idx_t;\n-\n-protected:\n-  address _base;          \/\/ the real base address\n-  size_t _length;         \/\/ the length of the array\n-  address _biased_base;   \/\/ base address biased by \"bias\" elements\n-  size_t _bias;           \/\/ the bias, i.e. the offset biased_base is located to the right in elements\n-  uint _shift_by;         \/\/ the amount of bits to shift right when mapping to an index of the array.\n-\n-protected:\n-  G1BiasedMappedArrayBase();\n-\n@@ -70,0 +57,12 @@\n+public:\n+  typedef size_t idx_t;\n+\n+protected:\n+  address _base;          \/\/ the real base address\n+  size_t _length;         \/\/ the length of the array\n+  address _biased_base;   \/\/ base address biased by \"bias\" elements\n+  size_t _bias;           \/\/ the bias, i.e. the offset biased_base is located to the right in elements\n+  uint _shift_by;         \/\/ the amount of bits to shift right when mapping to an index of the array.\n+\n+  G1BiasedMappedArrayBase();\n+\n@@ -93,1 +92,0 @@\n-  void verify_biased_index_inclusive_end(idx_t biased_index) const PRODUCT_RETURN;\n@@ -106,0 +104,6 @@\n+\n+  T* base() const { return (T*)G1BiasedMappedArrayBase::_base; }\n+\n+  \/\/ The raw biased base pointer.\n+  T* biased_base() const { return (T*)G1BiasedMappedArrayBase::_biased_base; }\n+\n@@ -109,1 +113,0 @@\n-  T* base() const { return (T*)G1BiasedMappedArrayBase::_base; }\n@@ -126,3 +129,0 @@\n-  \/\/ The raw biased base pointer.\n-  T* biased_base() const { return (T*)G1BiasedMappedArrayBase::_biased_base; }\n-\n@@ -157,21 +157,0 @@\n-  \/\/ Set the value of all array entries that correspond to addresses\n-  \/\/ in the specified MemRegion.\n-  void set_by_address(MemRegion range, T value) {\n-    idx_t biased_start = ((uintptr_t)range.start()) >> this->shift_by();\n-    idx_t biased_last = ((uintptr_t)range.last()) >> this->shift_by();\n-    this->verify_biased_index(biased_start);\n-    this->verify_biased_index(biased_last);\n-    for (idx_t i = biased_start; i <= biased_last; i++) {\n-      biased_base()[i] = value;\n-    }\n-  }\n-\n-protected:\n-  \/\/ Returns the address of the element the given address maps to\n-  T* address_mapped_to(HeapWord* address) {\n-    idx_t biased_index = ((uintptr_t)address) >> this->shift_by();\n-    this->verify_biased_index_inclusive_end(biased_index);\n-    return biased_base() + biased_index;\n-  }\n-\n-public:\n@@ -197,0 +176,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BiasedArray.hpp","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"}]}