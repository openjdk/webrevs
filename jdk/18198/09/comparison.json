{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1829,0 +1812,1 @@\n+\n@@ -1830,0 +1814,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1842,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run main compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmU(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0) & \/\/ assert in inversions to generates the pattern looking for\n+               !(Integer.compareUnsigned((m & x), m) > 0) &\n+               Integer.compareUnsigned((x & m), m + 1) < 0 &\n+               Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"4\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmU(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0) |\n+                !(Integer.compareUnsigned((m & x), m - 1) > 0) |\n+                Integer.compareUnsigned((x & m), m + 2) < 0 |\n+                Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = { 0, 1, 5, 8, 16, 42, 100, Integer.MAX_VALUE };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmU(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}