{"files":[{"patch":"@@ -261,0 +261,15 @@\n+\n+\/\/ If there is an existing ConvI2L node with the given parent and type, return\n+\/\/ it. Otherwise, create and return a new one. Both reusing existing ConvI2L\n+\/\/ nodes and postponing the idealization of new ones are needed to avoid an\n+\/\/ explosion of recursive Ideal() calls when compiling long AddI chains.\n+static Node* find_or_make_convI2L(PhaseIterGVN* igvn, Node* parent,\n+                                  const TypeLong* type) {\n+  Node* n = new ConvI2LNode(parent, type);\n+  Node* existing = igvn->hash_find_insert(n);\n+  if (existing != NULL) {\n+    n->destruct(igvn);\n+    return existing;\n+  }\n+  return igvn->register_new_node_with_optimizer(n);\n+}\n@@ -265,0 +280,1 @@\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n@@ -268,1 +284,1 @@\n-  if (can_reshape) {\n+  if (igvn != NULL) {\n@@ -337,4 +353,3 @@\n-    if (!can_reshape) {\n-      \/\/ Postpone this optimization to after parsing because with deep AddNode\n-      \/\/ chains a large amount of dead ConvI2L nodes might be created that are\n-      \/\/ not removed during parsing. As a result, we might hit the node limit.\n+    if (igvn == NULL) {\n+      \/\/ Postpone this optimization to iterative GVN, where we can handle deep\n+      \/\/ AddI chains without an exponential number of recursive Ideal() calls.\n@@ -402,5 +417,2 @@\n-    Node* cx = phase->C->constrained_convI2L(phase, x, TypeInt::make(rxlo, rxhi, widen), NULL);\n-    Node *hook = new Node(1);\n-    hook->init_req(0, cx);  \/\/ Add a use to cx to prevent him from dying\n-    Node* cy = phase->C->constrained_convI2L(phase, y, TypeInt::make(rylo, ryhi, widen), NULL);\n-    hook->destruct(phase);\n+    Node* cx = find_or_make_convI2L(igvn, x, TypeLong::make(rxlo, rxhi, widen));\n+    Node* cy = find_or_make_convI2L(igvn, y, TypeLong::make(rylo, ryhi, widen));\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.conversions;\n+\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8254317\n+ * @requires vm.compiler2.enabled\n+ * @summary Exercises the optimization that moves integer-to-long conversions\n+ *          upwards through different shapes of integer addition\n+ *          subgraphs. Contains three small functional tests and two stress\n+ *          tests that resulted in a compilation time and memory explosion\n+ *          before fixing bug 8254317. The stress tests run with -Xbatch to wait\n+ *          for C2, so that a timeout or an out-of-memory error is triggered if\n+ *          there was an explosion. These tests use a timeout of 30s to catch\n+ *          the explosion earlier.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs functional\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs stress1\n+ * @run main\/othervm\/timeout=30 -Xbatch\n+ *      compiler.conversions.TestMoveConvI2LThroughAddIs stress2\n+ *\/\n+\n+public class TestMoveConvI2LThroughAddIs {\n+\n+    \/\/ Number of repetitions of each test. Should be sufficiently large for the\n+    \/\/ method under test to be compiled with C2.\n+    static final int N = 100_000;\n+\n+    \/\/ Chain-shaped functional test.\n+    static long testChain(boolean cnd) {\n+        int a = cnd ? 1 : 2;\n+        int b = a + a;\n+        int c = b + b;\n+        int d = c + c;\n+        return d;\n+    }\n+\n+    \/\/ Tree-shaped functional test.\n+    static long testTree(boolean cnd) {\n+        int a0 = cnd ? 1 : 2;\n+        int a1 = cnd ? 1 : 2;\n+        int a2 = cnd ? 1 : 2;\n+        int a3 = cnd ? 1 : 2;\n+        int a4 = cnd ? 1 : 2;\n+        int a5 = cnd ? 1 : 2;\n+        int a6 = cnd ? 1 : 2;\n+        int a7 = cnd ? 1 : 2;\n+        int b0 = a0 + a1;\n+        int b1 = a2 + a3;\n+        int b2 = a4 + a5;\n+        int b3 = a6 + a7;\n+        int c0 = b0 + b1;\n+        int c1 = b2 + b3;\n+        int d = c0 + c1;\n+        return d;\n+    }\n+\n+    \/\/ DAG-shaped functional test.\n+    static long testDAG(boolean cnd) {\n+        int a0 = cnd ? 1 : 2;\n+        int a1 = cnd ? 1 : 2;\n+        int a2 = cnd ? 1 : 2;\n+        int a3 = cnd ? 1 : 2;\n+        int b0 = a0 + a1;\n+        int b1 = a1 + a2;\n+        int b2 = a2 + a3;\n+        int c0 = b0 + b1;\n+        int c1 = b1 + b2;\n+        int d = c0 + c1;\n+        return d;\n+    }\n+\n+    \/\/ Chain-shaped stress test. Before fixing bug 8254317, this test would\n+    \/\/ result in an out-of-memory error after minutes running.\n+    static long testStress1(boolean cnd) {\n+        \/\/ C2 infers a finite, small value range for a. Note that there are\n+        \/\/ different ways to achieve this, for example a might take the value of\n+        \/\/ the induction variable in an outer counted loop.\n+        int a = cnd ? 1 : 2;\n+        \/\/ C2 fully unrolls this loop, creating a long chain of AddIs.\n+        for (int i = 0; i < 28; i++) {\n+            a = a + a;\n+        }\n+        \/\/ C2 places a ConvI2L at the end of the AddI chain.\n+        return a;\n+    }\n+\n+    \/\/ DAG-shaped stress test. Before fixing bug 8254317, this test would result\n+    \/\/ in an out-of-memory error after minutes running.\n+    static long testStress2(boolean cnd) {\n+        int a = cnd ? 1 : 2;\n+        int b = a;\n+        int c = a + a;\n+        for (int i = 0; i < 20; i++) {\n+            b = b + c;\n+            c = b + c;\n+        }\n+        int d = b + c;\n+        return d;\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ We use a random number generator to avoid constant propagation in C2\n+        \/\/ and produce a variable (\"a\" in the different tests) with a finite,\n+        \/\/ small value range.\n+        Random rnd = new Random();\n+        switch(args[0]) {\n+        case \"functional\":\n+            \/\/ Small, functional tests.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testChain(cnd), cnd ? 8L : 16L);\n+                Asserts.assertEQ(testTree(cnd), cnd ? 8L : 16L);\n+                Asserts.assertEQ(testDAG(cnd), cnd ? 8L : 16L);\n+            }\n+            break;\n+        case \"stress1\":\n+            \/\/ Chain-shaped stress test.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testStress1(cnd),\n+                                 cnd ? 268435456L : 536870912L);\n+            }\n+            break;\n+        case \"stress2\":\n+            \/\/ DAG-shaped stress test.\n+            for (int i = 0; i < N; i++) {\n+                boolean cnd = rnd.nextBoolean();\n+                Asserts.assertEQ(testStress2(cnd),\n+                                 cnd ? 701408733L : 1402817466L);\n+            }\n+            break;\n+        default:\n+            System.out.println(\"invalid mode\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/conversions\/TestMoveConvI2LThroughAddIs.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}