{"files":[{"patch":"@@ -51,2 +51,6 @@\n-bool VerificationType::resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object, TRAPS) {\n+\/\/ Potentially resolve the target class and from class, and check whether the from class is assignable\n+\/\/ to the target class. The current_klass is the class being verified - it could also be the target in some\n+\/\/ cases, and otherwise is needed to obtain the correct classloader for resolving the other classes.\n+bool VerificationType::resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name, Symbol* from_name,\n+                                                       bool from_field_is_protected, bool from_is_array,\n+                                                       bool from_is_object, bool* target_is_interface, TRAPS) {\n@@ -54,3 +58,3 @@\n-  Klass* this_class;\n-  if (klass->is_hidden() && klass->name() == name) {\n-    this_class = klass;\n+  Klass* target_klass;\n+  if (current_klass->is_hidden() && current_klass->name() == target_name) {\n+    target_klass = current_klass;\n@@ -58,2 +62,2 @@\n-    this_class = SystemDictionary::resolve_or_fail(\n-      name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n+    target_klass = SystemDictionary::resolve_or_fail(\n+      target_name, Handle(THREAD, current_klass->class_loader()), true, CHECK_false);\n@@ -61,1 +65,1 @@\n-      Verifier::trace_class_resolution(this_class, klass);\n+      Verifier::trace_class_resolution(target_klass, current_klass);\n@@ -65,1 +69,6 @@\n-  if (this_class->is_interface() && (!from_field_is_protected ||\n+  bool is_intf = target_klass->is_interface();\n+  if (target_is_interface != nullptr) {\n+    *target_is_interface = is_intf;\n+  }\n+\n+  if (is_intf && (!from_field_is_protected ||\n@@ -72,2 +81,2 @@\n-      this_class == vmClasses::Cloneable_klass() ||\n-      this_class == vmClasses::Serializable_klass();\n+      target_klass == vmClasses::Cloneable_klass() ||\n+      target_klass == vmClasses::Serializable_klass();\n@@ -75,3 +84,3 @@\n-    Klass* from_class;\n-    if (klass->is_hidden() && klass->name() == from_name) {\n-      from_class = klass;\n+    Klass* from_klass;\n+    if (current_klass->is_hidden() && current_klass->name() == from_name) {\n+      from_klass = current_klass;\n@@ -79,2 +88,2 @@\n-      from_class = SystemDictionary::resolve_or_fail(\n-        from_name, Handle(THREAD, klass->class_loader()), true, CHECK_false);\n+      from_klass = SystemDictionary::resolve_or_fail(\n+        from_name, Handle(THREAD, current_klass->class_loader()), true, CHECK_false);\n@@ -82,1 +91,1 @@\n-        Verifier::trace_class_resolution(from_class, klass);\n+        Verifier::trace_class_resolution(from_klass, current_klass);\n@@ -85,1 +94,1 @@\n-    return from_class->is_subclass_of(this_class);\n+    return from_klass->is_subclass_of(target_klass);\n@@ -93,2 +102,2 @@\n-    bool from_field_is_protected, TRAPS) const {\n-  InstanceKlass* klass = context->current_class();\n+    bool from_field_is_protected, bool* this_is_interface, TRAPS) const {\n+\n@@ -112,1 +121,1 @@\n-      SystemDictionaryShared::add_verification_constraint(klass,\n+      SystemDictionaryShared::add_verification_constraint(context->current_class(),\n@@ -122,2 +131,3 @@\n-    return resolve_and_check_assignability(klass, name(), from.name(),\n-          from_field_is_protected, from.is_array(), from.is_object(), THREAD);\n+    return resolve_and_check_assignability(context->current_class(), name(), from.name(),\n+                                           from_field_is_protected, from.is_array(),\n+                                           from.is_object(), this_is_interface, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,1 +291,1 @@\n-                                                THREAD);\n+                                                nullptr, THREAD);\n@@ -330,1 +330,2 @@\n- private:\n+  bool is_reference_assignable_from(const VerificationType& from, ClassVerifier* context,\n+                                    bool from_field_is_protected, bool* this_is_interface, TRAPS) const;\n@@ -332,3 +333,7 @@\n-  bool is_reference_assignable_from(\n-    const VerificationType&, ClassVerifier*, bool from_field_is_protected,\n-    TRAPS) const;\n+  static bool resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name,\n+                                              Symbol* from_name, bool from_field_is_protected,\n+                                              bool from_is_array, bool from_is_object,\n+                                              TRAPS) {\n+    return resolve_and_check_assignability(current_klass, target_name, from_name, from_field_is_protected,\n+                                           from_is_array, from_is_object, nullptr, THREAD);\n+  }\n@@ -336,2 +341,2 @@\n- public:\n-  static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,\n+ private:\n+  static bool resolve_and_check_assignability(InstanceKlass* current_klass, Symbol* target_name,\n@@ -340,0 +345,1 @@\n+                                              bool* target_is_interface,\n@@ -341,0 +347,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2894,14 +2894,23 @@\n-  } else if (opcode == Bytecodes::_invokespecial\n-             && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)\n-             && !ref_class_type.equals(VerificationType::reference_type(\n-                  current_class()->super()->name()))) {\n-    bool subtype = false;\n-    bool have_imr_indirect = cp->tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;\n-    subtype = ref_class_type.is_assignable_from(\n-               current_type(), this, false, CHECK_VERIFY(this));\n-    if (!subtype) {\n-      verify_error(ErrorContext::bad_code(bci),\n-          \"Bad invokespecial instruction: \"\n-          \"current class isn't assignable to reference class.\");\n-       return;\n-    } else if (have_imr_indirect) {\n+  }\n+  \/\/ invokespecial, when not <init>, must be to a method in the current class, a direct superinterface,\n+  \/\/ or any superclass (including Object).\n+  else if (opcode == Bytecodes::_invokespecial\n+           && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)\n+           && !ref_class_type.equals(VerificationType::reference_type(current_class()->super()->name()))) {\n+\n+    \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+    \/\/ could be:\n+    \/\/ - a totally unrelated class or interface\n+    \/\/ - an indirect superinterface\n+    \/\/ - an indirect superclass (including Object)\n+    \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+    \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+    \/\/ implemented as assignability treats all interfaces as Object.\n+\n+    bool is_interface = false; \/\/ This can only be set true if the assignability check will return true\n+                               \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                               \/\/ or Object) we either can't get here (same class already excluded above)\n+                               \/\/ or we know it is not an interface (i.e. Object).\n+    bool subtype = ref_class_type.is_reference_assignable_from(current_type(), this, false,\n+                                                               &is_interface, CHECK_VERIFY(this));\n+    if (!subtype) {  \/\/ Totally unrelated class\n@@ -2909,2 +2918,2 @@\n-          \"Bad invokespecial instruction: \"\n-          \"interface method reference is in an indirect superinterface.\");\n+                   \"Bad invokespecial instruction: \"\n+                   \"current class isn't assignable to reference class.\");\n@@ -2912,0 +2921,9 @@\n+    } else {\n+      \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+      \/\/ Any interface use is an error.\n+      if (is_interface) {\n+        verify_error(ErrorContext::bad_code(bci),\n+                     \"Bad invokespecial instruction: \"\n+                     \"interface method to invoke is not in a direct superinterface.\");\n+        return;\n+      }\n@@ -2913,1 +2931,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1203,1 +1203,1 @@\n-  \/\/ a direct superinterface, not an indirect superinterface\n+  \/\/ a direct superinterface, not an indirect superinterface or unrelated interface\n@@ -1212,1 +1212,1 @@\n-      ss.print(\"', is in an indirect superinterface of %s\",\n+      ss.print(\"', is not in a direct superinterface of %s\",\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,4 +24,5 @@\n-public interface Intf1 {\n-\n-    Object foo(Object bar);\n-\n+\/**\n+ * A class with a run()V method that doesn't implement Runnable.\n+ *\/\n+public class Run {\n+    public void run() { }\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/invokespecial\/Run.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"test\/langtools\/tools\/javac\/8351232\/Intf1.java","status":"copied"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=verified\n+ * @compile Run.java UseMethodRef.jasm UseInterfaceMethodRef.jasm TestInvokeSpecialInterface.java\n+ * @run main\/othervm TestInvokeSpecialInterface true\n+ *\/\n+\n+\/*\n+ * @test id=unverified\n+ * @compile Run.java UseMethodRef.jasm UseInterfaceMethodRef.jasm TestInvokeSpecialInterface.java\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:-BytecodeVerificationRemote TestInvokeSpecialInterface false\n+ *\/\n+\n+public class TestInvokeSpecialInterface {\n+    public static void main(String[] args) throws Throwable {\n+        if (args[0].equals(\"true\")) {\n+            check_verified();\n+        } else {\n+            check_unverified();\n+        }\n+    }\n+\n+    static void check_verified() {\n+        String veMsg = \"interface method to invoke is not in a direct superinterface\";\n+        try {\n+            UseMethodRef t = new UseMethodRef();\n+            UseMethodRef.test(t);\n+        }\n+        catch(VerifyError ve) {\n+            if (ve.getMessage().contains(veMsg)) {\n+                System.out.println(\"Got expected: \" + ve);\n+            } else {\n+                throw new RuntimeException(\"Unexpected VerifyError thrown\", ve);\n+            }\n+        }\n+\n+        try {\n+            UseInterfaceMethodRef t = new UseInterfaceMethodRef();\n+            UseInterfaceMethodRef.test(t);\n+        }\n+        catch(VerifyError ve) {\n+            if (ve.getMessage().contains(veMsg)) {\n+                System.out.println(\"Got expected: \" + ve);\n+            } else {\n+                throw new RuntimeException(\"Unexpected VerifyError thrown\", ve);\n+            }\n+        }\n+    }\n+\n+    static void check_unverified() {\n+        try {\n+            UseMethodRef t = new UseMethodRef();\n+            UseMethodRef.test(t);\n+        }\n+        catch(IncompatibleClassChangeError icce) {\n+            String icceMsg = \"Method 'void java.lang.Runnable.run()' must be InterfaceMethodref constant\";\n+            if (icce.getMessage().contains(icceMsg)) {\n+                System.out.println(\"Got expected: \" + icce);\n+            } else {\n+                throw new RuntimeException(\"Unexpected IncompatibleClassChangeError\", icce);\n+            }\n+        }\n+\n+        try {\n+            UseInterfaceMethodRef t = new UseInterfaceMethodRef();\n+            UseInterfaceMethodRef.test(t);\n+        }\n+        catch(IncompatibleClassChangeError icce) {\n+            String icceMsg = \"Interface method reference: 'void java.lang.Runnable.run()', is not in a direct superinterface of UseInterfaceMethodRef\";\n+            if (icce.getMessage().contains(icceMsg)) {\n+                System.out.println(\"Got expected: \" + icce);\n+            } else {\n+                throw new RuntimeException(\"Unexpected IncompatibleClassChangeError\", icce);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/invokespecial\/TestInvokeSpecialInterface.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class UseInterfaceMethodRef extends Run version 52:0 {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial   Method Run.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method test:\"(LUseInterfaceMethodRef;)V\" stack 2 {\n+        aload_0;\n+        invokespecial InterfaceMethod java\/lang\/Runnable.run:()V; \/\/ VerifyError\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/invokespecial\/UseInterfaceMethodRef.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class UseMethodRef extends Run version 52:0 {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial   Method Run.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method test:\"(LUseMethodRef;)V\" stack 2 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Runnable.run:()V; \/\/ VerifyError\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/invokespecial\/UseMethodRef.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}