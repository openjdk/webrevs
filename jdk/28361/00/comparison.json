{"files":[{"patch":"@@ -1687,2 +1687,2 @@\n-int java_lang_Thread::_jvmti_VTMS_transition_disable_count_offset;\n-int java_lang_Thread::_jvmti_is_in_VTMS_transition_offset;\n+int java_lang_Thread::_VTMS_transition_disable_count_offset;\n+int java_lang_Thread::_is_in_VTMS_transition_offset;\n@@ -1749,1 +1749,2 @@\n-  return java_thread->int_field(_jvmti_VTMS_transition_disable_count_offset);\n+  jint* addr = java_thread->field_addr<jint>(_VTMS_transition_disable_count_offset);\n+  return AtomicAccess::load(addr);\n@@ -1753,3 +1754,4 @@\n-  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n-  int val = VTMS_transition_disable_count(java_thread);\n-  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val + 1);\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  jint* addr = java_thread->field_addr<jint>(_VTMS_transition_disable_count_offset);\n+  int val = AtomicAccess::load(addr);\n+  AtomicAccess::store(addr, val + 1);\n@@ -1759,4 +1761,4 @@\n-  assert(JvmtiVTMSTransition_lock->owned_by_self(), \"Must be locked\");\n-  int val = VTMS_transition_disable_count(java_thread);\n-  assert(val > 0, \"VTMS_transition_disable_count should never be negative\");\n-  java_thread->int_field_put(_jvmti_VTMS_transition_disable_count_offset, val - 1);\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  jint* addr = java_thread->field_addr<jint>(_VTMS_transition_disable_count_offset);\n+  int val = AtomicAccess::load(addr);\n+  AtomicAccess::store(addr, val - 1);\n@@ -1766,1 +1768,2 @@\n-  return java_thread->bool_field_volatile(_jvmti_is_in_VTMS_transition_offset);\n+  jboolean* addr = java_thread->field_addr<jboolean>(_is_in_VTMS_transition_offset);\n+  return AtomicAccess::load(addr);\n@@ -1771,5 +1774,2 @@\n-  java_thread->bool_field_put_volatile(_jvmti_is_in_VTMS_transition_offset, val);\n-}\n-\n-int java_lang_Thread::is_in_VTMS_transition_offset() {\n-  return _jvmti_is_in_VTMS_transition_offset;\n+  jboolean* addr = java_thread->field_addr<jboolean>(_is_in_VTMS_transition_offset);\n+  AtomicAccess::store(addr, (jboolean)val);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -378,2 +378,2 @@\n-  macro(java_lang_Thread, jvmti_VTMS_transition_disable_count, int_signature, false) \\\n-  macro(java_lang_Thread, jvmti_is_in_VTMS_transition, bool_signature, false) \\\n+  macro(java_lang_Thread, VTMS_transition_disable_count, int_signature, false) \\\n+  macro(java_lang_Thread, is_in_VTMS_transition, bool_signature, false) \\\n@@ -393,2 +393,2 @@\n-  static int _jvmti_VTMS_transition_disable_count_offset;\n-  static int _jvmti_is_in_VTMS_transition_offset;\n+  static int _VTMS_transition_disable_count_offset;\n+  static int _is_in_VTMS_transition_offset;\n@@ -447,0 +447,1 @@\n+\n@@ -450,0 +451,2 @@\n+  static int  VTMS_transition_disable_count_offset() { return _VTMS_transition_disable_count_offset; }\n+\n@@ -452,1 +455,1 @@\n-  static int  is_in_VTMS_transition_offset();\n+  static int  is_in_VTMS_transition_offset() { return _is_in_VTMS_transition_offset; }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -652,4 +652,4 @@\n-  do_intrinsic(_notifyJvmtiVThreadStart, java_lang_VirtualThread, notifyJvmtiStart_name, void_method_signature, F_RN)   \\\n-  do_intrinsic(_notifyJvmtiVThreadEnd, java_lang_VirtualThread, notifyJvmtiEnd_name, void_method_signature, F_RN)       \\\n-  do_intrinsic(_notifyJvmtiVThreadMount, java_lang_VirtualThread, notifyJvmtiMount_name, bool_void_signature, F_RN)     \\\n-  do_intrinsic(_notifyJvmtiVThreadUnmount, java_lang_VirtualThread, notifyJvmtiUnmount_name, bool_void_signature, F_RN) \\\n+  do_intrinsic(_vthreadEndFirstTransition, java_lang_VirtualThread, endFirstTransition_name, void_method_signature, F_RN) \\\n+  do_intrinsic(_vthreadStartFinalTransition, java_lang_VirtualThread, startFinalTransition_name, void_method_signature, F_RN) \\\n+  do_intrinsic(_vthreadStartTransition, java_lang_VirtualThread, startTransition_name, bool_void_signature, F_RN)       \\\n+  do_intrinsic(_vthreadEndTransition, java_lang_VirtualThread, endTransition_name, bool_void_signature, F_RN)           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -398,4 +398,4 @@\n-  template(notifyJvmtiStart_name,                     \"notifyJvmtiStart\")                         \\\n-  template(notifyJvmtiEnd_name,                       \"notifyJvmtiEnd\")                           \\\n-  template(notifyJvmtiMount_name,                     \"notifyJvmtiMount\")                         \\\n-  template(notifyJvmtiUnmount_name,                   \"notifyJvmtiUnmount\")                       \\\n+  template(startTransition_name,                      \"startTransition\")                          \\\n+  template(endTransition_name,                        \"endTransition\")                            \\\n+  template(startFinalTransition_name,                 \"startFinalTransition\")                     \\\n+  template(endFirstTransition_name,                   \"endFirstTransition\")                       \\\n@@ -500,2 +500,2 @@\n-  template(jvmti_VTMS_transition_disable_count_name,  \"jvmti_VTMS_transition_disable_count\")      \\\n-  template(jvmti_is_in_VTMS_transition_name,          \"jvmti_is_in_VTMS_transition\")              \\\n+  template(VTMS_transition_disable_count_name,        \"VTMS_transition_disable_count\")            \\\n+  template(is_in_VTMS_transition_name,                \"is_in_VTMS_transition\")                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1349,6 +1349,0 @@\n-#if INCLUDE_JVMTI\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_start);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_end);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_mount);\n-    SET_ADDRESS(_extrs, SharedRuntime::notify_jvmti_vthread_unmount);\n-#endif\n@@ -1361,0 +1355,4 @@\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_start_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_end_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_start_transition_C);\n+    SET_ADDRESS(_extrs, OptoRuntime::vthread_end_transition_C);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1109,1 +1109,1 @@\n-JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide);\n+JVM_VirtualThreadStartTransition(JNIEnv* env, jobject vthread, jboolean is_mount);\n@@ -1112,1 +1112,1 @@\n-JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide);\n+JVM_VirtualThreadEndTransition(JNIEnv* env, jobject vthread, jboolean is_mount);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -262,1 +263,1 @@\n-  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_VTMS_transition,                        bool))                                 \\\n+  nonstatic_field(JavaThread,                  _is_in_VTMS_transition,                        bool)                                  \\\n@@ -268,1 +269,1 @@\n-  JVMTI_ONLY(static_field(JvmtiVTMSTransitionDisabler, _VTMS_notify_jvmti_events,             bool))                                 \\\n+  static_field(MountUnmountDisabler,           _notify_jvmti_events,                          bool)                                  \\\n@@ -438,1 +439,1 @@\n-  static_field(java_lang_Thread,            _jvmti_is_in_VTMS_transition_offset,              int)                                   \\\n+  static_field(java_lang_Thread,            _is_in_VTMS_transition_offset,                    int)                                   \\\n@@ -880,4 +881,0 @@\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_start)) \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_end))   \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_mount)) \\\n-  JVMTI_ONLY(declare_function(SharedRuntime::notify_jvmti_vthread_unmount)) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -862,0 +862,4 @@\n+  case vmIntrinsics::_vthreadEndFirstTransition:\n+  case vmIntrinsics::_vthreadStartFinalTransition:\n+  case vmIntrinsics::_vthreadStartTransition:\n+  case vmIntrinsics::_vthreadEndTransition:\n@@ -863,4 +867,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadStart:\n-  case vmIntrinsics::_notifyJvmtiVThreadEnd:\n-  case vmIntrinsics::_notifyJvmtiVThreadMount:\n-  case vmIntrinsics::_notifyJvmtiVThreadUnmount:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -482,0 +483,8 @@\n+  case vmIntrinsics::_vthreadEndFirstTransition:    return inline_native_vthread_end_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_start_Java()),\n+                                                                                                \"endFirstTransition\", true);\n+  case vmIntrinsics::_vthreadStartFinalTransition:  return inline_native_vthread_start_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_end_Java()),\n+                                                                                                  \"startFinalTransition\", true);\n+  case vmIntrinsics::_vthreadStartTransition:       return inline_native_vthread_start_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_start_transition_Java()),\n+                                                                                                  \"startTransition\", false);\n+  case vmIntrinsics::_vthreadEndTransition:         return inline_native_vthread_end_transition(CAST_FROM_FN_PTR(address, OptoRuntime::vthread_end_transition_Java()),\n+                                                                                                \"endTransition\", false);\n@@ -483,8 +492,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadStart:   return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_start()),\n-                                                                                         \"notifyJvmtiStart\", true, false);\n-  case vmIntrinsics::_notifyJvmtiVThreadEnd:     return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_end()),\n-                                                                                         \"notifyJvmtiEnd\", false, true);\n-  case vmIntrinsics::_notifyJvmtiVThreadMount:   return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_mount()),\n-                                                                                         \"notifyJvmtiMount\", false, false);\n-  case vmIntrinsics::_notifyJvmtiVThreadUnmount: return inline_native_notify_jvmti_funcs(CAST_FROM_FN_PTR(address, OptoRuntime::notify_jvmti_vthread_unmount()),\n-                                                                                         \"notifyJvmtiUnmount\", false, false);\n@@ -3045,0 +3046,3 @@\n+bool LibraryCallKit::inline_native_vthread_start_transition(address funcAddr, const char* funcName, bool is_final_transition) {\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n+  IdealKit ideal(this);\n@@ -3046,7 +3050,20 @@\n-#if INCLUDE_JVMTI\n-\n-\/\/ When notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given function call implementing JVMTI notification protocol.\n-bool LibraryCallKit::inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName, bool is_start, bool is_end) {\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    return true;\n+  Node* thread = ideal.thread();\n+  Node* jt_addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_VTMS_transition_offset()));\n+  Node* vt_addr = basic_plus_adr(vt_oop, java_lang_Thread::is_in_VTMS_transition_offset());\n+  access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), ideal.ConI(1), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+  access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), ideal.ConI(1), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+  insert_mem_bar(Op_MemBarVolatile);\n+  ideal.sync_kit(this);\n+\n+  Node* global_disable_addr = makecon(TypeRawPtr::make((address)MountUnmountDisabler::global_start_transition_disable_count_address()));\n+  Node* global_disable = ideal.load(ideal.ctrl(), global_disable_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, true \/*require_atomic_access*\/);\n+  Node* vt_disable_addr = basic_plus_adr(vt_oop, java_lang_Thread::VTMS_transition_disable_count_offset());\n+  Node* vt_disable = ideal.load(ideal.ctrl(), vt_disable_addr, TypeInt::INT, T_INT, Compile::AliasIdxRaw, true \/*require_atomic_access*\/);\n+  Node* disabled = _gvn.transform(new AddINode(global_disable, vt_disable));\n+\n+  ideal.if_then(disabled, BoolTest::ne, ideal.ConI(0)); {\n+    sync_kit(ideal);\n+    Node* is_mount = is_final_transition ? ideal.ConI(0) : _gvn.transform(argument(1));\n+    const TypeFunc* tf = OptoRuntime::vthread_transition_Type();\n+    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, is_mount);\n+    ideal.sync_kit(this);\n@@ -3054,0 +3071,7 @@\n+  ideal.end_if();\n+\n+  final_sync(ideal);\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_native_vthread_end_transition(address funcAddr, const char* funcName, bool is_first_transition) {\n@@ -3057,4 +3081,2 @@\n-  Node* ONE = ideal.ConI(1);\n-  Node* hide = is_start ? ideal.ConI(0) : (is_end ? ideal.ConI(1) : _gvn.transform(argument(1)));\n-  Node* addr = makecon(TypeRawPtr::make((address)&JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events));\n-  Node* notify_jvmti_enabled = ideal.load(ideal.ctrl(), addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+  Node* _notify_jvmti_addr = makecon(TypeRawPtr::make((address)MountUnmountDisabler::notify_jvmti_events_address()));\n+  Node* _notify_jvmti = ideal.load(ideal.ctrl(), _notify_jvmti_addr, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n@@ -3062,1 +3084,1 @@\n-  ideal.if_then(notify_jvmti_enabled, BoolTest::eq, ONE); {\n+  ideal.if_then(_notify_jvmti, BoolTest::eq, ideal.ConI(1)); {\n@@ -3064,3 +3086,3 @@\n-    \/\/ if notifyJvmti enabled then make a call to the given SharedRuntime function\n-    const TypeFunc* tf = OptoRuntime::notify_jvmti_vthread_Type();\n-    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, hide);\n+    Node* is_mount = is_first_transition ? ideal.ConI(1) : _gvn.transform(argument(1));\n+    const TypeFunc* tf = OptoRuntime::vthread_transition_Type();\n+    make_runtime_call(RC_NO_LEAF, tf, funcAddr, funcName, TypePtr::BOTTOM, vt_oop, is_mount);\n@@ -3069,1 +3091,0 @@\n-    \/\/ set hide value to the VTMS transition bit in current JavaThread and VirtualThread object\n@@ -3075,3 +3096,2 @@\n-    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-\n+    access_store_at(nullptr, jt_addr, _gvn.type(jt_addr)->is_ptr(), ideal.ConI(0), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n+    access_store_at(nullptr, vt_addr, _gvn.type(vt_addr)->is_ptr(), ideal.ConI(0), TypeInt::BOOL, T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n@@ -3080,1 +3100,0 @@\n-  final_sync(ideal);\n@@ -3082,0 +3101,1 @@\n+  final_sync(ideal);\n@@ -3085,0 +3105,2 @@\n+#if INCLUDE_JVMTI\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":50,"deletions":28,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -278,0 +278,4 @@\n+\n+  bool inline_native_vthread_start_transition(address funcAddr, const char* funcName, bool is_final_transition);\n+  bool inline_native_vthread_end_transition(address funcAddr, const char* funcName, bool is_first_transition);\n+\n@@ -279,2 +283,0 @@\n-  bool inline_native_notify_jvmti_funcs(address funcAddr, const char* funcName, bool is_start, bool is_end);\n-  bool inline_native_notify_jvmti_hide();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -95,3 +96,1 @@\n-#define C2_JVMTI_STUB_FIELD_DEFINE(name) \\\n-  address OptoRuntime:: STUB_FIELD_NAME(name) = nullptr;\n-C2_STUBS_DO(C2_BLOB_FIELD_DEFINE, C2_STUB_FIELD_DEFINE, C2_JVMTI_STUB_FIELD_DEFINE)\n+C2_STUBS_DO(C2_BLOB_FIELD_DEFINE, C2_STUB_FIELD_DEFINE)\n@@ -100,1 +99,0 @@\n-#undef C2_JVMTI_STUB_FIELD_DEFINE\n@@ -156,14 +154,0 @@\n-#define C2_JVMTI_STUB_C_FUNC(name) CAST_FROM_FN_PTR(address, SharedRuntime::name)\n-\n-#define GEN_C2_JVMTI_STUB(name)                                       \\\n-  STUB_FIELD_NAME(name) =                                             \\\n-    generate_stub(env,                                                \\\n-                  notify_jvmti_vthread_Type,                          \\\n-                  C2_JVMTI_STUB_C_FUNC(name),                         \\\n-                  C2_STUB_NAME(name),                                 \\\n-                  C2_STUB_ID(name),                                   \\\n-                  0,                                                  \\\n-                  true,                                               \\\n-                  false);                                             \\\n-  if (STUB_FIELD_NAME(name) == nullptr) { return false; }             \\\n-\n@@ -172,1 +156,1 @@\n-  C2_STUBS_DO(GEN_C2_BLOB, GEN_C2_STUB, GEN_C2_JVMTI_STUB)\n+  C2_STUBS_DO(GEN_C2_BLOB, GEN_C2_STUB)\n@@ -185,2 +169,0 @@\n-#undef C2_JVMTI_STUB_C_FUNC\n-#undef GEN_C2_JVMTI_STUB\n@@ -260,0 +242,1 @@\n+const TypeFunc* OptoRuntime::_vthread_transition_Type             = nullptr;\n@@ -263,3 +246,0 @@\n-#if INCLUDE_JVMTI\n-const TypeFunc* OptoRuntime::_notify_jvmti_vthread_Type           = nullptr;\n-#endif \/\/ INCLUDE_JVMTI\n@@ -575,0 +555,20 @@\n+JRT_ENTRY(void, OptoRuntime::vthread_start_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  MountUnmountDisabler::end_transition(current, vt, true \/*is_mount*\/, true \/*is_thread_start*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_end_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  java_lang_Thread::set_is_in_VTMS_transition(vt, false);\n+  current->set_is_in_VTMS_transition(false);\n+  MountUnmountDisabler::start_transition(current, vt, false \/*is_mount *\/, true \/*is_thread_end*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_start_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  java_lang_Thread::set_is_in_VTMS_transition(vt, false);\n+  current->set_is_in_VTMS_transition(false);\n+  MountUnmountDisabler::start_transition(current, vt, is_mount, false \/*is_thread_end*\/);\n+JRT_END\n+\n+JRT_ENTRY(void, OptoRuntime::vthread_end_transition_C(oopDesc* vt, jboolean is_mount, JavaThread* current))\n+  MountUnmountDisabler::end_transition(current, vt, is_mount, false \/*is_thread_start*\/);\n+JRT_END\n+\n@@ -590,2 +590,1 @@\n-#if INCLUDE_JVMTI\n-static const TypeFunc* make_notify_jvmti_vthread_Type() {\n+static const TypeFunc* make_vthread_transition_Type() {\n@@ -605,1 +604,0 @@\n-#endif\n@@ -2339,0 +2337,1 @@\n+  _vthread_transition_Type            = make_vthread_transition_Type();\n@@ -2342,3 +2341,0 @@\n-#if INCLUDE_JVMTI\n-  _notify_jvmti_vthread_Type          = make_notify_jvmti_vthread_Type();\n-#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -118,2 +118,0 @@\n-#define C2_JVMTI_STUB_FIELD_DECLARE(name) \\\n-  static address     STUB_FIELD_NAME(name);\n@@ -121,1 +119,1 @@\n-  C2_STUBS_DO(C2_BLOB_FIELD_DECLARE, C2_STUB_FIELD_DECLARE, C2_JVMTI_STUB_FIELD_DECLARE)\n+  C2_STUBS_DO(C2_BLOB_FIELD_DECLARE, C2_STUB_FIELD_DECLARE)\n@@ -126,1 +124,0 @@\n-#undef C2_JVMTI_STUB_FIELD_DECLARE\n@@ -200,0 +197,1 @@\n+  static const TypeFunc* _vthread_transition_Type;\n@@ -203,3 +201,0 @@\n-#if INCLUDE_JVMTI\n-  static const TypeFunc* _notify_jvmti_vthread_Type;\n-#endif \/\/ INCLUDE_JVMTI\n@@ -242,0 +237,5 @@\n+  static void vthread_start_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_end_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_start_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+  static void vthread_end_transition_C(oopDesc* vt, jboolean hide, JavaThread* current);\n+\n@@ -296,6 +296,5 @@\n-#if INCLUDE_JVMTI\n-  static address notify_jvmti_vthread_start()            { return _notify_jvmti_vthread_start; }\n-  static address notify_jvmti_vthread_end()              { return _notify_jvmti_vthread_end; }\n-  static address notify_jvmti_vthread_mount()            { return _notify_jvmti_vthread_mount; }\n-  static address notify_jvmti_vthread_unmount()          { return _notify_jvmti_vthread_unmount; }\n-#endif\n+\n+  static address vthread_start_Java()                    { return _vthread_start_Java; }\n+  static address vthread_end_Java()                      { return _vthread_end_Java; }\n+  static address vthread_start_transition_Java()         { return _vthread_start_transition_Java; }\n+  static address vthread_end_transition_Java()           { return _vthread_end_transition_Java; }\n@@ -721,0 +720,21 @@\n+  static inline const TypeFunc* vthread_transition_Type() {\n+    assert(_vthread_transition_Type != nullptr, \"should be initialized\");\n+    return _vthread_transition_Type;\n+  }\n+\n+  static inline const TypeFunc* vthread_start_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_end_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_start_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n+  static inline const TypeFunc* vthread_end_transition_Type() {\n+    return vthread_transition_Type();\n+  }\n+\n@@ -728,7 +748,0 @@\n-#if INCLUDE_JVMTI\n-  static inline const TypeFunc* notify_jvmti_vthread_Type() {\n-    assert(_notify_jvmti_vthread_Type != nullptr, \"should be initialized\");\n-    return _notify_jvmti_vthread_Type;\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -3665,12 +3666,2 @@\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_start(vthread);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, false);\n-  }\n-#endif\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::end_transition(thread, vt, true \/*is_mount*\/, true \/*is_thread_start*\/);\n@@ -3680,12 +3671,2 @@\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_end(vthread);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, true);\n-  }\n-#endif\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::start_transition(thread, vt, false \/*is_mount *\/, true \/*is_thread_end*\/);\n@@ -3694,15 +3675,3 @@\n-\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call.\n-JVM_ENTRY(void, JVM_VirtualThreadMount(JNIEnv* env, jobject vthread, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_mount(vthread, hide);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, hide);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadStartTransition(JNIEnv* env, jobject vthread, jboolean is_mount))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::start_transition(thread, vt, is_mount, false \/*is_thread_end*\/);\n@@ -3711,15 +3680,3 @@\n-\/\/ If notifications are disabled then just update the VTMS transition bit and return.\n-\/\/ Otherwise, the bit is updated in the given jvmtiVTMSTransitionDisabler function call below.\n-JVM_ENTRY(void, JVM_VirtualThreadUnmount(JNIEnv* env, jobject vthread, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount(vthread, hide);\n-  } else {\n-    \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-    JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(thread, vthread, hide);\n-  }\n-#endif\n+JVM_ENTRY(void, JVM_VirtualThreadEndTransition(JNIEnv* env, jobject vthread, jboolean is_mount))\n+  oop vt = JNIHandles::resolve_external_guard(vthread);\n+  MountUnmountDisabler::end_transition(thread, vt, is_mount, false \/*is_thread_start*\/);\n@@ -3775,0 +3732,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":54,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -150,1 +151,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -203,1 +204,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(thread);\n+    MountUnmountDisabler disabler(thread);\n@@ -564,1 +565,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -588,1 +589,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -870,1 +871,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -942,1 +943,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -952,1 +953,1 @@\n-    \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+    \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -977,1 +978,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -1010,1 +1011,1 @@\n-  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -1031,1 +1032,1 @@\n-    JvmtiVTMSTransitionDisabler disabler(true);\n+    MountUnmountDisabler disabler(true);\n@@ -1081,1 +1082,1 @@\n-  \/\/ Do not use JvmtiVTMSTransitionDisabler in context of self suspend to avoid deadlocks.\n+  \/\/ Do not use MountUnmountDisabler in context of self suspend to avoid deadlocks.\n@@ -1092,1 +1093,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1114,1 +1115,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1153,1 +1154,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true);\n+  MountUnmountDisabler disabler(true);\n@@ -1199,1 +1200,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1237,1 +1238,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1283,1 +1284,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1372,1 +1373,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1427,1 +1428,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1710,1 +1711,1 @@\n-    JvmtiVTMSTransitionDisabler disabler;\n+    MountUnmountDisabler disabler;\n@@ -1743,1 +1744,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1798,1 +1799,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -1826,1 +1827,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2087,1 +2088,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2128,1 +2129,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2170,1 +2171,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2212,1 +2213,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2254,1 +2255,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2296,1 +2297,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2337,1 +2338,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2374,1 +2375,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2411,1 +2412,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2448,1 +2449,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2485,1 +2486,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n@@ -2577,1 +2578,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2590,1 +2591,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2603,1 +2604,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -2616,1 +2617,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -722,1 +723,0 @@\n-    assert(!java_thread->is_in_VTMS_transition(), \"invariant\");\n@@ -1697,1 +1697,0 @@\n-        jt->set_VTMS_transition_mark(true);\n@@ -1714,1 +1713,1 @@\n-    JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(_enable);\n+    MountUnmountDisabler::set_notify_jvmti_events(_enable);\n@@ -1725,1 +1724,1 @@\n-  if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+  if (MountUnmountDisabler::notify_jvmti_events()) {\n@@ -1741,1 +1740,1 @@\n-  if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+  if (!MountUnmountDisabler::notify_jvmti_events()) {\n@@ -1744,1 +1743,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(true); \/\/ ensure there are no other disablers\n+  MountUnmountDisabler disabler(true); \/\/ ensure there are no other disablers\n@@ -1772,1 +1771,0 @@\n-  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -1831,1 +1829,0 @@\n-  assert(!java_thread->is_in_VTMS_transition(), \"sanity check\");\n@@ -2011,1 +2008,1 @@\n-\/\/ JvmtiVTMSTransitionDisabler is always set by this function.\n+\/\/ MountUnmountDisabler is always set by this function.\n@@ -2016,1 +2013,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(target);\n+  MountUnmountDisabler disabler(target);\n@@ -2033,1 +2030,1 @@\n-\/\/ JvmtiVTMSTransitionDisabler has to be set before call to this function.\n+\/\/ MountUnmountDisabler has to be set before call to this function.\n@@ -2214,1 +2211,1 @@\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n+  MountUnmountDisabler disabler(thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -415,1 +416,1 @@\n-      if (!JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+      if (!MountUnmountDisabler::notify_jvmti_events()) {\n@@ -429,1 +430,1 @@\n-      JvmtiVTMSTransitionDisabler::set_VTMS_notify_jvmti_events(true);\n+      MountUnmountDisabler::set_notify_jvmti_events(true, true \/*is_onload*\/);\n@@ -1642,1 +1643,1 @@\n-          (*callback)(env->jvmti_external(), jem.jni_env(), vthread);\n+          (*callback)(env->jvmti_external(), jem.jni_env(), jem.jni_thread());\n@@ -2927,1 +2928,1 @@\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vthread.raw_value(), false);\n+  MountUnmountDisabler::end_transition(current, vthread(), true \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -2933,1 +2934,1 @@\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)vthread.raw_value(), true);\n+  MountUnmountDisabler::start_transition(current, vthread(), false \/*is_mount*\/, false \/*is_thread_start*\/);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -80,1 +81,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -138,1 +139,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -3031,1 +3032,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -3059,1 +3060,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n@@ -3079,1 +3080,1 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n+  MountUnmountDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -212,473 +212,0 @@\n-\/\/\n-\/\/ Virtual Threads Mount State transition (VTMS transition) mechanism\n-\/\/\n-\n-\/\/ VTMS transitions for one virtual thread are disabled while it is positive\n-volatile int JvmtiVTMSTransitionDisabler::_VTMS_transition_disable_for_one_count = 0;\n-\n-\/\/ VTMS transitions for all virtual threads are disabled while it is positive\n-volatile int JvmtiVTMSTransitionDisabler::_VTMS_transition_disable_for_all_count = 0;\n-\n-\/\/ There is an active suspender or resumer.\n-volatile bool JvmtiVTMSTransitionDisabler::_SR_mode = false;\n-\n-\/\/ Notifications from VirtualThread about VTMS events are enabled.\n-bool JvmtiVTMSTransitionDisabler::_VTMS_notify_jvmti_events = false;\n-\n-\/\/ The JvmtiVTMSTransitionDisabler sync protocol is enabled if this count > 0.\n-volatile int JvmtiVTMSTransitionDisabler::_sync_protocol_enabled_count = 0;\n-\n-\/\/ JvmtiVTMSTraansitionDisabler sync protocol is enabled permanently after seeing a suspender.\n-volatile bool JvmtiVTMSTransitionDisabler::_sync_protocol_enabled_permanently = false;\n-\n-#ifdef ASSERT\n-void\n-JvmtiVTMSTransitionDisabler::print_info() {\n-  log_error(jvmti)(\"_VTMS_transition_disable_for_one_count: %d\\n\", _VTMS_transition_disable_for_one_count);\n-  log_error(jvmti)(\"_VTMS_transition_disable_for_all_count: %d\\n\\n\", _VTMS_transition_disable_for_all_count);\n-  int attempts = 10000;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *java_thread = jtiwh.next(); ) {\n-    if (java_thread->VTMS_transition_mark()) {\n-      log_error(jvmti)(\"jt: %p VTMS_transition_mark: %d\\n\",\n-                       (void*)java_thread, java_thread->VTMS_transition_mark());\n-    }\n-    ResourceMark rm;\n-    \/\/ Handshake with target.\n-    PrintStackTraceClosure pstc;\n-    Handshake::execute(&pstc, java_thread);\n-  }\n-}\n-#endif\n-\n-\/\/ disable VTMS transitions for one virtual thread\n-\/\/ disable VTMS transitions for all threads if thread is nullptr or a platform thread\n-JvmtiVTMSTransitionDisabler::JvmtiVTMSTransitionDisabler(jthread thread)\n-  : _is_SR(false),\n-    _is_virtual(false),\n-    _is_self(false),\n-    _thread(thread)\n-{\n-  if (!Continuations::enabled()) {\n-    return; \/\/ JvmtiVTMSTransitionDisabler is no-op without virtual threads\n-  }\n-  if (Thread::current_or_null() == nullptr) {\n-    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n-  }\n-  JavaThread* current = JavaThread::current();\n-  oop thread_oop = JNIHandles::resolve_external_guard(thread);\n-  _is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n-\n-  if (thread == nullptr ||\n-      (!_is_virtual && thread_oop == current->threadObj()) ||\n-      (_is_virtual && thread_oop == current->vthread())) {\n-    _is_self = true;\n-    return; \/\/ no need for current thread to disable and enable transitions for itself\n-  }\n-  if (!sync_protocol_enabled_permanently()) {\n-    JvmtiVTMSTransitionDisabler::inc_sync_protocol_enabled_count();\n-  }\n-\n-  \/\/ Target can be virtual or platform thread.\n-  \/\/ If target is a platform thread then we have to disable VTMS transitions for all threads.\n-  \/\/ It is by several reasons:\n-  \/\/ - carrier threads can mount virtual threads which may cause incorrect behavior\n-  \/\/ - there is no mechanism to disable transitions for a specific carrier thread yet\n-  if (_is_virtual) {\n-    VTMS_transition_disable_for_one(); \/\/ disable VTMS transitions for one virtual thread\n-  } else {\n-    VTMS_transition_disable_for_all(); \/\/ disable VTMS transitions for all virtual threads\n-  }\n-}\n-\n-\/\/ disable VTMS transitions for all virtual threads\n-JvmtiVTMSTransitionDisabler::JvmtiVTMSTransitionDisabler(bool is_SR)\n-  : _is_SR(is_SR),\n-    _is_virtual(false),\n-    _is_self(false),\n-    _thread(nullptr)\n-{\n-  if (!Continuations::enabled()) {\n-    return; \/\/ JvmtiVTMSTransitionDisabler is no-op without virtual threads\n-  }\n-  if (Thread::current_or_null() == nullptr) {\n-    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n-  }\n-  if (!sync_protocol_enabled_permanently()) {\n-    JvmtiVTMSTransitionDisabler::inc_sync_protocol_enabled_count();\n-    if (is_SR) {\n-      AtomicAccess::store(&_sync_protocol_enabled_permanently, true);\n-    }\n-  }\n-  VTMS_transition_disable_for_all();\n-}\n-\n-JvmtiVTMSTransitionDisabler::~JvmtiVTMSTransitionDisabler() {\n-  if (!Continuations::enabled()) {\n-    return; \/\/ JvmtiVTMSTransitionDisabler is a no-op without virtual threads\n-  }\n-  if (Thread::current_or_null() == nullptr) {\n-    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n-  }\n-  if (_is_self) {\n-    return; \/\/ no need for current thread to disable and enable transitions for itself\n-  }\n-  if (_is_virtual) {\n-    VTMS_transition_enable_for_one(); \/\/ enable VTMS transitions for one virtual thread\n-  } else {\n-    VTMS_transition_enable_for_all(); \/\/ enable VTMS transitions for all virtual threads\n-  }\n-  if (!sync_protocol_enabled_permanently()) {\n-    JvmtiVTMSTransitionDisabler::dec_sync_protocol_enabled_count();\n-  }\n-}\n-\n-\/\/ disable VTMS transitions for one virtual thread\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_transition_disable_for_one() {\n-  assert(_thread != nullptr, \"sanity check\");\n-  JavaThread* thread = JavaThread::current();\n-  HandleMark hm(thread);\n-  Handle vth = Handle(thread, JNIHandles::resolve_external_guard(_thread));\n-  assert(java_lang_VirtualThread::is_instance(vth()), \"sanity check\");\n-\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n-\n-  while (_SR_mode) { \/\/ suspender or resumer is a JvmtiVTMSTransitionDisabler monopolist\n-    ml.wait(10); \/\/ wait while there is an active suspender or resumer\n-  }\n-  AtomicAccess::inc(&_VTMS_transition_disable_for_one_count);\n-  java_lang_Thread::inc_VTMS_transition_disable_count(vth());\n-\n-  while (java_lang_Thread::is_in_VTMS_transition(vth())) {\n-    ml.wait(10); \/\/ wait while the virtual thread is in transition\n-  }\n-#ifdef ASSERT\n-  thread->set_is_VTMS_transition_disabler(true);\n-#endif\n-}\n-\n-\/\/ disable VTMS transitions for all virtual threads\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_transition_disable_for_all() {\n-  JavaThread* thread = JavaThread::current();\n-  int attempts = 50000;\n-  {\n-    MonitorLocker ml(JvmtiVTMSTransition_lock);\n-\n-    assert(!thread->is_in_VTMS_transition(), \"VTMS_transition sanity check\");\n-    while (_SR_mode) { \/\/ Suspender or resumer is a JvmtiVTMSTransitionDisabler monopolist.\n-      ml.wait(10);     \/\/ Wait while there is an active suspender or resumer.\n-    }\n-    if (_is_SR) {\n-      _SR_mode = true;\n-      while (_VTMS_transition_disable_for_all_count > 0 ||\n-             _VTMS_transition_disable_for_one_count > 0) {\n-        ml.wait(10);   \/\/ Wait while there is any active jvmtiVTMSTransitionDisabler.\n-      }\n-    }\n-    AtomicAccess::inc(&_VTMS_transition_disable_for_all_count);\n-\n-    \/\/ Block while some mount\/unmount transitions are in progress.\n-    \/\/ Debug version fails and prints diagnostic information.\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-      while (jt->VTMS_transition_mark()) {\n-        if (ml.wait(10)) {\n-          attempts--;\n-        }\n-        DEBUG_ONLY(if (attempts == 0) break;)\n-      }\n-    }\n-    assert(!thread->is_VTMS_transition_disabler(), \"VTMS_transition sanity check\");\n-#ifdef ASSERT\n-    if (attempts > 0) {\n-      thread->set_is_VTMS_transition_disabler(true);\n-    }\n-#endif\n-  }\n-#ifdef ASSERT\n-    if (attempts == 0) {\n-      print_info();\n-      fatal(\"stuck in JvmtiVTMSTransitionDisabler::VTMS_transition_disable\");\n-    }\n-#endif\n-}\n-\n-\/\/ enable VTMS transitions for one virtual thread\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_transition_enable_for_one() {\n-  JavaThread* thread = JavaThread::current();\n-  HandleMark hm(thread);\n-  Handle vth = Handle(thread, JNIHandles::resolve_external_guard(_thread));\n-  if (!java_lang_VirtualThread::is_instance(vth())) {\n-    return; \/\/ no-op if _thread is not a virtual thread\n-  }\n-  MonitorLocker ml(JvmtiVTMSTransition_lock);\n-  java_lang_Thread::dec_VTMS_transition_disable_count(vth());\n-  AtomicAccess::dec(&_VTMS_transition_disable_for_one_count);\n-  if (_VTMS_transition_disable_for_one_count == 0) {\n-    ml.notify_all();\n-  }\n-#ifdef ASSERT\n-  thread->set_is_VTMS_transition_disabler(false);\n-#endif\n-}\n-\n-\/\/ enable VTMS transitions for all virtual threads\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_transition_enable_for_all() {\n-  JavaThread* current = JavaThread::current();\n-  {\n-    MonitorLocker ml(JvmtiVTMSTransition_lock);\n-    assert(_VTMS_transition_disable_for_all_count > 0, \"VTMS_transition sanity check\");\n-\n-    if (_is_SR) {  \/\/ Disabler is suspender or resumer.\n-      _SR_mode = false;\n-    }\n-    AtomicAccess::dec(&_VTMS_transition_disable_for_all_count);\n-    if (_VTMS_transition_disable_for_all_count == 0 || _is_SR) {\n-      ml.notify_all();\n-    }\n-#ifdef ASSERT\n-    current->set_is_VTMS_transition_disabler(false);\n-#endif\n-  }\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::start_VTMS_transition(jthread vthread, bool is_mount) {\n-  JavaThread* thread = JavaThread::current();\n-  oop vt = JNIHandles::resolve_external_guard(vthread);\n-  assert(!thread->is_in_VTMS_transition(), \"VTMS_transition sanity check\");\n-\n-  \/\/ Avoid using MonitorLocker on performance critical path, use\n-  \/\/ two-level synchronization with lock-free operations on state bits.\n-  assert(!thread->VTMS_transition_mark(), \"sanity check\");\n-  thread->set_VTMS_transition_mark(true); \/\/ Try to enter VTMS transition section optmistically.\n-  java_lang_Thread::set_is_in_VTMS_transition(vt, true);\n-\n-  if (!sync_protocol_enabled()) {\n-    thread->set_is_in_VTMS_transition(true);\n-    return;\n-  }\n-  HandleMark hm(thread);\n-  Handle vth = Handle(thread, vt);\n-  int attempts = 50000;\n-\n-  \/\/ Do not allow suspends inside VTMS transitions.\n-  \/\/ Block while transitions are disabled or there are suspend requests.\n-  int64_t thread_id = java_lang_Thread::thread_id(vth());  \/\/ Cannot use oops while blocked.\n-\n-  if (_VTMS_transition_disable_for_all_count > 0 ||\n-      java_lang_Thread::VTMS_transition_disable_count(vth()) > 0 ||\n-      thread->is_suspended() ||\n-      JvmtiVTSuspender::is_vthread_suspended(thread_id)\n-  ) {\n-    \/\/ Slow path: undo unsuccessful optimistic set of the VTMS_transition_mark.\n-    \/\/ It can cause an extra waiting cycle for VTMS transition disablers.\n-    thread->set_VTMS_transition_mark(false);\n-    java_lang_Thread::set_is_in_VTMS_transition(vth(), false);\n-\n-    while (true) {\n-      MonitorLocker ml(JvmtiVTMSTransition_lock);\n-\n-      \/\/ Do not allow suspends inside VTMS transitions.\n-      \/\/ Block while transitions are disabled or there are suspend requests.\n-      if (_VTMS_transition_disable_for_all_count > 0 ||\n-          java_lang_Thread::VTMS_transition_disable_count(vth()) > 0 ||\n-          thread->is_suspended() ||\n-          JvmtiVTSuspender::is_vthread_suspended(thread_id)\n-      ) {\n-        \/\/ Block while transitions are disabled or there are suspend requests.\n-        if (ml.wait(200)) {\n-          attempts--;\n-        }\n-        DEBUG_ONLY(if (attempts == 0) break;)\n-        continue;  \/\/ ~ThreadBlockInVM has handshake-based suspend point.\n-      }\n-      thread->set_VTMS_transition_mark(true);\n-      java_lang_Thread::set_is_in_VTMS_transition(vth(), true);\n-      break;\n-    }\n-  }\n-#ifdef ASSERT\n-  if (attempts == 0) {\n-    log_error(jvmti)(\"start_VTMS_transition: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n-                     thread->is_suspended(), JvmtiVTSuspender::is_vthread_suspended(thread_id));\n-    print_info();\n-    fatal(\"stuck in JvmtiVTMSTransitionDisabler::start_VTMS_transition\");\n-  }\n-#endif\n-  \/\/ Enter VTMS transition section.\n-  thread->set_is_in_VTMS_transition(true);\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::finish_VTMS_transition(jthread vthread, bool is_mount) {\n-  JavaThread* thread = JavaThread::current();\n-\n-  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n-  thread->set_is_in_VTMS_transition(false);\n-  oop vt = JNIHandles::resolve_external_guard(vthread);\n-  java_lang_Thread::set_is_in_VTMS_transition(vt, false);\n-  assert(thread->VTMS_transition_mark(), \"sanity check\");\n-  thread->set_VTMS_transition_mark(false);\n-\n-  if (!sync_protocol_enabled()) {\n-    return;\n-  }\n-  int64_t thread_id = java_lang_Thread::thread_id(vt);\n-\n-  \/\/ Unblock waiting VTMS transition disablers.\n-  if (_VTMS_transition_disable_for_one_count > 0 ||\n-      _VTMS_transition_disable_for_all_count > 0) {\n-    MonitorLocker ml(JvmtiVTMSTransition_lock);\n-    ml.notify_all();\n-  }\n-  \/\/ In unmount case the carrier thread is attached after unmount transition.\n-  \/\/ Check and block it if there was external suspend request.\n-  int attempts = 10000;\n-  if (!is_mount && thread->is_carrier_thread_suspended()) {\n-    while (true) {\n-      MonitorLocker ml(JvmtiVTMSTransition_lock);\n-\n-      \/\/ Block while there are suspend requests.\n-      if ((!is_mount && thread->is_carrier_thread_suspended()) ||\n-          (is_mount && JvmtiVTSuspender::is_vthread_suspended(thread_id))\n-      ) {\n-        \/\/ Block while there are suspend requests.\n-        if (ml.wait(200)) {\n-          attempts--;\n-        }\n-        DEBUG_ONLY(if (attempts == 0) break;)\n-        continue;\n-      }\n-      break;\n-    }\n-  }\n-#ifdef ASSERT\n-  if (attempts == 0) {\n-    log_error(jvmti)(\"finish_VTMS_transition: thread->is_suspended: %d is_vthread_suspended: %d\\n\\n\",\n-                     thread->is_suspended(), JvmtiVTSuspender::is_vthread_suspended(thread_id));\n-    print_info();\n-    fatal(\"stuck in JvmtiVTMSTransitionDisabler::finish_VTMS_transition\");\n-  }\n-#endif\n-}\n-\n-\/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-void JvmtiVTMSTransitionDisabler::set_is_in_VTMS_transition(JavaThread* thread, jobject vthread, bool in_trans) {\n-  oop vt = JNIHandles::resolve_external_guard(vthread);\n-  java_lang_Thread::set_is_in_VTMS_transition(vt, in_trans);\n-  thread->set_is_in_VTMS_transition(in_trans);\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_vthread_start(jobject vthread) {\n-  VTMS_mount_end(vthread);\n-  JavaThread* thread = JavaThread::current();\n-\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-\n-  \/\/ If interp_only_mode has been enabled then we must eagerly create JvmtiThreadState\n-  \/\/ objects for globally enabled virtual thread filtered events. Otherwise,\n-  \/\/ it is an important optimization to create JvmtiThreadState objects lazily.\n-  \/\/ This optimization is disabled when watchpoint capabilities are present. It is to\n-  \/\/ work around a bug with virtual thread frames which can be not deoptimized in time.\n-  if (JvmtiThreadState::seen_interp_only_mode() ||\n-      JvmtiExport::should_post_field_access() ||\n-      JvmtiExport::should_post_field_modification()){\n-    JvmtiEventController::thread_started(thread);\n-  }\n-  if (JvmtiExport::should_post_vthread_start()) {\n-    JvmtiExport::post_vthread_start(vthread);\n-  }\n-  \/\/ post VirtualThreadMount event after VirtualThreadStart\n-  if (JvmtiExport::should_post_vthread_mount()) {\n-    JvmtiExport::post_vthread_mount(vthread);\n-  }\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_vthread_end(jobject vthread) {\n-  JavaThread* thread = JavaThread::current();\n-\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-\n-  \/\/ post VirtualThreadUnmount event before VirtualThreadEnd\n-  if (JvmtiExport::should_post_vthread_unmount()) {\n-    JvmtiExport::post_vthread_unmount(vthread);\n-  }\n-  if (JvmtiExport::should_post_vthread_end()) {\n-    JvmtiExport::post_vthread_end(vthread);\n-  }\n-  VTMS_unmount_begin(vthread, \/* last_unmount *\/ true);\n-  if (thread->jvmti_thread_state() != nullptr) {\n-    JvmtiExport::cleanup_thread(thread);\n-    assert(thread->jvmti_thread_state() == nullptr, \"should be null\");\n-    assert(java_lang_Thread::jvmti_thread_state(JNIHandles::resolve(vthread)) == nullptr, \"should be null\");\n-  }\n-  thread->rebind_to_jvmti_thread_state_of(thread->threadObj());\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_vthread_mount(jobject vthread, bool hide) {\n-  if (hide) {\n-    VTMS_mount_begin(vthread);\n-  } else {\n-    VTMS_mount_end(vthread);\n-    if (JvmtiExport::should_post_vthread_mount()) {\n-      JvmtiExport::post_vthread_mount(vthread);\n-    }\n-  }\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount(jobject vthread, bool hide) {\n-  if (hide) {\n-    if (JvmtiExport::should_post_vthread_unmount()) {\n-      JvmtiExport::post_vthread_unmount(vthread);\n-    }\n-    VTMS_unmount_begin(vthread, \/* last_unmount *\/ false);\n-  } else {\n-    VTMS_unmount_end(vthread);\n-  }\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_mount_begin(jobject vthread) {\n-  JavaThread* thread = JavaThread::current();\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-  start_VTMS_transition(vthread, \/* is_mount *\/ true);\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_mount_end(jobject vthread) {\n-  JavaThread* thread = JavaThread::current();\n-  oop vt = JNIHandles::resolve(vthread);\n-\n-  thread->rebind_to_jvmti_thread_state_of(vt);\n-\n-  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n-  finish_VTMS_transition(vthread, \/* is_mount *\/ true);\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_unmount_begin(jobject vthread, bool last_unmount) {\n-  JavaThread* thread = JavaThread::current();\n-\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-\n-  start_VTMS_transition(vthread, \/* is_mount *\/ false);\n-  if (!last_unmount) {\n-    thread->rebind_to_jvmti_thread_state_of(thread->threadObj());\n-  }\n-}\n-\n-void\n-JvmtiVTMSTransitionDisabler::VTMS_unmount_end(jobject vthread) {\n-  JavaThread* thread = JavaThread::current();\n-  assert(thread->is_in_VTMS_transition(), \"sanity check\");\n-  finish_VTMS_transition(vthread, \/* is_mount *\/ false);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":0,"deletions":473,"binary":false,"changes":473,"status":"modified"},{"patch":"@@ -75,61 +75,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ class JvmtiVTMSTransitionDisabler\n-\/\/\n-\/\/ Virtual Thread Mount State Transition (VTMS transition) mechanism\n-\/\/\n-class JvmtiVTMSTransitionDisabler : public AnyObj {\n- private:\n-  static volatile int _VTMS_transition_disable_for_one_count; \/\/ transitions for one virtual thread are disabled while it is positive\n-  static volatile int _VTMS_transition_disable_for_all_count; \/\/ transitions for all virtual threads are disabled while it is positive\n-  static volatile bool _SR_mode;                         \/\/ there is an active suspender or resumer\n-  static volatile int _sync_protocol_enabled_count;      \/\/ current number of JvmtiVTMSTransitionDisablers enabled sync protocol\n-  static volatile bool _sync_protocol_enabled_permanently; \/\/ seen a suspender: JvmtiVTMSTransitionDisabler protocol is enabled permanently\n-\n-  bool _is_SR;                                           \/\/ is suspender or resumer\n-  bool _is_virtual;                                      \/\/ target thread is virtual\n-  bool _is_self;                                         \/\/ JvmtiVTMSTransitionDisabler is a no-op for current platform, carrier or virtual thread\n-  jthread _thread;                                       \/\/ virtual thread to disable transitions for, no-op if it is a platform thread\n-\n-  DEBUG_ONLY(static void print_info();)\n-  void VTMS_transition_disable_for_one();\n-  void VTMS_transition_disable_for_all();\n-  void VTMS_transition_enable_for_one();\n-  void VTMS_transition_enable_for_all();\n-\n- public:\n-  static bool _VTMS_notify_jvmti_events;                 \/\/ enable notifications from VirtualThread about VTMS events\n-  static bool VTMS_notify_jvmti_events()             { return _VTMS_notify_jvmti_events; }\n-  static void set_VTMS_notify_jvmti_events(bool val) { _VTMS_notify_jvmti_events = val; }\n-\n-  static void inc_sync_protocol_enabled_count()      { AtomicAccess::inc(&_sync_protocol_enabled_count); }\n-  static void dec_sync_protocol_enabled_count()      { AtomicAccess::dec(&_sync_protocol_enabled_count); }\n-  static int  sync_protocol_enabled_count()          { return AtomicAccess::load(&_sync_protocol_enabled_count); }\n-  static bool sync_protocol_enabled_permanently()    { return AtomicAccess::load(&_sync_protocol_enabled_permanently); }\n-\n-  static bool sync_protocol_enabled()                { return sync_protocol_enabled_permanently() || sync_protocol_enabled_count() > 0; }\n-\n-  \/\/ parameter is_SR: suspender or resumer\n-  JvmtiVTMSTransitionDisabler(bool is_SR = false);\n-  JvmtiVTMSTransitionDisabler(jthread thread);\n-  ~JvmtiVTMSTransitionDisabler();\n-\n-  \/\/ set VTMS transition bit value in JavaThread and java.lang.VirtualThread object\n-  static void set_is_in_VTMS_transition(JavaThread* thread, jobject vthread, bool in_trans);\n-\n-  static void start_VTMS_transition(jthread vthread, bool is_mount);\n-  static void finish_VTMS_transition(jthread vthread, bool is_mount);\n-\n-  static void VTMS_vthread_start(jobject vthread);\n-  static void VTMS_vthread_end(jobject vthread);\n-\n-  static void VTMS_vthread_mount(jobject vthread, bool hide);\n-  static void VTMS_vthread_unmount(jobject vthread, bool hide);\n-\n-  static void VTMS_mount_begin(jobject vthread);\n-  static void VTMS_mount_end(jobject vthread);\n-\n-  static void VTMS_unmount_begin(jobject vthread, bool last_unmount);\n-  static void VTMS_unmount_end(jobject vthread);\n-};\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -59,2 +60,1 @@\n-#if INCLUDE_JVMTI\n-class JvmtiUnmountBeginMark : public StackObj {\n+class UnmountBeginMark : public StackObj {\n@@ -67,1 +67,1 @@\n-  JvmtiUnmountBeginMark(JavaThread* t) :\n+  UnmountBeginMark(JavaThread* t) :\n@@ -71,11 +71,1 @@\n-    if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n-      JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)_vthread.raw_value(), true);\n-\n-      \/\/ Don't preempt if there is a pending popframe or earlyret operation. This can\n-      \/\/ be installed in start_VTMS_transition() so we need to check it here.\n-      if (JvmtiExport::can_pop_frame() || JvmtiExport::can_force_early_return()) {\n-        JvmtiThreadState* state = _current->jvmti_thread_state();\n-        if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n-          _failed = true;\n-        }\n-      }\n+    MountUnmountDisabler::start_transition(_current, _vthread(), false \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -83,3 +73,5 @@\n-      \/\/ Don't preempt in case there is an async exception installed since\n-      \/\/ we would incorrectly throw it during the unmount logic in the carrier.\n-      if (_current->has_async_exception_condition()) {\n+    \/\/ Don't preempt if there is a pending popframe or earlyret operation. This can\n+    \/\/ be installed in in process_at_transition_start() so we need to check it here.\n+    if (JvmtiExport::can_pop_frame() || JvmtiExport::can_force_early_return()) {\n+      JvmtiThreadState* state = _current->jvmti_thread_state();\n+      if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n@@ -88,3 +80,6 @@\n-    } else {\n-      _current->set_is_in_VTMS_transition(true);\n-      java_lang_Thread::set_is_in_VTMS_transition(_vthread(), true);\n+    }\n+\n+    \/\/ Don't preempt in case there is an async exception installed since\n+    \/\/ we would incorrectly throw it during the unmount logic in the carrier.\n+    if (_current->has_async_exception_condition()) {\n+      _failed = true;\n@@ -93,1 +88,1 @@\n-  ~JvmtiUnmountBeginMark() {\n+  ~UnmountBeginMark() {\n@@ -95,1 +90,0 @@\n-\n@@ -97,5 +91,0 @@\n-    assert(java_lang_Thread::is_in_VTMS_transition(_vthread()), \"must be\");\n-\n-    \/\/ Read it again since for late binding agents the flag could have\n-    \/\/ been set while blocked in the allocation path during freeze.\n-    bool jvmti_present = JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events();\n@@ -105,6 +94,1 @@\n-      if (jvmti_present) {\n-        JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)_vthread.raw_value(), false);\n-      } else {\n-        _current->set_is_in_VTMS_transition(false);\n-        java_lang_Thread::set_is_in_VTMS_transition(_vthread(), false);\n-      }\n+      MountUnmountDisabler::end_transition(_current, _vthread(), true \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -117,0 +101,1 @@\n+#if INCLUDE_JVMTI\n@@ -153,2 +138,2 @@\n-  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(current);)\n-  JVMTI_ONLY(if (jubm.failed()) return freeze_pinned_native;)\n+  UnmountBeginMark ubm(current);\n+  if (ubm.failed()) return freeze_pinned_native;\n@@ -157,1 +142,1 @@\n-  JVMTI_ONLY(jubm.set_result(res);)\n+  ubm.set_result(res);\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":21,"deletions":36,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -1693,1 +1694,1 @@\n-    JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vth.raw_value(), false);\n+    MountUnmountDisabler::end_transition(current, vth(), true \/*is_mount*\/, false \/*is_thread_start*\/);\n@@ -2632,1 +2633,0 @@\n-#if INCLUDE_JVMTI\n@@ -2637,1 +2637,2 @@\n-    if (JvmtiVTMSTransitionDisabler::VTMS_notify_jvmti_events()) {\n+#if INCLUDE_JVMTI\n+    if (MountUnmountDisabler::notify_jvmti_events()) {\n@@ -2639,2 +2640,4 @@\n-    } else {\n-      _thread->set_is_in_VTMS_transition(false);\n+    } else\n+#endif\n+    { \/\/ Faster version of MountUnmountDisabler::end_transition() to avoid\n+      \/\/ unnecessary extra instructions from jvmti_mount_end().\n@@ -2642,0 +2645,1 @@\n+      _thread->set_is_in_VTMS_transition(false);\n@@ -2644,1 +2648,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n@@ -364,0 +365,21 @@\n+void Handshake::execute(HandshakeClosure* hs_cl, oop vthread) {\n+  assert(java_lang_VirtualThread::is_instance(vthread), \"\");\n+  Handle vth(JavaThread::current(), vthread);\n+\n+  MountUnmountDisabler md(vthread);\n+  oop carrier_thread = java_lang_VirtualThread::carrier_thread(vth());\n+  if (carrier_thread != nullptr) {\n+    JavaThread* target = java_lang_Thread::thread(carrier_thread);\n+    assert(target != nullptr, \"\");\n+    \/\/ Technically there is need for a ThreadsListHandle since the target\n+    \/\/ will block if it tries to unmount the vthread, so it can never exit.\n+    ThreadsListHandle tlh(JavaThread::current());\n+    assert(tlh.includes(target), \"\");\n+    execute(hs_cl, &tlh, target);\n+    assert(target->threadObj() == java_lang_VirtualThread::carrier_thread(vth()), \"\");\n+  } else {\n+    \/\/ unmounted vthread, execute closure with the current thread\n+    hs_cl->do_thread(nullptr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  static void execute(HandshakeClosure*       hs_cl, oop vthread);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -451,1 +451,0 @@\n-  _is_in_VTMS_transition(false),\n@@ -454,1 +453,0 @@\n-  _VTMS_transition_mark(false),\n@@ -457,3 +455,0 @@\n-#ifdef ASSERT\n-  _is_VTMS_transition_disabler(false),\n-#endif\n@@ -505,0 +500,3 @@\n+  _is_in_VTMS_transition(false),\n+  DEBUG_ONLY(_is_VTMS_transition_disabler(false) COMMA)\n+\n@@ -1152,1 +1150,4 @@\n-#if INCLUDE_JVMTI\n+bool JavaThread::is_in_VTMS_transition() const {\n+  return AtomicAccess::load(&_is_in_VTMS_transition);\n+}\n+\n@@ -1155,1 +1156,1 @@\n-  _is_in_VTMS_transition = val;\n+  AtomicAccess::store(&_is_in_VTMS_transition, val);\n@@ -1163,1 +1164,0 @@\n-#endif\n@@ -1174,1 +1174,0 @@\n-  assert(!is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -325,1 +325,0 @@\n-  bool                  _is_in_VTMS_transition;          \/\/ thread is in virtual thread mount state transition\n@@ -328,1 +327,0 @@\n-  bool                  _VTMS_transition_mark;           \/\/ used for sync between VTMS transitions and disablers\n@@ -331,3 +329,0 @@\n-#ifdef ASSERT\n-  bool                  _is_VTMS_transition_disabler;    \/\/ thread currently disabled VTMS transitions\n-#endif\n@@ -739,0 +734,11 @@\n+private:\n+  bool _is_in_VTMS_transition;                    \/\/ thread is in virtual thread mount state transition\n+  DEBUG_ONLY(bool _is_VTMS_transition_disabler;)  \/\/ thread currently disabled VTMS transitions\n+public:\n+  bool is_in_VTMS_transition() const;\n+  void set_is_in_VTMS_transition(bool val);\n+#ifdef ASSERT\n+  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n+  void set_is_VTMS_transition_disabler(bool val);\n+#endif\n+\n@@ -747,3 +753,0 @@\n-  bool is_in_VTMS_transition() const             { return _is_in_VTMS_transition; }\n-  void set_is_in_VTMS_transition(bool val);\n-\n@@ -756,3 +759,0 @@\n-  bool VTMS_transition_mark() const              { return AtomicAccess::load(&_VTMS_transition_mark); }\n-  void set_VTMS_transition_mark(bool val)        { AtomicAccess::store(&_VTMS_transition_mark, val); }\n-\n@@ -770,4 +770,0 @@\n-#ifdef ASSERT\n-  bool is_VTMS_transition_disabler() const       { return _is_VTMS_transition_disabler; }\n-  void set_is_VTMS_transition_disabler(bool val);\n-#endif\n@@ -928,0 +924,1 @@\n+  static ByteSize is_in_VTMS_transition_offset()     { return byte_offset_of(JavaThread, _is_in_VTMS_transition); }\n@@ -930,1 +927,0 @@\n-  static ByteSize is_in_VTMS_transition_offset()     { return byte_offset_of(JavaThread, _is_in_VTMS_transition); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,430 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"prims\/jvmtiEventController.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiThreadState.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/mountUnmountDisabler.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+\n+volatile int MountUnmountDisabler::_global_start_transition_disable_count = 0;\n+volatile int MountUnmountDisabler::_active_disablers = 0;\n+bool MountUnmountDisabler::_exclusive_operation_ongoing = false;\n+bool MountUnmountDisabler::_notify_jvmti_events = false;\n+\n+#if INCLUDE_JVMTI\n+class JVMTIStartTransition : public StackObj {\n+  JavaThread* _current;\n+  Handle _vthread;\n+  bool _is_mount;\n+  bool _is_thread_end;\n+ public:\n+  JVMTIStartTransition(JavaThread* current, oop vthread, bool is_mount, bool is_thread_end) :\n+    _current(current), _vthread(current, vthread), _is_mount(is_mount), _is_thread_end(is_thread_end) {\n+    if (DoJVMTIVirtualThreadTransitions && MountUnmountDisabler::notify_jvmti_events()) {\n+      \/\/ post VirtualThreadUnmount event before VirtualThreadEnd\n+      if (!_is_mount && JvmtiExport::should_post_vthread_unmount()) {\n+        JvmtiExport::post_vthread_unmount((jthread)_vthread.raw_value());\n+      }\n+      if (_is_thread_end && JvmtiExport::should_post_vthread_end()) {\n+        JvmtiExport::post_vthread_end((jthread)_vthread.raw_value());\n+      }\n+    }\n+  }\n+  ~JVMTIStartTransition() {\n+    if (DoJVMTIVirtualThreadTransitions && MountUnmountDisabler::notify_jvmti_events()) {\n+      if (_is_thread_end && _current->jvmti_thread_state() != nullptr) {\n+        JvmtiExport::cleanup_thread(_current);\n+        assert(_current->jvmti_thread_state() == nullptr, \"should be null\");\n+        assert(java_lang_Thread::jvmti_thread_state(_vthread()) == nullptr, \"should be null\");\n+      }\n+      _current->rebind_to_jvmti_thread_state_of(_is_mount ? _vthread() : _current->threadObj());\n+    }\n+  }\n+};\n+\n+class JVMTIEndTransition : public StackObj {\n+  JavaThread* _current;\n+  Handle _vthread;\n+  bool _is_mount;\n+  bool _is_thread_start;\n+ public:\n+  JVMTIEndTransition(JavaThread* current, oop vthread, bool is_mount, bool is_thread_start) :\n+    _current(current), _vthread(current, vthread), _is_mount(is_mount), _is_thread_start(is_thread_start) {\n+    if (DoJVMTIVirtualThreadTransitions && MountUnmountDisabler::notify_jvmti_events()) {\n+      bool is_virtual = java_lang_VirtualThread::is_instance(_current->jvmti_vthread());\n+      bool should_rebind = (_is_mount && !is_virtual) || (!_is_mount && is_virtual);\n+      if (should_rebind) {\n+        \/\/ We rebinded on start_transition but the mount\/unmount operation\n+        \/\/ failed so now we need to rebind to the original state.\n+        _current->rebind_to_jvmti_thread_state_of(_is_mount ? _vthread() : _current->threadObj());\n+        OrderAccess::fence();  \/\/ dont reorder with clear of transition flags\n+      }\n+    }\n+  }\n+  ~JVMTIEndTransition() {\n+    if (DoJVMTIVirtualThreadTransitions && MountUnmountDisabler::notify_jvmti_events()) {\n+      if (!_is_mount && _current->is_carrier_thread_suspended()) {\n+        MonitorLocker ml(VTMSTransition_lock);\n+        while (_current->is_carrier_thread_suspended()) {\n+          ml.wait(200);\n+        }\n+      }\n+\n+      if (_is_thread_start) {\n+        \/\/ If interp_only_mode has been enabled then we must eagerly create JvmtiThreadState\n+        \/\/ objects for globally enabled virtual thread filtered events. Otherwise,\n+        \/\/ it is an important optimization to create JvmtiThreadState objects lazily.\n+        \/\/ This optimization is disabled when watchpoint capabilities are present. It is to\n+        \/\/ work around a bug with virtual thread frames which can be not deoptimized in time.\n+        if (JvmtiThreadState::seen_interp_only_mode() ||\n+            JvmtiExport::should_post_field_access() ||\n+            JvmtiExport::should_post_field_modification()){\n+          JvmtiEventController::thread_started(_current);\n+        }\n+        if (JvmtiExport::should_post_vthread_start()) {\n+          JvmtiExport::post_vthread_start((jthread)_vthread.raw_value());\n+        }\n+      }\n+      if (_is_mount && JvmtiExport::should_post_vthread_mount()) {\n+        JvmtiExport::post_vthread_mount((jthread)_vthread.raw_value());\n+      }\n+    }\n+  }\n+};\n+#endif \/\/ INCLUDE_JVMTI\n+\n+bool MountUnmountDisabler::is_start_transition_disabled(JavaThread* thread, oop vthread) {\n+  int base_disable_count = notify_jvmti_events() ? 1 : 0;\n+  return java_lang_Thread::VTMS_transition_disable_count(vthread) > 0\n+         || global_start_transition_disable_count() > base_disable_count\n+         JVMTI_ONLY(|| (JvmtiVTSuspender::is_vthread_suspended(java_lang_Thread::thread_id(vthread)) || thread->is_suspended()));\n+}\n+\n+void MountUnmountDisabler::start_transition(JavaThread* current, oop vthread, bool is_mount, bool is_thread_end) {\n+  assert(!java_lang_Thread::is_in_VTMS_transition(vthread), \"\");\n+  assert(!current->is_in_VTMS_transition(), \"\");\n+  Handle vth = Handle(current, vthread);\n+  JVMTI_ONLY(JVMTIStartTransition jst(current, vthread, is_mount, is_thread_end);)\n+\n+  java_lang_Thread::set_is_in_VTMS_transition(vth(), true);\n+  current->set_is_in_VTMS_transition(true);\n+\n+  \/\/ Prevent loads of disable conditions from floating up.\n+  OrderAccess::storeload();\n+\n+  while (is_start_transition_disabled(current, vth())) {\n+    java_lang_Thread::set_is_in_VTMS_transition(vth(), false);\n+    current->set_is_in_VTMS_transition(false);\n+    {\n+      \/\/ Block while transitions are disabled\n+      MonitorLocker ml(VTMSTransition_lock);\n+      while (is_start_transition_disabled(current, vth())) {\n+        ml.wait(200);\n+      }\n+    }\n+\n+    \/\/ Try to start transition again...\n+    java_lang_Thread::set_is_in_VTMS_transition(vth(), true);\n+    current->set_is_in_VTMS_transition(true);\n+    OrderAccess::storeload();\n+  }\n+\n+  \/\/ Start of the critical section. We need an acquire fence to prevent future memory\n+  \/\/ operations to be ordered before we read the disabled conditions. But if this is\n+  \/\/ a mount, this is already guaranteed by the fences in VirtualThread.mount which will\n+  \/\/ be executed once we go back to Java. If this is an unmount, the handshake that the\n+  \/\/ disabler executed against this carrier thread already provided the needed synchronization.\n+  \/\/ This matches the release fence in xx_enable_for_one()\/xx_enable_for_all().\n+}\n+\n+void MountUnmountDisabler::end_transition(JavaThread* current, oop vthread, bool is_mount, bool is_thread_start) {\n+  assert(java_lang_Thread::is_in_VTMS_transition(vthread), \"\");\n+  assert(current->is_in_VTMS_transition(), \"\");\n+  Handle vth = Handle(current, vthread);\n+  JVMTI_ONLY(JVMTIEndTransition jst(current, vthread, is_mount, is_thread_start);)\n+\n+  \/\/ End of the critical section. We need a release fence here to prevent previous memory\n+  \/\/ operations to be ordered after we mark the thread as outside transition. But if this\n+  \/\/ is an unmount, this is already guaranteed by the fences previously executed in\n+  \/\/ VirtualThread.unmount. If this is a mount, the only thing that needs to be ordered is\n+  \/\/ the setting of carrierThread, since the handshake that the disabler will execute against\n+  \/\/ the carrier thread will already provide the needed synchronization. This order is already\n+  \/\/ guaranteed by the fences in VirtualThread.mount.\n+  \/\/ This matches the acquire fence in xx_disable_for_one()\/xx_disable_for_all().\n+\n+  java_lang_Thread::set_is_in_VTMS_transition(vth(), false);\n+  current->set_is_in_VTMS_transition(false);\n+\n+  \/\/ Unblock waiting transition disablers.\n+  if (active_disablers() > 0) {\n+    MonitorLocker ml(VTMSTransition_lock);\n+    ml.notify_all();\n+  }\n+}\n+\n+\/\/ disable VTMS transitions for one virtual thread\n+\/\/ disable VTMS transitions for all threads if thread is nullptr or a platform thread\n+MountUnmountDisabler::MountUnmountDisabler(oop thread_oop)\n+  : _is_exclusive(false),\n+    _is_self(false)\n+{\n+  if (!Continuations::enabled()) {\n+    return; \/\/ MountUnmountDisabler is no-op without virtual threads\n+  }\n+  if (Thread::current_or_null() == nullptr) {\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n+  }\n+  JavaThread* current = JavaThread::current();\n+  assert(!current->is_in_VTMS_transition(), \"\");\n+\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+  if (thread_oop == nullptr ||\n+      (!is_virtual && thread_oop == current->threadObj()) ||\n+      (is_virtual && thread_oop == current->vthread())) {\n+    _is_self = true;\n+    return; \/\/ no need for current thread to disable and enable transitions for itself\n+  }\n+\n+  \/\/ Target can be virtual or platform thread.\n+  \/\/ If target is a platform thread then we have to disable VTMS transitions for all threads.\n+  \/\/ It is by several reasons:\n+  \/\/ - carrier threads can mount virtual threads which may cause incorrect behavior\n+  \/\/ - there is no mechanism to disable transitions for a specific carrier thread yet\n+  if (is_virtual) {\n+    _vthread = Handle(current, thread_oop);\n+    VTMS_transition_disable_for_one(); \/\/ disable VTMS transitions for one virtual thread\n+  } else {\n+    VTMS_transition_disable_for_all(); \/\/ disable VTMS transitions for all virtual threads\n+  }\n+}\n+\n+\/\/ disable VTMS transitions for all virtual threads\n+MountUnmountDisabler::MountUnmountDisabler(bool exclusive)\n+  : _is_exclusive(exclusive),\n+    _is_self(false)\n+{\n+  if (!Continuations::enabled()) {\n+    return; \/\/ MountUnmountDisabler is no-op without virtual threads\n+  }\n+  if (Thread::current_or_null() == nullptr) {\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n+  }\n+  assert(!JavaThread::current()->is_in_VTMS_transition(), \"\");\n+  VTMS_transition_disable_for_all();\n+}\n+\n+MountUnmountDisabler::~MountUnmountDisabler() {\n+  if (!Continuations::enabled()) {\n+    return; \/\/ MountUnmountDisabler is a no-op without virtual threads\n+  }\n+  if (Thread::current_or_null() == nullptr) {\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n+  }\n+  if (_is_self) {\n+    return; \/\/ no need for current thread to disable and enable transitions for itself\n+  }\n+  if (_vthread() != nullptr) {\n+    VTMS_transition_enable_for_one(); \/\/ enable VTMS transitions for one virtual thread\n+  } else {\n+    VTMS_transition_enable_for_all(); \/\/ enable VTMS transitions for all virtual threads\n+  }\n+}\n+\n+\/\/ disable VTMS transitions for one virtual thread\n+void\n+MountUnmountDisabler::VTMS_transition_disable_for_one() {\n+  MonitorLocker ml(VTMSTransition_lock);\n+  while (exclusive_operation_ongoing()) {\n+    ml.wait(10);\n+  }\n+\n+  inc_active_disablers();\n+  java_lang_Thread::inc_VTMS_transition_disable_count(_vthread());\n+\n+  \/\/ Prevent load of transition flag from floating up.\n+  OrderAccess::storeload();\n+\n+  while (java_lang_Thread::is_in_VTMS_transition(_vthread())) {\n+    ml.wait(10); \/\/ wait while the virtual thread is in transition\n+  }\n+\n+  \/\/ Start of the critical region. Prevent future memory\n+  \/\/ operations to be ordered before we read the transition flag.\n+  \/\/ This matches the release fence in end_transition().\n+  OrderAccess::acquire();\n+  DEBUG_ONLY(JavaThread::current()->set_is_VTMS_transition_disabler(true);)\n+}\n+\n+\/\/ disable VTMS transitions for all virtual threads\n+void\n+MountUnmountDisabler::VTMS_transition_disable_for_all() {\n+  JavaThread* thread = JavaThread::current();\n+\n+  MonitorLocker ml(VTMSTransition_lock);\n+  while (exclusive_operation_ongoing()) {\n+    ml.wait(10);\n+  }\n+  if (_is_exclusive) {\n+    set_exclusive_operation_ongoing(true);\n+    while (active_disablers() > 0) {\n+      ml.wait(10);\n+    }\n+  }\n+  inc_active_disablers();\n+  inc_global_start_transition_disable_count();\n+\n+  \/\/ Prevent loads of transition flag from floating up. Technically not\n+  \/\/ required since JavaThreadIteratorWithHandle includes full fence.\n+  OrderAccess::storeload();\n+\n+  \/\/ Block while some mount\/unmount transitions are in progress.\n+  \/\/ Debug version fails and prints diagnostic information.\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    while (jt->is_in_VTMS_transition()) {\n+      ml.wait(10);\n+    }\n+  }\n+\n+  \/\/ Start of the critical region. Prevent future memory\n+  \/\/ operations to be ordered before we read the transition flags.\n+  \/\/ This matches the release fence in end_transition().\n+  OrderAccess::acquire();\n+  DEBUG_ONLY(thread->set_is_VTMS_transition_disabler(true);)\n+}\n+\n+\/\/ enable VTMS transitions for one virtual thread\n+void\n+MountUnmountDisabler::VTMS_transition_enable_for_one() {\n+  assert(java_lang_VirtualThread::is_instance(_vthread()), \"\");\n+\n+  \/\/ End of the critical section. Prevent previous memory operations to\n+  \/\/ be ordered after we clear the clear the disable transition flag.\n+  \/\/ This matches the equivalent acquire fence in start_transition().\n+  OrderAccess::release();\n+\n+  MonitorLocker ml(VTMSTransition_lock);\n+  dec_active_disablers();\n+  java_lang_Thread::dec_VTMS_transition_disable_count(_vthread());\n+  if (java_lang_Thread::VTMS_transition_disable_count(_vthread()) == 0) {\n+    ml.notify_all();\n+  }\n+  DEBUG_ONLY(JavaThread::current()->set_is_VTMS_transition_disabler(false);)\n+}\n+\n+\/\/ enable VTMS transitions for all virtual threads\n+void\n+MountUnmountDisabler::VTMS_transition_enable_for_all() {\n+  JavaThread* thread = JavaThread::current();\n+\n+  \/\/ End of the critical section. Prevent previous memory operations to\n+  \/\/ be ordered after we clear the clear the disable transition flag.\n+  \/\/ This matches the equivalent acquire fence in start_transition().\n+  OrderAccess::release();\n+\n+  MonitorLocker ml(VTMSTransition_lock);\n+  if (exclusive_operation_ongoing()) {\n+    set_exclusive_operation_ongoing(false);\n+  }\n+  dec_active_disablers();\n+  dec_global_start_transition_disable_count();\n+  int base_disable_count = notify_jvmti_events() ? 1 : 0;\n+  if (global_start_transition_disable_count() == base_disable_count || _is_exclusive) {\n+    ml.notify_all();\n+  }\n+  DEBUG_ONLY(thread->set_is_VTMS_transition_disabler(false);)\n+}\n+\n+int MountUnmountDisabler::global_start_transition_disable_count() {\n+  assert(_global_start_transition_disable_count >= 0, \"\");\n+  return AtomicAccess::load(&_global_start_transition_disable_count);\n+}\n+\n+void MountUnmountDisabler::inc_global_start_transition_disable_count() {\n+  assert(VTMSTransition_lock->owned_by_self() || SafepointSynchronize::is_at_safepoint(), \"Must be locked\");\n+  assert(_global_start_transition_disable_count >= 0, \"\");\n+  AtomicAccess::store(&_global_start_transition_disable_count, _global_start_transition_disable_count + 1);\n+}\n+\n+void MountUnmountDisabler::dec_global_start_transition_disable_count() {\n+  assert(VTMSTransition_lock->owned_by_self() || SafepointSynchronize::is_at_safepoint(), \"Must be locked\");\n+  assert(_global_start_transition_disable_count > 0, \"\");\n+  AtomicAccess::store(&_global_start_transition_disable_count, _global_start_transition_disable_count - 1);\n+}\n+\n+bool MountUnmountDisabler::exclusive_operation_ongoing() {\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  return _exclusive_operation_ongoing;\n+}\n+\n+void MountUnmountDisabler::set_exclusive_operation_ongoing(bool val) {\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  assert(_exclusive_operation_ongoing != val, \"\");\n+  _exclusive_operation_ongoing = val;\n+}\n+\n+int MountUnmountDisabler::active_disablers() {\n+  assert(_active_disablers >= 0, \"\");\n+  return AtomicAccess::load(&_active_disablers);\n+}\n+\n+void MountUnmountDisabler::inc_active_disablers() {\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  assert(_active_disablers >= 0, \"\");\n+  _active_disablers++;\n+}\n+\n+void MountUnmountDisabler::dec_active_disablers() {\n+  assert(VTMSTransition_lock->owned_by_self(), \"Must be locked\");\n+  assert(_active_disablers > 0, \"\");\n+  _active_disablers--;\n+}\n+\n+bool MountUnmountDisabler::notify_jvmti_events() {\n+  return _notify_jvmti_events;\n+}\n+\n+void MountUnmountDisabler::set_notify_jvmti_events(bool val, bool is_onload) {\n+  if (val == _notify_jvmti_events || !DoJVMTIVirtualThreadTransitions) return;\n+\n+  \/\/ Force slow path on start\/end vthread transitions for JVMTI bookkeeping.\n+  \/\/ 'val' is always true except with WhiteBox methods for testing purposes.\n+  if (is_onload) {\n+    \/\/ Skip existing increment methods since asserts will fail.\n+    assert(val && _global_start_transition_disable_count == 0, \"\");\n+    AtomicAccess::inc(&_global_start_transition_disable_count);\n+  } else {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"\");\n+    if (val) {\n+      inc_global_start_transition_disable_count();\n+    } else {\n+      dec_global_start_transition_disable_count();\n+    }\n+  }\n+  log_trace(continuations,tracking)(\"%s _notify_jvmti_events, _global_start_transition_disable_count=%d\", val ? \"enabling\" : \"disabling\", _global_start_transition_disable_count);\n+  _notify_jvmti_events = val;\n+}\n","filename":"src\/hotspot\/share\/runtime\/mountUnmountDisabler.cpp","additions":430,"deletions":0,"binary":false,"changes":430,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_MOUNTUNMOUNTDISABLER_HPP\n+#define SHARE_RUNTIME_MOUNTUNMOUNTDISABLER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+\n+class JavaThread;\n+\n+class MountUnmountDisabler : public AnyObj {\n+  static volatile int _global_start_transition_disable_count;\n+  static volatile int _active_disablers;\n+  static bool    _exclusive_operation_ongoing;\n+\n+  bool _is_exclusive;    \/\/ currently only for suspender or resumer\n+  bool _is_virtual;      \/\/ target thread is virtual\n+  bool _is_self;         \/\/ MountUnmountDisabler is a no-op for current platform, carrier or virtual thread\n+  Handle _vthread;       \/\/ virtual thread to disable transitions for, no-op if it is a platform thread\n+\n+  \/\/DEBUG_ONLY(static void print_info();)\n+  void VTMS_transition_disable_for_one();\n+  void VTMS_transition_disable_for_all();\n+  void VTMS_transition_enable_for_one();\n+  void VTMS_transition_enable_for_all();\n+\n+ public:\n+  \/\/ parameter is_SR: suspender or resumer\n+  MountUnmountDisabler(bool exlusive = false);\n+  MountUnmountDisabler(oop thread_oop);\n+  ~MountUnmountDisabler();\n+\n+  static int global_start_transition_disable_count();\n+  static void inc_global_start_transition_disable_count();\n+  static void dec_global_start_transition_disable_count();\n+\n+  static volatile int* global_start_transition_disable_count_address() {\n+    return &_global_start_transition_disable_count;\n+  }\n+\n+  static bool exclusive_operation_ongoing();\n+  static void set_exclusive_operation_ongoing(bool val);\n+\n+  static int active_disablers();\n+  static void inc_active_disablers();\n+  static void dec_active_disablers();\n+\n+  static void start_transition(JavaThread* thread, oop vthread, bool is_mount, bool is_thread_end);\n+  static void end_transition(JavaThread* thread, oop vthread, bool is_mount, bool is_thread_start);\n+\n+  static bool is_start_transition_disabled(JavaThread* thread, oop vthread);\n+\n+  \/\/ enable notifications from VirtualThread about Mount\/Unmount events\n+  static bool _notify_jvmti_events;\n+  static bool notify_jvmti_events();\n+  static void set_notify_jvmti_events(bool val, bool is_onload = false);\n+  static bool* notify_jvmti_events_address() {\n+    return &_notify_jvmti_events;\n+  }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_MOUNTUNMOUNTDISABLER_HPP\n","filename":"src\/hotspot\/share\/runtime\/mountUnmountDisabler.hpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-Monitor* JvmtiVTMSTransition_lock     = nullptr;\n+Monitor* VTMSTransition_lock          = nullptr;\n@@ -268,1 +268,1 @@\n-  MUTEX_DEFN(JvmtiVTMSTransition_lock        , PaddedMonitor, safepoint);   \/\/ used for Virtual Thread Mount State transition management\n+  MUTEX_DEFN(VTMSTransition_lock             , PaddedMonitor, safepoint);   \/\/ used for Virtual Thread Mount State transition management\n@@ -364,1 +364,1 @@\n-  MUTEX_DEFL(JvmtiThreadState_lock          , PaddedMutex  , JvmtiVTMSTransition_lock);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n+  MUTEX_DEFL(JvmtiThreadState_lock          , PaddedMutex  , VTMSTransition_lock);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-extern Monitor* JvmtiVTMSTransition_lock;        \/\/ a lock for Virtual Thread Mount State transition (VTMS transition) management\n+extern Monitor* VTMSTransition_lock;             \/\/ a lock for Virtual Thread Mount State transition (VTMS transition) management\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -732,28 +732,0 @@\n-#if INCLUDE_JVMTI\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_start(oopDesc* vt, jboolean hide, JavaThread* current))\n-  assert(hide == JNI_FALSE, \"must be VTMS transition finish\");\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_start(vthread);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_end(oopDesc* vt, jboolean hide, JavaThread* current))\n-  assert(hide == JNI_TRUE, \"must be VTMS transition start\");\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_end(vthread);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_mount(oopDesc* vt, jboolean hide, JavaThread* current))\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_mount(vthread, hide);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-\n-JRT_ENTRY(void, SharedRuntime::notify_jvmti_vthread_unmount(oopDesc* vt, jboolean hide, JavaThread* current))\n-  jobject vthread = JNIHandles::make_local(const_cast<oopDesc*>(vt));\n-  JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount(vthread, hide);\n-  JNIHandles::destroy_local(vthread);\n-JRT_END\n-#endif \/\/ INCLUDE_JVMTI\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -320,8 +320,0 @@\n-#if INCLUDE_JVMTI\n-  \/\/ Functions for JVMTI notifications\n-  static void notify_jvmti_vthread_start(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_end(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_mount(oopDesc* vt, jboolean hide, JavaThread* current);\n-  static void notify_jvmti_vthread_unmount(oopDesc* vt, jboolean hide, JavaThread* current);\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -202,12 +202,0 @@\n-\/\/ do_jvmti_stub(name)\n-#if INCLUDE_JVMTI\n-#define C2_JVMTI_STUBS_DO(do_jvmti_stub)                               \\\n-  do_jvmti_stub(notify_jvmti_vthread_start)                            \\\n-  do_jvmti_stub(notify_jvmti_vthread_end)                              \\\n-  do_jvmti_stub(notify_jvmti_vthread_mount)                            \\\n-  do_jvmti_stub(notify_jvmti_vthread_unmount)                          \\\n-\n-#else\n-#define C2_JVMTI_STUBS_DO(do_jvmti_stub)\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -218,1 +206,0 @@\n-\/\/ do_jvmti_stub(name)\n@@ -228,2 +215,0 @@\n-\/\/ do_jvmti_stub generates a JVMTI stub as an IR intrinsic which\n-\/\/ employs jump 0, and requires no special access\n@@ -231,1 +216,1 @@\n-#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)                   \\\n+#define C2_STUBS_DO(do_blob, do_stub)                                  \\\n@@ -242,1 +227,0 @@\n-  C2_JVMTI_STUBS_DO(do_jvmti_stub)                                     \\\n@@ -249,0 +233,4 @@\n+  do_stub(vthread_start, 0, false, false)                              \\\n+  do_stub(vthread_end, 0, false, false)                                \\\n+  do_stub(vthread_start_transition, 0, false, false)                   \\\n+  do_stub(vthread_end_transition, 0, false, false)                     \\\n@@ -251,1 +239,1 @@\n-#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)\n+#define C2_STUBS_DO(do_blob, do_stub)\n@@ -1193,3 +1181,0 @@\n-\/\/ ignore do_jvmti_stub(name) declarations\n-#define DO_JVMTI_STUB_EMPTY1(stub_name)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -512,8 +512,0 @@\n-#define PROCESS_C2_JVMTI_STUB(name)                               \\\n-  process_c2_blob(_group_cursor, _blob_cursor,                    \\\n-                  _stub_cursor, _entry_cursor,                    \\\n-                  \"C2 Runtime \" # name \"_blob\",                   \\\n-                  BlobId:: JOIN3(c2, name, id),                   \\\n-                  StubId:: JOIN3(c2, name, id),                   \\\n-                  EntryId:: JOIN3(c2, name, id));                 \\\n-\n@@ -613,1 +605,1 @@\n-  C2_STUBS_DO(PROCESS_C2_BLOB, PROCESS_C2_STUB, PROCESS_C2_JVMTI_STUB);\n+  C2_STUBS_DO(PROCESS_C2_BLOB, PROCESS_C2_STUB);\n@@ -640,1 +632,0 @@\n-#undef PROCESS_C2_JVMTI_STUB\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n@@ -180,2 +179,1 @@\n-              C2_DECLARE_TAG4,\n-              C2_DECLARE_TAG1)\n+              C2_DECLARE_TAG4)\n@@ -217,1 +215,0 @@\n-#define C2_DECLARE_TAG1(name) JOIN3(c2, name, id) ,\n@@ -230,2 +227,1 @@\n-              C2_DECLARE_TAG4,\n-              C2_DECLARE_TAG1)\n+              C2_DECLARE_TAG4)\n@@ -310,1 +306,1 @@\n-\/\/ blob, stub or JVMTI stub all of which have a single unique entry\n+\/\/ blob, stub all of which have a single unique entry\n@@ -321,3 +317,0 @@\n-#define C2_DECLARE_JVMTI_STUB_TAG(name)                               \\\n-  JOIN3(c2, name, id),                                                \\\n-\n@@ -369,2 +362,1 @@\n-              C2_DECLARE_STUB_TAG,\n-              C2_DECLARE_JVMTI_STUB_TAG)\n+              C2_DECLARE_STUB_TAG)\n@@ -385,1 +377,0 @@\n-#undef C2_DECLARE_JVMTI_STUB_TAG\n@@ -405,1 +396,1 @@\n-  0 C2_STUBS_DO(COUNT2, COUNT4, COUNT1)\n+  0 C2_STUBS_DO(COUNT2, COUNT4)\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.hpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-  JVMTI_ONLY(assert(!_target->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");)\n@@ -101,0 +100,1 @@\n+    assert(!self->is_in_VTMS_transition(), \"no suspend allowed in VTMS transition\");\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1182,0 +1182,1 @@\n+  OopHandle _carrier_thread;\n@@ -1185,1 +1186,1 @@\n-  GetThreadSnapshotHandshakeClosure(Handle thread_h, JavaThread* java_thread):\n+  GetThreadSnapshotHandshakeClosure(Handle thread_h):\n@@ -1187,1 +1188,1 @@\n-    _thread_h(thread_h), _java_thread(java_thread),\n+    _thread_h(thread_h), _java_thread(nullptr),\n@@ -1278,0 +1279,1 @@\n+    _java_thread = th != nullptr ? JavaThread::cast(th) : nullptr;\n@@ -1283,3 +1285,3 @@\n-        oop carrier_thread = java_lang_VirtualThread::carrier_thread(_thread_h());\n-        assert(carrier_thread != nullptr, \"should only get here for a mounted vthread\");\n-        _thread_status = java_lang_Thread::get_thread_status(carrier_thread);\n+        _carrier_thread = OopHandle(oop_storage(), java_lang_VirtualThread::carrier_thread(_thread_h()));\n+        assert(_carrier_thread.resolve() == _java_thread->threadObj(), \"\");\n+        _thread_status = java_lang_Thread::get_thread_status(_carrier_thread.resolve());\n@@ -1462,2 +1464,1 @@\n-  Handle thread_h(THREAD, thread_oop);\n-  bool is_virtual = java_lang_VirtualThread::is_instance(thread_h());  \/\/ Deals with null\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);  \/\/ Deals with null\n@@ -1469,42 +1470,0 @@\n-  \/\/ wrapper to auto delete JvmtiVTMSTransitionDisabler\n-  class TransitionDisabler {\n-    JvmtiVTMSTransitionDisabler* _transition_disabler;\n-  public:\n-    TransitionDisabler(): _transition_disabler(nullptr) {}\n-    ~TransitionDisabler() {\n-      reset();\n-    }\n-    void init(jobject jthread) {\n-      _transition_disabler = new (mtInternal) JvmtiVTMSTransitionDisabler(jthread);\n-    }\n-    void reset() {\n-      if (_transition_disabler != nullptr) {\n-        delete _transition_disabler;\n-        _transition_disabler = nullptr;\n-      }\n-    }\n-  } transition_disabler;\n-\n-  Handle carrier_thread;\n-  if (is_virtual) {\n-    \/\/ 1st need to disable mount\/unmount transitions\n-    transition_disabler.init(jthread);\n-\n-    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(thread_h()));\n-    if (carrier_thread != nullptr) {\n-      \/\/ Note: The java_thread associated with this carrier_thread may not be\n-      \/\/ protected by the ThreadsListHandle above. There could have been an\n-      \/\/ unmount and remount after the ThreadsListHandle above was created\n-      \/\/ and before the JvmtiVTMSTransitionDisabler was created. However, as\n-      \/\/ we have disabled transitions, if we are mounted on it, then it cannot\n-      \/\/ terminate and so is safe to handshake with.\n-      java_thread = java_lang_Thread::thread(carrier_thread());\n-    } else {\n-      \/\/ We may have previously found a carrier but the virtual thread has unmounted\n-      \/\/ after that, so clear that previous reference.\n-      java_thread = nullptr;\n-    }\n-  } else {\n-    java_thread = java_lang_Thread::thread(thread_h());\n-  }\n-\n@@ -1512,4 +1471,4 @@\n-  GetThreadSnapshotHandshakeClosure cl(thread_h, java_thread);\n-  if (java_thread == nullptr) {\n-    \/\/ unmounted vthread, execute on the current thread\n-    cl.do_thread(nullptr);\n+  Handle thread_h(THREAD, thread_oop);\n+  GetThreadSnapshotHandshakeClosure cl(thread_h);\n+  if (java_lang_VirtualThread::is_instance(thread_oop)) {\n+    Handshake::execute(&cl, thread_oop);\n@@ -1520,3 +1479,0 @@\n-  \/\/ all info is collected, can enable transitions.\n-  transition_disabler.reset();\n-\n@@ -1572,1 +1528,1 @@\n-  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n+  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), cl._carrier_thread.resolve());\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-                    vthread.notifyJvmtiStart(); \/\/ notify JVMTI\n+                    vthread.endFirstTransition();\n@@ -253,1 +253,1 @@\n-                        vthread.notifyJvmtiEnd(); \/\/ notify JVMTI\n+                        vthread.startFinalTransition();\n@@ -482,2 +482,1 @@\n-        \/\/ notify JVMTI before mount\n-        notifyJvmtiMount(\/*hide*\/true);\n+        startTransition(\/*is_mount*\/true);\n@@ -524,2 +523,1 @@\n-        \/\/ notify JVMTI after unmount\n-        notifyJvmtiUnmount(\/*hide*\/false);\n+        endTransition(\/*is_mount*\/false);\n@@ -534,1 +532,1 @@\n-        notifyJvmtiUnmount(\/*hide*\/true);\n+        startTransition(\/*is_mount*\/false);\n@@ -538,1 +536,1 @@\n-            notifyJvmtiMount(\/*hide*\/false);\n+            endTransition(\/*is_mount*\/true);\n@@ -1396,1 +1394,1 @@\n-    private native void notifyJvmtiStart();\n+    private native void endFirstTransition();\n@@ -1400,1 +1398,1 @@\n-    private native void notifyJvmtiEnd();\n+    private native void startFinalTransition();\n@@ -1404,1 +1402,1 @@\n-    private native void notifyJvmtiMount(boolean hide);\n+    private native void startTransition(boolean is_mount);\n@@ -1408,1 +1406,1 @@\n-    private native void notifyJvmtiUnmount(boolean hide);\n+    private native void endTransition(boolean is_mount);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,4 +35,4 @@\n-    { \"notifyJvmtiStart\",          \"()V\",  (void *)&JVM_VirtualThreadStart },\n-    { \"notifyJvmtiEnd\",            \"()V\",  (void *)&JVM_VirtualThreadEnd },\n-    { \"notifyJvmtiMount\",          \"(Z)V\", (void *)&JVM_VirtualThreadMount },\n-    { \"notifyJvmtiUnmount\",        \"(Z)V\", (void *)&JVM_VirtualThreadUnmount },\n+    { \"endFirstTransition\",       \"()V\",  (void *)&JVM_VirtualThreadStart },\n+    { \"startFinalTransition\",     \"()V\",  (void *)&JVM_VirtualThreadEnd },\n+    { \"startTransition\",          \"(Z)V\", (void *)&JVM_VirtualThreadStartTransition },\n+    { \"endTransition\",            \"(Z)V\", (void *)&JVM_VirtualThreadEndTransition },\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=transitions\n+ * @bug 8364343\n+ * @summary HotSpotDiagnosticMXBean.dumpThreads while virtual threads are parking and unparking\n+ * @requires vm.continuations\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=200 DumpThreadsWhenParking 1000 1 100\n+ *\/\n+\n+\/*\n+ * @test id=concurrent\n+ * @summary HotSpotDiagnosticMXBean.dumpThreads from concurrent threads while virtual threads\n+ *    are parking and unparking\n+ * @requires vm.continuations\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=200 DumpThreadsWhenParking 100 4 100\n+ *\/\n+\n+\/*\n+ * @test id=concurrent_gcstress\n+ * @summary HotSpotDiagnosticMXBean.dumpThreads from concurrent threads while virtual threads\n+ *    are parking and unparking\n+ * @requires vm.debug == true & vm.continuations\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=200 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=10000 DumpThreadsWhenParking 100 4 100\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.IntStream;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.threaddump.ThreadDump;\n+\n+public class DumpThreadsWhenParking {\n+\n+    public static void main(String... args) throws Throwable {\n+        int vthreadCount = Integer.parseInt(args[0]);\n+        int concurrentDumpers = Integer.parseInt(args[1]);\n+        int iterations = Integer.parseInt(args[2]);\n+\n+        \/\/ need >=2 carriers to make progress\n+        VThreadRunner.ensureParallelism(2);\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor();\n+             var pool = Executors.newCachedThreadPool()) {\n+\n+            \/\/ start virtual threads that park and unpark\n+            var done = new AtomicBoolean();\n+            var phaser = new Phaser(vthreadCount + 1);\n+            for (int i = 0; i < vthreadCount; i++) {\n+                executor.submit(() -> {\n+                    phaser.arriveAndAwaitAdvance();\n+                    while (!done.get()) {\n+                        LockSupport.parkNanos(1);\n+                    }\n+                });\n+            }\n+            \/\/ wait for all virtual threads to start so all have a non-empty stack\n+            System.out.format(\"Waiting for %d virtual threads to start ...%n\", vthreadCount);\n+            phaser.arriveAndAwaitAdvance();\n+            System.out.format(\"%d virtual threads started.%n\", vthreadCount);\n+\n+            \/\/ Bash on HotSpotDiagnosticMXBean.dumpThreads from >= 1 threads\n+            try {\n+                String containerName = Objects.toIdentityString(executor);\n+                for (int i = 1; i <= iterations; i++) {\n+                    System.out.format(\"%s %d of %d ...%n\", Instant.now(), i, iterations);\n+                    List<Future<Void>> futures = IntStream.of(0, concurrentDumpers)\n+                            .mapToObj(_ -> pool.submit(() -> dumpThreads(containerName, vthreadCount)))\n+                            .toList();\n+                    for (Future<?> future : futures) {\n+                        future.get();\n+                    }\n+                }\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invoke HotSpotDiagnosticMXBean.dumpThreads to generate a thread dump to a file in\n+     * JSON format. Parse the thread dump to ensure it contains a thread grouping with\n+     * the expected number of virtual threads.\n+     *\/\n+    static Void dumpThreads(String containerName, int expectedVThreadCount) throws Exception {\n+        long tid = Thread.currentThread().threadId();\n+        Path file = Path.of(\"threads-\" + tid + \".json\").toAbsolutePath();\n+        Files.deleteIfExists(file);\n+        ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class)\n+                .dumpThreads(file.toString(), HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n+\n+        \/\/ read and parse the dump\n+        String jsonText = Files.readString(file);\n+        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+        var container = threadDump.findThreadContainer(containerName).orElse(null);\n+        if (container == null) {\n+            fail(containerName + \" not found in thread dump\");\n+        }\n+\n+        \/\/ check expected virtual thread count\n+        long threadCount = container.threads().count();\n+        if (threadCount != expectedVThreadCount) {\n+            fail(threadCount + \" virtual threads found, expected \" + expectedVThreadCount);\n+        }\n+\n+        \/\/ check each thread is a virtual thread with stack frames\n+        container.threads().forEach(t -> {\n+            if (!t.isVirtual()) {\n+                fail(\"#\" + t.tid() + \"(\" + t.name() + \") is not a virtual thread\");\n+            }\n+            long stackFrameCount = t.stack().count();\n+            if (stackFrameCount == 0) {\n+                fail(\"#\" + t.tid() + \" has empty stack\");\n+            }\n+        });\n+        return null;\n+    }\n+\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWhenParking.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}