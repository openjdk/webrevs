{"files":[{"patch":"@@ -192,0 +192,1 @@\n+    authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n@@ -134,2 +134,1 @@\n-  intptr_t* lspp = f.addr_at(frame::interpreter_frame_last_sp_offset);\n-  *lspp = f.unextended_sp() - f.fp();\n+  f.interpreter_frame_set_last_sp(f.unextended_sp());\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n@@ -132,2 +132,1 @@\n-  intptr_t* lspp = f.addr_at(frame::interpreter_frame_last_sp_offset);\n-  *lspp = f.unextended_sp() - f.fp();\n+  f.interpreter_frame_set_last_sp(f.unextended_sp());\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n@@ -131,2 +131,1 @@\n-  intptr_t* lspp = f.addr_at(frame::interpreter_frame_last_sp_offset);\n-  *lspp = f.unextended_sp() - f.fp();\n+  f.interpreter_frame_set_last_sp(f.unextended_sp());\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-inline void FreezeBase::prepare_freeze_interpreted_top_frame(const frame& f) {\n+inline void FreezeBase::prepare_freeze_interpreted_top_frame(frame& f) {\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-  static inline void prepare_freeze_interpreted_top_frame(const frame& f);\n+  static inline void prepare_freeze_interpreted_top_frame(frame& f);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -807,1 +807,1 @@\n-ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current) {\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current) {\n@@ -809,2 +809,2 @@\n-  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ The JavaThread* locking_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the locking_thread == Thread::current() or is suspended throughout the call by\n@@ -825,2 +825,2 @@\n-    \/\/                   is anonymous and the inflating_thread owns the\n-    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   is anonymous and the locking_thread owns the\n+    \/\/                   object lock, then we make the locking_thread\n@@ -828,1 +828,1 @@\n-    \/\/                   the inflating_thread's lock stack.\n+    \/\/                   the locking_thread's lock stack.\n@@ -838,3 +838,3 @@\n-          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(inflating_thread);\n-        size_t removed = inflating_thread->lock_stack().remove(object);\n+          locking_thread != nullptr && locking_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(locking_thread);\n+        size_t removed = locking_thread->lock_stack().remove(object);\n@@ -847,1 +847,1 @@\n-    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/ Could be fast-locked either by the locking_thread or by some other thread.\n@@ -851,2 +851,2 @@\n-    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ the locking_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the locking_thread. Otherwise, we set the ObjectMonitor's owner\n@@ -859,1 +859,1 @@\n-      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      bool own = locking_thread != nullptr && locking_thread->lock_stack().contains(object);\n@@ -861,2 +861,2 @@\n-        \/\/ Owned by inflating_thread.\n-        monitor->set_owner(inflating_thread);\n+        \/\/ Owned by locking_thread.\n+        monitor->set_owner(locking_thread);\n@@ -872,1 +872,1 @@\n-          size_t removed = inflating_thread->lock_stack().remove(object);\n+          size_t removed = locking_thread->lock_stack().remove(object);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current);\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, Thread* current);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2370,1 +2370,1 @@\n-oop ObjectWaiter::vthread() {\n+oop ObjectWaiter::vthread() const {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,9 +64,9 @@\n-  JavaThread* thread() { return _thread; }\n-  bool is_vthread()    { return _thread == nullptr; }\n-  uint8_t state()      { return TState; }\n-  ObjectMonitor* monitor() { return _monitor; }\n-  bool is_monitorenter()   { return !_is_wait; }\n-  bool is_wait()           { return _is_wait; }\n-  bool notified()          { return _notified; }\n-  bool at_reenter()        { return _at_reenter; }\n-  oop vthread();\n+  JavaThread* thread()      const { return _thread; }\n+  bool is_vthread()         const { return _thread == nullptr; }\n+  uint8_t state()           const { return TState; }\n+  ObjectMonitor* monitor()  const { return _monitor; }\n+  bool is_monitorenter()    const { return !_is_wait; }\n+  bool is_wait()            const { return _is_wait; }\n+  bool notified()           const { return _notified; }\n+  bool at_reenter()         const { return _at_reenter; }\n+  oop vthread() const;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1440,2 +1440,2 @@\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* inflating_thread requires that the inflating_thread == Thread::current() or\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* locking_thread, oop object, const InflateCause cause) {\n+  \/\/ The JavaThread* locking_thread requires that the locking_thread == Thread::current() or\n@@ -1455,2 +1455,2 @@\n-    \/\/                   inflating_thread owns the object lock, then we\n-    \/\/                   make the inflating_thread the ObjectMonitor owner.\n+    \/\/                   locking_thread owns the object lock, then we\n+    \/\/                   make the locking_thread the ObjectMonitor owner.\n@@ -1467,1 +1467,1 @@\n-      if (inf->has_anonymous_owner() && inflating_thread != nullptr) {\n+      if (inf->has_anonymous_owner() && locking_thread != nullptr) {\n@@ -1469,1 +1469,1 @@\n-        if (inflating_thread->is_lock_owned((address)inf->stack_locker())) {\n+        if (locking_thread->is_lock_owned((address)inf->stack_locker())) {\n@@ -1471,1 +1471,1 @@\n-          inf->set_owner_from_anonymous(inflating_thread);\n+          inf->set_owner_from_anonymous(locking_thread);\n@@ -1553,2 +1553,2 @@\n-      if (inflating_thread != nullptr && inflating_thread->is_lock_owned((address)mark.locker())) {\n-        m->set_owner(inflating_thread);\n+      if (locking_thread != nullptr && locking_thread->is_lock_owned((address)mark.locker())) {\n+        m->set_owner(locking_thread);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-  static ObjectMonitor* inflate_impl(JavaThread* inflating_thread, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(JavaThread* locking_thread, oop obj, const InflateCause cause);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}