{"files":[{"patch":"@@ -1681,3 +1681,2 @@\n-  \/\/ On preemption JVMTI state rebinding has already happened so get it always directly from the oop.\n-  JvmtiThreadState *state = java_lang_Thread::jvmti_thread_state(JNIHandles::resolve(vthread));\n-  if (state == NULL) {\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n+  if (state == nullptr) {\n@@ -1702,1 +1701,1 @@\n-          (*callback)(env->jvmti_external(), jem.jni_env(), vthread);\n+          (*callback)(env->jvmti_external(), jem.jni_env(), jem.jni_thread());\n@@ -2878,2 +2877,1 @@\n-  current->rebind_to_jvmti_thread_state_of(vthread());\n-  JvmtiVTMSTransitionDisabler::finish_VTMS_transition((jthread)vthread.raw_value(), \/* is_mount *\/ true);\n+  JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vthread.raw_value(), false);\n@@ -2885,2 +2883,1 @@\n-  JvmtiVTMSTransitionDisabler::start_VTMS_transition((jthread)vthread.raw_value(), \/* is_mount *\/ true);\n-  current->rebind_to_jvmti_thread_state_of(current->threadObj());\n+  JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)vthread.raw_value(), true);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -670,6 +670,0 @@\n-\n-  if (thread->pending_jvmti_unmount_event()) {\n-    assert(java_lang_VirtualThread::is_preempted(JNIHandles::resolve(vthread)), \"should be marked preempted\");\n-    JvmtiExport::post_vthread_unmount(vthread);\n-    thread->set_pending_jvmti_unmount_event(false);\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-      JvmtiVTMSTransitionDisabler::start_VTMS_transition((jthread)_vthread.raw_value(), \/* is_mount *\/ false);\n+      JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)_vthread.raw_value(), true);\n@@ -107,1 +107,1 @@\n-        JvmtiVTMSTransitionDisabler::finish_VTMS_transition((jthread)_vthread.raw_value(), false);\n+        JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)_vthread.raw_value(), false);\n@@ -112,9 +112,0 @@\n-    } else {\n-      if (jvmti_present) {\n-        _target->rebind_to_jvmti_thread_state_of(_target->threadObj());\n-        if (JvmtiExport::should_post_vthread_unmount()) {\n-          \/\/ We are inside the VTMS transition already so we will post the event\n-          \/\/ once we finish it in JvmtiVTMSTransitionDisabler::VTMS_unmount_end().\n-          _target->set_pending_jvmti_unmount_event(true);\n-        }\n-      }\n@@ -127,1 +118,1 @@\n-static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* target, oop vthread) {\n+static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* target) {\n@@ -141,1 +132,1 @@\n-  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(target, vthread)) NOT_JVMTI(true);\n+  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(target)) NOT_JVMTI(true);\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1611,11 +1611,1 @@\n-    current->rebind_to_jvmti_thread_state_of(vth());\n-    JvmtiVTMSTransitionDisabler::finish_VTMS_transition((jthread)vth.raw_value(), \/* is_mount *\/ true);\n-\n-    \/\/ If pending_jvmti_unmount_event() is true here we are in the preemption\n-    \/\/ cancelled case. Since we never unmounted we don't post the mount event\n-    \/\/ and just clear the pending unmount flag.\n-    if (current->pending_jvmti_unmount_event()) {\n-      current->set_pending_jvmti_unmount_event(false);\n-    } else if (JvmtiExport::should_post_vthread_mount()) {\n-      JvmtiExport::post_vthread_mount((jthread)vth.raw_value());\n-    }\n+    JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vth.raw_value(), false);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -458,1 +458,0 @@\n-  _pending_jvmti_unmount_event(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -331,1 +331,0 @@\n-  bool                  _pending_jvmti_unmount_event;    \/\/ When preempting we post unmount event at unmount end rather than start\n@@ -725,3 +724,0 @@\n-  bool pending_jvmti_unmount_event()             { return _pending_jvmti_unmount_event; }\n-  void set_pending_jvmti_unmount_event(bool val) { _pending_jvmti_unmount_event = val; }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+const int MAX_COUNT = 50;\n@@ -41,0 +42,32 @@\n+  jvmtiError err;\n+  jint count = 0;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+\n+  va_list ap;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n+\n+  va_start(ap, jvmti);\n+  jni = va_arg(ap, JNIEnv*);\n+  thread = va_arg(ap, jthread);\n+  va_end(ap);\n+\n+  err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count);\n+  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetStackTrace call\");\n+\n+  \/\/ Verify top 3 methods to filter events from Continuation::try_preempt().\n+  const int verification_count = 3;\n+  const char* expected_methods[verification_count] = {\"yieldContinuation\", \"park\", \"parkVirtualThread\"};\n+\n+  if (count < verification_count) return;\n+\n+  for (int idx = 0; idx < verification_count; idx++) {\n+    char *methodName = nullptr;\n+\n+    err = jvmti->GetMethodName(frameInfo[idx].method, &methodName, nullptr, nullptr);\n+    check_jvmti_status(jni, err, \"event handler: error in JVMTI GetMethodName call\");\n+\n+    if (strcmp(methodName, expected_methods[idx]) != 0) {\n+      return;\n+    }\n+  }\n@@ -45,0 +78,32 @@\n+  jvmtiError err;\n+  jint count = 0;\n+  jvmtiFrameInfo frameInfo[MAX_COUNT];\n+\n+  va_list ap;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n+\n+  va_start(ap, jvmti);\n+  jni = va_arg(ap, JNIEnv*);\n+  thread = va_arg(ap, jthread);\n+  va_end(ap);\n+\n+  err = jvmti->GetStackTrace(thread, 0, MAX_COUNT, frameInfo, &count);\n+  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetStackTrace call\");\n+\n+  \/\/ Verify top 3 methods to filter events from Continuation::try_preempt().\n+  const int verification_count = 3;\n+  const char* expected_methods[verification_count] = {\"run\", \"enter0\", \"enter\"};\n+\n+  if (count < verification_count) return;\n+\n+  for (int idx = 0; idx < verification_count; idx++) {\n+    char *methodName = nullptr;\n+\n+    err = jvmti->GetMethodName(frameInfo[idx].method, &methodName, nullptr, nullptr);\n+    check_jvmti_status(jni, err, \"event handler: error in JVMTI GetMethodName call\");\n+\n+    if (strcmp(methodName, expected_methods[idx]) != 0) {\n+      return;\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/libVThreadEventTest.cpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}