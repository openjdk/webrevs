{"files":[{"patch":"@@ -166,1 +166,1 @@\n-  \/\/ calls to VirtualThread.switchToCarrierThread will temporary change _vthread\n+  \/\/ calls to VirtualThread.switchToCarrierThread will temporarily change _vthread\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,1 +347,1 @@\n-  alloced_monitor->set_owner_anonymous();\n+  alloced_monitor->set_anonymous_owner();\n@@ -744,1 +744,1 @@\n-  if (monitor->has_owner_anonymous()) {\n+  if (monitor->has_anonymous_owner()) {\n@@ -789,1 +789,1 @@\n-      if (monitor->has_owner_anonymous()) {\n+      if (monitor->has_anonymous_owner()) {\n@@ -837,1 +837,1 @@\n-      if (inf->has_owner_anonymous() &&\n+      if (inf->has_anonymous_owner() &&\n@@ -865,1 +865,1 @@\n-        monitor->set_owner_anonymous();\n+        monitor->set_anonymous_owner();\n@@ -955,1 +955,1 @@\n-    if (monitor->has_owner_anonymous()) {\n+    if (monitor->has_anonymous_owner()) {\n@@ -1076,1 +1076,1 @@\n-      if (monitor->has_owner_anonymous() && lock_stack.contains(object)) {\n+      if (monitor->has_anonymous_owner() && lock_stack.contains(object)) {\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1539,5 +1539,2 @@\n-\/\/ complete_exit exits a lock returning recursion count\n-\/\/ complete_exit requires an inflated monitor\n-\/\/ The _owner field is not always the Thread addr even with an\n-\/\/ inflated monitor, e.g. the monitor can be inflated by a non-owning\n-\/\/ thread due to contention.\n+\/\/ Exits the monitor returning recursion count. _owner should\n+\/\/ be set to current's tid, i.e. no ANONYMOUS_OWNER allowed.\n@@ -1546,9 +1543,0 @@\n-\n-  if (!has_owner(current)) {\n-    if (LockingMode == LM_LEGACY && has_stack_locker(current)) {\n-      assert(_recursions == 0, \"internal state error\");\n-      set_owner_from_BasicLock(current);  \/\/ Convert from BasicLock* to Thread*.\n-      _recursions = 0;\n-    }\n-  }\n-\n@@ -1556,0 +1544,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -301,2 +301,0 @@\n-  \/\/ Set _owner field to tid of current thread; current value must be ANONYMOUS_OWNER.\n-  void      set_owner_from_BasicLock(JavaThread* current);\n@@ -325,2 +323,2 @@\n-  bool has_owner_anonymous() const { return owner_raw() == ANONYMOUS_OWNER; }\n-  void set_owner_anonymous() {\n+  bool has_anonymous_owner() const { return owner_raw() == ANONYMOUS_OWNER; }\n+  void set_anonymous_owner() {\n@@ -333,3 +331,0 @@\n-  \/\/ Returns true if BasicLock* stored in _stack_locker\n-  \/\/ points to current's stack, false otherwise.\n-  bool has_stack_locker(JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  if (has_owner_anonymous()) {\n+  if (has_anonymous_owner()) {\n@@ -128,4 +128,0 @@\n-inline bool ObjectMonitor::has_stack_locker(JavaThread* current) {\n-  return has_owner_anonymous() && current->is_lock_owned((address)stack_locker());\n-}\n-\n@@ -194,16 +190,0 @@\n-\/\/ Simply set _owner to the tid of current. Current owner must be anonymous.\n-inline void ObjectMonitor::set_owner_from_BasicLock(JavaThread* current) {\n-  BasicLock* basic_lock_p = stack_locker();\n-\n-  set_stack_locker(nullptr); \/\/ first\n-  assert(has_owner_anonymous(), \"\");\n-\n-  \/\/ Non-null owner field to non-null owner field is safe without\n-  \/\/ cmpxchg() as long as all readers can tolerate either flavor.\n-  Atomic::store(&_owner, owner_from(current));\n-  log_trace(monitorinflation, owner)(\"set_owner_from_BasicLock(): mid=\"\n-                                     INTPTR_FORMAT \", basic_lock_p=\"\n-                                     INTPTR_FORMAT \", new_value=\" INT64_FORMAT,\n-                                     p2i(this), p2i(basic_lock_p), owner_from(current));\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-  assert(!monitor->has_owner_anonymous(), \"must not be\");\n+  assert(!monitor->has_anonymous_owner(), \"must not be\");\n@@ -1467,1 +1467,1 @@\n-      if (inf->has_owner_anonymous() && inflating_thread != nullptr) {\n+      if (inf->has_anonymous_owner() && inflating_thread != nullptr) {\n@@ -1470,1 +1470,2 @@\n-          inf->set_owner_from_BasicLock(inflating_thread);\n+          inf->set_stack_locker(nullptr);\n+          inf->set_owner_from_anonymous(inflating_thread);\n@@ -1558,1 +1559,1 @@\n-        m->set_owner_anonymous();  \/\/ second\n+        m->set_anonymous_owner();  \/\/ second\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1268,1 +1268,1 @@\n-  if (monitor->has_owner_anonymous()) {\n+  if (monitor->has_anonymous_owner()) {\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-    if (monitor->has_owner_anonymous()) {\n+    if (monitor->has_anonymous_owner()) {\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-     * counter is off-heap and shared with the VM to allow it assign thread\n+     * counter is off-heap and shared with the VM to allow it to assign thread\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -631,1 +631,1 @@\n-            byte nonce;\n+            byte seqNo;\n@@ -634,1 +634,1 @@\n-                nonce = 0;  \/\/ not used\n+                seqNo = 0;  \/\/ not used\n@@ -639,1 +639,1 @@\n-                    nonce = ++timedWaitSeqNo;\n+                    seqNo = ++timedWaitSeqNo;\n@@ -662,1 +662,1 @@\n-                waitTimeoutTask = schedule(() -> waitTimeoutExpired(nonce), waitTimeout, MILLISECONDS);\n+                waitTimeoutTask = schedule(() -> waitTimeoutExpired(seqNo), waitTimeout, MILLISECONDS);\n@@ -948,1 +948,1 @@\n-    private void waitTimeoutExpired(byte nounce) {\n+    private void waitTimeoutExpired(byte seqNo) {\n@@ -953,1 +953,1 @@\n-                if (nounce != timedWaitSeqNo) {\n+                if (seqNo != timedWaitSeqNo) {\n@@ -1397,1 +1397,1 @@\n-     * Returns a lock object to coordinating timed-wait setup and timeout handling.\n+     * Returns a lock object for coordinating timed-wait setup and timeout handling.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}