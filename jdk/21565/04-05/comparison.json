{"files":[{"patch":"@@ -444,8 +444,18 @@\n-void stackChunkOopDesc::copy_lockstack(oop* dst) {\n-  int cnt = lockstack_size();\n-\n-  if (!(is_gc_mode() || requires_barriers())) {\n-    oop* lockstack_start = (oop*)start_address();\n-    for (int i = 0; i < cnt; i++) {\n-      dst[i] = lockstack_start[i];\n-      assert(oopDesc::is_oop(dst[i]), \"not an oop\");\n+void stackChunkOopDesc::transfer_lockstack(oop* dst) {\n+  const bool requires_gc_barriers = is_gc_mode() || requires_barriers();\n+  const bool requires_uncompress = has_bitmap() && UseCompressedOops;\n+  const auto load_and_clear_obj = [&](intptr_t* at) -> oop {\n+    if (requires_gc_barriers) {\n+      if (requires_uncompress) {\n+        oop value = HeapAccess<>::oop_load(reinterpret_cast<narrowOop*>(at));\n+        HeapAccess<>::oop_store(reinterpret_cast<narrowOop*>(at), nullptr);\n+        return value;\n+      } else {\n+        oop value = HeapAccess<>::oop_load(reinterpret_cast<oop*>(at));\n+        HeapAccess<>::oop_store(reinterpret_cast<oop*>(at), nullptr);\n+        return value;\n+      }\n+    } else {\n+      oop value = *reinterpret_cast<oop*>(at);\n+      HeapAccess<>::oop_store(reinterpret_cast<oop*>(at), nullptr);\n+      return value;\n@@ -453,2 +463,1 @@\n-    return;\n-  }\n+  };\n@@ -456,14 +465,6 @@\n-  if (has_bitmap() && UseCompressedOops) {\n-    intptr_t* lockstack_start = start_address();\n-    for (int i = 0; i < cnt; i++) {\n-      oop mon_owner = HeapAccess<>::oop_load((narrowOop*)&lockstack_start[i]);\n-      assert(oopDesc::is_oop(mon_owner), \"not an oop\");\n-      dst[i] = mon_owner;\n-    }\n-  } else {\n-    intptr_t* lockstack_start = start_address();\n-    for (int i = 0; i < cnt; i++) {\n-      oop mon_owner = HeapAccess<>::oop_load((oop*)&lockstack_start[i]);\n-      assert(oopDesc::is_oop(mon_owner), \"not an oop\");\n-      dst[i] = mon_owner;\n-    }\n+  const int cnt = lockstack_size();\n+  intptr_t* lockstack_start = start_address();\n+  for (int i = 0; i < cnt; i++) {\n+    oop mon_owner = load_and_clear_obj(&lockstack_start[i]);\n+    assert(oopDesc::is_oop(mon_owner), \"not an oop\");\n+    dst[i] = mon_owner;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  void copy_lockstack(oop* start);\n+  void transfer_lockstack(oop* start);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  void freeze_lockstack();\n+  void freeze_lockstack(stackChunkOop chunk);\n@@ -542,2 +542,1 @@\n-void FreezeBase::freeze_lockstack() {\n-  stackChunkOop chunk = _cont.tail();\n+void FreezeBase::freeze_lockstack(stackChunkOop chunk) {\n@@ -547,1 +546,1 @@\n-  chunk->set_lockstack_size((uint8_t)_monitors_in_lockstack);\n+  chunk->set_lockstack_size(checked_cast<uint8_t>(_monitors_in_lockstack));\n@@ -779,1 +778,1 @@\n-    freeze_lockstack();\n+    freeze_lockstack(chunk);\n@@ -1070,1 +1069,1 @@\n-    freeze_lockstack();\n+    freeze_lockstack(chunk);\n@@ -1920,0 +1919,2 @@\n+  void thaw_lockstack(stackChunkOop chunk);\n+\n@@ -2086,0 +2087,12 @@\n+void ThawBase::thaw_lockstack(stackChunkOop chunk) {\n+  int lockStackSize = chunk->lockstack_size();\n+  assert(lockStackSize > 0 && lockStackSize <= LockStack::CAPACITY, \"\");\n+\n+  oop tmp_lockstack[LockStack::CAPACITY];\n+  chunk->transfer_lockstack(tmp_lockstack);\n+  _thread->lock_stack().move_from_address(tmp_lockstack, lockStackSize);\n+\n+  chunk->set_lockstack_size(0);\n+  chunk->set_has_lockstack(false);\n+}\n+\n@@ -2240,9 +2253,1 @@\n-    int lockStackSize = chunk->lockstack_size();\n-    assert(lockStackSize > 0, \"should be\");\n-\n-    oop tmp_lockstack[8];\n-    chunk->copy_lockstack(tmp_lockstack);\n-    _thread->lock_stack().move_from_address(tmp_lockstack, lockStackSize);\n-\n-    chunk->set_lockstack_size(0);\n-    chunk->set_has_lockstack(false);\n+    thaw_lockstack(chunk);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -645,0 +645,5 @@\n+    \/**\n+     * Thread identifier assigned to the primordial thread.\n+     *\/\n+    static final long PRIMORDIAL_TID = 3;\n+\n@@ -647,4 +652,4 @@\n-     * 2 as this class cannot be used during early startup to generate the\n-     * identifier for the primordial thread. The counter is off-heap and\n-     * shared with the VM to allow it assign thread identifiers to non-Java\n-     * threads.\n+     * {@link Thread#PRIMORDIAL_TID}&nbsp;+1 as this class cannot be used during\n+     * early startup to generate the identifier for the primordial thread. The\n+     * counter is off-heap and shared with the VM to allow it assign thread\n+     * identifiers to non-Java threads.\n@@ -731,1 +736,1 @@\n-            this.tid = 3;  \/\/ primordial thread\n+            this.tid = PRIMORDIAL_TID;  \/\/ primordial thread\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    private byte timedWaitNonce;\n+    private byte timedWaitSeqNo;\n@@ -639,1 +639,1 @@\n-                    nonce = ++timedWaitNonce;\n+                    nonce = ++timedWaitSeqNo;\n@@ -953,1 +953,1 @@\n-                if (nounce != timedWaitNonce) {\n+                if (nounce != timedWaitSeqNo) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}