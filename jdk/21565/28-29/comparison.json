{"files":[{"patch":"@@ -272,1 +272,1 @@\n-        : *(intptr_t**)(hf.sp() - frame::sender_sp_offset);\n+        : *(intptr_t**)(hf.sp() - 2);\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2106,1 +2106,1 @@\n-jlong java_lang_VirtualThread::waitTimeout(oop vthread) {\n+jlong java_lang_VirtualThread::timeout(oop vthread) {\n@@ -2110,1 +2110,1 @@\n-void java_lang_VirtualThread::set_waitTimeout(oop vthread, jlong value) {\n+void java_lang_VirtualThread::set_timeout(oop vthread, jlong value) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -584,2 +584,2 @@\n-  static jlong waitTimeout(oop vthread);\n-  static void set_waitTimeout(oop vthread, jlong value);\n+  static jlong timeout(oop vthread);\n+  static void set_timeout(oop vthread, jlong value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1149,1 +1149,1 @@\n-JVM_VirtualThreadPinnedEvent(jint reasonCode, jstring reasonString);\n+JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass clazz, jstring op);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,2 @@\n-  <Event name=\"VirtualThreadPinned\" category=\"Java Virtual Machine, Runtime\" label=\"Virtual Thread Pinned\" thread=\"true\" stackTrace=\"true\" startTime=\"false\">\n+  <Event name=\"VirtualThreadPinned\" category=\"Java Virtual Machine, Runtime\" label=\"Virtual Thread Pinned\" thread=\"true\" stackTrace=\"true\">\n+    <Field type=\"string\" name=\"blockingOperation\" label=\"Blocking operation\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1108,16 +1108,0 @@\n-\n-#if INCLUDE_JFR\n-      ContinuationEntry* ce = jt->last_continuation();\n-      if (ce != nullptr && ce->is_virtual_thread()) {\n-        EventVirtualThreadPinned e;\n-        if (e.should_commit()) {\n-          ResourceMark rm(jt);\n-          char reason[256];\n-          jio_snprintf(reason, sizeof reason, \"Waiting for initialization of klass %s\", external_name());\n-          e.set_pinnedReason(reason);\n-          e.set_carrierThread(JFR_JVM_THREAD_ID(THREAD));\n-          e.commit();\n-        }\n-      }\n- #endif\n-\n@@ -1622,0 +1606,1 @@\n+    ThreadInClassInitializer ticl(THREAD, this); \/\/ Track class being initialized\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3962,1 +3962,1 @@\n-JVM_ENTRY_NO_ENV(void, JVM_VirtualThreadPinnedEvent(jint reasonCode, jstring reasonString))\n+JVM_ENTRY(void, JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass ignored, jstring op))\n@@ -3964,2 +3964,5 @@\n-  EventVirtualThreadPinned e;\n-  if (e.should_commit()) {\n+  freeze_result result = THREAD->last_freeze_fail_result();\n+  assert(result != freeze_ok, \"sanity check\");\n+  EventVirtualThreadPinned event(UNTIMED);\n+  event.set_starttime(THREAD->last_freeze_fail_time());\n+  if (event.should_commit()) {\n@@ -3967,5 +3970,2 @@\n-    \/\/ ignore reason code for now\n-    const char *reason = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(reasonString));\n-    e.set_pinnedReason(reason);\n-    e.set_carrierThread(JFR_JVM_THREAD_ID(THREAD));\n-    e.commit();\n+    const char *str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(op));\n+    THREAD->post_vthread_pinned_event(&event, str, result);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  int _preempt_result;\n+  freeze_result _result;\n@@ -69,1 +69,1 @@\n-    _vthread(t, t->vthread()), _target(t), _preempt_result(freeze_pinned_native), _failed(false) {\n+    _vthread(t, t->vthread()), _target(t), _result(freeze_pinned_native), _failed(false) {\n@@ -104,1 +104,1 @@\n-    if (_preempt_result != freeze_ok) {\n+    if (_result != freeze_ok) {\n@@ -123,1 +123,1 @@\n-  void set_preempt_result(int res) { _preempt_result = res; }\n+  void set_result(freeze_result res) { _result = res; }\n@@ -144,1 +144,1 @@\n-typedef int (*FreezeContFnT)(JavaThread*, intptr_t*);\n+typedef freeze_result (*FreezeContFnT)(JavaThread*, intptr_t*);\n@@ -156,1 +156,1 @@\n-int Continuation::try_preempt(JavaThread* target, oop continuation) {\n+freeze_result Continuation::try_preempt(JavaThread* target, oop continuation) {\n@@ -169,1 +169,1 @@\n-  int res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(target, target->last_Java_sp());\n+  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(target, target->last_Java_sp());\n@@ -171,1 +171,1 @@\n-  JVMTI_ONLY(jubm.set_preempt_result(res);)\n+  JVMTI_ONLY(jubm.set_result(res);)\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  static int try_preempt(JavaThread* target, oop continuation);\n+  static freeze_result try_preempt(JavaThread* target, oop continuation);\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-template<typename ConfigT, bool preempt> static inline int freeze_internal(JavaThread* current, intptr_t* const sp);\n+template<typename ConfigT, bool preempt> static inline freeze_result freeze_internal(JavaThread* current, intptr_t* const sp);\n@@ -221,1 +221,1 @@\n-  return ConfigT::freeze(current, sp);\n+  return checked_cast<int>(ConfigT::freeze(current, sp));\n@@ -258,1 +258,1 @@\n-  static int freeze(JavaThread* thread, intptr_t* const sp) {\n+  static freeze_result freeze(JavaThread* thread, intptr_t* const sp) {\n@@ -262,1 +262,1 @@\n-  static int freeze_preempt(JavaThread* thread, intptr_t* const sp) {\n+  static freeze_result freeze_preempt(JavaThread* thread, intptr_t* const sp) {\n@@ -1415,1 +1415,3 @@\n-    oopDesc::set_klass_gap(mem, 0);\n+    if (oopDesc::has_klass_gap()) {\n+      oopDesc::set_klass_gap(mem, 0);\n+    }\n@@ -1669,1 +1671,1 @@\n-static inline int freeze_epilog(ContinuationWrapper& cont) {\n+static inline freeze_result freeze_epilog(ContinuationWrapper& cont) {\n@@ -1674,1 +1676,1 @@\n-  return 0;\n+  return freeze_ok;\n@@ -1677,1 +1679,1 @@\n-static int freeze_epilog(JavaThread* thread, ContinuationWrapper& cont, freeze_result res) {\n+static freeze_result freeze_epilog(JavaThread* thread, ContinuationWrapper& cont, freeze_result res) {\n@@ -1679,0 +1681,1 @@\n+    JFR_ONLY(thread->set_last_freeze_fail_result(res);)\n@@ -1688,1 +1691,1 @@\n-static int preempt_epilog(ContinuationWrapper& cont, freeze_result res, frame& old_last_frame) {\n+static freeze_result preempt_epilog(ContinuationWrapper& cont, freeze_result res, frame& old_last_frame) {\n@@ -1702,1 +1705,1 @@\n-static inline int freeze_internal(JavaThread* current, intptr_t* const sp) {\n+static inline freeze_result freeze_internal(JavaThread* current, intptr_t* const sp) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  _class_being_initialized(nullptr),\n@@ -2330,0 +2331,35 @@\n+\n+#if INCLUDE_JFR\n+void JavaThread::set_last_freeze_fail_result(freeze_result result) {\n+  assert(result != freeze_ok, \"sanity check\");\n+  _last_freeze_fail_result = result;\n+  _last_freeze_fail_time = Ticks::now();\n+}\n+\n+\/\/ Post jdk.VirtualThreadPinned event\n+void JavaThread::post_vthread_pinned_event(EventVirtualThreadPinned* event, const char* op, freeze_result result) {\n+  assert(result != freeze_ok, \"sanity check\");\n+  if (event->should_commit()) {\n+    char reason[256];\n+    if (class_to_be_initialized() != nullptr) {\n+      ResourceMark rm(this);\n+      jio_snprintf(reason, sizeof reason, \"Waited for initialization of %s by another thread\",\n+                   class_to_be_initialized()->external_name());\n+      event->set_pinnedReason(reason);\n+    } else if (class_being_initialized() != nullptr) {\n+      ResourceMark rm(this);\n+      jio_snprintf(reason, sizeof(reason), \"VM call to %s.<clinit> on stack\",\n+                   class_being_initialized()->external_name());\n+      event->set_pinnedReason(reason);\n+    } else if (result == freeze_pinned_native) {\n+      event->set_pinnedReason(\"Native or VM frame on stack\");\n+    } else {\n+      jio_snprintf(reason, sizeof(reason), \"Freeze or preempt failed (%d)\", result);\n+      event->set_pinnedReason(reason);\n+    }\n+    event->set_blockingOperation(op);\n+    event->set_carrierThread(JFR_JVM_THREAD_ID(this));\n+    event->commit();\n+  }\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -81,0 +82,2 @@\n+class EventVirtualThreadPinned;\n+\n@@ -1215,0 +1218,4 @@\n+  \/\/ Track executing class initializer, see ThreadInClassInitializer\n+  void set_class_being_initialized(InstanceKlass* k);\n+  InstanceKlass* class_being_initialized() const;\n+\n@@ -1217,0 +1224,1 @@\n+  InstanceKlass* _class_being_initialized;\n@@ -1220,0 +1228,7 @@\n+\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result _last_freeze_fail_result;\n+  Ticks _last_freeze_fail_time;\n+#endif\n+\n@@ -1228,0 +1243,9 @@\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result last_freeze_fail_result() { return _last_freeze_fail_result; }\n+  Ticks& last_freeze_fail_time() { return _last_freeze_fail_time; }\n+  void set_last_freeze_fail_result(freeze_result result);\n+#endif\n+  void post_vthread_pinned_event(EventVirtualThreadPinned* event, const char* op, freeze_result result) NOT_JFR_RETURN();\n+\n+\n@@ -1334,0 +1358,13 @@\n+class ThreadInClassInitializer : public StackObj {\n+  JavaThread* _thread;\n+  InstanceKlass* _previous;\n+ public:\n+  ThreadInClassInitializer(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = _thread->class_being_initialized();\n+    _thread->set_class_being_initialized(ik);\n+  }\n+  ~ThreadInClassInitializer() {\n+    _thread->set_class_being_initialized(_previous);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -244,0 +244,10 @@\n+inline void JavaThread::set_class_being_initialized(InstanceKlass* k) {\n+  assert(k != nullptr || _class_being_initialized != nullptr, \"incorrect usage\");\n+  assert(this == Thread::current(), \"Only the current thread can set this field\");\n+  _class_being_initialized = k;\n+}\n+\n+inline InstanceKlass* JavaThread::class_being_initialized() const {\n+  return _class_being_initialized;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,9 +122,0 @@\n-static void post_virtual_thread_pinned_event(JavaThread* current, const char* reason) {\n-  EventVirtualThreadPinned e;\n-  if (e.should_commit()) {\n-    e.set_pinnedReason(reason);\n-    e.set_carrierThread(JFR_JVM_THREAD_ID(current));\n-    e.commit();\n-  }\n-}\n-\n@@ -492,3 +483,3 @@\n-  EventJavaMonitorEnter event;\n-  if (event.is_started()) {\n-    event.set_monitorClass(object()->klass());\n+  EventJavaMonitorEnter enter_event;\n+  if (enter_event.is_started()) {\n+    enter_event.set_monitorClass(object()->klass());\n@@ -498,1 +489,1 @@\n-    event.set_address((uintptr_t)this);\n+    enter_event.set_address((uintptr_t)this);\n@@ -500,0 +491,3 @@\n+  EventVirtualThreadPinned vthread_pinned_event;\n+\n+  freeze_result result;\n@@ -520,1 +514,1 @@\n-      int result = Continuation::try_preempt(current, ce->cont_oop(current));\n+      result = Continuation::try_preempt(current, ce->cont_oop(current));\n@@ -540,5 +534,0 @@\n-      if (result == freeze_pinned_native) {\n-        post_virtual_thread_pinned_event(current, \"Native frame or <clinit> on stack\");\n-      } else if (result == freeze_unsupported) {\n-        post_virtual_thread_pinned_event(current, \"Native frame or <clinit> or monitors on stack\");\n-      }\n@@ -606,3 +595,9 @@\n-  if (event.should_commit()) {\n-    event.set_previousOwner(_previous_owner_tid);\n-    event.commit();\n+  if (enter_event.should_commit()) {\n+    enter_event.set_previousOwner(_previous_owner_tid);\n+    enter_event.commit();\n+  }\n+\n+  ContinuationEntry* ce = current->last_continuation();\n+  if (ce != nullptr && ce->is_virtual_thread()) {\n+    assert(result != freeze_ok, \"sanity check\");\n+    current->post_vthread_pinned_event(&vthread_pinned_event, \"Contended monitor enter\", result);\n@@ -610,0 +605,1 @@\n+\n@@ -1638,1 +1634,1 @@\n-      long timeout = java_lang_VirtualThread::waitTimeout(current->vthread());\n+      long timeout = java_lang_VirtualThread::timeout(current->vthread());\n@@ -1665,1 +1661,2 @@\n-  EventJavaMonitorWait event;\n+  EventJavaMonitorWait wait_event;\n+  EventVirtualThreadPinned vthread_pinned_event;\n@@ -1683,2 +1680,2 @@\n-    if (event.should_commit()) {\n-      post_monitor_wait_event(&event, this, 0, millis, false);\n+    if (wait_event.should_commit()) {\n+      post_monitor_wait_event(&wait_event, this, 0, millis, false);\n@@ -1692,0 +1689,1 @@\n+  freeze_result result;\n@@ -1694,1 +1692,1 @@\n-    int result = Continuation::try_preempt(current, ce->cont_oop(current));\n+    result = Continuation::try_preempt(current, ce->cont_oop(current));\n@@ -1700,10 +1698,0 @@\n-    if (result == freeze_pinned_native || result == freeze_unsupported) {\n-      const Klass* monitor_klass = object()->klass();\n-      if (!is_excluded(monitor_klass)) {\n-        if (result == freeze_pinned_native) {\n-          post_virtual_thread_pinned_event(current,\"Native frame or <clinit> on stack\");\n-        } else if (result == freeze_unsupported) {\n-          post_virtual_thread_pinned_event(current, \"Native frame or <clinit> or monitors on stack\");\n-        }\n-      }\n-    }\n@@ -1835,2 +1823,7 @@\n-    if (event.should_commit()) {\n-      post_monitor_wait_event(&event, this, node._notifier_tid, millis, ret == OS_TIMEOUT);\n+    if (wait_event.should_commit()) {\n+      post_monitor_wait_event(&wait_event, this, node._notifier_tid, millis, ret == OS_TIMEOUT);\n+    }\n+\n+    if (ce != nullptr && ce->is_virtual_thread()) {\n+      assert(result != freeze_ok, \"sanity check\");\n+      current->post_vthread_pinned_event(&vthread_pinned_event, \"Object.wait\", result);\n@@ -2038,1 +2031,1 @@\n-  java_lang_VirtualThread::set_waitTimeout(vthread, millis);\n+  java_lang_VirtualThread::set_timeout(vthread, millis);\n@@ -2068,3 +2061,3 @@\n-  EventJavaMonitorWait event;\n-  if (event.should_commit() || JvmtiExport::should_post_monitor_waited()) {\n-    vthread_monitor_waited_event(current, node, cont, &event, !was_notified && !node->_interrupted);\n+  EventJavaMonitorWait wait_event;\n+  if (wait_event.should_commit() || JvmtiExport::should_post_monitor_waited()) {\n+    vthread_monitor_waited_event(current, node, cont, &wait_event, !was_notified && !node->_interrupted);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":36,"deletions":43,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-            \/\/ emit JFR event\n-            virtualThreadPinnedEvent(reason.reasonCode(), reason.reasonString());\n@@ -264,7 +262,0 @@\n-    \/**\n-     * jdk.VirtualThreadPinned is emitted by HotSpot VM when pinned. Call into VM to\n-     * emit event to avoid having a JFR event in Java with the same name (but different ID)\n-     * to events emitted by the VM.\n-     *\/\n-    private static native void virtualThreadPinnedEvent(int reason, String reasonString);\n-\n@@ -836,0 +827,3 @@\n+\n+        \/\/ JFR jdk.VirtualThreadPinned event\n+        postPinnedEvent(\"LockSupport.park\");\n@@ -838,0 +832,8 @@\n+    \/**\n+     * Call into VM when pinned to record a JFR jdk.VirtualThreadPinned event.\n+     * Recording the event in the VM avoids having JFR event recorded in Java\n+     * with the same name, but different ID, to events recorded by the VM.\n+     *\/\n+    @Hidden\n+    private static native void postPinnedEvent(String op);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -60,16 +60,4 @@\n-        NATIVE(2, \"Native frame or <clinit> on stack\"),\n-        MONITOR(3, \"Monitor held\"),\n-        CRITICAL_SECTION(4, \"In critical section\");\n-\n-        private final int reasonCode;\n-        private final String reasonString;\n-        Pinned(int reasonCode, String reasonString) {\n-            this.reasonCode = reasonCode;\n-            this.reasonString = reasonString;\n-        }\n-        public int reasonCode() {\n-            return reasonCode;\n-        }\n-        public String reasonString() {\n-            return reasonString;\n-        }\n+        \/** Native frame on stack *\/ NATIVE,\n+        \/** Monitor held *\/          MONITOR,\n+        \/** In critical section *\/   CRITICAL_SECTION,\n+        \/** Exception (OOME\/SOE) *\/  EXCEPTION\n@@ -102,0 +90,1 @@\n+            case 5 -> Pinned.EXCEPTION;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#define THREAD \"Ljava\/lang\/Thread;\"\n+#define STR  \"Ljava\/lang\/String;\"\n@@ -40,0 +40,1 @@\n+    { \"postPinnedEvent\",           \"(\" STR \")V\", (void *)&JVM_VirtualThreadPinnedEvent },\n@@ -47,7 +48,0 @@\n-\n-JNIEXPORT void JNICALL\n-Java_java_lang_VirtualThread_virtualThreadPinnedEvent(JNIEnv *env, jclass ignored,\n-                                                      jint reasonCode, jstring reasonString)\n-{\n-    JVM_VirtualThreadPinnedEvent(reasonCode, reasonString);\n-}\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+      <setting name=\"threshold\">20 ms<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+      <setting name=\"threshold\">20 ms<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test parking when pinned and emitting the JFR VirtualThreadPinnedEvent throws\n- * @modules java.base\/jdk.internal.event jdk.management\n- * @library \/test\/lib\n- * @compile\/module=java.base jdk\/internal\/event\/VirtualThreadPinnedEvent.java\n- * @run junit\/othervm --enable-native-access=ALL-UNNAMED VirtualThreadPinnedEventThrows\n- *\/\n-\n-import java.lang.ref.Reference;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.locks.LockSupport;\n-import jdk.internal.event.VirtualThreadPinnedEvent;\n-\n-import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n-import jdk.test.lib.thread.VThreadPinner;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.BeforeAll;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class VirtualThreadPinnedEventThrows {\n-\n-    @BeforeAll\n-    static void setup() {\n-        \/\/ need >=2 carriers for testing pinning when main thread is a virtual thread\n-        if (Thread.currentThread().isVirtual()) {\n-            VThreadRunner.ensureParallelism(2);\n-        }\n-    }\n-\n-    \/**\n-     * Test parking when pinned and creating the VirtualThreadPinnedEvent fails with OOME.\n-     *\/\n-    @Test\n-    void testVirtualThreadPinnedEventCreateThrows() throws Exception {\n-        VirtualThreadPinnedEvent.setCreateThrows(true);\n-        try {\n-            testParkWhenPinned();\n-        } finally {\n-            VirtualThreadPinnedEvent.setCreateThrows(false);\n-        }\n-    }\n-\n-    \/**\n-     * Test parking when pinned and VirtualThreadPinnedEvent.begin fails with OOME.\n-     *\/\n-    @Test\n-    void testVirtualThreadPinnedEventBeginThrows() throws Exception {\n-        VirtualThreadPinnedEvent.setBeginThrows(true);\n-        try {\n-            testParkWhenPinned();\n-        } finally {\n-            VirtualThreadPinnedEvent.setBeginThrows(false);\n-        }\n-    }\n-\n-    \/**\n-     * Test parking when pinned and VirtualThreadPinnedEvent.commit fails with OOME.\n-     *\/\n-    @Test\n-    void testVirtualThreadPinnedEventCommitThrows() throws Exception {\n-        VirtualThreadPinnedEvent.setCommitThrows(true);\n-        try {\n-            testParkWhenPinned();\n-        } finally {\n-            VirtualThreadPinnedEvent.setCommitThrows(false);\n-        }\n-    }\n-\n-    \/**\n-     * Test parking a virtual thread when pinned.\n-     *\/\n-    private void testParkWhenPinned() throws Exception {\n-        var exception = new AtomicReference<Throwable>();\n-        var done = new AtomicBoolean();\n-        Thread thread = Thread.startVirtualThread(() -> {\n-            try {\n-                VThreadPinner.runPinned(() -> {\n-                    while (!done.get()) {\n-                        LockSupport.park();\n-                    }\n-                });\n-            } catch (Throwable e) {\n-                exception.set(e);\n-            }\n-        });\n-        try {\n-            \/\/ wait for thread to park\n-            Thread.State state;\n-            while ((state = thread.getState()) != Thread.State.WAITING) {\n-                assertTrue(state != Thread.State.TERMINATED);\n-                Thread.sleep(10);\n-            }\n-        } finally {\n-            done.set(true);\n-            LockSupport.unpark(thread);\n-            thread.join();\n-        }\n-        assertNull(exception.get());\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.event;\n-\n-\/**\n- * VirtualThreadPinnedEvent to optionally throw OOME at create, begin or commit time.\n- *\/\n-public class VirtualThreadPinnedEvent extends Event {\n-    private static boolean throwOnCreate;\n-    private static boolean throwOnBegin;\n-    private static boolean throwOnCommit;\n-\n-    public static void setCreateThrows(boolean value) {\n-        throwOnCreate = value;\n-    }\n-\n-    public static void setBeginThrows(boolean value) {\n-        throwOnBegin = value;\n-    }\n-\n-    public static void setCommitThrows(boolean value) {\n-        throwOnCommit = value;\n-    }\n-\n-    public VirtualThreadPinnedEvent() {\n-        if (throwOnCreate) {\n-            throw new OutOfMemoryError();\n-        }\n-    }\n-\n-    @Override\n-    public void begin() {\n-        if (throwOnBegin) {\n-            throw new OutOfMemoryError();\n-        }\n-    }\n-\n-    @Override\n-    public void commit() {\n-        if (throwOnCommit) {\n-            throw new OutOfMemoryError();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/java.base\/jdk\/internal\/event\/VirtualThreadPinnedEvent.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"}]}