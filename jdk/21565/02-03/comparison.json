{"files":[{"patch":"@@ -176,1 +176,1 @@\n-  if (waiter != nullptr && (waiter->is_monitorenter() || (waiter->is_wait() && (waiter->at_reenter() || waiter->notified())))) {\n+  if (waiter != nullptr && waiter->at_monitorenter()) {\n@@ -184,1 +184,4 @@\n-  return waiter != nullptr && waiter->is_wait() ? waiter->monitor() : nullptr;\n+  if (waiter != nullptr && waiter->is_wait()) {\n+    return waiter->monitor();\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1082,0 +1082,8 @@\n+    } else {\n+      assert(vthread != nullptr, \"no vthread oop\");\n+      oop cont = java_lang_VirtualThread::continuation(vthread);\n+      assert(cont != nullptr, \"vthread with no continuation\");\n+      stackChunkOop chunk = jdk_internal_vm_Continuation::tail(cont);\n+      assert(chunk != nullptr, \"unmounted vthread should have a chunk\");\n+      ObjectMonitor *mon = chunk->current_waiting_monitor();\n+      if (mon != nullptr) wait_obj = mon->object();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-  bool is_monitorenter()    const { return !_is_wait; }\n@@ -72,0 +71,1 @@\n+  bool at_monitorenter()    const { return !_is_wait || _at_reenter || _notified; }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    private static native void checkOwnedMonitor(Thread thread, int expectedCount);\n@@ -60,0 +61,1 @@\n+    private static volatile Thread waiter;\n@@ -76,0 +78,6 @@\n+            if (waiter == null) {\n+                try {\n+                    waiter = Thread.currentThread();\n+                    lock1.wait();\n+                } catch (InterruptedException e) {}\n+            }\n@@ -124,0 +132,7 @@\n+            \/\/ Wait for waiter to enter lock1.\n+            while (waiter == null) {}\n+            synchronized (lock1) {\n+                checkOwnedMonitor(waiter, 1);\n+                lock1.notify();\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadMonitorTest\/VThreadMonitorTest.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                    jthread thread, char* tname, jboolean is_vt, jobject monitor) {\n+                    jthread thread, char* tname, jboolean is_vt, jint expected_count) {\n@@ -138,2 +138,2 @@\n-  if (is_vt == JNI_TRUE && mcount < 2) {\n-    LOG(\"%s: FAIL: monitorCount for %s expected to be >= 2\\n\", func, tname);\n+  if (is_vt == JNI_TRUE && mcount != expected_count) {\n+    LOG(\"%s: FAIL: monitorCount for %s expected to be %d\\n\", func, tname, expected_count);\n@@ -189,1 +189,1 @@\n-                      vthread, vtname, JNI_TRUE, monitor);\n+                      vthread, vtname, JNI_TRUE, 2);\n@@ -191,1 +191,1 @@\n-                      cthread, ctname, JNI_FALSE, monitor);\n+                      cthread, ctname, JNI_FALSE, 2);\n@@ -355,0 +355,9 @@\n+JNIEXPORT void JNICALL\n+Java_VThreadMonitorTest_checkOwnedMonitor(JNIEnv *jni, jclass cls, jthread vthread, jint expected_count) {\n+  char* tname = get_thread_name(jvmti, jni, vthread);\n+\n+  check_owned_monitor(jvmti, jni, \"checkOwnedMonitor\", vthread, tname, JNI_TRUE, expected_count);\n+\n+  deallocate(jvmti, jni, (void*)tname);\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadMonitorTest\/libVThreadMonitorTest.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"}]}