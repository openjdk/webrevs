{"files":[{"patch":"@@ -1651,0 +1651,1 @@\n+  \/\/   str(rscratch2, Address(rthread, JavaThread::last_Java_pc_offset()));\n@@ -1652,1 +1653,0 @@\n-  \/\/   stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)))\n@@ -3695,0 +3695,1 @@\n+      \/\/ Make the anchor frame walkable\n@@ -3696,0 +3697,1 @@\n+      __ str(rscratch2, Address(rthread, JavaThread::last_Java_pc_offset()));\n@@ -3697,2 +3699,0 @@\n-      \/\/ Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()\n-      __ stp(zr, rscratch2, Address(__ pre(sp, -2 * wordSize)));\n@@ -3702,1 +3702,0 @@\n-      __ add(sp, sp, 2 * wordSize);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -295,22 +295,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  intptr_t* sp = top.sp();\n-  CodeBlob* cb = top.cb();\n-\n-  if (cb->frame_size() == 2) {\n-    \/\/ C2 runtime stub case. For aarch64 the real size of the c2 runtime stub is 2 words bigger\n-    \/\/ than what we think, i.e. size is 4. This is because the _last_Java_sp is not set to the\n-    \/\/ sp right before making the call to the VM, but rather it is artificially set 2 words above\n-    \/\/ this real sp so that we can store the return address at last_Java_sp[-1], and keep this\n-    \/\/ property where we can retrieve the last_Java_pc from the last_Java_sp. But that means that\n-    \/\/ once we return to the runtime stub, the code will adjust sp according to this real size.\n-    \/\/ So we must adjust the frame size back here and we copy lr\/rfp again.\n-    sp -= 2;\n-    sp[-2] = sp[0];\n-    sp[-1] = sp[1];\n-\n-    log_develop_trace(continuations, preempt)(\"adjusted sp for c2 runtime stub, initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT\n-                                              \" fp: \" INTPTR_FORMAT, p2i(sp + 2), p2i(sp), sp[-2]);\n-  }\n-  return sp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -553,5 +553,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  \/\/ Nothing to do\n-  return top.sp();\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -301,22 +301,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  intptr_t* sp = top.sp();\n-  CodeBlob* cb = top.cb();\n-\n-  if (cb->frame_size() == 2) {\n-    \/\/ C2 runtime stub case. For riscv64 the real size of the c2 runtime stub is 2 words bigger\n-    \/\/ than what we think, i.e. size is 4. This is because the _last_Java_sp is not set to the\n-    \/\/ sp right before making the call to the VM, but rather it is artificially set 2 words above\n-    \/\/ this real sp so that we can store the return address at last_Java_sp[-1], and keep this\n-    \/\/ property where we can retrieve the last_Java_pc from the last_Java_sp. But that means that\n-    \/\/ once we return to the runtime stub, the code will adjust sp according to this real size.\n-    \/\/ So we must adjust the frame size back here and we copy ra\/fp again.\n-    sp -= 2;\n-    sp[-2] = sp[0];\n-    sp[-1] = sp[1];\n-\n-    log_develop_trace(continuations, preempt)(\"adjusted sp for c2 runtime stub, initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT\n-                                              \" fp: \" INTPTR_FORMAT, p2i(sp + 2), p2i(sp), sp[-2]);\n-  }\n-  return sp;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1262,1 +1262,1 @@\n-  \/\/ for real runtime callouts it will be 9 instructions\n+  \/\/ for real runtime callouts it will be 8 instructions\n@@ -1264,5 +1264,4 @@\n-  \/\/   la(t0, retaddr)                ->  auipc + addi\n-  \/\/   addi(sp, sp, -2 * wordSize)    ->  addi\n-  \/\/   sd(t0, Address(sp, wordSize))  ->  sd\n-  \/\/   movptr(t1, addr, offset, t0)   ->  lui + lui + slli + add\n-  \/\/   jalr(t1, offset)               ->  jalr\n+  \/\/   la(t0, retaddr)                                             ->  auipc + addi\n+  \/\/   sd(t0, Address(xthread, JavaThread::last_Java_pc_offset())) ->  sd\n+  \/\/   movptr(t1, addr, offset, t0)                                ->  lui + lui + slli + add\n+  \/\/   jalr(t1, offset)                                            ->  jalr\n@@ -1276,1 +1275,1 @@\n-    return 9 * NativeInstruction::instruction_size;\n+    return 8 * NativeInstruction::instruction_size;\n@@ -2507,0 +2506,1 @@\n+      \/\/ Make the anchor frame walkable\n@@ -2508,3 +2508,1 @@\n-      \/\/ Leave a breadcrumb for JavaFrameAnchor::capture_last_Java_pc()\n-      __ addi(sp, sp, -2 * wordSize);\n-      __ sd(t0, Address(sp, wordSize));\n+      __ sd(t0, Address(xthread, JavaThread::last_Java_pc_offset()));\n@@ -2517,1 +2515,0 @@\n-      __ addi(sp, sp, 2 * wordSize);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -285,5 +285,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  \/\/ Nothing to do\n-  return top.sp();\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -94,5 +94,0 @@\n-inline intptr_t* ThawBase::possibly_adjust_frame(frame& top) {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -312,5 +312,1 @@\n-static void set_anchor(JavaThread* thread, intptr_t* sp, address pc = nullptr) {\n-  if (pc == nullptr) {\n-    pc = ContinuationHelper::return_address_at(\n-           sp - frame::sender_sp_ret_address_offset());\n-  }\n+static void set_anchor(JavaThread* thread, intptr_t* sp, address pc) {\n@@ -328,0 +324,6 @@\n+static void set_anchor(JavaThread* thread, intptr_t* sp) {\n+  address pc = ContinuationHelper::return_address_at(\n+           sp - frame::sender_sp_ret_address_offset());\n+  set_anchor(thread, sp, pc);\n+}\n+\n@@ -1842,1 +1844,0 @@\n-  size += frame::metadata_words; \/\/ for preemption case (see possibly_adjust_frame)\n@@ -1928,1 +1929,0 @@\n-  inline intptr_t* possibly_adjust_frame(frame& top);\n@@ -2484,2 +2484,0 @@\n-    \/\/ Some platforms require the size of the runtime frame to be adjusted.\n-    sp = possibly_adjust_frame(top);\n@@ -2966,20 +2964,7 @@\n-  bool use_cont_entry = false;\n-\n-  \/\/ Some preemption cases need to use and adjusted version of sp.\n-  if (preempted) {\n-    if (sp0 == cont.entrySP()) {\n-      \/\/ Still preempted (monitor not acquired) so no frames were thawed.\n-      assert(cont.tail()->preempted(), \"\");\n-      use_cont_entry = true;\n-    }\n-#if defined (AARCH64) || defined (RISCV64)\n-    else {\n-      CodeBlob* cb = CodeCache::find_blob(pc0);\n-      if (cb->frame_size() == 2) {\n-        assert(cb->is_runtime_stub(), \"\");\n-        \/\/ Returning to c2 runtime stub requires extra adjustment on aarch64\n-        \/\/ and riscv64 (see possibly_adjust_frame()).\n-        sp0 += frame::metadata_words;\n-      }\n-    }\n-#endif\n+\n+  if (preempted && sp0 == cont.entrySP()) {\n+    \/\/ Still preempted (monitor not acquired) so no frames were thawed.\n+    assert(cont.tail()->preempted(), \"\");\n+    set_anchor(thread, cont.entrySP(), cont.entryPC());\n+  } else {\n+    set_anchor(thread, sp0);\n@@ -2988,1 +2973,0 @@\n-  set_anchor(thread, use_cont_entry ? cont.entrySP() : sp0, use_cont_entry ? cont.entryPC() : nullptr);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":14,"deletions":30,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -135,1 +135,2 @@\n-\/\/   CAS()ing the _owner field from null to non-null.\n+\/\/   CAS()ing the _owner field from NO_OWNER\/DEFLATER_MARKER to\n+\/\/   its tid (return value from owner_from()).\n@@ -142,0 +143,6 @@\n+\/\/   If the thread is a virtual thread it will first attempt to\n+\/\/   unmount itself. The virtual thread will first try to freeze\n+\/\/   all frames in the heap. If the operation fails it will just\n+\/\/   follow the regular path for platform threads. If the operation\n+\/\/   succeeds, it will push itself onto the cxq with CAS and then\n+\/\/   return back to Java to continue the unmount logic.\n@@ -147,5 +154,9 @@\n-\/\/   tentative successor thread on the EntryList.  Critically, the\n-\/\/   exiting thread doesn't unlink the successor thread from the EntryList.\n-\/\/   After having been unparked, the wakee will recontend for ownership of\n-\/\/   the monitor.   The successor (wakee) will either acquire the lock or\n-\/\/   re-park itself.\n+\/\/   tentative successor thread on the EntryList. In case the successor\n+\/\/   is an unmounted virtual thread, the exiting thread will first try\n+\/\/   to add it to the list of vthreads waiting to be unblocked, and on\n+\/\/   success it will unpark the special unblocker thread instead, which\n+\/\/   will be in charge of submitting the vthread back to the scheduler\n+\/\/   queue. Critically, the exiting thread doesn't unlink the successor\n+\/\/   thread from the EntryList. After having been unparked\/re-scheduled,\n+\/\/   the wakee will recontend for ownership of the monitor. The successor\n+\/\/   (wakee) will either acquire the lock or re-park\/unmount itself.\n@@ -213,1 +224,1 @@\n-\/\/   park-unpark abstraction.  See the comments in os_solaris.cpp regarding\n+\/\/   park-unpark abstraction.  See the comments in os_posix.cpp regarding\n@@ -215,3 +226,1 @@\n-\/\/   depends only on atomic operations and park-unpark.  The monitor subsystem\n-\/\/   manages all RUNNING->BLOCKED and BLOCKED->READY transitions while the\n-\/\/   underlying OS manages the READY<->RUN transitions.\n+\/\/   depends only on atomic operations and park-unpark.\n@@ -224,3 +233,3 @@\n-\/\/   unpark the notifyee.  Unparking a notifee in notify() is inefficient -\n-\/\/   it's likely the notifyee would simply impale itself on the lock held\n-\/\/   by the notifier.\n+\/\/   unpark\/re-schedule the notifyee. Unparking\/re-scheduling a notifyee in\n+\/\/   notify() is inefficient - it's likely the notifyee would simply impale\n+\/\/   itself on the lock held by the notifier.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1878,3 +1878,6 @@\n-          \/\/ JNI locals for the top frame.\n-          assert(_java_thread != nullptr, \"impossible for unmounted vthread\");\n-          _java_thread->active_handles()->oops_do(&blk);\n+          \/\/ JNI locals for the top frame if mounted\n+          assert(_java_thread != nullptr || jvf->method()->is_synchronized()\n+                 || jvf->method()->is_object_wait0(), \"impossible for unmounted vthread\");\n+          if (_java_thread != nullptr) {\n+            _java_thread->active_handles()->oops_do(&blk);\n+          }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test dumping the heap while a virtual thread is unmounted with a native method frame at top.\n+ * @requires vm.continuations\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.model.ThreadObject;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+public class UnmountedVThreadNativeMethodAtTop {\n+\n+    \/**\n+     * Test dumping the heap while a virtual thread is blocked entering a synchronized native method.\n+     *\/\n+    @Test\n+    void VThreadBlockedAtSynchronizedNative() throws Exception {\n+        var lock = this;\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            runWithSynchronizedNative();\n+        });\n+        try {\n+            synchronized (lock) {\n+                vthread.start();\n+\n+                \/\/ wait for thread to start and block\n+                started.await();\n+                await(vthread, Thread.State.BLOCKED);\n+\n+                Path dumpFile = dumpHeap();\n+                verifyHeapDump(dumpFile);\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Run native method while holding the monitor for \"this\".\n+     *\/\n+    private synchronized native void runWithSynchronizedNative();\n+\n+    \/**\n+     * Called from the native method.\n+     *\/\n+    private void run() {\n+    }\n+\n+    \/**\n+     * Test dumping the heap while a virtual thread is waiting in Object.wait().\n+     *\/\n+    @Test\n+    void VThreadBlockedAtOjectWait() throws Exception {\n+        var lock = this;\n+        var started = new CountDownLatch(1);\n+        var vthread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            try {\n+                synchronized (lock) {\n+                    lock.wait();\n+                }\n+            } catch (InterruptedException e) { }\n+        });\n+        try {\n+            vthread.start();\n+\n+            \/\/ wait for thread to start and wait\n+            started.await();\n+            await(vthread, Thread.State.WAITING);\n+\n+            Path dumpFile = dumpHeap();\n+            verifyHeapDump(dumpFile);\n+\n+            synchronized (lock) {\n+                lock.notify();\n+            }\n+        } finally {\n+            vthread.join();\n+        }\n+    }\n+\n+    private Path dumpHeap() throws Exception {\n+        Path df = Files.createTempFile(Path.of(\".\"), \"dump\", \".hprof\");\n+        Files.delete(df);\n+        var bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        bean.dumpHeap(df.toString(), false);\n+        return df;\n+    }\n+\n+    private void verifyHeapDump(Path dumpFile) throws Exception {\n+        \/\/ Make sure that heap dump can be parsed\n+        System.out.println(\"Parse \" + dumpFile.toAbsolutePath() + \" ...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.toString(), false, 0)) {\n+            snapshot.resolve(true);\n+\n+            \/\/ find virtual threads\n+            List<ThreadObject> vthreads = snapshot.getThreads()\n+                    .stream()\n+                    .filter(t -> snapshot.findThing(t.getId())\n+                            .getClazz()\n+                            .getName().equals(\"java.lang.VirtualThread\"))\n+                    .toList();\n+\n+            assertFalse(vthreads.isEmpty(), \"No virtual threads found!!\");\n+            System.out.format(\"%s virtual thread(s) found%n\", vthreads.size());\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the given thread to reach a given state.\n+     *\/\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+\n+    static {\n+        System.loadLibrary(\"UnmountedVThreadNativeMethodAtTop\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/UnmountedVThreadNativeMethodAtTop.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT void JNICALL\n+Java_UnmountedVThreadNativeMethodAtTop_runWithSynchronizedNative(JNIEnv *env, jobject obj) {\n+    jclass clazz = (*env)->GetObjectClass(env, obj);\n+    jmethodID mid = (*env)->GetMethodID(env, clazz, \"run\", \"()V\");\n+    if (mid != NULL) {\n+        (*env)->CallVoidMethod(env, obj, mid);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/libUnmountedVThreadNativeMethodAtTop.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}