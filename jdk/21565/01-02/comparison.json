{"files":[{"patch":"@@ -163,1 +163,1 @@\n-  does_not_return, requires_return\n+  does_not_return, requires_return, requires_pop_epilogue_return\n@@ -166,1 +166,0 @@\n-\n@@ -172,5 +171,1 @@\n-  bool _return_state;\n-  bool _use_pop_on_epilogue;\n-\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-            return_state_t return_state, bool use_pop_on_epilogue);\n+  return_state_t _return_state;\n@@ -179,5 +174,1 @@\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, bool use_pop_on_epilogue);\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state);\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);\n-  ~StubFrame();\n-\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state=requires_return);\n@@ -185,0 +176,2 @@\n+\n+  ~StubFrame();\n@@ -207,3 +200,3 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     return_state_t return_state, bool use_pop_on_epilogue)\n-  : _sasm(sasm), _return_state(return_state), _use_pop_on_epilogue(use_pop_on_epilogue) {\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state) {\n+  _sasm = sasm;\n+  _return_state = return_state;\n@@ -213,11 +206,0 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     bool use_pop_on_epilogue) :\n-  StubFrame(sasm, name, must_gc_arguments, requires_return, use_pop_on_epilogue) {}\n-\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     return_state_t return_state) :\n-  StubFrame(sasm, name, must_gc_arguments, return_state, \/*use_pop_on_epilogue*\/false) {}\n-\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) :\n-  StubFrame(sasm, name, must_gc_arguments, requires_return, \/*use_pop_on_epilogue*\/false) {}\n-\n@@ -231,1 +213,5 @@\n-  __ epilogue(_use_pop_on_epilogue);\n+  if (_return_state == does_not_return) {\n+    __ should_not_reach_here();\n+  } else {\n+    __ epilogue(_return_state == requires_pop_epilogue_return);\n+  }\n@@ -895,1 +881,1 @@\n-        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, \/*use_pop_on_epilogue*\/true);\n+        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, requires_pop_epilogue_return);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -113,5 +113,1 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == nullptr,\n-  \/\/ otherwise m->owner may contain a thread id, a stack address for LM_LEGACY,\n-  \/\/ or the ANONYMOUS_OWNER constant for LM_LIGHTWEIGHT.\n-  \/\/\n-  \/\/ Try to CAS m->owner from null to current thread.\n+  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n@@ -380,1 +376,1 @@\n-    \/\/ CAS owner (null => current thread id).\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-                                              \" fp: \" INTPTR_FORMAT, p2i(sp + frame::metadata_words), p2i(sp), sp[-2]);\n+                                              \" fp: \" INTPTR_FORMAT, p2i(sp + 2), p2i(sp), sp[-2]);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -423,0 +423,30 @@\n+#if defined(ASSERT)\n+static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n+  RegisterMap map(nullptr,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n+  return map.location(reg, stub_fr.sp());\n+}\n+#endif\n+\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+\n+  JavaThread** thread_addr;\n+#ifdef COMPILER1\n+  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n+  } else\n+#endif\n+  {\n+    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n+    thread_addr = nullptr;\n+  }\n+  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n+  return thread_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -328,0 +328,5 @@\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -246,0 +246,5 @@\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  \/\/ The current thread (JavaThread*) is never stored on the stack\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2661,2 +2661,0 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner is null,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n@@ -2664,1 +2662,1 @@\n-  \/\/ Try to CAS m->owner from null to current thread.\n+  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n@@ -2944,1 +2942,1 @@\n-    \/\/ CAS owner (null => current thread id).\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  does_not_return, requires_return\n+  does_not_return, requires_return, requires_pop_epilogue_return\n@@ -176,2 +176,1 @@\n-  bool _return_state;\n-  bool _use_pop_on_epilogue;\n+  return_state_t _return_state;\n@@ -180,7 +179,2 @@\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-            return_state_t return_state, bool use_pop_on_epilogue);\n-\n- public:\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, bool use_pop_on_epilogue);\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state);\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state=requires_return);\n+  void load_argument(int offset_in_words, Register reg);\n@@ -189,2 +183,0 @@\n-\n-  void load_argument(int offset_in_words, Register reg);\n@@ -215,3 +207,3 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     return_state_t return_state, bool use_pop_on_epilogue)\n-  : _sasm(sasm), _return_state(return_state), _use_pop_on_epilogue(use_pop_on_epilogue) {\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state) {\n+  _sasm = sasm;\n+  _return_state = return_state;\n@@ -221,11 +213,0 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     bool use_pop_on_epilogue) :\n-  StubFrame(sasm, name, must_gc_arguments, requires_return, use_pop_on_epilogue) {}\n-\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n-                     return_state_t return_state) :\n-  StubFrame(sasm, name, must_gc_arguments, return_state, \/*use_pop_on_epilogue*\/false) {}\n-\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) :\n-  StubFrame(sasm, name, must_gc_arguments, requires_return, \/*use_pop_on_epilogue*\/false) {}\n-\n@@ -238,0 +219,1 @@\n+\n@@ -239,1 +221,6 @@\n-  __ epilogue(_use_pop_on_epilogue);\n+  if (_return_state == does_not_return) {\n+    __ should_not_reach_here();\n+  } else {\n+    __ epilogue(_return_state == requires_pop_epilogue_return);\n+  }\n+  _sasm = nullptr;\n@@ -919,1 +906,1 @@\n-        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, \/*use_pop_on_epilogue*\/true);\n+        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, requires_pop_epilogue_return);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -119,5 +119,1 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner == nullptr,\n-  \/\/ otherwise m->owner may contain a thread id, a stack address for LM_LEGACY,\n-  \/\/ the ANONYMOUS_OWNER constant for LM_LIGHTWEIGHT.\n-  \/\/\n-  \/\/ Try to CAS m->owner from null to current thread id.\n+  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n@@ -407,1 +403,1 @@\n-    \/\/ CAS owner (null => current thread id).\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-                                              \" fp: \" INTPTR_FORMAT, p2i(sp + frame::metadata_words), p2i(sp), sp[-2]);\n+                                              \" fp: \" INTPTR_FORMAT, p2i(sp + 2), p2i(sp), sp[-2]);\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,0 +396,30 @@\n+#if defined(ASSERT)\n+static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n+  RegisterMap map(nullptr,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n+  return map.location(reg, stub_fr.sp());\n+}\n+#endif\n+\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+\n+  JavaThread** thread_addr;\n+#ifdef COMPILER1\n+  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n+  } else\n+#endif\n+  {\n+    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n+    thread_addr = nullptr;\n+  }\n+  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n+  return thread_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -249,0 +249,5 @@\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3564,2 +3564,0 @@\n-  \/\/ The object's monitor m is unlocked iff m->owner is null,\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n@@ -3567,3 +3565,3 @@\n-  \/\/ Try to CAS m->owner from null to current thread's id.\n-  \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD_ID and CR=EQ.\n-  \/\/ Otherwise, register zero is filled with the current owner.\n+  \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+  \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n+  \/\/ with the current owner.\n@@ -6312,3 +6310,3 @@\n-    \/\/ Try to CAS m->owner from null to current thread's id.\n-    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD_ID and CR=EQ.\n-    \/\/ Otherwise, register zero is filled with the current owner.\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n+    \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n+    \/\/ with the current owner.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -628,1 +628,1 @@\n-    \/\/ CAS owner (null => current thread).\n+    \/\/ Try to CAS owner (no owner => current thread's _lock_id).\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,0 +412,30 @@\n+#if defined(ASSERT)\n+static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n+  RegisterMap map(nullptr,\n+                  RegisterMap::UpdateMap::include,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n+  return map.location(reg, stub_fr.sp());\n+}\n+#endif\n+\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  CodeBlob* cb = f.cb();\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+\n+  JavaThread** thread_addr;\n+#ifdef COMPILER1\n+  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n+      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n+    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n+  } else\n+#endif\n+  {\n+    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n+    thread_addr = nullptr;\n+  }\n+  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n+  return thread_addr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -75,0 +75,5 @@\n+JavaThread** frame::saved_thread_address(const frame& f) {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1681,1 +1681,1 @@\n-  \/\/ On preemption JVMTI state rebinding has already happened so get it always direclty from the oop.\n+  \/\/ On preemption JVMTI state rebinding has already happened so get it always directly from the oop.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-#ifdef COMPILER1\n-#include \"c1\/c1_Runtime1.hpp\"\n-#endif\n@@ -503,35 +500,0 @@\n-#if defined(ASSERT) && !defined(PPC64)\n-static address get_register_address_in_stub(const frame& stub_fr, VMReg reg) {\n-  RegisterMap map(nullptr,\n-                  RegisterMap::UpdateMap::include,\n-                  RegisterMap::ProcessFrames::skip,\n-                  RegisterMap::WalkContinuation::skip);\n-  stub_fr.oop_map()->update_register_map(&stub_fr, &map);\n-  return map.location(reg, stub_fr.sp());\n-}\n-#endif\n-\n-JavaThread** frame::saved_thread_address(const frame& f) {\n-#if defined(PPC64)\n-  \/\/ The current thread (JavaThread*) is never stored on the stack\n-  return nullptr;\n-#else\n-  CodeBlob* cb = f.cb();\n-  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n-\n-  JavaThread** thread_addr;\n-#ifdef COMPILER1\n-  if (cb == Runtime1::blob_for(C1StubId::monitorenter_id) ||\n-      cb == Runtime1::blob_for(C1StubId::monitorenter_nofpu_id)) {\n-    thread_addr = (JavaThread**)(f.sp() + Runtime1::runtime_blob_current_thread_offset(f));\n-  } else\n-#endif\n-  {\n-    \/\/ c2 only saves rbp in the stub frame so nothing to do.\n-    thread_addr = nullptr;\n-  }\n-  assert(get_register_address_in_stub(f, SharedRuntime::thread_register()) == (address)thread_addr, \"wrong thread address\");\n-  return thread_addr;\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -176,8 +176,0 @@\n-  \/\/ Used by async deflation as a marker in the _owner field.\n-  \/\/ Note that the choice of the two markers is peculiar:\n-  \/\/ - They need to represent values that cannot be pointers. In particular,\n-  \/\/   we achieve this by using the lowest two bits.\n-  \/\/ - ANONYMOUS_OWNER should be a small value, it is used in generated code\n-  \/\/   and small values encode much better.\n-  \/\/ - We test for anonymous owner by testing for the lowest bit, therefore\n-  \/\/   DEFLATER_MARKER must *not* have that bit set.\n@@ -186,1 +178,1 @@\n-  int64_t volatile _owner;  \/\/ Either tid of owner, ANONYMOUS_OWNER_MARKER or DEFLATER_MARKER.\n+  int64_t volatile _owner;  \/\/ Either tid of owner, NO_OWNER, ANONYMOUS_OWNER or DEFLATER_MARKER.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"}]}