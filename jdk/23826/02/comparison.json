{"files":[{"patch":"@@ -1057,1 +1057,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -1134,1 +1134,67 @@\n-  Unimplemented();\n+  assert(UseCRC32CIntrinsics, \"need AVX and CLMUL instructions support\");\n+  LIR_Opr result = rlock_result(x);\n+\n+  switch (x->id()) {\n+    case vmIntrinsics::_updateBytesCRC32C:\n+    case vmIntrinsics::_updateDirectByteBufferCRC32C: {\n+      bool is_updateBytes = (x->id() == vmIntrinsics::_updateBytesCRC32C);\n+\n+      LIRItem crc(x->argument_at(0), this);\n+      LIRItem buf(x->argument_at(1), this);\n+      LIRItem off(x->argument_at(2), this);\n+      LIRItem end(x->argument_at(3), this);\n+      buf.load_item();\n+      off.load_nonconstant();\n+      end.load_nonconstant();\n+\n+      \/\/ len = end - off\n+      LIR_Opr len  = end.result();\n+      LIR_Opr tmpA = new_register(T_INT);\n+      LIR_Opr tmpB = new_register(T_INT);\n+      __ move(end.result(), tmpA);\n+      __ move(off.result(), tmpB);\n+      __ sub(tmpA, tmpB, tmpA);\n+      len = tmpA;\n+\n+      LIR_Opr index = off.result();\n+      int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;\n+      if (off.result()->is_constant()) {\n+        index = LIR_OprFact::illegalOpr;\n+        offset += off.result()->as_jint();\n+      }\n+      LIR_Opr base_op = buf.result();\n+      LIR_Address* a = nullptr;\n+\n+      if (index->is_valid()) {\n+        LIR_Opr tmp = new_register(T_LONG);\n+        __ convert(Bytecodes::_i2l, index, tmp);\n+        index = tmp;\n+        __ add(index, LIR_OprFact::intptrConst(offset), index);\n+        a = new LIR_Address(base_op, index, T_BYTE);\n+      } else {\n+        a = new LIR_Address(base_op, offset, T_BYTE);\n+      }\n+\n+      BasicTypeList signature(3);\n+      signature.append(T_INT);\n+      signature.append(T_ADDRESS);\n+      signature.append(T_INT);\n+      CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+      const LIR_Opr result_reg = result_register_for(x->type());\n+\n+      LIR_Opr arg1 = cc->at(0),\n+              arg2 = cc->at(1),\n+              arg3 = cc->at(2);\n+\n+      crc.load_item_force(arg1);\n+      __ leal(LIR_OprFact::address(a), arg2);\n+      __ move(len, arg3);\n+\n+      __ call_runtime_leaf(StubRoutines::updateBytesCRC32C(), LIR_OprFact::illegalOpr, result_reg, cc->args());\n+      __ move(result_reg, result);\n+      break;\n+    }\n+    default: {\n+      ShouldNotReachHere();\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":68,"deletions":2,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-#if defined(S390) || defined(PPC64) || defined(AARCH64)\n+#if defined(S390) || defined(PPC64) || defined(AARCH64) || defined(AMD64)\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6555,1 +6555,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -6590,1 +6590,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n@@ -6634,1 +6634,1 @@\n-  assert(UseCRC32Intrinsics, \"need AVX and LCMUL instructions support\");\n+  assert(UseCRC32Intrinsics, \"need AVX and CLMUL instructions support\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}