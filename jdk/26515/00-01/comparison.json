{"files":[{"patch":"@@ -81,2 +81,0 @@\n-#define CPU_INFO_BUF_SIZE 512\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -652,1 +652,2 @@\n-  CpuInfoBuffer info_buffer(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  stringStream ss(512);\n+  ss.print(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n@@ -654,1 +655,1 @@\n-    info_buffer.append(\"(0x%03x)\", _model2);\n+    ss.print(\"(0x%03x)\", _model2);\n@@ -656,3 +657,3 @@\n-  info_buffer.append(\", \");\n-  int features_offset = info_buffer.length();\n-  insert_features_names(_features, info_buffer);\n+  ss.print(\", \");\n+  int features_offset = ss.size();\n+  insert_features_names(_features, ss);\n@@ -660,1 +661,1 @@\n-  _cpu_info_string = os::strdup(info_buffer);\n+  _cpu_info_string = ss.as_string(true);\n@@ -664,6 +665,8 @@\n-void VM_Version::insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer) {\n-  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n-    if (supports_feature((VM_Version::Feature_Flag)i)) {\n-      return _features_names[i];\n-    } else {\n-      return (const char*)nullptr;\n+void VM_Version::insert_features_names(uint64_t features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n@@ -671,2 +674,2 @@\n-  });\n-  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  static void insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer);\n+  static void insert_features_names(uint64_t features, stringStream& ss);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-#define CPU_INFO_BUF_SIZE 2048\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1104,10 +1104,9 @@\n-  CpuInfoBuffer info_buffer(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-                            cores_per_cpu(), threads_per_core(),\n-                            cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(!info_buffer.overflow(), \"not enough buffer size\");\n-  info_buffer.append(\", \");\n-  assert(!info_buffer.overflow(), \"not enough buffer size\");\n-  int features_offset = info_buffer.length();\n-  insert_features_names(_features, info_buffer);\n-\n-  _cpu_info_string = os::strdup(info_buffer);\n+  stringStream ss(2048);\n+  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+           cores_per_cpu(), threads_per_core(),\n+           cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  ss.print(\", \");\n+  int features_offset = ss.size();\n+  insert_features_names(_features, ss);\n+\n+  _cpu_info_string = ss.as_string(true);\n@@ -3296,5 +3295,8 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer) {\n-  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n-    const char* result = nullptr;\n-    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n-      result = _features_names[i];\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (_features.supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n@@ -3302,3 +3304,2 @@\n-    return result;\n-  });\n-  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer);\n+  static void insert_features_names(VM_Version::VM_Features features, stringStream& ss);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-  _features = CPU_FP | CPU_ASIMD;\n+  set_feature(CPU_FP);\n+  set_feature(CPU_ASIMD);\n@@ -78,1 +79,4 @@\n-  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;\n+  set_feature(CPU_AES);\n+  set_feature(CPU_PMULL);\n+  set_feature(CPU_SHA1);\n+  set_feature(CPU_SHA2);\n@@ -81,1 +85,1 @@\n-    _features |= CPU_CRC32;\n+    set_feature(CPU_CRC32);\n@@ -85,1 +89,1 @@\n-    _features |= CPU_LSE;\n+    set_feature(CPU_LSE);\n@@ -89,1 +93,1 @@\n-    _features |= CPU_SHA512;\n+    set_feature(CPU_SHA512);\n@@ -93,1 +97,1 @@\n-    _features |= CPU_SHA3;\n+    set_feature(CPU_SHA3);\n@@ -96,1 +100,1 @@\n-    _features |= CPU_SB;\n+    set_feature(CPU_SB);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,8 +44,0 @@\n-#ifndef CPU_INFO_BUF_SIZE\n-#define CPU_INFO_BUF_SIZE 1024\n-#endif \/\/ CPU_INFO_BUF_SIZE\n-\n-template<size_t bufsz> class FormatBuffer;\n-\n-using CpuInfoBuffer = FormatBuffer<CPU_INFO_BUF_SIZE>;\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n-\/\/ Simple class to format the ctor arguments into a fixed-sized buffer.\n-\/\/ Uses stack for the buffer. If the buffer is not sufficient to store the formatted string,\n-\/\/ then the _overflow flag is set. In such scenario buffer will hold the truncated string.\n+\/\/ Use stack for buffer\n@@ -58,1 +56,0 @@\n-  inline FormatBuffer();\n@@ -61,1 +58,1 @@\n-  inline int append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n+  inline void append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n@@ -66,1 +63,0 @@\n-  \/\/ returns total size of the buffer\n@@ -68,23 +64,0 @@\n-  \/\/ returns size of the buffer currently used\n-  int length() { return _len; }\n-  \/\/ if the buffer is full and contains truncated string, overflow is set\n-  bool overflow() { return _overflow; }\n-\n-  \/\/ Appends comma separated strings obtained by mapping given range of numbers to strings\n-  template<typename FN>\n-  void insert_string_list(int start, int limit, FN fn) {\n-    bool first = true;\n-    for (int i = start; i < limit; i++) {\n-      const char* str = fn(i);\n-      if (str == nullptr) {\n-        continue;\n-      }\n-      const char* comma = first ? \"\" : \", \";\n-      int result = append(\"%s%s\", comma, str);\n-      if (result < 0) {\n-        return;\n-      }\n-      first = false;\n-    }\n-    return;\n-  }\n@@ -95,9 +68,3 @@\n-  int _len;\n-  bool _overflow;\n-\n-  bool check_overflow(int result) {\n-    if (result == -1) {\n-      _overflow = true;\n-    }\n-    return _overflow;\n-  }\n+\n+ protected:\n+  inline FormatBuffer();\n@@ -107,1 +74,1 @@\n-FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n+FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer) {\n@@ -110,1 +77,1 @@\n-  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n+  jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -112,1 +79,0 @@\n-  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -116,3 +82,2 @@\n-FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n-  int result = jio_vsnprintf(_buf, bufsz, format, ap);\n-  _len = check_overflow(result) ? bufsz-1 : result;\n+FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer) {\n+  jio_vsnprintf(_buf, bufsz, format, ap);\n@@ -122,1 +87,1 @@\n-FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n+FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer) {\n@@ -130,1 +95,1 @@\n-  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n+  jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -132,1 +97,0 @@\n-  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -137,2 +101,1 @@\n-  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n-  _len = check_overflow(result) ? bufsz-1 : result;\n+  jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -142,4 +105,1 @@\n-int FormatBuffer<bufsz>::append(const char* format, ...) {\n-  if (_overflow) {\n-    return -1;\n-  }\n+void FormatBuffer<bufsz>::append(const char* format, ...) {\n@@ -148,2 +108,2 @@\n-  assert(_buf != nullptr, \"sanity check\");\n-  char* buf_end = _buf + _len;\n+  size_t len = strlen(_buf);\n+  char* buf_end = _buf + len;\n@@ -153,1 +113,1 @@\n-  int result = jio_vsnprintf(buf_end, bufsz - _len, format, argp);\n+  jio_vsnprintf(buf_end, bufsz - len, format, argp);\n@@ -155,2 +115,0 @@\n-  _len = check_overflow(result) ? bufsz-1 : _len+result;\n-  return result;\n","filename":"src\/hotspot\/share\/utilities\/formatBuffer.hpp","additions":16,"deletions":58,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -168,0 +168,15 @@\n+\n+   \/\/ Append strings returned by gen, separating each with separator.\n+   \/\/ Stops when gen returns null or when buffer is out of space.\n+   template <typename Generator>\n+   void join(Generator gen, const char* separator) {\n+     bool first = true;\n+     const char* str = gen();\n+     while (str != nullptr) {\n+       const char* sep = first ? \"\" : separator;\n+       print(\"%s%s\", sep, str);\n+       first = false;\n+       str = gen();\n+     }\n+     return;\n+   }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}