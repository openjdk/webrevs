{"files":[{"patch":"@@ -81,0 +81,2 @@\n+#define CPU_INFO_BUF_SIZE 512\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -77,0 +79,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -211,1 +218,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -251,1 +258,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -414,1 +421,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -425,1 +432,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -436,1 +443,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -637,2 +644,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -641,1 +648,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -645,2 +652,1 @@\n-  char buf[512];\n-  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  CpuInfoBuffer info_buffer(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n@@ -648,1 +654,1 @@\n-    os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n+    info_buffer.append(\"(0x%03x)\", _model2);\n@@ -650,7 +656,3 @@\n-  size_t features_offset = strnlen(buf, sizeof(buf));\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit)                 \\\n-  do {                                                          \\\n-    if (VM_Version::supports_##name()) strcat(buf, \", \" #name); \\\n-  } while(0);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n+  info_buffer.append(\", \");\n+  int features_offset = info_buffer.length();\n+  insert_features_names(_features, info_buffer);\n@@ -658,1 +660,3 @@\n-  _cpu_info_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(info_buffer);\n+  _features_string = _cpu_info_string + features_offset;\n+}\n@@ -660,3 +664,9 @@\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             features_offset);\n+void VM_Version::insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer) {\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n+    if (supports_feature((VM_Version::Feature_Flag)i)) {\n+      return _features_names[i];\n+    } else {\n+      return (const char*)nullptr;\n+    }\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -69,0 +71,2 @@\n+  static void insert_features_names(uint64_t features, CpuInfoBuffer& info_buffer);\n+\n@@ -142,1 +146,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -145,0 +149,1 @@\n+    MAX_CPU_FEATURES\n@@ -147,0 +152,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -149,1 +158,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -153,0 +162,10 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#define CPU_INFO_BUF_SIZE 2048\n+\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -1103,7 +1104,8 @@\n-  char buf[2048];\n-  size_t cpu_info_size = jio_snprintf(\n-              buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-              cores_per_cpu(), threads_per_core(),\n-              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  CpuInfoBuffer info_buffer(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+                            cores_per_cpu(), threads_per_core(),\n+                            cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+  info_buffer.append(\", \");\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n+  int features_offset = info_buffer.length();\n+  insert_features_names(_features, info_buffer);\n@@ -1111,7 +1113,2 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n-\n-  _cpu_info_string = os::strdup(buf);\n-\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             cpu_info_size);\n+  _cpu_info_string = os::strdup(info_buffer);\n+  _features_string = _cpu_info_string + features_offset;\n@@ -3299,2 +3296,3 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n-  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer) {\n+  info_buffer.insert_string_list(0, MAX_CPU_FEATURES, [&](int i) {\n+    const char* result = nullptr;\n@@ -3302,4 +3300,1 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      result = _features_names[i];\n@@ -3307,1 +3302,3 @@\n-  }\n+    return result;\n+  });\n+  assert(!info_buffer.overflow(), \"not enough buffer size\");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, CpuInfoBuffer& info_buffer);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,16 +120,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -155,2 +155,6 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) {\n+    set_feature(CPU_SVE2);\n+  }\n+  if (auxv2 & HWCAP2_SVEBITPERM) {\n+    set_feature(CPU_SVEBITPERM);\n+  }\n@@ -190,1 +194,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -328,13 +328,0 @@\n-const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n-                                                         size_t cpu_info_string_len,\n-                                                         size_t features_offset) {\n-  assert(features_offset <= cpu_info_string_len, \"\");\n-  if (features_offset < cpu_info_string_len) {\n-    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n-    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n-    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n-  } else {\n-    return \"\"; \/\/ empty\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,8 @@\n+#ifndef CPU_INFO_BUF_SIZE\n+#define CPU_INFO_BUF_SIZE 1024\n+#endif \/\/ CPU_INFO_BUF_SIZE\n+\n+template<size_t bufsz> class FormatBuffer;\n+\n+using CpuInfoBuffer = FormatBuffer<CPU_INFO_BUF_SIZE>;\n+\n@@ -135,3 +143,0 @@\n-  static const char* extract_features_string(const char* cpu_info_string,\n-                                             size_t cpu_info_string_len,\n-                                             size_t features_offset);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n-\/\/ Use stack for buffer\n+\/\/ Simple class to format the ctor arguments into a fixed-sized buffer.\n+\/\/ Uses stack for the buffer. If the buffer is not sufficient to store the formatted string,\n+\/\/ then the _overflow flag is set. In such scenario buffer will hold the truncated string.\n@@ -56,0 +58,1 @@\n+  inline FormatBuffer();\n@@ -58,1 +61,1 @@\n-  inline void append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n+  inline int append(const char* format, ...)  ATTRIBUTE_PRINTF(2, 3);\n@@ -63,0 +66,1 @@\n+  \/\/ returns total size of the buffer\n@@ -64,0 +68,23 @@\n+  \/\/ returns size of the buffer currently used\n+  int length() { return _len; }\n+  \/\/ if the buffer is full and contains truncated string, overflow is set\n+  bool overflow() { return _overflow; }\n+\n+  \/\/ Appends comma separated strings obtained by mapping given range of numbers to strings\n+  template<typename FN>\n+  void insert_string_list(int start, int limit, FN fn) {\n+    bool first = true;\n+    for (int i = start; i < limit; i++) {\n+      const char* str = fn(i);\n+      if (str == nullptr) {\n+        continue;\n+      }\n+      const char* comma = first ? \"\" : \", \";\n+      int result = append(\"%s%s\", comma, str);\n+      if (result < 0) {\n+        return;\n+      }\n+      first = false;\n+    }\n+    return;\n+  }\n@@ -68,3 +95,9 @@\n-\n- protected:\n-  inline FormatBuffer();\n+  int _len;\n+  bool _overflow;\n+\n+  bool check_overflow(int result) {\n+    if (result == -1) {\n+      _overflow = true;\n+    }\n+    return _overflow;\n+  }\n@@ -74,1 +107,1 @@\n-FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer) {\n+FormatBuffer<bufsz>::FormatBuffer(const char * format, ...) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n@@ -77,1 +110,1 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -79,0 +112,1 @@\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -82,2 +116,3 @@\n-FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer) {\n-  jio_vsnprintf(_buf, bufsz, format, ap);\n+FormatBuffer<bufsz>::FormatBuffer(FormatBufferDummy dummy, const char * format, va_list ap) : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n+  int result = jio_vsnprintf(_buf, bufsz, format, ap);\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -87,1 +122,1 @@\n-FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer) {\n+FormatBuffer<bufsz>::FormatBuffer() : FormatBufferBase(_buffer), _len(0), _overflow(false) {\n@@ -95,1 +130,1 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n@@ -97,0 +132,1 @@\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -101,1 +137,2 @@\n-  jio_vsnprintf(_buf, bufsz, format, argp);\n+  int result = jio_vsnprintf(_buf, bufsz, format, argp);\n+  _len = check_overflow(result) ? bufsz-1 : result;\n@@ -105,1 +142,4 @@\n-void FormatBuffer<bufsz>::append(const char* format, ...) {\n+int FormatBuffer<bufsz>::append(const char* format, ...) {\n+  if (_overflow) {\n+    return -1;\n+  }\n@@ -108,2 +148,2 @@\n-  size_t len = strlen(_buf);\n-  char* buf_end = _buf + len;\n+  assert(_buf != nullptr, \"sanity check\");\n+  char* buf_end = _buf + _len;\n@@ -113,1 +153,1 @@\n-  jio_vsnprintf(buf_end, bufsz - len, format, argp);\n+  int result = jio_vsnprintf(buf_end, bufsz - _len, format, argp);\n@@ -115,0 +155,2 @@\n+  _len = check_overflow(result) ? bufsz-1 : _len+result;\n+  return result;\n","filename":"src\/hotspot\/share\/utilities\/formatBuffer.hpp","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"}]}