{"files":[{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -53,0 +53,2 @@\n+const char* VM_Version::_features_names[MAX_CPU_FEATURES] = { nullptr };\n+\n@@ -77,0 +79,5 @@\n+#define SET_CPU_FEATURE_NAME(id, name, bit) \\\n+  _features_names[bit] = XSTR(name);\n+  CPU_FEATURE_FLAGS(SET_CPU_FEATURE_NAME)\n+#undef SET_CPU_FEATURE_NAME\n+\n@@ -211,1 +218,1 @@\n-    _features |= CPU_A53MAC;\n+    set_feature(CPU_A53MAC);\n@@ -251,1 +258,1 @@\n-  if (_features & (CPU_FP | CPU_ASIMD)) {\n+  if (supports_feature(CPU_FP) || supports_feature(CPU_ASIMD)) {\n@@ -414,1 +421,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -425,1 +432,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -436,1 +443,1 @@\n-  if (_features & CPU_ASIMD) {\n+  if (supports_feature(CPU_ASIMD)) {\n@@ -637,2 +644,2 @@\n-    _features &= ~CPU_SVE2;\n-    _features &= ~CPU_SVEBITPERM;\n+    clear_feature(CPU_SVE2);\n+    clear_feature(CPU_SVEBITPERM);\n@@ -641,1 +648,1 @@\n-    _features &= ~CPU_SVE;\n+    clear_feature(CPU_SVE);\n@@ -645,2 +652,2 @@\n-  char buf[512];\n-  int buf_used_len = os::snprintf_checked(buf, sizeof(buf), \"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n+  stringStream ss(512);\n+  ss.print(\"0x%02x:0x%x:0x%03x:%d\", _cpu, _variant, _model, _revision);\n@@ -648,1 +655,1 @@\n-    os::snprintf_checked(buf + buf_used_len, sizeof(buf) - buf_used_len, \"(0x%03x)\", _model2);\n+    ss.print(\"(0x%03x)\", _model2);\n@@ -650,7 +657,3 @@\n-  size_t features_offset = strnlen(buf, sizeof(buf));\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit)                 \\\n-  do {                                                          \\\n-    if (VM_Version::supports_##name()) strcat(buf, \", \" #name); \\\n-  } while(0);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n+  ss.print(\", \");\n+  int features_offset = ss.size();\n+  insert_features_names(_features, ss);\n@@ -658,1 +661,3 @@\n-  _cpu_info_string = os::strdup(buf);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n+}\n@@ -660,3 +665,11 @@\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             features_offset);\n+void VM_Version::insert_features_names(uint64_t features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n+    }\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+class stringStream;\n+\n+#define BIT_MASK(flag) (1ULL<<(flag))\n+\n@@ -69,0 +73,2 @@\n+  static void insert_features_names(uint64_t features, stringStream& ss);\n+\n@@ -142,1 +148,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = bit,\n@@ -145,0 +151,1 @@\n+    MAX_CPU_FEATURES\n@@ -147,0 +154,4 @@\n+  STATIC_ASSERT(sizeof(_features) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+  static const char* _features_names[MAX_CPU_FEATURES];\n+\n@@ -149,1 +160,1 @@\n-  static bool supports_##name() { return (_features & CPU_##id) != 0; };\n+  static bool supports_##name() { return supports_feature(CPU_##id); }\n@@ -153,0 +164,10 @@\n+  static void set_feature(Feature_Flag flag) {\n+    _features |= BIT_MASK(flag);\n+  }\n+  static void clear_feature(Feature_Flag flag) {\n+    _features &= (~BIT_MASK(flag));\n+  }\n+  static bool supports_feature(Feature_Flag flag) {\n+    return (_features & BIT_MASK(flag)) != 0;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -1103,7 +1104,7 @@\n-  char buf[2048];\n-  size_t cpu_info_size = jio_snprintf(\n-              buf, sizeof(buf),\n-              \"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-              cores_per_cpu(), threads_per_core(),\n-              cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n-  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  stringStream ss(2048);\n+  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n+           cores_per_cpu(), threads_per_core(),\n+           cpu_family(), _model, _stepping, os::cpu_microcode_revision());\n+  ss.print(\", \");\n+  int features_offset = (int)ss.size();\n+  insert_features_names(_features, ss);\n@@ -1111,7 +1112,2 @@\n-  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n-\n-  _cpu_info_string = os::strdup(buf);\n-\n-  _features_string = extract_features_string(_cpu_info_string,\n-                                             strnlen(_cpu_info_string, sizeof(buf)),\n-                                             cpu_info_size);\n+  _cpu_info_string = ss.as_string(true);\n+  _features_string = _cpu_info_string + features_offset;\n@@ -3299,7 +3295,8 @@\n-void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n-  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n-    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n-      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, stringStream& ss) {\n+  int i = 0;\n+  ss.join([&]() {\n+    while (i < MAX_CPU_FEATURES) {\n+      if (_features.supports_feature((VM_Version::Feature_Flag)i)) {\n+        return _features_names[i++];\n+      }\n+      i += 1;\n@@ -3307,1 +3304,2 @@\n-  }\n+    return (const char*)nullptr;\n+  }, \", \");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+class stringStream;\n+\n@@ -925,1 +927,1 @@\n-  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+  static void insert_features_names(VM_Version::VM_Features features, stringStream& ss);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-  _features = CPU_FP | CPU_ASIMD;\n+  set_feature(CPU_FP);\n+  set_feature(CPU_ASIMD);\n@@ -78,1 +79,4 @@\n-  _features |= CPU_AES | CPU_PMULL | CPU_SHA1 | CPU_SHA2;\n+  set_feature(CPU_AES);\n+  set_feature(CPU_PMULL);\n+  set_feature(CPU_SHA1);\n+  set_feature(CPU_SHA2);\n@@ -81,1 +85,1 @@\n-    _features |= CPU_CRC32;\n+    set_feature(CPU_CRC32);\n@@ -85,1 +89,1 @@\n-    _features |= CPU_LSE;\n+    set_feature(CPU_LSE);\n@@ -89,1 +93,1 @@\n-    _features |= CPU_SHA512;\n+    set_feature(CPU_SHA512);\n@@ -93,1 +97,1 @@\n-    _features |= CPU_SHA3;\n+    set_feature(CPU_SHA3);\n@@ -96,1 +100,1 @@\n-    _features |= CPU_SB;\n+    set_feature(CPU_SB);\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -120,16 +120,16 @@\n-  static_assert(CPU_FP      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMD   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n-  static_assert(CPU_EVTSTRM == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n-  static_assert(CPU_AES     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n-  static_assert(CPU_PMULL   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n-  static_assert(CPU_SHA1    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA2    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n-  static_assert(CPU_CRC32   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n-  static_assert(CPU_LSE     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n-  static_assert(CPU_DCPOP   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n-  static_assert(CPU_SHA3    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n-  static_assert(CPU_SHA512  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n-  static_assert(CPU_SVE     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n-  static_assert(CPU_PACA    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n-  static_assert(CPU_FPHP    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n-  static_assert(CPU_ASIMDHP == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FP)      == HWCAP_FP,      \"Flag CPU_FP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMD)   == HWCAP_ASIMD,   \"Flag CPU_ASIMD must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_EVTSTRM) == HWCAP_EVTSTRM, \"Flag CPU_EVTSTRM must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_AES)     == HWCAP_AES,     \"Flag CPU_AES must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PMULL)   == HWCAP_PMULL,   \"Flag CPU_PMULL must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA1)    == HWCAP_SHA1,    \"Flag CPU_SHA1 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA2)    == HWCAP_SHA2,    \"Flag CPU_SHA2 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_CRC32)   == HWCAP_CRC32,   \"Flag CPU_CRC32 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_LSE)     == HWCAP_ATOMICS, \"Flag CPU_LSE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_DCPOP)   == HWCAP_DCPOP,   \"Flag CPU_DCPOP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA3)    == HWCAP_SHA3,    \"Flag CPU_SHA3 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SHA512)  == HWCAP_SHA512,  \"Flag CPU_SHA512 must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_SVE)     == HWCAP_SVE,     \"Flag CPU_SVE must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_PACA)    == HWCAP_PACA,    \"Flag CPU_PACA must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_FPHP)    == HWCAP_FPHP,    \"Flag CPU_FPHP must follow Linux HWCAP\");\n+  static_assert(BIT_MASK(CPU_ASIMDHP) == HWCAP_ASIMDHP, \"Flag CPU_ASIMDHP must follow Linux HWCAP\");\n@@ -155,2 +155,6 @@\n-  if (auxv2 & HWCAP2_SVE2) _features |= CPU_SVE2;\n-  if (auxv2 & HWCAP2_SVEBITPERM) _features |= CPU_SVEBITPERM;\n+  if (auxv2 & HWCAP2_SVE2) {\n+    set_feature(CPU_SVE2);\n+  }\n+  if (auxv2 & HWCAP2_SVEBITPERM) {\n+    set_feature(CPU_SVEBITPERM);\n+  }\n@@ -190,1 +194,1 @@\n-            guarantee(_features & CPU_DCPOP, \"dcpop availability should be consistent\");\n+            guarantee(supports_feature(CPU_DCPOP), \"dcpop availability should be consistent\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -328,13 +328,0 @@\n-const char* Abstract_VM_Version::extract_features_string(const char* cpu_info_string,\n-                                                         size_t cpu_info_string_len,\n-                                                         size_t features_offset) {\n-  assert(features_offset <= cpu_info_string_len, \"\");\n-  if (features_offset < cpu_info_string_len) {\n-    assert(cpu_info_string[features_offset + 0] == ',', \"\");\n-    assert(cpu_info_string[features_offset + 1] == ' ', \"\");\n-    return cpu_info_string + features_offset + 2; \/\/ skip initial \", \"\n-  } else {\n-    return \"\"; \/\/ empty\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -135,3 +135,0 @@\n-  static const char* extract_features_string(const char* cpu_info_string,\n-                                             size_t cpu_info_string_len,\n-                                             size_t features_offset);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,0 +168,15 @@\n+\n+   \/\/ Append strings returned by gen, separating each with separator.\n+   \/\/ Stops when gen returns null or when buffer is out of space.\n+   template <typename Generator>\n+   void join(Generator gen, const char* separator) {\n+     bool first = true;\n+     const char* str = gen();\n+     while (str != nullptr) {\n+       const char* sep = first ? \"\" : separator;\n+       print(\"%s%s\", sep, str);\n+       first = false;\n+       str = gen();\n+     }\n+     return;\n+   }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}