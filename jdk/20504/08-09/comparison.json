{"files":[{"patch":"@@ -822,1 +822,1 @@\n-    if (C->live_nodes() + NodeLimitFudgeFactor > C->max_node_limit()) {\n+    \/*if (C->live_nodes() + NodeLimitFudgeFactor > C->max_node_limit()) {\n@@ -830,1 +830,1 @@\n-    }\n+    }*\/\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n- * @run main\/othervm\/timeout=240000\n- *                   -Xcomp\n+ * @run main\/othervm -Xcomp\n@@ -31,1 +30,4 @@\n- *                   -XX:EliminateAllocationArraySizeLimit=60240\n+ *                   -XX:EliminateAllocationArraySizeLimit=32000\n+ *                   -XX:MaxNodeLimit=20000\n+ *                   -XX:CompileCommand=dontinline,compiler.escapeAnalysis.TestScalarizeBailout::initializeArray\n+ *                   -XX:CompileCommand=compileonly,compiler.escapeAnalysis.TestScalarizeBailout::*\n@@ -42,3 +44,3 @@\n-        \/\/ The array size is set to 48K, which is below the threshold for scalarization.\n-        var1 = new long[48 * 1024];\n-        long[] a1 = new long[48 * 1024];\n+        \/\/ The array size is set to 16K, which is below the threshold for scalarization (MaxNodeLimit=20000).\n+        var1 = new long[16 * 1024];\n+        long[] a1 = new long[16 * 1024];\n@@ -50,2 +52,2 @@\n-    \/\/ Esape analysis should be able to eliminate the allocation of the array as the size 48k is\n-    \/\/ below the EliminateAllocationArraySizeLimit=60240.\n+    \/\/ Esape analysis should be able to eliminate the allocation of the array as the size 16k is\n+    \/\/ below the EliminateAllocationArraySizeLimit=32000.\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestScalarizeBailout.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}