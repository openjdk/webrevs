{"files":[{"patch":"@@ -110,1 +110,1 @@\n-    assert(is_in_encoding_range || k->is_interface() || k->is_abstract(), \"sanity\");\n+    assert(is_in_encoding_range, \"sanity\");\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5911,9 +5911,0 @@\n-\/\/ Returns true if the future Klass will need to be addressable with a narrow Klass ID.\n-bool ClassFileParser::klass_needs_narrow_id() const {\n-  \/\/ Classes that are never instantiated need no narrow Klass Id, since the\n-  \/\/ only point of having a narrow id is to put it into an object header. Keeping\n-  \/\/ never instantiated classes out of class space lessens the class space pressure.\n-  \/\/ For more details, see JDK-8338526.\n-  return !is_interface() && !is_abstract();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -517,5 +517,0 @@\n-  bool is_abstract() const { return _access_flags.is_abstract(); }\n-\n-  \/\/ Returns true if the Klass to be generated will need to be addressable\n-  \/\/ with a narrow Klass ID.\n-  bool klass_needs_narrow_id() const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  if (k != nullptr && UseCompressedClassPointers && k->needs_narrow_id()) {\n+  if (k != nullptr && UseCompressedClassPointers) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -76,3 +77,2 @@\n-static bool can_compress_element(const Klass* klass) {\n-  return CompressedKlassPointers::is_encodable(klass) &&\n-         JfrTraceId::load_raw(klass) < uncompressed_threshold;\n+static bool can_compress_element(traceid id) {\n+  return Metaspace::using_class_space() && id < uncompressed_threshold;\n@@ -83,1 +83,1 @@\n-  return element_size(can_compress_element(klass));\n+  return element_size(can_compress_element(JfrTraceId::load_raw(klass)));\n@@ -139,2 +139,1 @@\n-  assert(can_compress_element(klass), \"invariant\");\n-  assert(id == JfrTraceId::load_raw(klass), \"invariant\");\n+  assert(can_compress_element(id), \"invariant\");\n@@ -156,1 +155,1 @@\n-  if (can_compress_element(klass)) {\n+  if (can_compress_element(id)) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  return Metaspace::allocate(loader_data, word_size, type, \/*use_class_space*\/ false, THREAD);\n+  return Metaspace::allocate(loader_data, word_size, type, THREAD);\n@@ -84,1 +84,1 @@\n-  return Metaspace::allocate(loader_data, word_size, type, \/*use_class_space*\/ false);\n+  return Metaspace::allocate(loader_data, word_size, type);\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-                              MetaspaceObj::Type type, bool use_class_space) {\n+                              MetaspaceObj::Type type) {\n@@ -885,1 +885,1 @@\n-  MetadataType mdtype = use_class_space ? ClassType : NonClassType;\n+  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n@@ -909,1 +909,1 @@\n-                              MetaspaceObj::Type type, bool use_class_space, TRAPS) {\n+                              MetaspaceObj::Type type, TRAPS) {\n@@ -917,1 +917,1 @@\n-  MetaWord* result = allocate(loader_data, word_size, type, use_class_space);\n+  MetaWord* result = allocate(loader_data, word_size, type);\n@@ -920,1 +920,1 @@\n-    MetadataType mdtype = use_class_space ? ClassType : NonClassType;\n+    MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                            MetaspaceObj::Type type, bool use_class_space, TRAPS);\n+                            MetaspaceObj::Type type, TRAPS);\n@@ -128,1 +128,1 @@\n-                            MetaspaceObj::Type type, bool use_class_space);\n+                            MetaspaceObj::Type type);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                                     MetaspaceObj::array_type(sizeof(T)), false, THREAD);\n+                                     MetaspaceObj::array_type(sizeof(T)), THREAD);\n@@ -44,1 +44,1 @@\n-                                     MetaspaceObj::array_type(sizeof(T)), false);\n+                                     MetaspaceObj::array_type(sizeof(T)));\n","filename":"src\/hotspot\/share\/oops\/array.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,4 +44,0 @@\n-void* ArrayKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, true, THREAD);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,0 @@\n-  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n-\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,5 +458,0 @@\n-void* InstanceKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size,\n-                                  bool use_class_space, TRAPS) throw() {\n-  return Metaspace::allocate(loader_data, word_size, ClassType, use_class_space, THREAD);\n-}\n-\n@@ -475,1 +470,0 @@\n-  const bool use_class_space = UseClassMetaspaceForAllClasses || parser.klass_needs_narrow_id();\n@@ -480,1 +474,1 @@\n-    ik = new (loader_data, size, use_class_space, THREAD) InstanceRefKlass(parser);\n+    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n@@ -483,1 +477,1 @@\n-    ik = new (loader_data, size, use_class_space, THREAD) InstanceMirrorKlass(parser);\n+    ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n@@ -486,1 +480,1 @@\n-    ik = new (loader_data, size, use_class_space, THREAD) InstanceStackChunkKlass(parser);\n+    ik = new (loader_data, size, THREAD) InstanceStackChunkKlass(parser);\n@@ -489,1 +483,1 @@\n-    ik = new (loader_data, size, use_class_space, THREAD) InstanceClassLoaderKlass(parser);\n+    ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n@@ -492,1 +486,1 @@\n-    ik = new (loader_data, size, use_class_space, THREAD) InstanceKlass(parser);\n+    ik = new (loader_data, size, THREAD) InstanceKlass(parser);\n@@ -495,1 +489,1 @@\n-  if (ik != nullptr && UseCompressedClassPointers && use_class_space) {\n+  if (ik != nullptr && UseCompressedClassPointers) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, bool use_class_space, TRAPS) throw();\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -282,6 +282,3 @@\n-    \/\/ We therfore seed the mark word with the narrow Klass ID.\n-    \/\/ Note that only those Klass that can be instantiated have a narrow Klass ID.\n-    \/\/ For those who don't, we leave the klass bits empty and assert if someone\n-    \/\/ tries to use those.\n-    const narrowKlass nk = CompressedKlassPointers::is_encodable(kls) ?\n-        CompressedKlassPointers::encode(const_cast<Klass*>(kls)) : 0;\n+    \/\/ We therefore seed the mark word with the narrow Klass ID.\n+    precond(CompressedKlassPointers::is_encodable(kls));\n+    const narrowKlass nk = CompressedKlassPointers::encode(const_cast<Klass*>(kls));\n@@ -294,0 +291,4 @@\n+void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n+  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+}\n+\n@@ -1063,1 +1064,1 @@\n-  if (UseCompressedClassPointers && needs_narrow_id()) {\n+  if (UseCompressedClassPointers) {\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n+\n@@ -797,4 +799,0 @@\n-\n-  \/\/ Returns true if this Klass needs to be addressable via narrow Klass ID.\n-  inline bool needs_narrow_id() const;\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -178,9 +178,0 @@\n-\/\/ Returns true if this Klass needs to be addressable via narrow Klass ID.\n-inline bool Klass::needs_narrow_id() const {\n-  \/\/ Classes that are never instantiated need no narrow Klass Id, since the\n-  \/\/ only point of having a narrow id is to put it into an object header. Keeping\n-  \/\/ never instantiated classes out of class space lessens the class space pressure.\n-  \/\/ For more details, see JDK-8338526.\n-  \/\/ Note: don't call this function before access flags are initialized.\n-  return UseClassMetaspaceForAllClasses || (!is_abstract() && !is_interface());\n-}\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2003,3 +2003,0 @@\n-  product(bool, UseClassMetaspaceForAllClasses, false, DIAGNOSTIC,          \\\n-          \"Use the class metaspace for all classes including \"              \\\n-          \"abstract and interface classes.\")                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-        if (compressed && !canBeStoredInCompressibleMetaSpace()) {\n-            throw new IllegalArgumentException(\"constant cannot be compressed: \" + metaspaceObject);\n-        }\n@@ -91,13 +88,1 @@\n-        if (compressed) {\n-            return false;\n-        }\n-        return canBeStoredInCompressibleMetaSpace();\n-    }\n-\n-    private boolean canBeStoredInCompressibleMetaSpace() {\n-        if (!HotSpotVMConfig.config().useClassMetaspaceForAllClasses && metaspaceObject instanceof HotSpotResolvedJavaType t && !t.isArray()) {\n-            \/\/ As of JDK-8338526, interface and abstract types are not stored\n-            \/\/ in compressible metaspace.\n-            return !t.isInterface() && !t.isAbstract();\n-        }\n-        return true;\n+        return !compressed;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMetaspaceConstantImpl.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-    final boolean useClassMetaspaceForAllClasses = getFlag(\"UseClassMetaspaceForAllClasses\", Boolean.class);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}