{"files":[{"patch":"@@ -89,1 +89,1 @@\n- *                         l -> Objects.hash(l.bar, l.baz), -1);\n+ *                         l -> Objects.hash(l.bar, l.baz));\n@@ -123,35 +123,35 @@\n- * {@snippet lang=java:\n-        public final class LazySpecifiedFoo {\n-\n-        private final Bar bar;\n-        private final Baz baz;\n-\n-        private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n-                StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n-                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n-\n-        @Stable\n-        private long hash;\n-\n-        public LazySpecifiedFoo(Bar bar, Baz baz) {\n-            this.bar = bar;\n-            this.baz = baz;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-             return (o instanceof Foo that)\n-                     && Objects.equals(this.bar, that.bar)\n-                     && Objects.equals(this.baz, that.baz);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return (int) HASH_UPDATER.applyAsLong(this);\n-        }\n-\n-        static long hashCodeFor(LazySpecifiedFoo foo) {\n-            return Objects.hash(foo.bar, foo.baz);\n-        }\n-    }\n- * }\n+ * {@snippet lang = java:\n+ *     public final class LazySpecifiedFoo {\n+ *\n+ *         private final Bar bar;\n+ *         private final Baz baz;\n+ *\n+ *         private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n+ *                 StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n+ *                 StableFieldUpdater.replaceLongZero(LazySpecifiedFoo::hashCodeFor, 1L << 32));\n+ *\n+ *         @Stable\n+ *         private long hash;\n+ *\n+ *         public LazySpecifiedFoo(Bar bar, Baz baz) {\n+ *             this.bar = bar;\n+ *             this.baz = baz;\n+ *         }\n+ *\n+ *         @Override\n+ *         public boolean equals(Object o) {\n+ *             return (o instanceof Foo that)\n+ *                     && Objects.equals(this.bar, that.bar)\n+ *                     && Objects.equals(this.baz, that.baz);\n+ *         }\n+ *\n+ *         @Override\n+ *         public int hashCode() {\n+ *             return (int) HASH_UPDATER.applyAsLong(this);\n+ *         }\n+ *\n+ *         static long hashCodeFor(LazySpecifiedFoo foo) {\n+ *             return Objects.hash(foo.bar, foo.baz);\n+ *         }\n+ *     }\n+ *}\n@@ -175,2 +175,1 @@\n-                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n-                        -1);\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)));\n@@ -204,1 +203,1 @@\n- * There is a convenience method for this idiomatic case that looks like this:\n+ * There is a convenience method for the idiomatic case above that looks like this:\n@@ -216,0 +215,3 @@\n+ * <p>\n+ * If a reference value of {@code null} is used as a parameter in any of the methods\n+ * in this class, a {@link NullPointerException} is thrown.\n@@ -251,2 +253,1 @@\n-                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(int.class, lookup.lookupClass())),\n-                -1);\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(int.class, lookup.lookupClass())));\n@@ -256,2 +257,1 @@\n-                                             MethodHandle underlying,\n-                                             int zeroReplacement) {\n+                                             MethodHandle underlying) {\n@@ -261,1 +261,1 @@\n-        return new StableIntFieldUpdaterVarHandle<>(accessor, adaptedUnderlying, zeroReplacement);\n+        return new StableIntFieldUpdaterVarHandle<>(accessor, adaptedUnderlying);\n@@ -267,2 +267,1 @@\n-                                             ToIntFunction<? super T> underlying,\n-                                             int zeroReplacement) {\n+                                             ToIntFunction<? super T> underlying) {\n@@ -274,1 +273,1 @@\n-        return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        return new StableIntFieldUpdater<>(holderType, offset, underlying);\n@@ -304,2 +303,1 @@\n-                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(long.class, lookup.lookupClass())),\n-                1L << 31);\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(long.class, lookup.lookupClass())));\n@@ -309,2 +307,1 @@\n-                                               MethodHandle underlying,\n-                                               long zeroReplacement) {\n+                                               MethodHandle underlying) {\n@@ -314,1 +311,1 @@\n-        return makeLong(accessor, adaptedUnderlying, zeroReplacement);\n+        return makeLong(accessor, adaptedUnderlying);\n@@ -320,2 +317,1 @@\n-                                               ToLongFunction<? super T> underlying,\n-                                               long zeroReplacement) {\n+                                               ToLongFunction<? super T> underlying) {\n@@ -327,1 +323,1 @@\n-        return makeLong(holderType, offset, underlying, zeroReplacement);\n+        return makeLong(holderType, offset, underlying);\n@@ -330,0 +326,98 @@\n+    \/**\n+     * {@return a function that will replace any zero value returned by the provided\n+     *          {@code underlying} function with the provided {@code zeroReplacement}}\n+     * @param underlying      function to filter return values from\n+     * @param zeroReplacement to replace any zero values returned by the {@code underlying}\n+     *                        function.\n+     * @param <T>             The function's type parameter\n+     *\/\n+    public static <T> ToIntFunction<T> replaceIntZero(ToIntFunction<T> underlying, int zeroReplacement) {\n+\n+        record IntZeroReplacer<T>(ToIntFunction<T> underlying, int zeroReplacement) implements ToIntFunction<T> {\n+            @ForceInline\n+            @Override\n+            public int applyAsInt(T value) {\n+                return replaceZero(underlying.applyAsInt(value), zeroReplacement);\n+            }\n+        }\n+\n+        Objects.requireNonNull(underlying);\n+        return new IntZeroReplacer<>(underlying, zeroReplacement);\n+    }\n+\n+    \/**\n+     * {@return a method handle that will replace any zero value returned by the provided\n+     *          {@code underlying} handle with the provided {@code zeroReplacement}}\n+     * @param underlying      function to filter return values from\n+     * @param zeroReplacement to replace any zero values returned by the {@code underlying}\n+     *                        method handle.\n+     *\/\n+    public static MethodHandle replaceIntZero(MethodHandle underlying, int zeroReplacement) {\n+\n+        final class Holder {\n+            private static final MethodHandle RETURN_FILTER =\n+                    MhUtil.findStatic(LOCAL_LOOKUP, \"replaceZero\", MethodType.methodType(int.class, int.class, int.class));\n+        }\n+        check(underlying, int.class);\n+        return MethodHandles.filterReturnValue(underlying,\n+                MethodHandles.insertArguments(Holder.RETURN_FILTER, 1, zeroReplacement));\n+    }\n+\n+    \/**\n+     * {@return a function that will replace any zero value returned by the provided\n+     *          {@code underlying} function with the provided {@code zeroReplacement}}\n+     * @param underlying      function to filter return values from\n+     * @param zeroReplacement to replace any zero values returned by the {@code underlying}\n+     *                        function.\n+     * @param <T>             The function's type parameter\n+     *\/\n+    public static <T> ToLongFunction<T> replaceLongZero(ToLongFunction<T> underlying, long zeroReplacement) {\n+\n+        record LongZeroReplacer<T>(ToLongFunction<T> underlying, long zeroReplacement) implements ToLongFunction<T> {\n+            @ForceInline\n+            @Override\n+            public long applyAsLong(T value) {\n+                return replaceZero(underlying.applyAsLong(value), zeroReplacement);\n+            }\n+        }\n+\n+        Objects.requireNonNull(underlying);\n+        return new LongZeroReplacer<>(underlying, zeroReplacement);\n+    }\n+\n+    \/**\n+     * {@return a method handle that will replace any zero value returned by the provided\n+     *          {@code underlying} handle with the provided {@code zeroReplacement}}\n+     * @param underlying      function to filter return values from\n+     * @param zeroReplacement to replace any zero values returned by the {@code underlying}\n+     *                        method handle.\n+     *\/\n+    public static MethodHandle replaceLongZero(MethodHandle underlying, long zeroReplacement) {\n+\n+        final class Holder {\n+            private static final MethodHandle RETURN_FILTER =\n+                    MhUtil.findStatic(LOCAL_LOOKUP, \"replaceZero\", MethodType.methodType(long.class, long.class, long.class));\n+        }\n+\n+        check(underlying, long.class);\n+        return MethodHandles.filterReturnValue(underlying,\n+                MethodHandles.insertArguments(Holder.RETURN_FILTER, 1, zeroReplacement));\n+    }\n+\n+    \/\/ Also used reflectively\n+    @ForceInline\n+    private static int replaceZero(int value, int zeroReplacement) {\n+        return value == 0\n+                ? zeroReplacement\n+                : value;\n+    }\n+\n+    \/\/ Also used reflectively\n+    @ForceInline\n+    private static long replaceZero(long value, long zeroReplacement) {\n+        return value == 0\n+                ? zeroReplacement\n+                : value;\n+    }\n+\n+\n@@ -333,2 +427,1 @@\n-                                     MethodHandle underlying,\n-                                     int zeroReplacement) {\n+                                     MethodHandle underlying) {\n@@ -338,2 +431,2 @@\n-                \"ofInt\", MethodType.methodType(ToIntFunction.class, VarHandle.class, MethodHandle.class, int.class));\n-        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying, zeroReplacement));\n+                \"ofInt\", MethodType.methodType(ToIntFunction.class, VarHandle.class, MethodHandle.class));\n+        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying));\n@@ -345,2 +438,1 @@\n-                                      MethodHandle underlying,\n-                                      long zeroReplacement) {\n+                                      MethodHandle underlying) {\n@@ -350,2 +442,2 @@\n-                \"makeLong\", MethodType.methodType(ToLongFunction.class, VarHandle.class, MethodHandle.class, long.class));\n-        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying, zeroReplacement));\n+                \"makeLong\", MethodType.methodType(ToLongFunction.class, VarHandle.class, MethodHandle.class));\n+        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying));\n@@ -361,2 +453,1 @@\n-                                                 ToIntFunction<? super T> underlying,\n-                                                 int zeroReplacement) {\n+                                                 ToIntFunction<? super T> underlying) {\n@@ -368,1 +459,1 @@\n-            return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+            return new StableIntFieldUpdater<>(holderType, offset, underlying);\n@@ -373,2 +464,1 @@\n-                                                   ToLongFunction<? super T> underlying,\n-                                                   long zeroReplacement) {\n+                                                   ToLongFunction<? super T> underlying) {\n@@ -380,1 +470,1 @@\n-            return makeLong(holderType, offset, underlying, zeroReplacement);\n+            return makeLong(holderType, offset, underlying);\n@@ -387,2 +477,1 @@\n-                                                  ToLongFunction<? super T> underlying,\n-                                                  long zeroReplacement) {\n+                                                  ToLongFunction<? super T> underlying) {\n@@ -392,1 +481,1 @@\n-            return new StableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+            return new StableLongFieldUpdater<>(holderType, offset, underlying);\n@@ -394,1 +483,1 @@\n-            return new TearingStableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+            return new TearingStableLongFieldUpdater<>(holderType, offset, underlying);\n@@ -399,2 +488,1 @@\n-                                                  MethodHandle underlying,\n-                                                  long zeroReplacement) {\n+                                                  MethodHandle underlying) {\n@@ -404,1 +492,1 @@\n-            return new StableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+            return new StableLongFieldUpdaterVarHandle<>(accessor, underlying);\n@@ -406,1 +494,1 @@\n-            return new TearingStableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+            return new TearingStableLongFieldUpdaterVarHandle<>(accessor, underlying);\n@@ -412,2 +500,1 @@\n-                                            ToIntFunction<? super T> underlying,\n-                                            int zeroReplacement) implements ToIntFunction<T> {\n+                                            ToIntFunction<? super T> underlying) implements ToIntFunction<T> {\n@@ -429,3 +516,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -441,2 +525,1 @@\n-                                                     MethodHandle underlying,\n-                                                     int zeroReplacement) implements ToIntFunction<T> {\n+                                                     MethodHandle underlying) implements ToIntFunction<T> {\n@@ -461,3 +544,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -474,2 +554,1 @@\n-                                             ToLongFunction<? super T> underlying,\n-                                             long zeroReplacement) implements ToLongFunction<T> {\n+                                             ToLongFunction<? super T> underlying) implements ToLongFunction<T> {\n@@ -491,3 +570,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -504,2 +580,1 @@\n-                                                    ToLongFunction<? super T> underlying,\n-                                                    long zeroReplacement) implements ToLongFunction<T> {\n+                                                    ToLongFunction<? super T> underlying) implements ToLongFunction<T> {\n@@ -521,3 +596,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -533,2 +605,1 @@\n-                                                      MethodHandle underlying,\n-                                                      long zeroReplacement) implements ToLongFunction<T> {\n+                                                      MethodHandle underlying) implements ToLongFunction<T> {\n@@ -553,3 +624,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -565,2 +633,1 @@\n-                                                             MethodHandle underlying,\n-                                                             long zeroReplacement) implements ToLongFunction<T> {\n+                                                             MethodHandle underlying) implements ToLongFunction<T> {\n@@ -585,3 +652,0 @@\n-                        if (v == 0) {\n-                            v = zeroReplacement;\n-                        }\n@@ -613,1 +677,1 @@\n-        \/\/ Implicit null check\n+        check(underlying, returnType);\n@@ -615,3 +679,0 @@\n-        if (underlyingType.returnType() != returnType || underlyingType.parameterCount() != 1) {\n-            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n-        }\n@@ -624,0 +685,8 @@\n+    private static void check(MethodHandle underlying, Class<?> returnType) {\n+        \/\/ Implicit null check\n+        final var underlyingType = underlying.type();\n+        if (underlyingType.returnType() != returnType || underlyingType.parameterCount() != 1) {\n+            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":180,"deletions":111,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-                        l -> Objects.hash(l.bar, l.baz), -1);\n+                        l -> Objects.hash(l.bar, l.baz));\n@@ -153,1 +153,1 @@\n-                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n+                        StableFieldUpdater.replaceLongZero(LazySpecifiedFoo::hashCodeFor, 1L << 32));\n@@ -193,2 +193,1 @@\n-                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n-                        -1);\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)));\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterExampleTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.function.IntFunction;\n@@ -51,1 +52,0 @@\n-    private static final int ZERO_REPLACEMENT = 42;\n@@ -56,5 +56,16 @@\n-        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(null, \"a\", _ -> 0, ZERO_REPLACEMENT));\n-        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(String.class, null, _ -> 0, ZERO_REPLACEMENT));\n-        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"hash\", null, ZERO_REPLACEMENT));\n-        var x = assertThrows(IllegalArgumentException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"dummy\", _ -> 0, ZERO_REPLACEMENT));\n-        assertEquals(\"Only fields of type 'int' are supported. The provided field is 'long StableFieldUpdaterTest$Foo.dummy'\", x.getMessage());\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(null, \"a\", _ -> 0));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(String.class, null, _ -> 0));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"hash\", null));\n+        var xi = assertThrows(IllegalArgumentException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"dummy\", _ -> 0));\n+        assertEquals(\"Only fields of type 'int' are supported. The provided field is 'long StableFieldUpdaterTest$Foo.dummy'\", xi.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofLong(null, \"a\", _ -> 0));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofLong(String.class, null, _ -> 0));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofLong(Foo.class, \"hash\", null));\n+        var xl = assertThrows(IllegalArgumentException.class, () -> StableFieldUpdater.ofLong(Foo.class, \"hash\", _ -> 0));\n+        assertEquals(\"Only fields of type 'long' are supported. The provided field is 'int StableFieldUpdaterTest$Foo.hash'\", xl.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.replaceIntZero((ToIntFunction<?>)null, 1));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.replaceIntZero((MethodHandle) null, 1));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.replaceLongZero((ToLongFunction<?>)null, 1L));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.replaceLongZero((MethodHandle) null, 1L));\n@@ -78,1 +89,1 @@\n-                () -> StableFieldUpdater.ofInt(RecordFoo.class, \"hash\", _ -> 0, ZERO_REPLACEMENT));\n+                () -> StableFieldUpdater.ofInt(RecordFoo.class, \"hash\", _ -> 0));\n@@ -86,1 +97,1 @@\n-        ToIntFunction updater = StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        ToIntFunction updater = StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode());\n@@ -97,2 +108,1 @@\n-                MhUtil.findStatic(lookup,SimpleMhFoo.class, \"computeHash\", MethodType.methodType(int.class, SimpleMhFoo.class))\n-                , -1);\n+                MhUtil.findStatic(lookup,SimpleMhFoo.class, \"computeHash\", MethodType.methodType(int.class, SimpleMhFoo.class)));\n@@ -113,2 +123,1 @@\n-                MhUtil.findVirtual(lookup, LongMhFoo.class, \"hash0\", MethodType.methodType(long.class))\n-                , -1);\n+                MhUtil.findVirtual(lookup, LongMhFoo.class, \"hash0\", MethodType.methodType(long.class)));\n@@ -124,0 +133,36 @@\n+    @Test\n+    void replaceIntZeroFunction() {\n+        int zeroReplacement = -1;\n+        ToIntFunction<Integer> underlying = i -> i;\n+        var mod = StableFieldUpdater.replaceIntZero(underlying, zeroReplacement);\n+        assertEquals(1, mod.applyAsInt(1));\n+        assertEquals(zeroReplacement, mod.applyAsInt(0));\n+    }\n+\n+    @Test\n+    void replaceIntZeroHandle() throws Throwable {\n+        int zeroReplacement = -1;\n+        MethodHandle underlying = MethodHandles.identity(int.class);\n+        var mod = StableFieldUpdater.replaceIntZero(underlying, zeroReplacement);\n+        assertEquals(1, (int) mod.invoke(1));\n+        assertEquals(zeroReplacement, (int) mod.invoke(0));\n+    }\n+\n+    @Test\n+    void replaceLongZeroFunction() {\n+        long zeroReplacement = -1;\n+        ToLongFunction<Long> underlying = i -> i;\n+        var mod = StableFieldUpdater.replaceLongZero(underlying, zeroReplacement);\n+        assertEquals(1L, mod.applyAsLong(1L));\n+        assertEquals(zeroReplacement, mod.applyAsLong(0L));\n+    }\n+\n+    @Test\n+    void replaceLongZeroHandle() throws Throwable {\n+        long zeroReplacement = -1;\n+        MethodHandle underlying = MethodHandles.identity(long.class);\n+        var mod = StableFieldUpdater.replaceLongZero(underlying, zeroReplacement);\n+        assertEquals(1L, (long) mod.invoke(1L));\n+        assertEquals(zeroReplacement, (long) mod.invoke(0L));\n+    }\n+\n@@ -127,1 +172,1 @@\n-                StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+                StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode());\n@@ -151,1 +196,1 @@\n-                StableFieldUpdater.ofLong(LongFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+                StableFieldUpdater.ofLong(LongFoo.class, \"hash\", f -> f.string.hashCode());\n@@ -177,1 +222,1 @@\n-                StableFieldUpdater.ofInt(InheritingFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+                StableFieldUpdater.ofInt(InheritingFoo.class, \"hash\", f -> f.string.hashCode());\n@@ -208,1 +253,1 @@\n-                StableFieldUpdater.ofInt(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", int.class), HASH_MH, ZERO_REPLACEMENT);\n+                StableFieldUpdater.ofInt(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", int.class), HASH_MH);\n@@ -270,1 +315,1 @@\n-                StableFieldUpdater.ofLong(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", long.class), HASH_MH, ZERO_REPLACEMENT);\n+                StableFieldUpdater.ofLong(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", long.class), HASH_MH);\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":62,"deletions":17,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-                }, -1);\n+                });\n@@ -147,2 +147,1 @@\n-                        MhUtil.findVirtual(LOOKUP, \"hashCode0\", MethodType.methodType(int.class)),\n-                        -1);\n+                        MhUtil.findVirtual(LOOKUP, \"hashCode0\", MethodType.methodType(int.class)));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFieldUpdaterBenchmark.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}