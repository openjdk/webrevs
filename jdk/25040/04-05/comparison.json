{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -36,0 +37,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -199,0 +202,9 @@\n+ * There is a convenience method for this idiomatic case that looks like this:\n+ * {@snippet lang=java:\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(MethodHandles.lookup(), \"hash\", \"hashCodeFor\"));\n+ * }\n+ * This will use the provided {@link MethodHandles#lookup()} to look up the field\n+ * {@code hash} and also use the same lookup to look up a static method that takes\n+ * a {@code MhFoo} and returns an {@code int}.\n@@ -209,0 +221,31 @@\n+    \/**\n+     * {@return a function that lazily sets the field named {@code fieldName} by invoking\n+     *          the static method in the {@link MethodHandles.Lookup#lookupClass()}\n+     *          named {@code staticUnderlyingMethodName} if the field was not previously\n+     *          set. Otherwise, the function returns the set field value}\n+     * <p>\n+     * If the {@code staticUnderlyingMethodName} returns zero, the value is replaced with\n+     * {@code -1} which is then stored in the field with the provided {@code fieldName}.\n+     *\n+     * @param lookup                     used to reflectively lookup entities\n+     * @param fieldName                  the name of the lazily set field (of type {@code int})\n+     * @param staticUnderlyingMethodName the name of the method to invoke when computing\n+     *                                   the hash value (invoked at most once)\n+     * @param <T>                        target type\n+     * @throws NullPointerException     if any of the provided parameters are {@code null}\n+     * @throws IllegalArgumentException if no {@code int} field can be found using the\n+     *                                  provided {@code lookup} and {@code fieldName}\n+     * @throws IllegalArgumentException if no {@code int} function can be found using the\n+     *                                  provided {@code lookup} and\n+     *                                  {@code staticUnderlyingMethodName} where the\n+     *                                  single method parameter is of type {@code T}.\n+     *\/\n+    public static <T> ToIntFunction<T> ofInt(MethodHandles.Lookup lookup,\n+                                             String fieldName,\n+                                             String staticUnderlyingMethodName) {\n+        return ofInt(\n+                MhUtil.findVarHandle(lookup, fieldName, int.class),\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(int.class, lookup.lookupClass())),\n+                -1);\n+    }\n+\n@@ -232,0 +275,31 @@\n+    \/**\n+     * {@return a function that lazily sets the field named {@code fieldName} by invoking\n+     *          the static method in the {@link MethodHandles.Lookup#lookupClass()}\n+     *          named {@code staticUnderlyingMethodName} if the field was not previously\n+     *          set. Otherwise, the function returns the set field value}\n+     * <p>\n+     * If the {@code staticUnderlyingMethodName} returns zero, the value is replaced with\n+     * {@code 1L<<32} which is then stored in the field with the provided {@code fieldName}.\n+     *\n+     * @param lookup                     used to reflectively lookup entities\n+     * @param fieldName                  the name of the lazily set field (of type {@code long})\n+     * @param staticUnderlyingMethodName the name of the method to invoke when computing\n+     *                                   the hash value (invoked at most once)\n+     * @param <T>                        target type\n+     * @throws NullPointerException      if any of the provided parameters are {@code null}\n+     * @throws IllegalArgumentException  if no {@code int} field can be found using the\n+     *                                   provided {@code lookup} and {@code fieldName}\n+     * @throws IllegalArgumentException if no {@code long} function can be found using the\n+     *                                  provided {@code lookup} and\n+     *                                  {@code staticUnderlyingMethodName} where the\n+     *                                  single method parameter is of type {@code T}.\n+     *\/\n+    public static <T> ToLongFunction<T> ofLong(MethodHandles.Lookup lookup,\n+                                               String fieldName,\n+                                               String staticUnderlyingMethodName) {\n+        return ofLong(\n+                MhUtil.findVarHandle(lookup, fieldName, long.class),\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(long.class, lookup.lookupClass())),\n+                1L << 31);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -198,0 +198,31 @@\n+    static final class SimpleMhFoo implements HasHashField {\n+\n+        private static final ToIntFunction<SimpleMhFoo> UPDATER =\n+                StableFieldUpdater.ofInt(MethodHandles.lookup(), \"hash\", \"computeHash\");\n+        \n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public SimpleMhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+        \/\/ Used reflectively\n+        private static int computeHash(SimpleMhFoo target) {\n+            return target.string.hashCode();\n+        }\n+\n+    }\n+\n@@ -241,1 +272,2 @@\n-                InheritingFoo::new\n+                InheritingFoo::new,\n+                SimpleMhFoo::new\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}