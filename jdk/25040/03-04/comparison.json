{"files":[{"patch":"@@ -36,2 +36,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n@@ -52,2 +50,2 @@\n- *\n- * {@snippet lang=java:\n+ * <p>\n+ * {@snippet lang = java:\n@@ -76,4 +74,3 @@\n- * }\n- * to use {@code @Stable} lazy hashing:\n- *\n- * {@snippet lang=java:\n+ *} to use {@code @Stable} lazy hashing:\n+ * <p>\n+ * {@snippet lang = java:\n@@ -109,1 +106,6 @@\n- * }\n+ *}\n+ * <p>\n+ * If the underlying hash lamba returns zero, it is replaced with {@code -1}. It is legal\n+ * to provide {@code 0} as a replacement in which case there will be no replacement and\n+ * the hash code will be {@code 0}. In such cases, {@link @Stable} fields cannot be\n+ * constant-folded.\n@@ -111,2 +113,0 @@\n- * If the underlying hash lamba returns zero, it is replaced with {@code -1}.\n- *\n@@ -114,3 +114,3 @@\n- * {@code String}), a {@code long} field can be used instead, and then we can use\n- * {@code 1 << 32} as a token for zero (as the lower 32 bits are zero) and then just\n- * cast to an {@code int} as shown in this example:\n+ * {@code String}), a {@code long} field can be used instead, and a value of\n+ * {@code 1 << 32} can be used as a token for zero (as the lower 32 bits are zero) and\n+ * then just cast to an {@code int} as shown in this example:\n@@ -126,1 +126,1 @@\n-                        l -> Objects.hash(l.bar, l.baz), 1L << 32);\n+                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n@@ -147,0 +147,4 @@\n+\n+        static long hashCodeFor(LazySpecifiedFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n@@ -149,0 +153,2 @@\n+ * The example above also features a static method {@code hashCodeFor()} that acts as\n+ * the underlying hash function. This method can reside in another class.\n@@ -150,0 +156,44 @@\n+ * Here is another example where a more low-level approach with VarHandle and MethodHandle\n+ * parameters is used:\n+ *\n+ * {@snippet lang=java:\n+    public final class MhFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hash\", int.class),\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n+                        -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public MhFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+\n+        \/\/ Used reflectively\n+        static int hashCodeFor(MhFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n+    }\n+ * }\n+ *\n@@ -162,1 +212,1 @@\n-        Objects.requireNonNull(accessor);\n+        check(accessor, int.class);\n@@ -164,0 +214,1 @@\n+        var adaptedUnderlying = checkAndAdapt(underlying, int.class);\n@@ -165,10 +216,1 @@\n-        if (accessor.varType() != int.class) {\n-            throw new IllegalArgumentException(\"Illegal accessor: \" + accessor);\n-        }\n-        if (underlying.type().returnType() != int.class || underlying.type().parameterCount() != 1) {\n-            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n-        }\n-        if (!underlying.type().parameterType(0).equals(Object.class)) {\n-            underlying = underlying.asType(underlying.type().changeParameterType(0, Object.class));\n-        }\n-        return new StableIntFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+        return new StableIntFieldUpdaterVarHandle<>(accessor, adaptedUnderlying, zeroReplacement);\n@@ -190,0 +232,10 @@\n+    public static <T> ToLongFunction<T> ofLong(VarHandle accessor,\n+                                               MethodHandle underlying,\n+                                               long zeroReplacement) {\n+        check(accessor, long.class);\n+        Objects.requireNonNull(underlying);\n+        var adaptedUnderlying = checkAndAdapt(underlying, long.class);\n+\n+        return makeLong(accessor, adaptedUnderlying, zeroReplacement);\n+    }\n+\n@@ -247,0 +299,12 @@\n+    private static <T> ToLongFunction<T> makeLong(VarHandle accessor,\n+                                                  MethodHandle underlying,\n+                                                  long zeroReplacement) {\n+        if (Architecture.is64bit()) {\n+            \/\/ We are also relying on the fact that the VM will not place 64-bit\n+            \/\/ instance fields that can cross cache lines.\n+            return new StableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+        } else {\n+            return new TearingStableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+        }\n+    }\n+\n@@ -255,1 +319,1 @@\n-            checkType(holderType, t);\n+            checkInstanceOf(holderType, t);\n@@ -262,1 +326,0 @@\n-                \/\/ StableUtil.preventReentry(t);\n@@ -278,1 +341,0 @@\n-\n@@ -319,1 +381,1 @@\n-            checkType(holderType, t);\n+            checkInstanceOf(holderType, t);\n@@ -326,1 +388,0 @@\n-                \/\/ StableUtil.preventReentry(t);\n@@ -350,1 +411,1 @@\n-            checkType(holderType, t);\n+            checkInstanceOf(holderType, t);\n@@ -357,1 +418,0 @@\n-                \/\/ StableUtil.preventReentry(t);\n@@ -373,0 +433,64 @@\n+    private record StableLongFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                      MethodHandle underlying,\n+                                                      long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, the VM is 64-bit.\n+            long v = (long) accessor.get(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (long) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (long) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record TearingStableLongFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                             MethodHandle underlying,\n+                                                             long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics and this VM is not 64-bit.\n+            long v = (long) accessor.getOpaque(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (long) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (long) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n@@ -376,1 +500,1 @@\n-    private static void checkType(Class<?> holderType, Object t) {\n+    private static void checkInstanceOf(Class<?> holderType, Object t) {\n@@ -382,0 +506,18 @@\n+    private static void check(VarHandle accessor, Class<?> varType) {\n+        \/\/ Implicit null check\n+        if (accessor.varType() != varType) {\n+            throw new IllegalArgumentException(\"Illegal accessor: \" + accessor);\n+        }\n+    }\n+\n+    private static MethodHandle checkAndAdapt(MethodHandle underlying, Class<?> returnType) {\n+        final var underlyingType = underlying.type();\n+        if (underlyingType.returnType() != returnType || underlyingType.parameterCount() != 1) {\n+            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n+        }\n+        if (!underlyingType.parameterType(0).equals(Object.class)) {\n+            underlying = underlying.asType(underlyingType.changeParameterType(0, Object.class));\n+        }\n+        return underlying;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":176,"deletions":34,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules java.base\/jdk.internal.invoke\n@@ -30,0 +31,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -34,0 +36,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -149,1 +153,1 @@\n-                        l -> (l.bar == null && l.baz == null) ? 0 : Objects.hash(l.bar, l.baz), 1L << 32);\n+                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n@@ -170,0 +174,46 @@\n+\n+        static long hashCodeFor(LazySpecifiedFoo foo) {\n+            return (foo.bar == null && foo.baz == null) ? 0 : Objects.hash(foo.bar, foo.baz);\n+        }\n+\n+    }\n+\n+    static\n+\n+    public final class MhFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hash\", int.class),\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n+                        -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public MhFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+\n+        \/\/ Used reflectively\n+        static int hashCodeFor(MhFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterExampleTest.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -38,1 +40,1 @@\n-import java.lang.invoke.VarHandle;\n+import java.util.function.Function;\n@@ -40,0 +42,2 @@\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Stream;\n@@ -47,1 +51,0 @@\n-    private static final ToIntFunction<String> STRING_HASH_CODE = String::hashCode;\n@@ -58,15 +61,8 @@\n-    @Test\n-    void foo() {\n-        var foo = new Foo(STRING);\n-        assertEquals(0, foo.hash);\n-        assertEquals(STRING.hashCode(), foo.hashCode());\n-        assertEquals(STRING.hashCode(), foo.hash);\n-\n-    }\n-\n-    @Test\n-    void mhFoo() {\n-        var foo = new MhFoo(STRING);\n-        assertEquals(0, foo.hash);\n-        assertEquals(STRING.hashCode(), foo.hashCode());\n-        assertEquals(STRING.hashCode(), foo.hash);\n+    @ParameterizedTest\n+    @MethodSource(\"fooConstructors\")\n+    void basic(Function<String, HasHashField> namedConstructor) {\n+        final HasHashField foo = namedConstructor.apply(STRING);\n+        assertEquals(0L, foo.hash());\n+        int actual = foo.hashCode();\n+        assertEquals(STRING.hashCode(), actual);\n+        assertEquals(actual, foo.hash());\n@@ -84,9 +80,0 @@\n-    @Test\n-    void barInherit() {\n-        var bar = new Bar(STRING);\n-        assertEquals(0, bar.hash);\n-        assertEquals(STRING.hashCode(), bar.hashCode());\n-        assertEquals(STRING.hashCode(), bar.hash);\n-    }\n-\n-\n@@ -103,1 +90,1 @@\n-    static final class Foo {\n+    static final class Foo implements HasHashField {\n@@ -120,0 +107,28 @@\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+    }\n+\n+    static final class LongFoo implements HasHashField {\n+\n+        private static final ToLongFunction<LongFoo> UPDATER =\n+                StableFieldUpdater.ofLong(LongFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        long hash;\n+        long dummy;\n+\n+        public LongFoo(String string) {\n+            this.string = string;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return (int)UPDATER.applyAsLong(this);\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n@@ -124,3 +139,3 @@\n-    static final class Bar extends AbstractBar {\n-        private static final ToIntFunction<Bar> UPDATER =\n-                StableFieldUpdater.ofInt(Bar.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+    static final class InheritingFoo extends AbstractFoo implements HasHashField {\n+        private static final ToIntFunction<InheritingFoo> UPDATER =\n+                StableFieldUpdater.ofInt(InheritingFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n@@ -128,1 +143,1 @@\n-        public Bar(String string) {\n+        public InheritingFoo(String string) {\n@@ -138,1 +153,1 @@\n-    static abstract class AbstractBar {\n+    static abstract class AbstractFoo implements HasHashField {\n@@ -142,1 +157,1 @@\n-        public AbstractBar(String string) {\n+        public AbstractFoo(String string) {\n@@ -145,0 +160,5 @@\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n@@ -147,1 +167,1 @@\n-    static final class MhFoo {\n+    static final class MhFoo implements HasHashField {\n@@ -171,0 +191,52 @@\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+    }\n+\n+    static final class LongMhFoo implements HasHashField {\n+\n+        private static final MethodHandle HASH_MH = MhUtil.findVirtual(MethodHandles.lookup(), \"hash0\", MethodType.methodType(long.class));\n+\n+        private static final ToLongFunction<LongMhFoo> UPDATER =\n+                StableFieldUpdater.ofLong(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", long.class), HASH_MH, ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        long hash;\n+        long dummy;\n+\n+        public LongMhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int)UPDATER.applyAsLong(this);\n+        }\n+\n+        public long hash0() {\n+            return string.hashCode();\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+    }\n+\n+    interface HasHashField {\n+        long hash();\n+    }\n+\n+    \/\/ Apparently, `hashCode()` is invoked if we create a stream of just `HasHashField`\n+    \/\/ instances so we provide the associated constructors instead.\n+    static Stream<Function<String, HasHashField>> fooConstructors() {\n+        return Stream.of(\n+                Foo::new,\n+                LongFoo::new,\n+                MhFoo::new,\n+                LongMhFoo::new,\n+                InheritingFoo::new\n+        );\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":106,"deletions":34,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.net.URI;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.ToIntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgs = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.lang.stable=ALL-UNNAMED\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableFieldUpdaterBenchmark {\n+\n+    private static final String STRING = \"https:\/\/some.site.com\";\n+\n+    private static final Base BASE = new Base(STRING);\n+    private static final Updater UPDATER = new Updater(STRING);\n+    private static final MhUpdater MH_UPDATER = new MhUpdater(STRING);\n+    private static final URI U_R_I = URI.create(STRING);\n+\n+    private final Base base = new Base(STRING);\n+    private final Updater updater = new Updater(STRING);\n+    private final MhUpdater mhUpdater = new MhUpdater(STRING);\n+    private static final URI uri = URI.create(STRING);\n+\n+    @Benchmark\n+    public int baseStatic() {\n+        return BASE.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int base() {\n+        return base.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int mhUpdaterStatic() {\n+        return MH_UPDATER.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int mhUpdater() {\n+        return mhUpdater.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updaterStatic() {\n+        return UPDATER.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updater() {\n+        return updater.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uriStatic() {\n+        return U_R_I.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uri() {\n+        return uri.hashCode();\n+    }\n+\n+    static final class Base extends Abstract {\n+        Base(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = hashCode;\n+            if (h == 0) {\n+                hashCode = h = string.hashCode();\n+            }\n+            return h;\n+        }\n+    }\n+\n+    static final class Updater extends Abstract {\n+\n+        private static final ToIntFunction<Updater> HASH_CODE_UPDATER =\n+                StableFieldUpdater.ofInt(Updater.class, \"hashCode\", new ToIntFunction<>() {\n+                    @Override\n+                    public int applyAsInt(Updater updater) {\n+                        return updater.string.hashCode();\n+                    }\n+                }, -1);\n+\n+        Updater(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_CODE_UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static final class MhUpdater extends Abstract {\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+        private static final ToIntFunction<MhUpdater> HASH_CODE_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hashCode\", int.class),\n+                        MhUtil.findVirtual(LOOKUP, \"hashCode0\", MethodType.methodType(int.class)),\n+                        -1);\n+\n+        MhUpdater(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_CODE_UPDATER.applyAsInt(this);\n+        }\n+\n+        private int hashCode0() {\n+            return string.hashCode();\n+        }\n+\n+    }\n+\n+    static class Abstract {\n+\n+        final String string;\n+        int hashCode;\n+\n+        Abstract(String string) {\n+            this.string = string;\n+        }\n+    }\n+\n+\n+    \/\/ From j.i.i.MhUtil\n+\n+    private static final class MhUtil {\n+\n+        public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                              String name,\n+                                              Class<?> type) {\n+            return findVarHandle(lookup, lookup.lookupClass(), name, type);\n+        }\n+\n+        public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                              Class<?> recv,\n+                                              String name,\n+                                              Class<?> type) {\n+            try {\n+                return lookup.findVarHandle(recv, name, type);\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+\n+        public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                               String name,\n+                                               MethodType type) {\n+            return findVirtual(lookup, lookup.lookupClass(), name, type);\n+        }\n+\n+        public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                               Class<?> refc,\n+                                               String name,\n+                                               MethodType type) {\n+            try {\n+                return lookup.findVirtual(refc, name, type);\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFieldUpdaterBenchmark.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.stable;\n-\n-import jdk.internal.lang.stable.StableFieldUpdater;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Threads;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.net.URI;\n-import java.util.concurrent.TimeUnit;\n-import java.util.function.ToIntFunction;\n-\n-\/**\n- * Benchmark measuring StableValue performance\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 2)\n-@Fork(value = 2, jvmArgs = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.lang.stable=ALL-UNNAMED\"})\n-@Threads(Threads.MAX)   \/\/ Benchmark under contention\n-public class StableUpdatersBenchmark {\n-\n-    private static final String STRING = \"https:\/\/some.site.com\";\n-\n-    private static final Base BASE = new Base(STRING);\n-    private static final Updater UPDATER = new Updater(STRING);\n-    private static final URI U_R_I = URI.create(STRING);\n-\n-    private final Base base = new Base(STRING);\n-    private final Updater updater = new Updater(STRING);\n-    private static final URI uri = URI.create(STRING);\n-\n-    @Benchmark\n-    public int baseStatic() {\n-        return BASE.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int base() {\n-        return base.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int updaterStatic() {\n-        return UPDATER.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int updater() {\n-        return updater.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int uriStatic() {\n-        return U_R_I.hashCode();\n-    }\n-\n-    @Benchmark\n-    public int uri() {\n-        return uri.hashCode();\n-    }\n-\n-    static final class Base extends Abstract {\n-        Base(String string) { super(string); }\n-\n-        @Override\n-        public int hashCode() {\n-            int h = hashCode;\n-            if (h == 0) {\n-                hashCode = h = string.hashCode();\n-            }\n-            return h;\n-        }\n-    }\n-\n-    static final class Updater extends Abstract {\n-\n-        private static final ToIntFunction<Updater> HASH_CODE_UPDATER =\n-                StableFieldUpdater.ofInt(Updater.class, \"hashCode\", new ToIntFunction<>() {\n-                    @Override\n-                    public int applyAsInt(Updater updater) {\n-                        return updater.string.hashCode();\n-                    }\n-                }, -1);\n-\n-        Updater(String string) { super(string); }\n-\n-        @Override\n-        public int hashCode() {\n-            return HASH_CODE_UPDATER.applyAsInt(this);\n-        }\n-    }\n-\n-    static class Abstract {\n-\n-        final String string;\n-        int hashCode;\n-\n-        Abstract(String string) {\n-            this.string = string;\n-        }\n-    }\n-\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableUpdatersBenchmark.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"}]}