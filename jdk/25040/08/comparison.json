{"files":[{"patch":"@@ -95,0 +95,1 @@\n+        --add-exports java.base\/jdk.internal.lang.stable=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,661 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.vm.annotation.ForceInline;\n+import sun.reflect.misc.ReflectUtil;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Objects;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+\n+\/**\n+ * Stable field updaters.\n+ * <p>\n+ * This class allows, for example, effortless conversion of immutable classes to use lazy\n+ * {@link Object#hashCode()}.\n+ * <p>\n+ * Here is an example of how to convert\n+ * <p>\n+ * {@snippet lang = java:\n+ *    public final class Foo {\n+ *\n+ *         private final Bar bar;\n+ *         private final Baz baz;\n+ *\n+ *         public Foo(Bar bar, Baz baz) {\n+ *             this.bar = bar;\n+ *             this.baz = baz;\n+ *         }\n+ *\n+ *         @Override\n+ *         public boolean equals(Object o) {\n+ *             return o instanceof Foo that\n+ *                     && Objects.equals(this.bar, that.bar)\n+ *                     && Objects.equals(this.baz, that.baz);\n+ *         }\n+ *\n+ *         @Override\n+ *         public int hashCode() {\n+ *             return Objects.hash(bar, baz);\n+ *         }\n+ *     }\n+ *} to use {@code @Stable} lazy hashing:\n+ * <p>\n+ * {@snippet lang = java:\n+ *    public final class LazyFoo {\n+ *\n+ *         private final Bar bar;\n+ *         private final Baz baz;\n+ *\n+ *         private static final ToIntFunction<LazyFoo> HASH_UPDATER =\n+ *                 StableFieldUpdater.ofInt(LazyFoo.class, \"hash\",\n+ *                         l -> Objects.hash(l.bar, l.baz), -1);\n+ *\n+ *         @Stable\n+ *         private int hash;\n+ *\n+ *         public LazyFoo(Bar bar, Baz baz) {\n+ *             this.bar = bar;\n+ *             this.baz = baz;\n+ *         }\n+ *\n+ *         @Override\n+ *         public boolean equals(Object o) {\n+ *             return o instanceof Foo that\n+ *                     && Objects.equals(this.bar, that.bar)\n+ *                     && Objects.equals(this.baz, that.baz);\n+ *         }\n+ *\n+ *         @Override\n+ *         public int hashCode() {\n+ *             return HASH_UPDATER.applyAsInt(this);\n+ *         }\n+ *     }\n+ *}\n+ * <p>\n+ * If the underlying hash lamba returns zero, it is replaced with {@code -1}. It is legal\n+ * to provide {@code 0} as a replacement in which case there will be no replacement and\n+ * the hash code will be {@code 0}. In such cases, {@link @Stable} fields cannot be\n+ * constant-folded.\n+ * <p>\n+ * In cases where the entire range of hash codes are strictly specified (as it is for\n+ * {@code String}), a {@code long} field can be used instead, and a value of\n+ * {@code 1 << 32} can be used as a token for zero (as the lower 32 bits are zero) and\n+ * then just cast to an {@code int} as shown in this example:\n+ *\n+ * {@snippet lang=java:\n+        public final class LazySpecifiedFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n+                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n+\n+        @Stable\n+        private long hash;\n+\n+        public LazySpecifiedFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+             return (o instanceof Foo that)\n+                     && Objects.equals(this.bar, that.bar)\n+                     && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) HASH_UPDATER.applyAsLong(this);\n+        }\n+\n+        static long hashCodeFor(LazySpecifiedFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n+    }\n+ * }\n+ * The example above also features a static method {@code hashCodeFor()} that acts as\n+ * the underlying hash function. This method can reside in another class.\n+ * <p>\n+ * Here is another example where a more low-level approach with VarHandle and MethodHandle\n+ * parameters is used:\n+ *\n+ * {@snippet lang=java:\n+    public final class MhFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hash\", int.class),\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n+                        -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public MhFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+\n+        \/\/ Used reflectively\n+        static int hashCodeFor(MhFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n+    }\n+ * }\n+ * There is a convenience method for this idiomatic case that looks like this:\n+ * {@snippet lang=java:\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(MethodHandles.lookup(), \"hash\", \"hashCodeFor\"));\n+ * }\n+ * This will use the provided {@link MethodHandles#lookup()} to look up the field\n+ * {@code hash} and also use the same lookup to look up a static method that takes\n+ * a {@code MhFoo} and returns an {@code int}.\n+ *\n+ * The provided {@code underlying} function must not recurse or the result of the\n+ * operation is unspecified.\n+ *\/\n+public final class StableFieldUpdater {\n+\n+    private StableFieldUpdater() {}\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final MethodHandles.Lookup LOCAL_LOOKUP = MethodHandles.lookup();\n+\n+    \/**\n+     * {@return a function that lazily sets the field named {@code fieldName} by invoking\n+     *          the static method in the {@link MethodHandles.Lookup#lookupClass()}\n+     *          named {@code staticUnderlyingMethodName} if the field was not previously\n+     *          set. Otherwise, the function returns the set field value}\n+     * <p>\n+     * If the {@code staticUnderlyingMethodName} returns zero, the value is replaced with\n+     * {@code -1} which is then stored in the field with the provided {@code fieldName}.\n+     *\n+     * @param lookup                     used to reflectively lookup entities\n+     * @param fieldName                  the name of the lazily set field (of type {@code int})\n+     * @param staticUnderlyingMethodName the name of the method to invoke when computing\n+     *                                   the hash value (invoked at most once)\n+     * @param <T>                        target type\n+     * @throws NullPointerException     if any of the provided parameters are {@code null}\n+     * @throws IllegalArgumentException if no {@code int} field can be found using the\n+     *                                  provided {@code lookup} and {@code fieldName}\n+     * @throws IllegalArgumentException if no {@code int} function can be found using the\n+     *                                  provided {@code lookup} and\n+     *                                  {@code staticUnderlyingMethodName} where the\n+     *                                  single method parameter is of type {@code T}.\n+     *\/\n+    public static <T> ToIntFunction<T> ofInt(MethodHandles.Lookup lookup,\n+                                             String fieldName,\n+                                             String staticUnderlyingMethodName) {\n+        return ofInt(\n+                MhUtil.findVarHandle(lookup, fieldName, int.class),\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(int.class, lookup.lookupClass())),\n+                -1);\n+    }\n+\n+    public static <T> ToIntFunction<T> ofInt(VarHandle accessor,\n+                                             MethodHandle underlying,\n+                                             int zeroReplacement) {\n+        check(accessor, int.class);\n+        var adaptedUnderlying = checkAndAdapt(underlying, int.class);\n+\n+        return new StableIntFieldUpdaterVarHandle<>(accessor, adaptedUnderlying, zeroReplacement);\n+    }\n+\n+    @CallerSensitive\n+    public static <T> ToIntFunction<T> ofInt(Class<T> holderType,\n+                                             String fieldName,\n+                                             ToIntFunction<? super T> underlying,\n+                                             int zeroReplacement) {\n+        Objects.requireNonNull(holderType);\n+        Objects.requireNonNull(fieldName);\n+        Objects.requireNonNull(underlying);\n+\n+        final long offset = offset(holderType, fieldName, int.class, Reflection.getCallerClass());\n+        return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+    }\n+\n+    \/**\n+     * {@return a function that lazily sets the field named {@code fieldName} by invoking\n+     *          the static method in the {@link MethodHandles.Lookup#lookupClass()}\n+     *          named {@code staticUnderlyingMethodName} if the field was not previously\n+     *          set. Otherwise, the function returns the set field value}\n+     * <p>\n+     * If the {@code staticUnderlyingMethodName} returns zero, the value is replaced with\n+     * {@code 1L<<32} which is then stored in the field with the provided {@code fieldName}.\n+     *\n+     * @param lookup                     used to reflectively lookup entities\n+     * @param fieldName                  the name of the lazily set field (of type {@code long})\n+     * @param staticUnderlyingMethodName the name of the method to invoke when computing\n+     *                                   the hash value (invoked at most once)\n+     * @param <T>                        target type\n+     * @throws NullPointerException      if any of the provided parameters are {@code null}\n+     * @throws IllegalArgumentException  if no {@code int} field can be found using the\n+     *                                   provided {@code lookup} and {@code fieldName}\n+     * @throws IllegalArgumentException if no {@code long} function can be found using the\n+     *                                  provided {@code lookup} and\n+     *                                  {@code staticUnderlyingMethodName} where the\n+     *                                  single method parameter is of type {@code T}.\n+     *\/\n+    public static <T> ToLongFunction<T> ofLong(MethodHandles.Lookup lookup,\n+                                               String fieldName,\n+                                               String staticUnderlyingMethodName) {\n+        return ofLong(\n+                MhUtil.findVarHandle(lookup, fieldName, long.class),\n+                MhUtil.findStatic(lookup, staticUnderlyingMethodName, MethodType.methodType(long.class, lookup.lookupClass())),\n+                1L << 31);\n+    }\n+\n+    public static <T> ToLongFunction<T> ofLong(VarHandle accessor,\n+                                               MethodHandle underlying,\n+                                               long zeroReplacement) {\n+        check(accessor, long.class);\n+        var adaptedUnderlying = checkAndAdapt(underlying, long.class);\n+\n+        return makeLong(accessor, adaptedUnderlying, zeroReplacement);\n+    }\n+\n+    @CallerSensitive\n+    public static <T> ToLongFunction<T> ofLong(Class<T> holderType,\n+                                               String fieldName,\n+                                               ToLongFunction<? super T> underlying,\n+                                               long zeroReplacement) {\n+        Objects.requireNonNull(holderType);\n+        Objects.requireNonNull(fieldName);\n+        Objects.requireNonNull(underlying);\n+\n+        final long offset = offset(holderType, fieldName, long.class, Reflection.getCallerClass());\n+        return makeLong(holderType, offset, underlying, zeroReplacement);\n+    }\n+\n+    public static CallSite lazyOfInt(MethodHandles.Lookup lookup,\n+                                     String unused,\n+                                     VarHandle accessor,\n+                                     MethodHandle underlying,\n+                                     int zeroReplacement) {\n+        check(accessor, int.class);\n+        var adaptedUnderlying = checkAndAdapt(underlying, int.class);\n+        var handle = MhUtil.findStatic(LOCAL_LOOKUP,\n+                \"ofInt\", MethodType.methodType(ToIntFunction.class, VarHandle.class, MethodHandle.class, int.class));\n+        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying, zeroReplacement));\n+    }\n+\n+    public static CallSite lazyOfLong(MethodHandles.Lookup lookup,\n+                                      String unused,\n+                                      VarHandle accessor,\n+                                      MethodHandle underlying,\n+                                      long zeroReplacement) {\n+        check(accessor, long.class);\n+        var adaptedUnderlying = checkAndAdapt(underlying, long.class);\n+        var handle = MhUtil.findStatic(LOCAL_LOOKUP,\n+                \"makeLong\", MethodType.methodType(ToLongFunction.class, VarHandle.class, MethodHandle.class, long.class));\n+        return new ConstantCallSite(MethodHandles.insertArguments(handle, 0, accessor, adaptedUnderlying, zeroReplacement));\n+    }\n+\n+    \/\/ Only to be used by classes that are used \"early\" in the init sequence.\n+    public static final class Raw {\n+\n+        private Raw() {}\n+\n+        public static <T> ToIntFunction<T> ofInt(Class<T> holderType,\n+                                                 long offset,\n+                                                 ToIntFunction<? super T> underlying,\n+                                                 int zeroReplacement) {\n+            Objects.requireNonNull(holderType);\n+            if (offset < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(underlying);\n+            return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        }\n+\n+        public static <T> ToLongFunction<T> ofLong(Class<T> holderType,\n+                                                   long offset,\n+                                                   ToLongFunction<? super T> underlying,\n+                                                   long zeroReplacement) {\n+            Objects.requireNonNull(holderType);\n+            if (offset < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(underlying);\n+            return makeLong(holderType, offset, underlying, zeroReplacement);\n+        }\n+\n+    }\n+\n+    private static <T> ToLongFunction<T> makeLong(Class<T> holderType,\n+                                                  long offset,\n+                                                  ToLongFunction<? super T> underlying,\n+                                                  long zeroReplacement) {\n+        if (Architecture.is64bit()) {\n+            \/\/ We are also relying on the fact that the VM will not place 64-bit\n+            \/\/ instance fields that can cross cache lines.\n+            return new StableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        } else {\n+            return new TearingStableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        }\n+    }\n+\n+    private static <T> ToLongFunction<T> makeLong(VarHandle accessor,\n+                                                  MethodHandle underlying,\n+                                                  long zeroReplacement) {\n+        if (Architecture.is64bit()) {\n+            \/\/ We are also relying on the fact that the VM will not place 64-bit\n+            \/\/ instance fields that can cross cache lines.\n+            return new StableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+        } else {\n+            return new TearingStableLongFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+        }\n+    }\n+\n+    private record StableIntFieldUpdater<T>(Class<T> holderType,\n+                                            long offset,\n+                                            ToIntFunction<? super T> underlying,\n+                                            int zeroReplacement) implements ToIntFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public int applyAsInt(T t) {\n+            checkInstanceOf(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, `int` is 32-bit.\n+            int v = UNSAFE.getInt(t, offset);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = UNSAFE.getIntAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsInt(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putIntRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record StableIntFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                     MethodHandle underlying,\n+                                                     int zeroReplacement) implements ToIntFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public int applyAsInt(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, `int` is 32-bit.\n+            int v = (int) accessor.get(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (int) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (int) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record StableLongFieldUpdater<T>(Class<T> holderType,\n+                                             long offset,\n+                                             ToLongFunction<? super T> underlying,\n+                                             long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            checkInstanceOf(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, the VM is 64-bit.\n+            long v = UNSAFE.getLong(t, offset);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = UNSAFE.getLongAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsLong(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putLongRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record TearingStableLongFieldUpdater<T>(Class<T> holderType,\n+                                                    long offset,\n+                                                    ToLongFunction<? super T> underlying,\n+                                                    long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            checkInstanceOf(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics and this VM is not 64-bit.\n+            long v = UNSAFE.getLongOpaque(t, offset);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = UNSAFE.getLongAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsLong(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putLongRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record StableLongFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                      MethodHandle underlying,\n+                                                      long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, the VM is 64-bit.\n+            long v = (long) accessor.get(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (long) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (long) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record TearingStableLongFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                             MethodHandle underlying,\n+                                                             long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics and this VM is not 64-bit.\n+            long v = (long) accessor.getOpaque(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (long) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (long) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    \/\/ Static support functions\n+\n+    @ForceInline\n+    private static void checkInstanceOf(Class<?> holderType, Object t) {\n+        if (!holderType.isInstance(t)) {\n+            throw new IllegalArgumentException(\"The provided t is not an instance of \" + holderType);\n+        }\n+    }\n+\n+    private static void check(VarHandle accessor, Class<?> varType) {\n+        \/\/ Implicit null check\n+        if (accessor.varType() != varType) {\n+            throw new IllegalArgumentException(\"Illegal accessor: \" + accessor);\n+        }\n+    }\n+\n+    private static MethodHandle checkAndAdapt(MethodHandle underlying, Class<?> returnType) {\n+        \/\/ Implicit null check\n+        final var underlyingType = underlying.type();\n+        if (underlyingType.returnType() != returnType || underlyingType.parameterCount() != 1) {\n+            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n+        }\n+        if (!underlyingType.parameterType(0).equals(Object.class)) {\n+            underlying = underlying.asType(underlyingType.changeParameterType(0, Object.class));\n+        }\n+        return underlying;\n+    }\n+\n+    private static long offset(Class<?> holderType,\n+                               String fieldName,\n+                               Class<?> fieldType,\n+                               Class<?> caller) {\n+        final Field field;\n+        try {\n+            field = findField(holderType, fieldName);\n+            int modifiers = field.getModifiers();\n+            if (Modifier.isFinal(modifiers)) {\n+                throw illegalField(\"non final fields\", field);\n+            }\n+            ReflectUtil.ensureMemberAccess(caller, holderType, null, modifiers);\n+            if (field.getType() != fieldType) {\n+                throw illegalField(\"fields of type '\" + fieldType + \"'\", field);\n+            }\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return UNSAFE.objectFieldOffset(field);\n+    }\n+\n+    private static IllegalArgumentException illegalField(String msg, Field field) {\n+        return new IllegalArgumentException(\"Only \" + msg + \" are supported. The provided field is '\" + field + \"'\");\n+    }\n+\n+    private static Field findField(Class<?> holderType, String fieldName) throws NoSuchFieldException {\n+        if (holderType.equals(Object.class)) {\n+            throw new NoSuchFieldException(\"'\" + fieldName + \"' in '\" + holderType + \"'\");\n+        }\n+        for (Field f : holderType.getDeclaredFields()) {\n+            if (f.getName().equals(fieldName)) {\n+                return f;\n+            }\n+        }\n+        return findField(holderType.getSuperclass(), fieldName);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":661,"deletions":0,"binary":false,"changes":661,"status":"added"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFieldUpdaterExampleTest examples in javadoc\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @modules java.base\/jdk.internal.invoke\n+ * @run junit StableFieldUpdaterExampleTest\n+ *\/\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.Override;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class StableFieldUpdaterExampleTest {\n+\n+    @interface Stable {} \/\/ No access to the real @Stable\n+\n+    public static final class Bar extends Base {\n+        public Bar(int hash) {\n+            super(hash);\n+        }\n+    }\n+\n+    public static final class Baz extends Base {\n+        public Baz(int hash) {\n+            super(hash);\n+        }\n+    }\n+\n+    public static abstract class Base {\n+\n+        final int hash;\n+\n+        public Base(int hash) {\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof Base that &&\n+                    this.getClass().equals(that.getClass()) &&\n+                    this.hash == that.hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"[hash=\" + hash + ']';\n+        }\n+    }\n+\n+\n+    static \/\/ Intentionally in unblessed order to allow the example to look nice\n+\n+    public final class Foo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        public Foo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(bar, baz);\n+        }\n+    }\n+\n+    static\n+\n+    public final class LazyFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToIntFunction<LazyFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(LazyFoo.class, \"hash\",\n+                        l -> Objects.hash(l.bar, l.baz), -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public LazyFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static\n+\n+    public final class LazySpecifiedFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n+                        LazySpecifiedFoo::hashCodeFor, 1L << 32);\n+\n+        @Stable\n+        private long hash;\n+\n+        public LazySpecifiedFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return (o instanceof Foo that)\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) HASH_UPDATER.applyAsLong(this);\n+        }\n+\n+        static long hashCodeFor(LazySpecifiedFoo foo) {\n+            return (foo.bar == null && foo.baz == null) ? 0 : Objects.hash(foo.bar, foo.baz);\n+        }\n+\n+    }\n+\n+    static\n+\n+    public final class MhFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+        private static final ToIntFunction<MhFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hash\", int.class),\n+                        MhUtil.findStatic(LOOKUP, \"hashCodeFor\", MethodType.methodType(int.class, MhFoo.class)),\n+                        -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public MhFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+\n+        \/\/ Used reflectively\n+        static int hashCodeFor(MhFoo foo) {\n+            return Objects.hash(foo.bar, foo.baz);\n+        }\n+    }\n+\n+    @Test\n+    void lazy() {\n+        var bar = new Bar(1);\n+        var baz = new Baz(2);\n+\n+        var foo = new LazyFoo(bar, baz);\n+\n+        assertEquals(Objects.hash(1, 2), foo.hashCode());\n+    }\n+\n+    @Test\n+    void lazySpec() {\n+        var foo = new LazySpecifiedFoo(null, null);\n+        assertEquals(0, foo.hashCode());\n+        assertEquals(0, foo.hashCode());\n+        assertEquals(1L << 32, foo.hash);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterExampleTest.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFieldUpdater implementations\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @modules java.base\/jdk.internal.invoke\n+ * @run junit StableFieldUpdaterTest\n+ *\/\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Function;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableFieldUpdaterTest {\n+\n+    private static final int ZERO_REPLACEMENT = 42;\n+    private static final String STRING = \"Abc\";\n+\n+    @Test\n+    void invariants() {\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(null, \"a\", _ -> 0, ZERO_REPLACEMENT));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(String.class, null, _ -> 0, ZERO_REPLACEMENT));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"hash\", null, ZERO_REPLACEMENT));\n+        var x = assertThrows(IllegalArgumentException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"dummy\", _ -> 0, ZERO_REPLACEMENT));\n+        assertEquals(\"Only fields of type 'int' are supported. The provided field is 'long StableFieldUpdaterTest$Foo.dummy'\", x.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"fooConstructors\")\n+    void basic(Function<String, HasHashField> namedConstructor) {\n+        final HasHashField foo = namedConstructor.apply(STRING);\n+        assertEquals(0L, foo.hash());\n+        int actual = foo.hashCode();\n+        assertEquals(STRING.hashCode(), actual);\n+        assertEquals(actual, foo.hash());\n+    }\n+\n+    @Test\n+    void recordFoo() {\n+        var recordFoo = new RecordFoo(STRING, 0);\n+        \/\/ The field is `final`\n+        var x = assertThrows(IllegalArgumentException.class,\n+                () -> StableFieldUpdater.ofInt(RecordFoo.class, \"hash\", _ -> 0, ZERO_REPLACEMENT));\n+        assertEquals(\"Only non final fields are supported. The provided field is 'private final int StableFieldUpdaterTest$RecordFoo.hash'\", x.getMessage());\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Test\n+    void uncheckedCall() {\n+        \/\/ Use a raw type\n+        ToIntFunction updater = StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        var object = new Object();\n+        var x = assertThrows(IllegalArgumentException.class, () -> updater.applyAsInt(object));\n+        assertEquals(\"The provided t is not an instance of class StableFieldUpdaterTest$Foo\", x.getMessage());\n+    }\n+\n+    @Test\n+    void lazyOfInt() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        CallSite callSite = StableFieldUpdater.lazyOfInt(lookup, \"\",\n+                MhUtil.findVarHandle(lookup, SimpleMhFoo.class, \"hash\", int.class),\n+                MhUtil.findStatic(lookup,SimpleMhFoo.class, \"computeHash\", MethodType.methodType(int.class, SimpleMhFoo.class))\n+                , -1);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ToIntFunction<SimpleMhFoo> hasher = (ToIntFunction<SimpleMhFoo>) callSite.getTarget().invoke();\n+\n+        var foo = new SimpleMhFoo(STRING);\n+        int hash = hasher.applyAsInt(foo);\n+        assertEquals(STRING.hashCode(), hash);\n+    }\n+\n+    @Test\n+    void lazyOfLong() throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        CallSite callSite = StableFieldUpdater.lazyOfLong(lookup, \"\",\n+                MhUtil.findVarHandle(lookup, LongMhFoo.class, \"hash\", long.class),\n+                MhUtil.findVirtual(lookup, LongMhFoo.class, \"hash0\", MethodType.methodType(long.class))\n+                , -1);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ToLongFunction<LongMhFoo> hasher = (ToLongFunction<LongMhFoo>) callSite.getTarget().invoke();\n+\n+        var foo = new LongMhFoo(STRING);\n+        long hash = hasher.applyAsLong(foo);\n+        assertEquals(STRING.hashCode(), hash);\n+    }\n+\n+    static final class Foo implements HasHashField {\n+\n+        private static final ToIntFunction<Foo> UPDATER =\n+                StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public Foo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+    }\n+\n+    static final class LongFoo implements HasHashField {\n+\n+        private static final ToLongFunction<LongFoo> UPDATER =\n+                StableFieldUpdater.ofLong(LongFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        long hash;\n+        long dummy;\n+\n+        public LongFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) UPDATER.applyAsLong(this);\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+    }\n+\n+    record RecordFoo(String string, int hash) {}\n+\n+    static final class InheritingFoo extends AbstractFoo implements HasHashField {\n+        private static final ToIntFunction<InheritingFoo> UPDATER =\n+                StableFieldUpdater.ofInt(InheritingFoo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+\n+        public InheritingFoo(String string) {\n+            super(string);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static abstract class AbstractFoo implements HasHashField {\n+        final String string;\n+        int hash;\n+\n+        public AbstractFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+    }\n+\n+    static final class MhFoo implements HasHashField {\n+\n+        private static final MethodHandle HASH_MH = MhUtil.findVirtual(MethodHandles.lookup(), \"hash0\", MethodType.methodType(int.class));\n+\n+        private static final ToIntFunction<MhFoo> UPDATER =\n+                StableFieldUpdater.ofInt(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", int.class), HASH_MH, ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public MhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+        public int hash0() {\n+            return string.hashCode();\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+    }\n+\n+    static final class SimpleMhFoo implements HasHashField {\n+\n+        private static final ToIntFunction<SimpleMhFoo> UPDATER =\n+                StableFieldUpdater.ofInt(MethodHandles.lookup(), \"hash\", \"computeHash\");\n+\n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public SimpleMhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+        \/\/ Used reflectively\n+        private static int computeHash(SimpleMhFoo target) {\n+            return target.string.hashCode();\n+        }\n+\n+    }\n+\n+    static final class LongMhFoo implements HasHashField {\n+\n+        private static final MethodHandle HASH_MH = MhUtil.findVirtual(MethodHandles.lookup(), \"hash0\", MethodType.methodType(long.class));\n+\n+        private static final ToLongFunction<LongMhFoo> UPDATER =\n+                StableFieldUpdater.ofLong(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", long.class), HASH_MH, ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        long hash;\n+        long dummy;\n+\n+        public LongMhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) UPDATER.applyAsLong(this);\n+        }\n+\n+        public long hash0() {\n+            return string.hashCode();\n+        }\n+\n+        @Override\n+        public long hash() {\n+            return hash;\n+        }\n+\n+    }\n+\n+    interface HasHashField {\n+        long hash();\n+    }\n+\n+    \/\/ Apparently, `hashCode()` is invoked if we create a stream of just `HasHashField`\n+    \/\/ instances so we provide the associated constructors instead.\n+    static Stream<Function<String, HasHashField>> fooConstructors() {\n+        return Stream.of(\n+                Foo::new,\n+                LongFoo::new,\n+                MhFoo::new,\n+                LongMhFoo::new,\n+                InheritingFoo::new,\n+                SimpleMhFoo::new\n+        );\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -101,1 +101,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.net.URI;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.ToIntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgs = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.lang.stable=ALL-UNNAMED\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableFieldUpdaterBenchmark {\n+\n+    private static final String STRING = \"https:\/\/some.site.com\";\n+\n+    private static final Base BASE = new Base(STRING);\n+    private static final Updater UPDATER = new Updater(STRING);\n+    private static final MhUpdater MH_UPDATER = new MhUpdater(STRING);\n+    private static final URI U_R_I = URI.create(STRING);\n+\n+    private final Base base = new Base(STRING);\n+    private final Updater updater = new Updater(STRING);\n+    private final MhUpdater mhUpdater = new MhUpdater(STRING);\n+    private static final URI uri = URI.create(STRING);\n+\n+    @Benchmark\n+    public int baseStatic() {\n+        return BASE.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int base() {\n+        return base.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int mhUpdaterStatic() {\n+        return MH_UPDATER.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int mhUpdater() {\n+        return mhUpdater.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updaterStatic() {\n+        return UPDATER.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updater() {\n+        return updater.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uriStatic() {\n+        return U_R_I.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uri() {\n+        return uri.hashCode();\n+    }\n+\n+    static final class Base extends Abstract {\n+        Base(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = hashCode;\n+            if (h == 0) {\n+                hashCode = h = string.hashCode();\n+            }\n+            return h;\n+        }\n+    }\n+\n+    static final class Updater extends Abstract {\n+\n+        private static final ToIntFunction<Updater> HASH_CODE_UPDATER =\n+                StableFieldUpdater.ofInt(Updater.class, \"hashCode\", new ToIntFunction<>() {\n+                    @Override\n+                    public int applyAsInt(Updater updater) {\n+                        return updater.string.hashCode();\n+                    }\n+                }, -1);\n+\n+        Updater(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_CODE_UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static final class MhUpdater extends Abstract {\n+\n+        private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+        private static final ToIntFunction<MhUpdater> HASH_CODE_UPDATER =\n+                StableFieldUpdater.ofInt(\n+                        MhUtil.findVarHandle(LOOKUP, \"hashCode\", int.class),\n+                        MhUtil.findVirtual(LOOKUP, \"hashCode0\", MethodType.methodType(int.class)),\n+                        -1);\n+\n+        MhUpdater(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_CODE_UPDATER.applyAsInt(this);\n+        }\n+\n+        private int hashCode0() {\n+            return string.hashCode();\n+        }\n+\n+    }\n+\n+    static class Abstract {\n+\n+        final String string;\n+        int hashCode;\n+\n+        Abstract(String string) {\n+            this.string = string;\n+        }\n+    }\n+\n+\n+    \/\/ From j.i.i.MhUtil\n+\n+    private static final class MhUtil {\n+\n+        public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                              String name,\n+                                              Class<?> type) {\n+            return findVarHandle(lookup, lookup.lookupClass(), name, type);\n+        }\n+\n+        public static VarHandle findVarHandle(MethodHandles.Lookup lookup,\n+                                              Class<?> recv,\n+                                              String name,\n+                                              Class<?> type) {\n+            try {\n+                return lookup.findVarHandle(recv, name, type);\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+\n+        public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                               String name,\n+                                               MethodType type) {\n+            return findVirtual(lookup, lookup.lookupClass(), name, type);\n+        }\n+\n+        public static MethodHandle findVirtual(MethodHandles.Lookup lookup,\n+                                               Class<?> refc,\n+                                               String name,\n+                                               MethodType type) {\n+            try {\n+                return lookup.findVirtual(refc, name, type);\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableFieldUpdaterBenchmark.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"}]}