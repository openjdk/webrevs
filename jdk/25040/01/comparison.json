{"files":[{"patch":"@@ -95,0 +95,1 @@\n+        --add-exports java.base\/jdk.internal.lang.stable=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import jdk.internal.misc.Unsafe;\n@@ -50,0 +52,1 @@\n+import java.util.function.ToIntFunction;\n@@ -96,0 +99,9 @@\n+\n+    private static final ToIntFunction<Method> HASH_UPDATER =\n+            StableFieldUpdater.Raw.ofInt(Method.class, Unsafe.getUnsafe().objectFieldOffset(Method.class, \"hash\"), new ToIntFunction<Method>() {\n+                @Override\n+                public int applyAsInt(Method method) {\n+                    return method.getDeclaringClass().getName().hashCode() ^\n+                            method.getName().hashCode();\n+                }\n+            }, 0); \/\/ The `hashCode()` is specified so, zeroReplacement is 0\n@@ -97,0 +109,3 @@\n+\n+    \/\/ Used reflectively via HASH_UPDATER\n+    @Stable\n@@ -363,7 +378,1 @@\n-        int hc = hash;\n-\n-        if (hc == 0) {\n-            hc = hash = getDeclaringClass().getName().hashCode() ^ getName()\n-                .hashCode();\n-        }\n-        return hc;\n+        return HASH_UPDATER.applyAsInt(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import java.util.function.ToIntFunction;\n+\n@@ -45,0 +47,3 @@\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n@@ -547,0 +552,7 @@\n+\n+    private static final ToIntFunction<URI> HASH_UPDATER = StableFieldUpdater.ofInt(\n+            URI.class, \"hash\", new ToIntFunction<>() {\n+                @ForceInline @Override public int applyAsInt(URI uri) { return uri.hashCode0(); }}, -1);\n+\n+    \/\/ Used reflectively by HASH_UPDATER\n+    @Stable\n@@ -1578,6 +1590,16 @@\n-        int h = hash;\n-        if (h == 0) {\n-            h = hashIgnoringCase(0, scheme);\n-            h = hash(h, fragment);\n-            if (isOpaque()) {\n-                h = hash(h, schemeSpecificPart);\n+        return HASH_UPDATER.applyAsInt(this);\n+    }\n+\n+    private int hashCode0() {\n+        int h = 0;\n+        h = hashIgnoringCase(0, scheme);\n+        h = hash(h, fragment);\n+        if (isOpaque()) {\n+            h = hash(h, schemeSpecificPart);\n+        } else {\n+            h = hash(h, path);\n+            h = hash(h, query);\n+            if (host != null) {\n+                h = hash(h, userInfo);\n+                h = hashIgnoringCase(h, host);\n+                h += 1949 * port;\n@@ -1585,12 +1607,1 @@\n-                h = hash(h, path);\n-                h = hash(h, query);\n-                if (host != null) {\n-                    h = hash(h, userInfo);\n-                    h = hashIgnoringCase(h, host);\n-                    h += 1949 * port;\n-                } else {\n-                    h = hash(h, authority);\n-                }\n-            }\n-            if (h != 0) {\n-                hash = h;\n+                h = hash(h, authority);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.vm.annotation.ForceInline;\n+import sun.reflect.misc.ReflectUtil;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.Objects;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+\n+\/**\n+ * Stable field updaters.\n+ * <p>\n+ * This class allows, for example, effortless conversion of immutable classes to use lazy\n+ * {@link Object#hashCode()}.\n+ * <p>\n+ * Here is an example of how to convert\n+ *\n+ * {@snippet lang=java:\n+ *    public final class Foo {\n+ *\n+ *         private final Bar bar;\n+ *         private final Baz baz;\n+ *\n+ *         public Foo(Bar bar, Baz baz) {\n+ *             this.bar = bar;\n+ *             this.baz = baz;\n+ *         }\n+ *\n+ *         @Override\n+ *         public boolean equals(Object o) {\n+ *             return o instanceof Foo that\n+ *                     && Objects.equals(this.bar, that.bar)\n+ *                     && Objects.equals(this.baz, that.baz);\n+ *         }\n+ *\n+ *         @Override\n+ *         public int hashCode() {\n+ *             return Objects.hash(bar, baz);\n+ *         }\n+ *     }\n+ * }\n+ * to use {@code @Stable} lazy hashing:\n+ *\n+ * {@snippet lang=java:\n+ *    public final class LazyFoo {\n+ *\n+ *         private final Bar bar;\n+ *         private final Baz baz;\n+ *\n+ *         private static final ToIntFunction<LazyFoo> HASH_UPDATER =\n+ *                 StableFieldUpdater.ofInt(LazyFoo.class, \"hash\",\n+ *                         l -> Objects.hash(l.bar, l.baz), -1);\n+ *\n+ *         @Stable\n+ *         private int hash;\n+ *\n+ *         public LazyFoo(Bar bar, Baz baz) {\n+ *             this.bar = bar;\n+ *             this.baz = baz;\n+ *         }\n+ *\n+ *         @Override\n+ *         public boolean equals(Object o) {\n+ *             return o instanceof Foo that\n+ *                     && Objects.equals(this.bar, that.bar)\n+ *                     && Objects.equals(this.baz, that.baz);\n+ *         }\n+ *\n+ *         @Override\n+ *         public int hashCode() {\n+ *             return HASH_UPDATER.applyAsInt(this);\n+ *         }\n+ *     }\n+ * }\n+ * <p>\n+ * If the underlying hash lamba returns zero, it is replaced with {@code -1}.\n+ *\n+ * In cases where the entire range of hash codes are strictly specified (as it is for\n+ * {@code String}), a {@code long} field can be used instead, and then we can use\n+ * {@code 1 << 32} as a token for zero (as the lower 32 bits are zero) and then just\n+ * cast to an {@code int} as shown in this example:\n+ *\n+ * {@snippet lang=java:\n+        public final class LazySpecifiedFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n+                        l -> Objects.hash(l.bar, l.baz), 1L << 32);\n+\n+        @Stable\n+        private long hash;\n+\n+        public LazySpecifiedFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+             return (o instanceof Foo that)\n+                     && Objects.equals(this.bar, that.bar)\n+                     && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) HASH_UPDATER.applyAsLong(this);\n+        }\n+    }\n+ * }\n+ * <p>\n+ * The provided {@code underlying} function must not recurse or the result of the\n+ * operation is unspecified.\n+ *\/\n+public final class StableFieldUpdater {\n+\n+    private StableFieldUpdater() {}\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @CallerSensitive\n+    public static <T> ToIntFunction<T> ofInt(Class<T> holderType,\n+                                             String fieldName,\n+                                             ToIntFunction<? super T> underlying,\n+                                             int zeroReplacement) {\n+        Objects.requireNonNull(holderType);\n+        Objects.requireNonNull(fieldName);\n+        Objects.requireNonNull(underlying);\n+\n+        final long offset = offset(holderType, fieldName, int.class, Reflection.getCallerClass());\n+        return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+    }\n+\n+    @CallerSensitive\n+    public static <T> ToLongFunction<T> ofLong(Class<T> holderType,\n+                                               String fieldName,\n+                                               ToLongFunction<? super T> underlying,\n+                                               long zeroReplacement) {\n+        Objects.requireNonNull(holderType);\n+        Objects.requireNonNull(fieldName);\n+        Objects.requireNonNull(underlying);\n+\n+        final long offset = offset(holderType, fieldName, long.class, Reflection.getCallerClass());\n+        return makeLong(holderType, offset, underlying, zeroReplacement);\n+    }\n+\n+    \/\/ Only to be used by classes that are used \"early\" in the init sequence.\n+    public static final class Raw {\n+\n+        private Raw() {}\n+\n+        public static <T> ToIntFunction<T> ofInt(Class<T> holderType,\n+                                                 long offset,\n+                                                 ToIntFunction<? super T> underlying,\n+                                                 int zeroReplacement) {\n+            Objects.requireNonNull(holderType);\n+            if (offset < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(underlying);\n+            return new StableIntFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        }\n+\n+        public static <T> ToLongFunction<T> ofLong(Class<T> holderType,\n+                                                   long offset,\n+                                                   ToLongFunction<? super T> underlying,\n+                                                   long zeroReplacement) {\n+            Objects.requireNonNull(holderType);\n+            if (offset < 0) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(underlying);\n+            return makeLong(holderType, offset, underlying, zeroReplacement);\n+        }\n+\n+    }\n+\n+    private static <T> ToLongFunction<T> makeLong(Class<T> holderType,\n+                                                  long offset,\n+                                                  ToLongFunction<? super T> underlying,\n+                                                  long zeroReplacement) {\n+        if (Architecture.is64bit()) {\n+            \/\/ We are also relying on the fact that the VM will not place 64-bit\n+            \/\/ instance fields that can cross cache lines.\n+            return new StableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        } else {\n+            return new TearingStableLongFieldUpdater<>(holderType, offset, underlying, zeroReplacement);\n+        }\n+    }\n+\n+    private record StableIntFieldUpdater<T>(Class<T> holderType,\n+                                            long offset,\n+                                            ToIntFunction<? super T> underlying,\n+                                            int zeroReplacement) implements ToIntFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public int applyAsInt(T t) {\n+            checkType(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, `int` is 32-bit.\n+            int v = UNSAFE.getInt(t, offset);\n+            if (v == 0) {\n+                \/\/ StableUtil.preventReentry(t);\n+                synchronized (t) {\n+                    v = UNSAFE.getIntAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsInt(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putIntRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record StableLongFieldUpdater<T>(Class<T> holderType,\n+                                             long offset,\n+                                             ToLongFunction<? super T> underlying,\n+                                             long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            checkType(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, the VM is 64-bit.\n+            long v = UNSAFE.getLong(t, offset);\n+            if (v == 0) {\n+                \/\/ StableUtil.preventReentry(t);\n+                synchronized (t) {\n+                    v = UNSAFE.getLongAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsLong(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putLongRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    private record TearingStableLongFieldUpdater<T>(Class<T> holderType,\n+                                                    long offset,\n+                                                    ToLongFunction<? super T> underlying,\n+                                                    long zeroReplacement) implements ToLongFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public long applyAsLong(T t) {\n+            checkType(holderType, t);\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics and this VM is not 64-bit.\n+            long v = UNSAFE.getLongOpaque(t, offset);\n+            if (v == 0) {\n+                \/\/ StableUtil.preventReentry(t);\n+                synchronized (t) {\n+                    v = UNSAFE.getLongAcquire(t, offset);\n+                    if (v == 0) {\n+                        v = underlying.applyAsLong(t);\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        UNSAFE.putLongRelease(t, offset, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n+    \/\/ Static support functions\n+\n+    @ForceInline\n+    private static void checkType(Class<?> holderType, Object t) {\n+        if (!holderType.isInstance(t)) {\n+            throw new IllegalArgumentException(\"The provided t is not an instance of \" + holderType);\n+        }\n+    }\n+\n+    private static long offset(Class<?> holderType,\n+                               String fieldName,\n+                               Class<?> fieldType,\n+                               Class<?> caller) {\n+        final Field field;\n+        try {\n+            field = findField(holderType, fieldName);\n+            int modifiers = field.getModifiers();\n+            if (Modifier.isFinal(modifiers)) {\n+                throw illegalField(\"non final fields\", field);\n+            }\n+            ReflectUtil.ensureMemberAccess(caller, holderType, null, modifiers);\n+            if (field.getType() != fieldType) {\n+                throw illegalField(\"fields of type '\" + fieldType + \"'\", field);\n+            }\n+        } catch (NoSuchFieldException | IllegalAccessException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return UNSAFE.objectFieldOffset(field);\n+    }\n+\n+    private static IllegalArgumentException illegalField(String msg, Field field) {\n+        return new IllegalArgumentException(\"Only \" + msg + \" are supported. The provided field is '\" + field + \"'\");\n+    }\n+\n+    private static Field findField(Class<?> holderType, String fieldName) throws NoSuchFieldException {\n+        if (holderType.equals(Object.class)) {\n+            throw new NoSuchFieldException(\"'\" + fieldName + \"' in '\" + holderType + \"'\");\n+        }\n+        for (Field f : holderType.getDeclaredFields()) {\n+            if (f.getName().equals(fieldName)) {\n+                return f;\n+            }\n+        }\n+        return findField(holderType.getSuperclass(), fieldName);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.misc.Unsafe;\n+\n+import java.lang.reflect.Field;\n@@ -32,0 +35,2 @@\n+import java.util.function.Function;\n+import java.util.function.ToIntFunction;\n@@ -99,0 +104,8 @@\n+    \/\/ This method is not annotated with @ForceInline as it is always called\n+    \/\/ in a slow path.\n+    static void preventReentry(Object obj) {\n+        if (Thread.holdsLock(obj)) {\n+            throw new IllegalStateException(\"Recursive initialization of a stable value is illegal\");\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        preventReentry();\n+        StableUtil.preventReentry(this);\n@@ -135,1 +135,1 @@\n-        preventReentry();\n+        StableUtil.preventReentry(this);\n@@ -171,8 +171,0 @@\n-    \/\/ This method is not annotated with @ForceInline as it is always called\n-    \/\/ in a slow path.\n-    private void preventReentry() {\n-        if (Thread.holdsLock(this)) {\n-            throw new IllegalStateException(\"Recursive initialization of a stable value is illegal\");\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFieldUpdaterExampleTest examples in javadoc\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit StableFieldUpdaterExampleTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.Override;\n+import java.util.Objects;\n+import java.util.function.ToIntFunction;\n+import java.util.function.ToLongFunction;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+final class StableFieldUpdaterExampleTest {\n+\n+    @interface Stable {} \/\/ No access to the real @Stable\n+\n+    public static final class Bar extends Base {\n+        public Bar(int hash) {\n+            super(hash);\n+        }\n+    }\n+\n+    public static final class Baz extends Base {\n+        public Baz(int hash) {\n+            super(hash);\n+        }\n+    }\n+\n+    public static abstract class Base {\n+\n+        final int hash;\n+\n+        public Base(int hash) {\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof Base that &&\n+                    this.getClass().equals(that.getClass()) &&\n+                    this.hash == that.hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \"[hash=\" + hash + ']';\n+        }\n+    }\n+\n+\n+    static \/\/ Intentionally in unblessed order to allow the example to look nice\n+\n+    public final class Foo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        public Foo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(bar, baz);\n+        }\n+    }\n+\n+    static\n+\n+    public final class LazyFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToIntFunction<LazyFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofInt(LazyFoo.class, \"hash\",\n+                        l -> Objects.hash(l.bar, l.baz), -1);\n+\n+        @Stable\n+        private int hash;\n+\n+        public LazyFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Foo that\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static\n+\n+    public final class LazySpecifiedFoo {\n+\n+        private final Bar bar;\n+        private final Baz baz;\n+\n+        private static final ToLongFunction<LazySpecifiedFoo> HASH_UPDATER =\n+                StableFieldUpdater.ofLong(LazySpecifiedFoo.class, \"hash\",\n+                        l -> (l.bar == null && l.baz == null) ? 0 : Objects.hash(l.bar, l.baz), 1L << 32);\n+\n+        @Stable\n+        private long hash;\n+\n+        public LazySpecifiedFoo(Bar bar, Baz baz) {\n+            this.bar = bar;\n+            this.baz = baz;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return (o instanceof Foo that)\n+                    && Objects.equals(this.bar, that.bar)\n+                    && Objects.equals(this.baz, that.baz);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (int) HASH_UPDATER.applyAsLong(this);\n+        }\n+    }\n+\n+    @Test\n+    void lazy() {\n+        var bar = new Bar(1);\n+        var baz = new Baz(2);\n+\n+        var foo = new LazyFoo(bar, baz);\n+\n+        assertEquals(Objects.hash(1, 2), foo.hashCode());\n+    }\n+\n+    @Test\n+    void lazySpec() {\n+        var foo = new LazySpecifiedFoo(null, null);\n+        assertEquals(0, foo.hashCode());\n+        assertEquals(0, foo.hashCode());\n+        assertEquals(1L << 32, foo.hash);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterExampleTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Basic tests for StableFieldUpdater implementations\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit StableFieldUpdaterTest\n+ *\/\n+\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.ToIntFunction;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class StableFieldUpdaterTest {\n+\n+    private static final int ZERO_REPLACEMENT = 42;\n+    private static final String STRING = \"Abc\";\n+    private static final ToIntFunction<String> STRING_HASH_CODE = String::hashCode;\n+\n+    @Test\n+    void invariants() {\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(null, \"a\", _ -> 0, ZERO_REPLACEMENT));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(String.class, null, _ -> 0, ZERO_REPLACEMENT));\n+        assertThrows(NullPointerException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"hash\", null, ZERO_REPLACEMENT));\n+        var x = assertThrows(IllegalArgumentException.class, () -> StableFieldUpdater.ofInt(Foo.class, \"dummy\", _ -> 0, ZERO_REPLACEMENT));\n+        assertEquals(\"Only fields of type 'int' are supported. The provided field is 'long StableFieldUpdaterTest$Foo.dummy'\", x.getMessage());\n+    }\n+\n+    @Test\n+    void foo() {\n+        var foo = new Foo(STRING);\n+        assertEquals(0, foo.hash);\n+        assertEquals(STRING.hashCode(), foo.hashCode());\n+        assertEquals(STRING.hashCode(), foo.hash);\n+    }\n+\n+    @Test\n+    void recordFoo() {\n+        var recordFoo = new RecordFoo(STRING, 0);\n+        \/\/ The field is `final`\n+        var x = assertThrows(IllegalArgumentException.class,\n+                () -> StableFieldUpdater.ofInt(RecordFoo.class, \"hash\", _ -> 0, ZERO_REPLACEMENT));\n+        assertEquals(\"Only non final fields are supported. The provided field is 'private final int StableFieldUpdaterTest$RecordFoo.hash'\", x.getMessage());\n+    }\n+\n+    @Test\n+    void barInherit() {\n+        var bar = new Bar(STRING);\n+        assertEquals(0, bar.hash);\n+        assertEquals(STRING.hashCode(), bar.hashCode());\n+        assertEquals(STRING.hashCode(), bar.hash);\n+    }\n+\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @Test\n+    void uncheckedCall() {\n+        \/\/ Use a raw type\n+        ToIntFunction updater = StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        var object = new Object();\n+        var x = assertThrows(IllegalArgumentException.class, () -> updater.applyAsInt(object));\n+        assertEquals(\"The provided t is not an instance of class StableFieldUpdaterTest$Foo\", x.getMessage());\n+    }\n+\n+    static final class Foo {\n+\n+        private static final ToIntFunction<Foo> UPDATER =\n+                StableFieldUpdater.ofInt(Foo.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public Foo(String string) {\n+            this.string = string;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+    }\n+\n+    record RecordFoo(String string, int hash) {}\n+\n+    static final class Bar extends AbstractBar {\n+        private static final ToIntFunction<Bar> UPDATER =\n+                StableFieldUpdater.ofInt(Bar.class, \"hash\", f -> f.string.hashCode(), ZERO_REPLACEMENT);\n+\n+        public Bar(String string) {\n+            super(string);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static abstract class AbstractBar {\n+        final String string;\n+        int hash;\n+\n+        public AbstractBar(String string) {\n+            this.string = string;\n+        }\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -101,1 +101,0 @@\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.stable;\n+\n+import jdk.internal.lang.stable.StableFieldUpdater;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.net.URI;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.ToIntFunction;\n+\n+\/**\n+ * Benchmark measuring StableValue performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark) \/\/ Share the same state instance (for contention)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@Fork(value = 2, jvmArgs = {\"--enable-preview\", \"--add-exports\", \"java.base\/jdk.internal.lang.stable=ALL-UNNAMED\"})\n+@Threads(Threads.MAX)   \/\/ Benchmark under contention\n+public class StableUpdatersBenchmark {\n+\n+    private static final String STRING = \"https:\/\/some.site.com\";\n+\n+    private static final Base BASE = new Base(STRING);\n+    private static final Updater UPDATER = new Updater(STRING);\n+    private static final URI U_R_I = URI.create(STRING);\n+\n+    private final Base base = new Base(STRING);\n+    private final Updater updater = new Updater(STRING);\n+    private static final URI uri = URI.create(STRING);\n+\n+    @Benchmark\n+    public int baseStatic() {\n+        return BASE.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int base() {\n+        return base.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updaterStatic() {\n+        return UPDATER.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int updater() {\n+        return updater.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uriStatic() {\n+        return U_R_I.hashCode();\n+    }\n+\n+    @Benchmark\n+    public int uri() {\n+        return uri.hashCode();\n+    }\n+\n+    static final class Base extends Abstract {\n+        Base(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            int h = hashCode;\n+            if (h == 0) {\n+                hashCode = h = string.hashCode();\n+            }\n+            return h;\n+        }\n+    }\n+\n+    static final class Updater extends Abstract {\n+\n+        private static final ToIntFunction<Updater> HASH_CODE_UPDATER =\n+                StableFieldUpdater.ofInt(Updater.class, \"hashCode\", new ToIntFunction<>() {\n+                    @Override\n+                    public int applyAsInt(Updater updater) {\n+                        return updater.string.hashCode();\n+                    }\n+                }, -1);\n+\n+        Updater(String string) { super(string); }\n+\n+        @Override\n+        public int hashCode() {\n+            return HASH_CODE_UPDATER.applyAsInt(this);\n+        }\n+    }\n+\n+    static class Abstract {\n+\n+        final String string;\n+        int hashCode;\n+\n+        Abstract(String string) {\n+            this.string = string;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableUpdatersBenchmark.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}