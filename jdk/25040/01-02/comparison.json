{"files":[{"patch":"@@ -35,0 +35,4 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n@@ -155,0 +159,18 @@\n+    public static <T> ToIntFunction<T> ofInt(VarHandle accessor,\n+                                             MethodHandle underlying,\n+                                             int zeroReplacement) {\n+        Objects.requireNonNull(accessor);\n+        Objects.requireNonNull(underlying);\n+\n+        if (accessor.varType() != int.class) {\n+            throw new IllegalArgumentException(\"Illegal accessor: \" + accessor);\n+        }\n+        if (underlying.type().returnType() != int.class || underlying.type().parameterCount() != 1) {\n+            throw new IllegalArgumentException(\"Illegal underlying function: \" + underlying);\n+        }\n+        if (!underlying.type().parameterType(0).equals(Object.class)) {\n+            underlying = underlying.asType(underlying.type().changeParameterType(0, Object.class));\n+        }\n+        return new StableIntFieldUpdaterVarHandle<>(accessor, underlying, zeroReplacement);\n+    }\n+\n@@ -256,0 +278,33 @@\n+\n+    private record StableIntFieldUpdaterVarHandle<T>(VarHandle accessor,\n+                                                     MethodHandle underlying,\n+                                                     int zeroReplacement) implements ToIntFunction<T> {\n+\n+        @ForceInline\n+        @Override\n+        public int applyAsInt(T t) {\n+            \/\/ Plain semantics suffice here as we are not dealing with a reference (for\n+            \/\/ a reference, the internal state initialization can be reordered with\n+            \/\/ other store ops). JLS (24) 17.4 states that 64-bit fields tear under\n+            \/\/ plain memory semantics. But, `int` is 32-bit.\n+            int v = (int) accessor.get(t);\n+            if (v == 0) {\n+                synchronized (t) {\n+                    v = (int) accessor.getAcquire(t);\n+                    if (v == 0) {\n+                        try {\n+                            v = (int) underlying.invokeExact(t);\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                        if (v == 0) {\n+                            v = zeroReplacement;\n+                        }\n+                        accessor.setRelease(t, v);\n+                    }\n+                }\n+            }\n+            return v;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFieldUpdater.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules java.base\/jdk.internal.invoke\n@@ -30,0 +31,1 @@\n+import jdk.internal.invoke.MhUtil;\n@@ -33,0 +35,4 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n@@ -58,0 +64,9 @@\n+\n+    }\n+\n+    @Test\n+    void mhFoo() {\n+        var foo = new MhFoo(STRING);\n+        assertEquals(0, foo.hash);\n+        assertEquals(STRING.hashCode(), foo.hashCode());\n+        assertEquals(STRING.hashCode(), foo.hash);\n@@ -132,0 +147,25 @@\n+    static final class MhFoo {\n+\n+        private static final MethodHandle HASH_MH = MhUtil.findVirtual(MethodHandles.lookup(), \"hash0\", MethodType.methodType(int.class));\n+\n+        private static final ToIntFunction<MhFoo> UPDATER =\n+                StableFieldUpdater.ofInt(MhUtil.findVarHandle(MethodHandles.lookup(), \"hash\", int.class), HASH_MH, ZERO_REPLACEMENT);\n+        private final String string;\n+\n+        int hash;\n+        long dummy;\n+\n+        public MhFoo(String string) {\n+            this.string = string;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return UPDATER.applyAsInt(this);\n+        }\n+\n+        public int hash0() {\n+            return string.hashCode();\n+        }\n+\n+    }\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFieldUpdaterTest.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}