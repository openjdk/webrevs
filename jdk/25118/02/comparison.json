{"files":[{"patch":"@@ -845,0 +845,3 @@\n+\/\/ Return true if the execution after the provided bytecode continues at the\n+\/\/ next bytecode in the code. This is not the case for gotos, returns, and\n+\/\/ throws.\n@@ -847,2 +850,0 @@\n-    \/\/ List may be incomplete.  Here we really only care about bytecodes where compiled code\n-    \/\/ can deoptimize.\n@@ -852,0 +853,10 @@\n+    case Bytecodes::_areturn:\n+    case Bytecodes::_dreturn:\n+    case Bytecodes::_freturn:\n+    case Bytecodes::_ireturn:\n+    case Bytecodes::_lreturn:\n+    case Bytecodes::_jsr:\n+    case Bytecodes::_ret:\n+    case Bytecodes::_return:\n+    case Bytecodes::_lookupswitch:\n+    case Bytecodes::_tableswitch:\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=return\n+ * @bug 8336906\n+ * @summary Ensure VerifyStack does not crash on bytecodes in unreachable basic blocks after return.\n+ * @compile TestVerifyStackWithUnreachableBytecodeImpl.jasm TestVerifyStackWithUnreachableBytecode.java\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -Xcomp\n+ *      -XX:CompileCommand=compileonly,compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeImpl.test*\n+ *      compiler.interpreter.TestVerifyStackWithUnreachableBytecode return\n+ *\/\n+\n+\/*\n+ * @test id=areturn\n+ * @bug 8336906\n+ * @summary Ensure VerifyStack does not crash on bytecodes in unreachable basic blocks after areturn.\n+ * @compile TestVerifyStackWithUnreachableBytecodeImpl.jasm TestVerifyStackWithUnreachableBytecode.java\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -Xcomp\n+ *      -XX:CompileCommand=compileonly,compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeImpl.test*\n+ *      compiler.interpreter.TestVerifyStackWithUnreachableBytecode areturn\n+ *\/\n+\n+\/*\n+ * @test id=goto\n+ * @bug 8336906 8271055\n+ * @summary Ensure VerifyStack does not crash on bytecodes in unreachable basic blocks after goto.\n+ * @compile TestVerifyStackWithUnreachableBytecodeImpl.jasm TestVerifyStackWithUnreachableBytecode.java\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -Xcomp\n+ *      -XX:CompileCommand=compileonly,compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeImpl.test*\n+ *      compiler.interpreter.TestVerifyStackWithUnreachableBytecode goto\n+ *\/\n+\n+\/*\n+ * @test id=gotow\n+ * @bug 8336906 8271055\n+ * @summary Ensure VerifyStack does not crash on bytecodes in unreachable basic blocks after gotow.\n+ * @compile TestVerifyStackWithUnreachableBytecodeImpl.jasm TestVerifyStackWithUnreachableBytecode.java\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -Xcomp\n+ *      -XX:CompileCommand=compileonly,compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeImpl.test*\n+ *      compiler.interpreter.TestVerifyStackWithUnreachableBytecode gotow\n+ *\/\n+\n+package compiler.interpreter;\n+\n+import compiler.interpreter.TestVerifyStackWithUnreachableBytecodeImpl;\n+\n+public class TestVerifyStackWithUnreachableBytecode {\n+    public static void main(String[] args) {\n+        TestCase t = testCaseFromString(args[0]);\n+\n+        \/\/ The following is designed to cause a deopt with the reason `null_assert_or_unreached0`\n+        \/\/ when accessing A.val using getstatic due to the class B not being loaded and the consequent\n+        \/\/ assumption of A.val == null.\n+        TestVerifyStackWithUnreachableBytecodeA.val = null;\n+        dispatchTest(t);\n+        TestVerifyStackWithUnreachableBytecodeA.val = new TestVerifyStackWithUnreachableBytecodeB(42);\n+        dispatchTest(t);\n+    }\n+\n+    private enum TestCase {\n+        ARETURN,\n+        GOTO,\n+        GOTOW,\n+        RETURN;\n+    }\n+\n+    private static TestCase testCaseFromString(String s) {\n+        return switch (s) {\n+            case \"areturn\" -> TestCase.ARETURN;\n+            case \"return\" -> TestCase.RETURN;\n+            case \"goto\" -> TestCase.GOTO;\n+            case \"gotow\" -> TestCase.GOTOW;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + s);\n+        };\n+    }\n+\n+    private static void dispatchTest(TestCase testCase) {\n+        switch (testCase) {\n+            case ARETURN -> TestVerifyStackWithUnreachableBytecodeImpl.testAreturn();\n+            case RETURN -> TestVerifyStackWithUnreachableBytecodeImpl.testReturn();\n+            case GOTO -> TestVerifyStackWithUnreachableBytecodeImpl.testGoto();\n+            case GOTOW -> TestVerifyStackWithUnreachableBytecodeImpl.testGotow();\n+        }\n+    }\n+}\n+\n+class TestVerifyStackWithUnreachableBytecodeA {\n+    public static TestVerifyStackWithUnreachableBytecodeB val = null;\n+}\n+\n+class TestVerifyStackWithUnreachableBytecodeB {\n+    public int val = 0;\n+\n+    TestVerifyStackWithUnreachableBytecodeB(int v) { this.val = v; }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/interpreter\/TestVerifyStackWithUnreachableBytecode.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler\/interpreter;\n+\n+\/\/ We need a class file format version < 50:0 so we do not need to specify a\n+\/\/ stack map for the unreachable bytecodes, which are the reason this test\n+\/\/ relies on a JASM implementation.\n+super class TestVerifyStackWithUnreachableBytecodeImpl version 49:0\n+{\n+    public Method \"<init>\":\"()V\"\n+        stack  1 locals  1\n+    {\n+           aload_0;\n+           invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+           return;\n+    }\n+    public static Method testAreturn:\"()Ljava\/lang\/Object;\"\n+        stack 1 locals 0\n+    {\n+        \/\/ If A not loaded -> trap for TestVerifyStackWithUnreachableBytecodeA unloaded\n+        \/\/ If a loaded, but TestVerifyStackWithUnreachableBytecodeB not -> assume TestVerifyStackWithUnreachableBytecodeA.val null, else trap.\n+        \/\/   -> \"null_assert_or_unreached0\"\n+        getstatic    Field compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeA.val:\"Lcompiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeB;\";\n+        areturn;\n+\n+        \/\/ some unreachable instruction after return\n+        iconst_0;\n+    }\n+    public static Method testReturn:\"()V\"\n+        stack  1 locals  0\n+    {\n+        getstatic   Field compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeA.val:\"Lcompiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeB;\";\n+        return;\n+        \/\/ unreachable\n+        iconst_0;\n+    }\n+    public static Method testGoto:\"()V\"\n+        stack  1 locals  0\n+    {\n+        getstatic   Field compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeA.val:\"Lcompiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeB;\";\n+        goto There;\n+        \/\/ unreachable\n+        iconst_0;\n+    There:\n+        return;\n+    }\n+    public static Method testGotow:\"()V\"\n+        stack  1 locals  0\n+    {\n+        getstatic   Field compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeA.val:\"Lcompiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeB;\";\n+        goto_w There;\n+        \/\/ unreachable\n+        iconst_0;\n+    There:\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/interpreter\/TestVerifyStackWithUnreachableBytecodeImpl.jasm","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}