{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.internal.net.http.common.Log;\n@@ -495,1 +496,1 @@\n-    private void removeFromPool(HttpConnection c) {\n+    private boolean removeFromPool(HttpConnection c) {\n@@ -498,1 +499,1 @@\n-            removeFromPool(c, plainPool);\n+            return removeFromPool(c, plainPool);\n@@ -501,1 +502,1 @@\n-            removeFromPool(c, sslPool);\n+            return removeFromPool(c, sslPool);\n@@ -527,1 +528,1 @@\n-    void cleanup(HttpConnection c, Throwable error) {\n+    void cleanup(HttpConnection c, long pendingData, Throwable error) {\n@@ -532,0 +533,1 @@\n+        boolean removed;\n@@ -533,1 +535,1 @@\n-            removeFromPool(c);\n+            removed = removeFromPool(c);\n@@ -538,1 +540,18 @@\n-        c.close();\n+        if (!removed && pendingData != 0) {\n+            \/\/ this should not happen; the cleanup may have consumed\n+            \/\/ some data that wasn't supposed to be consumed, so\n+            \/\/ the only thing we can do is log it and close the\n+            \/\/ connection.\n+            if (Log.errors()) {\n+                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing {0}\", c.dbgString());\n+            }\n+            if (debug.on()) {\n+                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing %s\", c.dbgString());\n+            }\n+            Throwable cause = new IOException(\"Unexpected cleanup triggered for non pooled connection\", error);\n+            c.close(cause);\n+        } else {\n+            c.close();\n+        }\n@@ -552,0 +571,1 @@\n+        private volatile boolean dropped;\n@@ -559,1 +579,1 @@\n-        private void triggerCleanup(Throwable error) {\n+        private void triggerCleanup(long pendingData, Throwable error) {\n@@ -561,1 +581,4 @@\n-            cleanup(connection, error);\n+            if (debug.on()) {\n+                debug.log(\"Cleanup triggered for %s: pendingData:%s error:%s\", this, pendingData, error);\n+            }\n+            cleanup(connection, pendingData, error);\n@@ -569,0 +592,1 @@\n+            if (dropped || done) return;\n@@ -572,1 +596,1 @@\n-        public void onError(Throwable error) { triggerCleanup(error); }\n+        public void onError(Throwable error) { triggerCleanup(0, error); }\n@@ -574,1 +598,1 @@\n-        public void onComplete() { triggerCleanup(null); }\n+        public void onComplete() { triggerCleanup(0, null); }\n@@ -577,1 +601,1 @@\n-            triggerCleanup(new IOException(\"Data received while in pool\"));\n+            triggerCleanup(Utils.remaining(item), new IOException(\"Data received while in pool\"));\n@@ -589,0 +613,5 @@\n+\n+        @Override\n+        public void dropSubscription() {\n+            dropped = true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -560,1 +561,1 @@\n-        AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+        ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n@@ -568,4 +569,2 @@\n-            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n-            ReadSubscription previous = pendingSubscription.getAndSet(target);\n-\n-            if (previous != null && previous != target) {\n+            ReadSubscription previous;\n+            while ((previous = pendingSubscriptions.poll()) != null) {\n@@ -576,0 +575,2 @@\n+                \/\/ make sure no data will be routed to the old subscriber.\n+                previous.stopReading();\n@@ -583,0 +584,2 @@\n+            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n+            pendingSubscriptions.offer(target);\n@@ -584,1 +587,1 @@\n-            if (debug.on()) debug.log(\"read publisher got subscriber\");\n+            if (debug.on()) debug.log(\"read publisher got new subscriber: \" + s);\n@@ -609,0 +612,1 @@\n+            private volatile boolean stopped;\n@@ -626,1 +630,2 @@\n-                if (!cancelled) {\n+                if (!cancelled && !stopped) {\n+                    \/\/ should be safe to not synchronize here.\n@@ -630,1 +635,1 @@\n-                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n@@ -664,0 +669,26 @@\n+\n+            \/**\n+             * Called when switching subscriber on the {@link InternalReadSubscription}.\n+             * This subscriber is the old subscriber. Demand on the internal\n+             * subscription will be reset and reading will be paused until the\n+             * new subscriber is subscribed.\n+             * This should ensure that no data is routed to this subscriber\n+             * until the new subscriber is subscribed.\n+             *\/\n+            synchronized void stopReading() {\n+                stopped = true;\n+                impl.demand.reset();\n+            }\n+\n+            synchronized boolean tryDecrementDemand() {\n+                if (stopped) return false;\n+                return impl.demand.tryDecrement();\n+            }\n+\n+            synchronized boolean isStopped() {\n+                return stopped;\n+            }\n+\n+            synchronized void increaseDemand(long n) {\n+                if (!stopped) impl.demand.increase(n);\n+            }\n@@ -838,1 +869,1 @@\n-                        if (demand.tryDecrement()) {\n+                        if (current.tryDecrementDemand()) {\n@@ -884,2 +915,4 @@\n-                                    demand.increase(1);\n-                                    resumeReadEvent();\n+                                    if (!current.isStopped()) {\n+                                        current.increaseDemand(1);\n+                                        resumeReadEvent();\n+                                    }\n@@ -925,4 +958,6 @@\n-                ReadSubscription pending = pendingSubscription.getAndSet(null);\n-                if (pending == null) return false;\n-                if (debug.on())\n-                    debug.log(\"handling pending subscription for %s\",\n+                ReadSubscription pending;\n+                boolean subscribed = false;\n+                while ((pending = pendingSubscriptions.poll()) != null) {\n+                    subscribed = true;\n+                    if (debug.on())\n+                        debug.log(\"handling pending subscription for %s\",\n@@ -930,15 +965,8 @@\n-                ReadSubscription current = subscription;\n-                if (current != null && current != pending && !completed) {\n-                    current.subscriber.dropSubscription();\n-                }\n-                if (debug.on()) debug.log(\"read demand reset to 0\");\n-                subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n-                pending.errorRef.compareAndSet(null, errorRef.get());\n-                if (!readScheduler.isStopped()) {\n-                    subscription = pending;\n-                } else {\n-                    if (debug.on()) debug.log(\"socket tube is already stopped\");\n-                }\n-                if (debug.on()) debug.log(\"calling onSubscribe\");\n-                pending.signalOnSubscribe();\n-                if (completed) {\n+                    ReadSubscription current = subscription;\n+                    if (current != null && current != pending && !completed) {\n+                        debug.log(\"dropping pending subscription for current %s\",\n+                                current.subscriber);\n+                        current.subscriber.dropSubscription();\n+                    }\n+                    if (debug.on()) debug.log(\"read demand reset to 0\");\n+                    subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n@@ -946,1 +974,11 @@\n-                    pending.signalCompletion();\n+                    if (!readScheduler.isStopped()) {\n+                        subscription = pending;\n+                    } else {\n+                        if (debug.on()) debug.log(\"socket tube is already stopped\");\n+                    }\n+                    if (debug.on()) debug.log(\"calling onSubscribe on \" + pending.subscriber);\n+                    pending.signalOnSubscribe();\n+                    if (completed) {\n+                        pending.errorRef.compareAndSet(null, errorRef.get());\n+                        pending.signalCompletion();\n+                    }\n@@ -948,1 +986,1 @@\n-                return true;\n+                return subscribed;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":71,"deletions":33,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -183,0 +183,4 @@\n+            @Override\n+            public String toString() {\n+                return \"TubeSubscriberWrapper(\"+delegate.toString()+\")\";\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/FlowTube.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112\n+ * @bug 8087112 8336655 8338569\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -215,0 +215,1 @@\n+                assertTrue(client.isTerminated());\n@@ -216,1 +217,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -218,1 +223,0 @@\n-            assertTrue(client.isTerminated());\n@@ -275,1 +279,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -277,0 +281,1 @@\n+                assertTrue(client.isTerminated());\n@@ -278,1 +283,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -280,1 +289,0 @@\n-            assertTrue(client.isTerminated());\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8087112 8178699\n+ * @bug 8087112 8178699 8338569\n@@ -57,0 +57,2 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n@@ -575,2 +577,1 @@\n-        URI uri = new URI(target);\n-        HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n+        AtomicInteger count = new AtomicInteger();\n@@ -579,0 +580,3 @@\n+            URI uri = new URI(target+\"?get-sync;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n@@ -587,4 +591,1 @@\n-        request = HttpRequest.newBuilder()\n-                .uri(uri)\n-                .POST(BodyPublishers.ofFile(requestBody))\n-                .build();\n+\n@@ -593,0 +594,6 @@\n+            URI uri = new URI(target+\"?post-async;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(uri)\n+                    .POST(BodyPublishers.ofFile(requestBody))\n+                    .build();\n@@ -613,1 +620,0 @@\n-        request = HttpRequest.newBuilder(uri).GET().build();\n@@ -615,0 +621,1 @@\n+        Set<String> inFlight = ConcurrentHashMap.newKeySet();\n@@ -616,0 +623,4 @@\n+            URI uri = new URI(target+\"?get-async;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -618,0 +629,2 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n@@ -633,0 +646,4 @@\n+            URI uri = new URI(target+\"?get-async-next;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -635,0 +652,3 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n+                      System.out.println(\"In flight: \" + inFlight);\n@@ -642,0 +662,2 @@\n+        System.out.println(\"Waiting: In flight: \" + inFlight);\n+        System.out.println(\"Queue size: \" + q.size());\n@@ -645,0 +667,2 @@\n+            System.out.println(\"Waiting: In flight: \" + inFlight);\n+            System.out.println(\"Queue size: \" + q.size());\n","filename":"test\/jdk\/java\/net\/httpclient\/SmokeTest.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"}]}