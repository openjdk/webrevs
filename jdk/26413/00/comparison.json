{"files":[{"patch":"@@ -602,1 +602,1 @@\n-                str = JLA.uncheckedNewStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n+                str = JLA.uncheckedNewString(bytearr, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            str = utf8(bytes, offset, length);\n+            str = utf8ThrowingIae(bytes, offset, length);\n@@ -571,1 +571,29 @@\n-    private static String utf8(byte[] bytes, int offset, int length) {\n+    private static String utf8ThrowingIae(byte[] bytes, int offset, int length) {\n+        try {\n+            return utf8(bytes, offset, length);\n+        } catch (CharacterCodingException cce) {\n+            throw cce2iae(cce);\n+        }\n+    }\n+\n+    private static IllegalArgumentException cce2iae(CharacterCodingException cce) {\n+        Throwable cause = cce.getCause();\n+        \/\/ If the CCE is caused by an IAE, it implies that IAE is injected by\n+        \/\/ us to provide more context into CCE. Try swapping them to obtain an\n+        \/\/ IAE caused by a CCE.\n+        if (cause instanceof IllegalArgumentException iae) {\n+            if (cce instanceof MalformedInputException mie) {\n+                return new IllegalArgumentException(\n+                        iae.getMessage(),\n+                        new MalformedInputException(mie.getInputLength()));\n+            }\n+            if (cce instanceof UnmappableCharacterException uce) {\n+                return new IllegalArgumentException(\n+                        iae.getMessage(),\n+                        new UnmappableCharacterException(uce.getInputLength()));\n+            }\n+        }\n+        return new IllegalArgumentException(cce);\n+    }\n+\n+    private static String utf8(byte[] bytes, int offset, int length) throws CharacterCodingException {\n@@ -692,1 +720,1 @@\n-     * Throws iae, instead of replacing, if malformed or unmappable.\n+     * {@return a new string by decoding from the given UTF-8 bytes array}\n@@ -694,0 +722,2 @@\n+     * @param offset the index of the first byte to decode\n+     * @param length the number of bytes to decode\n@@ -698,0 +728,5 @@\n+     * @throws NullPointerException If {@code bytes} is null\n+     * @throws StringIndexOutOfBoundsException If {@code offset} is negative,\n+     *         {@code length} is negative, or {@code offset} is greater than\n+     *         {@code bytes.length - length}\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n@@ -699,2 +734,2 @@\n-    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n+    static String newStringUTF8(byte[] bytes, int offset, int length, boolean noShare) throws CharacterCodingException {\n+        checkBoundsOffCount(offset, length, bytes.length);  \/\/ Implicit null check on `bytes`\n@@ -762,14 +797,1 @@\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n-        try {\n-            return newStringNoRepl1(src, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException mie) {\n-                throw mie;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static String newStringNoRepl1(byte[] src, Charset cs) {\n+    static String newString(byte[] src, Charset cs) throws CharacterCodingException {\n@@ -781,1 +803,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length, false);\n+            return newStringUTF8(src, 0, src.length, false);\n@@ -809,7 +831,1 @@\n-        int caLen;\n-        try {\n-            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n-        } catch (CharacterCodingException x) {\n-            \/\/ throw via IAE\n-            throw new IllegalArgumentException(x);\n-        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -850,1 +866,1 @@\n-    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n+    private static byte[] encode(Charset cs, byte coder, byte[] val) throws CharacterCodingException {\n@@ -863,1 +879,1 @@\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) throws CharacterCodingException {\n@@ -908,1 +924,1 @@\n-                throw new IllegalArgumentException(x);\n+                throw x;\n@@ -916,2 +932,6 @@\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n+     *\n+     * @param s the string to encode\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -919,2 +939,2 @@\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n+    static byte[] getBytesUTF8(String s) throws CharacterCodingException {\n+        return encodeUTF8(s.coder(), s.value(), false);  \/\/ Implicit null check on `s`\n@@ -927,2 +947,12 @@\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@linkplain java.nio.charset.Charset charset}}\n+     * <p>\n+     * <b>WARNING: This method returns the {@code byte[]} backing the provided\n+     * {@code String}, if the input is ASCII. Hence, the returned byte array\n+     * must not be modified.<\/b>\n+     *\n+     * @param s the string to encode\n+     * @param cs the charset\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -930,14 +960,3 @@\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n+    static byte[] getBytes(String s, Charset cs) throws CharacterCodingException {\n+        Objects.requireNonNull(s, \"s\");\n+        Objects.requireNonNull(cs, \"cs\");\n@@ -1008,1 +1027,1 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val) {\n+    private static byte[] encode8859_1(byte coder, byte[] val) throws UnmappableCharacterException {\n@@ -1012,1 +1031,1 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) throws UnmappableCharacterException {\n@@ -1121,1 +1140,2 @@\n-    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace)\n+            throws CharacterCodingException {\n@@ -1262,1 +1282,2 @@\n-    private static void throwMalformed(int off, int nb) {\n+    private static void throwMalformed(int off, int nb) throws MalformedInputException {\n+        MalformedInputException mie = new MalformedInputException(nb);\n@@ -1264,1 +1285,2 @@\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+        mie.initCause(new IllegalArgumentException(msg));\n+        throw mie;\n@@ -1267,1 +1289,1 @@\n-    private static void throwMalformed(byte[] val) {\n+    private static void throwMalformed(byte[] val) throws MalformedInputException {\n@@ -1272,1 +1294,2 @@\n-    private static void throwUnmappable(int off) {\n+    private static void throwUnmappable(int off) throws UnmappableCharacterException {\n+        UnmappableCharacterException uce = new UnmappableCharacterException(1);\n@@ -1274,1 +1297,2 @@\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+        uce.initCause(new IllegalArgumentException(msg, uce));\n+        throw uce;\n@@ -1277,1 +1301,1 @@\n-    private static void throwUnmappable(byte[] val) {\n+    private static void throwUnmappable(byte[] val) throws UnmappableCharacterException {\n@@ -1282,1 +1306,1 @@\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) throws UnmappableCharacterException {\n@@ -1307,1 +1331,1 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) throws UnmappableCharacterException {\n@@ -1372,1 +1396,1 @@\n-    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) throws UnmappableCharacterException {\n@@ -1826,1 +1850,5 @@\n-        return encode(lookupCharset(charsetName), coder(), value);\n+        try {\n+            return encode(lookupCharset(charsetName), coder(), value);\n+        } catch (CharacterCodingException cce) {\n+            throw cce2iae(cce);\n+        }\n@@ -1849,2 +1877,6 @@\n-        return encode(charset, coder(), value);\n-     }\n+        try {\n+            return encode(charset, coder(), value);\n+        } catch (CharacterCodingException cce) {\n+            throw cce2iae(cce);\n+        }\n+    }\n@@ -1867,1 +1899,5 @@\n-        return encode(Charset.defaultCharset(), coder(), value);\n+        try {\n+            return encode(Charset.defaultCharset(), coder(), value);\n+        } catch (CharacterCodingException cce) {\n+            throw cce2iae(cce);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":102,"deletions":66,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2124,0 +2123,1 @@\n+\n@@ -2127,2 +2127,3 @@\n-            public String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoRepl(bytes, cs);\n+\n+            public String uncheckedNewString(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newString(bytes, cs);\n@@ -2130,0 +2131,1 @@\n+\n@@ -2133,0 +2135,1 @@\n+\n@@ -2136,2 +2139,3 @@\n-            public byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoRepl(s, cs);\n+\n+            public byte[] uncheckedGetBytes(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytes(s, cs);\n@@ -2140,2 +2144,2 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n+            public String newStringUTF8(byte[] bytes, int off, int len) throws CharacterCodingException {\n+                return String.newStringUTF8(bytes, off, len, true);\n@@ -2144,2 +2148,2 @@\n-            public byte[] getBytesUTF8NoRepl(String s) {\n-                return String.getBytesUTF8NoRepl(s);\n+            public byte[] getBytesUTF8(String s) throws CharacterCodingException {\n+                return String.getBytesUTF8(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4153,1 +4153,1 @@\n-                return JLA.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+                return JLA.uncheckedNewString(buf, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-        return JLA.uncheckedNewStringNoRepl(ba, cs);\n+        return JLA.uncheckedNewString(ba, cs);\n@@ -3365,1 +3365,1 @@\n-        byte[] bytes = JLA.uncheckedGetBytesNoRepl(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.uncheckedGetBytes(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n@@ -699,1 +699,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n@@ -735,1 +735,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n@@ -763,1 +763,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n@@ -799,1 +799,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n@@ -827,1 +827,1 @@\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-            return jla.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewString(buf, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,5 @@\n-            return JLA.newStringUTF8NoRepl(ba, off, length);\n+            try {\n+                return JLA.newStringUTF8(ba, off, length);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -260,1 +264,5 @@\n-            return JLA.getBytesUTF8NoRepl(s);\n+            try {\n+                return JLA.getBytesUTF8(s);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -274,1 +282,1 @@\n-                \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                \/\/ We use the JLA.newStringUTF8 variant to throw\n@@ -276,1 +284,1 @@\n-                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n+                return hash(JLA.newStringUTF8(a, off, len));\n@@ -292,1 +300,1 @@\n-                byte[] encoded = JLA.uncheckedGetBytesNoRepl(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.uncheckedGetBytes(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-    String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewString(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -331,2 +331,2 @@\n-     * Encode the given string into a sequence of bytes using the specified\n-     * {@linkplain java.nio.charset.Charset charset}.\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@linkplain java.nio.charset.Charset charset}}\n@@ -337,3 +337,0 @@\n-     * <p>\n-     * This method throws {@code CharacterCodingException} instead of replacing\n-     * when malformed input or unmappable characters are encountered.\n@@ -343,2 +340,2 @@\n-     * @return the encoded bytes\n-     * @throws CharacterCodingException for malformed input or unmappable characters\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -346,1 +343,1 @@\n-    byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n+    byte[] uncheckedGetBytes(String s, Charset cs) throws CharacterCodingException;\n@@ -349,1 +346,1 @@\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n+     * {@return a new string by decoding from the given UTF-8 bytes array}\n@@ -351,4 +348,7 @@\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n+     * @param offset the index of the first byte to decode\n+     * @param length the number of bytes to decode\n+     * @throws NullPointerException If {@code bytes} is null\n+     * @throws StringIndexOutOfBoundsException If {@code offset} is negative,\n+     *         {@code length} is negative, or {@code offset} is greater than\n+     *         {@code bytes.length - length}\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n@@ -356,1 +356,1 @@\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n+    String newStringUTF8(byte[] bytes, int offset, int length) throws CharacterCodingException;\n@@ -382,1 +382,1 @@\n-     * Encode the given string into a sequence of bytes using utf8.\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n@@ -385,2 +385,2 @@\n-     * @return the encoded bytes in utf8\n-     * @throws IllegalArgumentException for malformed surrogates\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -388,1 +388,1 @@\n-    byte[] getBytesUTF8NoRepl(String s);\n+    byte[] getBytesUTF8(String s) throws CharacterCodingException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.uncheckedGetBytesNoRepl(input, Util.jnuEncoding());\n+            return JLA.uncheckedGetBytes(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}