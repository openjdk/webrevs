{"files":[{"patch":"@@ -607,1 +607,1 @@\n-            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n+            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp);\n@@ -614,1 +614,1 @@\n-            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0);\n@@ -692,3 +692,14 @@\n-     * Throws iae, instead of replacing, if malformed or unmappable.\n-     * The byte array can be exclusively used to construct\n-     * the string and is not modified or used for any other purpose.\n+     * {@return a new string by decoding from the given UTF-8 bytes array}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param bytes byte array containing UTF-8 encoded characters\n+     * @param offset the index of the first byte to decode\n+     * @param length the number of bytes to decode\n+     * @throws NullPointerException If {@code bytes} is null\n+     * @throws StringIndexOutOfBoundsException If {@code offset} is negative,\n+     *         {@code length} is negative, or {@code offset} is greater than\n+     *         {@code bytes.length - length}\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n@@ -696,2 +707,2 @@\n-    private static String newStringUTF8NoRepl(byte[] bytes, int offset, int length) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n+    private static String newStringUTF8NoReplacement(byte[] bytes, int offset, int length) throws CharacterCodingException {\n+        checkBoundsOffCount(offset, length, bytes.length);  \/\/ Implicit null check on `bytes`\n@@ -748,1 +759,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, sl, dst, dp);\n@@ -751,1 +762,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n+            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, offset + length, dst, 0);\n@@ -787,14 +798,1 @@\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n-        try {\n-            return newStringNoRepl1(src, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException mie) {\n-                throw mie;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static String newStringNoRepl1(byte[] src, Charset cs) {\n+    static String newStringNoReplacement(byte[] src, Charset cs) throws CharacterCodingException {\n@@ -806,1 +804,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length);\n+            return newStringUTF8NoReplacement(src, 0, src.length);\n@@ -819,1 +817,1 @@\n-                throwMalformed(src);\n+                throw malformedASCII(src);\n@@ -834,7 +832,1 @@\n-        int caLen;\n-        try {\n-            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n-        } catch (CharacterCodingException x) {\n-            \/\/ throw via IAE\n-            throw new IllegalArgumentException(x);\n-        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -877,1 +869,1 @@\n-            return encodeUTF8(coder, val, true);\n+            return encodeUTF8(coder, val);\n@@ -885,1 +877,10 @@\n-        return encodeWithEncoder(cs, coder, val, true);\n+        return encodeWithEncoder(cs, coder, val);\n+    }\n+\n+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val) {\n+        return encodeWithEncoder(cs, coder, val, null);\n+    }\n+\n+    private static byte[] encodeWithEncoderNoReplacement(Charset cs, byte coder, byte[] val)\n+            throws CharacterCodingException {\n+        return encodeWithEncoder(cs, coder, val, CharacterCodingException.class);\n@@ -888,1 +889,4 @@\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n+    private static <E extends Exception> byte[] encodeWithEncoder(\n+            Charset cs, byte coder, byte[] val, Class<E> exceptionClass)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -892,0 +896,1 @@\n+        boolean doReplace = exceptionClass == null;\n@@ -933,1 +938,3 @@\n-                throw new IllegalArgumentException(x);\n+                @SuppressWarnings(\"unchecked\")\n+                E cce = (E) x;\n+                throw cce;\n@@ -941,2 +948,6 @@\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n+     *\n+     * @param s the string to encode\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -944,2 +955,2 @@\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n+    static byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n+        return encodeUTF8NoReplacement(s.coder(), s.value());  \/\/ Implicit null check on `s`\n@@ -952,2 +963,12 @@\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@code Charset}}\n+     * <p>\n+     * <b>WARNING: This method returns the {@code byte[]} backing the provided\n+     * {@code String}, if the input is ASCII. Hence, the returned byte array\n+     * must not be modified.<\/b>\n+     *\n+     * @param s the string to encode\n+     * @param cs the charset\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -955,15 +976,3 @@\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n-        byte[] val = s.value();\n+    static byte[] getBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n+        Objects.requireNonNull(cs);\n+        byte[] val = s.value();     \/\/ Implicit null check on `s`\n@@ -975,1 +984,1 @@\n-            return encodeUTF8(coder, val, false);\n+            return encodeUTF8NoReplacement(coder, val);\n@@ -981,1 +990,1 @@\n-            return encode8859_1(coder, val, false);\n+            return encode8859_1NoReplacement(coder, val);\n@@ -988,1 +997,1 @@\n-                    throwUnmappable(val);\n+                    throw unmappableCharacterException(val);\n@@ -992,1 +1001,1 @@\n-        return encodeWithEncoder(cs, coder, val, false);\n+        return encodeWithEncoderNoReplacement(cs, coder, val);\n@@ -1034,1 +1043,1 @@\n-        return encode8859_1(coder, val, true);\n+        return encode8859_1(coder, val, null);\n@@ -1037,1 +1046,7 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+    private static byte[] encode8859_1NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+        return encode8859_1(coder, val, UnmappableCharacterException.class);\n+    }\n+\n+    private static <E extends Exception> byte[] encode8859_1(byte coder, byte[] val, Class<E> exceptionClass)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -1051,2 +1066,2 @@\n-                if (!doReplace) {\n-                    throwUnmappable(sp);\n+                if (exceptionClass != null) {\n+                    throw unmappableCharacterException(sp, exceptionClass);\n@@ -1146,1 +1161,14 @@\n-    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp) {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, null);\n+    }\n+\n+    private static int decodeUTF8_UTF16NoReplacement(\n+            byte[] src, int sp, int sl, byte[] dst, int dp)\n+            throws MalformedInputException {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, MalformedInputException.class);\n+    }\n+\n+    private static <E extends Exception> int decodeUTF8_UTF16(\n+            byte[] src, int sp, int sl, byte[] dst, int dp, Class <E> exceptionClass)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -1155,2 +1183,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 1, 1);\n+                        if (exceptionClass != null) {\n+                            throw malformedInputException(sp - 1, 1, exceptionClass);\n@@ -1165,2 +1193,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n+                if (exceptionClass != null) {\n+                    throw malformedInputException(sp, 1, exceptionClass);  \/\/ underflow()\n@@ -1175,2 +1203,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 3, 3);\n+                        if (exceptionClass != null) {\n+                            throw malformedInputException(sp - 3, 3, exceptionClass);\n@@ -1184,2 +1212,2 @@\n-                            if (!doReplace) {\n-                                throwMalformed(sp - 3, 3);\n+                            if (exceptionClass != null) {\n+                                throw malformedInputException(sp - 3, 3, exceptionClass);\n@@ -1195,2 +1223,2 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 2);\n+                    if (exceptionClass != null) {\n+                        throw malformedInputException(sp - 1, 2, exceptionClass);\n@@ -1201,2 +1229,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);\n+                if (exceptionClass != null) {\n+                    throw malformedInputException(sp, 1, exceptionClass);\n@@ -1214,2 +1242,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 4, 4);\n+                        if (exceptionClass != null) {\n+                            throw malformedInputException(sp - 4, 4, exceptionClass);\n@@ -1228,2 +1256,2 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                    if (exceptionClass != null) {\n+                        throw malformedInputException(sp - 1, 1, exceptionClass);  \/\/ or 2\n@@ -1234,2 +1262,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n+                if (exceptionClass != null) {\n+                    throw malformedInputException(sp - 1, 1, exceptionClass);\n@@ -1244,2 +1272,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n+                if (exceptionClass != null) {\n+                    throw malformedInputException(sp - 1, 1, exceptionClass);\n@@ -1287,1 +1315,3 @@\n-    private static void throwMalformed(int off, int nb) {\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E malformedInputException(int off, int nb, Class<E> exceptionClass) {\n+        MalformedInputException mie = new MalformedInputException(nb);\n@@ -1289,1 +1319,2 @@\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+        mie.initCause(new IllegalArgumentException(msg));\n+        return (E) mie;\n@@ -1292,1 +1323,1 @@\n-    private static void throwMalformed(byte[] val) {\n+    private static MalformedInputException malformedASCII(byte[] val) {\n@@ -1294,1 +1325,1 @@\n-        throwMalformed(dp, 1);\n+        return malformedInputException(dp, 1, MalformedInputException.class);\n@@ -1297,1 +1328,3 @@\n-    private static void throwUnmappable(int off) {\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E unmappableCharacterException(int off, Class<E> exceptionClass) {\n+        UnmappableCharacterException uce = new UnmappableCharacterException(1);\n@@ -1299,1 +1332,2 @@\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+        uce.initCause(new IllegalArgumentException(msg, uce));\n+        return (E) uce;\n@@ -1302,1 +1336,1 @@\n-    private static void throwUnmappable(byte[] val) {\n+    private static UnmappableCharacterException unmappableCharacterException(byte[] val) {\n@@ -1304,1 +1338,9 @@\n-        throwUnmappable(dp);\n+        return unmappableCharacterException(dp, UnmappableCharacterException.class);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val) {\n+        return encodeUTF8(coder, val, null);\n+    }\n+\n+    private static byte[] encodeUTF8NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+        return encodeUTF8(coder, val, UnmappableCharacterException.class);\n@@ -1307,1 +1349,3 @@\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+    private static <E extends Exception> byte[] encodeUTF8(byte coder, byte[] val, Class<E> exceptionClass)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -1309,1 +1353,1 @@\n-            return encodeUTF8_UTF16(val, doReplace);\n+            return encodeUTF8_UTF16(val, exceptionClass);\n@@ -1337,1 +1381,3 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    private static <E extends Exception> byte[] encodeUTF8_UTF16(byte[] val, Class<E> unmappableCharacterException)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -1343,1 +1389,1 @@\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, doReplace) : sl * 3;\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, unmappableCharacterException) : sl * 3;\n@@ -1372,1 +1418,1 @@\n-                    if (doReplace) {\n+                    if (unmappableCharacterException == null) {\n@@ -1375,1 +1421,1 @@\n-                        throwUnmappable(sp - 1);\n+                        throw unmappableCharacterException(sp - 1, unmappableCharacterException);\n@@ -1399,2 +1445,0 @@\n-     * @param val UTF16 encoded byte array\n-     * @param doReplace true to replace unmappable characters\n@@ -1402,1 +1446,3 @@\n-    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    private static <E extends Exception> long computeSizeUTF8_UTF16(byte[] val, Class<E> unmappableCharacterException)\n+            \/\/ Parametrizing on exception type to enable callers (using null) to avoid having to declare the exception\n+            throws E {\n@@ -1421,1 +1467,1 @@\n-                    if (doReplace) {\n+                    if (unmappableCharacterException == null) {\n@@ -1424,1 +1470,1 @@\n-                        throwUnmappable(sp - 1);\n+                        throw unmappableCharacterException(sp - 1, unmappableCharacterException);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":151,"deletions":105,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -2126,0 +2126,1 @@\n+\n@@ -2134,2 +2135,2 @@\n-            public String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoRepl(bytes, cs);\n+            public String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringNoReplacement(bytes, cs);\n@@ -2137,0 +2138,1 @@\n+\n@@ -2140,0 +2142,1 @@\n+\n@@ -2143,2 +2146,3 @@\n-            public byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoRepl(s, cs);\n+\n+            public byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesNoReplacement(s, cs);\n@@ -2147,2 +2151,2 @@\n-            public byte[] getBytesUTF8NoRepl(String s) {\n-                return String.getBytesUTF8NoRepl(s);\n+            public byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n+                return String.getBytesUTF8NoReplacement(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-        return JLA.uncheckedNewStringNoRepl(ba, cs);\n+        return JLA.uncheckedNewStringNoReplacement(ba, cs);\n@@ -3365,1 +3365,1 @@\n-        byte[] bytes = JLA.uncheckedGetBytesNoRepl(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.uncheckedGetBytesNoReplacement(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-                return JLA.uncheckedNewStringNoRepl(bytes, StandardCharsets.UTF_8);\n+                return JLA.uncheckedNewStringNoReplacement(bytes, StandardCharsets.UTF_8);\n@@ -267,1 +267,5 @@\n-            return JLA.getBytesUTF8NoRepl(s);\n+            try {\n+                return JLA.getBytesUTF8NoReplacement(s);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -281,2 +285,0 @@\n-                \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n-                \/\/ exceptions eagerly when opening ZipFiles\n@@ -299,1 +301,1 @@\n-                byte[] encoded = JLA.uncheckedGetBytesNoRepl(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.uncheckedGetBytesNoReplacement(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.function.BiFunction;\n@@ -335,1 +334,1 @@\n-     * using the specified {@linkplain java.nio.charset.Charset charset}.\n+     * using the specified {@code Charset}.\n@@ -346,1 +345,1 @@\n-    String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -349,2 +348,2 @@\n-     * Encode the given string into a sequence of bytes using the specified\n-     * {@linkplain java.nio.charset.Charset charset}.\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@code Charset}}\n@@ -355,3 +354,0 @@\n-     * <p>\n-     * This method throws {@code CharacterCodingException} instead of replacing\n-     * when malformed input or unmappable characters are encountered.\n@@ -361,1 +357,1 @@\n-     * @return the encoded bytes\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n@@ -364,1 +360,1 @@\n-    byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n+    byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException;\n@@ -390,1 +386,1 @@\n-     * Encode the given string into a sequence of bytes using utf8.\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n@@ -393,2 +389,2 @@\n-     * @return the encoded bytes in utf8\n-     * @throws IllegalArgumentException for malformed surrogates\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -396,1 +392,1 @@\n-    byte[] getBytesUTF8NoRepl(String s);\n+    byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.uncheckedGetBytesNoRepl(input, Util.jnuEncoding());\n+            return JLA.uncheckedGetBytesNoReplacement(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8286287 8288589\n- * @summary Tests for *NoRepl() shared secret methods.\n- * @run testng NoReplTest\n- * @modules jdk.charsets\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.HexFormat;\n-import static java.nio.charset.StandardCharsets.UTF_16;\n-\n-import org.testng.annotations.Test;\n-\n-@Test\n-public class NoReplTest {\n-    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n-    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n-    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n-\n-    \/**\n-     * Verifies newStringNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.readString()` method.\n-     *\/\n-    @Test\n-    public void newStringNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try (var fos = Files.newOutputStream(f)) {\n-            fos.write(MALFORMED_UTF16);\n-            var read = Files.readString(f, UTF_16);\n-            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n-                    HexFormat.of()\n-                            .withPrefix(\"x\")\n-                            .withUpperCase()\n-                            .formatHex(read.getBytes(UTF_16)));\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies getBytesNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.writeString()` method.\n-     *\/\n-    @Test\n-    public void getBytesNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try {\n-            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n-            throw new RuntimeException(\"Exception should be thrown\");\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8286287 8288589\n+ * @summary Tests for *NoReplacement() shared secret methods.\n+ * @run testng NoReplacementTest\n+ * @modules jdk.charsets\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.util.HexFormat;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class NoReplacementTest {\n+    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n+    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n+    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+\n+    \/**\n+     * Verifies {@code uncheckedNewStringNoReplacement()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.readString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedNewStringNoReplacementTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try (var fos = Files.newOutputStream(f)) {\n+            fos.write(MALFORMED_UTF16);\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies {@code uncheckedGetBytesNoReplacement()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.writeString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedGetBytesNoReplacementTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try {\n+            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n+            throw new RuntimeException(\"Exception should be thrown\");\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplacementTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}