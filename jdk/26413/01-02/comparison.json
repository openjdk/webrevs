{"files":[{"patch":"@@ -788,1 +788,1 @@\n-                throw malformedInputException(src);\n+                throw malformedInputException(src, MalformedInputException.class);\n@@ -851,1 +851,12 @@\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val) {\n+    private static <E extends Exception> byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val) {\n+        return encodeWithEncoder(cs, coder, val, null);\n+    }\n+\n+    private static <E extends Exception> byte[] encodeWithEncoderNoReplacement(Charset cs, byte coder, byte[] val)\n+            throws CharacterCodingException {\n+        return encodeWithEncoder(cs, coder, val, CharacterCodingException.class);\n+    }\n+\n+    private static <E extends Exception> byte[] encodeWithEncoder(\n+            Charset cs, byte coder, byte[] val, Class<E> characterCodingException)\n+            throws E {\n@@ -855,2 +866,2 @@\n-        \/\/ Fast-path with `ArrayEncoder` implies replacement.\n-        if (ce instanceof ArrayEncoder ae) {\n+        \/\/ fastpath with ArrayEncoder implies replacement.\n+        if (characterCodingException == null && ce instanceof ArrayEncoder ae) {\n@@ -879,2 +890,4 @@\n-        ce.onMalformedInput(CodingErrorAction.REPLACE)\n-                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        if (characterCodingException == null) {\n+            ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        }\n@@ -893,12 +906,7 @@\n-            throw new Error(x);\n-        }\n-        return trimArray(ba, bb.position());\n-    }\n-\n-    private static byte[] encodeWithEncoderNoReplacement(Charset cs, byte coder, byte[] val) throws CharacterCodingException {\n-        CharsetEncoder ce = cs.newEncoder();\n-        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n-        int en = scale(len, ce.maxBytesPerChar());\n-        byte[] ba = new byte[en];\n-        if (len == 0) {\n-            return ba;\n+            if (characterCodingException != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                E cce = (E) x;\n+                throw cce;\n+            } else {\n+                throw new Error(x);\n+            }\n@@ -906,10 +914,0 @@\n-        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n-                : StringUTF16.toChars(val);\n-        ByteBuffer bb = ByteBuffer.wrap(ba);\n-        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n-        CoderResult cr = ce.encode(cb, bb, true);\n-        if (!cr.isUnderflow())\n-            cr.throwException();\n-        cr = ce.flush(bb);\n-        if (!cr.isUnderflow())\n-            cr.throwException();\n@@ -948,3 +946,2 @@\n-        Objects.requireNonNull(s, \"s\");\n-        Objects.requireNonNull(cs, \"cs\");\n-        byte[] val = s.value();\n+        Objects.requireNonNull(cs);\n+        byte[] val = s.value();     \/\/ Implicit null check on `s`\n@@ -969,1 +966,1 @@\n-                    throw unmappableCharacterException(val);\n+                    throw unmappableCharacterException(val, UnmappableCharacterException.class);\n@@ -1015,0 +1012,8 @@\n+        return encode8859_1(coder, val, null);\n+    }\n+\n+    private static byte[] encode8859_1NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+        return encode8859_1(coder, val, UnmappableCharacterException.class);\n+    }\n+\n+    private static <E extends Exception> byte[] encode8859_1(byte coder, byte[] val, Class<E> unmappableCharacterException) throws E {\n@@ -1028,0 +1033,3 @@\n+                if (unmappableCharacterException != null) {\n+                    throw unmappableCharacterException(sp, unmappableCharacterException);\n+                }\n@@ -1043,22 +1051,0 @@\n-    private static byte[] encode8859_1NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n-        if (coder == LATIN1) {\n-            return val.clone();\n-        }\n-        int len = val.length >> 1;\n-        byte[] dst = new byte[len];\n-        int dp = 0;\n-        int sp = 0;\n-        while (sp < len) {\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n-            sp = sp + ret;\n-            dp = dp + ret;\n-            if (ret != len) {\n-                throw unmappableCharacterException(sp);\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n@@ -1142,1 +1128,13 @@\n-    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp) {\n+    private static <E extends Exception> int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp) {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, null);\n+    }\n+\n+    private static <E extends Exception> int decodeUTF8_UTF16NoReplacement(\n+            byte[] src, int sp, int sl, byte[] dst, int dp)\n+            throws MalformedInputException {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, MalformedInputException.class);\n+    }\n+\n+    private static <E extends Exception> int decodeUTF8_UTF16(\n+            byte[] src, int sp, int sl, byte[] dst, int dp, Class <E> malformedInputException)\n+            throws E {\n@@ -1151,0 +1149,3 @@\n+                        if (malformedInputException != null) {\n+                            throw malformedInputException(sp - 1, 1, malformedInputException);\n+                        }\n@@ -1158,0 +1159,3 @@\n+                if (malformedInputException != null) {\n+                    throw malformedInputException(sp, 1, malformedInputException);  \/\/ underflow()\n+                }\n@@ -1165,0 +1169,3 @@\n+                        if (malformedInputException != null) {\n+                            throw malformedInputException(sp - 3, 3, malformedInputException);\n+                        }\n@@ -1171,0 +1178,3 @@\n+                            if (malformedInputException != null) {\n+                                throw malformedInputException(sp - 3, 3, malformedInputException);\n+                            }\n@@ -1179,0 +1189,3 @@\n+                    if (malformedInputException != null) {\n+                        throw malformedInputException(sp - 1, 2, malformedInputException);\n+                    }\n@@ -1182,0 +1195,3 @@\n+                if (malformedInputException != null) {\n+                    throw malformedInputException(sp, 1, malformedInputException);\n+                }\n@@ -1192,0 +1208,3 @@\n+                        if (malformedInputException != null) {\n+                            throw malformedInputException(sp - 4, 4, malformedInputException);\n+                        }\n@@ -1203,0 +1222,3 @@\n+                    if (malformedInputException != null) {\n+                        throw malformedInputException(sp - 1, 1, malformedInputException);  \/\/ or 2\n+                    }\n@@ -1206,0 +1228,3 @@\n+                if (malformedInputException != null) {\n+                    throw malformedInputException(sp - 1, 1, malformedInputException);\n+                }\n@@ -1213,38 +1238,2 @@\n-                StringUTF16.putChar(dst, dp++, REPL);\n-            }\n-        }\n-        return dp;\n-    }\n-\n-    private static int decodeUTF8_UTF16NoReplacement(byte[] src, int sp, int sl, byte[] dst, int dp)\n-            throws CharacterCodingException {\n-        while (sp < sl) {\n-            int b1 = src[sp++];\n-            if (b1 >= 0) {\n-                StringUTF16.putChar(dst, dp++, (char) b1);\n-            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n-                if (sp < sl) {\n-                    int b2 = src[sp++];\n-                    if (isNotContinuation(b2)) {\n-                        throw malformedInputException(sp - 1, 1);\n-                    } else {\n-                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n-                    }\n-                    continue;\n-                }\n-                throw malformedInputException(sp, 1);  \/\/ underflow()\n-            } else if ((b1 >> 4) == -2) {\n-                if (sp + 1 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    if (isMalformed3(b1, b2, b3)) {\n-                        throw malformedInputException(sp - 3, 3);\n-                    } else {\n-                        char c = decode3(b1, b2, b3);\n-                        if (Character.isSurrogate(c)) {\n-                            throw malformedInputException(sp - 3, 3);\n-                        } else {\n-                            StringUTF16.putChar(dst, dp++, c);\n-                        }\n-                    }\n-                    continue;\n+                if (malformedInputException != null) {\n+                    throw malformedInputException(sp - 1, 1, malformedInputException);\n@@ -1252,26 +1241,1 @@\n-                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n-                    throw malformedInputException(sp - 1, 2);\n-                }\n-                throw malformedInputException(sp, 1);\n-            } else if ((b1 >> 3) == -2) {\n-                if (sp + 2 < sl) {\n-                    int b2 = src[sp++];\n-                    int b3 = src[sp++];\n-                    int b4 = src[sp++];\n-                    int uc = decode4(b1, b2, b3, b4);\n-                    if (isMalformed4(b2, b3, b4) ||\n-                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n-                        throw malformedInputException(sp - 4, 4);\n-                    } else {\n-                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n-                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n-                    }\n-                    continue;\n-                }\n-                b1 &= 0xff;\n-                if (b1 > 0xf4 || sp < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n-                    throw malformedInputException(sp - 1, 1);  \/\/ or 2\n-                }\n-                throw malformedInputException(sp - 1, 1);\n-            } else {\n-                throw malformedInputException(sp - 1, 1);\n+                StringUTF16.putChar(dst, dp++, REPL);\n@@ -1317,1 +1281,2 @@\n-    private static MalformedInputException malformedInputException(int off, int nb) {\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E malformedInputException(int off, int nb, Class<E> exceptionType) {\n@@ -1321,1 +1286,1 @@\n-        return mie;\n+        return (E) mie;\n@@ -1324,1 +1289,1 @@\n-    private static MalformedInputException malformedInputException(byte[] val) {\n+    private static <E extends Exception> E malformedInputException(byte[] val, Class<E> exceptionType) {\n@@ -1326,1 +1291,1 @@\n-        return malformedInputException(dp, 1);\n+        return malformedInputException(dp, 1, exceptionType);\n@@ -1329,1 +1294,2 @@\n-    private static UnmappableCharacterException unmappableCharacterException(int off) {\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E unmappableCharacterException(int off, Class<E> exceptionType) {\n@@ -1333,1 +1299,1 @@\n-        return uce;\n+        return (E) uce;\n@@ -1336,1 +1302,1 @@\n-    private static UnmappableCharacterException unmappableCharacterException(byte[] val) {\n+    private static <E extends Exception> E unmappableCharacterException(byte[] val, Class<E> exceptionType) {\n@@ -1338,1 +1304,1 @@\n-        return unmappableCharacterException(dp);\n+        return unmappableCharacterException(dp, exceptionType);\n@@ -1342,22 +1308,1 @@\n-        if (coder == UTF16) {\n-            return encodeUTF8_UTF16(val);\n-        }\n-\n-        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n-            return val.clone();\n-        }\n-\n-        int dp = 0;\n-        byte[] dst = StringUTF16.newBytesFor(val.length);\n-        for (byte c : val) {\n-            if (c < 0) {\n-                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n-                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n-            } else {\n-                dst[dp++] = c;\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n+        return encodeUTF8(coder, val, null);\n@@ -1367,0 +1312,4 @@\n+        return encodeUTF8(coder, val, UnmappableCharacterException.class);\n+    }\n+\n+    private static <E extends Exception> byte[] encodeUTF8(byte coder, byte[] val, Class<E> unmappableCharacterException) throws E {\n@@ -1368,1 +1317,1 @@\n-            return encodeUTF8_UTF16NoReplacement(val);\n+            return encodeUTF8_UTF16(val, unmappableCharacterException);\n@@ -1391,57 +1340,1 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val) {\n-        int dp = 0;\n-        int sp = 0;\n-        int sl = val.length >> 1;\n-        \/\/ UTF-8 encoded can be as much as 3 times the string length\n-        \/\/ For very large estimate, (as in overflow of 32 bit int), precompute the exact size\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val) : sl * 3;\n-        if (allocLen > (long)Integer.MAX_VALUE) {\n-            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n-        }\n-        byte[] dst = new byte[(int) allocLen];\n-        while (sp < sl) {\n-            \/\/ ascii fast loop;\n-            char c = StringUTF16.getChar(val, sp);\n-            if (c >= '\\u0080') {\n-                break;\n-            }\n-            dst[dp++] = (byte)c;\n-            sp++;\n-        }\n-        while (sp < sl) {\n-            char c = StringUTF16.getChar(val, sp++);\n-            if (c < 0x80) {\n-                dst[dp++] = (byte)c;\n-            } else if (c < 0x800) {\n-                dst[dp++] = (byte)(0xc0 | (c >> 6));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            } else if (Character.isSurrogate(c)) {\n-                int uc = -1;\n-                char c2;\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n-                    uc = Character.toCodePoint(c, c2);\n-                }\n-                if (uc < 0) {\n-                    dst[dp++] = '?';\n-                } else {\n-                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n-                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n-                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n-                    sp++;  \/\/ 2 chars\n-                }\n-            } else {\n-                \/\/ 3 bytes, 16 bits\n-                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n-                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n-                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n-            }\n-        }\n-        if (dp == dst.length) {\n-            return dst;\n-        }\n-        return Arrays.copyOf(dst, dp);\n-    }\n-\n-    private static byte[] encodeUTF8_UTF16NoReplacement(byte[] val) throws UnmappableCharacterException {\n+    private static <E extends Exception> byte[] encodeUTF8_UTF16(byte[] val, Class<E> unmappableCharacterException) throws E {\n@@ -1453,1 +1346,1 @@\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16NoReplacement(val) : sl * 3;\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, unmappableCharacterException) : sl * 3;\n@@ -1482,1 +1375,5 @@\n-                    throw unmappableCharacterException(sp - 1);\n+                    if (unmappableCharacterException == null) {\n+                        dst[dp++] = '?';\n+                    } else {\n+                        throw unmappableCharacterException(sp - 1, unmappableCharacterException);\n+                    }\n@@ -1505,37 +1402,0 @@\n-     * @param val UTF16 encoded byte array\n-     *\/\n-    private static long computeSizeUTF8_UTF16(byte[] val) {\n-        long dp = 0L;\n-        int sp = 0;\n-        int sl = val.length >> 1;\n-\n-        while (sp < sl) {\n-            char c = StringUTF16.getChar(val, sp++);\n-            if (c < 0x80) {\n-                dp++;\n-            } else if (c < 0x800) {\n-                dp += 2;\n-            } else if (Character.isSurrogate(c)) {\n-                int uc = -1;\n-                char c2;\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n-                    uc = Character.toCodePoint(c, c2);\n-                }\n-                if (uc < 0) {\n-                    dp++;\n-                } else {\n-                    dp += 4;\n-                    sp++;  \/\/ 2 chars\n-                }\n-            } else {\n-                \/\/ 3 bytes, 16 bits\n-                dp += 3;\n-            }\n-        }\n-        return dp;\n-    }\n-\n-    \/**\n-     * {@return the exact size required to UTF_8 encode this UTF16 string}\n-     * @param val UTF16 encoded byte array\n@@ -1543,1 +1403,1 @@\n-    private static long computeSizeUTF8_UTF16NoReplacement(byte[] val) throws UnmappableCharacterException {\n+    private static <E extends Exception> long computeSizeUTF8_UTF16(byte[] val, Class<E> unmappableCharacterException) throws E {\n@@ -1562,1 +1422,5 @@\n-                    throw unmappableCharacterException(sp - 1);\n+                    if (unmappableCharacterException == null) {\n+                        dp++;\n+                    } else {\n+                        throw unmappableCharacterException(sp - 1, unmappableCharacterException);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":112,"deletions":248,"binary":false,"changes":360,"status":"modified"}]}