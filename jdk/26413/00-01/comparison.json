{"files":[{"patch":"@@ -602,1 +602,1 @@\n-                str = JLA.uncheckedNewString(bytearr, StandardCharsets.ISO_8859_1);\n+                str = JLA.uncheckedNewStringNoReplacement(bytearr, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-            str = utf8ThrowingIae(bytes, offset, length);\n+            str = utf8(bytes, offset, length);\n@@ -571,29 +571,1 @@\n-    private static String utf8ThrowingIae(byte[] bytes, int offset, int length) {\n-        try {\n-            return utf8(bytes, offset, length);\n-        } catch (CharacterCodingException cce) {\n-            throw cce2iae(cce);\n-        }\n-    }\n-\n-    private static IllegalArgumentException cce2iae(CharacterCodingException cce) {\n-        Throwable cause = cce.getCause();\n-        \/\/ If the CCE is caused by an IAE, it implies that IAE is injected by\n-        \/\/ us to provide more context into CCE. Try swapping them to obtain an\n-        \/\/ IAE caused by a CCE.\n-        if (cause instanceof IllegalArgumentException iae) {\n-            if (cce instanceof MalformedInputException mie) {\n-                return new IllegalArgumentException(\n-                        iae.getMessage(),\n-                        new MalformedInputException(mie.getInputLength()));\n-            }\n-            if (cce instanceof UnmappableCharacterException uce) {\n-                return new IllegalArgumentException(\n-                        iae.getMessage(),\n-                        new UnmappableCharacterException(uce.getInputLength()));\n-            }\n-        }\n-        return new IllegalArgumentException(cce);\n-    }\n-\n-    private static String utf8(byte[] bytes, int offset, int length) throws CharacterCodingException {\n+    private static String utf8(byte[] bytes, int offset, int length) {\n@@ -635,1 +607,1 @@\n-            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n+            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp);\n@@ -642,1 +614,1 @@\n-            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0);\n@@ -734,1 +706,1 @@\n-    static String newStringUTF8(byte[] bytes, int offset, int length, boolean noShare) throws CharacterCodingException {\n+    static String newStringUTF8NoReplacement(byte[] bytes, int offset, int length, boolean noShare) throws CharacterCodingException {\n@@ -786,1 +758,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, sl, dst, dp);\n@@ -789,1 +761,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n+            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, offset + length, dst, 0);\n@@ -797,1 +769,1 @@\n-    static String newString(byte[] src, Charset cs) throws CharacterCodingException {\n+    static String newStringNoReplacement(byte[] src, Charset cs) throws CharacterCodingException {\n@@ -803,1 +775,1 @@\n-            return newStringUTF8(src, 0, src.length, false);\n+            return newStringUTF8NoReplacement(src, 0, src.length, false);\n@@ -816,1 +788,1 @@\n-                throwMalformed(src);\n+                throw malformedInputException(src);\n@@ -866,1 +838,1 @@\n-    private static byte[] encode(Charset cs, byte coder, byte[] val) throws CharacterCodingException {\n+    private static byte[] encode(Charset cs, byte coder, byte[] val) {\n@@ -868,1 +840,1 @@\n-            return encodeUTF8(coder, val, true);\n+            return encodeUTF8(coder, val);\n@@ -876,1 +848,1 @@\n-        return encodeWithEncoder(cs, coder, val, true);\n+        return encodeWithEncoder(cs, coder, val);\n@@ -879,1 +851,1 @@\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) throws CharacterCodingException {\n+    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val) {\n@@ -883,2 +855,2 @@\n-        \/\/ fastpath with ArrayEncoder implies `doReplace`.\n-        if (doReplace && ce instanceof ArrayEncoder ae) {\n+        \/\/ Fast-path with `ArrayEncoder` implies replacement.\n+        if (ce instanceof ArrayEncoder ae) {\n@@ -907,4 +879,2 @@\n-        if (doReplace) {\n-            ce.onMalformedInput(CodingErrorAction.REPLACE)\n-                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-        }\n+        ce.onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n@@ -923,5 +893,12 @@\n-            if (!doReplace) {\n-                throw x;\n-            } else {\n-                throw new Error(x);\n-            }\n+            throw new Error(x);\n+        }\n+        return trimArray(ba, bb.position());\n+    }\n+\n+    private static byte[] encodeWithEncoderNoReplacement(Charset cs, byte coder, byte[] val) throws CharacterCodingException {\n+        CharsetEncoder ce = cs.newEncoder();\n+        int len = val.length >> coder;  \/\/ assume LATIN1=0\/UTF16=1;\n+        int en = scale(len, ce.maxBytesPerChar());\n+        byte[] ba = new byte[en];\n+        if (len == 0) {\n+            return ba;\n@@ -929,0 +906,10 @@\n+        char[] ca = (coder == LATIN1 ) ? StringLatin1.toChars(val)\n+                : StringUTF16.toChars(val);\n+        ByteBuffer bb = ByteBuffer.wrap(ba);\n+        CharBuffer cb = CharBuffer.wrap(ca, 0, len);\n+        CoderResult cr = ce.encode(cb, bb, true);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n+        cr = ce.flush(bb);\n+        if (!cr.isUnderflow())\n+            cr.throwException();\n@@ -939,2 +926,2 @@\n-    static byte[] getBytesUTF8(String s) throws CharacterCodingException {\n-        return encodeUTF8(s.coder(), s.value(), false);  \/\/ Implicit null check on `s`\n+    static byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n+        return encodeUTF8NoReplacement(s.coder(), s.value());  \/\/ Implicit null check on `s`\n@@ -960,1 +947,1 @@\n-    static byte[] getBytes(String s, Charset cs) throws CharacterCodingException {\n+    static byte[] getBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n@@ -969,1 +956,1 @@\n-            return encodeUTF8(coder, val, false);\n+            return encodeUTF8NoReplacement(coder, val);\n@@ -975,1 +962,1 @@\n-            return encode8859_1(coder, val, false);\n+            return encode8859_1NoReplacement(coder, val);\n@@ -982,1 +969,1 @@\n-                    throwUnmappable(val);\n+                    throw unmappableCharacterException(val);\n@@ -986,1 +973,1 @@\n-        return encodeWithEncoder(cs, coder, val, false);\n+        return encodeWithEncoderNoReplacement(cs, coder, val);\n@@ -1027,5 +1014,1 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val) throws UnmappableCharacterException {\n-        return encode8859_1(coder, val, true);\n-    }\n-\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) throws UnmappableCharacterException {\n+    private static byte[] encode8859_1(byte coder, byte[] val) {\n@@ -1045,3 +1028,0 @@\n-                if (!doReplace) {\n-                    throwUnmappable(sp);\n-                }\n@@ -1063,0 +1043,22 @@\n+    private static byte[] encode8859_1NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+        if (coder == LATIN1) {\n+            return val.clone();\n+        }\n+        int len = val.length >> 1;\n+        byte[] dst = new byte[len];\n+        int dp = 0;\n+        int sp = 0;\n+        while (sp < len) {\n+            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            sp = sp + ret;\n+            dp = dp + ret;\n+            if (ret != len) {\n+                throw unmappableCharacterException(sp);\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n@@ -1140,2 +1142,1 @@\n-    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace)\n-            throws CharacterCodingException {\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp) {\n@@ -1150,3 +1151,0 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 1, 1);\n-                        }\n@@ -1160,3 +1158,0 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n-                }\n@@ -1170,3 +1165,0 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 3, 3);\n-                        }\n@@ -1179,3 +1171,0 @@\n-                            if (!doReplace) {\n-                                throwMalformed(sp - 3, 3);\n-                            }\n@@ -1190,3 +1179,0 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 2);\n-                    }\n@@ -1196,3 +1182,0 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);\n-                }\n@@ -1209,3 +1192,0 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 4, 4);\n-                        }\n@@ -1223,3 +1203,0 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n-                    }\n@@ -1229,3 +1206,0 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n@@ -1239,3 +1213,0 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n-                }\n@@ -1248,0 +1219,64 @@\n+    private static int decodeUTF8_UTF16NoReplacement(byte[] src, int sp, int sl, byte[] dst, int dp)\n+            throws CharacterCodingException {\n+        while (sp < sl) {\n+            int b1 = src[sp++];\n+            if (b1 >= 0) {\n+                StringUTF16.putChar(dst, dp++, (char) b1);\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                if (sp < sl) {\n+                    int b2 = src[sp++];\n+                    if (isNotContinuation(b2)) {\n+                        throw malformedInputException(sp - 1, 1);\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, decode2(b1, b2));\n+                    }\n+                    continue;\n+                }\n+                throw malformedInputException(sp, 1);  \/\/ underflow()\n+            } else if ((b1 >> 4) == -2) {\n+                if (sp + 1 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    if (isMalformed3(b1, b2, b3)) {\n+                        throw malformedInputException(sp - 3, 3);\n+                    } else {\n+                        char c = decode3(b1, b2, b3);\n+                        if (Character.isSurrogate(c)) {\n+                            throw malformedInputException(sp - 3, 3);\n+                        } else {\n+                            StringUTF16.putChar(dst, dp++, c);\n+                        }\n+                    }\n+                    continue;\n+                }\n+                if (sp < sl && isMalformed3_2(b1, src[sp])) {\n+                    throw malformedInputException(sp - 1, 2);\n+                }\n+                throw malformedInputException(sp, 1);\n+            } else if ((b1 >> 3) == -2) {\n+                if (sp + 2 < sl) {\n+                    int b2 = src[sp++];\n+                    int b3 = src[sp++];\n+                    int b4 = src[sp++];\n+                    int uc = decode4(b1, b2, b3, b4);\n+                    if (isMalformed4(b2, b3, b4) ||\n+                            !Character.isSupplementaryCodePoint(uc)) { \/\/ shortest form check\n+                        throw malformedInputException(sp - 4, 4);\n+                    } else {\n+                        StringUTF16.putChar(dst, dp++, Character.highSurrogate(uc));\n+                        StringUTF16.putChar(dst, dp++, Character.lowSurrogate(uc));\n+                    }\n+                    continue;\n+                }\n+                b1 &= 0xff;\n+                if (b1 > 0xf4 || sp < sl && isMalformed4_2(b1, src[sp] & 0xff)) {\n+                    throw malformedInputException(sp - 1, 1);  \/\/ or 2\n+                }\n+                throw malformedInputException(sp - 1, 1);\n+            } else {\n+                throw malformedInputException(sp - 1, 1);\n+            }\n+        }\n+        return dp;\n+    }\n+\n@@ -1282,1 +1317,1 @@\n-    private static void throwMalformed(int off, int nb) throws MalformedInputException {\n+    private static MalformedInputException malformedInputException(int off, int nb) {\n@@ -1286,1 +1321,1 @@\n-        throw mie;\n+        return mie;\n@@ -1289,1 +1324,1 @@\n-    private static void throwMalformed(byte[] val) throws MalformedInputException {\n+    private static MalformedInputException malformedInputException(byte[] val) {\n@@ -1291,1 +1326,1 @@\n-        throwMalformed(dp, 1);\n+        return malformedInputException(dp, 1);\n@@ -1294,1 +1329,1 @@\n-    private static void throwUnmappable(int off) throws UnmappableCharacterException {\n+    private static UnmappableCharacterException unmappableCharacterException(int off) {\n@@ -1298,1 +1333,1 @@\n-        throw uce;\n+        return uce;\n@@ -1301,1 +1336,1 @@\n-    private static void throwUnmappable(byte[] val) throws UnmappableCharacterException {\n+    private static UnmappableCharacterException unmappableCharacterException(byte[] val) {\n@@ -1303,1 +1338,26 @@\n-        throwUnmappable(dp);\n+        return unmappableCharacterException(dp);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val) {\n+        if (coder == UTF16) {\n+            return encodeUTF8_UTF16(val);\n+        }\n+\n+        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n+            return val.clone();\n+        }\n+\n+        int dp = 0;\n+        byte[] dst = StringUTF16.newBytesFor(val.length);\n+        for (byte c : val) {\n+            if (c < 0) {\n+                dst[dp++] = (byte) (0xc0 | ((c & 0xff) >> 6));\n+                dst[dp++] = (byte) (0x80 | (c & 0x3f));\n+            } else {\n+                dst[dp++] = c;\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n@@ -1306,1 +1366,1 @@\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) throws UnmappableCharacterException {\n+    private static byte[] encodeUTF8NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n@@ -1308,1 +1368,1 @@\n-            return encodeUTF8_UTF16(val, doReplace);\n+            return encodeUTF8_UTF16NoReplacement(val);\n@@ -1331,1 +1391,1 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) throws UnmappableCharacterException {\n+    private static byte[] encodeUTF8_UTF16(byte[] val) {\n@@ -1337,1 +1397,1 @@\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, doReplace) : sl * 3;\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val) : sl * 3;\n@@ -1366,5 +1426,57 @@\n-                    if (doReplace) {\n-                        dst[dp++] = '?';\n-                    } else {\n-                        throwUnmappable(sp - 1);\n-                    }\n+                    dst[dp++] = '?';\n+                } else {\n+                    dst[dp++] = (byte)(0xf0 | ((uc >> 18)));\n+                    dst[dp++] = (byte)(0x80 | ((uc >> 12) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | ((uc >>  6) & 0x3f));\n+                    dst[dp++] = (byte)(0x80 | (uc & 0x3f));\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dst[dp++] = (byte)(0xe0 | ((c >> 12)));\n+                dst[dp++] = (byte)(0x80 | ((c >>  6) & 0x3f));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            }\n+        }\n+        if (dp == dst.length) {\n+            return dst;\n+        }\n+        return Arrays.copyOf(dst, dp);\n+    }\n+\n+    private static byte[] encodeUTF8_UTF16NoReplacement(byte[] val) throws UnmappableCharacterException {\n+        int dp = 0;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+        \/\/ UTF-8 encoded can be as much as 3 times the string length\n+        \/\/ For very large estimate, (as in overflow of 32 bit int), precompute the exact size\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16NoReplacement(val) : sl * 3;\n+        if (allocLen > (long)Integer.MAX_VALUE) {\n+            throw new OutOfMemoryError(\"Required length exceeds implementation limit\");\n+        }\n+        byte[] dst = new byte[(int) allocLen];\n+        while (sp < sl) {\n+            \/\/ ascii fast loop;\n+            char c = StringUTF16.getChar(val, sp);\n+            if (c >= '\\u0080') {\n+                break;\n+            }\n+            dst[dp++] = (byte)c;\n+            sp++;\n+        }\n+        while (sp < sl) {\n+            char c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dst[dp++] = (byte)c;\n+            } else if (c < 0x800) {\n+                dst[dp++] = (byte)(0xc0 | (c >> 6));\n+                dst[dp++] = (byte)(0x80 | (c & 0x3f));\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    throw unmappableCharacterException(sp - 1);\n@@ -1394,1 +1506,0 @@\n-     * @param doReplace true to replace unmappable characters\n@@ -1396,1 +1507,1 @@\n-    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) throws UnmappableCharacterException {\n+    private static long computeSizeUTF8_UTF16(byte[] val) {\n@@ -1415,5 +1526,37 @@\n-                    if (doReplace) {\n-                        dp++;\n-                    } else {\n-                        throwUnmappable(sp - 1);\n-                    }\n+                    dp++;\n+                } else {\n+                    dp += 4;\n+                    sp++;  \/\/ 2 chars\n+                }\n+            } else {\n+                \/\/ 3 bytes, 16 bits\n+                dp += 3;\n+            }\n+        }\n+        return dp;\n+    }\n+\n+    \/**\n+     * {@return the exact size required to UTF_8 encode this UTF16 string}\n+     * @param val UTF16 encoded byte array\n+     *\/\n+    private static long computeSizeUTF8_UTF16NoReplacement(byte[] val) throws UnmappableCharacterException {\n+        long dp = 0L;\n+        int sp = 0;\n+        int sl = val.length >> 1;\n+\n+        while (sp < sl) {\n+            char c = StringUTF16.getChar(val, sp++);\n+            if (c < 0x80) {\n+                dp++;\n+            } else if (c < 0x800) {\n+                dp += 2;\n+            } else if (Character.isSurrogate(c)) {\n+                int uc = -1;\n+                char c2;\n+                if (Character.isHighSurrogate(c) && sp < sl &&\n+                        Character.isLowSurrogate(c2 = StringUTF16.getChar(val, sp))) {\n+                    uc = Character.toCodePoint(c, c2);\n+                }\n+                if (uc < 0) {\n+                    throw unmappableCharacterException(sp - 1);\n@@ -1850,5 +1993,1 @@\n-        try {\n-            return encode(lookupCharset(charsetName), coder(), value);\n-        } catch (CharacterCodingException cce) {\n-            throw cce2iae(cce);\n-        }\n+        return encode(lookupCharset(charsetName), coder(), value);\n@@ -1877,5 +2016,1 @@\n-        try {\n-            return encode(charset, coder(), value);\n-        } catch (CharacterCodingException cce) {\n-            throw cce2iae(cce);\n-        }\n+        return encode(charset, coder(), value);\n@@ -1899,5 +2034,1 @@\n-        try {\n-            return encode(Charset.defaultCharset(), coder(), value);\n-        } catch (CharacterCodingException cce) {\n-            throw cce2iae(cce);\n-        }\n+        return encode(Charset.defaultCharset(), coder(), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":270,"deletions":139,"binary":false,"changes":409,"status":"modified"},{"patch":"@@ -2131,2 +2131,2 @@\n-            public String uncheckedNewString(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newString(bytes, cs);\n+            public String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringNoReplacement(bytes, cs);\n@@ -2143,2 +2143,2 @@\n-            public byte[] uncheckedGetBytes(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytes(s, cs);\n+            public byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesNoReplacement(s, cs);\n@@ -2147,2 +2147,2 @@\n-            public String newStringUTF8(byte[] bytes, int off, int len) throws CharacterCodingException {\n-                return String.newStringUTF8(bytes, off, len, true);\n+            public String newStringUTF8NoReplacement(byte[] bytes, int off, int len) throws CharacterCodingException {\n+                return String.newStringUTF8NoReplacement(bytes, off, len, true);\n@@ -2151,2 +2151,2 @@\n-            public byte[] getBytesUTF8(String s) throws CharacterCodingException {\n-                return String.getBytesUTF8(s);\n+            public byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n+                return String.getBytesUTF8NoReplacement(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4153,1 +4153,1 @@\n-                return JLA.uncheckedNewString(buf, StandardCharsets.ISO_8859_1);\n+                return JLA.uncheckedNewStringNoReplacement(buf, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-        return JLA.uncheckedNewString(ba, cs);\n+        return JLA.uncheckedNewStringNoReplacement(ba, cs);\n@@ -3365,1 +3365,1 @@\n-        byte[] bytes = JLA.uncheckedGetBytes(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.uncheckedGetBytesNoReplacement(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n@@ -699,1 +699,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n@@ -735,1 +735,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n@@ -763,1 +763,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n@@ -799,1 +799,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n@@ -827,1 +827,1 @@\n-            return jla.uncheckedNewString(rep, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(rep, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-            return jla.uncheckedNewString(buf, StandardCharsets.ISO_8859_1);\n+            return jla.uncheckedNewStringNoReplacement(buf, StandardCharsets.ISO_8859_1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-                return JLA.newStringUTF8(ba, off, length);\n+                return JLA.newStringUTF8NoReplacement(ba, off, length);\n@@ -265,1 +265,1 @@\n-                return JLA.getBytesUTF8(s);\n+                return JLA.getBytesUTF8NoReplacement(s);\n@@ -282,1 +282,1 @@\n-                \/\/ We use the JLA.newStringUTF8 variant to throw\n+                \/\/ We use the JLA.newStringUTF8NoReplacement variant to throw\n@@ -284,1 +284,1 @@\n-                return hash(JLA.newStringUTF8(a, off, len));\n+                return hash(JLA.newStringUTF8NoReplacement(a, off, len));\n@@ -300,1 +300,1 @@\n-                byte[] encoded = JLA.uncheckedGetBytes(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.uncheckedGetBytesNoReplacement(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-    String uncheckedNewString(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -348,1 +348,1 @@\n-    byte[] uncheckedGetBytes(String s, Charset cs) throws CharacterCodingException;\n+    byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException;\n@@ -359,1 +359,1 @@\n-     * @throws CharacterCodingException for malformed input or unmappable characters\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -361,1 +361,1 @@\n-    String newStringUTF8(byte[] bytes, int offset, int length) throws CharacterCodingException;\n+    String newStringUTF8NoReplacement(byte[] bytes, int offset, int length) throws CharacterCodingException;\n@@ -393,1 +393,1 @@\n-    byte[] getBytesUTF8(String s) throws CharacterCodingException;\n+    byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.uncheckedGetBytes(input, Util.jnuEncoding());\n+            return JLA.uncheckedGetBytesNoReplacement(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Tests for *NoRepl() shared secret methods.\n+ * @summary Tests for *NoReplacement() shared secret methods.\n@@ -48,1 +48,1 @@\n-     * Verifies newStringNoRepl() throws a CharacterCodingException.\n+     * Verifies `uncheckedNewStringNoReplacement()` throws a `CharacterCodingException`.\n@@ -52,1 +52,1 @@\n-    public void newStringNoReplTest() throws IOException {\n+    public void uncheckedNewStringNoReplacementTest() throws IOException {\n@@ -70,1 +70,1 @@\n-     * Verifies getBytesNoRepl() throws a CharacterCodingException.\n+     * Verifies `uncheckedGetBytesNoReplacement()` throws a `CharacterCodingException`.\n@@ -74,1 +74,1 @@\n-    public void getBytesNoReplTest() throws IOException {\n+    public void uncheckedGetBytesNoReplacementTest() throws IOException {\n","filename":"test\/jdk\/java\/lang\/String\/NoReplTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}