{"files":[{"patch":"@@ -707,1 +707,2 @@\n-    private static String newStringUTF8NoReplacement(byte[] bytes, int offset, int length) throws CharacterCodingException {\n+    private static String newStringUTF8OrThrow(byte[] bytes, int offset, int length)\n+            throws CharacterCodingException {\n@@ -759,1 +760,1 @@\n-            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, sl, dst, dp);\n+            dp = decodeUTF8_UTF16OrThrow(bytes, offset, sl, dst, dp);\n@@ -762,1 +763,1 @@\n-            dp = decodeUTF8_UTF16NoReplacement(bytes, offset, offset + length, dst, 0);\n+            dp = decodeUTF8_UTF16OrThrow(bytes, offset, offset + length, dst, 0);\n@@ -798,1 +799,1 @@\n-    static String newStringNoReplacement(byte[] src, Charset cs) throws CharacterCodingException {\n+    static String newStringOrThrow(byte[] src, Charset cs) throws CharacterCodingException {\n@@ -804,1 +805,1 @@\n-            return newStringUTF8NoReplacement(src, 0, src.length);\n+            return newStringUTF8OrThrow(src, 0, src.length);\n@@ -877,4 +878,0 @@\n-        return encodeWithEncoder(cs, coder, val);\n-    }\n-\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val) {\n@@ -884,5 +881,0 @@\n-    private static byte[] encodeWithEncoderNoReplacement(Charset cs, byte coder, byte[] val)\n-            throws CharacterCodingException {\n-        return encodeWithEncoder(cs, coder, val, CharacterCodingException.class);\n-    }\n-\n@@ -962,2 +954,2 @@\n-    static byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n-        return encodeUTF8NoReplacement(s.coder(), s.value());  \/\/ Implicit null check on `s`\n+    static byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException {\n+        return encodeUTF8OrThrow(s.coder(), s.value());  \/\/ Implicit null check on `s`\n@@ -983,1 +975,1 @@\n-    static byte[] getBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n+    static byte[] getBytesOrThrow(String s, Charset cs) throws CharacterCodingException {\n@@ -991,1 +983,1 @@\n-            return encodeUTF8NoReplacement(coder, val);\n+            return encodeUTF8OrThrow(coder, val);\n@@ -997,1 +989,1 @@\n-            return encode8859_1NoReplacement(coder, val);\n+            return encode8859_1OrThrow(coder, val);\n@@ -1008,1 +1000,1 @@\n-        return encodeWithEncoderNoReplacement(cs, coder, val);\n+        return encodeWithEncoder(cs, coder, val, CharacterCodingException.class);\n@@ -1053,1 +1045,1 @@\n-    private static byte[] encode8859_1NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+    private static byte[] encode8859_1OrThrow(byte coder, byte[] val) throws UnmappableCharacterException {\n@@ -1178,1 +1170,1 @@\n-    private static int decodeUTF8_UTF16NoReplacement(\n+    private static int decodeUTF8_UTF16OrThrow(\n@@ -1336,1 +1328,2 @@\n-     * {@return a new {@link MalformedInputException} for the sub-range denoted by specified {@code offset} and {@code length}}\n+     * {@return a new {@link MalformedInputException} for the sub-range denoted\n+     * by specified {@code offset} and {@code length}}\n@@ -1338,1 +1331,2 @@\n-     * @param <E> The exception type parameter to enable callers to avoid having to declare the exception\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n@@ -1349,1 +1343,2 @@\n-     * {@return a new {@link MalformedInputException} for the given malformed ASCII string}\n+     * {@return a new {@link MalformedInputException} for the given malformed\n+     * ASCII string}\n@@ -1351,1 +1346,2 @@\n-     * @param <E> The exception type parameter to enable callers to avoid having to declare the exception\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n@@ -1361,1 +1357,2 @@\n-     * @param <E> The exception type parameter to enable callers to avoid having to declare the exception\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n@@ -1372,1 +1369,2 @@\n-     * {@return a new {@link UnmappableCharacterException} for the given malformed ASCII string}\n+     * {@return a new {@link UnmappableCharacterException} for the given\n+     * malformed ASCII string}\n@@ -1374,1 +1372,2 @@\n-     * @param <E> The exception type parameter to enable callers to avoid having to declare the exception\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *          having to declare the exception\n@@ -1385,1 +1384,1 @@\n-    private static byte[] encodeUTF8NoReplacement(byte coder, byte[] val) throws UnmappableCharacterException {\n+    private static byte[] encodeUTF8OrThrow(byte coder, byte[] val) throws UnmappableCharacterException {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":29,"deletions":30,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2135,2 +2135,2 @@\n-            public String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoReplacement(bytes, cs);\n+            public String uncheckedNewStringOrThrow(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringOrThrow(bytes, cs);\n@@ -2147,2 +2147,2 @@\n-            public byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoReplacement(s, cs);\n+            public byte[] uncheckedGetBytesOrThrow(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesOrThrow(s, cs);\n@@ -2151,2 +2151,2 @@\n-            public byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException {\n-                return String.getBytesUTF8NoReplacement(s);\n+            public byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException {\n+                return String.getBytesUTF8OrThrow(s);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-        return JLA.uncheckedNewStringNoReplacement(ba, cs);\n+        return JLA.uncheckedNewStringOrThrow(ba, cs);\n@@ -3365,1 +3365,1 @@\n-        byte[] bytes = JLA.uncheckedGetBytesNoReplacement(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.uncheckedGetBytesOrThrow(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-                return JLA.uncheckedNewStringNoReplacement(bytes, StandardCharsets.UTF_8);\n+                return JLA.uncheckedNewStringOrThrow(bytes, StandardCharsets.UTF_8);\n@@ -268,1 +268,1 @@\n-                return JLA.getBytesUTF8NoReplacement(s);\n+                return JLA.getBytesUTF8OrThrow(s);\n@@ -301,1 +301,1 @@\n-                byte[] encoded = JLA.uncheckedGetBytesNoReplacement(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.uncheckedGetBytesOrThrow(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -345,1 +345,1 @@\n-    String uncheckedNewStringNoReplacement(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewStringOrThrow(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -360,1 +360,1 @@\n-    byte[] uncheckedGetBytesNoReplacement(String s, Charset cs) throws CharacterCodingException;\n+    byte[] uncheckedGetBytesOrThrow(String s, Charset cs) throws CharacterCodingException;\n@@ -392,1 +392,1 @@\n-    byte[] getBytesUTF8NoReplacement(String s) throws CharacterCodingException;\n+    byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.uncheckedGetBytesNoReplacement(input, Util.jnuEncoding());\n+            return JLA.uncheckedGetBytesOrThrow(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8286287 8288589\n- * @summary Tests for *NoReplacement() shared secret methods.\n- * @run testng NoReplacementTest\n- * @modules jdk.charsets\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.HexFormat;\n-import static java.nio.charset.StandardCharsets.UTF_16;\n-\n-import org.testng.annotations.Test;\n-\n-@Test\n-public class NoReplacementTest {\n-    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n-    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n-    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n-\n-    \/**\n-     * Verifies {@code uncheckedNewStringNoReplacement()} throws a {@link CharacterCodingException}.\n-     * The method is invoked by {@code Files.readString()} method.\n-     *\/\n-    @Test\n-    public void uncheckedNewStringNoReplacementTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try (var fos = Files.newOutputStream(f)) {\n-            fos.write(MALFORMED_UTF16);\n-            var read = Files.readString(f, UTF_16);\n-            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n-                    HexFormat.of()\n-                            .withPrefix(\"x\")\n-                            .withUpperCase()\n-                            .formatHex(read.getBytes(UTF_16)));\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies {@code uncheckedGetBytesNoReplacement()} throws a {@link CharacterCodingException}.\n-     * The method is invoked by {@code Files.writeString()} method.\n-     *\/\n-    @Test\n-    public void uncheckedGetBytesNoReplacementTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try {\n-            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n-            throw new RuntimeException(\"Exception should be thrown\");\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplacementTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8286287 8288589\n+ * @summary Tests for *OrThrow() shared secret methods.\n+ * @run testng OrThrowTest\n+ * @modules jdk.charsets\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.util.HexFormat;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class OrThrowTest {\n+    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n+    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n+    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+\n+    \/**\n+     * Verifies {@code uncheckedNewStringOrThrow()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.readString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedNewStringOrThrowTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try (var fos = Files.newOutputStream(f)) {\n+            fos.write(MALFORMED_UTF16);\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies {@code uncheckedGetBytesOrThrow()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.writeString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedGetBytesOrThrowTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try {\n+            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n+            throw new RuntimeException(\"Exception should be thrown\");\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/OrThrowTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}