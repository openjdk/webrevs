{"files":[{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -34,3 +33,3 @@\n-uint ObjectStartArray::_card_shift = 0;\n-uint ObjectStartArray::_card_size = 0;\n-uint ObjectStartArray::_card_size_in_words = 0;\n+static size_t num_bytes_required(MemRegion mr) {\n+  assert(CardTable::is_card_aligned(mr.start()), \"precondition\");\n+  assert(CardTable::is_card_aligned(mr.end()), \"precondition\");\n@@ -38,4 +37,1 @@\n-void ObjectStartArray::initialize_block_size(uint card_shift) {\n-  _card_shift = card_shift;\n-  _card_size = 1 << _card_shift;\n-  _card_size_in_words = _card_size \/ sizeof(HeapWord);\n+  return mr.word_size() \/ BOTConstants::card_size_in_words();\n@@ -45,5 +41,0 @@\n-  \/\/ We're based on the assumption that we use the same\n-  \/\/ size blocks as the card table.\n-  assert(_card_size == CardTable::card_size(), \"Sanity\");\n-  assert(_card_size <= MaxBlockSize, \"block_size must be less than or equal to \" UINT32_FORMAT, MaxBlockSize);\n-\n@@ -51,3 +42,1 @@\n-  _reserved_region = reserved_region;\n-\n-  size_t bytes_to_reserve = reserved_region.word_size() \/ _card_size_in_words;\n+  size_t bytes_to_reserve = num_bytes_required(reserved_region);\n@@ -65,1 +54,1 @@\n-  MemTracker::record_virtual_memory_type((address)backing_store.base(), mtGC);\n+  MemTracker::record_virtual_memory_type(backing_store.base(), mtGC);\n@@ -70,7 +59,1 @@\n-  _raw_base = (jbyte*)_virtual_space.low_boundary();\n-  assert(_raw_base != nullptr, \"set from the backing_store\");\n-\n-  _offset_base = _raw_base - (size_t(reserved_region.start()) >> _card_shift);\n-\n-  _covered_region.set_start(reserved_region.start());\n-  _covered_region.set_word_size(0);\n+  assert(_virtual_space.low_boundary() != nullptr, \"set from the backing_store\");\n@@ -78,2 +61,1 @@\n-  _blocks_region.set_start((HeapWord*)_raw_base);\n-  _blocks_region.set_word_size(0);\n+  _offset_base = (uint8_t*)(_virtual_space.low_boundary() - (uintptr_t(reserved_region.start()) >> BOTConstants::log_card_size()));\n@@ -83,9 +65,1 @@\n-  assert(_reserved_region.contains(mr), \"MemRegion outside of reserved space\");\n-  assert(_reserved_region.start() == mr.start(), \"Attempt to move covered region\");\n-\n-  HeapWord* low_bound  = mr.start();\n-  HeapWord* high_bound = mr.end();\n-  assert((uintptr_t(low_bound)  & (_card_size - 1))  == 0, \"heap must start at block boundary\");\n-  assert((uintptr_t(high_bound) & (_card_size - 1))  == 0, \"heap must end at block boundary\");\n-\n-  size_t requested_blocks_size_in_bytes = mr.word_size() \/ _card_size_in_words;\n+  DEBUG_ONLY(_covered_region = mr;)\n@@ -93,0 +67,1 @@\n+  size_t requested_size = num_bytes_required(mr);\n@@ -94,2 +69,1 @@\n-  requested_blocks_size_in_bytes =\n-    align_up(requested_blocks_size_in_bytes, os::vm_page_size());\n+  requested_size = align_up(requested_size, os::vm_page_size());\n@@ -97,1 +71,1 @@\n-  _covered_region = mr;\n+  size_t current_size = _virtual_space.committed_size();\n@@ -99,1 +73,3 @@\n-  size_t current_blocks_size_in_bytes = _blocks_region.byte_size();\n+  if (requested_size == current_size) {\n+    return;\n+  }\n@@ -101,1 +77,1 @@\n-  if (requested_blocks_size_in_bytes > current_blocks_size_in_bytes) {\n+  if (requested_size > current_size) {\n@@ -103,1 +79,1 @@\n-    size_t expand_by = requested_blocks_size_in_bytes - current_blocks_size_in_bytes;\n+    size_t expand_by = requested_size - current_size;\n@@ -107,5 +83,1 @@\n-    \/\/ Clear *only* the newly allocated region\n-    memset(_blocks_region.end(), clean_block, expand_by);\n-  }\n-\n-  if (requested_blocks_size_in_bytes < current_blocks_size_in_bytes) {\n+  } else {\n@@ -113,1 +85,1 @@\n-    size_t shrink_by = current_blocks_size_in_bytes - requested_blocks_size_in_bytes;\n+    size_t shrink_by = current_size - requested_size;\n@@ -116,7 +88,0 @@\n-\n-  _blocks_region.set_word_size(requested_blocks_size_in_bytes \/ sizeof(HeapWord));\n-\n-  assert(requested_blocks_size_in_bytes % sizeof(HeapWord) == 0, \"Block table not expanded in word sized increment\");\n-  assert(requested_blocks_size_in_bytes == _blocks_region.byte_size(), \"Sanity\");\n-  assert(block_for_addr(low_bound) == &_raw_base[0], \"Checking start of map\");\n-  assert(block_for_addr(high_bound-1) <= &_raw_base[_blocks_region.byte_size()-1], \"Checking end of map\");\n@@ -125,2 +90,3 @@\n-void ObjectStartArray::reset() {\n-  memset(_blocks_region.start(), clean_block, _blocks_region.byte_size());\n+static void fill_range(uint8_t* start, uint8_t* end, uint8_t v) {\n+  \/\/ + 1 for inclusive\n+  memset(start, v, pointer_delta(end, start, sizeof(uint8_t)) + 1);\n@@ -129,11 +95,29 @@\n-bool ObjectStartArray::object_starts_in_range(HeapWord* start_addr,\n-                                              HeapWord* end_addr) const {\n-  assert(start_addr <= end_addr,\n-         \"Range is wrong. start_addr (\" PTR_FORMAT \") is after end_addr (\" PTR_FORMAT \")\",\n-         p2i(start_addr), p2i(end_addr));\n-\n-  assert(is_aligned(start_addr, _card_size), \"precondition\");\n-\n-  if (start_addr == end_addr) {\n-    \/\/ No objects in empty range.\n-    return false;\n+void ObjectStartArray::update_for_block_work(HeapWord* blk_start,\n+                                             HeapWord* blk_end) {\n+  HeapWord* const cur_card_boundary = align_up_by_card_size(blk_start);\n+  uint8_t* const offset_entry = entry_for_addr(cur_card_boundary);\n+\n+  \/\/ The first card holds the actual offset.\n+  *offset_entry = checked_cast<uint8_t>(pointer_delta(cur_card_boundary, blk_start));\n+\n+  \/\/ Check if this block spans over other cards.\n+  uint8_t* const end_entry = entry_for_addr(blk_end - 1);\n+  assert(offset_entry <= end_entry, \"inv\");\n+\n+  if (offset_entry != end_entry) {\n+    \/\/ Handling remaining entries.\n+    uint8_t* start_entry_for_region = offset_entry + 1;\n+    for (uint i = 0; i < BOTConstants::N_powers; i++) {\n+      \/\/ -1 so that the reach ends in this region and not at the start\n+      \/\/ of the next.\n+      uint8_t* reach = offset_entry + BOTConstants::power_to_cards_back(i + 1) - 1;\n+      uint8_t value = checked_cast<uint8_t>(BOTConstants::card_size_in_words() + i);\n+\n+      fill_range(start_entry_for_region, MIN2(reach, end_entry), value);\n+      start_entry_for_region = reach + 1;\n+\n+      if (reach >= end_entry) {\n+        break;\n+      }\n+    }\n+    assert(start_entry_for_region > end_entry, \"Sanity check\");\n@@ -142,2 +126,2 @@\n-  jbyte* start_block = block_for_addr(start_addr);\n-  jbyte* end_block = block_for_addr(end_addr - 1);\n+  debug_only(verify_for_block(blk_start, blk_end);)\n+}\n@@ -145,3 +129,15 @@\n-  for (jbyte* block = start_block; block <= end_block; block++) {\n-    if (*block != clean_block) {\n-      return true;\n+void ObjectStartArray::verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const {\n+  assert(is_crossing_card_boundary(blk_start, blk_end), \"precondition\");\n+\n+  const uint8_t* const start_entry = entry_for_addr(align_up_by_card_size(blk_start));\n+  const uint8_t* const end_entry = entry_for_addr(blk_end - 1);\n+  \/\/ Check entries in [start_entry, end_entry]\n+  assert(*start_entry < BOTConstants::card_size_in_words(), \"offset entry\");\n+\n+  for (const uint8_t* i = start_entry + 1; i <= end_entry; ++i) {\n+    const uint8_t prev  = *(i-1);\n+    const uint8_t value = *i;\n+    if (prev != value) {\n+      assert(value >= prev, \"monotonic\");\n+      size_t n_cards_back = BOTConstants::entry_to_cards_back(value);\n+      assert(start_entry == (i - n_cards_back), \"inv\");\n@@ -150,2 +146,0 @@\n-\n-  return false;\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":68,"deletions":74,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/blockOffsetTable.hpp\"\n@@ -39,5 +40,0 @@\n- friend class VerifyObjectStartArrayClosure;\n-\n- private:\n-  PSVirtualSpace  _virtual_space;\n-  MemRegion       _reserved_region;\n@@ -45,22 +41,1 @@\n-  MemRegion       _covered_region;\n-  MemRegion       _blocks_region;\n-  jbyte*          _raw_base;\n-  jbyte*          _offset_base;\n-\n-  static uint _card_shift;\n-  static uint _card_size;\n-  static uint _card_size_in_words;\n-\n- public:\n-\n-  enum BlockValueConstants {\n-    clean_block                  = -1\n-  };\n-\n-  \/\/ Maximum size an offset table entry can cover. This maximum is derived from that\n-  \/\/ we need an extra bit for possible offsets in the byte for backskip values, leaving 2^7 possible offsets.\n-  \/\/ Minimum object alignment is 8 bytes (2^3), so we can at most represent 2^10 offsets within a BOT value.\n-  static const uint MaxBlockSize = 1024;\n-\n-  \/\/ Initialize block size based on card size\n-  static void initialize_block_size(uint card_shift);\n+  DEBUG_ONLY(MemRegion  _covered_region;)\n@@ -68,10 +43,2 @@\n-  static uint card_shift() {\n-    return _card_shift;\n-  }\n-\n-  static uint card_size() {\n-    return _card_size;\n-  }\n-  static uint card_size_in_words() {\n-    return _card_size_in_words;\n-  }\n+  \/\/ BOT array\n+  PSVirtualSpace  _virtual_space;\n@@ -79,1 +46,2 @@\n- protected:\n+  \/\/ Biased array-start of BOT array for fast heap-addr \/ BOT entry translation\n+  uint8_t*        _offset_base;\n@@ -82,1 +50,1 @@\n-  jbyte* block_for_addr(void* p) const {\n+  uint8_t* entry_for_addr(const void* const p) const {\n@@ -85,3 +53,1 @@\n-    jbyte* result = &_offset_base[uintptr_t(p) >> _card_shift];\n-    assert(_blocks_region.contains(result),\n-           \"out of bounds result in byte_for\");\n+    uint8_t* result = &_offset_base[uintptr_t(p) >> BOTConstants::log_card_size()];\n@@ -92,5 +58,3 @@\n-  HeapWord* addr_for_block(jbyte* p) {\n-    assert(_blocks_region.contains(p),\n-           \"out of bounds access to object start array\");\n-    size_t delta = pointer_delta(p, _offset_base, sizeof(jbyte));\n-    HeapWord* result = (HeapWord*) (delta << _card_shift);\n+  HeapWord* addr_for_entry(const uint8_t* const p) const {\n+    size_t delta = pointer_delta(p, _offset_base, sizeof(uint8_t));\n+    HeapWord* result = (HeapWord*) (delta << BOTConstants::log_card_size());\n@@ -102,15 +66,3 @@\n-  \/\/ Mapping that includes the derived offset.\n-  \/\/ If the block is clean, returns the last address in the covered region.\n-  \/\/ If the block is < index 0, returns the start of the covered region.\n-  HeapWord* offset_addr_for_block(jbyte* p) const {\n-    \/\/ We have to do this before the assert\n-    if (p < _raw_base) {\n-      return _covered_region.start();\n-    }\n-\n-    assert(_blocks_region.contains(p),\n-           \"out of bounds access to object start array\");\n-\n-    if (*p == clean_block) {\n-      return _covered_region.end();\n-    }\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, BOTConstants::card_size());\n+  }\n@@ -118,3 +70,1 @@\n-    size_t delta = pointer_delta(p, _offset_base, sizeof(jbyte));\n-    HeapWord* result = (HeapWord*) (delta << _card_shift);\n-    result += *p;\n+  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n@@ -122,5 +72,1 @@\n-    assert(_covered_region.contains(result),\n-           \"out of bounds accessor from card marking array\");\n-\n-    return result;\n-  }\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const;\n@@ -129,3 +75,0 @@\n-\n-  \/\/ This method is in lieu of a constructor, so that this class can be\n-  \/\/ embedded inline in other classes.\n@@ -134,0 +77,1 @@\n+  \/\/ Heap old-gen resizing\n@@ -136,18 +80,5 @@\n-  void reset();\n-\n-  MemRegion covered_region() { return _covered_region; }\n-\n-#define assert_covered_region_contains(addr)                                                                 \\\n-        assert(_covered_region.contains(addr),                                                               \\\n-               #addr \" (\" PTR_FORMAT \") is not in covered region [\" PTR_FORMAT \", \" PTR_FORMAT \"]\",          \\\n-               p2i(addr), p2i(_covered_region.start()), p2i(_covered_region.end()))\n-\n-  void allocate_block(HeapWord* p) {\n-    assert_covered_region_contains(p);\n-    jbyte* block = block_for_addr(p);\n-    HeapWord* block_base = addr_for_block(block);\n-    size_t offset = pointer_delta(p, block_base, sizeof(HeapWord*));\n-    assert(offset < 128, \"Sanity\");\n-    \/\/ When doing MT offsets, we can't assert this.\n-    \/\/assert(offset > *block, \"Found backwards allocation\");\n-    *block = (jbyte)offset;\n+  static bool is_crossing_card_boundary(HeapWord* const blk_start,\n+                                        HeapWord* const blk_end) {\n+    HeapWord* cur_card_boundary = align_up_by_card_size(blk_start);\n+    \/\/ Strictly greater-than, since we check if this block *crosses* card boundary.\n+    return blk_end > cur_card_boundary;\n@@ -156,5 +87,3 @@\n-  \/\/ Optimized for finding the first object that crosses into\n-  \/\/ a given block. The blocks contain the offset of the last\n-  \/\/ object in that block. Scroll backwards by one, and the first\n-  \/\/ object hit should be at the beginning of the block\n-  inline HeapWord* object_start(HeapWord* addr) const;\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  inline HeapWord* block_start_reaching_into_card(HeapWord* const addr) const;\n@@ -162,4 +91,5 @@\n-  bool is_block_allocated(HeapWord* addr) {\n-    assert_covered_region_contains(addr);\n-    jbyte* block = block_for_addr(addr);\n-    return *block != clean_block;\n+  \/\/ [blk_start, blk_end) representing a block of memory in the heap.\n+  void update_for_block(HeapWord* blk_start, HeapWord* blk_end) {\n+    if (is_crossing_card_boundary(blk_start, blk_end)) {\n+      update_for_block_work(blk_start, blk_end);\n+    }\n@@ -168,6 +98,1 @@\n-  \/\/ Return true iff an object starts in\n-  \/\/   [start_addr, end_addr_aligned_up)\n-  \/\/ where\n-  \/\/   end_addr_aligned_up = align_up(end_addr, _card_size)\n-  \/\/ Precondition: start_addr is card-size aligned\n-  bool object_starts_in_range(HeapWord* start_addr, HeapWord* end_addr) const;\n+  inline HeapWord* object_start(HeapWord* const addr) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":31,"deletions":106,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -30,11 +30,2 @@\n-\/\/ Optimized for finding the first object that crosses into\n-\/\/ a given block. The blocks contain the offset of the last\n-\/\/ object in that block. Scroll backwards by one, and the first\n-\/\/ object hit should be at the beginning of the block\n-HeapWord* ObjectStartArray::object_start(HeapWord* addr) const {\n-  assert_covered_region_contains(addr);\n-  jbyte* block = block_for_addr(addr);\n-  HeapWord* scroll_forward = offset_addr_for_block(block--);\n-  while (scroll_forward > addr) {\n-    scroll_forward = offset_addr_for_block(block--);\n-  }\n+HeapWord* ObjectStartArray::object_start(HeapWord* const addr) const {\n+  HeapWord* cur_block = block_start_reaching_into_card(addr);\n@@ -42,4 +33,10 @@\n-  HeapWord* next = scroll_forward;\n-  while (next <= addr) {\n-    scroll_forward = next;\n-    next += cast_to_oop(next)->size();\n+  while (true) {\n+    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!is_crossing_card_boundary(next_block, addr), \"must be\");\n+    cur_block = next_block;\n@@ -47,3 +44,0 @@\n-  assert(scroll_forward <= addr, \"wrong order for current and arg\");\n-  assert(addr <= next, \"wrong order for arg and next\");\n-  return scroll_forward;\n@@ -52,0 +46,20 @@\n+HeapWord* ObjectStartArray::block_start_reaching_into_card(HeapWord* const addr) const {\n+  const uint8_t* entry = entry_for_addr(addr);\n+\n+  uint8_t offset;\n+  while (true) {\n+    offset = *entry;\n+\n+    if (offset < BOTConstants::card_size_in_words()) {\n+      break;\n+    }\n+\n+    \/\/ The excess of the offset from N_words indicates a power of Base\n+    \/\/ to go back by.\n+    size_t n_cards_back = BOTConstants::entry_to_cards_back(offset);\n+    entry -= n_cards_back;\n+  }\n+\n+  HeapWord* q = addr_for_entry(entry);\n+  return q - offset;\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.inline.hpp","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  guarantee(ct->is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n+  guarantee(CardTable::is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n@@ -98,1 +98,1 @@\n-  guarantee(ct->is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n+  guarantee(CardTable::is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n@@ -136,2 +136,2 @@\n-  assert((block_word_size % (ObjectStartArray::card_size())) == 0,\n-         \"Block size not a multiple of start_array block\");\n+  assert((block_word_size % BOTConstants::card_size_in_words()) == 0,\n+         \"To ensure fast object_start calls\");\n@@ -144,4 +144,0 @@\n-  if (!start_array()->object_starts_in_range(begin, end)) {\n-    return;\n-  }\n-\n@@ -289,1 +285,0 @@\n-    _start_array.allocate_block(cur);\n@@ -291,0 +286,1 @@\n+    _start_array.update_for_block(cur, cur + word_size);\n@@ -393,1 +389,1 @@\n- public:\n+public:\n@@ -400,1 +396,0 @@\n-    guarantee(_start_array->is_block_allocated(cast_from_oop<HeapWord*>(obj)), \"ObjectStartArray missing block allocation\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -54,17 +54,0 @@\n-#ifdef ASSERT\n-  void assert_block_in_covered_region(MemRegion new_memregion) {\n-    \/\/ Explicitly capture current covered_region in a local\n-    MemRegion covered_region = this->start_array()->covered_region();\n-    assert(covered_region.contains(new_memregion),\n-           \"new region is not in covered_region [ \" PTR_FORMAT \", \" PTR_FORMAT \" ], \"\n-           \"new region [ \" PTR_FORMAT \", \" PTR_FORMAT \" ], \"\n-           \"object space [ \" PTR_FORMAT \", \" PTR_FORMAT \" ]\",\n-           p2i(covered_region.start()),\n-           p2i(covered_region.end()),\n-           p2i(new_memregion.start()),\n-           p2i(new_memregion.end()),\n-           p2i(this->object_space()->used_region().start()),\n-           p2i(this->object_space()->used_region().end()));\n-  }\n-#endif\n-\n@@ -75,2 +58,1 @@\n-      DEBUG_ONLY(assert_block_in_covered_region(MemRegion(res, word_size)));\n-      _start_array.allocate_block(res);\n+      _start_array.update_for_block(res, res + word_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1495,1 +1495,1 @@\n-    start_array(id)->allocate_block(obj_beg);\n+    start_array(id)->update_for_block(obj_beg, obj_beg + obj_len);\n@@ -2449,1 +2449,0 @@\n-  old_gen->start_array()->reset();\n@@ -2521,1 +2520,1 @@\n-  _start_array->allocate_block(addr);\n+  _start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n@@ -2614,1 +2613,1 @@\n-    start_array->allocate_block(addr);\n+    start_array->update_for_block(addr, addr + cast_to_oop(addr)->size());\n@@ -3120,1 +3119,1 @@\n-    _start_array->allocate_block(destination());\n+    _start_array->update_for_block(destination(), destination() + words);\n@@ -3185,2 +3184,3 @@\n-    _start_array->allocate_block(addr);\n-    addr += cast_to_oop(addr)->size();\n+    size_t size = cast_to_oop(addr)->size();\n+    _start_array->update_for_block(addr, addr + size);\n+    addr += size;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-  _start_array->allocate_block(obj);\n+  \/\/ filler obj\n+  _start_array->update_for_block(obj, obj + cast_to_oop(obj)->size());\n@@ -135,2 +136,0 @@\n-  assert(_start_array->covered_region().contains(lab), \"Sanity\");\n-\n@@ -141,5 +140,1 @@\n-  if (used.contains(lab)) {\n-    return true;\n-  }\n-\n-  return false;\n+  return used.contains(lab);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-      _start_array->allocate_block(obj);\n+      _start_array->update_for_block(obj, obj + size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,2 +306,2 @@\n-  guarantee(_rs->is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n-  guarantee(_rs->is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n+  guarantee(CardTable::is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n+  guarantee(CardTable::is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,5 +57,0 @@\n-#if INCLUDE_PARALLELGC\n-  \/\/ Set ObjectStartArray block size based on card table entry size\n-  ObjectStartArray::initialize_block_size(_card_shift);\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  bool is_card_aligned(HeapWord* p) {\n+  static bool is_card_aligned(HeapWord* p) {\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}