{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -753,1 +753,10 @@\n-        Object[] a = c.toArray();\n+        Object[] a;\n+        int numNew;\n+        if (c.getClass() == ArrayList.class) {\n+            ArrayList<?> src = (ArrayList<?>) c;\n+            a = src.elementData;\n+            numNew = src.size;\n+        } else {\n+            a = c.toArray();\n+            numNew = a.length;\n+        }\n@@ -755,1 +764,0 @@\n-        int numNew = a.length;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5256,0 +5256,14 @@\n+        @Override\n+        public Object[] toArray() {\n+            return new Object[] {element};\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(T[] a) {\n+            if (a.length < 1)\n+                a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), 1);\n+            a[0] = (T)element;\n+            if (a.length > 1)\n+                a[1] = null;\n+            return a;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -890,0 +890,35 @@\n+    private static void testAddAll(Collection<Integer> c) {\n+        if (!supportsAdd(c))\n+            return;\n+\n+        clear(c);\n+\n+        \/\/ Test empty ArrayList source\n+        ArrayList<Integer> emptySource = new ArrayList<>();\n+        check(!c.addAll(emptySource));\n+\n+        \/\/ Test non-empty ArrayList source\n+        ArrayList<Integer> arraySource = new ArrayList<>();\n+        arraySource.add(42);\n+        arraySource.add(99);\n+        check(c.addAll(arraySource));\n+        equal(new ArrayList<Integer>(c), arraySource);\n+\n+        clear(c);\n+\n+        \/\/ Test non-ArrayList source\n+        List<Integer> linkedSource = new LinkedList<>();\n+        linkedSource.add(77);\n+        check(c.addAll(linkedSource));\n+        equal(new ArrayList<Integer>(c), linkedSource);\n+\n+        \/\/ Test non-empty destination\n+        clear(c);\n+        c.add(10);\n+        c.add(20);\n+        int sizeBefore = c.size();\n+        check(c.addAll(arraySource));\n+        equal(c.size(), sizeBefore + arraySource.size());\n+        check(c.containsAll(arraySource));\n+    }\n+\n@@ -1297,0 +1332,2 @@\n+        testAddAll(c);\n+\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\n+\/**\n+ * Benchmark measuring ArrayList addAll() performance.\n+ *\n+ * Tests the performance of ArrayList.addAll() when copying from another ArrayList.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgs = { \"-XX:+UseParallelGC\", \"-Xmx3g\" })\n+public class ArrayListBulkOpsBenchmark {\n+    @Param({\"0\", \"1\", \"5\", \"75\"})\n+    int size;\n+\n+    @Param({\"ArrayList\", \"LinkedList\"})\n+    String type;\n+\n+    List<String> source;\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        switch (type) {\n+            case \"ArrayList\" -> source = new ArrayList<>(size);\n+            case \"LinkedList\" -> source = new LinkedList<>();\n+        }\n+        for (int i = 0; i < size; i++) source.add(\"key\" + i);\n+    }\n+\n+    @Benchmark\n+    public ArrayList<String> addAll() {\n+        ArrayList<String> result = new ArrayList<>(size);\n+        result.addAll(source);\n+        return result;\n+    }\n+\n+    static void poisonCallSites() {\n+        HashMap<String, String> hashMapSource = new HashMap<>();\n+        TreeSet<String> treeSetSource = new TreeSet<>();\n+        WeakHashMap<String, String> weakHashMapSource = new WeakHashMap<>();\n+        for (int i = 0; i < 75; i++) {\n+            hashMapSource.put(\"key\" + i, \"value\" + i);\n+            treeSetSource.add(\"key\" + i);\n+            weakHashMapSource.put(\"key\" + i, \"value\" + i);\n+        }\n+        \/\/ Poison ArrayList.addAll() with different Collection types\n+        for (int i = 0; i < 40_000; i++) {\n+            ArrayList<Object> temp = new ArrayList<>();\n+            temp.addAll(hashMapSource.entrySet());\n+            temp.addAll(treeSetSource);\n+            temp.addAll(weakHashMapSource.keySet());\n+        }\n+    }\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Benchmark)\n+    @Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+    @Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+    @Fork(value = 1, jvmArgs = { \"-XX:+UseParallelGC\", \"-Xmx3g\" })\n+    public static class SingletonSet {\n+        Set<String> singletonSetSource = Collections.singleton(\"key\");\n+\n+        @Param({ \"false\", \"true\" })\n+        private boolean poison;\n+\n+        @Setup(Level.Trial)\n+        public void setup() {\n+            if (poison) poisonCallSites();\n+        }\n+\n+        @Benchmark\n+        public ArrayList<String> addAllSingletonSet() {\n+            ArrayList<String> result = new ArrayList<>(1);\n+            result.addAll(singletonSetSource);\n+            return result;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArrayListBulkOpsBenchmark.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}