{"files":[{"patch":"@@ -6237,0 +6237,9 @@\n+  \/\/ As Â±2^24 is the range in which all contiguous integers can be represented by floats, special handling has to be\n+  \/\/ done to avoid losing precision by potentially rounding up when outside of this range. To avoid that, we shift the\n+  \/\/ input by 24 bits, to isolate any high bits that are set. The source is then masked with the inverse of this shift,\n+  \/\/ to remove low set bits. This removes a corresponding amount of low bits as there are set bits above position 24.\n+  \/\/ As the rounding issue only occurs when the high bits are all set to 1, this prevents the floating point representation\n+  \/\/ from overflowing while not changing the output as the high bits are kept intact.\n+  vpsrld(xtmp2, src, 24, vec_enc);\n+  vpandn(xtmp3, xtmp2, src, vec_enc);\n+\n@@ -6238,1 +6247,1 @@\n-  vcvtdq2ps(dst, src, vec_enc);\n+  vcvtdq2ps(dst, xtmp3, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +27,1 @@\n+* @bug 8297172 8331993 8349637\n@@ -41,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -43,0 +46,1 @@\n+    private static final int[] SPECIAL = { 0x01FFFFFF, 0x03FFFFFE, 0x07FFFFFC, 0x0FFFFFF8, 0x1FFFFFF0, 0x3FFFFFE0, 0xFFFFFFFF };\n@@ -59,1 +63,1 @@\n-        rng = new Random(42);\n+        rng = Utils.getRandomInstance();\n@@ -122,0 +126,38 @@\n+\n+    @Setup\n+    static Object[] setupSpecialIntArray() {\n+        int[] res = new int[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            res[i] = SPECIAL[i % SPECIAL.length];\n+        }\n+\n+        return new Object[] { res };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNT_LEADING_ZEROS_VI, \"> 0\"})\n+    @Arguments(setup = \"setupSpecialIntArray\")\n+    public Object[] testSpecialIntLeadingZeros(int[] ints) {\n+        int[] res = new int[LEN];\n+\n+        for (int i = 0; i < LEN; ++i) {\n+            res[i] = Integer.numberOfLeadingZeros(ints[i]);\n+        }\n+\n+        return new Object[] { ints, res };\n+    }\n+\n+    @Check(test = \"testSpecialIntLeadingZeros\")\n+    public void checkSpecialIntLeadingZeros(Object[] vals) {\n+        int[] in = (int[]) vals[0];\n+        int[] out = (int[]) vals[1];\n+\n+        for (int i = 0; i < LEN; ++i) {\n+            int value = Integer.numberOfLeadingZeros(in[i]);\n+\n+            if (out[i] != value) {\n+                throw new IllegalStateException(\"Expected lzcnt(\" + in[i] + \") to be \" + value + \" but got \" + out[i]);\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"}]}