{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/serviceThread.hpp\"\n@@ -498,0 +499,4 @@\n+  if (JvmtiEventController::is_execution_finished()) {\n+    now_enabled &= VM_DEATH_BIT;\n+  }\n+\n@@ -540,0 +545,4 @@\n+  if (JvmtiEventController::is_execution_finished()) {\n+    now_enabled &= VM_DEATH_BIT;\n+  }\n+\n@@ -1050,1 +1059,1 @@\n-  \/\/ events are disabled (phase has changed)\n+  \/\/ events are disabled, see JvmtiEventController::_execution_finished\n@@ -1062,0 +1071,3 @@\n+volatile bool JvmtiEventController::_execution_finished = false;\n+volatile int  JvmtiEventController::_in_callback_count = 0;\n+\n@@ -1210,0 +1222,2 @@\n+  \/\/ No new events except vm_death can be generated after this point.\n+  AtomicAccess::store(&_execution_finished, true);\n@@ -1214,1 +1228,15 @@\n-}\n+\n+  \/\/ The deferred events are already posted, so it is needed to wait until\n+  \/\/ they are actually posted on the ServiceThrea\n+  ServiceThread::clear_deferred_events_queue();\n+\n+  \/\/ Some events might be still in callback for daemons threads and ServiceThread.\n+  const double start = os::elapsedTime();\n+  const double max_wait_time = 60;\n+  while (in_callback_count() > 0) {\n+    os::naked_short_sleep(100);\n+    if (os::elapsedTime() - start > max_wait_time) {\n+      break;\n+    }\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -200,0 +200,5 @@\n+  \/\/ These fields are used to synchronize stop posting events and\n+  \/\/ wait until already executing callbacks are finished.\n+  volatile static bool _execution_finished;\n+  volatile static int   _in_callback_count;\n+\n@@ -248,0 +253,4 @@\n+  static bool is_execution_finished();\n+  static void inc_in_callback_count();\n+  static void dec_in_callback_count();\n+  static int in_callback_count();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -111,0 +111,18 @@\n+inline bool JvmtiEventController::is_execution_finished() {\n+  return AtomicAccess::load(&_execution_finished);\n+}\n+\n+inline void JvmtiEventController::inc_in_callback_count() {\n+  AtomicAccess::inc(&_in_callback_count);\n+}\n+\n+inline void JvmtiEventController::dec_in_callback_count() {\n+  AtomicAccess::dec(&_in_callback_count);\n+}\n+\n+inline int JvmtiEventController::in_callback_count() {\n+  int result = AtomicAccess::load(&_in_callback_count);\n+  assert(result >= 0, \"Should be positive\");\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.inline.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -100,1 +100,6 @@\n-    _hm(thread)  {};\n+    _hm(thread) {\n+    JvmtiEventController::inc_in_callback_count();\n+  };\n+  ~JvmtiJavaThreadEventTransition() {\n+    JvmtiEventController::dec_in_callback_count();\n+  }\n@@ -114,0 +119,1 @@\n+    JvmtiEventController::inc_in_callback_count();\n@@ -128,1 +134,1 @@\n-    if (_jthread != nullptr)\n+    if (_jthread != nullptr) {\n@@ -130,0 +136,2 @@\n+    }\n+    JvmtiEventController::dec_in_callback_count();\n@@ -133,0 +141,5 @@\n+\/\/ The JVMTI_...__BLOCK are used to ensure that vm_death is the last posted event.\n+\/\/ The callbacks are not executed after _execution_finished is set to true\n+\/\/ and the _in_callback_count contains the number of callbacks still in progress.\n+#define JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread) JvmtiJavaThreadEventTransition jet(thread); if (JvmtiEventController::is_execution_finished()) { return; }\n+#define JVMTI_EVENT_CALLBACK_BLOCK(thread) JvmtiThreadEventTransition jet(thread); if (JvmtiEventController::is_execution_finished()) { return; }\n@@ -665,1 +678,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -694,1 +707,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -744,1 +757,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -772,0 +785,5 @@\n+  \/\/ It is needed to disable event generation before setting DEAD phase and wait\n+  \/\/ until already executing events are finished.\n+  \/\/ The VM_DEATH should be the last posted event.\n+  JvmtiEventController::vm_death();\n+\n@@ -779,0 +797,1 @@\n+      \/\/ JVMTI_JAVA_EVENT_CALLBACK_BLOCK shouldn't be used here\n@@ -788,1 +807,0 @@\n-  JvmtiEventController::vm_death();\n@@ -974,1 +992,1 @@\n-    JvmtiJavaThreadEventTransition jet(_thread);\n+    JVMTI_JAVA_EVENT_CALLBACK_BLOCK(_thread)\n@@ -1186,1 +1204,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1228,1 +1246,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1369,1 +1387,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1410,1 +1428,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1453,1 +1471,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1499,1 +1517,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1547,1 +1565,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1577,1 +1595,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1613,1 +1631,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1648,1 +1666,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1683,1 +1701,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1796,1 +1814,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1836,1 +1854,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1923,1 +1941,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1950,1 +1968,1 @@\n-          JvmtiJavaThreadEventTransition jet(thread);\n+          JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -1998,1 +2016,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2086,1 +2104,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2161,1 +2179,1 @@\n-          JvmtiJavaThreadEventTransition jet(thread);\n+          JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2247,1 +2265,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2405,1 +2423,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2437,1 +2455,1 @@\n-        JvmtiJavaThreadEventTransition jet(thread);\n+        JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2534,1 +2552,1 @@\n-  JvmtiJavaThreadEventTransition jet(thread);\n+  JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2561,1 +2579,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2603,1 +2621,1 @@\n-    JvmtiJavaThreadEventTransition jet(thread);\n+    JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2687,1 +2705,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2708,1 +2726,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2729,1 +2747,1 @@\n-     JvmtiThreadEventTransition jet(thread);\n+     JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2763,1 +2781,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2797,1 +2815,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2830,1 +2848,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2864,1 +2882,1 @@\n-      JvmtiThreadEventTransition jet(thread);\n+      JVMTI_EVENT_CALLBACK_BLOCK(thread)\n@@ -2907,1 +2925,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n@@ -2945,1 +2963,1 @@\n-      JvmtiJavaThreadEventTransition jet(thread);\n+      JVMTI_JAVA_EVENT_CALLBACK_BLOCK(thread)\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":58,"deletions":40,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -191,0 +191,8 @@\n+void ServiceThread::clear_deferred_events_queue() {\n+  \/\/ All jvmti events should be already disabled before calling this method.\n+  MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  while (_jvmti_service_queue.has_events()) {\n+    _jvmti_service_queue.dequeue();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  static void clear_deferred_events_queue();\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}