{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Method;\n@@ -90,1 +91,5 @@\n-                    result = bootstrapMethod.invoke(caller, name, c);\n+                    if (bootstrapMethod.type() == CONDY_GET_STATIC_FINAL_MT) {\n+                        result = bootstrapMethod.invokeExact(caller, name, c);\n+                    } else {\n+                        result = bootstrapMethod.invoke(caller, name, c);\n+                    }\n@@ -100,1 +105,1 @@\n-                if (isStringConcatFactoryBSM(bootstrapMethod.type())) {\n+                if (bootstrapMethod.type() == SCF_MT) {\n@@ -107,1 +112,5 @@\n-                        result = bootstrapMethod.invoke(caller, name, c, info);\n+                        if (bootstrapMethod.type() == CONDY_GET_STATIC_FINAL_CLASS_MT) {\n+                            result = bootstrapMethod.invokeExact(caller, name, c, (Class<?>)info);\n+                        } else {\n+                            result = bootstrapMethod.invoke(caller, name, c, info);\n+                        }\n@@ -132,1 +141,1 @@\n-                if (isLambdaMetafactoryIndyBSM(bsmType) && argv.length == 3) {\n+                if (bsmType == LMF_INDY_MT) {\n@@ -136,5 +145,1 @@\n-                } else if (isLambdaMetafactoryCondyBSM(bsmType) && argv.length == 3) {\n-                    result = bootstrapMethod\n-                            .invokeExact(caller, name, (Class<?>)type, (MethodType)argv[0],\n-                                    (MethodHandle)argv[1], (MethodType)argv[2]);\n-                } else if (isStringConcatFactoryBSM(bsmType) && argv.length >= 1) {\n+                } else if (argv.length >= 1 && bsmType == SCF_MT) {\n@@ -145,1 +150,1 @@\n-                } else if (isLambdaMetafactoryAltMetafactoryBSM(bsmType)) {\n+                } else if (bsmType == LMF_ALT_MT) {\n@@ -148,1 +153,1 @@\n-                } else if (isObjectMethodsBootstrapBSM(bsmType)) {\n+                } else if (bsmType == OBJECT_METHODS_MT) {\n@@ -151,0 +156,6 @@\n+                } else if (bsmType == PROXY_GET_METHOD_MT) {\n+                    result = (Method)bootstrapMethod.invokeExact(caller, name, (Class<?>)type, (Class<?>)argv[0], (String)argv[1], (MethodType)argv[2]);\n+                } else if (bsmType == CONDY_GET_STATIC_FINAL_MT) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type);\n+                } else if (bsmType == CONDY_GET_STATIC_FINAL_CLASS_MT) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type, (Class<?>)argv[0]);\n@@ -246,0 +257,5 @@\n+\n+    \/**\n+     * Exact type used by the {@link java.lang.invoke.LambdaMetafactory#metafactory(\n+     * MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType)} bootstrap method.\n+     *\/\n@@ -249,0 +265,4 @@\n+    \/**\n+     * Exact type used by the {@link java.lang.invoke.LambdaMetafactory#altMetafactory(\n+     * MethodHandles.Lookup,String,MethodType,Object[])} bootstrap method.\n+     *\/\n@@ -252,9 +272,0 @@\n-    private static final MethodType OBJECT_METHODS_MT = MethodType.methodType(Object.class,\n-            Lookup.class, String.class, TypeDescriptor.class, Class.class, String.class, MethodHandle[].class);\n-\n-    private static final MethodType LMF_CONDY_MT = MethodType.methodType(Object.class,\n-            Lookup.class, String.class, Class.class, MethodType.class, MethodHandle.class, MethodType.class);\n-\n-    private static final MethodType SCF_MT = MethodType.methodType(CallSite.class,\n-            Lookup.class, String.class, MethodType.class, String.class, Object[].class);\n-\n@@ -262,3 +273,2 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup,\n-     *                 String,MethodType,String,Object...))}\n+     * Exact type used for the {@link java.lang.runtime.ObjectMethods#bootstrap(\n+     * MethodHandles.Lookup,String,TypeDescriptor,Class,String,MethodHandle[])} bootstrap method.\n@@ -266,3 +276,2 @@\n-    private static boolean isStringConcatFactoryBSM(MethodType bsmType) {\n-        return bsmType == SCF_MT;\n-    }\n+    private static final MethodType OBJECT_METHODS_MT = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, TypeDescriptor.class, Class.class, String.class, MethodHandle[].class);\n@@ -271,3 +280,1 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#metafactory(\n-     *          MethodHandles.Lookup,String,Class,MethodType,MethodHandle,MethodType)}\n+     * Exact type of the bootstrap methods generated for {@link java.lang.reflect.Proxy} classes.\n@@ -275,3 +282,2 @@\n-    private static boolean isLambdaMetafactoryCondyBSM(MethodType bsmType) {\n-        return bsmType == LMF_CONDY_MT;\n-    }\n+    private static final MethodType PROXY_GET_METHOD_MT = MethodType.methodType(Method.class,\n+            Lookup.class, String.class, Class.class, Class.class, String.class, MethodType.class);\n@@ -280,3 +286,2 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#metafactory(\n-     *          MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType)}\n+     * Exact type used of the {@link java.lang.invoke.ConstantBootstraps#getStaticFinal(Lookup, String, Class)}\n+     * bootstrap method.\n@@ -284,3 +289,2 @@\n-    private static boolean isLambdaMetafactoryIndyBSM(MethodType bsmType) {\n-        return bsmType == LMF_INDY_MT;\n-    }\n+    private static final MethodType CONDY_GET_STATIC_FINAL_MT = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, Class.class);\n@@ -289,3 +293,2 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#altMetafactory(\n-     *          MethodHandles.Lookup,String,MethodType,Object[])}\n+     * Exact type of the {@link java.lang.invoke.ConstantBootstraps#getStaticFinal(Lookup, String, Class, Class)}\n+     * bootstrap method.\n@@ -293,3 +296,2 @@\n-    private static boolean isLambdaMetafactoryAltMetafactoryBSM(MethodType bsmType) {\n-        return bsmType == LMF_ALT_MT;\n-    }\n+    private static final MethodType CONDY_GET_STATIC_FINAL_CLASS_MT = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, Class.class, Class.class);\n@@ -298,3 +300,2 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.runtime.ObjectMethods#bootstrap(\n-     *          MethodHandles.Lookup,String,TypeDescriptor,Class,String,MethodHandle[])}\n+     * Exact type of the {@link java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup,\n+     * String,MethodType,String,Object...))} bootstrap method.\n@@ -302,3 +303,2 @@\n-    private static boolean isObjectMethodsBootstrapBSM(MethodType bsmType) {\n-        return bsmType == OBJECT_METHODS_MT;\n-    }\n+    private static final MethodType SCF_MT = MethodType.methodType(CallSite.class,\n+            Lookup.class, String.class, MethodType.class, String.class, Object[].class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    public void generate100Proxies() {\n+    public int generateAndProxy100() {\n+        int hash = 0;\n@@ -55,1 +56,1 @@\n-            Proxy.newProxyInstance(new ClsLoader(), INTF, HANDLER);\n+            hash += Proxy.newProxyInstance(new ClsLoader(), INTF, HANDLER).hashCode();\n@@ -57,0 +58,1 @@\n+        return hash;\n@@ -68,1 +70,10 @@\n-            throw new UnsupportedOperationException();\n+            if (method.getName().equals(\"hashCode\")) {\n+                return 17;\n+            }\n+            if (method.getName().equals(\"equals\")) {\n+                return false;\n+            }\n+            if (method.getName().equals(\"toString\")) {\n+                return \"proxy\";\n+            }\n+            return null;\n@@ -80,1 +91,1 @@\n-        new ProxyGenBench().generate100Proxies();\n+        new ProxyGenBench().generateAndProxy100();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ProxyGenBench.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}