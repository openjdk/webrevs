{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Method;\n@@ -90,1 +91,5 @@\n-                    result = bootstrapMethod.invoke(caller, name, c);\n+                    if (bootstrapMethod.type() == CONDY_NO_ARG) {\n+                        result = bootstrapMethod.invokeExact(caller, name, c);\n+                    } else {\n+                        result = bootstrapMethod.invoke(caller, name, c);\n+                    }\n@@ -100,3 +105,2 @@\n-                if (isStringConcatFactoryBSM(bootstrapMethod.type())) {\n-                    result = (CallSite)bootstrapMethod\n-                            .invokeExact(caller, name, (MethodType)type,\n+                if (bootstrapMethod.type() == SCF_MT) {\n+                    result = (CallSite)bootstrapMethod.invokeExact(caller, name, (MethodType)type,\n@@ -104,0 +108,3 @@\n+                } else if (bootstrapMethod.type() == CONDY_INVOKE) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type,\n+                                    (MethodHandle)info, new Object[0]);\n@@ -107,1 +114,5 @@\n-                        result = bootstrapMethod.invoke(caller, name, c, info);\n+                        if (bootstrapMethod.type() == CONDY_EXTRA_CLASS) {\n+                            result = bootstrapMethod.invokeExact(caller, name, c, (Class<?>)info);\n+                        } else {\n+                            result = bootstrapMethod.invoke(caller, name, c, info);\n+                        }\n@@ -132,1 +143,1 @@\n-                if (isLambdaMetafactoryIndyBSM(bsmType) && argv.length == 3) {\n+                if (bsmType == LMF_INDY_MT) {\n@@ -136,6 +147,5 @@\n-                } else if (isLambdaMetafactoryCondyBSM(bsmType) && argv.length == 3) {\n-                    result = bootstrapMethod\n-                            .invokeExact(caller, name, (Class<?>)type, (MethodType)argv[0],\n-                                    (MethodHandle)argv[1], (MethodType)argv[2]);\n-                } else if (isStringConcatFactoryBSM(bsmType) && argv.length >= 1) {\n-                    String recipe = (String)argv[0];\n+                } else if (bsmType == SCF_MT) {\n+                    Object[] shiftedArgs = Arrays.copyOfRange(argv, 1, argv.length);\n+                    maybeReBoxElements(shiftedArgs);\n+                    result = (CallSite)bootstrapMethod.invokeExact(caller, name, (MethodType)type, (String)argv[0], shiftedArgs);\n+                } else if (bsmType == CONDY_INVOKE) {\n@@ -144,2 +154,2 @@\n-                    result = (CallSite)bootstrapMethod.invokeExact(caller, name, (MethodType)type, recipe, shiftedArgs);\n-                } else if (isLambdaMetafactoryAltMetafactoryBSM(bsmType)) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type, (MethodHandle)argv[0], shiftedArgs);\n+                } else if (bsmType == LMF_ALT_MT) {\n@@ -148,1 +158,1 @@\n-                } else if (isObjectMethodsBootstrapBSM(bsmType)) {\n+                } else if (bsmType == OBJECT_METHODS_MT) {\n@@ -151,0 +161,6 @@\n+                } else if (bsmType == PROXY_GET_METHOD_MT) {\n+                    result = (Method)bootstrapMethod.invokeExact(caller, name, (Class<?>)type, (Class<?>)argv[0], (String)argv[1], (MethodType)argv[2]);\n+                } else if (bsmType == CONDY_NO_ARG) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type);\n+                } else if (bsmType == CONDY_EXTRA_CLASS) {\n+                    result = bootstrapMethod.invokeExact(caller, name, (Class<?>)type, (Class<?>)argv[0]);\n@@ -167,1 +183,1 @@\n-                            case 0 -> bootstrapMethod.invoke(caller, name, mt);\n+                            case 0 -> bootstrapMethod.invokeBasic(caller, name, mt);\n@@ -246,0 +262,5 @@\n+\n+    \/**\n+     * Exact type used by the {@link java.lang.invoke.LambdaMetafactory#metafactory(\n+     * MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType)} bootstrap method.\n+     *\/\n@@ -249,0 +270,4 @@\n+    \/**\n+     * Exact type used by the {@link java.lang.invoke.LambdaMetafactory#altMetafactory(\n+     * MethodHandles.Lookup,String,MethodType,Object[])} bootstrap method.\n+     *\/\n@@ -252,0 +277,4 @@\n+    \/**\n+     * Exact type used for the {@link java.lang.runtime.ObjectMethods#bootstrap(\n+     * MethodHandles.Lookup,String,TypeDescriptor,Class,String,MethodHandle[])} bootstrap method.\n+     *\/\n@@ -255,6 +284,0 @@\n-    private static final MethodType LMF_CONDY_MT = MethodType.methodType(Object.class,\n-            Lookup.class, String.class, Class.class, MethodType.class, MethodHandle.class, MethodType.class);\n-\n-    private static final MethodType SCF_MT = MethodType.methodType(CallSite.class,\n-            Lookup.class, String.class, MethodType.class, String.class, Object[].class);\n-\n@@ -262,3 +285,1 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup,\n-     *                 String,MethodType,String,Object...))}\n+     * Exact type of the bootstrap methods generated for {@link java.lang.reflect.Proxy} classes.\n@@ -266,3 +287,2 @@\n-    private static boolean isStringConcatFactoryBSM(MethodType bsmType) {\n-        return bsmType == SCF_MT;\n-    }\n+    private static final MethodType PROXY_GET_METHOD_MT = MethodType.methodType(Method.class,\n+            Lookup.class, String.class, Class.class, Class.class, String.class, MethodType.class);\n@@ -271,3 +291,3 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#metafactory(\n-     *          MethodHandles.Lookup,String,Class,MethodType,MethodHandle,MethodType)}\n+     * Exact type of for example\n+     * {@link java.lang.invoke.ConstantBootstraps#getStaticFinal(Lookup, String, Class)}\n+     * bootstrap method.\n@@ -275,3 +295,2 @@\n-    private static boolean isLambdaMetafactoryCondyBSM(MethodType bsmType) {\n-        return bsmType == LMF_CONDY_MT;\n-    }\n+    private static final MethodType CONDY_NO_ARG = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, Class.class);\n@@ -280,3 +299,3 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#metafactory(\n-     *          MethodHandles.Lookup,String,MethodType,MethodType,MethodHandle,MethodType)}\n+     * Exact type of for example the\n+     * {@link java.lang.invoke.ConstantBootstraps#getStaticFinal(Lookup, String, Class, Class)}\n+     * bootstrap method.\n@@ -284,3 +303,2 @@\n-    private static boolean isLambdaMetafactoryIndyBSM(MethodType bsmType) {\n-        return bsmType == LMF_INDY_MT;\n-    }\n+    private static final MethodType CONDY_EXTRA_CLASS = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, Class.class, Class.class);\n@@ -289,3 +307,3 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#altMetafactory(\n-     *          MethodHandles.Lookup,String,MethodType,Object[])}\n+     * Exact type of the\n+     * {@link java.lang.invoke.ConstantBootstraps#invoke(Lookup, String, Class, MethodHandle, Object...)}\n+     * bootstrap method.\n@@ -293,3 +311,2 @@\n-    private static boolean isLambdaMetafactoryAltMetafactoryBSM(MethodType bsmType) {\n-        return bsmType == LMF_ALT_MT;\n-    }\n+    private static final MethodType CONDY_INVOKE = MethodType.methodType(Object.class,\n+            Lookup.class, String.class, Class.class, MethodHandle.class, Object[].class);\n@@ -298,3 +315,2 @@\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.runtime.ObjectMethods#bootstrap(\n-     *          MethodHandles.Lookup,String,TypeDescriptor,Class,String,MethodHandle[])}\n+     * Exact type of the {@link java.lang.invoke.StringConcatFactory#makeConcatWithConstants(MethodHandles.Lookup,\n+     * String,MethodType,String,Object...))} bootstrap method.\n@@ -302,3 +318,2 @@\n-    private static boolean isObjectMethodsBootstrapBSM(MethodType bsmType) {\n-        return bsmType == OBJECT_METHODS_MT;\n-    }\n+    private static final MethodType SCF_MT = MethodType.methodType(CallSite.class,\n+            Lookup.class, String.class, MethodType.class, String.class, Object[].class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":67,"deletions":52,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    public void generate100Proxies() {\n+    public int generateAndProxy100() {\n+        int hash = 0;\n@@ -55,1 +56,1 @@\n-            Proxy.newProxyInstance(new ClsLoader(), INTF, HANDLER);\n+            hash += Proxy.newProxyInstance(new ClsLoader(), INTF, HANDLER).hashCode();\n@@ -57,0 +58,1 @@\n+        return hash;\n@@ -68,1 +70,10 @@\n-            throw new UnsupportedOperationException();\n+            if (method.getName().equals(\"hashCode\")) {\n+                return 17;\n+            }\n+            if (method.getName().equals(\"equals\")) {\n+                return false;\n+            }\n+            if (method.getName().equals(\"toString\")) {\n+                return \"proxy\";\n+            }\n+            return null;\n@@ -80,1 +91,1 @@\n-        new ProxyGenBench().generate100Proxies();\n+        new ProxyGenBench().generateAndProxy100();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ProxyGenBench.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}