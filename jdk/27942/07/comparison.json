{"files":[{"patch":"@@ -334,0 +334,1 @@\n+  static mask unsigned_mask(mask btm) { return mask(btm | unsigned_compare); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1701,1 +1701,3 @@\n-  if (cmp0->Opcode() == Op_CmpF || cmp0->Opcode() == Op_CmpD) {\n+  switch (cmp0->Opcode()) {\n+  case Op_CmpF:\n+  case Op_CmpD:\n@@ -1745,1 +1747,18 @@\n-  }\n+    break;\n+  case Op_CmpU:\n+  case Op_CmpUL:\n+    \/\/ When we have CmpU->Bool, the mask of the Bool has no unsigned-ness information,\n+    \/\/ but the mask is implicitly unsigned only because of the CmpU. Since we will replace\n+    \/\/ the CmpU->Bool with a single VectorMaskCmp, we need to now make the unsigned-ness\n+    \/\/ explicit.\n+    mask = BoolTest::unsigned_mask(mask);\n+    break;\n+  case Op_CmpI:\n+  case Op_CmpL:\n+    \/\/ The mask of signed int\/long scalar comparisons has the same semantics\n+    \/\/ as the mask for vector elementwise int\/long comparison with VectorMaskCmp.\n+    break;\n+  default:\n+    \/\/ Other Cmp ops are not expected to get here.\n+    ShouldNotReachHere();\n+  } \/\/ switch\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+    \/\/ Signed comparison: I\/L\n@@ -180,0 +181,138 @@\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/    I for I\n+    private int cmoveUIGTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveUIGEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveUILTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveUILEforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for L\n+    private long cmoveUIGTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveUILTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveUILEforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for F\n+    private float cmoveUIGTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveUILTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveUILEforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    I for D\n+    private double cmoveUIGTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveUILTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveUILEforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for I\n+    private int cmoveULGTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveULGEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private int cmoveULLTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private int cmoveULLEforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for L\n+    private long cmoveULGTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveULGEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private long cmoveULLTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private long cmoveULLEforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for F\n+    private float cmoveULGTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveULGEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private float cmoveULLTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private float cmoveULLEforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/    L for D\n+    private double cmoveULGTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveULGEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) >= 0 ? c : d;\n+    }\n+\n+    private double cmoveULLTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) < 0 ? c : d;\n+    }\n+\n+    private double cmoveULLEforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) <= 0 ? c : d;\n+    }\n+\n+    \/\/ Float comparison\n@@ -598,0 +737,1 @@\n+    \/\/ Signed comparison: I\/L\n@@ -697,0 +837,405 @@\n+    \/\/ Unsigned comparison: I\/L\n+    \/\/     I fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo F\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUILEforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     I fo D\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUILEforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo I\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLEforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLEforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo F\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULLEforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n+    \/\/     L fo D\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) >= 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) < 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULLEforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) <= 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -980,1 +1525,2 @@\n-    @Run(test = {\"testCMoveIGTforI\",\n+    @Run(test = {\/\/ Signed\n+                 \"testCMoveIGTforI\",\n@@ -988,0 +1534,42 @@\n+                 \/\/ Unsigned\n+                 \/\/     I for I\n+                 \"testCMoveUIGTforI\",\n+                 \"testCMoveUIGEforI\",\n+                 \"testCMoveUILTforI\",\n+                 \"testCMoveUILEforI\",\n+                 \/\/     I for L\n+                 \"testCMoveUIGTforL\",\n+                 \"testCMoveUIGEforL\",\n+                 \"testCMoveUILTforL\",\n+                 \"testCMoveUILEforL\",\n+                 \/\/     I for F\n+                 \"testCMoveUIGTforF\",\n+                 \"testCMoveUIGEforF\",\n+                 \"testCMoveUILTforF\",\n+                 \"testCMoveUILEforF\",\n+                 \/\/     I for D\n+                 \"testCMoveUIGTforD\",\n+                 \"testCMoveUIGEforD\",\n+                 \"testCMoveUILTforD\",\n+                 \"testCMoveUILEforD\",\n+                 \/\/     L for I\n+                 \"testCMoveULGTforI\",\n+                 \"testCMoveULGEforI\",\n+                 \"testCMoveULLTforI\",\n+                 \"testCMoveULLEforI\",\n+                 \/\/     L for L\n+                 \"testCMoveULGTforL\",\n+                 \"testCMoveULGEforL\",\n+                 \"testCMoveULLTforL\",\n+                 \"testCMoveULLEforL\",\n+                 \/\/     L for F\n+                 \"testCMoveULGTforF\",\n+                 \"testCMoveULGEforF\",\n+                 \"testCMoveULLTforF\",\n+                 \"testCMoveULLEforF\",\n+                 \/\/     L for D\n+                 \"testCMoveULGTforD\",\n+                 \"testCMoveULGEforD\",\n+                 \"testCMoveULLTforD\",\n+                 \"testCMoveULLEforD\",\n+                 \/\/ Float\n@@ -1037,0 +1625,1 @@\n+        \/\/ Signed\n@@ -1077,0 +1666,170 @@\n+        \/\/ Unsigned\n+        \/\/     I for I\n+        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUILEforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUILEforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     I for L\n+        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUILEforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUILEforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     I for F\n+        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUILEforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUILEforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     I for D\n+        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUIGEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveUILEforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUILEforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/     L for I\n+        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULLEforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULLEforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        \/\/     L for L\n+        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULLEforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULLEforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        \/\/     L for F\n+        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULLEforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULLEforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        \/\/     L for D\n+        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULLEforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULLEforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Float\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":760,"deletions":1,"binary":false,"changes":761,"status":"modified"}]}