{"files":[{"patch":"@@ -334,0 +334,1 @@\n+  static mask unsigned_mask(mask btm) { return mask(btm | unsigned_compare); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1701,1 +1701,3 @@\n-  if (cmp0->Opcode() == Op_CmpF || cmp0->Opcode() == Op_CmpD) {\n+  switch (cmp0->Opcode()) {\n+  case Op_CmpF:\n+  case Op_CmpD: {\n@@ -1745,1 +1747,15 @@\n-  }\n+    break;\n+  }\n+  case Op_CmpU:\n+  case Op_CmpUL:\n+    \/\/ Carry unsigned-ness information from CmpUxx to VTransformBoolTest,\n+    \/\/ which will be passed to e.g. VectorMaskCmp.\n+    mask = BoolTest::unsigned_mask(mask);\n+    break;\n+  case Op_CmpI:\n+  case Op_CmpL:\n+    break;\n+  default:\n+    \/\/ Other Cmp ops are not expected to get here.\n+    ShouldNotReachHere();\n+  } \/\/ switch\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+    \/\/ Signed comparison: I\/L\n@@ -180,0 +181,34 @@\n+    \/\/ Unsigned comparison: I\/L\n+    private int cmoveUIGTforI(int a, int b, int c, int d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveUIGTforL(int a, int b, long c, long d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveUIGTforF(int a, int b, float c, float d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveUIGTforD(int a, int b, double c, double d) {\n+        return Integer.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private int cmoveULGTforI(long a, long b, int c, int d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private long cmoveULGTforL(long a, long b, long c, long d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private float cmoveULGTforF(long a, long b, float c, float d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    private double cmoveULGTforD(long a, long b, double c, double d) {\n+        return Long.compareUnsigned(a, b) > 0 ? c : d;\n+    }\n+\n+    \/\/ Float comparison\n@@ -598,0 +633,1 @@\n+    \/\/ Signed comparison: I\/L\n@@ -697,0 +733,100 @@\n+    \/\/ Unsigned comparison: I\/L\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforI(int[] a, int[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforL(int[] a, int[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.LOAD_VECTOR_F,     IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_I, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.VECTOR_BLEND_F,    IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveUIGTforF(int[] a, int[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveUIGTforD(int[] a, int[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Integer.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforI(long[] a, long[] b, int[] c, int[] d, int[] r, int[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            int cc = c[i];\n+            int dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforL(long[] a, long[] b, long[] c, long[] d, long[] r, long[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            long cc = c[i];\n+            long dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    private static void testCMoveULGTforF(long[] a, long[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.LOAD_VECTOR_D,     IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_MASK_CMP_L, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.VECTOR_BLEND_D,    IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Requires avx2, else L is restricted to 16 byte, and D has 32. That leads to a vector elements mismatch of 2 to 4.\n+    private static void testCMoveULGTforD(long[] a, long[] b, double[] c, double[] d, double[] r, double[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            double cc = c[i];\n+            double dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = Long.compareUnsigned(a[i], b[i]) > 0 ? cc : dd;\n+        }\n+    }\n+\n@@ -988,0 +1124,8 @@\n+                 \"testCMoveUIGTforI\",\n+                 \"testCMoveUIGTforL\",\n+                 \"testCMoveUIGTforF\",\n+                 \"testCMoveUIGTforD\",\n+                 \"testCMoveULGTforI\",\n+                 \"testCMoveULGTforL\",\n+                 \"testCMoveULGTforF\",\n+                 \"testCMoveULGTforD\",\n@@ -1037,0 +1181,1 @@\n+        \/\/ Signed\n@@ -1077,0 +1222,42 @@\n+        \/\/ Unsigned\n+        testCMoveUIGTforI(aI, bI, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveUIGTforI(aI[i], bI[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveUIGTforL(aI, bI, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveUIGTforL(aI[i], bI[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveUIGTforF(aI, bI, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveUIGTforF(aI[i], bI[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveUIGTforD(aI, bI, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveUIGTforD(aI[i], bI[i], cD[i], dD[i]));\n+        }\n+\n+        testCMoveULGTforI(aL, bL, cI, dI, rI, rI);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rI[i], cmoveULGTforI(aL[i], bL[i], cI[i], dI[i]));\n+        }\n+\n+        testCMoveULGTforL(aL, bL, cL, dL, rL, rL);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rL[i], cmoveULGTforL(aL[i], bL[i], cL[i], dL[i]));\n+        }\n+\n+        testCMoveULGTforF(aL, bL, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveULGTforF(aL[i], bL[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveULGTforD(aL, bL, cD, dD, rD, rD);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rD[i], cmoveULGTforD(aL[i], bL[i], cD[i], dD[i]));\n+        }\n+\n+        \/\/ Float\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"modified"}]}