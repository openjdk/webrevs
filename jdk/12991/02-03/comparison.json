{"files":[{"patch":"@@ -26,3 +26,2 @@\n- * @summary Verifies that ZipFile rejects ZIP files which CEN size does not fit in a Java byte array\n- * @requires (sun.arch.data.model == \"64\" & os.maxMemory > 8g)\n- * @run testng\/manual\/othervm -Xmx8g CenSizeTooLarge\n+ * @summary Verify that ZipFile rejects a ZIP with a CEN size which does not fit in a Java byte array\n+ * @run testng\/manual CenSizeTooLarge\n@@ -38,0 +37,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n@@ -48,1 +49,23 @@\n-    private static int MAX_CEN_SIZE = Integer.MAX_VALUE - ZipFile.ENDHDR - 1;\n+    static final int MAX_CEN_SIZE = Integer.MAX_VALUE - ZipFile.ENDHDR - 1;\n+\n+    \/\/ Maximum size (unsigned short) of an extra field allowed by the standard\n+    static final int MAX_EXTRA_FIELD_SIZE = 2 * Short.MAX_VALUE;\n+\n+    \/\/ Data size (unsigned short)\n+    \/\/ Field size minus the leading header 'tag' and 'data size' fields (2 bytes each)\n+    static final short MAX_DATA_SIZE = (short) ((MAX_EXTRA_FIELD_SIZE - 2 * Short.BYTES) & 0xFFFF);\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ Entry names produced in this test are fixed-length\n+    public static final int NAME_LENGTH = 10;\n+\n+    \/\/ Use a shared LocalDataTime on all entries to save processing time\n+    static final LocalDateTime TIME_LOCAL = LocalDateTime.now();\n+\n+    \/\/ The size of one CEN header, including the name and the extra field\n+    static final int CEN_HEADER_SIZE = ZipFile.CENHDR + NAME_LENGTH + MAX_EXTRA_FIELD_SIZE;\n+\n+    \/\/ The number of entries needed to exceed the MAX_CEN_SIZE\n+    static final int NUM_ENTRIES = (MAX_CEN_SIZE \/ CEN_HEADER_SIZE) + 1;\n@@ -62,3 +85,4 @@\n-            \/\/ Creating the LocalDataTime once allows faster processing\n-            LocalDateTime time = LocalDateTime.now();\n-            long cenSize = 0;\n+\n+            \/\/ Keep track of entries so we can update extra data before the CEN is written\n+            ZipEntry[] entries = new ZipEntry[NUM_ENTRIES];\n+\n@@ -66,1 +90,2 @@\n-            for (int i = 0; cenSize < MAX_CEN_SIZE; i++) {\n+            for (int i = 0; i < NUM_ENTRIES; i++) {\n+                \/\/ Create a fixed-length name for the entry\n@@ -68,1 +93,5 @@\n-                ZipEntry entry = new ZipEntry(name);\n+                name = \"0\".repeat(NAME_LENGTH - name.length()) + name;\n+\n+                \/\/ Create and track the entry\n+                ZipEntry entry = entries[i] = new ZipEntry(name);\n+\n@@ -73,1 +102,5 @@\n-                entry.setTimeLocal(time);\n+\n+                \/\/ Set the time\/date field for faster processing\n+                entry.setTimeLocal(TIME_LOCAL);\n+\n+                \/\/ Add the entry\n@@ -75,2 +108,9 @@\n-                \/\/ Calculate current cenSize\n-                cenSize += ZipFile.CENHDR + name.length();\n+\n+            }\n+            \/\/ Finish writing the last entry\n+            zip.closeEntry();\n+\n+            \/\/ Before the CEN headers are written, set the extra data on each entry\n+            byte[] extra = makeLargeExtraField();\n+            for (ZipEntry entry : entries) {\n+                entry.setExtra(extra);\n@@ -86,1 +126,1 @@\n-    public void test() {\n+    public void centralDirectoryTooLargeToFitInByteArray() {\n@@ -90,0 +130,24 @@\n+\n+    \/**\n+     * We can reduce the number of written CEN headers by making each CEN header maximally large.\n+     * We do this by adding the extra field produced by this method to each CEN header.\n+     * <p>\n+     * The structure of an extra field is as follows:\n+     * <p>\n+     * Header ID  (Two bytes, describes the type of the field, also called 'tag')\n+     * Data Size  (Two byte short)\n+     * Data Block (Contents depend on field type)\n+     *\/\n+    private byte[] makeLargeExtraField() {\n+        \/\/ Make a maximally sized extra field\n+        byte[] extra = new byte[MAX_EXTRA_FIELD_SIZE];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(extra).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ We use the 'unknown' tag, specifield in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort(MAX_DATA_SIZE);\n+        return extra;\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":77,"deletions":13,"binary":false,"changes":90,"status":"modified"}]}