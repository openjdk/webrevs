{"files":[{"patch":"@@ -116,2 +116,2 @@\n-size_t G1ParScanThreadState::flush_stats(size_t* surviving_young_words, uint num_workers) {\n-  _rdc_local_qset.flush();\n+size_t G1ParScanThreadState::flush_stats(size_t* surviving_young_words, uint num_workers, BufferNodeList* rdc_buffers) {\n+  *rdc_buffers = _rdc_local_qset.flush();\n@@ -124,1 +124,1 @@\n-     _g1h->gc_tracer_stw()->report_evacuation_failed(_evacuation_failed_info);\n+    _g1h->gc_tracer_stw()->report_evacuation_failed(_evacuation_failed_info);\n@@ -596,1 +596,0 @@\n-\n@@ -607,1 +606,1 @@\n-    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _num_workers) * HeapWordSize;\n+    size_t copied_bytes = pss->flush_stats(_surviving_young_words_total, _num_workers, &_rdc_buffers[worker_id]) * HeapWordSize;\n@@ -709,0 +708,1 @@\n+    _rdc_buffers(NEW_C_HEAP_ARRAY(BufferNodeList, num_workers, mtGC)),\n@@ -716,0 +716,1 @@\n+    _rdc_buffers[i] = BufferNodeList();\n@@ -724,0 +725,1 @@\n+  FREE_C_HEAP_ARRAY(BufferNodeList, _rdc_buffers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  size_t flush_stats(size_t* surviving_young_words, uint num_workers);\n+  size_t flush_stats(size_t* surviving_young_words, uint num_workers, BufferNodeList* buffer_log);\n@@ -250,0 +250,1 @@\n+  BufferNodeList* _rdc_buffers;\n@@ -263,0 +264,1 @@\n+  BufferNodeList* rdc_buffers() { return _rdc_buffers; }\n@@ -269,0 +271,1 @@\n+  uint num_workers() const { return _num_workers; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-void G1RedirtyCardsLocalQueueSet::flush() {\n+BufferNodeList G1RedirtyCardsLocalQueueSet::flush() {\n@@ -70,0 +70,1 @@\n+  BufferNodeList cur_buffers = _buffers;\n@@ -72,0 +73,1 @@\n+  return cur_buffers;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-  void flush();\n+  \/\/ Returns the flushed BufferNodeList which is later used\n+  \/\/ as a shortcut into the shared qset.\n+  BufferNodeList flush();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -594,1 +594,2 @@\n-  BufferNode* volatile _nodes;\n+  BufferNodeList* _rdc_buffers;\n+  uint _num_buffer_lists;\n@@ -598,1 +599,1 @@\n-  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions) :\n+  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions, BufferNodeList* rdc_buffers, uint num_buffer_lists) :\n@@ -601,1 +602,2 @@\n-    _nodes(rdcqs->all_completed_buffers()),\n+    _rdc_buffers(rdc_buffers),\n+    _num_buffer_lists(num_buffer_lists),\n@@ -617,7 +619,17 @@\n-    BufferNode* next = Atomic::load(&_nodes);\n-    while (next != nullptr) {\n-      BufferNode* node = next;\n-      next = Atomic::cmpxchg(&_nodes, node, node->next());\n-      if (next == node) {\n-        cl.apply_to_buffer(node, worker_id);\n-        next = node->next();\n+\n+    uint start = worker_id;\n+    for (uint i = 0; i < _num_buffer_lists; i++) {\n+      uint index = (start + i) % _num_buffer_lists;\n+\n+      BufferNode* next = Atomic::load(&_rdc_buffers[index]._head);\n+      BufferNode* tail = Atomic::load(&_rdc_buffers[index]._tail);\n+\n+      while (next != nullptr) {\n+        BufferNode* node = next;\n+        next = Atomic::cmpxchg(&_rdc_buffers[index]._head, node, (node != tail ) ? node->next() : nullptr);\n+        if (next == node) {\n+          cl.apply_to_buffer(node, worker_id);\n+          next = (node != tail ) ? node->next() : nullptr;\n+        } else {\n+          break; \/\/ If there is contention, move to the next BufferNodeList\n+        }\n@@ -973,1 +985,4 @@\n-  add_parallel_task(new RedirtyLoggedCardsTask(per_thread_states->rdcqs(), evac_failure_regions));\n+  add_parallel_task(new RedirtyLoggedCardsTask(per_thread_states->rdcqs(),\n+                    evac_failure_regions, per_thread_states->rdc_buffers(),\n+                    per_thread_states->num_workers()));\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"}]}