{"files":[{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2014 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n-#include \"utilities\/compilerWarnings.hpp\"\n-\n-\/\/ put OS-includes here\n-# include <pthread.h>\n-\n-\/\/\n-\/\/ See threadCritical.hpp for details of this class.\n-\/\/\n-\n-static pthread_t             tc_owner = 0;\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED\n-static pthread_mutex_t       tc_mutex = PTHREAD_MUTEX_INITIALIZER;\n-PRAGMA_DIAG_POP\n-\n-static int                   tc_count = 0;\n-\n-ThreadCritical::ThreadCritical() {\n-  pthread_t self = pthread_self();\n-  if (self != tc_owner) {\n-    int ret = pthread_mutex_lock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_lock()\");\n-    assert(tc_count == 0, \"Lock acquired with illegal reentry count.\");\n-    tc_owner = self;\n-  }\n-  tc_count++;\n-}\n-\n-ThreadCritical::~ThreadCritical() {\n-  assert(tc_owner == pthread_self(), \"must have correct owner\");\n-  assert(tc_count > 0, \"must have correct count\");\n-\n-  tc_count--;\n-  if (tc_count == 0) {\n-    tc_owner = 0;\n-    int ret = pthread_mutex_unlock(&tc_mutex);\n-    guarantee(ret == 0, \"fatal error with pthread_mutex_unlock()\");\n-  }\n-}\n","filename":"src\/hotspot\/os\/posix\/threadCritical_posix.cpp","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -66,1 +66,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n-\n-\/\/ OS-includes here\n-# include <windows.h>\n-# include <winbase.h>\n-\n-\/\/\n-\/\/ See threadCritical.hpp for details of this class.\n-\/\/\n-\n-static INIT_ONCE initialized = INIT_ONCE_STATIC_INIT;\n-static int lock_count = 0;\n-static HANDLE lock_event;\n-static DWORD lock_owner = 0;\n-\n-\/\/\n-\/\/ Note that Microsoft's critical region code contains a race\n-\/\/ condition, and is not suitable for use. A thread holding the\n-\/\/ critical section cannot safely suspend a thread attempting\n-\/\/ to enter the critical region. The failure mode is that both\n-\/\/ threads are permanently suspended.\n-\/\/\n-\/\/ I experiemented with the use of ordinary windows mutex objects\n-\/\/ and found them ~30 times slower than the critical region code.\n-\/\/\n-\n-static BOOL WINAPI initialize(PINIT_ONCE InitOnce, PVOID Parameter, PVOID *Context) {\n-  lock_event = CreateEvent(nullptr, false, true, nullptr);\n-  assert(lock_event != nullptr, \"unexpected return value from CreateEvent\");\n-  return true;\n-}\n-\n-ThreadCritical::ThreadCritical() {\n-  InitOnceExecuteOnce(&initialized, &initialize, nullptr, nullptr);\n-\n-  DWORD current_thread = GetCurrentThreadId();\n-  if (lock_owner != current_thread) {\n-    \/\/ Grab the lock before doing anything.\n-    DWORD ret = WaitForSingleObject(lock_event,  INFINITE);\n-    assert(ret != WAIT_FAILED,   \"WaitForSingleObject failed with error code: %lu\", GetLastError());\n-    assert(ret == WAIT_OBJECT_0, \"WaitForSingleObject failed with return value: %lu\", ret);\n-    lock_owner = current_thread;\n-  }\n-  \/\/ Atomicity isn't required. Bump the recursion count.\n-  lock_count++;\n-}\n-\n-ThreadCritical::~ThreadCritical() {\n-  assert(lock_owner == GetCurrentThreadId(), \"unlock attempt by wrong thread\");\n-  assert(lock_count >= 0, \"Attempt to unlock when already unlocked\");\n-\n-  lock_count--;\n-  if (lock_count == 0) {\n-    \/\/ We're going to unlock\n-    lock_owner = 0;\n-    \/\/ No lost wakeups, lock_event stays signaled until reset.\n-    DWORD ret = SetEvent(lock_event);\n-    assert(ret != 0, \"unexpected return value from SetEvent\");\n-  }\n-}\n","filename":"src\/hotspot\/os\/windows\/threadCritical_windows.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -72,1 +72,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -40,0 +39,23 @@\n+\/\/ One global static mutex for chunk pools.\n+\/\/ It is used very early in the vm initialization, in allocation\n+\/\/ code and other areas.  For many calls, the current thread has not\n+\/\/ been created so we cannot use Mutex.\n+static PlatformMutex* _global_chunk_pool_mutex = nullptr;\n+static int _recursion_count = 0;\n+\n+void Arena::initialize_chunk_pool() {\n+  _global_chunk_pool_mutex = new PlatformMutex();\n+}\n+\n+ChunkPoolLocker::ChunkPoolLocker() {\n+  assert(_global_chunk_pool_mutex != nullptr, \"must be initialized\");\n+  _global_chunk_pool_mutex->lock();\n+  assert(_recursion_count == 0, \"not recursive\");\n+  _recursion_count++;\n+};\n+\n+ChunkPoolLocker::~ChunkPoolLocker() {\n+  _recursion_count--;\n+  _global_chunk_pool_mutex->unlock();\n+};\n+\n@@ -71,1 +93,1 @@\n-    ThreadCritical tc;\n+    ChunkPoolLocker lock;\n@@ -80,1 +102,1 @@\n-    ThreadCritical tc;\n+    ChunkPoolLocker lock;\n@@ -87,1 +109,1 @@\n-    \/\/ Free all chunks while in ThreadCritical lock\n+    \/\/ Free all chunks with ChunkPoolLocker lock\n@@ -89,1 +111,1 @@\n-    ThreadCritical tc;\n+    ChunkPoolLocker lock;\n@@ -201,1 +223,2 @@\n-    ThreadCritical tc;  \/\/ Free chunks under TC lock so that NMT adjustment is stable.\n+    \/\/ Free chunks under a lock so that NMT adjustment is stable.\n+    ChunkPoolLocker lock;\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+class ChunkPoolLocker : public StackObj {\n+ public:\n+  ChunkPoolLocker();\n+  ~ChunkPoolLocker();\n+};\n@@ -153,0 +158,2 @@\n+  static void initialize_chunk_pool();\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -64,1 +65,1 @@\n-  \/\/ Use ThreadCritical to make sure that mtChunks don't get deallocated while the\n+  \/\/ Use lock to make sure that mtChunks don't get deallocated while the\n@@ -67,1 +68,1 @@\n-  ThreadCritical tc;\n+  ChunkPoolLocker lock;\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-      \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent NMT deadlocks (ThreadCritical).\n+      \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent NMT deadlocks.\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -55,1 +55,2 @@\n-  \/\/ Thread critical needed keep values in sync, total area size\n+  MallocMemorySnapshot* ms;\n+  \/\/ Lock needed to keep values in sync, total area size\n@@ -57,2 +58,4 @@\n-  ThreadCritical tc;\n-  const MallocMemorySnapshot* ms = MallocMemorySummary::as_snapshot();\n+  {\n+    ChunkPoolLocker lock;\n+    ms = MallocMemorySummary::as_snapshot();\n+  }\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_THREADCRITICAL_HPP\n-#define SHARE_RUNTIME_THREADCRITICAL_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-\n-\/\/ ThreadCritical is used to protect short non-blocking critical sections.\n-\/\/ This class must use no vm facilities that require initialization.\n-\/\/ It is used very early in the vm's initialization, in allocation\n-\/\/ code and other areas. ThreadCritical regions are reentrant.\n-\/\/\n-\/\/ Due to race conditions during vm exit, some of the os level\n-\/\/ synchronization primitives may not be deallocated at exit. It\n-\/\/ is a good plan to implement the platform dependent sections of\n-\/\/ code with resources that are recoverable during process\n-\/\/ cleanup by the os. Calling the initialize method before use\n-\/\/ is also problematic, it is best to use preinitialized primitives\n-\/\/ if possible. As an example:\n-\/\/\n-\/\/ mutex_t  mp  =  DEFAULTMUTEX;\n-\/\/\n-\/\/ Also note that this class is declared as a StackObj to enforce\n-\/\/ block structured short locks. It cannot be declared a ResourceObj\n-\/\/ or CHeapObj, due to initialization issues.\n-\n-class ThreadCritical : public StackObj {\n- public:\n-  ThreadCritical();\n-  ~ThreadCritical();\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_THREADCRITICAL_HPP\n","filename":"src\/hotspot\/share\/runtime\/threadCritical.hpp","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -462,0 +462,3 @@\n+  \/\/ Initialize memory pools\n+  Arena::initialize_chunk_pool();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}