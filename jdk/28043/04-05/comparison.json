{"files":[{"patch":"@@ -2019,1 +2019,1 @@\n-    boolean bytesCompatible(Charset charset) {\n+    boolean bytesCompatible(Charset charset, int srcIndex, int numChars) {\n@@ -2024,1 +2024,1 @@\n-                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+                return !StringCoding.hasNegatives(value, srcIndex, numChars); \/\/ ok, if ASCII-compatible\n@@ -2030,2 +2030,2 @@\n-    void copyToSegmentRaw(MemorySegment segment, long offset) {\n-        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    void copyToSegmentRaw(MemorySegment segment, long offset, int srcIndex, int numChars) {\n+        MemorySegment.copy(value, srcIndex, segment, ValueLayout.JAVA_BYTE, offset, numChars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2318,2 +2318,2 @@\n-            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-                string.copyToSegmentRaw(segment, offset);\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int numChars) {\n+                string.copyToSegmentRaw(segment, offset, srcIndex, numChars);\n@@ -2323,2 +2323,2 @@\n-            public boolean bytesCompatible(String string, Charset charset) {\n-                return string.bytesCompatible(charset);\n+            public boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+                return string.bytesCompatible(charset, srcIndex, numChars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1327,2 +1327,2 @@\n-     * Reads a string using the given length from this segment at the given offset,\n-     * using the provided charset.\n+     * Reads a string from this segment at the given offset, using the provided length\n+     * and charset.\n@@ -1339,2 +1339,1 @@\n-     * @param length  length to be used for string conversion, in code units for\n-     *                the provided charset\n+     * @param length  length to be used for string conversion, in bytes\n@@ -1346,2 +1345,1 @@\n-     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (length * N)},\n-     *         where {@code N} is the size, in bytes, of a code unit in the provided charset\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - length}\n@@ -1356,1 +1354,1 @@\n-    String getString(long offset, Charset charset, int length);\n+    String getString(long offset, Charset charset, long length);\n@@ -2636,0 +2634,41 @@\n+    \/**\n+     * Copies the byte sequence of the given string encoded using the provided charset\n+     * to the destination segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param src      the Java string to be written into this segment\n+     * @param dstEncoding the charset used to {@linkplain Charset#newEncoder() encode}\n+     *                 the string bytes. The {@code charset} must be a\n+     *                 {@linkplain StandardCharsets standard charset}\n+     * @param srcIndex the starting index of the source string\n+     * @param dst      the destination segment\n+     * @param numChars the number of characters to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dst} is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code dst.isAccessibleBy(T) == false}\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex} or {@code numChars} are {@code < 0}\n+     * @throws IndexOutOfBoundsException  if the {@code endIndex} is larger than the length of\n+     *         this {@code String} object, or {@code beginIndex} is larger than {@code endIndex}.\n+     * @throws IllegalArgumentException if {@code dst} is {@linkplain #isReadOnly() read-only}\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n+     *\/\n+    @ForceInline\n+    static void copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+\n+        AbstractMemorySegmentImpl.copy(src, dstEncoding, srcIndex, dst, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n@@ -137,1 +139,1 @@\n-        int termCharSize = StringSupport.CharsetKind.of(charset).codeUnitSize();\n+        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n@@ -140,1 +142,1 @@\n-        if (StringSupport.bytesCompatible(str, charset)) {\n+        if (StringSupport.bytesCompatible(str, charset, 0, str.length())) {\n@@ -143,1 +145,1 @@\n-            StringSupport.copyToSegmentRaw(str, segment, 0);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, 0, str.length());\n@@ -156,0 +158,53 @@\n+    \/**\n+     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * and storing the result into a memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array. The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param str      the Java string to be converted into a C string\n+     * @param charset  the charset used to {@linkplain Charset#newEncoder() encode} the\n+     *                 string bytes\n+     * @param srcIndex the starting index of the source string\n+     * @param numChars the number of characters to be copied\n+     * @return a new native segment containing the converted C string\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex} or {@code numChars} are {@code < 0}\n+     * @throws IndexOutOfBoundsException  if the {@code endIndex} is larger than the length of\n+     *         this {@code String} object, or {@code beginIndex} is larger than {@code endIndex}.\n+     *\n+     * @implSpec The default implementation for this method copies the contents of the\n+     *           provided Java string into a new memory segment obtained by calling\n+     *           {@code this.allocate(B)}, where {@code B} is the size, in bytes, of\n+     *           the string encoded using the provided charset\n+     *           (e.g. {@code str.getBytes(charset).length});\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset, int srcIndex, int numChars) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        MemorySegment segment;\n+        if (StringSupport.bytesCompatible(str, charset, srcIndex, numChars)) {\n+            segment = allocateNoInit(numChars);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, srcIndex, numChars);\n+        } else if (srcIndex == 0 && numChars == str.length()) {\n+            byte[] bytes = str.getBytes(charset);\n+            segment = allocateNoInit(bytes.length);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        } else {\n+            CharBuffer charBuffer = CharBuffer.wrap(str, srcIndex, numChars);\n+            ByteBuffer bytes = charset.encode(charBuffer);\n+            segment = allocateNoInit(bytes.limit());\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.limit());\n+        }\n+        return segment;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":58,"deletions":3,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -615,1 +615,1 @@\n-    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int numChars);\n@@ -620,1 +620,1 @@\n-    boolean bytesCompatible(String string, Charset charset);\n+    boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -539,1 +539,1 @@\n-    public String getString(long offset, Charset charset, int length) {\n+    public String getString(long offset, Charset charset, long length) {\n@@ -698,0 +698,10 @@\n+    @ForceInline\n+    public static void copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dst;\n+        StringSupport.copyBytes(src, destImpl, dstEncoding, 0, srcIndex, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n@@ -62,3 +64,2 @@\n-    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset, int length) {\n-        int lengthBytes = length * CharsetKind.of(charset).codeUnitSize();\n-        return readBytes(segment, offset, charset, lengthBytes);\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        return readBytes(segment, offset, charset, length);\n@@ -68,1 +69,2 @@\n-    public static String readBytes(AbstractMemorySegmentImpl segment, long offset, Charset charset, int lengthBytes) {\n+    public static String readBytes(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        final int lengthBytes = (int) length;\n@@ -315,1 +317,1 @@\n-        final int codeUnitSize;\n+        final int terminatorCharSize;\n@@ -317,2 +319,2 @@\n-        CharsetKind(int codeUnitSize) {\n-            this.codeUnitSize = codeUnitSize;\n+        CharsetKind(int terminatorCharSize) {\n+            this.terminatorCharSize = terminatorCharSize;\n@@ -321,2 +323,2 @@\n-        public int codeUnitSize() {\n-            return codeUnitSize;\n+        public int terminatorCharSize() {\n+            return terminatorCharSize;\n@@ -345,2 +347,2 @@\n-    public static boolean bytesCompatible(String string, Charset charset) {\n-        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    public static boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset, srcIndex, numChars);\n@@ -350,2 +352,2 @@\n-        if (bytesCompatible(string, charset)) {\n-            copyToSegmentRaw(string, segment, offset);\n+        if (bytesCompatible(string, charset, 0, string.length())) {\n+            copyToSegmentRaw(string, segment, offset, 0, string.length());\n@@ -360,2 +362,18 @@\n-    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset, int srcIndex, int numChars) {\n+        if (bytesCompatible(string, charset, srcIndex, numChars)) {\n+            copyToSegmentRaw(string, segment, offset, srcIndex, numChars);\n+            return string.length();\n+        } else if (srcIndex == 0 && numChars == string.length()) {\n+            byte[] bytes = string.getBytes();\n+            MemorySegment.copy(bytes, 0, segment, JAVA_BYTE, offset, bytes.length);\n+            return bytes.length;\n+        } else {\n+            CharBuffer charBuffer = CharBuffer.wrap(string, srcIndex, numChars);\n+            ByteBuffer byteBuffer = segment.asByteBuffer().position((int) offset);\n+            charset.newEncoder().encode(charBuffer, byteBuffer, false);\n+            return byteBuffer.position();\n+        }\n+    }\n+\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int numChars) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset, srcIndex, numChars);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -80,0 +80,8 @@\n+                        int terminatorSize = \"\\0\".getBytes(charset).length;\n+                        if (charset == StandardCharsets.UTF_16) {\n+                            terminatorSize -= 2; \/\/ drop BOM\n+                        }\n+                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+\n@@ -81,1 +89,2 @@\n-                                testString.getBytes(charset).length + codeUnitSize(charset);\n+                                testString.getBytes(charset).length +\n+                                        terminatorSize;\n@@ -107,1 +116,1 @@\n-                            int length = testString.getBytes(charset).length \/ codeUnitSize(charset);\n+                            int length = testString.getBytes(charset).length;\n@@ -565,12 +574,0 @@\n-\n-    static int codeUnitSize(Charset charset) {\n-        int codeUnitSize = \"\\0\".getBytes(charset).length;\n-        if (charset == StandardCharsets.UTF_16) {\n-            codeUnitSize -= 2; \/\/ drop BOM\n-        }\n-        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n-        return codeUnitSize;\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class FromJavaStringTest {\n+\n+    private String str;\n+    private MemorySegment strSegment;\n+    private int lengthBytes;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\", \"451\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        while (LOREM.length() < size) {\n+            LOREM += LOREM;\n+        }\n+        str = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(str);\n+        lengthBytes = str.getBytes(UTF_8).length;\n+    }\n+\n+    @Benchmark\n+    public void panama_setString() {\n+        strSegment.setString(0, str, UTF_8);\n+    }\n+\n+    @Benchmark\n+    public void panama_copy() {\n+        MemorySegment.copy(str, UTF_8, 0, strSegment, str.length());\n+    }\n+\n+    @Benchmark\n+    public void panama_getBytes() {\n+        byte[] bytes = str.getBytes(UTF_8);\n+        MemorySegment.copy(bytes, 0, strSegment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n+    static String LOREM =\n+            \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+             dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+             ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+             fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+             mollit anim id est laborum.\n+            \"\"\";\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FromJavaStringTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}