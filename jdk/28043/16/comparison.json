{"files":[{"patch":"@@ -2048,1 +2048,1 @@\n-    boolean bytesCompatible(Charset charset) {\n+    boolean bytesCompatible(Charset charset, int srcIndex, int numChars) {\n@@ -2053,1 +2053,1 @@\n-                return !StringCoding.hasNegatives(value, 0, value.length); \/\/ ok, if ASCII-compatible\n+                return !StringCoding.hasNegatives(value, srcIndex, numChars); \/\/ ok, if ASCII-compatible\n@@ -2059,2 +2059,9 @@\n-    void copyToSegmentRaw(MemorySegment segment, long offset) {\n-        MemorySegment.copy(value, 0, segment, ValueLayout.JAVA_BYTE, offset, value.length);\n+    void copyToSegmentRaw(MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+        if (!isLatin1()) {\n+            \/\/ This method is intended to be used together with bytesCompatible, which currently only supports\n+            \/\/ latin1 strings. In the future, bytesCompatible could be updated to handle more cases, like\n+            \/\/ UTF-16 strings (when the platform and charset endianness match, and the String doesnâ€™t contain\n+            \/\/ unpaired surrogates). If that happens, copyToSegmentRaw should also be updated.\n+            throw new IllegalStateException(\"This string does not support copyToSegmentRaw\");\n+        }\n+        MemorySegment.copy(value, srcIndex, segment, ValueLayout.JAVA_BYTE, offset, srcLength);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2334,2 +2334,2 @@\n-            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-                string.copyToSegmentRaw(segment, offset);\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+                string.copyToSegmentRaw(segment, offset, srcIndex, srcLength);\n@@ -2339,2 +2339,2 @@\n-            public boolean bytesCompatible(String string, Charset charset) {\n-                return string.bytesCompatible(charset);\n+            public boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+                return string.bytesCompatible(charset, srcIndex, numChars);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1299,6 +1299,1 @@\n-     * known byte length can be done like so:\n-     * {@snippet lang=java :\n-     *     byte[] bytes = new byte[length];\n-     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n-     *     return new String(bytes, charset);\n-     * }\n+     * known byte length can be done using {@link #getString(long, Charset, long)}.\n@@ -1331,0 +1326,34 @@\n+    \/**\n+     * Reads a string from this segment at the given offset, using the provided length\n+     * and charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the string contains any {@code '\\0'} characters, they will be read as well.\n+     * This differs from {@link #getString(long, Charset)}, which will only read up\n+     * to the first {@code '\\0'}, resulting in truncation for string data that contains\n+     * the {@code '\\0'} character.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the\n+     *                string bytes\n+     * @param byteLength length, in bytes, of the region of memory to read and decode into\n+     *                a string\n+     * @return a Java string constructed from the bytes read from the given starting\n+     *         address up to the given length\n+     * @throws IllegalArgumentException  if the size of the string is greater than the\n+     *         largest string supported by the platform\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - byteLength}\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code isAccessibleBy(T) == false}\n+     * @throws IllegalArgumentException if {@code byteLength < 0}\n+     *\/\n+    String getString(long offset, Charset charset, long byteLength);\n+\n@@ -1369,1 +1398,2 @@\n-     * will appear truncated when read again.\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link #getString(long, Charset, long)}.\n@@ -2609,0 +2639,44 @@\n+    \/**\n+     * Copies the byte sequence of the given string encoded using the provided charset\n+     * to the destination segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link #getString(long, Charset, long)}.\n+     *\n+     * @param src      the Java string to be written into the destination segment\n+     * @param dstEncoding the charset used to {@linkplain Charset#newEncoder() encode}\n+     *                 the string bytes.\n+     * @param srcIndex the starting character index of the source string\n+     * @param dst      the destination segment\n+     * @param dstOffset the starting offset, in bytes, of the destination segment\n+     * @param numChars the number of characters to be copied\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         {@code dst} is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code dst.isAccessibleBy(T) == false}\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex}, {@code numChars}, or {@code dstOffset}\n+     *         are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code srcIndex > src.length() - numChars}\n+     * @throws IllegalArgumentException if {@code dst} is {@linkplain #isReadOnly() read-only}\n+     * @throws IndexOutOfBoundsException if {@code dstOffset > dstSegment.byteSize() - B} where {@code B} is the size,\n+     *         in bytes, of the substring of {@code src} encoded using the given charset\n+     * @return the number of copied bytes.\n+     *\/\n+    @ForceInline\n+    static long copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, long dstOffset, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+        Objects.checkFromIndexSize(srcIndex, numChars, src.length());\n+\n+        return AbstractMemorySegmentImpl.copy(src, dstEncoding, srcIndex, dst, dstOffset, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":81,"deletions":7,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-     * will appear truncated when read again.\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link MemorySegment#getString(long, Charset, long)}.\n@@ -140,1 +141,1 @@\n-        if (StringSupport.bytesCompatible(str, charset)) {\n+        if (StringSupport.bytesCompatible(str, charset, 0, str.length())) {\n@@ -143,1 +144,1 @@\n-            StringSupport.copyToSegmentRaw(str, segment, 0);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, 0, str.length());\n@@ -156,0 +157,47 @@\n+    \/**\n+     * Encodes a Java string using the provided charset and stores the resulting\n+     * byte array into a memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array. The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again. The string can be read without\n+     * truncation using {@link MemorySegment#getString(long, Charset, long)}.\n+     *\n+     * @param str      the Java string to be encoded\n+     * @param charset  the charset used to {@linkplain Charset#newEncoder() encode} the\n+     *                 string bytes\n+     * @param srcIndex the starting index of the source string\n+     * @param numChars the number of characters to be copied\n+     * @return a new native segment containing the encoded string\n+     * @throws IndexOutOfBoundsException if either {@code srcIndex} or {@code numChars} are {@code < 0}\n+     * @throws IndexOutOfBoundsException if {@code srcIndex > str.length() - numChars}\n+     *\n+     * @implSpec The default implementation for this method copies the contents of the\n+     *           provided Java string into a new memory segment obtained by calling\n+     *           {@code this.allocate(B)}, where {@code B} is the size, in bytes, of\n+     *           the string encoded using the provided charset\n+     *           (e.g. {@code str.getBytes(charset).length});\n+     *\/\n+    @ForceInline\n+    default MemorySegment allocateFrom(String str, Charset charset, int srcIndex, int numChars) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        Objects.checkFromIndexSize(srcIndex, numChars, str.length());\n+        MemorySegment segment;\n+        if (StringSupport.bytesCompatible(str, charset, srcIndex, numChars)) {\n+            segment = allocateNoInit(numChars);\n+            StringSupport.copyToSegmentRaw(str, segment, 0, srcIndex, numChars);\n+        } else {\n+            byte[] bytes = str.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n+            segment = allocateNoInit(bytes.length);\n+            MemorySegment.copy(bytes, 0, segment, ValueLayout.JAVA_BYTE, 0, bytes.length);\n+        }\n+        return segment;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-    void copyToSegmentRaw(String string, MemorySegment segment, long offset);\n+    void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength);\n@@ -642,1 +642,1 @@\n-    boolean bytesCompatible(String string, Charset charset);\n+    boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -554,0 +554,7 @@\n+    @Override\n+    public String getString(long offset, Charset charset, long byteLength) {\n+        Utils.checkNonNegativeArgument(byteLength, \"byteLength\");\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset, byteLength);\n+    }\n+\n@@ -705,0 +712,10 @@\n+    @ForceInline\n+    public static long copy(String src, Charset dstEncoding, int srcIndex, MemorySegment dst, long dstOffset, int numChars) {\n+        Objects.requireNonNull(src);\n+        Objects.requireNonNull(dstEncoding);\n+        Objects.requireNonNull(dst);\n+\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dst;\n+        return StringSupport.copyBytes(src, destImpl, dstEncoding, dstOffset, srcIndex, numChars);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -36,0 +37,1 @@\n+import java.lang.reflect.Array;\n@@ -38,0 +40,1 @@\n+import java.util.Objects;\n@@ -61,0 +64,21 @@\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        return readBytes(segment, offset, charset, length);\n+    }\n+\n+    @ForceInline\n+    public static String readBytes(AbstractMemorySegmentImpl segment, long offset, Charset charset, long length) {\n+        if (length > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Required length exceeds implementation limit\");\n+        }\n+        final int lengthBytes = (int) length;\n+        final byte[] bytes = new byte[lengthBytes];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, lengthBytes);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n+    }\n+\n@@ -73,8 +97,1 @@\n-        final byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -92,8 +109,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-          \/\/ use replacement characters for malformed input\n-          return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -111,8 +121,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -348,2 +351,2 @@\n-    public static boolean bytesCompatible(String string, Charset charset) {\n-        return JAVA_LANG_ACCESS.bytesCompatible(string, charset);\n+    public static boolean bytesCompatible(String string, Charset charset, int srcIndex, int numChars) {\n+        return JAVA_LANG_ACCESS.bytesCompatible(string, charset, srcIndex, numChars);\n@@ -353,3 +356,7 @@\n-        if (bytesCompatible(string, charset)) {\n-            copyToSegmentRaw(string, segment, offset);\n-            return string.length();\n+        return copyBytes(string, segment, charset, offset, 0, string.length());\n+    }\n+\n+    public static int copyBytes(String string, MemorySegment segment, Charset charset, long offset, int srcIndex, int numChars) {\n+        if (bytesCompatible(string, charset, srcIndex, numChars)) {\n+            copyToSegmentRaw(string, segment, offset, srcIndex, numChars);\n+            return numChars;\n@@ -357,1 +364,1 @@\n-            byte[] bytes = string.getBytes(charset);\n+            byte[] bytes = string.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n@@ -363,2 +370,2 @@\n-    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n-        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset);\n+    public static void copyToSegmentRaw(String string, MemorySegment segment, long offset, int srcIndex, int srcLength) {\n+        JAVA_LANG_ACCESS.copyToSegmentRaw(string, segment, offset, srcIndex, srcLength);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -105,0 +106,134 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsLength(String testString) {\n+        if (!testString.isEmpty()) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (charset.canEncode()) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                            long length = text.byteSize();\n+                            assertEquals(length, testString.getBytes(charset).length);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsCopy(String testString) {\n+        if (!testString.isEmpty()) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (charset.canEncode()) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            byte[] bytes = testString.getBytes(charset);\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, bytes.length);\n+                            MemorySegment.copy(testString, charset, 0, text, 0, testString.length());\n+                            String roundTrip = text.getString(0, charset, bytes.length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStringsLengthNegative() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocateFrom(\"abc\");\n+            assertThrows(IllegalArgumentException.class, () -> segment.getString(1, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            String testString_notBytesCompatible = \"snowman \\u26C4\";\n+            MemorySegment text = arena.allocate(JAVA_BYTE, 3);\n+            MemorySegment text_notBytesCompatible = arena.allocate(JAVA_BYTE,\n+                    testString_notBytesCompatible.getBytes(StandardCharsets.UTF_8).length);\n+            MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length());\n+            MemorySegment.copy(testString_notBytesCompatible, StandardCharsets.UTF_8, 0,\n+                    text_notBytesCompatible, 0,\n+                    testString_notBytesCompatible.length());\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, -1, text, 0, testString.length()));\n+            \/\/ dstOffset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 1, text, 0, testString.length()));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length() + 1));\n+            \/\/ dstOffset > byteSize() - B\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 1, testString.length()));\n+            \/\/ srcIndex + numChars overflows\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, Integer.MAX_VALUE, text, 0, Integer.MAX_VALUE + 3));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString_notBytesCompatible, StandardCharsets.UTF_8, Integer.MAX_VALUE, text, 0, Integer.MAX_VALUE + 3));\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateFromThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            String testString_notBytesCompatible = \"snowman \\u26C4\";\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 2, 1);\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length() + 1));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 1, testString.length()));\n+            \/\/ srcIndex + numChars overflows\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 3, Integer.MAX_VALUE));\n+            assertThrows(IndexOutOfBoundsException.class, () -> arena.allocateFrom(\n+                    testString_notBytesCompatible, StandardCharsets.UTF_8, 3, Integer.MAX_VALUE));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetStringThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            MemorySegment text = arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            text.getString(0, StandardCharsets.UTF_8, 3);\n+            \/\/ unsupported string size\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, Integer.MAX_VALUE + 1L));\n+            \/\/ offset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(-1, StandardCharsets.UTF_8, 3));\n+            \/\/ offset > byteSize() - length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(1, StandardCharsets.UTF_8, 3));\n+            \/\/ length < 0\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n@@ -224,0 +359,68 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringGetString(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            \/\/ this test assumes single-byte charsets\n+                            String roundTrip = text.getString(srcIndex, charset, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringAllocate(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset, srcIndex, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(text.byteSize(), substring.getBytes(charset).length);\n+                            String roundTrip = text.getString(0, charset, text.byteSize());\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringCopy(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            long length = substring.getBytes(charset).length;\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, length);\n+                            long copied = MemorySegment.copy(testString, charset, srcIndex, text, 0, numChars);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            assertEquals(roundTrip, substring);\n+                            assertEquals(copied, length);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -405,1 +608,1 @@\n-                {\"yen \\u00A5\"},\n+                {\"section \\u00A7\"},\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":204,"deletions":1,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class FromJavaStringTest {\n+\n+    private String str;\n+    private MemorySegment strSegment;\n+    private int lengthBytes;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\", \"451\"})\n+    int size;\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        while (LOREM.length() < size) {\n+            LOREM += LOREM;\n+        }\n+        str = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(str);\n+        lengthBytes = str.getBytes(UTF_8).length;\n+    }\n+\n+    @Benchmark\n+    public void segment_setString() {\n+        strSegment.setString(0, str, UTF_8);\n+    }\n+\n+    @Benchmark\n+    public void segment_copyStringRaw() {\n+        MemorySegment.copy(str, UTF_8, 0, strSegment, 0, str.length());\n+    }\n+\n+    @Benchmark\n+    public void segment_copyStringBytes() {\n+        byte[] bytes = str.getBytes(UTF_8);\n+        MemorySegment.copy(bytes, 0, strSegment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n+    static String LOREM =\n+            \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+             dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+             ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+             fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+             mollit anim id est laborum.\n+            \"\"\";\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FromJavaStringTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -50,0 +53,1 @@\n+    private int length;\n@@ -64,1 +68,3 @@\n-        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+        var s = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(s);\n+        length = s.getBytes(UTF_8).length;\n@@ -68,1 +74,1 @@\n-    public String panama_readString() {\n+    public String segment_getString() {\n@@ -72,0 +78,5 @@\n+    @Benchmark\n+    public String segment_getStringLength() {\n+        return strSegment.getString(0, UTF_8, length);\n+    }\n+\n@@ -77,0 +88,7 @@\n+    @Benchmark\n+    public String segment_copyStringBytes() {\n+        byte[] bytes = new byte[length];\n+        MemorySegment.copy(strSegment, JAVA_BYTE, 0, bytes, 0, length);\n+        return new String(bytes, UTF_8);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}