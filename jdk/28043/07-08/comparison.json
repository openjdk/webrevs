{"files":[{"patch":"@@ -2032,0 +2032,4 @@\n+            \/\/ This method is intended to be used together with bytesCompatible, which currently only supports\n+            \/\/ latin1 strings. In the future, bytesCompatible could be updated to handle more cases, like\n+            \/\/ UTF-16 strings (when the platform and charset endianness match, and the String doesnâ€™t contain\n+            \/\/ unpaired surrogates). If that happens, copyToSegmentRaw should also be updated.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1339,1 +1339,1 @@\n-     * @param length  length to be used for string conversion, in bytes\n+     * @param length  length in bytes of the string to read\n@@ -1341,1 +1341,1 @@\n-     *         address reading the given length of characters\n+     *         address reading the given length of bytes\n@@ -1350,2 +1350,0 @@\n-     * @throws IllegalArgumentException if {@code charset} is not a\n-     *         {@linkplain StandardCharsets standard charset}\n@@ -2661,2 +2659,2 @@\n-     * @throws IndexOutOfBoundsException if the {@code endIndex} is larger than the length of\n-     *         this {@code String} object, or {@code beginIndex} is larger than {@code endIndex}.\n+     * @throws IndexOutOfBoundsException if the {@code numChars + srcIndex} is larger than the length of\n+     *         this {@code String} object.\n@@ -2664,1 +2662,0 @@\n-     * @throws IllegalArgumentException if {@code charset} is not a {@linkplain StandardCharsets standard charset}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-     * Converts a Java string into a null-terminated C string using the provided charset,\n+     * Converts a Java string into a C string using the provided charset,\n@@ -176,2 +176,0 @@\n-     * @throws IllegalArgumentException if {@code charset} is not a\n-     *         {@linkplain StandardCharsets standard charset}\n@@ -179,2 +177,2 @@\n-     * @throws IndexOutOfBoundsException  if the {@code endIndex} is larger than the length of\n-     *         this {@code String} object, or {@code beginIndex} is larger than {@code endIndex}.\n+     * @throws IndexOutOfBoundsException if the {@code numChars + srcIndex} is larger than the length of\n+     *         this {@code String} object.\n@@ -197,1 +195,1 @@\n-            byte[] bytes = str.substring(srcIndex, numChars).getBytes(charset);\n+            byte[] bytes = str.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+        if (length > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Required length exceeds implementation limit\");\n+        }\n@@ -365,1 +368,1 @@\n-            byte[] bytes = string.substring(srcIndex, numChars).getBytes(charset);\n+            byte[] bytes = string.substring(srcIndex, srcIndex + numChars).getBytes(charset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-        Set<String> excluded = Set.of(\"yen\", \"snowman\", \"rainbow\");\n-        \/\/ This test only works for certain strings where the last character is not special\n+        Set<String> excluded = Set.of(\"yen\");\n+        \/\/ This test only works for strings that can round trip through the given charsets\n@@ -112,1 +112,1 @@\n-                if (isStandard(charset)) {\n+                if (charset.canEncode()) {\n@@ -115,2 +115,3 @@\n-                            MemorySegment text = arena.allocateFrom(testString, charset);\n-                            int length = testString.getBytes(charset).length;\n+                            MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                            long length = text.byteSize();\n+                            assertEquals(length, testString.getBytes(charset).length);\n@@ -128,0 +129,23 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsCopy(String testString) {\n+        Set<String> excluded = Set.of(\"yen\");\n+        \/\/ This test only works for strings that can round trip through the given charsets\n+        if (!testString.isEmpty() && excluded.stream().noneMatch(testString::startsWith)) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (charset.canEncode()) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            byte[] bytes = testString.getBytes(charset);\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, bytes.length);\n+                            MemorySegment.copy(testString, charset, 0, text, 0, testString.length());\n+                            String roundTrip = text.getString(0, charset, bytes.length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -132,1 +156,68 @@\n-            assertThrows(IllegalArgumentException.class, () -> segment.getString(0, StandardCharsets.UTF_8, -1));\n+            assertThrows(IllegalArgumentException.class, () -> segment.getString(1, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n+    @Test\n+    public void testCopyThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            MemorySegment text = arena.allocate(JAVA_BYTE, 3);\n+            MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length());\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, -1, text, 0, testString.length()));\n+            \/\/ dstOffset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 1, text, 0, testString.length()));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 0, testString.length() + 1));\n+            \/\/ dstOffset > byteSize() + B\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    MemorySegment.copy(testString, StandardCharsets.UTF_8, 0, text, 1, testString.length()));\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateFromThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            arena.allocateFrom(testString, StandardCharsets.UTF_8, 2, 1);\n+            \/\/ srcIndex < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, -1, testString.length()));\n+            \/\/ numChars < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, -1));\n+            \/\/ srcIndex + numChars > length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length() + 1));\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    arena.allocateFrom(testString, StandardCharsets.UTF_8, 1, testString.length()));\n+        }\n+    }\n+\n+    @Test\n+    public void testGetStringThrows() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            String testString = \"abc\";\n+            MemorySegment text = arena.allocateFrom(testString, StandardCharsets.UTF_8, 0, testString.length());\n+            text.getString(0, StandardCharsets.UTF_8, 3);\n+            \/\/ unsupported string size\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, Integer.MAX_VALUE + 1L));\n+            \/\/ offset < 0\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(-1, StandardCharsets.UTF_8, 3));\n+            \/\/ offset > byteSize() - length\n+            assertThrows(IndexOutOfBoundsException.class, () ->\n+                    text.getString(1, StandardCharsets.UTF_8, 3));\n+            \/\/ length < 0\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    text.getString(0, StandardCharsets.UTF_8, -1));\n@@ -255,0 +346,67 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringGetString(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    MemorySegment text = arena.allocateFrom(testString, charset, 0, testString.length());\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            \/\/ this test assumes single-byte charsets\n+                            String roundTrip = text.getString(srcIndex, charset, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringAllocate(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset, srcIndex, numChars);\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            assertEquals(text.byteSize(), substring.getBytes(charset).length);\n+                            String roundTrip = text.getString(0, charset, text.byteSize());\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testSubstringCopy(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for (var charset : singleByteCharsets()) {\n+            for (var arena: arenas()) {\n+                try (arena) {\n+                    for (int srcIndex = 0; srcIndex <= testString.length(); srcIndex++) {\n+                        for (int numChars = 0; numChars <= testString.length() - srcIndex; numChars++) {\n+                            String substring = testString.substring(srcIndex, srcIndex + numChars);\n+                            long length = substring.getBytes(charset).length;\n+                            MemorySegment text = arena.allocate(JAVA_BYTE, length);\n+                            MemorySegment.copy(testString, charset, srcIndex, text, 0, numChars);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            assertEquals(roundTrip, substring);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":164,"deletions":6,"binary":false,"changes":170,"status":"modified"}]}