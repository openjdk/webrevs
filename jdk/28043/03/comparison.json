{"files":[{"patch":"@@ -1299,6 +1299,1 @@\n-     * known byte length can be done like so:\n-     * {@snippet lang=java :\n-     *     byte[] bytes = new byte[length];\n-     *     MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, length);\n-     *     return new String(bytes, charset);\n-     * }\n+     * known byte length can be done using {@link #getString(long, Charset, int)}.\n@@ -1331,0 +1326,32 @@\n+    \/**\n+     * Reads a string using the given length from this segment at the given offset,\n+     * using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur\n+     * @param charset the charset used to {@linkplain Charset#newDecoder() decode} the\n+     *                string bytes\n+     * @param length  length to be used for string conversion, in code units for\n+     *                the provided charset\n+     * @return a Java string constructed from the bytes read from the given starting\n+     *         address reading the given length of characters\n+     * @throws IllegalArgumentException  if the size of the string is greater than the\n+     *         largest string supported by the platform\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - (length * N)},\n+     *         where {@code N} is the size, in bytes, of a code unit in the provided charset\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code isAccessibleBy(T) == false}\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n+     * @throws IllegalArgumentException if {@code length < 0}\n+     *\/\n+    String getString(long offset, Charset charset, int length);\n+\n@@ -1398,0 +1425,37 @@\n+    \/**\n+     * Writes the given string into this segment at the given offset, converting it to a\n+     * byte sequence using the provided charset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string. The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * If the given string contains any {@code '\\0'} characters, they will be\n+     * copied as well. This means that, depending on the method used to read\n+     * the string, such as {@link MemorySegment#getString(long)}, the string\n+     * will appear truncated when read again.\n+     *\n+     * @param offset  offset in bytes (relative to this segment address) at which this\n+     *                access operation will occur, the final address of this write\n+     *                operation can be expressed as {@code address() + offset}\n+     * @param str     the Java string to be written into this segment\n+     * @param charset the charset used to {@linkplain Charset#newEncoder() encode} the\n+     *                string bytes. The {@code charset} must be a\n+     *                {@linkplain StandardCharsets standard charset}\n+     * @return the number of bytes written.\n+     * @throws IndexOutOfBoundsException if {@code offset < 0}\n+     * @throws IndexOutOfBoundsException if {@code offset > byteSize() - B}, where:\n+     *         {@code B} is the size, in bytes, of the string encoded using the\n+     *         provided charset (e.g. {@code str.getBytes(charset).length}).\n+     * @throws IllegalStateException if the {@linkplain #scope() scope} associated with\n+     *         this segment is not {@linkplain Scope#isAlive() alive}\n+     * @throws WrongThreadException if this method is called from a thread {@code T},\n+     *         such that {@code isAccessibleBy(T) == false}\n+     * @throws IllegalArgumentException if {@code charset} is not a\n+     *         {@linkplain StandardCharsets standard charset}\n+     * @throws IllegalArgumentException if this segment is\n+     *         {@linkplain #isReadOnly() read-only}\n+     *\/\n+    int setStringWithoutNullTerminator(long offset, String str, Charset charset);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        int termCharSize = StringSupport.CharsetKind.of(charset).terminatorCharSize();\n+        int termCharSize = StringSupport.CharsetKind.of(charset).codeUnitSize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,0 +538,9 @@\n+    @Override\n+    public String getString(long offset, Charset charset, int length) {\n+        if (length < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        Objects.requireNonNull(charset);\n+        return StringSupport.read(this, offset, charset, length);\n+    }\n+\n@@ -954,0 +963,8 @@\n+\n+    @ForceInline\n+    @Override\n+    public int setStringWithoutNullTerminator(long offset, String str, Charset charset) {\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(str);\n+        return StringSupport.copyBytes(str, this, charset, offset);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -61,0 +61,18 @@\n+    @ForceInline\n+    public static String read(AbstractMemorySegmentImpl segment, long offset, Charset charset, int length) {\n+        int lengthBytes = length * CharsetKind.of(charset).codeUnitSize();\n+        return readBytes(segment, offset, charset, lengthBytes);\n+    }\n+\n+    @ForceInline\n+    public static String readBytes(AbstractMemorySegmentImpl segment, long offset, Charset charset, int lengthBytes) {\n+        final byte[] bytes = new byte[lengthBytes];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, lengthBytes);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n+    }\n+\n@@ -73,8 +91,1 @@\n-        final byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -92,8 +103,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-          \/\/ use replacement characters for malformed input\n-          return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -111,8 +115,1 @@\n-        byte[] bytes = new byte[len];\n-        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, len);\n-        try {\n-            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n-        } catch (CharacterCodingException _) {\n-            \/\/ use replacement characters for malformed input\n-            return new String(bytes, charset);\n-        }\n+        return readBytes(segment, offset, charset, len);\n@@ -318,1 +315,1 @@\n-        final int terminatorCharSize;\n+        final int codeUnitSize;\n@@ -320,2 +317,2 @@\n-        CharsetKind(int terminatorCharSize) {\n-            this.terminatorCharSize = terminatorCharSize;\n+        CharsetKind(int codeUnitSize) {\n+            this.codeUnitSize = codeUnitSize;\n@@ -324,2 +321,2 @@\n-        public int terminatorCharSize() {\n-            return terminatorCharSize;\n+        public int codeUnitSize() {\n+            return codeUnitSize;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Set;\n@@ -79,8 +80,0 @@\n-                        int terminatorSize = \"\\0\".getBytes(charset).length;\n-                        if (charset == StandardCharsets.UTF_16) {\n-                            terminatorSize -= 2; \/\/ drop BOM\n-                        }\n-                        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n-                        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n-                        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n-\n@@ -88,2 +81,1 @@\n-                                testString.getBytes(charset).length +\n-                                        terminatorSize;\n+                                testString.getBytes(charset).length + codeUnitSize(charset);\n@@ -105,0 +97,30 @@\n+    @Test(dataProvider = \"strings\")\n+    public void testStringsLength(String testString) {\n+        Set<String> excluded = Set.of(\"yen\", \"snowman\", \"rainbow\");\n+        \/\/ This test only works for certain strings where the last character is not special\n+        if (!testString.isEmpty() && excluded.stream().noneMatch(testString::startsWith)) {\n+            for (Charset charset : Charset.availableCharsets().values()) {\n+                if (isStandard(charset)) {\n+                    for (Arena arena : arenas()) {\n+                        try (arena) {\n+                            MemorySegment text = arena.allocateFrom(testString, charset);\n+                            int length = testString.getBytes(charset).length \/ codeUnitSize(charset);\n+                            String roundTrip = text.getString(0, charset, length);\n+                            if (charset.newEncoder().canEncode(testString)) {\n+                                assertEquals(roundTrip, testString);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testStringsLengthNegative() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            var segment = arena.allocateFrom(\"abc\");\n+            assertThrows(IllegalArgumentException.class, () -> segment.getString(0, StandardCharsets.UTF_8, -1));\n+        }\n+    }\n+\n@@ -543,0 +565,12 @@\n+\n+    static int codeUnitSize(Charset charset) {\n+        int codeUnitSize = \"\\0\".getBytes(charset).length;\n+        if (charset == StandardCharsets.UTF_16) {\n+            codeUnitSize -= 2; \/\/ drop BOM\n+        }\n+        \/\/ Note that the JDK's UTF_32 encoder doesn't add a BOM.\n+        \/\/ This is legal under the Unicode standard, and means the byte order is BE.\n+        \/\/ See: https:\/\/unicode.org\/faq\/utf_bom.html#gen7\n+        return codeUnitSize;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(\n+        value = 3,\n+        jvmArgs = {\"--enable-native-access=ALL-UNNAMED\", \"-Djava.library.path=micro\/native\"})\n+public class FromJavaStringTest {\n+\n+    private String str;\n+    private MemorySegment strSegment;\n+    private int lengthBytes;\n+\n+    @Param({\"5\", \"20\", \"100\", \"200\", \"451\"})\n+    int size;\n+\n+    static {\n+        System.loadLibrary(\"ToJavaString\");\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        var arena = Arena.ofAuto();\n+        while (LOREM.length() < size) {\n+            LOREM += LOREM;\n+        }\n+        str = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(str);\n+        lengthBytes = str.getBytes(UTF_8).length;\n+    }\n+\n+    @Benchmark\n+    public void panama_setString() {\n+        strSegment.setString(0, str, UTF_8);\n+    }\n+\n+    @Benchmark\n+    public void panama_setStringWithoutNullTerminator() {\n+        strSegment.setStringWithoutNullTerminator(0, str, UTF_8);\n+    }\n+\n+    @Benchmark\n+    public void panama_copyStringWithoutNullTerminator() {\n+        byte[] bytes = str.getBytes(UTF_8);\n+        MemorySegment.copy(bytes, 0, strSegment, JAVA_BYTE, 0, bytes.length);\n+    }\n+\n+    static String LOREM =\n+            \"\"\"\n+            Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+             dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+             ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+             fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+             mollit anim id est laborum.\n+            \"\"\";\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/FromJavaStringTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -25,0 +25,3 @@\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -50,0 +53,1 @@\n+    private int lengthBytes;\n@@ -64,1 +68,3 @@\n-        strSegment = arena.allocateFrom(LOREM.substring(0, size));\n+        var s = LOREM.substring(0, size);\n+        strSegment = arena.allocateFrom(s);\n+        lengthBytes = s.getBytes(UTF_8).length;\n@@ -72,0 +78,12 @@\n+    @Benchmark\n+    public String panama_readStringLength() {\n+        return strSegment.getString(0, UTF_8, lengthBytes);\n+    }\n+\n+    @Benchmark\n+    public String panama_copyLength() {\n+        byte[] bytes = new byte[lengthBytes];\n+        MemorySegment.copy(strSegment, JAVA_BYTE, 0, bytes, 0, lengthBytes);\n+        return new String(bytes, UTF_8);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToJavaStringTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}