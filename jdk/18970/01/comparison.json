{"files":[{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectionSetCandidates.hpp\"\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -98,0 +98,15 @@\n+  assert(ci1->_r != nullptr && ci2->_r != nullptr, \"Should not be!\");\n+\n+  double gc_eff1 = ci1->_gc_efficiency;\n+  double gc_eff2 = ci2->_gc_efficiency;\n+\n+  if (gc_eff1 > gc_eff2) {\n+    return -1;\n+  } if (gc_eff1 < gc_eff2) {\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int G1CollectionCandidateList::compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -109,2 +124,2 @@\n-  double gc_eff1 = ci1->_gc_efficiency;\n-  double gc_eff2 = ci2->_gc_efficiency;\n+  size_t reclaimable1 = ci1->_r->reclaimable_bytes();\n+  size_t reclaimable2 = ci2->_r->reclaimable_bytes();\n@@ -112,7 +127,3 @@\n-  if (gc_eff1 > gc_eff2) {\n-    return -1;\n-  } if (gc_eff1 < gc_eff2) {\n-    return 1;\n-  } else {\n-    return 0;\n-  }\n+  if (reclaimable1 == reclaimable2) return 0;\n+  if (reclaimable1 > reclaimable2) return -1;\n+  return 1;\n@@ -185,0 +196,9 @@\n+void G1CollectionSetCandidates::calc_gc_efficiency() {\n+  G1CollectionCandidateListIterator iter = _marking_regions.begin();\n+  for (; iter != _marking_regions.end(); ++iter) {\n+    HeapRegion* hr = (*iter)->_r;\n+    (*iter)->_gc_efficiency = hr->calc_gc_efficiency();\n+  }\n+  _marking_regions.sort_by_efficiency();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+  static int compare_reclaimble_bytes(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n+\n@@ -229,0 +231,2 @@\n+  void calc_gc_efficiency();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-      _data[idx] = CandidateInfo(hr, hr->calc_gc_efficiency());\n+      _data[idx] = CandidateInfo(hr, 0.0);\n@@ -100,1 +100,1 @@\n-    void sort_by_efficiency() {\n+    void sort_by_reclaimable_bytes() {\n@@ -107,1 +107,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionCandidateList::compare_reclaimble_bytes);\n@@ -155,2 +155,1 @@\n-      assert(!r->rem_set()->is_updating(), \"must be\");\n-      if (!r->rem_set()->is_complete()) {\n+      if (!r->rem_set()->is_tracked()) {\n@@ -252,1 +251,1 @@\n-    _result.sort_by_efficiency();\n+    _result.sort_by_reclaimable_bytes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1440,0 +1440,1 @@\n+\n@@ -1441,0 +1442,6 @@\n+\n+      if (_needs_remembered_set_rebuild) {\n+        \/\/ Prune rebuild candidates based on G1HeapWastePercent.\n+        \/\/ Improves rebuild time in addition to remembered set memory usage.\n+        G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), _g1h->policy()->candidates());\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1313,1 +1313,1 @@\n-    G1CollectionSetChooser::build(_g1h->workers(), _g1h->num_regions(), candidates());\n+    candidates()->calc_gc_efficiency();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,2 @@\n+  G1CollectionSetCandidates* candidates() const;\n+\n@@ -189,1 +191,0 @@\n-  G1CollectionSetCandidates* candidates() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}