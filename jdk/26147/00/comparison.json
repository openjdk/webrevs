{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"compiler\/compileBroker.hpp\"\n@@ -118,0 +119,1 @@\n+DEBUG_ONLY(static bool _disable_interning_during_cds_dump = false);\n@@ -349,0 +351,4 @@\n+size_t StringTable::items_count_acquire() {\n+  return Atomic::load_acquire(&_items_count);\n+}\n+\n@@ -507,0 +513,3 @@\n+  assert(!Atomic::load_acquire(&_disable_interning_during_cds_dump),\n+         \"All threads that may intern strings should have been stopped before CDS starts copying the interned string table\");\n+\n@@ -796,1 +805,1 @@\n-class VerifyCompStrings : StackObj {\n+class StringTable::VerifyCompStrings : StackObj {\n@@ -808,1 +817,1 @@\n-  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n+  VerifyCompStrings() : _table(unsigned(items_count_acquire() \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n@@ -942,3 +951,2 @@\n-\/\/ This is called BEFORE we enter the CDS safepoint. We can allocate heap objects.\n-\/\/ This should be called when we know no more strings will be added (which will be easy\n-\/\/ to guarantee because CDS runs with a single Java thread. See JDK-8253495.)\n+\/\/ This is called BEFORE we enter the CDS safepoint. We can still allocate Java object arrays to\n+\/\/ be used by the shared strings table.\n@@ -949,1 +957,0 @@\n-  assert(CDSConfig::allow_only_single_java_thread(), \"No more interned strings can be added\");\n@@ -951,2 +958,15 @@\n-  if (_items_count > (size_t)max_jint) {\n-    fatal(\"Too many strings to be archived: %zu\", _items_count);\n+  CompileBroker::wait_for_no_active_tasks();\n+\n+  precond(CDSConfig::allow_only_single_java_thread());\n+\n+  \/\/ At this point, no more strings will be added:\n+  \/\/ - There's only a single Java thread (this thread). It no longer executes Java bytecodes\n+  \/\/   so JIT compilation will eventually stop.\n+  \/\/ - CompileBroker has no more active tasks, so all JIT requests have been processed.\n+\n+  \/\/ This flag will be cleared after intern table dumping has completed, so we can run the\n+  \/\/ compiler again (for future AOT method compilation, etc).\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, true));\n+\n+  if (items_count_acquire() > (size_t)max_jint) {\n+    fatal(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -955,1 +975,1 @@\n-  int total = (int)_items_count;\n+  int total = (int)items_count_acquire();\n@@ -975,1 +995,1 @@\n-      log_error(aot)(\"Too many strings to be archived: %zu\", _items_count);\n+      log_error(aot)(\"Too many strings to be archived: %zu\", items_count_acquire());\n@@ -1073,1 +1093,1 @@\n-  CompactHashtableWriter writer((int)_items_count, ArchiveBuilder::string_stats());\n+  CompactHashtableWriter writer((int)items_count_acquire(), ArchiveBuilder::string_stats());\n@@ -1087,0 +1107,2 @@\n+\n+  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, false));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\n+  class VerifyCompStrings;\n@@ -77,0 +77,1 @@\n+  static size_t items_count_acquire();\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1753,0 +1753,4 @@\n+void CompileBroker::wait_for_no_active_tasks() {\n+  CompileTask::wait_for_no_active_tasks();\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,0 +386,3 @@\n+\n+  static void wait_for_no_active_tasks();\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+int CompileTask::_active_tasks = 0;\n@@ -45,1 +46,1 @@\n-  MutexLocker locker(CompileTaskAlloc_lock);\n+  MonitorLocker locker(CompileTaskAlloc_lock);\n@@ -59,0 +60,1 @@\n+  _active_tasks++;\n@@ -66,1 +68,1 @@\n-  MutexLocker locker(CompileTaskAlloc_lock);\n+  MonitorLocker locker(CompileTaskAlloc_lock);\n@@ -82,0 +84,11 @@\n+    _active_tasks--;\n+    if (_active_tasks == 0) {\n+      locker.notify_all();\n+    }\n+  }\n+}\n+\n+void CompileTask::wait_for_no_active_tasks() {\n+  MonitorLocker locker(CompileTaskAlloc_lock);\n+  while (_active_tasks > 0) {\n+    locker.wait();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,1 @@\n+  static int           _active_tasks;\n@@ -126,0 +127,1 @@\n+  static void         wait_for_no_active_tasks();\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-Mutex*   CompileTaskAlloc_lock        = nullptr;\n+Monitor* CompileTaskAlloc_lock        = nullptr;\n@@ -346,1 +346,1 @@\n-  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMutex  , MethodCompileQueue_lock);\n+  MUTEX_DEFL(CompileTaskAlloc_lock          , PaddedMonitor, MethodCompileQueue_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-extern Mutex*   CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n+extern Monitor* CompileTaskAlloc_lock;           \/\/ a lock held when CompileTasks are allocated\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}