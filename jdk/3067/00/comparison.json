{"files":[{"patch":"@@ -459,0 +459,101 @@\n+class ArgumentPusher : public SignatureIterator {\n+ protected:\n+  JavaCallArguments*  _jca;\n+  jlong _argument;\n+  bool _pushed;\n+\n+  jlong next_arg(BasicType expectedType) {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    return _argument;\n+  }\n+\n+  float next_float() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.i = (jint) _argument;\n+    return v.f;\n+  }\n+\n+  double next_double() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.j = _argument;\n+    return v.d;\n+  }\n+\n+ public:\n+  ArgumentPusher(Symbol* signature, JavaCallArguments*  jca, jlong argument, bool is_static) : SignatureIterator(signature) {\n+    this->_return_type = T_ILLEGAL;\n+    _jca = jca;\n+    _argument = argument;\n+    _pushed = false;\n+    iterate();\n+  }\n+\n+  inline void do_object() {       _jca->push_oop((oop) (address) next_arg(T_OBJECT)); }\n+\n+  inline void do_bool()   { if (!is_return_type()) _jca->push_int((jboolean) next_arg(T_BOOLEAN)); }\n+  inline void do_char()   { if (!is_return_type()) _jca->push_int((jchar) next_arg(T_CHAR)); }\n+  inline void do_short()  { if (!is_return_type()) _jca->push_int((jint)  next_arg(T_SHORT)); }\n+  inline void do_byte()   { if (!is_return_type()) _jca->push_int((jbyte) next_arg(T_BYTE)); }\n+  inline void do_int()    { if (!is_return_type()) _jca->push_int((jint)  next_arg(T_INT)); }\n+\n+  inline void do_long()   { if (!is_return_type()) _jca->push_long((jlong) next_arg(T_LONG)); }\n+  inline void do_float()  { if (!is_return_type()) _jca->push_float(next_float()); }\n+  inline void do_double() { if (!is_return_type()) _jca->push_double(next_double()); }\n+\n+  inline void do_object(int begin, int end) { if (!is_return_type()) do_object(); }\n+  inline void do_array(int begin, int end)  { if (!is_return_type()) do_object(); }\n+\n+  inline void do_void()                     { }\n+};\n+\n+\n+JRT_ENTRY(jlong, JVMCIRuntime::invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument))\n+  ResourceMark rm;\n+  HandleMark hm;\n+\n+  methodHandle mh(thread, method);\n+  if (mh->size_of_parameters() > 1 && !mh->is_static()) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Invoked method must be static and take at most one argument\");\n+  }\n+\n+  Symbol* signature = mh->signature();\n+  JavaCallArguments jca(mh->size_of_parameters());\n+  ArgumentPusher jap(signature, &jca, argument, mh->is_static());\n+  JavaValue result(jap.get_ret_type());\n+  JavaCalls::call(&result, mh, &jca, CHECK_0);\n+\n+  if (jap.get_ret_type() == T_VOID) {\n+    return 0;\n+  } else if (jap.get_ret_type() == T_OBJECT || jap.get_ret_type() == T_ARRAY) {\n+    thread->set_vm_result((oop) result.get_jobject());\n+    return 0;\n+  } else {\n+    jvalue *value = (jvalue *) result.get_value_addr();\n+    \/\/ Narrow the value down if required (Important on big endian machines)\n+    switch (jap.get_ret_type()) {\n+      case T_BOOLEAN:\n+        return (jboolean) value->i;\n+      case T_BYTE:\n+        return (jbyte) value->i;\n+      case T_CHAR:\n+        return (jchar) value->i;\n+      case T_SHORT:\n+        return (jshort) value->i;\n+      case T_INT:\n+      case T_FLOAT:\n+        return value->i;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        return value->j;\n+      default:\n+        ShouldNotReachHere();\n+        return 0;\n+    }\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -415,0 +415,5 @@\n+  \/\/ A helper to allow invocation of an arbitrary Java method.  For simplicity the method is\n+  \/\/ restricted to a static method that takes at most one argument.  For calling convention\n+  \/\/ simplicty all types are passed by being converted into a jlong\n+  static jlong invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -687,0 +687,2 @@\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n+  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}