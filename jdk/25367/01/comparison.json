{"files":[{"patch":"@@ -1799,1 +1799,1 @@\n-        jvf->print_lock_info_on(st, count);\n+        jvf->print_lock_info_on(st, false\/*is_virtual*\/, count);\n@@ -1841,1 +1841,1 @@\n-        jvf->print_lock_info_on(st, count);\n+        jvf->print_lock_info_on(st, true\/*is_virtual*\/, count);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-void javaVFrame::print_lock_info_on(outputStream* st, int frame_count) {\n+void javaVFrame::print_lock_info_on(outputStream* st, bool is_virtual, int frame_count) {\n@@ -207,2 +207,3 @@\n-    }\n-    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+    } else if (thread()->osthread()->get_state() == OBJECT_WAIT &&\n+        \/\/ If this is a carrier thread with mounted virtual thread this is reported for the virtual thread.\n+        (is_virtual || !thread()->is_vthread_mounted())) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -142,2 +142,2 @@\n-  void print_lock_info_on(outputStream* st, int frame_count);\n-  void print_lock_info(int frame_count) { print_lock_info_on(tty, frame_count); }\n+  void print_lock_info_on(outputStream* st, bool is_virtual, int frame_count);\n+  void print_lock_info(bool is_virtual, int frame_count) { print_lock_info_on(tty, is_virtual, frame_count); }\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/*\n+ * @test\n+ * @bug 8356222\n+ * @summary Test jcmd Thread.print command for \"waiting on the Class initialization monitor\" case\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run main ClassInitMonitorVThread\n+ *\/\n+\n+class LongInitClass {\n+    static {\n+        ClassInitMonitorVThread.longInitClass_waiting = true;\n+        while (ClassInitMonitorVThread.longInitClass_wait) {\n+            try {\n+                Thread.sleep(10);\n+            } catch (Exception ex) {\n+            }\n+        }\n+        ClassInitMonitorVThread.longInitClass_waiting = false;\n+    }\n+\n+    LongInitClass() {}\n+}\n+\n+public class ClassInitMonitorVThread {\n+    static volatile boolean longInitClass_wait;\n+    static volatile boolean longInitClass_waiting;\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        try {\n+            \/\/ 1st thread starts class initialization\n+            longInitClass_wait = true;\n+            longInitClass_waiting = false;\n+            Thread vthread1 = Thread.ofVirtual().name(\"Loader1\").start(new Loader(null));\n+            while (!longInitClass_waiting) {\n+                Thread.sleep(10);\n+            }\n+\n+            \/\/ 2nd thread is blocked at class initialization\n+            \/\/ thread state is \"RUNNING\", so just wait some time after the thread is ready\n+            CountDownLatch loaderReady = new CountDownLatch(1);\n+            Thread vthread2 = Thread.ofVirtual().name(\"Loader2\").start(new Loader(loaderReady));\n+            loaderReady.await();\n+\n+            Thread.sleep(100);\n+            \/\/ try up to 20 times to avoid failures on slow environment\n+            for (int iter = 20; iter > 0; iter--) {\n+                try {\n+                    verify(vthread2);\n+                    break;\n+                } catch (RuntimeException ex) {\n+                    if (iter == 0) {\n+                        throw ex;\n+                    }\n+                    System.out.println(\"Failed with: \" + ex.getMessage() + \", retrying...\");\n+                    System.out.println();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } finally {\n+            longInitClass_wait = false;\n+        }\n+    }\n+\n+    static void verify(Thread vthread2) {\n+        boolean silent = true;\n+        OutputAnalyzer output = new PidJcmdExecutor().execute(\"Thread.print -l\", silent);\n+        String out = output.getStdout();\n+        String carrierPrefix = \"Carrying virtual thread #\" + vthread2.threadId();\n+        String vthreadPrefix = \"Mounted virtual thread \" + \"#\" + vthread2.threadId();\n+        int carrierStart = out.indexOf(carrierPrefix);\n+        int vthreadStart = out.indexOf(vthreadPrefix);\n+        int vthreadEnd = out.indexOf(\"\\n\\n\", vthreadStart);\n+        String carrierOut = out.substring(carrierStart, vthreadStart);\n+        String vthreadOut = out.substring(vthreadStart, vthreadEnd);\n+\n+        System.out.println(\"carrier: \" + carrierOut);\n+        System.out.println(\"vthread: \" + vthreadOut);\n+\n+        String waitText = \"- waiting on the Class initialization monitor for LongInitClass\";\n+\n+        if (!vthreadOut.contains(waitText)) {\n+            throw new RuntimeException(\"Vthread does not contain the lock\");\n+        }\n+        if (carrierOut.contains(waitText)) {\n+            throw new RuntimeException(\"Carrier does contain the lock\");\n+        }\n+    }\n+\n+    static class Loader implements Runnable {\n+        CountDownLatch ready;\n+        Loader(CountDownLatch ready) {\n+            this.ready = ready;\n+        }\n+        public void run() {\n+            try {\n+                if (ready != null) {\n+                    ready.countDown();\n+                }\n+                Class<?> myClass = Class.forName(\"LongInitClass\");\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ClassInitMonitorVThread.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}