{"files":[{"patch":"@@ -1274,0 +1274,1 @@\n+  INSN(vfcvt_x_f_v,      0b1010111, 0b001, 0b00001, 0b010010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2331,0 +2331,56 @@\n+\/\/ j.l.Math.round(float)\n+\/\/  Returns the closest int to the argument, with ties rounding to positive infinity.\n+\/\/ We need to handle 3 special cases defined by java api spec:\n+\/\/    NaN,\n+\/\/    float >= Integer.MAX_VALUE,\n+\/\/    float <= Integer.MIN_VALUE.\n+void C2_MacroAssembler::java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp) {\n+  \/\/ In riscv, there is no straight corresponding rounding mode to satisfy the behaviour defined,\n+  \/\/ in java api spec, i.e. any rounding mode can not handle some corner cases, e.g.\n+  \/\/  RNE is the closest one, but it ties to \"even\", which means 1.5\/2.5 both will be converted\n+  \/\/    to 2, instead of 2 and 3 respectively.\n+  \/\/  RUP does not work either, although java api requires \"rounding to positive infinity\",\n+  \/\/    but both 1.3\/1.8 will be converted to 2, instead of 1 and 2 respectively.\n+  \/\/\n+  \/\/ The optimal solution for non-NaN cases is:\n+  \/\/    src+0.5 => dst, with rdn rounding mode,\n+  \/\/    convert dst from float to int, with rnd rounding mode.\n+  \/\/ and, this solution works as expected for float >= Integer.MAX_VALUE and float <= Integer.MIN_VALUE.\n+  \/\/\n+  \/\/ But, we still need to handle NaN explicilty with vector mask instructions.\n+  \/\/\n+  \/\/ Check MacroAssembler::java_round_float and C2_MacroAssembler::vector_round_sve in aarch64 for more details.\n+\n+  \/\/ don't rearrage the instructions sequence order without performance testing.\n+  \/\/ check MacroAssembler::java_round_float in riscv64 for more details.\n+  mv(t0, jint_cast(0.5f));\n+  fmv_w_x(ftmp, t0);\n+\n+  \/\/ replacing vfclass with feq as performance optimization\n+  vmfeq_vv(v0, src, src);\n+  \/\/ set dst = 0 in cases of NaN\n+  vmv_v_x(dst, zr);\n+\n+  \/\/ dst = (src + 0.5) rounded down towards negative infinity\n+  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n+  vfcvt_x_f_v(dst, dst, Assembler::v0_t); \/\/ in RoundingMode::rdn\n+}\n+\n+\/\/ java.lang.Math.round(double a)\n+\/\/ Returns the closest long to the argument, with ties rounding to positive infinity.\n+void C2_MacroAssembler::java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp) {\n+  \/\/ check C2_MacroAssembler::java_round_float_v above for more details.\n+\n+  mv(t0, julong_cast(0.5));\n+  fmv_d_x(ftmp, t0);\n+\n+  \/\/ replacing vfclass with feq as performance optimization\n+  vmfeq_vv(v0, src, src);\n+  \/\/ set dst = 0 in cases of NaN\n+  vmv_v_x(dst, zr);\n+\n+  \/\/ dst = (src + 0.5) rounded down towards negative infinity\n+  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n+  vfcvt_x_f_v(dst, dst, Assembler::v0_t); \/\/ in RoundingMode::rdn\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -191,0 +191,3 @@\n+  void java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp);\n+  void java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3666,0 +3666,32 @@\n+\/\/ ---------------- Round float\/double Vector Operations ----------------\n+\n+instruct vround_f(vReg dst, vReg src, fRegF tmp, vRegMask_V0 v0) %{\n+  match(Set dst (RoundVF src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"java_round_float_v $dst, $src\\t\" %}\n+  ins_encode %{\n+    __ csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ java_round_float_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                          as_FloatRegister($tmp$$reg));\n+    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_d(vReg dst, vReg src, fRegD tmp, vRegMask_V0 v0) %{\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  format %{ \"java_round_double_v $dst, $src\\t\" %}\n+  ins_encode %{\n+    __ csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ java_round_double_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                           as_FloatRegister($tmp$$reg));\n+    __ csrwi(CSR_FRM, C2_MacroAssembler::rne);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,0 +452,11 @@\n+      a1[14] = Double.longBitsToDouble(0x7ff0000000000001L);\n+      a1[15] = Double.longBitsToDouble(0x7ff8000000000000L);\n+      a1[16] = Double.longBitsToDouble(0xfff0000000000001L);\n+      a1[17] = Double.longBitsToDouble(0xfff8000000000000L);\n+      a1[18] = Double.longBitsToDouble(0xffffffffffffffffL);\n+      a1[19] = Double.longBitsToDouble(0x7fffffffffffffffL);\n+      a1[20] = 1.5;\n+      a1[21] = 100000000.5;\n+      a1[22] = -1.5;\n+      a1[23] = -100000000.5;\n+\n@@ -468,1 +479,13 @@\n-      for (int i=14; i<ARRLEN; i++) {\n+\n+      errn += verify(\"test_round: \", 14, l0[14], 0);\n+      errn += verify(\"test_round: \", 15, l0[15], 0);\n+      errn += verify(\"test_round: \", 16, l0[16], 0);\n+      errn += verify(\"test_round: \", 17, l0[17], 0);\n+      errn += verify(\"test_round: \", 18, l0[18], 0);\n+      errn += verify(\"test_round: \", 19, l0[19], 0);\n+      errn += verify(\"test_round: \", 20, l0[20], 2);\n+      errn += verify(\"test_round: \", 21, l0[21], 100000001);\n+      errn += verify(\"test_round: \", 22, l0[22], -1);\n+      errn += verify(\"test_round: \", 23, l0[23], -100000000);\n+\n+      for (int i=24; i<ARRLEN; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVect.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -399,0 +399,11 @@\n+      a1[14] = Float.intBitsToFloat(0x7f800001);\n+      a1[15] = Float.intBitsToFloat(0x7fc00000);\n+      a1[16] = Float.intBitsToFloat(0xff800001);\n+      a1[17] = Float.intBitsToFloat(0xffc00000);\n+      a1[18] = Float.intBitsToFloat(0xffffffff);\n+      a1[19] = Float.intBitsToFloat(0x7fffffff);\n+      a1[20] = 1.5f;\n+      a1[21] = 10000.5f;\n+      a1[22] = -1.5f;;\n+      a1[23] = -10000.5f;\n+\n@@ -415,1 +426,12 @@\n-      for (int i=14; i<ARRLEN; i++) {\n+      errn += verify(\"test_round: \", 14, i0[14], 0);\n+      errn += verify(\"test_round: \", 15, i0[15], 0);\n+      errn += verify(\"test_round: \", 16, i0[16], 0);\n+      errn += verify(\"test_round: \", 17, i0[17], 0);\n+      errn += verify(\"test_round: \", 18, i0[18], 0);\n+      errn += verify(\"test_round: \", 19, i0[19], 0);\n+      errn += verify(\"test_round: \", 20, i0[20], 2);\n+      errn += verify(\"test_round: \", 21, i0[21], 10001);\n+      errn += verify(\"test_round: \", 22, i0[22], -1);\n+      errn += verify(\"test_round: \", 23, i0[23], -10000);\n+\n+      for (int i=24; i<ARRLEN; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVect.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 1234567\n+ * @summary Auto-vectorize Math.round API\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"riscv64\"\n+ * @requires vm.cpu.features ~= \".*v,.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestRoundVectRiscv64\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestRoundVectRiscv64 {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static double [] dinp;\n+  private static long   [] lout;\n+  private static float  [] finp;\n+  private static int    [] iout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"})\n+  public void test_round_double(long[] lout, double[] dinp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Math.round(dinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_double\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round_double() {\n+      dinp = new double[ARRLEN];\n+      lout = new long[ARRLEN];\n+      for (int i = 0 ; i < ARRLEN; i++) {\n+          dinp[i] = (double)i*1.4;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_double(lout , dinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"})\n+  public void test_round_float(int[] iout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          iout[i] = Math.round(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round() {\n+      finp = new float[ARRLEN];\n+      iout = new int[ARRLEN];\n+      for (int i = 0 ; i < ARRLEN; i++) {\n+          finp[i] = (float)i*1.4f;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_float(iout , finp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectRiscv64.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}