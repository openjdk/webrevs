{"files":[{"patch":"@@ -1270,0 +1270,1 @@\n+  INSN(vfcvt_x_f_v,      0b1010111, 0b001, 0b00001, 0b010010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2328,0 +2328,68 @@\n+\/\/ j.l.Math.round(float)\n+\/\/  Returns the closest int to the argument, with ties rounding to positive infinity.\n+\/\/ We need to handle 3 special cases defined by java api spec:\n+\/\/    NaN,\n+\/\/    float >= Integer.MAX_VALUE,\n+\/\/    float <= Integer.MIN_VALUE.\n+void C2_MacroAssembler::java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp,\n+                                           BasicType bt, uint vector_length) {\n+  \/\/ In riscv, there is no straight corresponding rounding mode to satisfy the behaviour defined,\n+  \/\/ in java api spec, i.e. any rounding mode can not handle some corner cases, e.g.\n+  \/\/  RNE is the closest one, but it ties to \"even\", which means 1.5\/2.5 both will be converted\n+  \/\/    to 2, instead of 2 and 3 respectively.\n+  \/\/  RUP does not work either, although java api requires \"rounding to positive infinity\",\n+  \/\/    but both 1.3\/1.8 will be converted to 2, instead of 1 and 2 respectively.\n+  \/\/\n+  \/\/ The optimal solution for non-NaN cases is:\n+  \/\/    src+0.5 => dst, with rdn rounding mode,\n+  \/\/    convert dst from float to int, with rnd rounding mode.\n+  \/\/ and, this solution works as expected for float >= Integer.MAX_VALUE and float <= Integer.MIN_VALUE.\n+  \/\/\n+  \/\/ But, we still need to handle NaN explicilty with vector mask instructions.\n+  \/\/\n+  \/\/ Check MacroAssembler::java_round_float and C2_MacroAssembler::vector_round_sve in aarch64 for more details.\n+\n+  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n+  vsetvli_helper(bt, vector_length);\n+\n+  \/\/ don't rearrage the instructions sequence order without performance testing.\n+  \/\/ check MacroAssembler::java_round_float in riscv64 for more details.\n+  mv(t0, jint_cast(0.5f));\n+  fmv_w_x(ftmp, t0);\n+\n+  \/\/ replacing vfclass with feq as performance optimization\n+  vmfeq_vv(v0, src, src);\n+  \/\/ set dst = 0 in cases of NaN\n+  vmv_v_x(dst, zr);\n+\n+  \/\/ dst = (src + 0.5) rounded down towards negative infinity\n+  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n+  vfcvt_x_f_v(dst, dst, Assembler::v0_t); \/\/ in RoundingMode::rdn\n+\n+  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n+}\n+\n+\/\/ java.lang.Math.round(double a)\n+\/\/ Returns the closest long to the argument, with ties rounding to positive infinity.\n+void C2_MacroAssembler::java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp,\n+                                            BasicType bt, uint vector_length) {\n+  \/\/ check C2_MacroAssembler::java_round_float_v above for more details.\n+\n+  csrwi(CSR_FRM, C2_MacroAssembler::rdn);\n+  vsetvli_helper(bt, vector_length);\n+\n+  mv(t0, julong_cast(0.5));\n+  fmv_d_x(ftmp, t0);\n+\n+  \/\/ replacing vfclass with feq as performance optimization\n+  vmfeq_vv(v0, src, src);\n+  \/\/ set dst = 0 in cases of NaN\n+  vmv_v_x(dst, zr);\n+\n+  \/\/ dst = (src + 0.5) rounded down towards negative infinity\n+  vfadd_vf(dst, src, ftmp, Assembler::v0_t);\n+  vfcvt_x_f_v(dst, dst, Assembler::v0_t); \/\/ in RoundingMode::rdn\n+\n+  csrwi(CSR_FRM, C2_MacroAssembler::rne);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -190,0 +190,3 @@\n+  void java_round_float_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length);\n+  void java_round_double_v(VectorRegister dst, VectorRegister src, FloatRegister ftmp, BasicType bt, uint vector_length);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1923,0 +1923,12 @@\n+    \/\/ Current test shows that, it brings performance gain when MaxVectorSize >= 32, but brings\n+    \/\/ regression when MaxVectorSize == 16. So only enable the intrinsic when MaxVectorSize >= 32.\n+    case Op_RoundVF:\n+      return UseRVV && MaxVectorSize >= 32;\n+\n+    \/\/ For double, current test shows that even with MaxVectorSize == 32, there is still some regression.\n+    \/\/ Although there is no hardware to verify it for now, from the trend of performance data on hardwares\n+    \/\/ (with vlenb == 16 and 32 respectively), it's promising to bring better performance rather than\n+    \/\/ regression for double when MaxVectorSize == 64+. So only enable the intrinsic when MaxVectorSize >= 64.\n+    case Op_RoundVD:\n+      return UseRVV && MaxVectorSize >= 64;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4718,0 +4718,28 @@\n+\/\/ ---------------- Round float\/double Vector Operations ----------------\n+\n+instruct vround_f(vReg dst, vReg src, fRegF tmp, vRegMask_V0 v0) %{\n+  match(Set dst (RoundVF src));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP v0);\n+  format %{ \"java_round_float_v $dst, $src\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vector_length = Matcher::vector_length(this);\n+    __ java_round_float_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                          as_FloatRegister($tmp$$reg), bt, vector_length);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vround_d(vReg dst, vReg src, fRegD tmp, vRegMask_V0 v0) %{\n+  match(Set dst (RoundVD src));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP v0);\n+  format %{ \"java_round_double_v $dst, $src\\t\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint vector_length = Matcher::vector_length(this);\n+    __ java_round_double_v(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg),\n+                           as_FloatRegister($tmp$$reg), bt, vector_length);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @requires os.arch == \"riscv64\"\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileThresholdScaling=0.3 -XX:-UseSuperWord\n+ *      -XX:CompileCommand=compileonly,compiler.floatingpoint.TestRoundFloatAll::test*\n+ *      compiler.floatingpoint.TestRoundFloatAll\n+ *\/\n+\n+package compiler.floatingpoint;\n+\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+\n+public class TestRoundFloatAll {\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  \/\/ return true when test fails\n+  static boolean test(int n, float f) {\n+    int actual = Math.round(f);\n+    int expected = golden_round(f);\n+    if (actual != expected) {\n+      System.err.println(\"round error, input: \" + f + \", res: \" + actual + \"expected: \" + expected + \", input hex: \" + n);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static void test() {\n+    final int ITERS = 11000;\n+    boolean fail = false;\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      float f = Float.intBitsToFloat(i);\n+      fail |= test(i, f);\n+    }\n+    if (fail) {\n+      throw new RuntimeException(\"Warmup failed\");\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int testInt = 0;\n+    do {\n+      float testFloat = Float.intBitsToFloat(testInt);\n+      fail |= test(testInt, testFloat);\n+    } while (++testInt != 0);\n+    if (fail) {\n+      throw new RuntimeException(\"Test failed\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestRoundFloatAll.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.golden;\n+\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+\n+public class GoldenRound {\n+  public static int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n+  }\n+\n+\n+  public static long golden_round(double a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(double a) { ... }\n+\n+    long longBits = Double.doubleToRawLongBits(a);\n+    long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n+            >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+    long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n+            + DoubleConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n+        \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n+        long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n+                | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n+        if (longBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (long) a;\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/golden\/GoldenRound.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 1234567\n+ * @summary Auto-vectorize Math.round API\n+ * @requires vm.compiler2.enabled\n+ * @requires os.arch == \"riscv64\"\n+ * @requires vm.cpu.features ~= \".*rvv.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestRoundVectRiscv64\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestRoundVectRiscv64 {\n+  private static final int ARRLEN = 1024;\n+  private static final int ITERS  = 11000;\n+\n+  private static double [] dinp;\n+  private static long   [] lout;\n+  private static float  [] finp;\n+  private static int    [] iout;\n+\n+  public static void main(String args[]) {\n+      TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n+                                 \"-XX:CompileThresholdScaling=0.3\");\n+      System.out.println(\"PASSED\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"})\n+  public void test_round_double(long[] lout, double[] dinp) {\n+      for (int i = 0; i < lout.length; i+=1) {\n+          lout[i] = Math.round(dinp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_double\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round_double() {\n+      dinp = new double[ARRLEN];\n+      lout = new long[ARRLEN];\n+      for (int i = 0 ; i < ARRLEN; i++) {\n+          dinp[i] = (double)i*1.4;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_double(lout , dinp);\n+      }\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"})\n+  public void test_round_float(int[] iout, float[] finp) {\n+      for (int i = 0; i < finp.length; i+=1) {\n+          iout[i] = Math.round(finp[i]);\n+      }\n+  }\n+\n+  @Run(test = {\"test_round_float\"}, mode = RunMode.STANDALONE)\n+  public void kernel_test_round() {\n+      finp = new float[ARRLEN];\n+      iout = new int[ARRLEN];\n+      for (int i = 0 ; i < ARRLEN; i++) {\n+          finp[i] = (float)i*1.4f;\n+      }\n+      for (int i = 0; i < ITERS; i++) {\n+          test_round_float(iout , finp);\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectRiscv64.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8321011\n+ * @summary Test vector intrinsic for Math.round(double) with random input in 64 bits range, verify IR at the same time.\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @requires os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"\n+ * @run main compiler.vectorization.TestRoundVectorDoubleRandom\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunInfo;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.Warmup;\n+\n+public class TestRoundVectorDoubleRandom {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final double ADD_INIT = -7500.;\n+\n+  private static final double[] input = new double[ARRLEN];\n+  private static final long [] res = new long[ARRLEN];\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=8\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=16\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=32\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"},\n+      applyIf = {\"MaxVectorSize\", \">= 64\"})\n+  static void test_round(long[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  @Run(test = \"test_round\")\n+  @Warmup(ITERS)\n+  static void test_rounds(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      double val = ADD_INIT+(double)i;\n+      input[i] = val;\n+    }\n+\n+    test_round(res, input);\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    int errn = 0;\n+    \/\/ a double precise float point is composed of 3 parts: sign\/exponent\/signicand\n+    \/\/ exponent part of a float value\n+    final int exponentShift = 52;\n+    final int exponentWidth = 11;\n+    final int exponentBound = 1 << exponentWidth;\n+    \/\/ significant part of a float value\n+    final int signicandWidth = exponentShift;\n+    final long signicandBound = 1L << signicandWidth;\n+    final int signicandNum = 256;\n+\n+    \/\/ prepare for data of significand part\n+    long signicandValues[] = new long[signicandNum];\n+    int signicandIdx = 0;\n+    for (; signicandIdx < signicandWidth; signicandIdx++) {\n+      signicandValues[signicandIdx] = 1L << signicandIdx;\n+    }\n+    for (; signicandIdx < signicandNum; signicandIdx++) {\n+      signicandValues[signicandIdx] = rand.nextLong(signicandBound);\n+    }\n+    signicandValues[rand.nextInt(signicandNum)] = 0;\n+\n+    \/\/ generate input arrays for testing, then run tests & verify results\n+\n+    \/\/ generate input arrays by combining different parts\n+    for (long sv : signicandValues) {\n+      \/\/ generate test input by combining different parts:\n+      \/\/   previously generated significand values,\n+      \/\/   random value in exponent range,\n+      \/\/   both positive and negative of previous combined values (exponent+significand)\n+      final int exponentStart = rand.nextInt(9);\n+      final int exponentStep = (1 << 3) + rand.nextInt(3);\n+      \/\/ Here, we could have iterated the whole range of exponent values, but it would\n+      \/\/ take more time to run the test, so just randomly choose some of exponent values.\n+      int ev = exponentStart;\n+      int inputIdx = 0;\n+      for (; ev < exponentBound; ev += exponentStep) {\n+        inputIdx = ev\/exponentStep;\n+        \/\/ combine exponent and significand\n+        long bits = ((long)ev << exponentShift) + sv;\n+        \/\/ combine sign(+\/-) with exponent and significand\n+        \/\/ positive values\n+        input[inputIdx*2] = Double.longBitsToDouble(bits);\n+        \/\/ negative values\n+        bits = bits | (1L << 63);\n+        input[inputIdx*2+1] = Double.longBitsToDouble(bits);\n+      }\n+      \/\/ add specific test cases where it looks like in binary format:\n+      \/\/   s111 1111 1111 xxxx xxxx xxxx xxxx xxxx ...\n+      \/\/ these are for the NaN and Inf.\n+      inputIdx = inputIdx*2+2;\n+      long bits = (1L << exponentWidth) - 1L;\n+      bits <<= exponentShift;\n+      input[inputIdx++] = Double.longBitsToDouble(bits);\n+      bits = bits | (1L << 63);\n+      input[inputIdx] = Double.longBitsToDouble(bits);\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      ev = exponentStart;\n+      inputIdx = ev\/exponentStep;\n+      for (; ev < exponentBound; ev += exponentStep) {\n+        for (int sign = 0; sign < 2; sign++) {\n+          int idx = inputIdx * 2 + sign;\n+          if (res[idx] != golden_round(input[idx])) {\n+            errn++;\n+            System.err.println(\"round error, input: \" + input[idx] +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n+                               \", input hex: \" + Double.doubleToLongBits(input[idx]) +\n+                               \", fi: \" + sv + \", ei: \" + ev + \", sign: \" + sign);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextDouble();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Double[] dv = new Double[] {\n+        +0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Double.longBitsToDouble(0x7ff0000000000001L), \/\/ another NaN\n+        Double.MIN_NORMAL,\n+        0x0.fffffffffffffp-1022,   \/\/ Maximum Subnormal Value\n+        1.5,\n+        100.5,\n+        10000.5,\n+        -1.5,\n+        -100.5,\n+        -10000.5\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @requires os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=32 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+\n+public class TestRoundVectorFloatAll {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  static void test() {\n+    float[] input = new float[ARRLEN];\n+    int [] res = new int[ARRLEN];\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(res, input);\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+    for (long l = Integer.MIN_VALUE; l <= Integer.MAX_VALUE; l+=ARRLEN) {\n+      for (int i = 0; i < ARRLEN; i++) {\n+        input[i] = Float.intBitsToFloat((int)(i+l));\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatAll.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) with random input in 32 bits range, verify IR at the same time.\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @requires os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunInfo;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.Warmup;\n+\n+public class TestRoundVectorFloatRandom {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  private static final float[] input = new float[ARRLEN];\n+  private static final int[] res = new int[ARRLEN];\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=8\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=16\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=32\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"},\n+      applyIf = {\"MaxVectorSize\", \">= 32\"})\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  @Run(test = \"test_round\")\n+  @Warmup(ITERS)\n+  static void test_rounds(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      float val = ADD_INIT+(float)i;\n+      input[i] = val;\n+    }\n+\n+    test_round(res, input);\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    int errn = 0;\n+    \/\/ a single precise float point is composed of 3 parts: sign\/exponent\/signicand\n+    \/\/ exponent part of a float value\n+    final int exponentStart = 0;\n+    final int exponentShift = 23;\n+    final int exponentWidth = 8;\n+    final int exponentBound = 1 << exponentWidth;\n+    \/\/ significant part of a float value\n+    final int signicandWidth = exponentShift;\n+    final int signicandBound = 1 << signicandWidth;\n+    final int signicandNum = 128;\n+\n+    \/\/ prepare for data of significand part\n+    int signicandValues[] = new int[signicandNum];\n+    int signicandIdx = 0;\n+    for (; signicandIdx < signicandWidth; signicandIdx++) {\n+      signicandValues[signicandIdx] = 1 << signicandIdx;\n+    }\n+    for (; signicandIdx < signicandNum; signicandIdx++) {\n+      signicandValues[signicandIdx] = rand.nextInt(signicandBound);\n+    }\n+    signicandValues[rand.nextInt(signicandNum)] = 0;\n+\n+    \/\/ generate input arrays for testing, then run tests & verify results\n+\n+    \/\/ generate input arrays by combining different parts\n+    for (int sv : signicandValues) {\n+      \/\/ generate test input by combining different parts:\n+      \/\/   previously generated significand values,\n+      \/\/   all values in exponent range,\n+      \/\/   both positive and negative of previous combined values (exponent+significand)\n+      for (int ev = exponentStart; ev < exponentBound; ev++) {\n+        \/\/ combine exponent and significand\n+        int bits = (ev << exponentShift) + sv;\n+        \/\/ combine sign(+\/-) with exponent and significand\n+        \/\/ positive values\n+        input[ev*2] = Float.intBitsToFloat(bits);\n+        \/\/ negative values\n+        bits = bits | (1 << 31);\n+        input[ev*2+1] = Float.intBitsToFloat(bits);\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int ev = exponentStart; ev < exponentBound; ev++) {\n+        for (int sign = 0; sign < 2; sign++) {\n+          int idx = ev * 2 + sign;\n+          if (res[idx] != golden_round(input[idx])) {\n+            errn++;\n+            System.err.println(\"round error, input: \" + input[idx] +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n+                               \", input hex: \" + Float.floatToIntBits(input[idx]) +\n+                               \", fi: \" + sv + \", ei: \" + ev + \", sign: \" + sign);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextFloat();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Float[] dv = new Float[] {\n+        +0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        Float.NEGATIVE_INFINITY,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+        Float.intBitsToFloat(0x7f800001), \/\/ another NaN\n+        Float.MIN_NORMAL,\n+        0x0.fffffep-126f,   \/\/ Maximum Subnormal Value\n+        1.5f,\n+        100.5f,\n+        10000.5f,\n+        -1.5f,\n+        -100.5f,\n+        -10000.5f\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}