{"files":[{"patch":"@@ -126,1 +126,0 @@\n-  size_t    src_region_idx() const   { return _src_region_idx; }\n@@ -286,3 +285,0 @@\n-    \/\/ The highest address referenced by objects in this region.\n-    inline HeapWord* highest_ref() const;\n-\n@@ -317,1 +313,0 @@\n-    inline void set_highest_ref(HeapWord* addr);\n@@ -446,1 +441,0 @@\n-  inline HeapWord*  region_to_addr(size_t region, size_t offset) const;\n@@ -453,2 +447,0 @@\n-  \/\/ Analogous to region_offset() for blocks.\n-  size_t     block_offset(const HeapWord* addr) const;\n@@ -456,3 +448,0 @@\n-  size_t     addr_to_block_idx(const oop obj) const {\n-    return addr_to_block_idx(cast_from_oop<HeapWord*>(obj));\n-  }\n@@ -460,2 +449,0 @@\n-  inline HeapWord*  block_to_addr(size_t block) const;\n-  inline size_t     region_to_block_idx(size_t region) const;\n@@ -464,2 +451,0 @@\n-  inline HeapWord*  block_align_up(HeapWord* addr) const;\n-  inline bool       is_block_aligned(HeapWord* addr) const;\n@@ -566,6 +551,0 @@\n-inline HeapWord* ParallelCompactData::RegionData::highest_ref() const\n-{\n-  DEBUG_ONLY(return _highest_ref;)\n-  NOT_DEBUG(return nullptr;)\n-}\n-\n@@ -600,10 +579,0 @@\n-inline void ParallelCompactData::RegionData::set_highest_ref(HeapWord* addr)\n-{\n-#ifdef ASSERT\n-  HeapWord* tmp = _highest_ref;\n-  while (addr > tmp) {\n-    tmp = Atomic::cmpxchg(&_highest_ref, tmp, addr);\n-  }\n-#endif  \/\/ #ifdef ASSERT\n-}\n-\n@@ -698,8 +667,0 @@\n-inline HeapWord*\n-ParallelCompactData::region_to_addr(size_t region, size_t offset) const\n-{\n-  assert(region <= _region_count, \"region out of range\");\n-  assert(offset < RegionSize, \"offset too big\");  \/\/ This may be too strict.\n-  return region_to_addr(region) + offset;\n-}\n-\n@@ -728,8 +689,0 @@\n-inline size_t\n-ParallelCompactData::block_offset(const HeapWord* addr) const\n-{\n-  assert(addr >= _heap_start, \"bad addr\");\n-  assert(addr <= _heap_end, \"bad addr\");\n-  return (size_t(addr) & BlockAddrOffsetMask) >> LogHeapWordSize;\n-}\n-\n@@ -750,13 +703,0 @@\n-inline HeapWord*\n-ParallelCompactData::block_to_addr(size_t block) const\n-{\n-  assert(block < _block_count, \"block out of range\");\n-  return _heap_start + (block << Log2BlockSize);\n-}\n-\n-inline size_t\n-ParallelCompactData::region_to_block_idx(size_t region) const\n-{\n-  return region << Log2BlocksPerRegion;\n-}\n-\n@@ -771,14 +711,0 @@\n-inline HeapWord*\n-ParallelCompactData::block_align_up(HeapWord* addr) const\n-{\n-  assert(addr >= _heap_start, \"bad addr\");\n-  assert(addr <= _heap_end, \"bad addr\");\n-  return block_align_down(addr + BlockSizeOffsetMask);\n-}\n-\n-inline bool\n-ParallelCompactData::is_block_aligned(HeapWord* addr) const\n-{\n-  return block_offset(addr) == 0;\n-}\n-\n@@ -1173,9 +1099,0 @@\n-  \/\/ Process the end of the given region range in the dense prefix.\n-  \/\/ This includes saving any object not updated.\n-  static void dense_prefix_regions_epilogue(ParCompactionManager* cm,\n-                                            size_t region_start_index,\n-                                            size_t region_end_index,\n-                                            idx_t exiting_object_offset,\n-                                            idx_t region_offset_start,\n-                                            idx_t region_offset_end);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":83,"binary":false,"changes":83,"status":"modified"}]}