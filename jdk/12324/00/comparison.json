{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  assert_cond(method != NULL);\n+  assert_cond(method != nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/abstractInterpreter_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,1 @@\n-    assert_cond(a != NULL);\n+    assert_cond(a != nullptr);\n@@ -1929,1 +1929,1 @@\n-    assert_cond(a != NULL);\n+    assert_cond(a != nullptr);\n@@ -2174,1 +2174,1 @@\n-    assert_cond(dest != NULL);                                                               \\\n+    assert_cond(dest != nullptr);                                                            \\\n@@ -2202,1 +2202,1 @@\n-    assert_cond(dest != NULL);                                                               \\\n+    assert_cond(dest != nullptr);                                                            \\\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n@@ -256,1 +256,1 @@\n-  address a = NULL;\n+  address a = nullptr;\n@@ -325,1 +325,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_CodeStubs_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-  assert(info == NULL, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n+  assert(info == nullptr, \"should never be used, idiv\/irem and ldiv\/lrem not handled by this method\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arith_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  assert(copyfunc_addr != NULL, \"generic arraycopy stub required\");\n+  assert(copyfunc_addr != nullptr, \"generic arraycopy stub required\");\n@@ -83,1 +83,1 @@\n-  \/\/ test for NULL\n+  \/\/ test for null\n@@ -223,1 +223,1 @@\n-    __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, NULL);\n+    __ check_klass_subtype_fast_path(src, dst, tmp, &cont, &slow, nullptr);\n@@ -234,1 +234,1 @@\n-    if (copyfunc_addr != NULL) { \/\/ use stub if available\n+    if (copyfunc_addr != nullptr) { \/\/ use stub if available\n@@ -245,1 +245,1 @@\n-  assert(default_type != NULL, \"NULL default_type!\");\n+  assert(default_type != nullptr, \"null default_type!\");\n@@ -302,1 +302,1 @@\n-  BasicType basic_type = default_type != NULL ? default_type->element_type()->basic_type() : T_ILLEGAL;\n+  BasicType basic_type = default_type != nullptr ? default_type->element_type()->basic_type() : T_ILLEGAL;\n@@ -306,1 +306,1 @@\n-  if (default_type == NULL) {\n+  if (default_type == nullptr) {\n@@ -311,1 +311,1 @@\n-  assert(default_type != NULL && default_type->is_array_klass() && default_type->is_loaded(),\n+  assert(default_type != nullptr && default_type->is_array_klass() && default_type->is_loaded(),\n@@ -333,1 +333,1 @@\n-  const char *name = NULL;\n+  const char *name = nullptr;\n@@ -337,1 +337,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_arraycopy_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-  guarantee(osr_entry != NULL, \"NULL osr_entry!\");\n+  guarantee(osr_entry != nullptr, \"null osr_entry!\");\n@@ -254,1 +254,1 @@\n-        __ stop(\"locked object is NULL\");\n+        __ stop(\"locked object is null\");\n@@ -291,1 +291,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -312,1 +312,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -359,1 +359,1 @@\n-  MonitorExitStub* stub = NULL;\n+  MonitorExitStub* stub = nullptr;\n@@ -387,1 +387,1 @@\n-  if (stub != NULL) {\n+  if (stub != nullptr) {\n@@ -397,1 +397,1 @@\n-  if (handler_base == NULL) {\n+  if (handler_base == nullptr) {\n@@ -430,1 +430,1 @@\n-  guarantee(info != NULL, \"Shouldn't be NULL\");\n+  guarantee(info != nullptr, \"Shouldn't be null\");\n@@ -448,1 +448,1 @@\n-  address const_addr = NULL;\n+  address const_addr = nullptr;\n@@ -485,1 +485,1 @@\n-      assert(const_addr != NULL, \"must create float constant in the constant table\");\n+      assert(const_addr != nullptr, \"must create float constant in the constant table\");\n@@ -491,1 +491,1 @@\n-      assert(const_addr != NULL, \"must create double constant in the constant table\");\n+      assert(const_addr != nullptr, \"must create double constant in the constant table\");\n@@ -506,1 +506,1 @@\n-      if (c->as_jobject() == NULL) {\n+      if (c->as_jobject() == nullptr) {\n@@ -509,1 +509,1 @@\n-        const2reg(src, FrameMap::t1_opr, lir_patch_none, NULL);\n+        const2reg(src, FrameMap::t1_opr, lir_patch_none, nullptr);\n@@ -514,1 +514,1 @@\n-      const2reg(src, FrameMap::t1_opr, lir_patch_none, NULL);\n+      const2reg(src, FrameMap::t1_opr, lir_patch_none, nullptr);\n@@ -585,1 +585,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -733,1 +733,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -803,1 +803,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -904,1 +904,1 @@\n-  move_op(opr2, result, type, lir_patch_none, NULL,\n+  move_op(opr2, result, type, lir_patch_none, nullptr,\n@@ -909,1 +909,1 @@\n-  move_op(opr1, result, type, lir_patch_none, NULL,\n+  move_op(opr1, result, type, lir_patch_none, nullptr,\n@@ -918,1 +918,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -1081,1 +1081,1 @@\n-  assert(method != NULL, \"Should have method\");\n+  assert(method != nullptr, \"Should have method\");\n@@ -1084,1 +1084,1 @@\n-  guarantee(*md != NULL, \"Sanity\");\n+  guarantee(*md != nullptr, \"Sanity\");\n@@ -1086,1 +1086,1 @@\n-  assert(*data != NULL, \"need data for type check\");\n+  assert(*data != nullptr, \"need data for type check\");\n@@ -1121,1 +1121,1 @@\n-    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+    __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -1168,2 +1168,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -1357,1 +1357,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -1367,1 +1367,1 @@\n-  if (call == NULL) {\n+  if (call == nullptr) {\n@@ -1379,1 +1379,1 @@\n-  if (stub == NULL) {\n+  if (stub == nullptr) {\n@@ -1503,1 +1503,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -1512,1 +1512,1 @@\n-    if (op->info() != NULL) {\n+    if (op->info() != nullptr) {\n@@ -1529,1 +1529,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1547,1 +1547,1 @@\n-  guarantee(md != NULL, \"Sanity\");\n+  guarantee(md != nullptr, \"Sanity\");\n@@ -1549,1 +1549,1 @@\n-  assert(data != NULL && data->is_CounterData(), \"need CounterData for calls\");\n+  assert(data != nullptr && data->is_CounterData(), \"need CounterData for calls\");\n@@ -1562,1 +1562,1 @@\n-    if (C1OptimizeVirtualCallProfiling && known_klass != NULL) {\n+    if (C1OptimizeVirtualCallProfiling && known_klass != nullptr) {\n@@ -1585,1 +1585,1 @@\n-        if (receiver == NULL) {\n+        if (receiver == nullptr) {\n@@ -1621,2 +1621,2 @@\n-  if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {\n-    if (exact_klass != NULL) {\n+  if (exact_klass == nullptr || TypeEntries::is_type_none(current_klass)) {\n+    if (exact_klass != nullptr) {\n@@ -1653,1 +1653,1 @@\n-    assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+    assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -1679,1 +1679,1 @@\n-  assert(exact_klass != NULL, \"should be\");\n+  assert(exact_klass != nullptr, \"should be\");\n@@ -1708,1 +1708,1 @@\n-    assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &&\n+    assert(ciTypeEntries::valid_ciklass(current_klass) != nullptr &&\n@@ -1747,1 +1747,1 @@\n-  bool exact_klass_set = exact_klass != NULL && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n+  bool exact_klass_set = exact_klass != nullptr && ciTypeEntries::valid_ciklass(current_klass) == exact_klass;\n@@ -1772,1 +1772,1 @@\n-    if (exact_klass != NULL) {\n+    if (exact_klass != nullptr) {\n@@ -1843,1 +1843,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -1854,1 +1854,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -1995,1 +1995,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -2005,1 +2005,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -2015,1 +2015,1 @@\n-  if (const_addr == NULL) {\n+  if (const_addr == nullptr) {\n@@ -2045,1 +2045,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -2112,2 +2112,2 @@\n-  ciMethodData* md = NULL;\n-  ciProfileData* data = NULL;\n+  ciMethodData* md = nullptr;\n+  ciProfileData* data = nullptr;\n@@ -2182,1 +2182,1 @@\n-  __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);\n+  __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, nullptr);\n@@ -2202,1 +2202,1 @@\n-        const2reg(src, FrameMap::t0_opr, lir_patch_none, NULL);\n+        const2reg(src, FrameMap::t0_opr, lir_patch_none, nullptr);\n@@ -2205,1 +2205,1 @@\n-        const2reg(src, FrameMap::t0_long_opr, lir_patch_none, NULL);\n+        const2reg(src, FrameMap::t0_long_opr, lir_patch_none, nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = NULL);\n+  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -113,1 +113,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -115,1 +115,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -117,1 +117,1 @@\n-  } else if (v->type()->as_FloatConstant() != NULL) {\n+  } else if (v->type()->as_FloatConstant() != nullptr) {\n@@ -119,1 +119,1 @@\n-  } else if (v->type()->as_DoubleConstant() != NULL) {\n+  } else if (v->type()->as_DoubleConstant() != nullptr) {\n@@ -126,1 +126,1 @@\n-  if (v->type()->as_IntConstant() != NULL) {\n+  if (v->type()->as_IntConstant() != nullptr) {\n@@ -131,1 +131,1 @@\n-  } else if (v->type()->as_ObjectConstant() != NULL) {\n+  } else if (v->type()->as_ObjectConstant() != nullptr) {\n@@ -133,1 +133,1 @@\n-  } else if (v->type()->as_LongConstant() != NULL) {\n+  } else if (v->type()->as_LongConstant() != nullptr) {\n@@ -138,1 +138,1 @@\n-  } else if (v->type()->as_FloatConstant() != NULL) {\n+  } else if (v->type()->as_FloatConstant() != nullptr) {\n@@ -140,1 +140,1 @@\n-  } else if (v->type()->as_DoubleConstant() != NULL) {\n+  } else if (v->type()->as_DoubleConstant() != nullptr) {\n@@ -147,1 +147,1 @@\n-  if (c->as_constant() != NULL) {\n+  if (c->as_constant() != nullptr) {\n@@ -281,1 +281,1 @@\n-  CodeEmitInfo* info_for_exception = NULL;\n+  CodeEmitInfo* info_for_exception = nullptr;\n@@ -425,1 +425,1 @@\n-    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), NULL);\n+    arithmetic_op_long(x->op(), x->operand(), left.result(), right.result(), nullptr);\n@@ -470,1 +470,1 @@\n-      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ irem(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -472,1 +472,1 @@\n-      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, NULL);\n+      __ idiv(left_arg->result(), right_arg->result(), x->operand(), ill, nullptr);\n@@ -506,1 +506,1 @@\n-  if (x->is_commutative() && x->y()->as_Constant() == NULL && x->x()->use_count() > x->y()->use_count()) {\n+  if (x->is_commutative() && x->y()->as_Constant() == nullptr && x->x()->use_count() > x->y()->use_count()) {\n@@ -528,1 +528,1 @@\n-    assert(count.type()->as_IntConstant() != NULL || count.type()->as_LongConstant() != NULL , \"should be\");\n+    assert(count.type()->as_IntConstant() != nullptr || count.type()->as_LongConstant() != nullptr , \"should be\");\n@@ -678,1 +678,1 @@\n-  CallingConvention* cc = NULL;\n+  CallingConvention* cc = nullptr;\n@@ -700,1 +700,1 @@\n-      if (StubRoutines::dexp() != NULL) { __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dexp() != nullptr) { __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc->args()); }\n@@ -704,1 +704,1 @@\n-      if (StubRoutines::dlog() != NULL) {  __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dlog() != nullptr) {  __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc->args()); }\n@@ -708,1 +708,1 @@\n-      if (StubRoutines::dlog10() != NULL) { __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dlog10() != nullptr) { __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc->args()); }\n@@ -712,1 +712,1 @@\n-      if (StubRoutines::dsin() != NULL) { __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dsin() != nullptr) { __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc->args()); }\n@@ -716,1 +716,1 @@\n-      if (StubRoutines::dcos() != NULL) {  __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dcos() != nullptr) {  __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc->args()); }\n@@ -720,1 +720,1 @@\n-      if (StubRoutines::dtan() != NULL) { __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dtan() != nullptr) { __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc->args()); }\n@@ -724,1 +724,1 @@\n-      if (StubRoutines::dpow() != NULL) { __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc->args()); }\n+      if (StubRoutines::dpow() != nullptr) { __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc->args()); }\n@@ -768,1 +768,1 @@\n-  ciArrayKlass* expected_type = NULL;\n+  ciArrayKlass* expected_type = nullptr;\n@@ -875,1 +875,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -908,1 +908,1 @@\n-  LIRItemList* items = new LIRItemList(i, i, NULL);\n+  LIRItemList* items = new LIRItemList(i, i, nullptr);\n@@ -915,1 +915,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -962,1 +962,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n@@ -976,1 +976,1 @@\n-  CodeStub* stub = NULL;\n+  CodeStub* stub = nullptr;\n@@ -978,1 +978,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -982,1 +982,1 @@\n-    assert(patching_info == NULL, \"can't patch this\");\n+    assert(patching_info == nullptr, \"can't patch this\");\n@@ -1005,1 +1005,1 @@\n-  CodeEmitInfo* patching_info = NULL;\n+  CodeEmitInfo* patching_info = nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  cmpxchgptr(hdr, disp_hdr, t1, t0, done, \/*fallthough*\/NULL);\n+  cmpxchgptr(hdr, disp_hdr, t1, t0, done, \/*fallthough*\/nullptr);\n@@ -102,1 +102,1 @@\n-  \/\/ location (NULL in the displaced hdr location indicates recursive locking)\n+  \/\/ location (null in the displaced hdr location indicates recursive locking)\n@@ -120,1 +120,1 @@\n-  \/\/ if the loaded hdr is NULL we had recursive locking\n+  \/\/ if the loaded hdr is null we had recursive locking\n@@ -301,1 +301,1 @@\n-  \/\/ explicit NULL check not needed since load from [klass_offset] causes a trap\n+  \/\/ explicit null check not needed since load from [klass_offset] causes a trap\n@@ -317,1 +317,1 @@\n-  bs->nmethod_entry_barrier(this, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  bs->nmethod_entry_barrier(this, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n@@ -401,2 +401,2 @@\n-  NULL, \/\/ lir_cond_belowEqual\n-  NULL, \/\/ lir_cond_aboveEqual\n+  nullptr, \/\/ lir_cond_belowEqual\n+  nullptr, \/\/ lir_cond_aboveEqual\n@@ -411,2 +411,2 @@\n-  NULL, \/\/ lir_cond_belowEqual\n-  NULL  \/\/ lir_cond_aboveEqual\n+  nullptr, \/\/ lir_cond_belowEqual\n+  nullptr  \/\/ lir_cond_aboveEqual\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-  void null_check(Register r, Label *Lnull = NULL) { MacroAssembler::null_check(r); }\n+  void null_check(Register r, Label *Lnull = nullptr) { MacroAssembler::null_check(r); }\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-  _sasm = NULL;\n+  _sasm = nullptr;\n@@ -262,1 +262,1 @@\n-  assert_cond(oop_map != NULL);\n+  assert_cond(oop_map != nullptr);\n@@ -371,1 +371,1 @@\n-  assert_cond(oop_map != NULL);\n+  assert_cond(oop_map != nullptr);\n@@ -381,1 +381,1 @@\n-  assert_cond(oop_maps != NULL);\n+  assert_cond(oop_maps != nullptr);\n@@ -395,2 +395,2 @@\n-  assert_cond(oop_maps != NULL);\n-  OopMap* oop_map = NULL;\n+  assert_cond(oop_maps != nullptr);\n+  OopMap* oop_map = nullptr;\n@@ -466,1 +466,1 @@\n-  guarantee(oop_map != NULL, \"NULL oop_map!\");\n+  guarantee(oop_map != nullptr, \"null oop_map!\");\n@@ -564,1 +564,1 @@\n-  assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+  assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -567,1 +567,1 @@\n-  assert_cond(oop_map != NULL);\n+  assert_cond(oop_map != nullptr);\n@@ -581,1 +581,1 @@\n-  assert_cond(oop_maps != NULL);\n+  assert_cond(oop_maps != nullptr);\n@@ -637,1 +637,1 @@\n-  OopMapSet* oop_maps = NULL;\n+  OopMapSet* oop_maps = nullptr;\n@@ -679,1 +679,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -682,1 +682,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -700,1 +700,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -710,1 +710,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -749,1 +749,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -758,1 +758,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -777,1 +777,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -784,1 +784,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -813,1 +813,1 @@\n-        assert_cond(oop_map != NULL);\n+        assert_cond(oop_map != nullptr);\n@@ -816,1 +816,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -867,1 +867,1 @@\n-        __ check_klass_subtype_slow_path(x14, x10, x12, x15, NULL, &miss);\n+        __ check_klass_subtype_slow_path(x14, x10, x12, x15, nullptr, &miss);\n@@ -889,1 +889,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -898,1 +898,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -911,1 +911,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -922,1 +922,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -932,1 +932,1 @@\n-        assert_cond(oop_map != NULL);\n+        assert_cond(oop_map != nullptr);\n@@ -937,1 +937,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -941,1 +941,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n@@ -1031,1 +1031,1 @@\n-        assert_cond(map != NULL);\n+        assert_cond(map != nullptr);\n@@ -1035,1 +1035,1 @@\n-        assert_cond(oop_maps != NULL);\n+        assert_cond(oop_maps != nullptr);\n@@ -1040,1 +1040,1 @@\n-        assert(deopt_blob != NULL, \"deoptimization blob must have been created\");\n+        assert(deopt_blob != nullptr, \"deoptimization blob must have been created\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+  assert(SharedRuntime::polling_page_return_handler_blob() != nullptr,\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-  RuntimeAddress stub = NULL;\n+  RuntimeAddress stub = nullptr;\n@@ -557,1 +557,1 @@\n-    assert(stub.target() != NULL, \"string_indexof_linear_ll stub has not been generated\");\n+    assert(stub.target() != nullptr, \"string_indexof_linear_ll stub has not been generated\");\n@@ -560,1 +560,1 @@\n-    assert(stub.target() != NULL, \"string_indexof_linear_ul stub has not been generated\");\n+    assert(stub.target() != nullptr, \"string_indexof_linear_ul stub has not been generated\");\n@@ -563,1 +563,1 @@\n-    assert(stub.target() != NULL, \"string_indexof_linear_uu stub has not been generated\");\n+    assert(stub.target() != nullptr, \"string_indexof_linear_uu stub has not been generated\");\n@@ -955,1 +955,1 @@\n-  RuntimeAddress stub = NULL;\n+  RuntimeAddress stub = nullptr;\n@@ -972,1 +972,1 @@\n-  assert(stub.target() != NULL, \"compare_long_string stub has not been generated\");\n+  assert(stub.target() != nullptr, \"compare_long_string stub has not been generated\");\n@@ -1214,1 +1214,1 @@\n-  NULL, \/\/ BoolTest::overflow\n+  nullptr, \/\/ BoolTest::overflow\n@@ -1218,1 +1218,1 @@\n-  NULL, \/\/ BoolTest::no_overflow\n+  nullptr, \/\/ BoolTest::no_overflow\n@@ -1224,1 +1224,1 @@\n-  NULL,\n+  nullptr,\n@@ -1228,1 +1228,1 @@\n-  NULL,\n+  nullptr,\n@@ -1237,1 +1237,1 @@\n-  NULL,  \/\/ BoolTest::overflow\n+  nullptr,  \/\/ BoolTest::overflow\n@@ -1241,1 +1241,1 @@\n-  NULL, \/\/ BoolTest::no_overflow\n+  nullptr, \/\/ BoolTest::no_overflow\n@@ -1247,1 +1247,1 @@\n-  NULL,\n+  nullptr,\n@@ -1251,1 +1251,1 @@\n-  NULL,\n+  nullptr,\n@@ -1664,1 +1664,1 @@\n-  if (ciEnv::current()->task() != NULL) {\n+  if (ciEnv::current()->task() != nullptr) {\n@@ -1666,1 +1666,1 @@\n-    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+    if (phase_output != nullptr && phase_output->in_scratch_emit_size()) {\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  if (mark == NULL) {\n+  if (mark == nullptr) {\n@@ -57,2 +57,2 @@\n-  if (base == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (base == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -89,1 +89,1 @@\n-  guarantee(stub != NULL, \"stub not found\");\n+  guarantee(stub != nullptr, \"stub not found\");\n@@ -117,1 +117,1 @@\n-  assert(stub != NULL, \"stub not found\");\n+  assert(stub != nullptr, \"stub not found\");\n@@ -138,1 +138,1 @@\n-  assert(stub != NULL, \"no stub found for static call\");\n+  assert(stub != nullptr, \"no stub found for static call\");\n","filename":"src\/hotspot\/cpu\/riscv\/compiledIC_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  \/\/ at(frame::interpreter_frame_last_sp_offset) can be NULL at safepoint preempts\n+  \/\/ at(frame::interpreter_frame_last_sp_offset) can be null at safepoint preempts\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static address decode_instruction0(address here, outputStream* st, address virtual_begin = NULL) {\n+static address decode_instruction0(address here, outputStream* st, address virtual_begin = nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/disassembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-     _oop_maps(NULL) {\n+     _oop_maps(nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -122,4 +122,4 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n+    intptr_t* sender_sp = nullptr;\n+    intptr_t* sender_unextended_sp = nullptr;\n+    address   sender_pc = nullptr;\n+    intptr_t* saved_fp =  nullptr;\n@@ -185,1 +185,1 @@\n-    if (sender_pc == NULL || sender_blob == NULL) {\n+    if (sender_pc == nullptr || sender_blob == nullptr) {\n@@ -215,1 +215,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -253,1 +253,1 @@\n-  if ((address)this->fp()[return_addr_offset] == NULL) { return false; }\n+  if ((address)this->fp()[return_addr_offset] == nullptr) { return false; }\n@@ -277,1 +277,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -342,1 +342,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -368,1 +368,1 @@\n-  return jfa->last_Java_sp() == NULL;\n+  return jfa->last_Java_sp() == nullptr;\n@@ -372,1 +372,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -403,1 +403,1 @@\n-  assert_cond(nm != NULL);\n+  assert_cond(nm != nullptr);\n@@ -418,1 +418,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -420,1 +420,1 @@\n-    if (sender_cm != NULL) {\n+    if (sender_cm != nullptr) {\n@@ -443,1 +443,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -463,1 +463,1 @@\n-  if (fp() == NULL || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+  if (fp() == nullptr || (intptr_t(fp()) & (wordSize-1)) != 0) {\n@@ -466,1 +466,1 @@\n-  if (sp() == NULL || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+  if (sp() == nullptr || (intptr_t(sp()) & (wordSize-1)) != 0) {\n@@ -525,1 +525,1 @@\n-  intptr_t* tos_addr = NULL;\n+  intptr_t* tos_addr = nullptr;\n@@ -544,1 +544,1 @@\n-        obj = (obj_p == NULL) ? (oop)NULL : *obj_p;\n+        obj = (obj_p == nullptr) ? (oop)nullptr : *obj_p;\n@@ -613,1 +613,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -628,1 +628,1 @@\n-  if (last_Java_sp() == NULL) { return; }\n+  if (last_Java_sp() == nullptr) { return; }\n@@ -631,2 +631,2 @@\n-  vmassert(last_Java_sp() != NULL, \"not called from Java code?\");\n-  vmassert(last_Java_pc() == NULL, \"already walkable\");\n+  vmassert(last_Java_sp() != nullptr, \"not called from Java code?\");\n+  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,5 +42,5 @@\n-  _pc = NULL;\n-  _sp = NULL;\n-  _unextended_sp = NULL;\n-  _fp = NULL;\n-  _cb = NULL;\n+  _pc = nullptr;\n+  _sp = nullptr;\n+  _unextended_sp = nullptr;\n+  _fp = nullptr;\n+  _cb = nullptr;\n@@ -61,1 +61,1 @@\n-  _oop_map = NULL;\n+  _oop_map = nullptr;\n@@ -65,1 +65,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -74,1 +74,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -77,1 +77,1 @@\n-    assert(_cb == NULL || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+    assert(_cb == nullptr || _cb->as_compiled_method()->insts_contains_inclusive(_pc),\n@@ -99,1 +99,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -101,2 +101,2 @@\n-  _oop_map = NULL;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _oop_map = nullptr;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n@@ -122,1 +122,1 @@\n-  if (cb != NULL) {\n+  if (cb != nullptr) {\n@@ -141,1 +141,1 @@\n-  assert(pc != NULL, \"no pc?\");\n+  assert(pc != nullptr, \"no pc?\");\n@@ -143,2 +143,2 @@\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(ptr_sp), p2i(unextended_sp), p2i(ptr_fp));\n-  _oop_map = NULL;\n+  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(ptr_sp), p2i(unextended_sp), p2i(ptr_fp));\n+  _oop_map = nullptr;\n@@ -175,1 +175,1 @@\n-  if (original_pc != NULL) {\n+  if (original_pc != nullptr) {\n@@ -195,1 +195,1 @@\n-\/\/ identity and younger\/older relationship. NULL represents an invalid (incomparable)\n+\/\/ identity and younger\/older relationship. null represents an invalid (incomparable)\n@@ -200,1 +200,1 @@\n-inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != NULL && id != NULL, \"NULL frame id\");\n+inline bool frame::is_older(intptr_t* id) const   { assert(this->id() != nullptr && id != nullptr, \"null frame id\");\n@@ -207,1 +207,1 @@\n-  return os::is_readable_pointer(ptr) ? *ptr : NULL;\n+  return os::is_readable_pointer(ptr) ? *ptr : nullptr;\n@@ -216,1 +216,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -240,1 +240,1 @@\n-  assert(mask != NULL, \"\");\n+  assert(mask != nullptr, \"\");\n@@ -290,1 +290,1 @@\n-  if (last_sp == NULL) {\n+  if (last_sp == nullptr) {\n@@ -329,1 +329,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -335,1 +335,1 @@\n-  guarantee(result_adr != NULL, \"bad register save location\");\n+  guarantee(result_adr != nullptr, \"bad register save location\");\n@@ -348,2 +348,2 @@\n-  if (_cb == NULL) return NULL;\n-  if (_cb->oop_maps() != NULL) {\n+  if (_cb == nullptr) return nullptr;\n+  if (_cb->oop_maps() != nullptr) {\n@@ -351,1 +351,1 @@\n-    if (nop != NULL && nop->displacement() != 0) {\n+    if (nop != nullptr && nop->displacement() != 0) {\n@@ -358,1 +358,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -378,1 +378,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -396,1 +396,1 @@\n-  if (_cb != NULL) {\n+  if (_cb != nullptr) {\n@@ -424,1 +424,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n@@ -431,1 +431,1 @@\n-      if (oop_map() != NULL) {\n+      if (oop_map() != nullptr) {\n@@ -437,1 +437,1 @@\n-      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n+      assert(oop_map() == nullptr || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n@@ -463,1 +463,1 @@\n-  assert(map != NULL, \"map must be set\");\n+  assert(map != nullptr, \"map must be set\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,1 +201,1 @@\n-  \/\/ crosses regions, storing NULL?\n+  \/\/ crosses regions, storing null?\n@@ -205,1 +205,1 @@\n-  \/\/ storing region crossing non-NULL, is card already dirty?\n+  \/\/ storing region crossing non-null, is card already dirty?\n@@ -226,1 +226,1 @@\n-  \/\/ storing a region crossing, non-NULL oop, card is clean.\n+  \/\/ storing a region crossing, non-null oop, card is clean.\n@@ -418,1 +418,1 @@\n-  \/\/ At this point we know new_value is non-NULL and the new_value crosses regions.\n+  \/\/ At this point we know new_value is non-null and the new_value crosses regions.\n@@ -449,1 +449,1 @@\n-  \/\/ storing region crossing non-NULL, card is clean.\n+  \/\/ storing region crossing non-null, card is clean.\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/g1\/g1BarrierSetAssembler_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-  if (bs_nm == NULL) {\n+  if (bs_nm == nullptr) {\n@@ -252,1 +252,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -307,1 +307,1 @@\n-  if (slow_path == NULL) {\n+  if (slow_path == nullptr) {\n@@ -330,1 +330,1 @@\n-  if (bs == NULL) {\n+  if (bs == nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) == NULL.\n+  \/\/ that checks that the *(rfp+frame::interpreter_frame_last_sp) is null.\n@@ -285,1 +285,1 @@\n-  address target = NULL;\n+  address target = nullptr;\n@@ -470,1 +470,1 @@\n-\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals NULL\n+\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals null\n@@ -683,1 +683,1 @@\n-  address target  = NULL;\n+  address target  = nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap NULLs past to check cast\n+define_pd_global(bool, UncommonNullCast,         true);  \/\/ Uncommon-trap nulls past to check cast\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  assert_cond(code_begin != NULL && entry_point != NULL);\n+  assert_cond(code_begin != nullptr && entry_point != nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/icBuffer_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  assert(entry != NULL, \"Entry must have been generated by now\");\n+  assert(entry != nullptr, \"Entry must have been generated by now\");\n@@ -159,1 +159,1 @@\n-    beqz(t0, L);  \/\/ if [thread->jvmti_thread_state() == NULL] then exit\n+    beqz(t0, L);  \/\/ if thread->jvmti_thread_state() is null then exit\n@@ -822,1 +822,1 @@\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n@@ -902,1 +902,1 @@\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n@@ -933,1 +933,1 @@\n-  \/\/ Test MDO to avoid the call if it is NULL.\n+  \/\/ Test MDO to avoid the call if it is null.\n@@ -1304,1 +1304,1 @@\n-  \/\/ observed the item[start_row] is NULL.\n+  \/\/ observed the item[start_row] is null.\n@@ -1322,1 +1322,1 @@\n-\/\/   if (row[0].rec != NULL) then [\n+\/\/   if (row[0].rec != nullptr) then [\n@@ -1328,1 +1328,1 @@\n-\/\/     if (row[1].rec != NULL) then [\n+\/\/     if (row[1].rec != nullptr) then [\n@@ -1334,1 +1334,1 @@\n-\/\/       if (row[2].rec != NULL) then [\n+\/\/       if (row[2].rec != nullptr) then [\n@@ -1616,1 +1616,1 @@\n-        \" last_sp != NULL\");\n+        \" last_sp != null\");\n@@ -1643,1 +1643,1 @@\n-         \" last_sp != NULL\");\n+         \" last_sp != null\");\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    \/\/ NULL last_sp until next java call\n+    \/\/ null last_sp until next java call\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-    intptr_t value = *addr == 0 ? NULL : (intptr_t)addr;\n+    intptr_t value = *addr == 0 ? nullptr : (intptr_t)addr;\n@@ -272,5 +272,5 @@\n-    _from           = NULL;\n-    _to             = NULL;\n-    _int_args       = NULL;\n-    _fp_args        = NULL;\n-    _fp_identifiers = NULL;\n+    _from           = nullptr;\n+    _to             = nullptr;\n+    _int_args       = nullptr;\n+    _fp_args        = nullptr;\n+    _fp_identifiers = nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    _last_Java_sp = NULL;\n+    _last_Java_sp = nullptr;\n@@ -45,2 +45,2 @@\n-    _last_Java_fp = NULL;\n-    _last_Java_pc = NULL;\n+    _last_Java_fp = nullptr;\n+    _last_Java_pc = nullptr;\n@@ -54,1 +54,1 @@\n-    \/\/ To act like previous version (pd_cache_state) don't NULL _last_Java_sp\n+    \/\/ To act like previous version (pd_cache_state) don't null _last_Java_sp\n@@ -57,1 +57,1 @@\n-    assert(src != NULL, \"Src should not be NULL.\");\n+    assert(src != nullptr, \"Src should not be null.\");\n@@ -59,1 +59,1 @@\n-      _last_Java_sp = NULL;\n+      _last_Java_sp = nullptr;\n@@ -68,1 +68,1 @@\n-  bool walkable(void)                            { return _last_Java_sp != NULL && _last_Java_pc != NULL; }\n+  bool walkable(void)                            { return _last_Java_sp != nullptr && _last_Java_pc != nullptr; }\n","filename":"src\/hotspot\/cpu\/riscv\/javaFrameAnchor_riscv.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-      name = NULL;  \/\/ unreachable\n+      name = nullptr;  \/\/ unreachable\n@@ -115,1 +115,1 @@\n-  assert_cond(bs != NULL);\n+  assert_cond(bs != nullptr);\n@@ -171,1 +171,1 @@\n-      slow_case_addr = NULL;  \/\/ unreachable\n+      slow_case_addr = nullptr;  \/\/ unreachable\n","filename":"src\/hotspot\/cpu\/riscv\/jniFastGetField_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-  assert(last_java_pc != NULL, \"must provide a valid PC\");\n+  assert(last_java_pc != nullptr, \"must provide a valid PC\");\n@@ -367,1 +367,1 @@\n-  assert(L_fast_path != NULL || L_slow_path != NULL, \"at least one is required\");\n+  assert(L_fast_path != nullptr || L_slow_path != nullptr, \"at least one is required\");\n@@ -371,1 +371,1 @@\n-  if (L_fast_path == NULL) {\n+  if (L_fast_path == nullptr) {\n@@ -373,1 +373,1 @@\n-  } else if (L_slow_path == NULL) {\n+  } else if (L_slow_path == nullptr) {\n@@ -400,1 +400,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -439,1 +439,1 @@\n-  const char* b = NULL;\n+  const char* b = nullptr;\n@@ -563,1 +563,1 @@\n-  beqz(value, done);           \/\/ Use NULL as-is.\n+  beqz(value, done);           \/\/ Use null as-is.\n@@ -596,1 +596,1 @@\n-  beqz(value, done);           \/\/ Use NULL as-is.\n+  beqz(value, done);           \/\/ Use null as-is.\n@@ -623,1 +623,1 @@\n-  const char* buf = NULL;\n+  const char* buf = nullptr;\n@@ -638,1 +638,1 @@\n-  mov_metadata(xmethod, (Metadata*)NULL);\n+  mov_metadata(xmethod, (Metadata*)nullptr);\n@@ -651,1 +651,1 @@\n-  if (retaddr != NULL) {\n+  if (retaddr != nullptr) {\n@@ -836,1 +836,1 @@\n-    assert_cond(dest != NULL);                                     \\\n+    assert_cond(dest != nullptr);                                  \\\n@@ -880,1 +880,1 @@\n-    assert_cond(dest != NULL);                                                        \\\n+    assert_cond(dest != nullptr);                                                     \\\n@@ -1416,1 +1416,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1430,1 +1430,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1442,1 +1442,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1450,1 +1450,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1459,1 +1459,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1469,1 +1469,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1478,1 +1478,1 @@\n-  assert_cond(branch != NULL);\n+  assert_cond(branch != nullptr);\n@@ -1506,1 +1506,1 @@\n-  assert_cond(insn_addr != NULL);\n+  assert_cond(insn_addr != nullptr);\n@@ -1881,1 +1881,1 @@\n-    if (CompressedKlassPointers::base() == NULL) {\n+    if (CompressedKlassPointers::base() == nullptr) {\n@@ -1896,1 +1896,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -1920,1 +1920,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -1976,1 +1976,1 @@\n-  _masm = NULL;\n+  _masm = nullptr;\n@@ -2025,1 +2025,1 @@\n-    \/\/ provoke OS NULL exception if reg = NULL by\n+    \/\/ provoke OS null exception if reg is null by\n@@ -2031,1 +2031,1 @@\n-    \/\/ will provoke OS NULL exception if reg = NULL\n+    \/\/ will provoke OS null exception if reg is null\n@@ -2051,1 +2051,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -2113,1 +2113,1 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n+  if (CompressedKlassPointers::base() == nullptr) {\n@@ -2148,1 +2148,1 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n+  if (CompressedKlassPointers::base() == nullptr) {\n@@ -2184,1 +2184,1 @@\n-  assert(Universe::heap() != NULL, \"java heap should be initialized\");\n+  assert(Universe::heap() != nullptr, \"java heap should be initialized\");\n@@ -2191,1 +2191,1 @@\n-    if (CompressedOops::base() != NULL) {\n+    if (CompressedOops::base() != nullptr) {\n@@ -2195,1 +2195,1 @@\n-    assert(CompressedOops::base() == NULL, \"sanity\");\n+    assert(CompressedOops::base() == nullptr, \"sanity\");\n@@ -2201,1 +2201,1 @@\n-  if (CompressedOops::base() == NULL) {\n+  if (CompressedOops::base() == nullptr) {\n@@ -2230,1 +2230,1 @@\n-\/\/ Used for storing NULLs.\n+\/\/ Used for storing nulls.\n@@ -2373,1 +2373,1 @@\n-  if (last != NULL && nativeInstruction_at(last)->is_membar() && prev == last) {\n+  if (last != nullptr && nativeInstruction_at(last)->is_membar() && prev == last) {\n@@ -2412,2 +2412,2 @@\n-  check_klass_subtype_fast_path(sub_klass, super_klass, tmp_reg, &L_success, &L_failure, NULL);\n-  check_klass_subtype_slow_path(sub_klass, super_klass, tmp_reg, noreg, &L_success, NULL);\n+  check_klass_subtype_fast_path(sub_klass, super_klass, tmp_reg, &L_success, &L_failure, nullptr);\n+  check_klass_subtype_slow_path(sub_klass, super_klass, tmp_reg, noreg, &L_success, nullptr);\n@@ -2450,1 +2450,1 @@\n-  if (fail != NULL) {\n+  if (fail != nullptr) {\n@@ -2714,1 +2714,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -2735,1 +2735,1 @@\n-  assert(CodeCache::find_blob(entry.target()) != NULL,\n+  assert(CodeCache::find_blob(entry.target()) != nullptr,\n@@ -2771,4 +2771,4 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n-  if (L_slow_path == NULL) { L_slow_path = &L_fallthrough; label_nulls++; }\n-  assert(label_nulls <= 1, \"at most one NULL in batch\");\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_slow_path == nullptr) { L_slow_path = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in batch\");\n@@ -2857,2 +2857,2 @@\n-  if (L_success == NULL)   { L_success   = &L_fallthrough; label_nulls++; }\n-  if (L_failure == NULL)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n@@ -2860,1 +2860,1 @@\n-  assert(label_nulls <= 1, \"at most one NULL in the batch\");\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n@@ -3063,2 +3063,2 @@\n-    assert (Universe::heap() != NULL, \"java heap should be initialized\");\n-    assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+    assert (Universe::heap() != nullptr, \"java heap should be initialized\");\n+    assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -3077,1 +3077,1 @@\n-  assert (oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n+  assert (oop_recorder() != nullptr, \"this assembler needs an OopRecorder\");\n@@ -3106,1 +3106,1 @@\n-        if (stub == NULL) {\n+        if (stub == nullptr) {\n@@ -3108,1 +3108,1 @@\n-          return NULL; \/\/ CodeCache is full\n+          return nullptr; \/\/ CodeCache is full\n@@ -3133,1 +3133,1 @@\n-  assert_cond(entry != NULL);\n+  assert_cond(entry != nullptr);\n@@ -3152,2 +3152,2 @@\n-  if (stub == NULL) {\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+  if (stub == nullptr) {\n+    return nullptr;  \/\/ CodeBuffer::expand failed\n@@ -3902,1 +3902,1 @@\n-    assert(zero_blocks.target() != NULL, \"zero_blocks stub has not been generated\");\n+    assert(zero_blocks.target() != nullptr, \"zero_blocks stub has not been generated\");\n@@ -3905,1 +3905,1 @@\n-      if (tpc == NULL) {\n+      if (tpc == nullptr) {\n@@ -3908,1 +3908,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -4326,1 +4326,1 @@\n-  assert_cond(map != NULL && receiver_offset != NULL);\n+  assert_cond(map != nullptr && receiver_offset != nullptr);\n@@ -4331,1 +4331,1 @@\n-  \/\/ See if oop is NULL if it is we need no handle\n+  \/\/ See if oop is null if it is we need no handle\n@@ -4343,1 +4343,1 @@\n-    \/\/ conditionally move a NULL\n+    \/\/ conditionally move a null\n@@ -4351,1 +4351,1 @@\n-    \/\/ on the stack for oop_handles and pass a handle if oop is non-NULL\n+    \/\/ on the stack for oop_handles and pass a handle if oop is non-null\n@@ -4378,1 +4378,1 @@\n-    \/\/ Store oop in handle area, may be NULL\n+    \/\/ Store oop in handle area, may be null\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    Label*  retaddr = NULL\n+    Label*  retaddr = nullptr\n@@ -222,1 +222,1 @@\n-  \/\/ Used for storing NULL. All other oop constants should be\n+  \/\/ Used for storing null. All other oop constants should be\n@@ -227,1 +227,1 @@\n-  \/\/ converting a zero (linked NULL) into a Register by giving\n+  \/\/ converting a zero (linked null) into a Register by giving\n@@ -232,1 +232,1 @@\n-  \/\/ Support for NULL-checks\n+  \/\/ Support for null-checks\n@@ -234,1 +234,1 @@\n-  \/\/ Generates code that causes a NULL OS exception if the content of reg is NULL.\n+  \/\/ Generates code that causes a null OS exception if the content of reg is null.\n@@ -295,1 +295,1 @@\n-  \/\/ One of the three labels can be NULL, meaning take the fall-through.\n+  \/\/ One of the three labels can be null, meaning take the fall-through.\n@@ -398,1 +398,1 @@\n-  static void pd_patch_instruction(address branch, address target, const char* file = NULL, int line = 0) {\n+  static void pd_patch_instruction(address branch, address target, const char* file = nullptr, int line = 0) {\n@@ -593,1 +593,1 @@\n-    assert_cond(dest != NULL);                                                                           \\\n+    assert_cond(dest != nullptr);                                                                        \\\n@@ -783,1 +783,1 @@\n-    assert_cond(dest != NULL);                                                                     \\\n+    assert_cond(dest != nullptr);                                                                  \\\n@@ -840,1 +840,1 @@\n-    assert_cond(dest != NULL);                                                                     \\\n+    assert_cond(dest != nullptr);                                                                  \\\n@@ -900,1 +900,1 @@\n-    assert_cond(dest != NULL);                                                                     \\\n+    assert_cond(dest != nullptr);                                                                  \\\n@@ -946,1 +946,1 @@\n-    assert_cond(dest != NULL);                                                                     \\\n+    assert_cond(dest != nullptr);                                                                  \\\n@@ -1142,1 +1142,1 @@\n-  \/\/ Return: the call PC or NULL if CodeCache is full.\n+  \/\/ Return: the call PC or null if CodeCache is full.\n@@ -1162,1 +1162,1 @@\n-  void clinit_barrier(Register klass, Register tmp, Label* L_fast_path = NULL, Label* L_slow_path = NULL);\n+  void clinit_barrier(Register klass, Register tmp, Label* L_fast_path = nullptr, Label* L_slow_path = nullptr);\n@@ -1333,1 +1333,1 @@\n-    assert_cond(dest != NULL);\n+    assert_cond(dest != nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    return CompressedOops::base() == NULL;\n+    return CompressedOops::base() == nullptr;\n@@ -101,1 +101,1 @@\n-    return CompressedKlassPointers::base() == NULL;\n+    return CompressedKlassPointers::base() == nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,1 +176,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -183,1 +183,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -49,1 +49,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -54,1 +54,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -59,1 +59,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -64,1 +64,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -131,1 +131,1 @@\n-  if (nm != NULL && nm->stub_contains(destination) && is_NativeCallTrampolineStub_at(destination)) {\n+  if (nm != nullptr && nm->stub_contains(destination) && is_NativeCallTrampolineStub_at(destination)) {\n@@ -160,1 +160,1 @@\n-  if (trampoline_stub_addr != NULL) {\n+  if (trampoline_stub_addr != nullptr) {\n@@ -169,1 +169,1 @@\n-    assert (trampoline_stub_addr != NULL, \"we need a trampoline\");\n+    assert (trampoline_stub_addr != nullptr, \"we need a trampoline\");\n@@ -180,1 +180,1 @@\n-  assert(code != NULL, \"Could not find the containing code blob\");\n+  assert(code != nullptr, \"Could not find the containing code blob\");\n@@ -183,1 +183,1 @@\n-  if (code != NULL && code->contains(jal_destination) && is_NativeCallTrampolineStub_at(jal_destination)) {\n+  if (code != nullptr && code->contains(jal_destination) && is_NativeCallTrampolineStub_at(jal_destination)) {\n@@ -187,1 +187,1 @@\n-  if (code != NULL && code->is_nmethod()) {\n+  if (code != nullptr && code->is_nmethod()) {\n@@ -191,1 +191,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -229,1 +229,1 @@\n-  if (nm != NULL) {\n+  if (nm != nullptr) {\n@@ -332,1 +332,1 @@\n-  assert_cond(instr != NULL);\n+  assert_cond(instr != nullptr);\n@@ -345,1 +345,1 @@\n-  assert_cond(code_pos != NULL);\n+  assert_cond(code_pos != nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,13 +71,13 @@\n-  static bool is_jal_at(address instr)        { assert_cond(instr != NULL); return extract_opcode(instr) == 0b1101111; }\n-  static bool is_jalr_at(address instr)       { assert_cond(instr != NULL); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n-  static bool is_branch_at(address instr)     { assert_cond(instr != NULL); return extract_opcode(instr) == 0b1100011; }\n-  static bool is_ld_at(address instr)         { assert_cond(instr != NULL); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n-  static bool is_load_at(address instr)       { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0000011; }\n-  static bool is_float_load_at(address instr) { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0000111; }\n-  static bool is_auipc_at(address instr)      { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0010111; }\n-  static bool is_jump_at(address instr)       { assert_cond(instr != NULL); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n-  static bool is_addi_at(address instr)       { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_at(address instr)      { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != NULL); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n-  static bool is_lui_at(address instr)        { assert_cond(instr != NULL); return extract_opcode(instr) == 0b0110111; }\n-  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != NULL); return is_lui_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_jal_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1101111; }\n+  static bool is_jalr_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n+  static bool is_branch_at(address instr)     { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100011; }\n+  static bool is_ld_at(address instr)         { assert_cond(instr != nullptr); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n+  static bool is_load_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000011; }\n+  static bool is_float_load_at(address instr) { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000111; }\n+  static bool is_auipc_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010111; }\n+  static bool is_jump_at(address instr)       { assert_cond(instr != nullptr); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n+  static bool is_addi_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_to_zr_at(address instr) { assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_lui_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110111; }\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != nullptr); return is_lui_at(instr) && extract_rd(instr) == zr; }\n@@ -85,1 +85,1 @@\n-    assert_cond(instr != NULL);\n+    assert_cond(instr != nullptr);\n@@ -316,1 +316,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -323,1 +323,1 @@\n-  assert_cond(return_address != NULL);\n+  assert_cond(return_address != nullptr);\n@@ -360,1 +360,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -381,1 +381,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -388,1 +388,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -480,1 +480,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -511,1 +511,1 @@\n-  address destination(nmethod *nm = NULL) const;\n+  address destination(nmethod *nm = nullptr) const;\n@@ -526,1 +526,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -542,1 +542,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -554,1 +554,1 @@\n-  assert_cond(addr != NULL);\n+  assert_cond(addr != nullptr);\n@@ -584,1 +584,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -606,1 +606,1 @@\n-    assert(instr != NULL, \"\");\n+    assert(instr != nullptr, \"\");\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    if (base_location != NULL) {\n+    if (base_location != nullptr) {\n@@ -40,1 +40,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/registerMap_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  address pd_location(VMReg reg) const { return NULL; }\n+  address pd_location(VMReg reg) const { return nullptr; }\n","filename":"src\/hotspot\/cpu\/riscv\/registerMap_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-      \/\/ in movoop when BarrierSet::barrier_set()->barrier_set_nmethod() != NULL\n+      \/\/ in movoop when BarrierSet::barrier_set()->barrier_set_nmethod() isn't null\n@@ -65,1 +65,1 @@\n-    if (trampoline != NULL) {\n+    if (trampoline != nullptr) {\n@@ -69,1 +69,1 @@\n-  if (orig_addr != NULL) {\n+  if (orig_addr != nullptr) {\n@@ -86,1 +86,1 @@\n-    if (trampoline != NULL) {\n+    if (trampoline != nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  assert_cond(oop_maps != NULL && oop_map != NULL);\n+  assert_cond(oop_maps != nullptr && oop_map != nullptr);\n@@ -661,1 +661,1 @@\n-  address c2i_no_clinit_check_entry = NULL;\n+  address c2i_no_clinit_check_entry = nullptr;\n@@ -698,1 +698,1 @@\n-  assert(regs2 == NULL, \"not needed on riscv\");\n+  assert(regs2 == nullptr, \"not needed on riscv\");\n@@ -1312,1 +1312,1 @@\n-                                       (OopMapSet*)NULL);\n+                                       (OopMapSet*)nullptr);\n@@ -1315,1 +1315,1 @@\n-  assert(native_func != NULL, \"must have function\");\n+  assert(native_func != nullptr, \"must have function\");\n@@ -1319,1 +1319,1 @@\n-  assert_cond(oop_maps != NULL);\n+  assert_cond(oop_maps != nullptr);\n@@ -1333,1 +1333,1 @@\n-  BasicType* in_elem_bt = NULL;\n+  BasicType* in_elem_bt = nullptr;\n@@ -1347,1 +1347,1 @@\n-  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n@@ -1471,2 +1471,2 @@\n-  assert_cond(bs != NULL);\n-  bs->nmethod_entry_barrier(masm, NULL \/* slow_path *\/, NULL \/* continuation *\/, NULL \/* guard *\/);\n+  assert_cond(bs != nullptr);\n+  bs->nmethod_entry_barrier(masm, nullptr \/* slow_path *\/, nullptr \/* continuation *\/, nullptr \/* guard *\/);\n@@ -1509,1 +1509,1 @@\n-  assert_cond(map != NULL);\n+  assert_cond(map != nullptr);\n@@ -1682,1 +1682,1 @@\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n+      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n@@ -2026,1 +2026,1 @@\n-  assert(nm != NULL, \"create native nmethod fail!\");\n+  assert(nm != nullptr, \"create native nmethod fail!\");\n@@ -2057,1 +2057,1 @@\n-  OopMap* map = NULL;\n+  OopMap* map = nullptr;\n@@ -2059,1 +2059,1 @@\n-  assert_cond(masm != NULL && oop_maps != NULL);\n+  assert_cond(masm != nullptr && oop_maps != nullptr);\n@@ -2420,1 +2420,1 @@\n-  assert(_deopt_blob != NULL, \"create deoptimization blob fail!\");\n+  assert(_deopt_blob != nullptr, \"create deoptimization blob fail!\");\n@@ -2450,1 +2450,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -2497,1 +2497,1 @@\n-  assert_cond(oop_maps != NULL && map != NULL);\n+  assert_cond(oop_maps != nullptr && map != nullptr);\n@@ -2649,2 +2649,2 @@\n-  assert_cond(oop_maps != NULL);\n-  OopMap* map = NULL;\n+  assert_cond(oop_maps != nullptr);\n+  OopMap* map = nullptr;\n@@ -2655,1 +2655,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -2658,1 +2658,1 @@\n-  address call_pc = NULL;\n+  address call_pc = nullptr;\n@@ -2773,1 +2773,1 @@\n-  assert(StubRoutines::forward_exception_entry() != NULL, \"must be generated before\");\n+  assert(StubRoutines::forward_exception_entry() != nullptr, \"must be generated before\");\n@@ -2780,1 +2780,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -2786,2 +2786,2 @@\n-  assert_cond(oop_maps != NULL);\n-  OopMap* map = NULL;\n+  assert_cond(oop_maps != nullptr);\n+  OopMap* map = nullptr;\n@@ -2896,1 +2896,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -2952,1 +2952,1 @@\n-  assert_cond(oop_maps != NULL);\n+  assert_cond(oop_maps != nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-    assert(StubRoutines::_call_stub_return_address != NULL,\n+    assert(StubRoutines::_call_stub_return_address != nullptr,\n@@ -615,1 +615,1 @@\n-    __ beqz(x10, exit); \/\/ if obj is NULL it is OK\n+    __ beqz(x10, exit); \/\/ if obj is null it is OK\n@@ -729,1 +729,1 @@\n-    const char* stub_name = NULL;\n+    const char* stub_name = nullptr;\n@@ -1121,1 +1121,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1189,1 +1189,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1472,2 +1472,2 @@\n-    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg, &L_success, &L_miss, NULL, super_check_offset);\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, NULL);\n+    __ check_klass_subtype_fast_path(sub_klass, super_klass, noreg, &L_success, &L_miss, nullptr, super_check_offset);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, noreg, noreg, &L_success, nullptr);\n@@ -1533,1 +1533,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1678,2 +1678,2 @@\n-    assert_cond(byte_copy_entry != NULL && short_copy_entry != NULL &&\n-                int_copy_entry != NULL && long_copy_entry != NULL);\n+    assert_cond(byte_copy_entry != nullptr && short_copy_entry != nullptr &&\n+                int_copy_entry != nullptr && long_copy_entry != nullptr);\n@@ -1733,3 +1733,3 @@\n-    assert_cond(byte_copy_entry != NULL && short_copy_entry != NULL &&\n-                int_copy_entry != NULL && oop_copy_entry != NULL &&\n-                long_copy_entry != NULL && checkcast_copy_entry != NULL);\n+    assert_cond(byte_copy_entry != nullptr && short_copy_entry != nullptr &&\n+                int_copy_entry != nullptr && oop_copy_entry != nullptr &&\n+                long_copy_entry != nullptr && checkcast_copy_entry != nullptr);\n@@ -1768,1 +1768,1 @@\n-    \/\/ (5) src klass and dst klass should be the same and not NULL.\n+    \/\/ (5) src klass and dst klass should be the same and not null.\n@@ -1774,1 +1774,1 @@\n-    \/\/ if [src == NULL] then return -1\n+    \/\/ if src is null then return -1\n@@ -1782,1 +1782,1 @@\n-    \/\/ if [dst == NULL] then return -1\n+    \/\/ if dst is null then return -1\n@@ -1806,1 +1806,1 @@\n-      __ bnez(scratch_src_klass, L2);   \/\/ it is broken if klass is NULL\n+      __ bnez(scratch_src_klass, L2);   \/\/ it is broken if klass is null\n@@ -1836,1 +1836,1 @@\n-    \/\/ if [src->is_Array() != NULL] then return -1\n+    \/\/ if [src->is_Array() != null] then return -1\n@@ -2179,7 +2179,7 @@\n-    address entry                     = NULL;\n-    address entry_jbyte_arraycopy     = NULL;\n-    address entry_jshort_arraycopy    = NULL;\n-    address entry_jint_arraycopy      = NULL;\n-    address entry_oop_arraycopy       = NULL;\n-    address entry_jlong_arraycopy     = NULL;\n-    address entry_checkcast_arraycopy = NULL;\n+    address entry                     = nullptr;\n+    address entry_jbyte_arraycopy     = nullptr;\n+    address entry_jshort_arraycopy    = nullptr;\n+    address entry_jint_arraycopy      = nullptr;\n+    address entry_oop_arraycopy       = nullptr;\n+    address entry_jlong_arraycopy     = nullptr;\n+    address entry_checkcast_arraycopy = nullptr;\n@@ -2201,1 +2201,1 @@\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_byte_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_byte_copy(true, entry, nullptr,\n@@ -2213,1 +2213,1 @@\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, NULL,\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_short_copy(true, entry, nullptr,\n@@ -2256,1 +2256,1 @@\n-        = generate_conjoint_oop_copy(aligned, entry, NULL, \"arrayof_oop_arraycopy_uninit\",\n+        = generate_conjoint_oop_copy(aligned, entry, nullptr, \"arrayof_oop_arraycopy_uninit\",\n@@ -2266,1 +2266,1 @@\n-    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", NULL,\n+    StubRoutines::_checkcast_arraycopy_uninit = generate_checkcast_copy(\"checkcast_arraycopy_uninit\", nullptr,\n@@ -3725,1 +3725,1 @@\n-    assert_cond(runtime_entry != NULL);\n+    assert_cond(runtime_entry != nullptr);\n@@ -3740,1 +3740,1 @@\n-    assert_cond(oop_maps != NULL && masm != NULL);\n+    assert_cond(oop_maps != nullptr && masm != nullptr);\n@@ -3776,1 +3776,1 @@\n-    assert_cond(map != NULL);\n+    assert_cond(map != nullptr);\n@@ -3801,1 +3801,1 @@\n-    assert(stub != NULL, \"create runtime stub fail!\");\n+    assert(stub != nullptr, \"create runtime stub fail!\");\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-address StubRoutines::riscv::_get_previous_sp_entry = NULL;\n+address StubRoutines::riscv::_get_previous_sp_entry = nullptr;\n@@ -39,18 +39,18 @@\n-address StubRoutines::riscv::_f2i_fixup = NULL;\n-address StubRoutines::riscv::_f2l_fixup = NULL;\n-address StubRoutines::riscv::_d2i_fixup = NULL;\n-address StubRoutines::riscv::_d2l_fixup = NULL;\n-address StubRoutines::riscv::_float_sign_mask = NULL;\n-address StubRoutines::riscv::_float_sign_flip = NULL;\n-address StubRoutines::riscv::_double_sign_mask = NULL;\n-address StubRoutines::riscv::_double_sign_flip = NULL;\n-address StubRoutines::riscv::_zero_blocks = NULL;\n-address StubRoutines::riscv::_compare_long_string_LL = NULL;\n-address StubRoutines::riscv::_compare_long_string_UU = NULL;\n-address StubRoutines::riscv::_compare_long_string_LU = NULL;\n-address StubRoutines::riscv::_compare_long_string_UL = NULL;\n-address StubRoutines::riscv::_string_indexof_linear_ll = NULL;\n-address StubRoutines::riscv::_string_indexof_linear_uu = NULL;\n-address StubRoutines::riscv::_string_indexof_linear_ul = NULL;\n-address StubRoutines::riscv::_large_byte_array_inflate = NULL;\n-address StubRoutines::riscv::_method_entry_barrier = NULL;\n+address StubRoutines::riscv::_f2i_fixup = nullptr;\n+address StubRoutines::riscv::_f2l_fixup = nullptr;\n+address StubRoutines::riscv::_d2i_fixup = nullptr;\n+address StubRoutines::riscv::_d2l_fixup = nullptr;\n+address StubRoutines::riscv::_float_sign_mask = nullptr;\n+address StubRoutines::riscv::_float_sign_flip = nullptr;\n+address StubRoutines::riscv::_double_sign_mask = nullptr;\n+address StubRoutines::riscv::_double_sign_flip = nullptr;\n+address StubRoutines::riscv::_zero_blocks = nullptr;\n+address StubRoutines::riscv::_compare_long_string_LL = nullptr;\n+address StubRoutines::riscv::_compare_long_string_UU = nullptr;\n+address StubRoutines::riscv::_compare_long_string_LU = nullptr;\n+address StubRoutines::riscv::_compare_long_string_UL = nullptr;\n+address StubRoutines::riscv::_string_indexof_linear_ll = nullptr;\n+address StubRoutines::riscv::_string_indexof_linear_uu = nullptr;\n+address StubRoutines::riscv::_string_indexof_linear_ul = nullptr;\n+address StubRoutines::riscv::_large_byte_array_inflate = nullptr;\n+address StubRoutines::riscv::_method_entry_barrier = nullptr;\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  \/\/        bcp (NULL)\n+  \/\/        bcp (null)\n@@ -162,2 +162,2 @@\n-  address fn = NULL;\n-  address entry_point = NULL;\n+  address fn = nullptr;\n+  address entry_point = nullptr;\n@@ -184,1 +184,1 @@\n-      if (StubRoutines::dsin() == NULL) {\n+      if (StubRoutines::dsin() == nullptr) {\n@@ -197,1 +197,1 @@\n-      if (StubRoutines::dcos() == NULL) {\n+      if (StubRoutines::dcos() == nullptr) {\n@@ -210,1 +210,1 @@\n-      if (StubRoutines::dtan() == NULL) {\n+      if (StubRoutines::dtan() == nullptr) {\n@@ -223,1 +223,1 @@\n-      if (StubRoutines::dlog() == NULL) {\n+      if (StubRoutines::dlog() == nullptr) {\n@@ -236,1 +236,1 @@\n-      if (StubRoutines::dlog10() == NULL) {\n+      if (StubRoutines::dlog10() == nullptr) {\n@@ -249,1 +249,1 @@\n-      if (StubRoutines::dexp() == NULL) {\n+      if (StubRoutines::dexp() == nullptr) {\n@@ -263,1 +263,1 @@\n-      if (StubRoutines::dpow() == NULL) {\n+      if (StubRoutines::dpow() == nullptr) {\n@@ -293,1 +293,1 @@\n-  if (entry_point != NULL) {\n+  if (entry_point != nullptr) {\n@@ -310,1 +310,1 @@\n-  \/\/  pop return address, reset last_sp to NULL\n+  \/\/  pop return address, reset last_sp to null\n@@ -390,1 +390,1 @@\n-  assert(!pass_oop || message == NULL, \"either oop or message but not both\");\n+  assert(!pass_oop || message == nullptr, \"either oop or message but not both\");\n@@ -407,1 +407,1 @@\n-    \/\/ kind of lame ExternalAddress can't take NULL because\n+    \/\/ kind of lame ExternalAddress can't take null because\n@@ -409,1 +409,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -428,1 +428,1 @@\n-  \/\/ and NULL it as marker that esp is now tos until next java call\n+  \/\/ and null it as marker that esp is now tos until next java call\n@@ -476,1 +476,1 @@\n-  \/\/ NULL last_sp until next java call\n+  \/\/ null last_sp until next java call\n@@ -490,1 +490,1 @@\n-  if (continuation == NULL) {\n+  if (continuation == nullptr) {\n@@ -515,1 +515,1 @@\n-  assert_cond(runtime_entry != NULL);\n+  assert_cond(runtime_entry != nullptr);\n@@ -645,1 +645,1 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != NULL, \"stub not yet generated\");\n+  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n@@ -687,1 +687,1 @@\n-      __ stop(\"synchronization object is NULL\");\n+      __ stop(\"synchronization object is null\");\n@@ -833,1 +833,1 @@\n-  \/\/ Check if local 0 != NULL\n+  \/\/ Check if local 0 isn't null\n@@ -1621,1 +1621,1 @@\n-    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument,or NULL.\n+    \/\/ Detect such a case in the InterpreterRuntime function and return the member name argument,or null.\n@@ -1717,1 +1717,1 @@\n-  assert(t != NULL && t->is_valid() && t->tos_in() == vtos, \"illegal template\");\n+  assert(t != nullptr && t->is_valid() && t->tos_in() == vtos, \"illegal template\");\n@@ -1786,1 +1786,1 @@\n-  assert(Interpreter::trace_code(t->tos_in()) != NULL, \"entry must have been generated\");\n+  assert(Interpreter::trace_code(t->tos_in()) != nullptr, \"entry must have been generated\");\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,2 +126,2 @@\n-\/\/ Store an oop (or NULL) at the Address described by obj.\n-\/\/ If val == noreg this means store a NULL\n+\/\/ Store an oop (or null) at the Address described by obj.\n+\/\/ If val == noreg this means store a null\n@@ -394,1 +394,1 @@\n-    __ mv(result, zr);  \/\/ NULL object reference\n+    __ mv(result, zr);  \/\/ null object reference\n@@ -1055,1 +1055,1 @@\n-  \/\/ do array store check - check for NULL value first\n+  \/\/ do array store check - check for null value first\n@@ -1083,1 +1083,1 @@\n-  \/\/ Have a NULL in x10, x13=array, x12=index.  Store NULL at ary[idx]\n+  \/\/ Have a null in x10, x13=array, x12=index.  Store null at ary[idx]\n@@ -1087,1 +1087,1 @@\n-  \/\/ Store a NULL\n+  \/\/ Store a null\n@@ -1722,1 +1722,1 @@\n-    \/\/ x10: osr nmethod (osr ok) or NULL (osr not possible)\n+    \/\/ x10: osr nmethod (osr ok) or null (osr not possible)\n@@ -2186,1 +2186,1 @@\n-    __ clinit_barrier(temp, t0, NULL, &clinit_barrier_slow);\n+    __ clinit_barrier(temp, t0, nullptr, &clinit_barrier_slow);\n@@ -2279,1 +2279,1 @@\n-      __ mv(c_rarg1, zr); \/\/ NULL object reference\n+      __ mv(c_rarg1, zr); \/\/ null object reference\n@@ -2284,1 +2284,1 @@\n-    \/\/ c_rarg1: object pointer or NULL\n+    \/\/ c_rarg1: object pointer or null\n@@ -2522,1 +2522,1 @@\n-    \/\/ c_rarg1: object pointer set up above (NULL if static)\n+    \/\/ c_rarg1: object pointer set up above (null if static)\n@@ -3540,1 +3540,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3595,1 +3595,1 @@\n-  \/\/ Collect counts on whether this test sees NULLs a lot or not.\n+  \/\/ Collect counts on whether this test sees nulls a lot or not.\n@@ -3604,2 +3604,2 @@\n-  \/\/ x10 = 0: obj == NULL or  obj is not an instanceof the specified klass\n-  \/\/ x10 = 1: obj != NULL and obj is     an instanceof the specified klass\n+  \/\/ x10 = 0: obj is    null or  obj is not an instanceof the specified klass\n+  \/\/ x10 = 1: obj isn't null and obj is     an instanceof the specified klass\n@@ -3666,1 +3666,1 @@\n-   \/\/ check for NULL object\n+   \/\/ check for null object\n@@ -3678,1 +3678,1 @@\n-   __ mv(c_rarg1, zr); \/\/ points to free slot or NULL\n+   __ mv(c_rarg1, zr); \/\/ points to free slot or null\n@@ -3764,1 +3764,1 @@\n-  \/\/ check for NULL object\n+  \/\/ check for null object\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-  if (_uarch != NULL && strcmp(_uarch, \"\") != 0) snprintf(buf, sizeof(buf), \"%s,\", _uarch);\n+  if (_uarch != nullptr && strcmp(_uarch, \"\") != 0) snprintf(buf, sizeof(buf), \"%s,\", _uarch);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,3 +55,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -63,1 +63,1 @@\n-  address   start_pc = NULL;\n+  address   start_pc = nullptr;\n@@ -70,1 +70,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -125,1 +125,1 @@\n-    __ stop(\"Vtable entry is NULL\");\n+    __ stop(\"Vtable entry is null\");\n@@ -147,3 +147,3 @@\n-  \/\/ Can be NULL if there is no free space in the code cache.\n-  if (s == NULL) {\n-    return NULL;\n+  \/\/ Can be null if there is no free space in the code cache.\n+  if (s == nullptr) {\n+    return nullptr;\n@@ -154,1 +154,1 @@\n-  address   start_pc = NULL;\n+  address   start_pc = nullptr;\n@@ -161,1 +161,1 @@\n-  assert_cond(masm != NULL);\n+  assert_cond(masm != nullptr);\n@@ -247,1 +247,1 @@\n-  assert(SharedRuntime::get_handle_wrong_method_stub() != NULL, \"check initialization order\");\n+  assert(SharedRuntime::get_handle_wrong_method_stub() != nullptr, \"check initialization order\");\n","filename":"src\/hotspot\/cpu\/riscv\/vtableStubs_riscv.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"}]}