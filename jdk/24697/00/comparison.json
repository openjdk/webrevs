{"files":[{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4217252\n+ * @summary Verify that scrolling beyond the visible region and scrolling\n+ *          a component smaller than the viewport is not allowed.\n+ * @library \/javax\/swing\/regtesthelpers\n+ * @build Util\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScrollRectToVisibleTest3\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.table.AbstractTableModel;\n+\n+public class ScrollRectToVisibleTest3 {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static JButton scrollButton;\n+    private static volatile int clickCount = 0;\n+    private static final String[] EXPECTED_TEXT = {\"99 x 0\", \"98 x 0\",\n+                                                   \"97 x 0\", \"96 x 0\"};\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoWaitForIdle(true);\n+\n+        SwingUtilities.invokeAndWait(ScrollRectToVisibleTest3::createTestUI);\n+        robot.waitForIdle();\n+        robot.delay(1000);\n+\n+        Rectangle frameBounds = Util.invokeOnEDT(() -> getComponentBounds(frame));\n+        robot.delay(100);\n+        Point scrollBtnLoc = Util.getCenterPoint(scrollButton);\n+\n+        robot.mouseMove(scrollBtnLoc.x, scrollBtnLoc.y);\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(50);\n+\n+        int rowHeight = Util.invokeOnEDT(() -> table.getRowHeight());\n+        for (int i = 1; i <= 4; i++) {\n+            robot.mouseMove(frameBounds.x + 50,\n+                            frameBounds.y + frameBounds.height - (rowHeight * i + 2));\n+            robot.delay(300);\n+            robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+            \/\/ 500 ms delay added so that current mouseClicked event\n+            \/\/ is processed successfully before proceeding to the next\n+            robot.delay(500);\n+        }\n+        if (clickCount != 4) {\n+            throw new RuntimeException(\"Test Failed! Expected 4 mouse clicks\"\n+                                       + \" but got \" + clickCount);\n+        }\n+    }\n+\n+    private static void createTestUI() {\n+        frame = new JFrame(\"ScrollRectToVisibleTest3\");\n+        table = new JTable(new TestModel());\n+        table.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                JTable testTable = (JTable) e.getComponent();\n+                int row = testTable.getSelectedRow();\n+                int column = testTable.getSelectedColumn();\n+                String cellContent = testTable.getValueAt(row, column).toString();\n+                if (!EXPECTED_TEXT[clickCount].equals(cellContent)) {\n+                    throw new RuntimeException((\"Test failed! Table Cell Content\"\n+                                + \" at (row %d , col %d)\\n Expected: %s vs Actual: %s\")\n+                                    .formatted(row, column,\n+                                            EXPECTED_TEXT[clickCount], cellContent));\n+                }\n+                clickCount++;\n+            }\n+        });\n+\n+        scrollButton = new JButton(\"Scroll\");\n+        scrollButton.addActionListener(ae -> {\n+            Rectangle bounds = table.getBounds();\n+            bounds.y = bounds.height + table.getRowHeight();\n+            bounds.height = table.getRowHeight();\n+            System.out.println(\"scrolling: \" + bounds);\n+            table.scrollRectToVisible(bounds);\n+            System.out.println(\"bounds: \" + table.getVisibleRect());\n+        });\n+\n+        frame.add(scrollButton, BorderLayout.NORTH);\n+        frame.add(new JScrollPane(table), BorderLayout.CENTER);\n+        frame.setSize(400, 300);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+\n+    private static class TestModel extends AbstractTableModel {\n+        @Override\n+        public String getColumnName(int column) {\n+            return Integer.toString(column);\n+        }\n+\n+        @Override\n+        public int getRowCount() {\n+            return 100;\n+        }\n+\n+        @Override\n+        public int getColumnCount() {\n+            return 5;\n+        }\n+\n+        @Override\n+        public Object getValueAt(int row, int col) {\n+            return row + \" x \" + col;\n+        }\n+\n+        @Override\n+        public boolean isCellEditable(int row, int column) { return false; }\n+\n+        @Override\n+        public void setValueAt(Object value, int row, int col) {\n+        }\n+    }\n+\n+    private static Rectangle getComponentBounds(Component c) {\n+        Point locationOnScreen = c.getLocationOnScreen();\n+        Dimension size = c.getSize();\n+        return new Rectangle(locationOnScreen, size);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JViewport\/ScrollRectToVisibleTest3.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4128110\n+ * @summary Verify that JViewport.setViewportView() and JScrollPane.setViewport()\n+ *          force a re-layout and a repaint.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual SetViewRepaint\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.GridLayout;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.JViewport;\n+\n+public class SetViewRepaint {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            Verify the following two cases:\n+\n+            1) Press \"JViewport.setViewportView()\" button and verify that\n+               the blue label is replaced by a scrolling list.\n+\n+            2) Press \"JScrollPane.setViewport()\" button and verify that\n+               the red label is replaced by a scrolling list as well.\n+\n+            In either case the display should update automatically after\n+            pressing the button.\n+\n+            If the above is true, press PASS else press FAIL.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .columns(30)\n+                .testUI(SetViewRepaint::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JFrame createTestUI() {\n+        JFrame frame = new JFrame(\"SetViewRepaint\");\n+        JPanel p1 = new JPanel(new BorderLayout());\n+        JPanel p2 = new JPanel(new BorderLayout());\n+\n+        JLabel label1 = new ColorLabel(Color.BLUE, \"Blue Label\");\n+        final JList list1 = new JList(new String[]{\"one\", \"two\", \"three\", \"four\"});\n+        final JScrollPane sp1 = new JScrollPane(label1);\n+        ActionListener doSetViewportView = e -> sp1.setViewportView(list1);\n+        JButton b1 = new JButton(\"JViewport.setViewportView()\");\n+        b1.addActionListener(doSetViewportView);\n+        p1.add(sp1, BorderLayout.CENTER);\n+        p1.add(b1, BorderLayout.SOUTH);\n+\n+        JLabel label2 = new ColorLabel(Color.RED, \"Red Label\");\n+        final JList list2 = new JList(new String[]{\"five\", \"six\", \"seven\", \"eight\"});\n+        final JScrollPane sp2 = new JScrollPane(label2);\n+        ActionListener doSetViewport = e -> {\n+            JViewport vp = new JViewport();\n+            vp.setView(list2);\n+            sp2.setViewport(vp);\n+        };\n+        JButton b2 = new JButton(\"JScrollPane.setViewport()\");\n+        b2.addActionListener(doSetViewport);\n+        p2.add(sp2, BorderLayout.CENTER);\n+        p2.add(b2, BorderLayout.SOUTH);\n+        frame.setLayout(new GridLayout(1, 2));\n+        frame.add(p1);\n+        frame.add(p2);\n+        frame.setResizable(false);\n+        frame.setSize(500, 120);\n+        return frame;\n+    }\n+\n+    private static class ColorLabel extends JLabel {\n+        ColorLabel(Color color, String text) {\n+            super(text);\n+            setForeground(Color.WHITE);\n+            setBackground(color);\n+            setOpaque(true);\n+            setHorizontalAlignment(CENTER);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JViewport\/SetViewRepaint.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}