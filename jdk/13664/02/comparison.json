{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -618,1 +618,1 @@\n-        return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);\n+        return sharedGetParameterAnnotations(parameterAnnotations);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import sun.reflect.annotation.AnnotatedTypeFactory;\n@@ -40,1 +42,0 @@\n-import sun.reflect.annotation.TypeAnnotationParser;\n@@ -42,0 +43,1 @@\n+import sun.reflect.annotation.TypeAnnotationParser;\n@@ -322,0 +324,2 @@\n+     * Returns value of {@link #getSharedParameterTypes()} if there is\n+     * no generic information or if the generic parameter types is invalid.\n@@ -324,38 +328,4 @@\n-        final boolean genericInfo = hasGenericInformation();\n-\n-        \/\/ Easy case: we don't have generic parameter information.  In\n-        \/\/ this case, we just return the result of\n-        \/\/ getParameterTypes().\n-        if (!genericInfo) {\n-            return getParameterTypes();\n-        } else {\n-            final boolean realParamData = hasRealParameterData();\n-            final Type[] genericParamTypes = getGenericParameterTypes();\n-            final Type[] nonGenericParamTypes = getSharedParameterTypes();\n-            \/\/ If we have real parameter data, then we use the\n-            \/\/ synthetic and mandate flags to our advantage.\n-            if (realParamData) {\n-                final Type[] out = new Type[nonGenericParamTypes.length];\n-                final Parameter[] params = getParameters();\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n-                    } else {\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx++;\n-                    }\n-                }\n-                return out;\n-            } else {\n-                \/\/ Otherwise, use the non-generic parameter data.\n-                \/\/ Without method parameter reflection data, we have\n-                \/\/ no way to figure out which parameters are\n-                \/\/ synthetic\/mandated, thus, no way to match up the\n-                \/\/ indexes.\n-                return genericParamTypes.length == nonGenericParamTypes.length ?\n-                    genericParamTypes : getParameterTypes();\n+        if (hasGenericInformation()) {\n+            var genericParameterTypes = getGenericInfo().getParameterTypes();\n+            if (genericParameterTypes.length == matchedParameterCount()) {\n+                return matchParameters(genericParameterTypes, Function.identity());\n@@ -364,0 +334,2 @@\n+\n+        return getSharedParameterTypes();\n@@ -389,12 +361,0 @@\n-    private Parameter[] synthesizeAllParams() {\n-        final int realparams = getParameterCount();\n-        final Parameter[] out = new Parameter[realparams];\n-        for (int i = 0; i < realparams; i++)\n-            \/\/ TODO: is there a way to synthetically derive the\n-            \/\/ modifiers?  Probably not in the general case, since\n-            \/\/ we'd have no way of knowing about them, but there\n-            \/\/ may be specific cases.\n-            out[i] = new Parameter(\"arg\" + i, 0, this, i);\n-        return out;\n-    }\n-\n@@ -425,1 +385,0 @@\n-\n@@ -427,1 +386,1 @@\n-        return parameterData().isReal;\n+        return parameterData().mappings != ParameterData.NO_REAL_DATA;\n@@ -445,0 +404,1 @@\n+        final int len = getParameterCount();\n@@ -447,2 +407,4 @@\n-            tmp = synthesizeAllParams();\n-            parameterData = new ParameterData(tmp, false);\n+            tmp = new Parameter[len];\n+            for (int i = 0; i < len; i++)\n+                tmp[i] = new Parameter(\"arg\" + i, 0, this, i);\n+            parameterData = new ParameterData(tmp, ParameterData.NO_REAL_DATA);\n@@ -451,1 +413,11 @@\n-            parameterData = new ParameterData(tmp, true);\n+            int[] mapping = new int[len];\n+            int i = 0;\n+            for (int j = 0; j < len; j++) {\n+                var p = tmp[j];\n+                if (!p.isImplicit() && !p.isSynthetic()) {\n+                    mapping[i++] = j;\n+                }\n+            }\n+            parameterData = new ParameterData(tmp, i == len\n+                    ? ParameterData.TRIVIAL_MAPPINGS\n+                    : Arrays.copyOf(mapping, i));\n@@ -458,1 +430,59 @@\n-    record ParameterData(@Stable Parameter[] parameters, boolean isReal) {}\n+    private record ParameterData(@Stable Parameter[] parameters, @Stable int[] mappings) {\n+        \/\/ mappings is declaration in source index -> formal index\n+        \/\/ empty if there's no mandated\/synthetic params, i.e. 1-on-1 mapping\n+        private static final int[] TRIVIAL_MAPPINGS = new int[0];\n+        private static final int[] NO_REAL_DATA = new int[0];\n+    }\n+\n+    \/**\n+     * Returns the number of explicit parameters we anticipate from MethodParameters\n+     * attribute.\n+     *\/\n+    int matchedParameterCount() {\n+        final int[] mappings = parameterData().mappings;\n+        return mappings.length == 0 ? getParameterCount() : mappings.length;\n+    }\n+\n+    \/**\n+     * Converts information from explicit parameters to information about all parameters,\n+     * using information from MethodParameters attribute. Guard calls checks to\n+     * {@code matchedParameterCount() == explicit.length}.\n+     *\n+     * @param <T> the type of information\n+     * @param explicit information from explicit parameters\n+     * @param implicitMapper generates information for implicit parameters\n+     * @return information about all parameters\n+     *\/\n+    <T> T[] matchParameters(final T[] explicit, Function<Class<?>, ? extends T> implicitMapper) {\n+        final int matchedCount = matchedParameterCount();\n+        assert matchedCount == explicit.length;\n+        if (matchedCount == getParameterCount()) {\n+            \/\/ trivial case\n+            return explicit;\n+        }\n+\n+        \/\/ perform shifting\n+        final int[] mappings = parameterData().mappings;\n+        final Class<?>[] allParams = getSharedParameterTypes();\n+        final int fullCount = allParams.length;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        final T[] out = (T[]) Array.newInstance(explicit.getClass().componentType(), fullCount);\n+        int j = 0;\n+        for (int i = 0; i < matchedCount; i++) {\n+            final int t = mappings[i];\n+            while (j < t) {\n+                out[j] = implicitMapper.apply(allParams[j]);\n+                j++;\n+            }\n+            out[j] = explicit[i];\n+            j++;\n+        }\n+\n+        while (j < fullCount) {\n+            out[j] = implicitMapper.apply(allParams[j]);\n+            j++;\n+        }\n+\n+        return out;\n+    }\n@@ -571,2 +601,2 @@\n-    Annotation[][] sharedGetParameterAnnotations(Class<?>[] parameterTypes,\n-                                                 byte[] parameterAnnotations) {\n+    Annotation[][] sharedGetParameterAnnotations(byte[] parameterAnnotations) {\n+        var parameterTypes = getSharedParameterTypes();\n@@ -574,2 +604,5 @@\n-        if (parameterAnnotations == null)\n-            return new Annotation[numParameters][0];\n+        if (parameterAnnotations == null) {\n+            var ret = new Annotation[numParameters][];\n+            Arrays.fill(ret, AnnotationParser.getEmptyAnnotationArray());\n+            return ret;\n+        }\n@@ -579,2 +612,6 @@\n-        if (result.length != numParameters &&\n-            handleParameterNumberMismatch(result.length, parameterTypes)) {\n+        if (result.length == matchedParameterCount()) {\n+            return matchParameters(result, _ -> AnnotationParser.getEmptyAnnotationArray());\n+        }\n+\n+        \/\/ Old routine, used for class files without MethodParameters attribute\n+        if (handleParameterNumberMismatch(result.length, parameterTypes)) {\n@@ -585,1 +622,1 @@\n-                tmp[i] = new Annotation[0];\n+                tmp[i] = AnnotationParser.getEmptyAnnotationArray();\n@@ -759,1 +796,14 @@\n-        return TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),\n+        var annotatedTypeBase = annotatedParameterTypesBase();\n+        if (annotatedTypeBase != INVALID_ANNOTATED_TYPE_BASE) {\n+            assert annotatedTypeBase.length == matchedParameterCount();\n+            var unmapped = TypeAnnotationParser.buildAnnotatedTypes(getTypeAnnotationBytes0(),\n+                    SharedSecrets.getJavaLangAccess().\n+                            getConstantPool(getDeclaringClass()),\n+                    this,\n+                    getDeclaringClass(),\n+                    annotatedTypeBase,\n+                    TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);\n+\n+            return matchParameters(unmapped, AnnotatedTypeFactory::simple);\n+        }\n+        return TypeAnnotationParser.buildAnnotatedTypesWithHeuristics(getTypeAnnotationBytes0(),\n@@ -765,1 +815,47 @@\n-                TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER);\n+                TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER,\n+                true);\n+    }\n+\n+    private static final Type[] INVALID_ANNOTATED_TYPE_BASE = new Type[0];\n+    private transient volatile @Stable Type[] annotatedParameterTypesBase;\n+\n+    \/**\n+     * Return an array of explicit-only parameter types that type annotations can build on.\n+     *\/\n+    private Type[] annotatedParameterTypesBase() {\n+        var annotatedTypeBase = this.annotatedParameterTypesBase;\n+        if (annotatedTypeBase != null) {\n+            return annotatedTypeBase;\n+        }\n+\n+        if (!hasRealParameterData()) {\n+            \/\/ Cannot assume anything without MethodParameters\n+            return this.annotatedParameterTypesBase = INVALID_ANNOTATED_TYPE_BASE;\n+        }\n+\n+        if (!hasGenericInformation()) {\n+            return this.annotatedParameterTypesBase = computeExplicitParameterTypes();\n+        }\n+\n+        var genericInfoParams = getGenericInfo().getParameterTypes();\n+        return this.annotatedParameterTypesBase = genericInfoParams.length == matchedParameterCount()\n+                ? genericInfoParams : INVALID_ANNOTATED_TYPE_BASE;\n+    }\n+\n+    \/**\n+     * Computes the explicit parameter types. Useful when there is no Signature\n+     * but synthetic or mandated parameters are present in MethodParameters.\n+     *\/\n+    private Class<?>[] computeExplicitParameterTypes() {\n+        int[] mappings = parameterData().mappings;\n+        var sharedParamTypes = getSharedParameterTypes();\n+        if (mappings.length == 0) {\n+            return sharedParamTypes;\n+        }\n+\n+        var explicitParameterTypes = new Class<?>[mappings.length];\n+        for (int i = 0; i < mappings.length; i++) {\n+            explicitParameterTypes[i] = sharedParamTypes[mappings[i]];\n+        }\n+\n+        return explicitParameterTypes;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":163,"deletions":67,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -628,1 +628,1 @@\n-     * A bridge method is a {@linkplain isSynthetic synthetic} method\n+     * A bridge method is a {@linkplain #isSynthetic synthetic} method\n@@ -811,1 +811,1 @@\n-        return sharedGetParameterAnnotations(parameterTypes, parameterAnnotations);\n+        return sharedGetParameterAnnotations(parameterAnnotations);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,12 @@\n+    \/**\n+     * Creates a simple AnnotatedType without generics or type annotations. This usually\n+     * corresponds to implicit elements, such as synthetic or mandated method parameters.\n+     *\n+     * @param type the base type\n+     * @return the created dummy type\n+     *\/\n+    public static AnnotatedType simple(Class<?> type) {\n+        return new AnnotatedTypeBaseImpl(type, LocationInfo.BASE_LOCATION, EMPTY_TYPE_ANNOTATION_ARRAY,\n+                EMPTY_TYPE_ANNOTATION_ARRAY);\n+    }\n+\n@@ -117,2 +129,1 @@\n-    static final AnnotatedType EMPTY_ANNOTATED_TYPE = new AnnotatedTypeBaseImpl(null, LocationInfo.BASE_LOCATION,\n-            EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY);\n+    static final AnnotatedType EMPTY_ANNOTATED_TYPE = simple(null);\n@@ -192,2 +203,1 @@\n-              return buildAnnotatedType(owner, LocationInfo.BASE_LOCATION,\n-                      EMPTY_TYPE_ANNOTATION_ARRAY, EMPTY_TYPE_ANNOTATION_ARRAY);\n+              return simple(owner);\n@@ -472,5 +482,1 @@\n-                return new AnnotatedType[] { buildAnnotatedType(Object.class,\n-                        LocationInfo.BASE_LOCATION,\n-                        EMPTY_TYPE_ANNOTATION_ARRAY,\n-                        EMPTY_TYPE_ANNOTATION_ARRAY)\n-                };\n+                return new AnnotatedType[] { simple(Object.class) };\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotatedTypeFactory.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -866,1 +866,1 @@\n-    static Annotation[] getEmptyAnnotationArray() { return EMPTY_ANNOTATION_ARRAY; }\n+    public static Annotation[] getEmptyAnnotationArray() { return EMPTY_ANNOTATION_ARRAY; }\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,13 @@\n+        return buildAnnotatedTypesWithHeuristics(rawAnnotations, cp, decl, container, types,\n+                filter, false);\n+    }\n+\n+    \/\/ Building an array of annotated types, legacy entrypoint kept to allow method\n+    \/\/ annotation to parameter mapping without MethodParameters attribute\n+    public static AnnotatedType[] buildAnnotatedTypesWithHeuristics(byte[] rawAnnotations,\n+                                                                    ConstantPool cp,\n+                                                                    AnnotatedElement decl,\n+                                                                    Class<?> container,\n+                                                                    Type[] types,\n+                                                                    TypeAnnotationTarget filter,\n+                                                                    boolean offsetHeuristics) {\n@@ -125,0 +138,1 @@\n+        \/\/ When heuristics is enabled (no MethodParameters attribute):\n@@ -129,1 +143,1 @@\n-        if (decl instanceof Constructor<?> ctor) {\n+        if (offsetHeuristics && decl instanceof Constructor<?> ctor) {\n@@ -151,1 +165,1 @@\n-                typeAnnotations = list.toArray(new TypeAnnotation[list.size()]);\n+                typeAnnotations = list.toArray(EMPTY_TYPE_ANNOTATION_ARRAY);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/TypeAnnotationParser.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8180892 8284333 8292275\n+ * @enablePreview\n+ * @compile -parameters ParameterMappingTest.java\n+ * @run junit ParameterMappingTest\n+ * @summary Core reflection should handle parameters correctly with or without certain attributes\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.lang.classfile.components.ClassRemapper;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.AnnotatedArrayType;\n+import java.lang.reflect.AnnotatedParameterizedType;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Checks that parameter info (generics, parameter annotations, type annotations) are\n+ * applied correctly in the presence\/absence of MethodParameters\/Signature attributes.\n+ * <p>\n+ * Note that this test does not take care of local or anonymous classes in initializers\n+ * (yet). They have an outer instance parameter in non-static initializer statements\n+ * and no outer instance parameter in static initializer statements, but their\n+ * InnerClasses flags do not indicate such static information, nor do their\n+ * EnclosingMethod indicate which type of initializer they are in.\n+ *\/\n+public class ParameterMappingTest {\n+    \/**\n+     * Loads Outer class that knows the patched inner classes, to prevent other\n+     * classloaders from loading the class file and fail on InnerClasses attribute\n+     * mismatch.\n+     *\/\n+    @BeforeAll\n+    public static void beforeTests() {\n+        load(\"Outer\", false, false);\n+    }\n+\n+    \/**\n+     * Checks when both MethodParameters and Signature are present.\n+     * This is what javac generates after JDK-8292275.\n+     *\/\n+    @Test\n+    public void testFull() {\n+        checkFullParams(\"Outer$1Local\", ACC_MANDATED, 0, 0, 0, ACC_SYNTHETIC);\n+        checkFullParams(\"Outer$Inner\", ACC_MANDATED, 0, 0, 0);\n+        checkFullParams(\"Outer$1Local$LocalInner\", ACC_MANDATED, 0, 0);\n+        checkFullParams(\"Outer$1Local$1Sub\", ACC_MANDATED, 0, 0, 0, ACC_SYNTHETIC, ACC_SYNTHETIC);\n+        checkFullParams(\"MyEnum\", ACC_SYNTHETIC, ACC_SYNTHETIC, 0, 0);\n+        checkFullParams(\"MyEnumNoGeneric\", ACC_SYNTHETIC, ACC_SYNTHETIC, 0, 0);\n+    }\n+\n+    \/**\n+     * Checks when MethodParameters is present but Signature is absent.\n+     *\/\n+    @Test\n+    public void testNoSignature() {\n+        checkNoSignatureParams(\"Outer$1Local\", ACC_MANDATED, 0, 0, 0, ACC_SYNTHETIC);\n+        checkNoSignatureParams(\"Outer$Inner\", ACC_MANDATED, 0, 0, 0);\n+        checkNoSignatureParams(\"Outer$1Local$LocalInner\", ACC_MANDATED, 0, 0);\n+        checkNoSignatureParams(\"Outer$1Local$1Sub\", ACC_MANDATED, 0, 0, 0, ACC_SYNTHETIC, ACC_SYNTHETIC);\n+        checkNoSignatureParams(\"MyEnum\", ACC_SYNTHETIC, ACC_SYNTHETIC, 0, 0);\n+        checkNoSignatureParams(\"MyEnumNoGeneric\", ACC_SYNTHETIC, ACC_SYNTHETIC, 0, 0);\n+    }\n+\n+    \/**\n+     * Checks when MethodParameters is absent but Signature is present.\n+     * This is what javac generates by default before JDK-8292275.\n+     * Core reflection will fall back to the default heuristics, preserving the old behaviors.\n+     *\/\n+    @Test\n+    public void testNoParams() {\n+        \/\/ Generic (parameterization) fails for any generics for everything\n+        \/\/ (Executable::getAllGenericParameterTypes)\n+        \/\/ Parameter annotations succeeds for enum, inner classes, fails for anonymous\/local classes\n+        \/\/ (Constructor::handleParameterNumberMismatch)\n+        \/\/ Parameter type annotations succeeds for inner classes, fails for anything else\n+        \/\/ (TypeAnnotationParser::buildAnnotatedTypesWithHeuristics)\n+        checkNoParams(\"Outer$1Local\", 5, false, false, false); \/\/ local\n+        checkNoParams(\"Outer$Inner\", 4, false, true, true); \/\/ inner\n+        checkNoParams(\"Outer$1Local$LocalInner\", 3, false, true, true); \/\/ inner\n+        checkNoParams(\"Outer$1Local$1Sub\", 6, false, false, false); \/\/ local\n+        checkNoParams(\"MyEnum\", 4, false, true, false); \/\/ enum\n+        checkNoParams(\"MyEnumNoGeneric\", 4, true, true, false); \/\/ no-generic, enum\n+    }\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private static void assertHidden(Parameter param, int access) {\n+        assertEquals(0, param.getDeclaredAnnotations().length);\n+        assertEquals(0, param.getAnnotatedType().getDeclaredAnnotations().length);\n+        assertEquals(access, param.getModifiers() & (ACC_MANDATED | ACC_SYNTHETIC));\n+    }\n+\n+    private static void assertVisible(Parameter param) {\n+        assertTrue(param.isNamePresent());\n+        assertEquals(param.getName(), param.getDeclaredAnnotation(ParamAnno.class).value());\n+\n+        checkType(param.getAnnotatedType());\n+        assertEquals(0, param.getModifiers() & (ACC_MANDATED | ACC_SYNTHETIC));\n+    }\n+\n+    private static void assertVisibleNoSignature(Parameter param) {\n+        assertTrue(param.isNamePresent());\n+        assertEquals(param.getName(), param.getDeclaredAnnotation(ParamAnno.class).value());\n+\n+        checkTypeNoSignature(param.getAnnotatedType());\n+        assertEquals(0, param.getModifiers() & (ACC_MANDATED | ACC_SYNTHETIC));\n+    }\n+\n+    private static void checkType(AnnotatedType at) {\n+        assertEquals(at.getType().getTypeName(), at.getDeclaredAnnotation(TypeAnno.class).value());\n+\n+        if (at instanceof AnnotatedParameterizedType apt) {\n+            for (var arg : apt.getAnnotatedActualTypeArguments()) {\n+                checkType(arg);\n+            }\n+        }\n+    }\n+\n+    private static void checkTypeNoSignature(AnnotatedType at) {\n+        var typeanno = at.getDeclaredAnnotation(TypeAnno.class);\n+        var targetName = typeanno.erased().isEmpty() ? typeanno.value() : typeanno.erased();\n+        assertEquals(at.getType().getTypeName(), targetName);\n+        assertTrue(at instanceof AnnotatedArrayType || at.getType() instanceof Class<?>);\n+    }\n+\n+    private static void checkFullParams(String name, int... flags) {\n+        var params = load(name, false, false).getDeclaredConstructors()[0].getParameters();\n+        assertEquals(flags.length, params.length);\n+        for (int i = 0; i < flags.length; i++) {\n+            if (flags[i] == 0) {\n+                assertVisible(params[i]);\n+            } else {\n+                assertHidden(params[i], flags[i]);\n+            }\n+        }\n+    }\n+\n+    private static void checkNoSignatureParams(String name, int... flags) {\n+        var params = load(name, false, true).getDeclaredConstructors()[0].getParameters();\n+        assertEquals(flags.length, params.length);\n+        for (int i = 0; i < flags.length; i++) {\n+            if (flags[i] == 0) {\n+                assertVisibleNoSignature(params[i]);\n+            } else {\n+                assertHidden(params[i], flags[i]);\n+            }\n+        }\n+    }\n+\n+    private static void checkNoParams(String name, int length, boolean genericSuccess, boolean paramAnnoSuccess, boolean paramTypeAnnoSuccess) {\n+        var modelParams = load(name, false, false).getDeclaredConstructors()[0].getParameters();\n+        var params = load(name, true, false).getDeclaredConstructors()[0].getParameters();\n+        assertEquals(length, params.length);\n+        for (int i = 0; i < length; i++) {\n+            var modelParam = modelParams[i];\n+            var param = params[i];\n+            assertFalse(param.isNamePresent());\n+            if (genericSuccess) {\n+                assertEquals(modelParam.getParameterizedType(), param.getParameterizedType());\n+            } else {\n+                \/\/ core reflection cannot apply generics when there's count mismatch\n+                \/\/ without MethodParameters attribute\n+                assertEquals(param.getType(), param.getParameterizedType());\n+            }\n+\n+            if (paramAnnoSuccess) {\n+                assertArrayEquals(modelParam.getAnnotations(), param.getAnnotations());\n+            }\n+\n+            if (paramTypeAnnoSuccess) {\n+                if (genericSuccess) {\n+                    assertEquals(modelParam.getAnnotatedType(), param.getAnnotatedType());\n+                } else {\n+                    \/\/ Since generics are erased, only top-level type annotations are guaranteed to be present\n+                    assertArrayEquals(modelParam.getAnnotatedType().getAnnotations(), param.getAnnotatedType().getAnnotations());\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final Map<String, Class<?>> defined = new ConcurrentHashMap<>(6 * 4);\n+\n+    private static Class<?> load(String name, boolean dropParams, boolean dropSigs) {\n+        ClassFile cf = ClassFile.of();\n+        String cn = name + (dropParams ? \"$DropParams\" : \"\") + (dropSigs ? \"$DropSigs\" : \"\");\n+        Class<?> cr;\n+        if ((cr = defined.get(cn)) != null)\n+            return cr;\n+\n+        ClassModel cm;\n+        try (var in = ParameterMappingTest.class.getResourceAsStream(\"\/\" + name + \".class\")) {\n+            Objects.requireNonNull(in);\n+            cm = cf.parse(in.readAllBytes());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+\n+        var pipedBytes = ClassRemapper.of(Map.of(cm.thisClass().asSymbol(), ClassDesc.of(cn))).remapClass(cf, cm);\n+        if (dropParams) pipedBytes = cf.transform(cf.parse(pipedBytes),\n+                ClassTransform.transformingMethods(MethodTransform.dropping(me\n+                -> me instanceof MethodParametersAttribute)));\n+        if (dropSigs) pipedBytes = cf.transform(cf.parse(pipedBytes),\n+                ClassTransform.transformingMethods(MethodTransform.dropping(me\n+                -> me instanceof SignatureAttribute)));\n+        if (!dropParams && !dropSigs) {\n+            \/\/ insert InnerClasses to prevent reflection glitches\n+            cm = cf.parse(pipedBytes);\n+            var cp = ConstantPoolBuilder.of(cm);\n+            var innerClassOpt = cm.findAttribute(Attributes.INNER_CLASSES);\n+            if (innerClassOpt.isPresent()) {\n+                var inners = innerClassOpt.get();\n+                var list = new ArrayList<>(inners.classes());\n+                for (var inner : inners.classes()) {\n+                    var innerName = inner.innerClass().asInternalName();\n+                    if (checks.contains(innerName)) {\n+                        dupInner(list, innerName + \"$DropParams\", cp, inner);\n+                        dupInner(list, innerName + \"$DropSigs\", cp, inner);\n+                        dupInner(list, innerName + \"$DropParams$DropSigs\", cp, inner);\n+                    }\n+                }\n+                final var currentModel = cm;\n+                pipedBytes = cf.build(cm.thisClass(), cp, cb -> {\n+                    for (var e : currentModel.elements()) {\n+                        if (!(e instanceof InnerClassesAttribute)) {\n+                            cb.with(e);\n+                        }\n+                    }\n+                    cb.with(InnerClassesAttribute.of(list));\n+                });\n+            }\n+        }\n+\n+        try {\n+            cr = LOOKUP.defineClass(pipedBytes);\n+            defined.put(cn, cr);\n+            return cr;\n+        } catch (IllegalAccessException iae) {\n+            throw new RuntimeException(iae);\n+        }\n+    }\n+\n+    private static void dupInner(List<InnerClassInfo> list, String name, ConstantPoolBuilder cp, InnerClassInfo original) {\n+        list.add(InnerClassInfo.of(cp.classEntry(cp.utf8Entry(name)), original.outerClass(), original.innerName(), original.flagsMask()));\n+    }\n+\n+    static final Set<String> checks = Set.of(\"Outer$Inner\", \"Outer$1Local\", \"Outer$1Local$LocalInner\", \"Outer$1Local$1Sub\");\n+}\n+\n+class Outer {\n+    class Inner<T> {\n+        \/\/ Has a leading implicit Outer instance\n+        Inner(\/\/@TypeAnno(\"receiver\") Outer Outer.this,\n+              @ParamAnno(\"v0\") @TypeAnno(value = \"T\", erased = \"java.lang.Object\") T v0,\n+              @ParamAnno(\"p0\") @TypeAnno(\"int\") int p0,\n+              @ParamAnno(\"p2\") @TypeAnno(value = \"java.util.Comparator<java.lang.Integer>\", erased = \"java.util.Comparator\") Comparator<@TypeAnno(\"java.lang.Integer\") Integer> p2) {}\n+    }\n+\n+    void method(int p) {\n+        class Local<V> {\n+            \/\/ Has a leading implicit Outer instance\n+            \/\/ and a trailing synthetic int p\n+            Local(\/\/@TypeAnno(\"receiver\") Outer Outer.this,\n+                  @ParamAnno(\"value\") @TypeAnno(value = \"V\", erased = \"java.lang.Object\") V value,\n+                  @ParamAnno(\"q\") @TypeAnno(\"int\") int q,\n+                  @ParamAnno(\"p2\") @TypeAnno(value = \"java.util.Comparator<java.lang.Integer>\", erased = \"java.util.Comparator\") Comparator<@TypeAnno(\"java.lang.Integer\") Integer> p2) {\n+                System.out.println(p + q);\n+            }\n+\n+            class LocalInner {\n+                LocalInner(\/\/@TypeAnno(\"receiver\") Local<@TypeAnno(\"V\") V> Local.this,\n+                           @ParamAnno(\"a\") @TypeAnno(\"int\") int a,\n+                           @ParamAnno(\"p2\") @TypeAnno(value = \"java.util.Comparator<java.lang.Integer>\", erased = \"java.util.Comparator\") Comparator<@TypeAnno(\"java.lang.Integer\") Integer> p2) {\n+                }\n+            }\n+\n+            void method(long r) {\n+                class Sub<P> extends Local<P> {\n+                    Sub(\/\/\n+                        @ParamAnno(\"value\") @TypeAnno(value = \"P\", erased = \"java.lang.Object\") P value,\n+                        @ParamAnno(\"q\") @TypeAnno(\"int\") int q,\n+                        @ParamAnno(\"p2\") @TypeAnno(value = \"java.util.Comparator<java.lang.Integer>\", erased = \"java.util.Comparator\") Comparator<@TypeAnno(\"java.lang.Integer\") Integer> p2) {\n+                        super(value, q, p2);\n+                        System.out.println(p + q + r);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+enum MyEnum {\n+    ;\n+    \/\/ 8284333: enum constructor and type annotation\n+    MyEnum(@ParamAnno(\"p0\") @TypeAnno(\"int\") int p0,\n+           @ParamAnno(\"p2\") @TypeAnno(value = \"java.util.Comparator<java.lang.Integer>\", erased = \"java.util.Comparator\") Comparator<@TypeAnno(\"java.lang.Integer\") Integer> p2) {}\n+}\n+\n+enum MyEnumNoGeneric {\n+    ;\n+    \/\/ This constructor has a signature, make sure it works with only methodparameters (no signature)\n+    MyEnumNoGeneric(@ParamAnno(\"sq\") @TypeAnno(\"int\") int sq,\n+                    @ParamAnno(\"pr\") @TypeAnno(\"java.lang.Object\") Object pr) {}\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface TypeAnno {\n+    String value();\n+\n+    String erased() default \"\";\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.PARAMETER)\n+@interface ParamAnno {\n+    String value();\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Executable\/ParameterMappingTest.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"}]}