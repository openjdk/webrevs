{"files":[{"patch":"@@ -89,1 +89,1 @@\n-import jdk.internal.classfile.impl.TransformingCodeBuilder;\n+\n@@ -195,1 +195,1 @@\n-        handler.accept(new TransformingCodeBuilder(this, resolved.consumer()));\n+        handler.accept(new ChainedCodeBuilder(this, resolved.consumer()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-        terminalMaxLocals = topLocal(terminal);\n-        terminal.with((LabelTarget) startLabel);\n+        terminalMaxLocals = terminal.curTopLocal();\n+        parent.with((LabelTarget) startLabel);\n@@ -59,2 +59,2 @@\n-        terminal.with((LabelTarget) endLabel);\n-        if (terminalMaxLocals != topLocal(terminal)) {\n+        parent.with((LabelTarget) endLabel);\n+        if (terminalMaxLocals != terminal.curTopLocal()) {\n@@ -76,4 +76,2 @@\n-            case ChainedCodeBuilder b -> topLocal(b.terminal);\n-            case DirectCodeBuilder b -> b.curTopLocal();\n-            case BufferedCodeBuilder b -> b.curTopLocal();\n-            case TransformingCodeBuilder b -> topLocal(b.delegate);\n+            case ChainedCodeBuilder b -> b.terminal.curTopLocal();\n+            case TerminalCodeBuilder b -> b.curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    private final ClassBuilder downstream;\n@@ -42,1 +41,0 @@\n-        this.downstream = downstream;\n@@ -63,1 +61,1 @@\n-        return downstream.with(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -67,0 +65,1 @@\n+        return this;\n@@ -75,1 +74,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n@@ -81,1 +81,1 @@\n-        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n@@ -85,0 +85,1 @@\n+        return this;\n@@ -92,1 +93,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    final MethodBuilder downstream;\n@@ -45,1 +44,0 @@\n-        this.downstream = downstream;\n@@ -61,1 +59,1 @@\n-        return downstream.with(terminal.bufferedCodeBuilder(null)\n+        consumer.accept(terminal.bufferedCodeBuilder(null)\n@@ -64,0 +62,1 @@\n+        return this;\n@@ -70,1 +69,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-        permits BufferedCodeBuilder, CodeImpl, DirectCodeBuilder {\n+        permits TerminalCodeBuilder, CodeImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n-public sealed interface TerminalCodeBuilder extends CodeBuilder\n-        permits DirectCodeBuilder, BufferedCodeBuilder, TransformingCodeBuilder {\n-\n+public sealed interface TerminalCodeBuilder extends CodeBuilder, LabelContext\n+        permits DirectCodeBuilder, BufferedCodeBuilder {\n+    int curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeModel;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-\n-public final class TransformingCodeBuilder implements TerminalCodeBuilder {\n-\n-    final CodeBuilder delegate;\n-    final Consumer<CodeElement> consumer;\n-\n-    public TransformingCodeBuilder(CodeBuilder delegate, Consumer<CodeElement> consumer) {\n-        this.delegate = delegate;\n-        this.consumer = consumer;\n-    }\n-\n-    @Override\n-    public CodeBuilder with(CodeElement e) {\n-        consumer.accept(e);\n-        return this;\n-    }\n-\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return delegate.original();\n-    }\n-\n-    @Override\n-    public Label newLabel() {\n-        return delegate.newLabel();\n-    }\n-\n-    @Override\n-    public Label startLabel() {\n-        return delegate.startLabel();\n-    }\n-\n-    @Override\n-    public Label endLabel() {\n-        return delegate.endLabel();\n-    }\n-\n-    @Override\n-    public int receiverSlot() {\n-        return delegate.receiverSlot();\n-    }\n-\n-    @Override\n-    public int parameterSlot(int paramNo) {\n-        return delegate.parameterSlot(paramNo);\n-    }\n-\n-    @Override\n-    public int allocateLocal(TypeKind typeKind) {\n-        return delegate.allocateLocal(typeKind);\n-    }\n-\n-    @Override\n-    public ConstantPoolBuilder constantPool() {\n-        return delegate.constantPool();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformingCodeBuilder.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8336010\n@@ -29,0 +30,12 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.FieldTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -42,0 +55,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -44,0 +60,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -129,0 +147,145 @@\n+    \/**\n+     * Test to ensure class elements, such as field and\n+     * methods defined with transform\/with, are visible\n+     * to next transforms.\n+     *\/\n+    @Test\n+    void testClassChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+        var otherCm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethodBody(\"baz\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withField(\"baz\", CD_long, ACC_STATIC)));\n+\n+        var methodBaz = otherCm.methods().getFirst();\n+        var fieldBaz = otherCm.fields().getFirst();\n+\n+        ClassTransform transform1 = ClassTransform.endHandler(cb -> {\n+            ClassBuilder ret;\n+            ret = cb.withMethodBody(\"bar\", MTD_void, ACC_STATIC, CodeBuilder::return_);\n+            assertSame(cb, ret);\n+            ret = cb.transformMethod(methodBaz, MethodTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+            ret = cb.withField(\"bar\", CD_int, ACC_STATIC);\n+            assertSame(cb, ret);\n+            ret = cb.transformField(fieldBaz, FieldTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+        });\n+\n+        Set<String> methodNames = new HashSet<>();\n+        Set<String> fieldNames = new HashSet<>();\n+        ClassTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                methodNames.add(mm.methodName().stringValue());\n+            }\n+            if (ce instanceof FieldModel fm) {\n+                fieldNames.add(fm.fieldName().stringValue());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, transform1.andThen(transform2));\n+\n+        assertEquals(Set.of(INIT_NAME, \"foo\", \"bar\", \"baz\"), methodNames);\n+        assertEquals(Set.of(\"bar\", \"baz\"), fieldNames);\n+    }\n+\n+    \/**\n+     * Test to ensure method elements, such as generated\n+     * or transformed code, are visible to transforms.\n+     *\/\n+    @Test\n+    void testMethodChaining() throws Exception {\n+        var mtd = MethodTypeDesc.of(CD_String);\n+\n+        var cf = ClassFile.of();\n+\n+        \/\/ withCode\n+        var cm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethod(\"baz\", mtd, ACC_STATIC | ACC_NATIVE, _ -> {})));\n+\n+        MethodTransform transform1 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.withCode(cob -> cob.loadConstant(\"foo\").areturn());\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawWithCode = { false };\n+        MethodTransform transform2 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawWithCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform1.andThen(transform2)));\n+\n+        assertTrue(sawWithCode[0], \"Code attribute generated not visible\");\n+\n+        \/\/ transformCode\n+        var outerCm = cf.parse(testClassPath);\n+        var foo = outerCm.methods().stream()\n+            .filter(m -> m.flags().has(AccessFlag.STATIC))\n+            .findFirst().orElseThrow();\n+\n+        MethodTransform transform3 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.transformCode(foo.code().orElseThrow(), CodeTransform.ACCEPT_ALL);\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawTransformCode = { false };\n+        MethodTransform transform4 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawTransformCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(transform3.andThen(transform4)));\n+\n+        assertTrue(sawTransformCode[0], \"Code attribute transformed not visible\");\n+    }\n+\n+    \/**\n+     * Test to ensure code elements, such as code block\n+     * begin and end labels, are visible to transforms.\n+     *\/\n+    @Test\n+    void testCodeChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+\n+        CodeTransform transform1 = new CodeTransform() {\n+            @Override\n+            public void atStart(CodeBuilder builder) {\n+                builder.block(bcb -> {\n+                    bcb.loadConstant(9876L);\n+                    bcb.goto_(bcb.endLabel());\n+                });\n+            }\n+\n+            @Override\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.with(element);\n+            }\n+        };\n+        Set<Label> leaveLabels = new HashSet<>();\n+        Set<Label> targetedLabels = new HashSet<>();\n+        CodeTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof BranchInstruction bi) {\n+                leaveLabels.add(bi.target());\n+            }\n+            if (ce instanceof LabelTarget lt) {\n+                targetedLabels.add(lt.label());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transformClass(cm, ClassTransform.transformingMethods(MethodTransform\n+            .transformingCode(transform1.andThen(transform2))));\n+\n+        leaveLabels.removeIf(targetedLabels::contains);\n+        assertTrue(leaveLabels.isEmpty(), () -> \"Some labels are not bounded: \" + leaveLabels);\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"modified"}]}