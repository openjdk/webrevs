{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/deferredStatic.hpp\"\n@@ -42,1 +43,33 @@\n-static PlatformMutex* GlobalChunkPoolMutex = nullptr;\n+\/\/ It's recursive because NMT may recursively lock it when NMT has detected\n+\/\/ a memory corruption in an Arena and the VM exits.\n+class RecursivePlatformMutex : public PlatformMutex {\n+  int64_t _recursions;\n+  intx _owner;\n+  static constexpr intx no_owner_sentinel = -1;\n+public:\n+  RecursivePlatformMutex()\n+  : PlatformMutex(), _recursions(0), _owner(no_owner_sentinel) {}\n+\n+  void lock() {\n+    intx current = os::current_thread_id();\n+    if (current == _owner) {\n+      _recursions++;\n+    } else {\n+      PlatformMutex::lock();\n+      _owner = current;\n+      _recursions++;\n+      assert(_recursions == 1, \"should be\");\n+    }\n+  }\n+\n+  void unlock() {\n+    assert(_owner == os::current_thread_id(), \"must be\");\n+    _recursions--;\n+    if (_recursions == 0) {\n+      _owner = no_owner_sentinel;\n+      PlatformMutex::unlock();\n+    }\n+  }\n+};\n+\n+static DeferredStatic<RecursivePlatformMutex> GlobalChunkPoolMutex;\n@@ -45,1 +78,1 @@\n-  GlobalChunkPoolMutex = new PlatformMutex();\n+  GlobalChunkPoolMutex.initialize();\n@@ -49,1 +82,0 @@\n-  assert(GlobalChunkPoolMutex != nullptr, \"must be initialized\");\n@@ -229,1 +261,1 @@\n- public:\n+public:\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- public:\n+public:\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}