{"files":[{"patch":"@@ -168,0 +168,8 @@\n+    \/\/ Creates a new root constructor with a custom accessor for serialization hooks.\n+    Constructor<T> newWithAccessor(ConstructorAccessor accessor) {\n+        var res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot,\n+                signature, annotations, parameterAnnotations);\n+        res.constructorAccessor = accessor;\n+        return res;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,15 +176,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -34,53 +34,3 @@\n-\n-class ReflectAccess implements jdk.internal.access.JavaLangReflectAccess {\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations)\n-    {\n-        return new Constructor<>(declaringClass,\n-                                  parameterTypes,\n-                                  checkedExceptions,\n-                                  modifiers,\n-                                  slot,\n-                                  signature,\n-                                  annotations,\n-                                  parameterAnnotations);\n-    }\n-\n-    public MethodAccessor getMethodAccessor(Method m) {\n-        return m.getMethodAccessor();\n-    }\n-\n-    public void setMethodAccessor(Method m, MethodAccessor accessor) {\n-        m.setMethodAccessor(accessor);\n-    }\n-\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return c.getConstructorAccessor();\n-    }\n-\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        c.setConstructorAccessor(accessor);\n-    }\n-\n-    public int getConstructorSlot(Constructor<?> c) {\n-        return c.getSlot();\n-    }\n-\n-    public String getConstructorSignature(Constructor<?> c) {\n-        return c.getSignature();\n-    }\n-\n-    public byte[] getConstructorAnnotations(Constructor<?> c) {\n-        return c.getRawAnnotations();\n-    }\n-\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c) {\n-        return c.getRawParameterAnnotations();\n+final class ReflectAccess implements JavaLangReflectAccess {\n+    public <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor) {\n+        return original.newWithAccessor(accessor);\n@@ -108,3 +58,0 @@\n-    public Method      leafCopyMethod(Method arg) {\n-        return arg.leafCopy();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":58,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-    internals of java.lang.reflect. *\/\n-\n+    internals of java.lang.reflect. Use as a last resort! *\/\n@@ -35,25 +34,5 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-      per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations);\n-\n-    \/** Gets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public MethodAccessor getMethodAccessor(Method m);\n-\n-    \/** Sets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public void setMethodAccessor(Method m, MethodAccessor accessor);\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c);\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor);\n+    \/**\n+     * Creates a new root constructor from the original one, with\n+     * a custom accessor. Used by serialization hooks.\n+     *\/\n+    <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor);\n@@ -64,12 +43,0 @@\n-    \/** Gets the \"slot\" field from a Constructor (used for serialization) *\/\n-    public int getConstructorSlot(Constructor<?> c);\n-\n-    \/** Gets the \"signature\" field from a Constructor (used for serialization) *\/\n-    public String getConstructorSignature(Constructor<?> c);\n-\n-    \/** Gets the \"annotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorAnnotations(Constructor<?> c);\n-\n-    \/** Gets the \"parameterAnnotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c);\n-\n@@ -82,1 +49,0 @@\n-    \/\/\n@@ -85,1 +51,0 @@\n-    \/\/\n@@ -90,3 +55,0 @@\n-    \/** Makes a copy of this non-root a Method *\/\n-    public Method      leafCopyMethod(Method arg);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-    for this purpose, namely the loss of compile-time checking. *\/\n+    for this purpose, namely the loss of compile-time checking.\n+ * <p><strong>\n+ * Usage of these APIs often means bad encapsulation designs,\n+ * increased complexity and lack of sustainability.\n+ * Use this only as a last resort!\n+ * <\/strong>\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,35 +182,0 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-        per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public Constructor<?> newConstructor(Class<?> declaringClass,\n-                                         Class<?>[] parameterTypes,\n-                                         Class<?>[] checkedExceptions,\n-                                         int modifiers,\n-                                         int slot,\n-                                         String signature,\n-                                         byte[] annotations,\n-                                         byte[] parameterAnnotations)\n-    {\n-        return langReflectAccess.newConstructor(declaringClass,\n-                                                parameterTypes,\n-                                                checkedExceptions,\n-                                                modifiers,\n-                                                slot,\n-                                                signature,\n-                                                annotations,\n-                                                parameterAnnotations);\n-    }\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -228,1 +193,2 @@\n-        return langReflectAccess.leafCopyMethod(arg);\n+        Method root = langReflectAccess.getRoot(arg);\n+        return langReflectAccess.copyMethod(root);\n@@ -231,1 +197,0 @@\n-\n@@ -372,9 +337,0 @@\n-\n-        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getExceptionTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             langReflectAccess.getConstructorSlot(constructorToCall),\n-                                             langReflectAccess.getConstructorSignature(constructorToCall),\n-                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n-                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n@@ -389,1 +345,1 @@\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -391,1 +347,4 @@\n-        setConstructorAccessor(ctor, acc);\n+        \/\/ Unlike other root constructors, this constructor is not copied for mutation\n+        \/\/ but directly mutated, as it is not cached. To cache this constructor,\n+        \/\/ setAccessible call must be done on a copy and return that copy instead.\n+        Constructor<?> ctor = langReflectAccess.newConstructorWithAccessor(constructorToCall, acc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"}]}