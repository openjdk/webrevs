{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2377,1 +2377,1 @@\n-                Thread.blockedOn(b);\n+                Thread.currentThread().blockedOn(b);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,1 +348,6 @@\n-    volatile Interruptible nioBlocker;\n+    private Interruptible nioBlocker;\n+\n+    Interruptible nioBlocker() {\n+        \/\/assert Thread.holdsLock(interruptLock);\n+        return nioBlocker;\n+    }\n@@ -353,4 +358,4 @@\n-    static void blockedOn(Interruptible b) {\n-        Thread me = Thread.currentThread();\n-        synchronized (me.interruptLock) {\n-            me.nioBlocker = b;\n+    void blockedOn(Interruptible b) {\n+        \/\/assert Thread.currentThread() == this;\n+        synchronized (interruptLock) {\n+            nioBlocker = b;\n@@ -1702,0 +1707,1 @@\n+            Interruptible blocker;\n@@ -1703,2 +1709,2 @@\n-                Interruptible b = nioBlocker;\n-                if (b != null) {\n+                blocker = nioBlocker;\n+                if (blocker != null) {\n@@ -1707,2 +1713,1 @@\n-                    b.interrupt(this);\n-                    return;\n+                    blocker.interrupt(this);\n@@ -1711,0 +1716,4 @@\n+            if (blocker != null) {\n+                blocker.postInterrupt();\n+                return;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -855,0 +855,10 @@\n+    @Override\n+    void blockedOn(Interruptible b) {\n+        notifyJvmtiDisableSuspend(true);\n+        try {\n+            super.blockedOn(b);\n+        } finally {\n+            notifyJvmtiDisableSuspend(false);\n+        }\n+    }\n+\n@@ -860,0 +870,4 @@\n+\n+            \/\/ if current thread is a virtual thread then prevent it from being\n+            \/\/ suspended when entering or holding interruptLock\n+            Interruptible blocker;\n@@ -864,3 +878,3 @@\n-                    Interruptible b = nioBlocker;\n-                    if (b != null) {\n-                        b.interrupt(this);\n+                    blocker = nioBlocker();\n+                    if (blocker != null) {\n+                        blocker.interrupt(this);\n@@ -876,0 +890,5 @@\n+\n+            \/\/ notify blocker after releasing interruptLock\n+            if (blocker != null) {\n+                blocker.postInterrupt();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -37,1 +38,0 @@\n-\n@@ -92,0 +92,3 @@\n+    \/\/ invoked if a Thread is interrupted when blocked in an I\/O op\n+    private final Interruptible interruptor;\n+\n@@ -95,1 +98,14 @@\n-    protected AbstractInterruptibleChannel() { }\n+    protected AbstractInterruptibleChannel() {\n+        this.interruptor = new Interruptible() {\n+            @Override\n+            public void interrupt(Thread target) {\n+                AbstractInterruptibleChannel.this.trySetTarget(target);\n+            }\n+            @Override\n+            public void postInterrupt() {\n+                try {\n+                    AbstractInterruptibleChannel.this.close();\n+                } catch (IOException x) { }\n+            }\n+        };\n+    }\n@@ -142,2 +158,9 @@\n-    private Interruptible interruptor;\n-    private volatile Thread interrupted;\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long INTERRUPTED_TARGET =\n+        U.objectFieldOffset(AbstractInterruptibleChannel.class, \"interruptedTarget\");\n+    private volatile Object interruptedTarget;  \/\/ Thread or placeholder object\n+\n+    private void trySetTarget(Thread target) {\n+        \/\/ can't use VarHandle here as CAS may park on first usage\n+        U.compareAndSetReference(this, INTERRUPTED_TARGET, null, target);\n+    }\n@@ -154,14 +177,0 @@\n-        if (interruptor == null) {\n-            interruptor = new Interruptible() {\n-                    public void interrupt(Thread target) {\n-                        synchronized (closeLock) {\n-                            if (closed)\n-                                return;\n-                            closed = true;\n-                            interrupted = target;\n-                            try {\n-                                AbstractInterruptibleChannel.this.implCloseChannel();\n-                            } catch (IOException x) { }\n-                        }\n-                    }};\n-        }\n@@ -170,1 +179,1 @@\n-        if (me.isInterrupted())\n+        if (me.isInterrupted()) {\n@@ -172,0 +181,2 @@\n+            interruptor.postInterrupt();\n+        }\n@@ -197,4 +208,8 @@\n-        Thread interrupted = this.interrupted;\n-        if (interrupted != null && interrupted == Thread.currentThread()) {\n-            this.interrupted = null;\n-            throw new ClosedByInterruptException();\n+        Object interruptedTarget = this.interruptedTarget;\n+        if (interruptedTarget != null) {\n+            interruptor.postInterrupt();\n+            if (interruptedTarget == Thread.currentThread()) {\n+                \/\/ replace with dummy object to avoid retaining reference to this thread\n+                this.interruptedTarget = new Object();\n+                throw new ClosedByInterruptException();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.java","additions":39,"deletions":24,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,3 @@\n+    \/\/ invoked if a Thread is interrupted when blocked on a selection op\n+    private final Interruptible interruptor;\n+\n@@ -106,0 +109,9 @@\n+        this.interruptor = new Interruptible() {\n+            @Override\n+            public void interrupt(Thread ignore) {\n+            }\n+            @Override\n+            public void postInterrupt() {\n+                AbstractSelector.this.wakeup();\n+            }\n+        };\n@@ -212,2 +224,0 @@\n-    private Interruptible interruptor = null;\n-\n@@ -228,6 +238,0 @@\n-        if (interruptor == null) {\n-            interruptor = new Interruptible() {\n-                    public void interrupt(Thread ignore) {\n-                        AbstractSelector.this.wakeup();\n-                    }};\n-        }\n@@ -236,2 +240,3 @@\n-        if (me.isInterrupted())\n-            interruptor.interrupt(me);\n+        if (me.isInterrupted()) {\n+            interruptor.postInterrupt();\n+        }\n@@ -251,1 +256,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelector.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,18 @@\n-    public void interrupt(Thread t);\n+    \/**\n+     * Invoked by Thread.interrupt when the given Thread is interrupted. Thread.interrupt\n+     * invokes this method while holding the given Thread's interrupt lock. This method\n+     * is also invoked by AbstractInterruptibleChannel when beginning an I\/O operation\n+     * with the current thread's interrupt status set. This method must not block.\n+     *\/\n+    void interrupt(Thread target);\n+\n+    \/**\n+     * Invoked by Thread.interrupt after releasing the Thread's interrupt lock.\n+     * It may also be invoked by AbstractInterruptibleChannel or AbstractSelector when\n+     * beginning an I\/O operation with the current thread's interrupt status set, or at\n+     * the end of an I\/O operation when any thread doing I\/O on the channel (or selector)\n+     * has been interrupted. This method closes the channel (or wakes up the Selector) to\n+     * ensure that AsynchronousCloseException or ClosedByInterruptException is thrown.\n+     * This method is required to be idempotent.\n+     *\/\n+    void postInterrupt();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Interruptible.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"}]}