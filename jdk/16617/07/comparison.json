{"files":[{"patch":"@@ -72,2 +72,2 @@\n-  int operator==(const Register r) const { return _encoding == r._encoding; }\n-  int operator!=(const Register r) const { return _encoding != r._encoding; }\n+  constexpr bool operator==(const Register r) const { return _encoding == r._encoding; }\n+  constexpr bool operator!=(const Register r) const { return _encoding != r._encoding; }\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -394,2 +394,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_Register(exact_log2(first)) : noreg;\n+  size_t first = _bitset & -_bitset;\n+  return first != 0 ? as_Register(exact_log2(first)) : noreg;\n@@ -401,1 +401,1 @@\n-  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n@@ -407,2 +407,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_XMMRegister(exact_log2(first)) : xnoreg;\n+  size_t first = _bitset & -_bitset;\n+  return first != 0 ? as_XMMRegister(exact_log2(first)) : xnoreg;\n@@ -414,1 +414,1 @@\n-  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  uint32_t _bitset;\n+  size_t _bitset;\n@@ -98,1 +98,5 @@\n-  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n+  constexpr AbstractRegSet(size_t bitset) : _bitset(bitset) { }\n+\n+  static constexpr int max_size() {\n+    return (int)(sizeof _bitset * CHAR_BIT);\n+  }\n@@ -102,1 +106,1 @@\n-  AbstractRegSet() : _bitset(0) { }\n+  constexpr AbstractRegSet() : _bitset(0) { }\n@@ -104,1 +108,2 @@\n-  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n+  constexpr AbstractRegSet(RegImpl r1)\n+    : _bitset(r1->is_valid() ? size_t(1) << r1->encoding() : 0) { }\n@@ -106,1 +111,1 @@\n-  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n+  constexpr AbstractRegSet operator+(const AbstractRegSet aSet) const {\n@@ -111,1 +116,1 @@\n-  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n+  constexpr AbstractRegSet operator-(const AbstractRegSet aSet) const {\n@@ -116,1 +121,1 @@\n-  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n+  constexpr AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n@@ -121,1 +126,1 @@\n-  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n+  constexpr AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n@@ -126,1 +131,1 @@\n-  static AbstractRegSet of(RegImpl r1) {\n+  constexpr static AbstractRegSet of(RegImpl r1) {\n@@ -130,1 +135,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n@@ -134,1 +139,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n@@ -138,1 +143,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n@@ -142,1 +147,1 @@\n-  static AbstractRegSet range(RegImpl start, RegImpl end) {\n+  constexpr static AbstractRegSet range(RegImpl start, RegImpl end) {\n@@ -146,1 +151,1 @@\n-    uint32_t bits = ~0;\n+    size_t bits = ~(size_t)0;\n@@ -148,2 +153,2 @@\n-    bits <<= 31 - end_enc;\n-    bits >>= 31 - end_enc;\n+    bits <<= max_size() - 1 - end_enc;\n+    bits >>= max_size() - 1 - end_enc;\n@@ -154,1 +159,3 @@\n-  uint size() const { return population_count(_bitset); }\n+  constexpr bool contains(RegImpl reg) {\n+    return (AbstractRegSet(reg).bits() & bits()) != 0;\n+  }\n@@ -156,1 +163,2 @@\n-  uint32_t bits() const { return _bitset; }\n+  constexpr uint size() const { return population_count(_bitset); }\n+  constexpr size_t bits() const { return _bitset; }\n@@ -248,0 +256,18 @@\n+template<typename R, typename... Rx>\n+inline constexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register) {\n+  return !allocated_regs.contains(first_register);\n+}\n+\n+template<typename R, typename... Rx>\n+inline constexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register, Rx... more_registers) {\n+  if (allocated_regs.contains(first_register)) {\n+    return false;\n+  }\n+  return different_registers(allocated_regs + first_register, more_registers...);\n+}\n+\n+template<typename R, typename... Rx>\n+inline constexpr bool different_registers(R first_register, Rx... more_registers) {\n+  return different_registers(AbstractRegSet<R>(first_register), more_registers...);\n+}\n+\n@@ -251,5 +277,8 @@\n-  const R regs[] = { first_register, more_registers... };\n-  \/\/ Verify there are no equal entries.\n-  for (size_t i = 0; i < ARRAY_SIZE(regs) - 1; ++i) {\n-    for (size_t j = i + 1; j < ARRAY_SIZE(regs); ++j) {\n-      assert(regs[i] != regs[j], \"Multiple uses of register: %s\", regs[i]->name());\n+  if (!different_registers(first_register, more_registers...)) {\n+    const R regs[] = { first_register, more_registers... };\n+    \/\/ Find a duplicate entry.\n+    for (size_t i = 0; i < ARRAY_SIZE(regs) - 1; ++i) {\n+      for (size_t j = i + 1; j < ARRAY_SIZE(regs); ++j) {\n+        assert(!regs[i]->is_valid() || regs[i] != regs[j],\n+               \"Multiple uses of register: %s\", regs[i]->name());\n+      }\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":53,"deletions":24,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-inline unsigned population_count(T x) {\n+constexpr unsigned population_count(T x) {\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}