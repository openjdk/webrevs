{"files":[{"patch":"@@ -71,0 +71,2 @@\n+static_assert(different_registers(zr, sp), \"fucked\");\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -392,2 +392,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_Register(exact_log2(first)) : noreg;\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n@@ -398,2 +398,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_FloatRegister(exact_log2(first)) : fnoreg;\n+  if (_bitset == 0) { return fnoreg; }\n+  return as_FloatRegister(count_trailing_zeros(_bitset));\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -394,2 +394,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_Register(exact_log2(first)) : noreg;\n+  if (_bitset == 0) { return noreg; }\n+  return as_Register(count_trailing_zeros(_bitset));\n@@ -401,1 +401,1 @@\n-  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n@@ -407,2 +407,2 @@\n-  uint32_t first = _bitset & -_bitset;\n-  return first ? as_XMMRegister(exact_log2(first)) : xnoreg;\n+  if (_bitset == 0) { return xnoreg; }\n+  return as_XMMRegister(count_trailing_zeros(_bitset));\n@@ -414,1 +414,1 @@\n-  uint32_t last = 31 - count_leading_zeros(_bitset);\n+  int last = max_size() - 1 - count_leading_zeros(_bitset);\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  uint32_t _bitset;\n+  uint64_t _bitset;\n@@ -98,1 +98,5 @@\n-  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n+  constexpr AbstractRegSet(uint64_t bitset) : _bitset(bitset) { }\n+\n+  static constexpr int max_size() {\n+    return (int)(sizeof(_bitset) * BitsPerByte);\n+  }\n@@ -102,1 +106,1 @@\n-  AbstractRegSet() : _bitset(0) { }\n+  constexpr AbstractRegSet() : _bitset(0) { }\n@@ -104,1 +108,4 @@\n-  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n+  constexpr AbstractRegSet(RegImpl r1)\n+    : _bitset(r1->is_valid() ? size_t(1) << r1->encoding() : 0) {\n+    assert(RegImpl::number_of_registers <= 64, \"must be\");\n+  }\n@@ -106,1 +113,1 @@\n-  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n+  constexpr AbstractRegSet operator+(const AbstractRegSet aSet) const {\n@@ -111,1 +118,1 @@\n-  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n+  constexpr AbstractRegSet operator-(const AbstractRegSet aSet) const {\n@@ -116,1 +123,1 @@\n-  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n+  constexpr AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n@@ -121,1 +128,1 @@\n-  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n+  constexpr AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n@@ -126,1 +133,1 @@\n-  static AbstractRegSet of(RegImpl r1) {\n+  constexpr static AbstractRegSet of(RegImpl r1) {\n@@ -130,1 +137,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n@@ -134,1 +141,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n@@ -138,1 +145,1 @@\n-  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n+  constexpr static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n@@ -142,1 +149,1 @@\n-  static AbstractRegSet range(RegImpl start, RegImpl end) {\n+  constexpr static AbstractRegSet range(RegImpl start, RegImpl end) {\n@@ -146,1 +153,1 @@\n-    uint32_t bits = ~0;\n+    size_t bits = ~(size_t)0;\n@@ -148,2 +155,2 @@\n-    bits <<= 31 - end_enc;\n-    bits >>= 31 - end_enc;\n+    bits <<= max_size() - 1 - end_enc;\n+    bits >>= max_size() - 1 - end_enc;\n@@ -154,1 +161,3 @@\n-  uint size() const { return population_count(_bitset); }\n+  constexpr bool contains(RegImpl reg) {\n+    return (AbstractRegSet(reg).bits() & bits()) != 0;\n+  }\n@@ -156,1 +165,2 @@\n-  uint32_t bits() const { return _bitset; }\n+  constexpr uint size() const { return population_count(_bitset); }\n+  constexpr uint64_t bits() const { return _bitset; }\n@@ -246,1 +256,19 @@\n-\/\/ Debugging support\n+\/\/ Debugging and assertion support\n+\n+template<typename R>\n+constexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register) {\n+  return !allocated_regs.contains(first_register);\n+}\n+\n+template<typename R, typename... Rx>\n+constexpr bool different_registers(AbstractRegSet<R> allocated_regs, R first_register, Rx... more_registers) {\n+  if (allocated_regs.contains(first_register)) {\n+    return false;\n+  }\n+  return different_registers(allocated_regs + first_register, more_registers...);\n+}\n+\n+template<typename R, typename... Rx>\n+inline constexpr bool different_registers(R first_register, Rx... more_registers) {\n+  return different_registers(AbstractRegSet<R>(first_register), more_registers...);\n+}\n@@ -251,5 +279,8 @@\n-  const R regs[] = { first_register, more_registers... };\n-  \/\/ Verify there are no equal entries.\n-  for (size_t i = 0; i < ARRAY_SIZE(regs) - 1; ++i) {\n-    for (size_t j = i + 1; j < ARRAY_SIZE(regs); ++j) {\n-      assert(regs[i] != regs[j], \"Multiple uses of register: %s\", regs[i]->name());\n+  if (!different_registers(first_register, more_registers...)) {\n+    const R regs[] = { first_register, more_registers... };\n+    \/\/ Find a duplicate entry.\n+    for (size_t i = 0; i < ARRAY_SIZE(regs) - 1; ++i) {\n+      for (size_t j = i + 1; j < ARRAY_SIZE(regs); ++j) {\n+        assert(!regs[i]->is_valid() || regs[i] != regs[j],\n+               \"Multiple uses of register: %s\", regs[i]->name());\n+      }\n","filename":"src\/hotspot\/share\/asm\/register.hpp","additions":56,"deletions":25,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-inline unsigned population_count(T x) {\n+constexpr unsigned population_count(T x) {\n","filename":"src\/hotspot\/share\/utilities\/population_count.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}