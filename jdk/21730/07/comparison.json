{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,10 +196,1 @@\n-                switch (cs) {\n-                    case String s -> s.getChars(next, next + n, cbuf, off);\n-                    case StringBuilder sb -> sb.getChars(next, next + n, cbuf, off);\n-                    case StringBuffer sb -> sb.getChars(next, next + n, cbuf, off);\n-                    case CharBuffer cb -> cb.get(next, cbuf, off, n);\n-                    default -> {\n-                        for (int i = 0; i < n; i++)\n-                            cbuf[off + i] = cs.charAt(next + i);\n-                    }\n-                }\n+                cs.getChars(next, next + n, cbuf, off);\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -486,28 +486,1 @@\n-    \/**\n-     * Characters are copied from this sequence into the\n-     * destination character array {@code dst}. The first character to\n-     * be copied is at index {@code srcBegin}; the last character to\n-     * be copied is at index {@code srcEnd-1}. The total number of\n-     * characters to be copied is {@code srcEnd-srcBegin}. The\n-     * characters are copied into the subarray of {@code dst} starting\n-     * at index {@code dstBegin} and ending at index:\n-     * <pre>{@code\n-     * dstbegin + (srcEnd-srcBegin) - 1\n-     * }<\/pre>\n-     *\n-     * @param      srcBegin   start copying at this offset.\n-     * @param      srcEnd     stop copying at this offset.\n-     * @param      dst        the array to copy the data into.\n-     * @param      dstBegin   offset into {@code dst}.\n-     * @throws     IndexOutOfBoundsException  if any of the following is true:\n-     *             <ul>\n-     *             <li>{@code srcBegin} is negative\n-     *             <li>{@code dstBegin} is negative\n-     *             <li>the {@code srcBegin} argument is greater than\n-     *             the {@code srcEnd} argument.\n-     *             <li>{@code srcEnd} is greater than\n-     *             {@code this.length()}.\n-     *             <li>{@code dstBegin+srcEnd-srcBegin} is greater than\n-     *             {@code dst.length}\n-     *             <\/ul>\n-     *\/\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":2,"deletions":29,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,0 +305,43 @@\n+    \/**\n+     * Copies characters from this sequence into the given destination array.\n+     * The first character to be copied is at index {@code srcBegin}; the last\n+     * character to be copied is at index {@code srcEnd-1}. The total number of\n+     * characters to be copied is {@code srcEnd-srcBegin}. The\n+     * characters are copied into the subarray of {@code dst} starting\n+     * at index {@code dstBegin} and ending at index:\n+     * <pre>{@code\n+     * dstbegin + (srcEnd-srcBegin) - 1\n+     * }<\/pre>\n+     *\n+     * @param      srcBegin   start copying at this offset.\n+     * @param      srcEnd     stop copying at this offset.\n+     * @param      dst        the array to copy the data into.\n+     * @param      dstBegin   offset into {@code dst}.\n+     * @throws     IndexOutOfBoundsException  if any of the following is true:\n+     *             <ul>\n+     *             <li>{@code srcBegin} is negative\n+     *             <li>{@code dstBegin} is negative\n+     *             <li>the {@code srcBegin} argument is greater than\n+     *             the {@code srcEnd} argument.\n+     *             <li>{@code srcEnd} is greater than\n+     *             {@code this.length()}.\n+     *             <li>{@code dstBegin+srcEnd-srcBegin} is greater than\n+     *             {@code dst.length}\n+     *             <\/ul>\n+     * @throws     NullPointerException if {@code dst} is {@code null}\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@link #charAt(int index)} in a loop\n+     * iterating {@code index} from {@code srcBegin} to {@code srcEnd-1}.\n+     * Concurrent truncation of this character sequence can throw\n+     * {@code IndexOutOfBoundsException}. In this case, some characters, but not\n+     * all, may be already transferred.\n+     *\n+     * @since 25\n+     *\/\n+    public default void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n+        Objects.checkFromToIndex(srcBegin, srcEnd, length());\n+        Objects.checkIndex(dstBegin, dst.length - (srcEnd - srcBegin) + 1);\n+        while (srcBegin < srcEnd)\n+            dst[dstBegin++] = charAt(srcBegin++);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharSequence.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1738,30 +1738,1 @@\n-    \/**\n-     * Copies characters from this string into the destination character\n-     * array.\n-     * <p>\n-     * The first character to be copied is at index {@code srcBegin};\n-     * the last character to be copied is at index {@code srcEnd-1}\n-     * (thus the total number of characters to be copied is\n-     * {@code srcEnd-srcBegin}). The characters are copied into the\n-     * subarray of {@code dst} starting at index {@code dstBegin}\n-     * and ending at index:\n-     * <blockquote><pre>\n-     *     dstBegin + (srcEnd-srcBegin) - 1\n-     * <\/pre><\/blockquote>\n-     *\n-     * @param      srcBegin   index of the first character in the string\n-     *                        to copy.\n-     * @param      srcEnd     index after the last character in the string\n-     *                        to copy.\n-     * @param      dst        the destination array.\n-     * @param      dstBegin   the start offset in the destination array.\n-     * @throws    IndexOutOfBoundsException If any of the following\n-     *            is true:\n-     *            <ul><li>{@code srcBegin} is negative.\n-     *            <li>{@code srcBegin} is greater than {@code srcEnd}\n-     *            <li>{@code srcEnd} is greater than the length of this\n-     *                string\n-     *            <li>{@code dstBegin} is negative\n-     *            <li>{@code dstBegin+(srcEnd-srcBegin)} is larger than\n-     *                {@code dst.length}<\/ul>\n-     *\/\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,3 +282,0 @@\n-    \/**\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringBuffer.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1899,0 +1899,38 @@\n+    \/**\n+     * Absolute bulk <i>get<\/i> method.\n+     *\n+     * <p> This method transfers {@code srcEnd-srcBegin} characters from this\n+     * buffer into the given array, starting at index {@code srcBegin} in this\n+     * buffer and at offset {@code dstBegin} in the array. The position of this\n+     * buffer is unchanged.\n+     *\n+     * @param  srcBegin\n+     *         The index in this buffer from which the first character will be\n+     *         read; must be non-negative and less than {@code limit()}\n+     *\n+     * @param  srcEnd\n+     *         The index in this buffer directly before the last character to\n+     *         read; must be non-negative and less or equal than {@code limit()}\n+     *         and must be greater or equal than {@code srcBegin}\n+     *\n+     * @param  dst\n+     *         The destination array\n+     *\n+     * @param  dstBegin\n+     *         The offset within the array of the first character to be\n+     *         written; must be non-negative and less than {@code dst.length}\n+     *\n+     * @throws  IndexOutOfBoundsException\n+     *          If the preconditions on the {@code srcBegin}, {@code srcEnd},\n+     *          and {@code dstBegin} parameters do not hold\n+     *\n+     * @implSpec This method is equivalent to\n+     *           {@code get(srcBegin, dst, dstBegin, srcEnd - srcBegin)}.\n+     *\n+     * @since 25\n+     *\/\n+    @Override\n+    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {\n+        get(srcBegin, dst, dstBegin, srcEnd - srcBegin);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8343110\n+ * @summary Check for expected behavior of default implementation of\n+ *          CharSequence.getChars().\n+ * @run testng GetChars\n+ *\/\n+public class GetChars {\n+    private static CharSequence CS = new CharSequence() {\n+        @Override\n+        public int length() {\n+            return 4;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            return \"Test\".charAt(index);\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int start, int end) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+    @Test\n+    public void testExactCopy() {\n+        var dst = new char[4];\n+        CS.getChars(0, 4, dst, 0);\n+        Assert.assertEquals(dst, new char[] {'T', 'e', 's', 't'});\n+    }\n+\n+    @Test\n+    public void testPartialCopy() {\n+        var dst = new char[2];\n+        CS.getChars(1, 3, dst, 0);\n+        Assert.assertEquals(dst, new char[] {'e', 's'});\n+    }\n+\n+    @Test\n+    public void testPositionedCopy() {\n+        var dst = new char[] {1, 2, 3, 4, 5, 6};\n+        CS.getChars(0, 4, dst, 1);\n+        Assert.assertEquals(dst, new char[] {1, 'T', 'e', 's', 't', 6});\n+    }\n+\n+    @Test\n+    public void testSrcBeginIsNegative() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CS.getChars(-1, 3, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testDstBeginIsNegative() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CS.getChars(0, 4, new char[4], -1));\n+    }\n+\n+    @Test\n+    public void testSrcBeginIsGreaterThanSrcEnd() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CS.getChars(4, 0, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testSrcEndIsGreaterThanSequenceLength() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CS.getChars(0, 5, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testRequestedLengthIsGreaterThanDstLength() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CS.getChars(0, 4, new char[3], 0));\n+    }\n+\n+    @Test\n+    public void testDstIsNull() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> CS.getChars(0, 4, null, 0));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/CharSequence\/GetChars.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/**\n+ * @test\n+ * @bug 8343110\n+ * @summary Check for expected behavior of CharBuffer.getChars().\n+ * @run testng GetChars\n+ * @key randomness\n+ *\/\n+public class GetChars {\n+    private static CharBuffer CB = CharBuffer.wrap(\"Test\");\n+\n+    @Test\n+    public void testExactCopy() {\n+        var dst = new char[4];\n+        CB.getChars(0, 4, dst, 0);\n+        Assert.assertEquals(dst, new char[] {'T', 'e', 's', 't'});\n+    }\n+\n+    @Test\n+    public void testPartialCopy() {\n+        var dst = new char[2];\n+        CB.getChars(1, 3, dst, 0);\n+        Assert.assertEquals(dst, new char[] {'e', 's'});\n+    }\n+\n+    @Test\n+    public void testPositionedCopy() {\n+        var dst = new char[] {1, 2, 3, 4, 5, 6};\n+        CB.getChars(0, 4, dst, 1);\n+        Assert.assertEquals(dst, new char[] {1, 'T', 'e', 's', 't', 6});\n+    }\n+\n+    @Test\n+    public void testSrcBeginIsNegative() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CB.getChars(-1, 3, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testDstBeginIsNegative() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CB.getChars(0, 4, new char[4], -1));\n+    }\n+\n+    @Test\n+    public void testSrcBeginIsGreaterThanSrcEnd() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CB.getChars(4, 0, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testSrcEndIsGreaterThanSequenceLength() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CB.getChars(0, 5, new char[4], 0));\n+    }\n+\n+    @Test\n+    public void testRequestedLengthIsGreaterThanDstLength() {\n+        Assert.assertThrows(IndexOutOfBoundsException.class,\n+                () -> CB.getChars(0, 4, new char[3], 0));\n+    }\n+\n+    @Test\n+    public void testDstIsNull() {\n+        Assert.assertThrows(NullPointerException.class,\n+                () -> CB.getChars(0, 4, null, 0));\n+    }\n+\n+    private static final Random RAND = new Random();\n+    private static final int SIZE = 128 + RAND.nextInt(1024);\n+\n+    \/**\n+     * Randomize the char buffer's position and limit.\n+     *\/\n+    private static CharBuffer randomizeRange(CharBuffer cb) {\n+        int mid = cb.capacity() >>> 1;\n+        int start = RAND.nextInt(mid + 1); \/\/ from 0 to mid\n+        int end = mid + RAND.nextInt(cb.capacity() - mid + 1); \/\/ from mid to capacity\n+        cb.position(start);\n+        cb.limit(end);\n+        return cb;\n+    }\n+\n+    \/**\n+     * Randomize the char buffer's contents, position and limit.\n+     *\/\n+    private static CharBuffer randomize(CharBuffer cb) {\n+        while (cb.hasRemaining()) {\n+            cb.put((char)RAND.nextInt());\n+        }\n+        return randomizeRange(cb);\n+    }\n+\n+    \/**\n+     * Sums the remaining chars in the char buffer.\n+     *\/\n+    private static int intSum(CharBuffer cb) {\n+        int sum = 0;\n+        cb.mark();\n+        while (cb.hasRemaining()) {\n+            sum += cb.get();\n+        }\n+        cb.reset();\n+        return sum;\n+    }\n+\n+    \/**\n+     * Sums the chars in the char array.\n+     *\/\n+    private static int intSum(char[] ca) {\n+        int sum = 0;\n+        for (int i = 0; i < ca.length; i++)\n+            sum += ca[i];\n+        return sum;\n+    }\n+\n+    \/**\n+     * Creates char buffers to test, adding them to the given list.\n+     *\/\n+    private static void addCases(CharBuffer cb, List<CharBuffer> buffers) {\n+        randomize(cb);\n+        buffers.add(cb);\n+\n+        buffers.add(cb.slice());\n+        buffers.add(cb.duplicate());\n+        buffers.add(cb.asReadOnlyBuffer());\n+\n+        buffers.add(randomizeRange(cb.slice()));\n+        buffers.add(randomizeRange(cb.duplicate()));\n+        buffers.add(randomizeRange(cb.asReadOnlyBuffer()));\n+    }\n+\n+    @DataProvider(name = \"charbuffers\")\n+    public Object[][] createCharBuffers() {\n+        List<CharBuffer> buffers = new ArrayList<>();\n+\n+        \/\/ heap\n+        addCases(CharBuffer.allocate(SIZE), buffers);\n+        addCases(CharBuffer.wrap(new char[SIZE]), buffers);\n+        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n+                buffers);\n+        addCases(ByteBuffer.allocate(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n+                buffers);\n+\n+        \/\/ direct\n+        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.BIG_ENDIAN).asCharBuffer(),\n+                buffers);\n+        addCases(ByteBuffer.allocateDirect(SIZE*2).order(ByteOrder.LITTLE_ENDIAN).asCharBuffer(),\n+                buffers);\n+\n+        \/\/ read-only buffer backed by a CharSequence\n+        buffers.add(CharBuffer.wrap(randomize(CharBuffer.allocate(SIZE))));\n+\n+        Object[][] params = new Object[buffers.size()][];\n+        for (int i = 0; i < buffers.size(); i++) {\n+            CharBuffer cb = buffers.get(i);\n+            params[i] = new Object[] { cb.getClass().getName(), cb };\n+        }\n+\n+        return params;\n+    }\n+\n+    @Test(dataProvider = \"charbuffers\")\n+    public void testGetChars(String type, CharBuffer cb) {\n+        System.out.format(\"%s position=%d, limit=%d%n\", type, cb.position(), cb.limit());\n+        int expected = intSum(cb);\n+        var dst = new char[cb.remaining()];\n+        cb.getChars(cb.position(), cb.limit(), dst, 0);\n+        int actual = intSum(dst);\n+        assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/Buffer\/GetChars.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}