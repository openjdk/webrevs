{"files":[{"patch":"@@ -886,1 +886,64 @@\n-  ShouldNotReachHere();\n+  assert(UseVectorizedMismatchIntrinsic, \"need RVV instructions support\");\n+\n+  \/\/ Make all state_for calls early since they can emit code\n+  LIR_Opr result = rlock_result(x);\n+\n+  LIRItem a(x->argument_at(0), this); \/\/ Object\n+  LIRItem aOffset(x->argument_at(1), this); \/\/ long\n+  LIRItem b(x->argument_at(2), this); \/\/ Object\n+  LIRItem bOffset(x->argument_at(3), this); \/\/ long\n+  LIRItem length(x->argument_at(4), this); \/\/ int\n+  LIRItem log2ArrayIndexScale(x->argument_at(5), this); \/\/ int\n+\n+  a.load_item();\n+  aOffset.load_nonconstant();\n+  b.load_item();\n+  bOffset.load_nonconstant();\n+\n+  long constant_aOffset = 0;\n+  LIR_Opr result_aOffset = aOffset.result();\n+  if (result_aOffset->is_constant()) {\n+    constant_aOffset = result_aOffset->as_jlong();\n+    result_aOffset = LIR_OprFact::illegalOpr;\n+  }\n+  LIR_Opr result_a = a.result();\n+\n+  long constant_bOffset = 0;\n+  LIR_Opr result_bOffset = bOffset.result();\n+  if (result_bOffset->is_constant()) {\n+    constant_bOffset = result_bOffset->as_jlong();\n+    result_bOffset = LIR_OprFact::illegalOpr;\n+  }\n+  LIR_Opr result_b = b.result();\n+\n+  LIR_Address* addr_a = new LIR_Address(result_a,\n+                                        result_aOffset,\n+                                        constant_aOffset,\n+                                        T_BYTE);\n+\n+  LIR_Address* addr_b = new LIR_Address(result_b,\n+                                        result_bOffset,\n+                                        constant_bOffset,\n+                                        T_BYTE);\n+\n+  BasicTypeList signature(4);\n+  signature.append(T_ADDRESS);\n+  signature.append(T_ADDRESS);\n+  signature.append(T_INT);\n+  signature.append(T_INT);\n+  CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n+  const LIR_Opr result_reg = result_register_for(x->type());\n+\n+  LIR_Opr ptr_addr_a = new_pointer_register();\n+  __ leal(LIR_OprFact::address(addr_a), ptr_addr_a);\n+\n+  LIR_Opr ptr_addr_b = new_pointer_register();\n+  __ leal(LIR_OprFact::address(addr_b), ptr_addr_b);\n+\n+  __ move(ptr_addr_a, cc->at(0));\n+  __ move(ptr_addr_b, cc->at(1));\n+  length.load_item_force(cc->at(2));\n+  log2ArrayIndexScale.load_item_force(cc->at(3));\n+\n+  __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc->args());\n+  __ move(result_reg, result);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -5658,0 +5658,42 @@\n+void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length,\n+                                         Register log2_array_indxscale, Register result,\n+                                         Register tmp1, Register tmp2,\n+                                         VectorRegister vrm, VectorRegister vra, VectorRegister vrb) {\n+  assert(UseVectorizedMismatchIntrinsic, \"sanity\");\n+  assert_different_registers(obja, objb, length, log2_array_indxscale, tmp1, tmp2, t0, t1);\n+  assert_different_registers(vra, vrb, vrm);\n+\n+  const Register consumed = t1;\n+  const Register cnt = tmp1;\n+  const Register idx = tmp2;\n+  Label MISMATCH_FOUND, NO_MISMATCH_FOUND, VEC_LOOP, DONE;\n+\n+  beqz(length, NO_MISMATCH_FOUND);\n+\n+  sll(cnt, length, log2_array_indxscale);\n+  mv(consumed, 0);\n+\n+  bind(VEC_LOOP);\n+  vsetvli(t0, cnt, Assembler::e8, Assembler::m8);\n+  vle8_v(vra, obja);\n+  vle8_v(vrb, objb);\n+  vmsne_vv(vrm, vra, vrb);\n+  vfirst_m(idx, vrm);\n+  bgez(idx, MISMATCH_FOUND);\n+  sub(cnt, cnt, t0);\n+  add(obja, obja, t0);\n+  add(objb, objb, t0);\n+  add(consumed, consumed, t0);\n+  bnez(cnt, VEC_LOOP);\n+\n+  bind(NO_MISMATCH_FOUND);\n+  mv(result, -1);\n+  j(DONE);\n+\n+  bind(MISMATCH_FOUND);\n+  add(idx, consumed, idx);\n+  srl(result, idx, log2_array_indxscale);\n+\n+  bind(DONE);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1404,0 +1404,5 @@\n+  void vectorized_mismatch(Register obja, Register objb, Register length,\n+                           Register log2_array_indxscale, Register result,\n+                           Register tmp1, Register tmp2,\n+                           VectorRegister vrm, VectorRegister vra, VectorRegister vrb);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3151,0 +3151,38 @@\n+  \/**\n+  *  Arguments:\n+  *\n+  *  Input:\n+  *    c_rarg0   - obja     address\n+  *    c_rarg1   - objb     address\n+  *    c_rarg3   - length   length               (number of elements)\n+  *    c_rarg4   - scale    log2_array_indxscale (element size)\n+  *\n+  *  Output:\n+  *        x10   - int >= 0 mismatched index, < 0 bitwise complement of tail\n+  *\/\n+  address generate_vectorizedMismatch()\n+  {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"vectorizedMismatch\");\n+    address entry = __ pc();\n+\n+    const Register result = c_rarg0;\n+    const Register obja   = c_rarg0;\n+    const Register objb   = c_rarg1;\n+    const Register length = c_rarg2;\n+    const Register scale  = c_rarg3;\n+    const Register tmp1   = x28;\n+    const Register tmp2   = x29;\n+    const VectorRegister vrm = v0;\n+    const VectorRegister vra = v8;\n+    const VectorRegister vrb = v16;\n+\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ enter();\n+    __ vectorized_mismatch(obja, objb, length, scale, result, tmp1, tmp2, vrm, vra, vrb);\n+    __ leave();\n+    __ ret();\n+\n+    return entry;\n+  }\n+\n@@ -6733,0 +6771,4 @@\n+    if (UseVectorizedMismatchIntrinsic) {\n+      StubRoutines::_vectorizedMismatch = generate_vectorizedMismatch();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -208,0 +208,10 @@\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {\n+      UseVectorizedMismatchIntrinsic = true;\n+    }\n+  } else if (UseVectorizedMismatchIntrinsic) {\n+    if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic))\n+      warning(\"VectorizedMismatch intrinsic is not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}