{"files":[{"patch":"@@ -2594,2 +2594,2 @@\n-  \/\/ 0 if hybrid CPU because it is difficult to derive number of cores.\n-  _no_of_cores = supports_hybrid() ? 0 : (cores_per_cpu() * _no_of_sockets);\n+  \/\/ -1 if hybrid CPU because it is difficult to derive number of cores.\n+  _no_of_cores = supports_hybrid() ? -1 : (cores_per_cpu() * _no_of_sockets);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-    <Field type=\"uint\" name=\"cores\" label=\"Cores\" \/>\n+    <Field type=\"long\" name=\"cores\" label=\"Cores\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+\/\/ Java Mission Control (JMC) uses (Java) Long.MIN_VALUE to describe that a\n+\/\/ long value is undefined.\n+static jlong jmc_undefined_long = min_jlong;\n+\n@@ -186,0 +190,1 @@\n+    jlong cores = cpu_info.number_of_cores() == -1 ? jmc_undefined_long : cpu_info.number_of_cores();\n@@ -190,1 +195,1 @@\n-    event.set_cores(cpu_info.number_of_cores());\n+    event.set_cores(cores);\n@@ -417,4 +422,0 @@\n-\/\/ Java Mission Control (JMC) uses (Java) Long.MIN_VALUE to describe that a\n-\/\/ long value is undefined.\n-static jlong jmc_undefined_long = min_jlong;\n-\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Asserts;\n@@ -53,1 +54,2 @@\n-            Events.assertField(event, \"cores\").atLeast(1);\n+            long cores = Events.assertField(event, \"cores\").getValue();\n+            Asserts.assertTrue(cores > 0 || cores == Long.MIN_VALUE);\n","filename":"test\/jdk\/jdk\/jfr\/event\/os\/TestCPUInformation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}