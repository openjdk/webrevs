{"files":[{"patch":"@@ -1684,0 +1684,38 @@\n+void C2_MacroAssembler::compress_bits_v(Register dst, Register src, Register mask, Register tmp, bool is_long) {\n+  Assembler::SEW sew = is_long ? Assembler::e64 : Assembler::e32;\n+  \/\/ intrinsic is enabled when MaxVectorSize >= 16\n+  Assembler::LMUL lmul = is_long ? Assembler::m4 : Assembler::m2;\n+  long len = is_long ? 64 : 32;\n+\n+  \/\/ load the src data(in bits) to be compressed.\n+  vsetivli(x0, 1, sew, lmul);\n+  vmv_s_x(v0, src);\n+  \/\/ reset the src data(in bytes) to zero.\n+  mv(tmp, len);\n+  vsetvli(x0, tmp, Assembler::e8, lmul);\n+  vmv_v_i(v4, 0);\n+  \/\/ convert the src data from bits to bytes.\n+  vmerge_vim(v4, v4, 1); \/\/ v0 as the implicit mask register\n+  \/\/ reset the dst data(in bytes) to zero.\n+  vmv_v_i(v8, 0);\n+  \/\/ load the mask data(in bits).\n+  vsetivli(x0, 1, sew, lmul);\n+  vmv_v_x(v0, mask);\n+  \/\/ compress the src data(in bytes) to dst(in bytes).\n+  vsetvli(x0, tmp, Assembler::e8, lmul);\n+  vcompress_vm(v8, v4, v0);\n+  \/\/ convert the dst data from bytes to bits.\n+  vmseq_vi(v0, v8, 1);\n+  \/\/ store result back.\n+  vsetivli(x0, 1, sew, lmul);\n+  vmv_x_s(dst, v0);\n+}\n+\n+void C2_MacroAssembler::compress_bits_i_v(Register dst, Register src, Register mask, Register tmp) {\n+  compress_bits_v(dst, src, mask, tmp, \/* is_long *\/ false);\n+}\n+\n+void C2_MacroAssembler::compress_bits_l_v(Register dst, Register src, Register mask, Register tmp) {\n+  compress_bits_v(dst, src, mask, tmp, \/* is_long *\/ true);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\n+  void compress_bits_v(Register dst, Register src, Register mask, Register tmp, bool is_long);\n+\n@@ -164,0 +167,5 @@\n+\n+  \/\/ compress bits, i.e. j.l.Integer\/Long::compress.\n+  void compress_bits_i_v(Register dst, Register src, Register mask, Register tmp);\n+  void compress_bits_l_v(Register dst, Register src, Register mask, Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1401,0 +1401,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1896,0 +1896,4 @@\n+    case Op_CompressBits:\n+      guarantee(UseRVV == (MaxVectorSize >= 16), \"UseRVV and MaxVectorSize not matched\");\n+      return UseRVV;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2881,0 +2881,52 @@\n+\/\/ CompressBits of Long & Integer\n+\n+instruct compressBitsI(iRegINoSp dst, iRegIorL2I src, iRegIorL2I mask, iRegPNoSp tmp, vRegMask_V0 v0, vReg_V4 v4, vReg_V8 v8) %{\n+  predicate(UseRVV && (MaxVectorSize >= 16));\n+  match(Set dst (CompressBits src mask));\n+  effect(TEMP tmp, TEMP v0, TEMP v4, TEMP v8);\n+  format %{ \"vsetivli x0, 1, e32, m2, tu, mu\\t#@compressBitsI\\n\\t\"\n+            \"vmv.s.x $v0, $src\\n\\t\"\n+            \"mv $tmp, 32\\n\\t\"\n+            \"vsetvli x0, $tmp, e8, m2, tu, mu\\n\\t\"\n+            \"vmv.v.i $v4, 0\\n\\t\"\n+            \"vmerge.vim $v4, $v4, 1, $v0\\n\\t\"\n+            \"vmv.v.i $v8, 0\\n\\t\"\n+            \"vsetivli x0, 1, e32, m2, tu, mu\\n\\t\"\n+            \"vmv.v.x $v0, $mask\\n\\t\"\n+            \"vsetvli x0, $tmp, e8, m2, tu, mu\\n\\t\"\n+            \"vcompress.vm $v8, $v4, $v0\\n\\t\"\n+            \"vmseq.vi $v0, $v8, 1\\n\\t\"\n+            \"vsetivli x0, 1, e32, m2, tu, mu\\n\\t\"\n+            \"vmv.x.s $dst, $v0\\t#@compressBitsI\\n\\t\"\n+          %}\n+  ins_encode %{\n+    __ compress_bits_i_v(as_Register($dst$$reg), as_Register($src$$reg), as_Register($mask$$reg), as_Register($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct compressBitsL(iRegLNoSp dst, iRegL src, iRegL mask, iRegPNoSp tmp, vRegMask_V0 v0, vReg_V4 v4, vReg_V8 v8) %{\n+  predicate(UseRVV && (MaxVectorSize >= 16));\n+  match(Set dst (CompressBits src mask));\n+  effect(TEMP tmp, TEMP v0, TEMP v4, TEMP v8);\n+  format %{ \"vsetivli x0, 1, e64, m4, tu, mu\\t#@compressBitsL\\n\\t\"\n+            \"vmv.s.x $v0, $src\\n\\t\"\n+            \"mv $tmp, 64\\n\\t\"\n+            \"vsetvli x0, $tmp, e8, m4, tu, mu\\n\\t\"\n+            \"vmv.v.i $v4, 0\\n\\t\"\n+            \"vmerge.vim $v4, $v4, 1, $v0\\n\\t\"\n+            \"vmv.v.i $v8, 0\\n\\t\"\n+            \"vsetivli x0, 1, e64, m4, tu, mu\\n\\t\"\n+            \"vmv.v.x $v0, $mask\\n\\t\"\n+            \"vsetvli x0, $tmp, e8, m4, tu, mu\\n\\t\"\n+            \"vcompress.vm $v8, $v4, $v0\\n\\t\"\n+            \"vmseq.vi $v0, $v8, 1\\n\\t\"\n+            \"vsetivli x0, 1, e64, m4, tu, mu\\n\\t\"\n+            \"vmv.x.s $dst, $v0\\t#@compressBitsL\\n\\t\"\n+          %}\n+  ins_encode %{\n+    __ compress_bits_l_v(as_Register($dst$$reg), as_Register($src$$reg), as_Register($mask$$reg), as_Register($tmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"}]}