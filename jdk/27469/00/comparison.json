{"files":[{"patch":"@@ -311,0 +311,6 @@\n+         * @implSpec\n+         * When a connection timeout is configured, an {@link HttpClient}\n+         * implementation applies it to the entire connection phase, from the\n+         * moment a connection is requested until it is established. The\n+         * elapsed time includes any SSL\/TLS handshake.\n+         *\n@@ -315,0 +321,2 @@\n+         * @see HttpRequest.Builder#timeout(Duration) Configuration timeout for\n+         * request execution\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -261,2 +261,17 @@\n-         * of not setting a timeout is the same as setting an infinite Duration,\n-         * i.e. block forever.\n+         * of not setting a timeout is the same as setting an infinite\n+         * {@code Duration}, i.e., block forever.\n+         *\n+         * @implSpec\n+         * When a timeout is configured, an {@link HttpClient} implementation\n+         * should apply it over the duration measured from the instant the\n+         * request execution starts to, <em>at least<\/em>, the instant an\n+         * {@link HttpResponse} is constructed. The elapsed time includes\n+         * obtaining a connection for transport and retrieving the response\n+         * headers.\n+         *\n+         * @implNote\n+         * When a timeout is configured, the JDK built-in implementation of the\n+         * {@link HttpClient} applies it over the duration measured from the\n+         * instant the request execution starts to <b>the instant the response\n+         * body is consumed<\/b>, if present. This is implemented by stopping\n+         * the timer after the response body subscriber completion.\n@@ -267,0 +282,2 @@\n+         * @see HttpClient.Builder#connectTimeout(Duration) Configuring\n+         * timeout for connection establishment\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,6 @@\n+         * @implSpec\n+         * When a connection timeout value is present, a {@link WebSocket}\n+         * implementation should apply it over the duration measured from the\n+         * instant a connection is requested to the instant that one is\n+         * established. This duration includes SSL handshakes, if required.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/WebSocket.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.net.http.HttpClient.Version;\n@@ -34,1 +33,0 @@\n-import java.util.concurrent.Executor;\n@@ -224,1 +222,3 @@\n-    public CompletableFuture<T> readBodyAsync(HttpResponse.BodyHandler<T> handler) {\n+    public CompletableFuture<T> readBodyAsync(\n+            HttpResponse.BodyHandler<T> handler,\n+            Runnable preTerminationCallback) {\n@@ -232,1 +232,1 @@\n-        return exchImpl.readBodyAsync(handler, !request.isWebSocket(), parentExecutor)\n+        return exchImpl.readBodyAsync(handler, preTerminationCallback, !request.isWebSocket(), parentExecutor)\n@@ -690,1 +690,1 @@\n-            return e.readBodyAsync(this::ignoreBody, false, parentExecutor)\n+            return e.readBodyAsync(this::ignoreBody, null, false, parentExecutor)\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -592,0 +592,1 @@\n+                                                Runnable preTerminationCallback,\n@@ -596,6 +597,12 @@\n-     * Creates and wraps an {@link HttpResponse.BodySubscriber} from a {@link\n-     * HttpResponse.BodyHandler} for the given {@link ResponseInfo}.\n-     * An {@code HttpBodySubscriberWrapper} wraps a response body subscriber and makes\n-     * sure its completed\/onError methods are called only once, and that its onSusbscribe\n-     * is called before onError. This is useful when errors occur asynchronously, and\n-     * most typically when the error occurs before the {@code BodySubscriber} has\n+     * {@return a new {@code HttpBodySubscriberWrapper} decorating the\n+     * {@link HttpResponse.BodySubscriber} obtained using the given {@link\n+     * HttpResponse.BodyHandler} and the {@link ResponseInfo}}\n+     *\n+     * <p>An {@code HttpBodySubscriberWrapper} decorates a response body\n+     * subscriber such that:\n+     * <ul>\n+     * <li>It is ensured that {@code onComplete}\/{@code onError} are called\n+     * only once\n+     * <li>It is ensured that {@code onSubscribe} is called before {@code\n+     * onError}. This is useful when errors occur asynchronously, and most\n+     * typically when the error occurs before the {@code BodySubscriber} has\n@@ -603,2 +610,8 @@\n-     * @param handler  a body handler\n-     * @param response a response info\n+     * <li>A pre-termination callback is invoked before\n+     * {@code onComplete}\/{@code onError}\n+     * <\/ul>\n+     *\n+     * @param handler  a response body handler to wrap\n+     * @param responseInfo a response info to create the subscriber from\n+     * @param preTerminationCallback a callback to be invoked before\n+     *                               completion with either success or failure\n@@ -608,2 +621,5 @@\n-            HttpResponse.BodyHandler<T> handler, ResponseInfo response) {\n-        return new HttpBodySubscriberWrapper<>(handler.apply(response));\n+            HttpResponse.BodyHandler<T> handler,\n+            ResponseInfo responseInfo,\n+            Runnable preTerminationCallback) {\n+        var subscriber = handler.apply(responseInfo);\n+        return new HttpBodySubscriberWrapper<>(subscriber, preTerminationCallback);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -209,2 +209,6 @@\n-        Http1ResponseBodySubscriber(BodySubscriber<U> userSubscriber, Http1Exchange<U> exchange) {\n-            super(userSubscriber);\n+\n+        Http1ResponseBodySubscriber(\n+                BodySubscriber<U> userSubscriber,\n+                Runnable preTerminationCallback,\n+                Http1Exchange<U> exchange) {\n+            super(userSubscriber, preTerminationCallback);\n@@ -447,0 +451,1 @@\n+                                       Runnable preTerminationCallback,\n@@ -452,1 +457,1 @@\n-        BodySubscriber<T> bs = createResponseSubscriber(handler, responseInfo);\n+        BodySubscriber<T> bs = createResponseSubscriber(handler, responseInfo, preTerminationCallback);\n@@ -460,1 +465,4 @@\n-    Http1ResponseBodySubscriber<T> createResponseSubscriber(BodyHandler<T> handler, ResponseInfo response) {\n+    Http1ResponseBodySubscriber<T> createResponseSubscriber(\n+            BodyHandler<T> handler,\n+            ResponseInfo response,\n+            Runnable preTerminationCallback) {\n@@ -462,3 +470,1 @@\n-        Http1ResponseBodySubscriber<T> bs =\n-                new Http1ResponseBodySubscriber<T>(subscriber, this);\n-        return bs;\n+        return new Http1ResponseBodySubscriber<>(subscriber, preTerminationCallback, this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -557,2 +557,2 @@\n-        Http3StreamResponseSubscriber(BodySubscriber<U> subscriber) {\n-            super(subscriber);\n+        Http3StreamResponseSubscriber(BodySubscriber<U> subscriber, Runnable preTerminationCallback) {\n+            super(subscriber, preTerminationCallback);\n@@ -588,1 +588,0 @@\n-\n@@ -591,1 +590,2 @@\n-                                                              ResponseInfo response) {\n+                                                              ResponseInfo response,\n+                                                              Runnable preTerminationCallback) {\n@@ -593,3 +593,1 @@\n-        Http3StreamResponseSubscriber<T> subscriber =\n-                new Http3StreamResponseSubscriber<>(handler.apply(response));\n-        return subscriber;\n+        return new Http3StreamResponseSubscriber<>(handler.apply(response), preTerminationCallback);\n@@ -600,0 +598,1 @@\n+                                       Runnable preTerminationCallback,\n@@ -608,1 +607,1 @@\n-                    createResponseSubscriber(handler, new ResponseInfoImpl(response));\n+                    createResponseSubscriber(handler, new ResponseInfoImpl(response), preTerminationCallback);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ExchangeImpl.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -232,2 +232,2 @@\n-        Http3PushStreamResponseSubscriber(BodySubscriber<U> subscriber) {\n-            super(subscriber);\n+        Http3PushStreamResponseSubscriber(BodySubscriber<U> subscriber, Runnable preTerminationCallback) {\n+            super(subscriber, preTerminationCallback);\n@@ -247,2 +247,4 @@\n-    Http3PushStreamResponseSubscriber<T> createResponseSubscriber(BodyHandler<T> handler,\n-                                                              ResponseInfo response) {\n+    Http3PushStreamResponseSubscriber<T> createResponseSubscriber(\n+            BodyHandler<T> handler,\n+            Runnable preTerminationCallback,\n+            ResponseInfo response) {\n@@ -250,1 +252,1 @@\n-        return new Http3PushStreamResponseSubscriber<>(handler.apply(response));\n+        return new Http3PushStreamResponseSubscriber<>(handler.apply(response), preTerminationCallback);\n@@ -372,1 +374,1 @@\n-        start.thenCompose( v -> readBodyAsync(getPushHandler(), false, getExchange().executor()))\n+        start.thenCompose( v -> readBodyAsync(getPushHandler(), null, false, getExchange().executor()))\n@@ -447,0 +449,1 @@\n+                                       Runnable preTerminationCallback,\n@@ -453,1 +456,1 @@\n-                    createResponseSubscriber(handler, new ResponseInfoImpl(response));\n+                    createResponseSubscriber(handler, preTerminationCallback, new ResponseInfoImpl(response));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3PushPromiseStream.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOError;\n@@ -415,1 +414,1 @@\n-                        return exch.readBodyAsync(responseHandler)\n+                        return exch.readBodyAsync(responseHandler, this::cancelTimer)\n@@ -470,0 +469,2 @@\n+            \/\/ Retried\/Forwarded requests should reset the timer, if present\n+            cancelTimer();\n@@ -505,1 +506,0 @@\n-                        cancelTimer();\n@@ -523,1 +523,0 @@\n-                    cancelTimer();\n@@ -528,0 +527,8 @@\n+\n+                    \/\/ Cancel the timer. Note that we only do so if the\n+                    \/\/ response has completed exceptionally. That is, we don't\n+                    \/\/ cancel the timer if there are no exceptions, since the\n+                    \/\/ response body might still get consumed, and it is\n+                    \/\/ still subject to the response timer.\n+                    cancelTimer();\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+                                       Runnable preTerminationCallback,\n@@ -375,2 +376,2 @@\n-            Http2StreamResponseSubscriber<T> bodySubscriber =\n-                    createResponseSubscriber(handler, new ResponseInfoImpl(response));\n+            var bodySubscriber = createResponseSubscriber(\n+                    handler, new ResponseInfoImpl(response), preTerminationCallback);\n@@ -393,4 +394,5 @@\n-    Http2StreamResponseSubscriber<T> createResponseSubscriber(BodyHandler<T> handler, ResponseInfo response) {\n-        Http2StreamResponseSubscriber<T> subscriber =\n-                new Http2StreamResponseSubscriber<>(handler.apply(response));\n-        return subscriber;\n+    Http2StreamResponseSubscriber<T> createResponseSubscriber(\n+            BodyHandler<T> handler,\n+            ResponseInfo response,\n+            Runnable preTerminationCallback) {\n+        return new Http2StreamResponseSubscriber<>(handler.apply(response), preTerminationCallback);\n@@ -1721,0 +1723,1 @@\n+                Runnable preTerminationCallback,\n@@ -1724,1 +1727,1 @@\n-            return super.readBodyAsync(handler, returnConnectionToPool, executor)\n+            return super.readBodyAsync(handler, preTerminationCallback, returnConnectionToPool, executor)\n@@ -1734,1 +1737,1 @@\n-            start.thenCompose( v -> readBodyAsync(getPushHandler(), false, getExchange().executor()))\n+            start.thenCompose( v -> readBodyAsync(getPushHandler(), null, false, getExchange().executor()))\n@@ -1958,2 +1961,2 @@\n-        Http2StreamResponseSubscriber(BodySubscriber<U> subscriber) {\n-            super(subscriber);\n+        Http2StreamResponseSubscriber(BodySubscriber<U> subscriber, Runnable preTerminationCallback) {\n+            super(subscriber, preTerminationCallback);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -54,1 +53,0 @@\n-\n@@ -70,0 +68,1 @@\n+    private final Runnable preTerminationCallback;\n@@ -74,2 +73,11 @@\n-    public HttpBodySubscriberWrapper(BodySubscriber<T> userSubscriber) {\n-        this.userSubscriber = userSubscriber;\n+\n+    \/**\n+     * Creates a new instance using provided details.\n+     *\n+     * @param userSubscriber a subscriber to wrap and delegate to\n+     * @param preTerminationCallback a callback to be invoked before completion\n+     *                              with either success or failure, can be null\n+     *\/\n+    public HttpBodySubscriberWrapper(BodySubscriber<T> userSubscriber, Runnable preTerminationCallback) {\n+        this.userSubscriber = Objects.requireNonNull(userSubscriber);\n+        this.preTerminationCallback = preTerminationCallback;\n@@ -399,0 +407,1 @@\n+\n@@ -401,0 +410,3 @@\n+        if (preTerminationCallback != null) {\n+            preTerminationCallback.run();\n+        }\n@@ -406,0 +418,3 @@\n+        if (preTerminationCallback != null) {\n+            preTerminationCallback.run();\n+        }\n@@ -408,0 +423,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.InputStream;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response body<\/b> timeouts.\n+ *\n+ * @implNote\n+ *\n+ * Using a response body subscriber (i.e., {@link InputStream}) of type that\n+ * allows gradual consumption of the response body after successfully building\n+ * an {@link HttpResponse} instance to ensure timeouts are propagated even\n+ * after the {@code HttpResponse} construction.\n+ * <p>\n+ * Each test is provided a pristine ephemeral client to avoid any unexpected\n+ * effects due to pooling.\n+ *\/\n+class TimeoutResponseBodyTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseBodyTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                HttpResponse<InputStream> response = client.send(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<InputStream>> responseFuture = client.sendAsync(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                HttpResponse<InputStream> response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyDoesNotArrive(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (InputStream responseBodyStream = response.body()) {\n+                int readByte = responseBodyStream.read();\n+                fail(\"Unexpected read byte: \" + readByte);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                HttpResponse<InputStream> response = client.send(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<InputStream>> responseFuture = client.sendAsync(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                HttpResponse<InputStream> response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyArrivesSlow(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (InputStream responseBodyStream = response.body()) {\n+                int i = 0;\n+                int l = ServerRequestPair.CONTENT_LENGTH;\n+                for (; i < l; i++) {\n+                    LOGGER.log(\"Reading byte %s\/%s\", i, l);\n+                    int readByte = responseBodyStream.read();\n+                    if (readByte < 0) {\n+                        break;\n+                    }\n+                    assertEquals(i, readByte);\n+                }\n+                fail(\"Should not have reached here! (i=%s)\".formatted(i));\n+            }\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseBodyTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response header<\/b> timeouts.\n+ *\/\n+class TimeoutResponseHeaderTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseHeaderTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    static {\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_HEADER_DELIVERY;\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSend(ServerRequestPair pair) throws Exception {\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(\n+                    REQUEST_TIMEOUT.multipliedBy(2),\n+                    () -> assertThrowsHttpTimeoutException(() -> {\n+                        LOGGER.log(\"Sending the request\");\n+                        client.send(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                    }));\n+        }\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsync(ServerRequestPair pair) throws Exception {\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<Void>> responseFuture =\n+                        client.sendAsync(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                assertThrowsHttpTimeoutException(() -> {\n+                    LOGGER.log(\"Obtaining the response\");\n+                    responseFuture.get();\n+                });\n+            });\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseHeaderTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.internal.net.http.http3.Http3Error;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Utilities for {@code TimeoutResponse*Test}s.\n+ *\n+ * @see TimeoutResponseBodyTest Server <b>response body<\/b> timeout tests\n+ * @see TimeoutResponseHeaderTest Server <b>response header<\/b> timeout tests\n+ * @see TimeoutBasic Server <b>connection<\/b> timeout tests\n+ *\/\n+public class TimeoutResponseTestSupport {\n+\n+    private static final String CLASS_NAME = TimeoutResponseTestSupport.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    protected static final Duration REQUEST_TIMEOUT =\n+            Duration.ofMillis(Long.parseLong(System.getProperty(\"test.requestTimeoutMillis\")));\n+\n+    static {\n+        assertTrue(\n+                REQUEST_TIMEOUT.isPositive(),\n+                \"was expecting `test.requestTimeoutMillis > 0`, found: \" + REQUEST_TIMEOUT);\n+    }\n+\n+    protected static final int RETRY_LIMIT =\n+            Integer.parseInt(System.getProperty(\"jdk.httpclient.redirects.retrylimit\", \"0\"));\n+\n+    private static final long RESPONSE_FAILURE_WAIT_DURATION_MILLIS =\n+            Long.parseLong(System.getProperty(\"test.responseFailureWaitDurationMillis\", \"0\"));\n+\n+    static {\n+        if (RETRY_LIMIT > 0) {\n+\n+            \/\/ Verify that response failure wait duration is provided\n+            if (RESPONSE_FAILURE_WAIT_DURATION_MILLIS <= 0) {\n+                String message = String.format(\n+                        \"`jdk.httpclient.redirects.retrylimit` (%s) is greater than zero. \" +\n+                                \"`test.responseFailureWaitDurationMillis` (%s) must be greater than zero too.\",\n+                        RETRY_LIMIT, RESPONSE_FAILURE_WAIT_DURATION_MILLIS);\n+                throw new AssertionError(message);\n+            }\n+\n+            \/\/ Verify that the total response failure waits exceed the request timeout\n+            Duration totalResponseFailureWaitDuration = Duration\n+                    .ofMillis(RESPONSE_FAILURE_WAIT_DURATION_MILLIS)\n+                    .multipliedBy(RETRY_LIMIT);\n+            if (totalResponseFailureWaitDuration.compareTo(REQUEST_TIMEOUT) <= 0) {\n+                String message = (\"`test.responseFailureWaitDurationMillis * jdk.httpclient.redirects.retrylimit` (%s * %s = %s) \" +\n+                        \"must be greater than `test.requestTimeoutMillis` (%s)\")\n+                        .formatted(\n+                                RESPONSE_FAILURE_WAIT_DURATION_MILLIS,\n+                                RETRY_LIMIT,\n+                                totalResponseFailureWaitDuration,\n+                                REQUEST_TIMEOUT);\n+                throw new AssertionError(message);\n+            }\n+\n+        }\n+    }\n+\n+    protected static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true),\n+            HTTP3 = ServerRequestPair.of(Version.HTTP_3, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    protected record ServerRequestPair(\n+            HttpServerAdapters.HttpTestServer server,\n+            HttpRequest request,\n+            boolean secure) {\n+\n+        private static final ExecutorService EXECUTOR = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        private static final CountDownLatch SHUT_DOWN_LATCH = new CountDownLatch(1);\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        \/**\n+         * An arbitrary content length to cause the client wait for it.\n+         * It just needs to be greater than zero, and big enough to trigger a timeout when delivered slowly.\n+         *\/\n+        public static final int CONTENT_LENGTH = 1234;\n+\n+        public enum ServerHandlerBehaviour {\n+            BLOCK_BEFORE_HEADER_DELIVERY,\n+            BLOCK_BEFORE_BODY_DELIVERY,\n+            DELIVER_BODY_SLOWLY\n+        }\n+\n+        public static volatile ServerHandlerBehaviour SERVER_HANDLER_BEHAVIOUR;\n+\n+        public static volatile int SERVER_HANDLER_PENDING_FAILURE_COUNT = 0;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            String serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            HttpServerAdapters.HttpTestServer server = createServer(version, sslContext);\n+            server.getVersion();\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            URI requestUri = URI.create(\"%s:\/\/%s%s-\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+\n+            \/\/ Register the request handler\n+            server.addHandler(createServerHandler(serverId), handlerPath);\n+\n+            \/\/ Create the request\n+            HttpRequest request = createRequestBuilder(requestUri, version).timeout(REQUEST_TIMEOUT).build();\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(server, request, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n+\n+        }\n+\n+        private static HttpServerAdapters.HttpTestServer createServer(\n+                Version version,\n+                SSLContext sslContext) {\n+            try {\n+                return switch (version) {\n+                    case HTTP_1_1, HTTP_2 -> HttpServerAdapters.HttpTestServer.create(version, sslContext, EXECUTOR);\n+                    case HTTP_3 -> HttpServerAdapters.HttpTestServer.create(HTTP_3_URI_ONLY, sslContext, EXECUTOR);\n+                };\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpServerAdapters.HttpTestHandler createServerHandler(String serverId) {\n+            return (exchange) -> {\n+                String connectionKey = exchange.getConnectionKey();\n+                LOGGER.log(\n+                        \"Server[%s] has received request %s\",\n+                        serverId, Map.of(\"connectionKey\", connectionKey));\n+                try (exchange) {\n+\n+                    \/\/ Short-circuit on `HEAD` requests.\n+                    \/\/ They are used for admitting established connections to the pool.\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        LOGGER.log(\n+                                \"Server[%s] is responding to the `HEAD` request %s\",\n+                                serverId, Map.of(\"connectionKey\", connectionKey));\n+                        exchange.sendResponseHeaders(200, 0);\n+                        return;\n+                    }\n+\n+                    \/\/ Short-circuit if instructed to fail\n+                    synchronized (ServerRequestPair.class) {\n+                        if (SERVER_HANDLER_PENDING_FAILURE_COUNT > 0) {\n+                            LOGGER.log(\n+                                    \"Server[%s] is prematurely failing as instructed %s\",\n+                                    serverId,\n+                                    Map.of(\n+                                            \"connectionKey\", connectionKey,\n+                                            \"SERVER_HANDLER_PENDING_FAILURE_COUNT\", SERVER_HANDLER_PENDING_FAILURE_COUNT));\n+                            \/\/ Closing the exchange will trigger an `END_STREAM` without a headers frame.\n+                            \/\/ This is a protocol violation, hence we must reset the stream first.\n+                            \/\/ We are doing so using by rejecting the stream, which is known to make the client retry.\n+                            if (Version.HTTP_2.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(ErrorFrame.REFUSED_STREAM);\n+                            } else if (Version.HTTP_3.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(Http3Error.H3_REQUEST_REJECTED.code());\n+                            }\n+                            SERVER_HANDLER_PENDING_FAILURE_COUNT--;\n+                            return;\n+                        }\n+                    }\n+\n+                    switch (SERVER_HANDLER_BEHAVIOUR) {\n+\n+                        case BLOCK_BEFORE_HEADER_DELIVERY:\n+                            sleepIndefinitely(serverId, connectionKey);\n+                            break;\n+\n+                        case BLOCK_BEFORE_BODY_DELIVERY:\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sleepIndefinitely(serverId, connectionKey);\n+                            break;\n+\n+                        case DELIVER_BODY_SLOWLY:\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sendResponseBodySlowly(serverId, exchange, connectionKey);\n+                            break;\n+                    }\n+\n+                } catch (Exception exception) {\n+                    String message = String.format(\n+                            \"Server[%s] has failed! %s\",\n+                            serverId, Map.of(\"connectionKey\", connectionKey));\n+                    LOGGER.log(System.Logger.Level.ERROR, message, exception);\n+                    if (exception instanceof InterruptedException) {\n+                        \/\/ Restore the interrupt\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    throw new RuntimeException(message, exception);\n+                }\n+            };\n+        }\n+\n+        private static void sleepIndefinitely(String serverId, String connectionKey) throws InterruptedException {\n+            LOGGER.log(\"Server[%s] is sleeping %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            SHUT_DOWN_LATCH.await();\n+        }\n+\n+        private static void sendResponseHeaders(\n+                String serverId,\n+                HttpServerAdapters.HttpTestExchange exchange,\n+                String connectionKey)\n+                throws IOException {\n+            LOGGER.log(\"Server[%s] is sending headers %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            exchange.sendResponseHeaders(200, CONTENT_LENGTH);\n+            \/\/ Force the headers to be flushed\n+            exchange.getResponseBody().flush();\n+        }\n+\n+        private static void sendResponseBodySlowly(\n+                String serverId,\n+                HttpServerAdapters.HttpTestExchange exchange,\n+                String connectionKey)\n+                throws Exception {\n+            Duration perBytePauseDuration = Duration.ofMillis(100);\n+            assertTrue(\n+                    perBytePauseDuration.multipliedBy(CONTENT_LENGTH).compareTo(REQUEST_TIMEOUT) > 0,\n+                    \"Per-byte pause duration (%s) must be long enough to exceed the timeout (%s) when delivering the content (%s bytes)\".formatted(\n+                            perBytePauseDuration, REQUEST_TIMEOUT, CONTENT_LENGTH));\n+            try (OutputStream responseBody = exchange.getResponseBody()) {\n+                for (int i = 0; i < CONTENT_LENGTH; i++) {\n+                    LOGGER.log(\n+                            \"Server[%s] is sending the body %s\/%s %s\",\n+                            serverId, i, CONTENT_LENGTH, Map.of(\"connectionKey\", connectionKey));\n+                    responseBody.write(i);\n+                    responseBody.flush();\n+                    Thread.sleep(perBytePauseDuration);\n+                }\n+                throw new AssertionError(\"Delivery should never have succeeded due to timeout!\");\n+            } catch (IOException _) {\n+                \/\/ Client's timeout mechanism is expected to short-circuit and cut the stream.\n+                \/\/ Hence, discard I\/O failures.\n+            }\n+        }\n+\n+        public HttpClient createClientWithEstablishedConnection() throws IOException, InterruptedException {\n+            Version version = server.getVersion();\n+            HttpClient client = HttpServerAdapters\n+                    .createClientBuilderFor(version)\n+                    .version(version)\n+                    .sslContext(SSL_CONTEXT)\n+                    .proxy(NO_PROXY)\n+                    .build();\n+            \/\/ Ensure an established connection is admitted to the pool. This\n+            \/\/ helps to cross out any possibilities of a timeout before a\n+            \/\/ request makes it to the server handler. For instance, consider\n+            \/\/ HTTP\/1.1 to HTTP\/2 upgrades, or long-running TLS handshakes.\n+            HttpRequest headRequest = createRequestBuilder(request.uri(), version).HEAD().build();\n+            client.send(headRequest, HttpResponse.BodyHandlers.discarding());\n+            return client;\n+        }\n+\n+        private static HttpRequest.Builder createRequestBuilder(URI uri, Version version) {\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).version(version);\n+            if (Version.HTTP_3.equals(version)) {\n+                requestBuilder.setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY);\n+            }\n+            return requestBuilder;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            Version version = server.getVersion();\n+            String versionString = version.toString();\n+            return switch (version) {\n+                case HTTP_1_1, HTTP_2 -> secure ? versionString.replaceFirst(\"_\", \"S_\") : versionString;\n+                case HTTP_3 -> versionString;\n+            };\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServers() {\n+\n+        \/\/ Terminate all handlers before shutting down the server, which would block otherwise.\n+        ServerRequestPair.SHUT_DOWN_LATCH.countDown();\n+        ServerRequestPair.EXECUTOR.shutdown();\n+\n+        \/\/ Shut down servers\n+        Exception[] exceptionRef = {null};\n+        serverRequestPairs()\n+                .forEach(pair -> {\n+                    try {\n+                        pair.server.stop();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Configures how many times the handler should fail.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerFailureIndex() {\n+        ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT = Math.max(0, RETRY_LIMIT - 1);\n+    }\n+\n+    \/**\n+     * Ensures that the handler has failed as many times as instructed.\n+     *\/\n+    @AfterEach\n+    void verifyServerHandlerFailureIndex() {\n+        assertEquals(0, ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT);\n+    }\n+\n+    protected static Stream<ServerRequestPair> serverRequestPairs() {\n+        return Stream.of(HTTP1, HTTPS1, HTTP2, HTTPS2, HTTP3);\n+    }\n+\n+    protected static void assertThrowsHttpTimeoutException(Executable executable) {\n+        Exception rootException = assertThrows(Exception.class, executable);\n+        \/\/ Due to intricacies involved in the way exceptions are generated and\n+        \/\/ nested, there is no bullet-proof way to determine at which level of\n+        \/\/ the causal chain an `HttpTimeoutException` will show up. Hence, we\n+        \/\/ scan through the entire causal chain.\n+        Throwable exception = rootException;\n+        while (exception != null) {\n+            if (exception instanceof HttpTimeoutException) {\n+                return;\n+            }\n+            exception = exception.getCause();\n+        }\n+        throw new AssertionError(\"was expecting an `HttpTimeoutException` in the causal chain\", rootException);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseTestSupport.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"}]}