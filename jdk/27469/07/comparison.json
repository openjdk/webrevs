{"files":[{"patch":"@@ -311,0 +311,5 @@\n+         * @implSpec\n+         * A connection timeout applies to the entire connection phase, from the\n+         * moment a connection is requested until it is established. The elapsed\n+         * time includes any SSL\/TLS handshake.\n+         *\n@@ -315,0 +320,2 @@\n+         * @see HttpRequest.Builder#timeout(Duration) Configuring timeout for\n+         * request execution\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -261,2 +261,16 @@\n-         * of not setting a timeout is the same as setting an infinite Duration,\n-         * i.e. block forever.\n+         * of not setting a timeout is the same as setting an infinite\n+         * {@code Duration}, i.e., block forever.\n+         *\n+         * @implSpec\n+         * A timeout applies to the duration measured from the instant the\n+         * request execution starts to, <em>at least<\/em>, the instant an\n+         * {@link HttpResponse} is constructed. The elapsed time includes\n+         * obtaining a connection for transport and retrieving the response\n+         * headers.\n+         *\n+         * @implNote\n+         * The JDK built-in implementation applies timeout over the duration\n+         * measured from the instant the request execution starts to <b>the\n+         * instant the response body is consumed<\/b>, if present. This is\n+         * implemented by stopping the timer after the response body subscriber\n+         * completion.\n@@ -267,0 +281,2 @@\n+         * @see HttpClient.Builder#connectTimeout(Duration) Configuring\n+         * timeout for connection establishment\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,5 @@\n+         * @implSpec\n+         * A connection timeout applies to the entire connection phase, from the\n+         * moment a connection is requested until it is established. The elapsed\n+         * time includes any SSL\/TLS handshake.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/WebSocket.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,0 +223,6 @@\n+\n+        @Override\n+        protected void onTermination() {\n+            exchange.exchange.multi.cancelTimer();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -571,0 +571,5 @@\n+        @Override\n+        protected void onTermination() {\n+            exchange.multi.cancelTimer();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -245,0 +245,6 @@\n+\n+        @Override\n+        protected void onTermination() {\n+            exchange.multi.cancelTimer();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3PushPromiseStream.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOError;\n@@ -257,1 +256,1 @@\n-    private void cancelTimer() {\n+    void cancelTimer() {\n@@ -470,0 +469,2 @@\n+            \/\/ Retried\/Forwarded requests should reset the timer, if present\n+            cancelTimer();\n@@ -505,1 +506,0 @@\n-                        cancelTimer();\n@@ -523,1 +523,0 @@\n-                    cancelTimer();\n@@ -528,0 +527,8 @@\n+\n+                    \/\/ Cancel the timer. Note that we only do so if the\n+                    \/\/ response has completed exceptionally. That is, we don't\n+                    \/\/ cancel the timer if there are no exceptions, since the\n+                    \/\/ response body might still get consumed, and it is\n+                    \/\/ still subject to the response timer.\n+                    cancelTimer();\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1972,0 +1972,5 @@\n+        @Override\n+        protected void onTermination() {\n+            exchange.multi.cancelTimer();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -54,1 +53,0 @@\n-\n@@ -78,1 +76,12 @@\n-    private class SubscriptionWrapper implements Subscription {\n+    \/**\n+     * A callback to be invoked <em>before<\/em> termination, whether due to the\n+     * completion or failure of the subscriber, or cancellation of the\n+     * subscription. To be precise, this method is called before\n+     * {@link #onComplete()}, {@link #onError(Throwable) onError()}, or\n+     * {@link #onCancel()}.\n+     *\/\n+    protected void onTermination() {\n+        \/\/ Do nothing\n+    }\n+\n+    private final class SubscriptionWrapper implements Subscription {\n@@ -95,0 +104,1 @@\n+                        onTermination();\n@@ -287,0 +297,1 @@\n+            onTermination();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.InputStream;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response body<\/b> timeouts.\n+ *\n+ * @implNote\n+ *\n+ * Using a response body subscriber (i.e., {@link InputStream}) of type that\n+ * allows gradual consumption of the response body after successfully building\n+ * an {@link HttpResponse} instance to ensure timeouts are propagated even\n+ * after the {@code HttpResponse} construction.\n+ * <p>\n+ * Each test is provided a pristine ephemeral client to avoid any unexpected\n+ * effects due to pooling.\n+ *\/\n+class TimeoutResponseBodyTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseBodyTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                HttpResponse<InputStream> response = client.send(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<InputStream>> responseFuture = client.sendAsync(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                HttpResponse<InputStream> response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyDoesNotArrive(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (InputStream responseBodyStream = response.body()) {\n+                int readByte = responseBodyStream.read();\n+                fail(\"Unexpected read byte: \" + readByte);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                HttpResponse<InputStream> response = client.send(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<InputStream>> responseFuture = client.sendAsync(\n+                        pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                HttpResponse<InputStream> response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyArrivesSlow(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (InputStream responseBodyStream = response.body()) {\n+                int i = 0;\n+                int l = ServerRequestPair.CONTENT_LENGTH;\n+                for (; i < l; i++) {\n+                    LOGGER.log(\"Reading byte %s\/%s\", i, l);\n+                    int readByte = responseBodyStream.read();\n+                    if (readByte < 0) {\n+                        break;\n+                    }\n+                    assertEquals(i, readByte);\n+                }\n+                fail(\"Should not have reached here! (i=%s)\".formatted(i));\n+            }\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseBodyTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @build TimeoutResponseTestSupport\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response header<\/b> timeouts.\n+ *\/\n+class TimeoutResponseHeaderTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseHeaderTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    static {\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_HEADER_DELIVERY;\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSend(ServerRequestPair pair) throws Exception {\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(\n+                    REQUEST_TIMEOUT.multipliedBy(2),\n+                    () -> assertThrowsHttpTimeoutException(() -> {\n+                        LOGGER.log(\"Sending the request\");\n+                        client.send(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                    }));\n+        }\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsync(ServerRequestPair pair) throws Exception {\n+        try (HttpClient client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                CompletableFuture<HttpResponse<Void>> responseFuture =\n+                        client.sendAsync(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                assertThrowsHttpTimeoutException(() -> {\n+                    LOGGER.log(\"Obtaining the response\");\n+                    responseFuture.get();\n+                });\n+            });\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseHeaderTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.internal.net.http.http3.Http3Error;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.createClientBuilderFor;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Utilities for {@code TimeoutResponse*Test}s.\n+ *\n+ * @see TimeoutResponseBodyTest Server <b>response body<\/b> timeout tests\n+ * @see TimeoutResponseHeaderTest Server <b>response header<\/b> timeout tests\n+ * @see TimeoutBasic Server <b>connection<\/b> timeout tests\n+ *\/\n+public class TimeoutResponseTestSupport {\n+\n+    private static final String CLASS_NAME = TimeoutResponseTestSupport.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    protected static final Duration REQUEST_TIMEOUT =\n+            Duration.ofMillis(Long.parseLong(System.getProperty(\"test.requestTimeoutMillis\")));\n+\n+    static {\n+        assertTrue(\n+                REQUEST_TIMEOUT.isPositive(),\n+                \"was expecting `test.requestTimeoutMillis > 0`, found: \" + REQUEST_TIMEOUT);\n+    }\n+\n+    protected static final int RETRY_LIMIT =\n+            Integer.parseInt(System.getProperty(\"jdk.httpclient.redirects.retrylimit\", \"0\"));\n+\n+    private static final long RESPONSE_FAILURE_WAIT_DURATION_MILLIS =\n+            Long.parseLong(System.getProperty(\"test.responseFailureWaitDurationMillis\", \"0\"));\n+\n+    static {\n+        if (RETRY_LIMIT > 0) {\n+\n+            \/\/ Verify that response failure wait duration is provided\n+            if (RESPONSE_FAILURE_WAIT_DURATION_MILLIS <= 0) {\n+                String message = String.format(\n+                        \"`jdk.httpclient.redirects.retrylimit` (%s) is greater than zero. \" +\n+                                \"`test.responseFailureWaitDurationMillis` (%s) must be greater than zero too.\",\n+                        RETRY_LIMIT, RESPONSE_FAILURE_WAIT_DURATION_MILLIS);\n+                throw new AssertionError(message);\n+            }\n+\n+            \/\/ Verify that the total response failure waits exceed the request timeout\n+            Duration totalResponseFailureWaitDuration = Duration\n+                    .ofMillis(RESPONSE_FAILURE_WAIT_DURATION_MILLIS)\n+                    .multipliedBy(RETRY_LIMIT);\n+            if (totalResponseFailureWaitDuration.compareTo(REQUEST_TIMEOUT) <= 0) {\n+                String message = (\"`test.responseFailureWaitDurationMillis * jdk.httpclient.redirects.retrylimit` (%s * %s = %s) \" +\n+                        \"must be greater than `test.requestTimeoutMillis` (%s)\")\n+                        .formatted(\n+                                RESPONSE_FAILURE_WAIT_DURATION_MILLIS,\n+                                RETRY_LIMIT,\n+                                totalResponseFailureWaitDuration,\n+                                REQUEST_TIMEOUT);\n+                throw new AssertionError(message);\n+            }\n+\n+        }\n+    }\n+\n+    protected static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true),\n+            HTTP3 = ServerRequestPair.of(Version.HTTP_3, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    protected record ServerRequestPair(HttpTestServer server, HttpRequest request, boolean secure) {\n+\n+        private static final ExecutorService EXECUTOR = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        private static final CountDownLatch SHUT_DOWN_LATCH = new CountDownLatch(1);\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        \/**\n+         * An arbitrary content length to cause the client wait for it.\n+         * It just needs to be greater than zero, and big enough to trigger a timeout when delivered slowly.\n+         *\/\n+        public static final int CONTENT_LENGTH = 1234;\n+\n+        public enum ServerHandlerBehaviour {\n+            BLOCK_BEFORE_HEADER_DELIVERY,\n+            BLOCK_BEFORE_BODY_DELIVERY,\n+            DELIVER_BODY_SLOWLY\n+        }\n+\n+        public static volatile ServerHandlerBehaviour SERVER_HANDLER_BEHAVIOUR;\n+\n+        public static volatile int SERVER_HANDLER_PENDING_FAILURE_COUNT = 0;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            String serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            HttpTestServer server = createServer(version, sslContext);\n+            server.getVersion();\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            URI requestUri = URI.create(\"%s:\/\/%s%s-\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+\n+            \/\/ Register the request handler\n+            server.addHandler(createServerHandler(serverId), handlerPath);\n+\n+            \/\/ Create the request\n+            HttpRequest request = createRequestBuilder(requestUri, version).timeout(REQUEST_TIMEOUT).build();\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(server, request, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                return switch (version) {\n+                    case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext, EXECUTOR);\n+                    case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext, EXECUTOR);\n+                };\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpTestHandler createServerHandler(String serverId) {\n+            return (exchange) -> {\n+                String connectionKey = exchange.getConnectionKey();\n+                LOGGER.log(\n+                        \"Server[%s] has received request %s\",\n+                        serverId, Map.of(\"connectionKey\", connectionKey));\n+                try (exchange) {\n+\n+                    \/\/ Short-circuit on `HEAD` requests.\n+                    \/\/ They are used for admitting established connections to the pool.\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        LOGGER.log(\n+                                \"Server[%s] is responding to the `HEAD` request %s\",\n+                                serverId, Map.of(\"connectionKey\", connectionKey));\n+                        exchange.sendResponseHeaders(200, 0);\n+                        return;\n+                    }\n+\n+                    \/\/ Short-circuit if instructed to fail\n+                    synchronized (ServerRequestPair.class) {\n+                        if (SERVER_HANDLER_PENDING_FAILURE_COUNT > 0) {\n+                            LOGGER.log(\n+                                    \"Server[%s] is prematurely failing as instructed %s\",\n+                                    serverId,\n+                                    Map.of(\n+                                            \"connectionKey\", connectionKey,\n+                                            \"SERVER_HANDLER_PENDING_FAILURE_COUNT\", SERVER_HANDLER_PENDING_FAILURE_COUNT));\n+                            \/\/ Closing the exchange will trigger an `END_STREAM` without a headers frame.\n+                            \/\/ This is a protocol violation, hence we must reset the stream first.\n+                            \/\/ We are doing so using by rejecting the stream, which is known to make the client retry.\n+                            if (Version.HTTP_2.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(ErrorFrame.REFUSED_STREAM);\n+                            } else if (Version.HTTP_3.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(Http3Error.H3_REQUEST_REJECTED.code());\n+                            }\n+                            SERVER_HANDLER_PENDING_FAILURE_COUNT--;\n+                            return;\n+                        }\n+                    }\n+\n+                    switch (SERVER_HANDLER_BEHAVIOUR) {\n+\n+                        case BLOCK_BEFORE_HEADER_DELIVERY:\n+                            sleepIndefinitely(serverId, connectionKey);\n+                            break;\n+\n+                        case BLOCK_BEFORE_BODY_DELIVERY:\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sleepIndefinitely(serverId, connectionKey);\n+                            break;\n+\n+                        case DELIVER_BODY_SLOWLY:\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sendResponseBodySlowly(serverId, exchange, connectionKey);\n+                            break;\n+                    }\n+\n+                } catch (Exception exception) {\n+                    String message = String.format(\n+                            \"Server[%s] has failed! %s\",\n+                            serverId, Map.of(\"connectionKey\", connectionKey));\n+                    LOGGER.log(System.Logger.Level.ERROR, message, exception);\n+                    if (exception instanceof InterruptedException) {\n+                        \/\/ Restore the interrupt\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    throw new RuntimeException(message, exception);\n+                }\n+            };\n+        }\n+\n+        private static void sleepIndefinitely(String serverId, String connectionKey) throws InterruptedException {\n+            LOGGER.log(\"Server[%s] is sleeping %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            SHUT_DOWN_LATCH.await();\n+        }\n+\n+        private static void sendResponseHeaders(String serverId, HttpTestExchange exchange, String connectionKey)\n+                throws IOException {\n+            LOGGER.log(\"Server[%s] is sending headers %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            exchange.sendResponseHeaders(200, CONTENT_LENGTH);\n+            \/\/ Force the headers to be flushed\n+            exchange.getResponseBody().flush();\n+        }\n+\n+        private static void sendResponseBodySlowly(String serverId, HttpTestExchange exchange, String connectionKey)\n+                throws Exception {\n+            Duration perBytePauseDuration = Duration.ofMillis(100);\n+            assertTrue(\n+                    perBytePauseDuration.multipliedBy(CONTENT_LENGTH).compareTo(REQUEST_TIMEOUT) > 0,\n+                    \"Per-byte pause duration (%s) must be long enough to exceed the timeout (%s) when delivering the content (%s bytes)\".formatted(\n+                            perBytePauseDuration, REQUEST_TIMEOUT, CONTENT_LENGTH));\n+            try (OutputStream responseBody = exchange.getResponseBody()) {\n+                for (int i = 0; i < CONTENT_LENGTH; i++) {\n+                    LOGGER.log(\n+                            \"Server[%s] is sending the body %s\/%s %s\",\n+                            serverId, i, CONTENT_LENGTH, Map.of(\"connectionKey\", connectionKey));\n+                    responseBody.write(i);\n+                    responseBody.flush();\n+                    Thread.sleep(perBytePauseDuration);\n+                }\n+                throw new AssertionError(\"Delivery should never have succeeded due to timeout!\");\n+            } catch (IOException _) {\n+                \/\/ Client's timeout mechanism is expected to short-circuit and cut the stream.\n+                \/\/ Hence, discard I\/O failures.\n+            }\n+        }\n+\n+        public HttpClient createClientWithEstablishedConnection() throws IOException, InterruptedException {\n+            Version version = server.getVersion();\n+            HttpClient client = createClientBuilderFor(version)\n+                    .version(version)\n+                    .sslContext(SSL_CONTEXT)\n+                    .proxy(NO_PROXY)\n+                    .build();\n+            \/\/ Ensure an established connection is admitted to the pool. This\n+            \/\/ helps to cross out any possibilities of a timeout before a\n+            \/\/ request makes it to the server handler. For instance, consider\n+            \/\/ HTTP\/1.1 to HTTP\/2 upgrades, or long-running TLS handshakes.\n+            HttpRequest headRequest = createRequestBuilder(request.uri(), version).HEAD().build();\n+            client.send(headRequest, HttpResponse.BodyHandlers.discarding());\n+            return client;\n+        }\n+\n+        private static HttpRequest.Builder createRequestBuilder(URI uri, Version version) {\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(uri).version(version);\n+            if (Version.HTTP_3.equals(version)) {\n+                requestBuilder.setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY);\n+            }\n+            return requestBuilder;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            Version version = server.getVersion();\n+            String versionString = version.toString();\n+            return switch (version) {\n+                case HTTP_1_1, HTTP_2 -> secure ? versionString.replaceFirst(\"_\", \"S_\") : versionString;\n+                case HTTP_3 -> versionString;\n+            };\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServers() {\n+\n+        \/\/ Terminate all handlers before shutting down the server, which would block otherwise.\n+        ServerRequestPair.SHUT_DOWN_LATCH.countDown();\n+        ServerRequestPair.EXECUTOR.shutdown();\n+\n+        \/\/ Shut down servers\n+        Exception[] exceptionRef = {null};\n+        serverRequestPairs()\n+                .forEach(pair -> {\n+                    try {\n+                        pair.server.stop();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Configures how many times the handler should fail.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerFailureIndex() {\n+        ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT = Math.max(0, RETRY_LIMIT - 1);\n+    }\n+\n+    \/**\n+     * Ensures that the handler has failed as many times as instructed.\n+     *\/\n+    @AfterEach\n+    void verifyServerHandlerFailureIndex() {\n+        assertEquals(0, ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT);\n+    }\n+\n+    protected static Stream<ServerRequestPair> serverRequestPairs() {\n+        return Stream.of(HTTP1, HTTPS1, HTTP2, HTTPS2, HTTP3);\n+    }\n+\n+    protected static void assertThrowsHttpTimeoutException(Executable executable) {\n+        Exception rootException = assertThrows(Exception.class, executable);\n+        \/\/ Due to intricacies involved in the way exceptions are generated and\n+        \/\/ nested, there is no bullet-proof way to determine at which level of\n+        \/\/ the causal chain an `HttpTimeoutException` will show up. Hence, we\n+        \/\/ scan through the entire causal chain.\n+        Throwable exception = rootException;\n+        while (exception != null) {\n+            if (exception instanceof HttpTimeoutException) {\n+                return;\n+            }\n+            exception = exception.getCause();\n+        }\n+        throw new AssertionError(\"was expecting an `HttpTimeoutException` in the causal chain\", rootException);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseTestSupport.java","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"}]}