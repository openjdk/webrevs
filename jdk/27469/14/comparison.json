{"files":[{"patch":"@@ -315,0 +315,5 @@\n+         * @implSpec\n+         * A connection timeout applies to the entire connection phase, from the\n+         * moment a connection is requested until it is established. The elapsed\n+         * time includes any SSL\/TLS handshake.\n+         *\n@@ -319,0 +324,2 @@\n+         * @see HttpRequest.Builder#timeout(Duration) Configuring timeout for\n+         * request execution\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -261,2 +261,16 @@\n-         * of not setting a timeout is the same as setting an infinite Duration,\n-         * i.e. block forever.\n+         * of not setting a timeout is the same as setting an infinite\n+         * {@code Duration}, i.e., block forever.\n+         *\n+         * @implSpec\n+         * A timeout applies to the duration measured from the instant the\n+         * request execution starts to, <em>at least<\/em>, the instant an\n+         * {@link HttpResponse} is constructed. The elapsed time includes\n+         * obtaining a connection for transport and retrieving the response\n+         * headers.\n+         *\n+         * @implNote\n+         * The JDK built-in implementation applies timeout over the duration\n+         * measured from the instant the request execution starts to <b>the\n+         * instant the response body is consumed<\/b>, if present. This is\n+         * implemented by stopping the timer after the response body subscriber\n+         * completion.\n@@ -267,0 +281,2 @@\n+         * @see HttpClient.Builder#connectTimeout(Duration) Configuring\n+         * timeout for connection establishment\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,5 @@\n+         * @implSpec\n+         * A connection timeout applies to the entire connection phase, from the\n+         * moment a connection is requested until it is established. The elapsed\n+         * time includes any WebSocket and SSL\/TLS handshakes.\n+         *\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/WebSocket.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -584,0 +584,12 @@\n+    \/**\n+     * {@return {@code true}, if it is allowed to cancel the request timer on\n+     * response body subscriber termination; {@code false}, otherwise}\n+     *\n+     * @param webSocket indicates if the associated request is a WebSocket handshake\n+     * @param statusCode the status code of the associated response\n+     *\/\n+    static boolean cancelTimerOnResponseBodySubscriberTermination(\n+            boolean webSocket, int statusCode) {\n+        return webSocket || statusCode < 100 || statusCode >= 200;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -209,1 +209,7 @@\n-        Http1ResponseBodySubscriber(BodySubscriber<U> userSubscriber, Http1Exchange<U> exchange) {\n+\n+        private final boolean cancelTimerOnTermination;\n+\n+        Http1ResponseBodySubscriber(\n+                BodySubscriber<U> userSubscriber,\n+                boolean cancelTimerOnTermination,\n+                Http1Exchange<U> exchange) {\n@@ -211,0 +217,1 @@\n+            this.cancelTimerOnTermination = cancelTimerOnTermination;\n@@ -223,0 +230,8 @@\n+\n+        @Override\n+        protected void onTermination() {\n+            if (cancelTimerOnTermination) {\n+                exchange.exchange.multi.cancelTimer();\n+            }\n+        }\n+\n@@ -462,3 +477,4 @@\n-        Http1ResponseBodySubscriber<T> bs =\n-                new Http1ResponseBodySubscriber<T>(subscriber, this);\n-        return bs;\n+        var cancelTimerOnTermination =\n+                cancelTimerOnResponseBodySubscriberTermination(\n+                        exchange.request().isWebSocket(), response.statusCode());\n+        return new Http1ResponseBodySubscriber<>(subscriber, cancelTimerOnTermination, this);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -557,1 +557,4 @@\n-        Http3StreamResponseSubscriber(BodySubscriber<U> subscriber) {\n+\n+        private final boolean cancelTimerOnTermination;\n+\n+        Http3StreamResponseSubscriber(BodySubscriber<U> subscriber, boolean cancelTimerOnTermination) {\n@@ -559,0 +562,1 @@\n+            this.cancelTimerOnTermination = cancelTimerOnTermination;\n@@ -571,0 +575,7 @@\n+        @Override\n+        protected void onTermination() {\n+            if (cancelTimerOnTermination) {\n+                exchange.multi.cancelTimer();\n+            }\n+        }\n+\n@@ -593,3 +604,4 @@\n-        Http3StreamResponseSubscriber<T> subscriber =\n-                new Http3StreamResponseSubscriber<>(handler.apply(response));\n-        return subscriber;\n+        var cancelTimerOnTermination =\n+                cancelTimerOnResponseBodySubscriberTermination(\n+                        exchange.request().isWebSocket(), response.statusCode());\n+        return new Http3StreamResponseSubscriber<>(handler.apply(response), cancelTimerOnTermination);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ExchangeImpl.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1833,0 +1833,7 @@\n+    \/\/ Visible for tests\n+    List<TimeoutEvent> timers() {\n+        synchronized (this) {\n+            return new ArrayList<>(timeouts);\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOError;\n@@ -257,1 +256,1 @@\n-    private void cancelTimer() {\n+    void cancelTimer() {\n@@ -407,0 +406,2 @@\n+                            \/\/ No response body consumption is expected, we can cancel the timer right away\n+                            cancelTimer();\n@@ -470,0 +471,2 @@\n+            \/\/ Retried\/Forwarded requests should reset the timer, if present\n+            cancelTimer();\n@@ -505,1 +508,0 @@\n-                        cancelTimer();\n@@ -523,1 +525,0 @@\n-                    cancelTimer();\n@@ -528,0 +529,8 @@\n+\n+                    \/\/ Cancel the timer. Note that we only do so if the\n+                    \/\/ response has completed exceptionally. That is, we don't\n+                    \/\/ cancel the timer if there are no exceptions, since the\n+                    \/\/ response body might still get consumed, and it is\n+                    \/\/ still subject to the response timer.\n+                    cancelTimer();\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -394,3 +394,4 @@\n-        Http2StreamResponseSubscriber<T> subscriber =\n-                new Http2StreamResponseSubscriber<>(handler.apply(response));\n-        return subscriber;\n+        var cancelTimerOnTermination =\n+                cancelTimerOnResponseBodySubscriberTermination(\n+                        exchange.request().isWebSocket(), response.statusCode());\n+        return new Http2StreamResponseSubscriber<>(handler.apply(response), cancelTimerOnTermination);\n@@ -1728,0 +1729,5 @@\n+        @Override\n+        Http2StreamResponseSubscriber<T> createResponseSubscriber(BodyHandler<T> handler, ResponseInfo response) {\n+            return new Http2StreamResponseSubscriber<T>(handler.apply(response), false);\n+        }\n+\n@@ -1958,1 +1964,4 @@\n-        Http2StreamResponseSubscriber(BodySubscriber<U> subscriber) {\n+\n+        private final boolean cancelTimerOnTermination;\n+\n+        Http2StreamResponseSubscriber(BodySubscriber<U> subscriber, boolean cancelTimerOnTermination) {\n@@ -1960,0 +1969,1 @@\n+            this.cancelTimerOnTermination = cancelTimerOnTermination;\n@@ -1972,0 +1982,7 @@\n+        @Override\n+        protected void onTermination() {\n+            if (cancelTimerOnTermination) {\n+                exchange.multi.cancelTimer();\n+            }\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -54,1 +53,0 @@\n-\n@@ -78,1 +76,12 @@\n-    private class SubscriptionWrapper implements Subscription {\n+    \/**\n+     * A callback to be invoked <em>before<\/em> termination, whether due to the\n+     * completion or failure of the subscriber, or cancellation of the\n+     * subscription. To be precise, this method is called before\n+     * {@link #onComplete()}, {@link #onError(Throwable) onError()}, or\n+     * {@link #onCancel()}.\n+     *\/\n+    protected void onTermination() {\n+        \/\/ Do nothing\n+    }\n+\n+    private final class SubscriptionWrapper implements Subscription {\n@@ -95,0 +104,1 @@\n+                        onTermination();\n@@ -287,0 +297,1 @@\n+            onTermination();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HttpBodySubscriberWrapper.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.InputStream;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import static jdk.internal.net.http.HttpClientTimerAccess.assertNoResponseTimerEventRegistrations;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          access\n+ * @build TimeoutResponseTestSupport\n+ *        java.net.http\/jdk.internal.net.http.HttpClientTimerAccess\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response body*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          access\n+ * @build TimeoutResponseTestSupport\n+ *        java.net.http\/jdk.internal.net.http.HttpClientTimerAccess\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseBodyTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response body<\/b> timeouts.\n+ *\n+ * @implNote\n+ *\n+ * Using a response body subscriber (i.e., {@link InputStream}) of type that\n+ * allows gradual consumption of the response body after successfully building\n+ * an {@link HttpResponse} instance to ensure timeouts are propagated even\n+ * after the {@code HttpResponse} construction.\n+ * <p>\n+ * Each test is provided a pristine ephemeral client to avoid any unexpected\n+ * effects due to pooling.\n+ *\/\n+class TimeoutResponseBodyTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseBodyTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                var response = client.send(pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering the response body.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnMissingBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_BODY_DELIVERY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                var responseFuture = client.sendAsync(pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                var response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyDoesNotArrive(response);\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyDoesNotArrive(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (var responseBodyStream = response.body()) {\n+                var readByte = responseBodyStream.read();\n+                fail(\"Unexpected read byte: \" + readByte);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                var response = client.send(pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server delivering the response body very slowly.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnSlowBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_BODY_SLOWLY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                var responseFuture = client.sendAsync(pair.request(), HttpResponse.BodyHandlers.ofInputStream());\n+                LOGGER.log(\"Obtaining the response\");\n+                var response = responseFuture.get();\n+                LOGGER.log(\"Consuming the obtained response\");\n+                verifyResponseBodyArrivesSlow(response);\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+    private static void verifyResponseBodyArrivesSlow(HttpResponse<InputStream> response) {\n+        assertEquals(200, response.statusCode());\n+        assertThrowsHttpTimeoutException(() -> {\n+            try (var responseBodyStream = response.body()) {\n+                int i = 0;\n+                int l = ServerRequestPair.CONTENT_LENGTH;\n+                for (; i < l; i++) {\n+                    LOGGER.log(\"Reading byte %s\/%s\", i, l);\n+                    var readByte = responseBodyStream.read();\n+                    if (readByte < 0) {\n+                        break;\n+                    }\n+                    assertEquals(i, readByte);\n+                }\n+                fail(\"Should not have reached here! (i=%s)\".formatted(i));\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server delivering 204, i.e., no content, which is handled\n+     * through a specialized path served by {@code MultiExchange::handleNoBody}.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendOnNoBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_NO_BODY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request\");\n+                client.send(pair.request(), HttpResponse.BodyHandlers.discarding());\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server delivering 204, i.e., no content, which is handled\n+     * through a specialized path served by {@code MultiExchange::handleNoBody}.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsyncOnNoBody(ServerRequestPair pair) throws Exception {\n+\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.DELIVER_NO_BODY;\n+\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                client.sendAsync(pair.request(), HttpResponse.BodyHandlers.discarding()).get();\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseBodyTest.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+\n+import static jdk.internal.net.http.HttpClientTimerAccess.assertNoResponseTimerEventRegistrations;\n+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;\n+\n+\/*\n+ * @test id=retriesDisabled\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts when all retry mechanisms are disabled.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *          access\n+ * @build TimeoutResponseTestSupport\n+ *        java.net.http\/jdk.internal.net.http.HttpClientTimerAccess\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=0\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/*\n+ * @test id=retriesEnabledForResponseFailure\n+ * @bug 8208693\n+ * @summary Verifies `HttpRequest::timeout` is effective for *response header*\n+ *          timeouts, where some initial responses are intentionally configured\n+ *          to fail to trigger retries.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *          access\n+ * @build TimeoutResponseTestSupport\n+ *        java.net.http\/jdk.internal.net.http.HttpClientTimerAccess\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.auth.retrylimit=0\n+ *      -Djdk.httpclient.disableRetryConnect\n+ *      -Djdk.httpclient.redirects.retrylimit=3\n+ *      -Dtest.requestTimeoutMillis=1000\n+ *      -Dtest.responseFailureWaitDurationMillis=600\n+ *      TimeoutResponseHeaderTest\n+ *\/\n+\n+\/**\n+ * Verifies {@link HttpRequest#timeout() HttpRequest.timeout()} is effective\n+ * for <b>response header<\/b> timeouts.\n+ *\/\n+class TimeoutResponseHeaderTest extends TimeoutResponseTestSupport {\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(\n+            TimeoutResponseHeaderTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    static {\n+        ServerRequestPair.SERVER_HANDLER_BEHAVIOUR =\n+                ServerRequestPair.ServerHandlerBehaviour.BLOCK_BEFORE_HEADER_DELIVERY;\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#send(HttpRequest, HttpResponse.BodyHandler) HttpClient::send}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSend(ServerRequestPair pair) throws Exception {\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(\n+                    REQUEST_TIMEOUT.multipliedBy(2),\n+                    () -> assertThrowsHttpTimeoutException(() -> {\n+                        LOGGER.log(\"Sending the request\");\n+                        client.send(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                    }));\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+    }\n+\n+    \/**\n+     * Tests timeouts using\n+     * {@link HttpClient#sendAsync(HttpRequest, HttpResponse.BodyHandler) HttpClient::sendAsync}\n+     * against a server blocking without delivering any response headers.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSendAsync(ServerRequestPair pair) throws Exception {\n+        try (var client = pair.createClientWithEstablishedConnection()) {\n+            assertTimeoutPreemptively(REQUEST_TIMEOUT.multipliedBy(2), () -> {\n+                LOGGER.log(\"Sending the request asynchronously\");\n+                var responseFuture = client.sendAsync(pair.request(), HttpResponse.BodyHandlers.discarding());\n+                assertThrowsHttpTimeoutException(() -> {\n+                    LOGGER.log(\"Obtaining the response\");\n+                    responseFuture.get();\n+                });\n+            });\n+            LOGGER.log(\"Verifying the registered response timer events\");\n+            assertNoResponseTimerEventRegistrations(client);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseHeaderTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,415 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.internal.net.http.http3.Http3Error;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.function.Executable;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.createClientBuilderFor;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Utilities for {@code TimeoutResponse*Test}s.\n+ *\n+ * @see TimeoutResponseBodyTest Server <b>response body<\/b> timeout tests\n+ * @see TimeoutResponseHeaderTest Server <b>response header<\/b> timeout tests\n+ * @see TimeoutBasic Server <b>connection<\/b> timeout tests\n+ *\/\n+public class TimeoutResponseTestSupport {\n+\n+    private static final String CLASS_NAME = TimeoutResponseTestSupport.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    protected static final Duration REQUEST_TIMEOUT =\n+            Duration.ofMillis(Long.parseLong(System.getProperty(\"test.requestTimeoutMillis\")));\n+\n+    static {\n+        assertTrue(\n+                REQUEST_TIMEOUT.isPositive(),\n+                \"was expecting `test.requestTimeoutMillis > 0`, found: \" + REQUEST_TIMEOUT);\n+    }\n+\n+    protected static final int RETRY_LIMIT =\n+            Integer.parseInt(System.getProperty(\"jdk.httpclient.redirects.retrylimit\", \"0\"));\n+\n+    private static final long RESPONSE_FAILURE_WAIT_DURATION_MILLIS =\n+            Long.parseLong(System.getProperty(\"test.responseFailureWaitDurationMillis\", \"0\"));\n+\n+    static {\n+        if (RETRY_LIMIT > 0) {\n+\n+            \/\/ Verify that response failure wait duration is provided\n+            if (RESPONSE_FAILURE_WAIT_DURATION_MILLIS <= 0) {\n+                var message = String.format(\n+                        \"`jdk.httpclient.redirects.retrylimit` (%s) is greater than zero. \" +\n+                                \"`test.responseFailureWaitDurationMillis` (%s) must be greater than zero too.\",\n+                        RETRY_LIMIT, RESPONSE_FAILURE_WAIT_DURATION_MILLIS);\n+                throw new AssertionError(message);\n+            }\n+\n+            \/\/ Verify that the total response failure waits exceed the request timeout\n+            var totalResponseFailureWaitDuration = Duration\n+                    .ofMillis(RESPONSE_FAILURE_WAIT_DURATION_MILLIS)\n+                    .multipliedBy(RETRY_LIMIT);\n+            if (totalResponseFailureWaitDuration.compareTo(REQUEST_TIMEOUT) <= 0) {\n+                var message = (\"`test.responseFailureWaitDurationMillis * jdk.httpclient.redirects.retrylimit` (%s * %s = %s) \" +\n+                        \"must be greater than `test.requestTimeoutMillis` (%s)\")\n+                        .formatted(\n+                                RESPONSE_FAILURE_WAIT_DURATION_MILLIS,\n+                                RETRY_LIMIT,\n+                                totalResponseFailureWaitDuration,\n+                                REQUEST_TIMEOUT);\n+                throw new AssertionError(message);\n+            }\n+\n+        }\n+    }\n+\n+    protected static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true),\n+            HTTP3 = ServerRequestPair.of(Version.HTTP_3, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    protected record ServerRequestPair(HttpTestServer server, HttpRequest request, boolean secure) {\n+\n+        private static final ExecutorService EXECUTOR = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        private static final CountDownLatch SHUT_DOWN_LATCH = new CountDownLatch(1);\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        \/**\n+         * An arbitrary content length to cause the client wait for it.\n+         * It just needs to be greater than zero, and big enough to trigger a timeout when delivered slowly.\n+         *\/\n+        public static final int CONTENT_LENGTH = 1234;\n+\n+        public enum ServerHandlerBehaviour {\n+            BLOCK_BEFORE_HEADER_DELIVERY,\n+            BLOCK_BEFORE_BODY_DELIVERY,\n+            DELIVER_BODY_SLOWLY,\n+            DELIVER_NO_BODY\n+        }\n+\n+        public static volatile ServerHandlerBehaviour SERVER_HANDLER_BEHAVIOUR;\n+\n+        public static volatile int SERVER_HANDLER_PENDING_FAILURE_COUNT = 0;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            var sslContext = secure ? SSL_CONTEXT : null;\n+            var serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            var server = createServer(version, sslContext);\n+            server.getVersion();\n+            var handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            var requestUriScheme = secure ? \"https\" : \"http\";\n+            var requestUri = URI.create(\"%s:\/\/%s%s-\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+\n+            \/\/ Register the request handler\n+            server.addHandler(createServerHandler(serverId), handlerPath);\n+\n+            \/\/ Create the request\n+            var request = createRequestBuilder(requestUri, version).timeout(REQUEST_TIMEOUT).build();\n+\n+            \/\/ Create the pair\n+            var pair = new ServerRequestPair(server, request, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                return switch (version) {\n+                    case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext, EXECUTOR);\n+                    case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext, EXECUTOR);\n+                };\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpTestHandler createServerHandler(String serverId) {\n+            return (exchange) -> {\n+                var connectionKey = exchange.getConnectionKey();\n+                LOGGER.log(\n+                        \"Server[%s] has received request %s\",\n+                        serverId, Map.of(\"connectionKey\", connectionKey));\n+                try (exchange) {\n+\n+                    \/\/ Short-circuit on `HEAD` requests.\n+                    \/\/ They are used for admitting established connections to the pool.\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        LOGGER.log(\n+                                \"Server[%s] is responding to the `HEAD` request %s\",\n+                                serverId, Map.of(\"connectionKey\", connectionKey));\n+                        exchange.sendResponseHeaders(200, 0);\n+                        return;\n+                    }\n+\n+                    \/\/ Short-circuit if instructed to fail\n+                    synchronized (ServerRequestPair.class) {\n+                        if (SERVER_HANDLER_PENDING_FAILURE_COUNT > 0) {\n+                            LOGGER.log(\n+                                    \"Server[%s] is prematurely failing as instructed %s\",\n+                                    serverId,\n+                                    Map.of(\n+                                            \"connectionKey\", connectionKey,\n+                                            \"SERVER_HANDLER_PENDING_FAILURE_COUNT\", SERVER_HANDLER_PENDING_FAILURE_COUNT));\n+                            \/\/ Closing the exchange will trigger an `END_STREAM` without a headers frame.\n+                            \/\/ This is a protocol violation, hence we must reset the stream first.\n+                            \/\/ We are doing so using by rejecting the stream, which is known to make the client retry.\n+                            if (Version.HTTP_2.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(ErrorFrame.REFUSED_STREAM);\n+                            } else if (Version.HTTP_3.equals(exchange.getExchangeVersion())) {\n+                                exchange.resetStream(Http3Error.H3_REQUEST_REJECTED.code());\n+                            }\n+                            SERVER_HANDLER_PENDING_FAILURE_COUNT--;\n+                            return;\n+                        }\n+                    }\n+\n+                    switch (SERVER_HANDLER_BEHAVIOUR) {\n+\n+                        case BLOCK_BEFORE_HEADER_DELIVERY -> sleepIndefinitely(serverId, connectionKey);\n+\n+                        case BLOCK_BEFORE_BODY_DELIVERY -> {\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sleepIndefinitely(serverId, connectionKey);\n+                        }\n+\n+                        case DELIVER_BODY_SLOWLY -> {\n+                            sendResponseHeaders(serverId, exchange, connectionKey);\n+                            sendResponseBodySlowly(serverId, exchange, connectionKey);\n+                        }\n+\n+                        case DELIVER_NO_BODY -> sendResponseHeaders(serverId, exchange, connectionKey, 204, 0);\n+\n+                    }\n+\n+                } catch (Exception exception) {\n+                    var message = String.format(\n+                            \"Server[%s] has failed! %s\",\n+                            serverId, Map.of(\"connectionKey\", connectionKey));\n+                    LOGGER.log(System.Logger.Level.ERROR, message, exception);\n+                    if (exception instanceof InterruptedException) {\n+                        \/\/ Restore the interrupt\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    throw new RuntimeException(message, exception);\n+                }\n+            };\n+        }\n+\n+        private static void sleepIndefinitely(String serverId, String connectionKey) throws InterruptedException {\n+            LOGGER.log(\"Server[%s] is sleeping %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            SHUT_DOWN_LATCH.await();\n+        }\n+\n+        private static void sendResponseHeaders(String serverId, HttpTestExchange exchange, String connectionKey)\n+                throws IOException {\n+            sendResponseHeaders(serverId, exchange, connectionKey, 200, CONTENT_LENGTH);\n+        }\n+\n+        private static void sendResponseHeaders(\n+                String serverId,\n+                HttpTestExchange exchange,\n+                String connectionKey,\n+                int statusCode,\n+                long contentLength)\n+                throws IOException {\n+            LOGGER.log(\"Server[%s] is sending headers %s\", serverId, Map.of(\"connectionKey\", connectionKey));\n+            exchange.sendResponseHeaders(statusCode, contentLength);\n+            \/\/ Force the headers to be flushed\n+            exchange.getResponseBody().flush();\n+        }\n+\n+        private static void sendResponseBodySlowly(String serverId, HttpTestExchange exchange, String connectionKey)\n+                throws Exception {\n+            var perBytePauseDuration = Duration.ofMillis(100);\n+            assertTrue(\n+                    perBytePauseDuration.multipliedBy(CONTENT_LENGTH).compareTo(REQUEST_TIMEOUT) > 0,\n+                    \"Per-byte pause duration (%s) must be long enough to exceed the timeout (%s) when delivering the content (%s bytes)\".formatted(\n+                            perBytePauseDuration, REQUEST_TIMEOUT, CONTENT_LENGTH));\n+            try (var responseBody = exchange.getResponseBody()) {\n+                for (int i = 0; i < CONTENT_LENGTH; i++) {\n+                    LOGGER.log(\n+                            \"Server[%s] is sending the body %s\/%s %s\",\n+                            serverId, i, CONTENT_LENGTH, Map.of(\"connectionKey\", connectionKey));\n+                    responseBody.write(i);\n+                    responseBody.flush();\n+                    Thread.sleep(perBytePauseDuration);\n+                }\n+                throw new AssertionError(\"Delivery should never have succeeded due to timeout!\");\n+            } catch (IOException _) {\n+                \/\/ Client's timeout mechanism is expected to short-circuit and cut the stream.\n+                \/\/ Hence, discard I\/O failures.\n+            }\n+        }\n+\n+        public HttpClient createClientWithEstablishedConnection() throws IOException, InterruptedException {\n+            var version = server.getVersion();\n+            var client = createClientBuilderFor(version)\n+                    .version(version)\n+                    .sslContext(SSL_CONTEXT)\n+                    .proxy(NO_PROXY)\n+                    .build();\n+            \/\/ Ensure an established connection is admitted to the pool. This\n+            \/\/ helps to cross out any possibilities of a timeout before a\n+            \/\/ request makes it to the server handler. For instance, consider\n+            \/\/ HTTP\/1.1 to HTTP\/2 upgrades, or long-running TLS handshakes.\n+            var headRequest = createRequestBuilder(request.uri(), version).HEAD().build();\n+            client.send(headRequest, HttpResponse.BodyHandlers.discarding());\n+            return client;\n+        }\n+\n+        private static HttpRequest.Builder createRequestBuilder(URI uri, Version version) {\n+            var requestBuilder = HttpRequest.newBuilder(uri).version(version);\n+            if (Version.HTTP_3.equals(version)) {\n+                requestBuilder.setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY);\n+            }\n+            return requestBuilder;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var version = server.getVersion();\n+            var versionString = version.toString();\n+            return switch (version) {\n+                case HTTP_1_1, HTTP_2 -> secure ? versionString.replaceFirst(\"_\", \"S_\") : versionString;\n+                case HTTP_3 -> versionString;\n+            };\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServers() {\n+\n+        \/\/ Terminate all handlers before shutting down the server, which would block otherwise.\n+        ServerRequestPair.SHUT_DOWN_LATCH.countDown();\n+        ServerRequestPair.EXECUTOR.shutdown();\n+\n+        \/\/ Shut down servers\n+        Exception[] exceptionRef = {null};\n+        serverRequestPairs()\n+                .forEach(pair -> {\n+                    try {\n+                        pair.server.stop();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Configures how many times the handler should fail.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerFailureIndex() {\n+        ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT = Math.max(0, RETRY_LIMIT - 1);\n+    }\n+\n+    \/**\n+     * Ensures that the handler has failed as many times as instructed.\n+     *\/\n+    @AfterEach\n+    void verifyServerHandlerFailureIndex() {\n+        assertEquals(0, ServerRequestPair.SERVER_HANDLER_PENDING_FAILURE_COUNT);\n+    }\n+\n+    protected static Stream<ServerRequestPair> serverRequestPairs() {\n+        return Stream.of(HTTP1, HTTPS1, HTTP2, HTTPS2, HTTP3);\n+    }\n+\n+    protected static void assertThrowsHttpTimeoutException(Executable executable) {\n+        var rootException = assertThrows(Exception.class, executable);\n+        \/\/ Due to intricacies involved in the way exceptions are generated and\n+        \/\/ nested, there is no bullet-proof way to determine at which level of\n+        \/\/ the causal chain an `HttpTimeoutException` will show up. Hence, we\n+        \/\/ scan through the entire causal chain.\n+        Throwable exception = rootException;\n+        while (exception != null) {\n+            if (exception instanceof HttpTimeoutException) {\n+                return;\n+            }\n+            exception = exception.getCause();\n+        }\n+        throw new AssertionError(\"was expecting an `HttpTimeoutException` in the causal chain\", rootException);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/TimeoutResponseTestSupport.java","additions":415,"deletions":0,"binary":false,"changes":415,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http;\n+\n+import java.net.http.HttpClient;\n+\n+public enum HttpClientTimerAccess {;\n+\n+    public static void assertNoResponseTimerEventRegistrations(HttpClient client) {\n+        assertTimerEventRegistrationCount(client, ResponseTimerEvent.class, 0);\n+    }\n+\n+    private static void assertTimerEventRegistrationCount(\n+            HttpClient client,\n+            Class<? extends TimeoutEvent> clazz,\n+            long expectedCount) {\n+        var facade = assertType(HttpClientFacade.class, client);\n+        var actualCount = facade.impl.timers().stream().filter(clazz::isInstance).count();\n+        if (actualCount != 0) {\n+            throw new AssertionError(\n+                    \"Found %s occurrences of `%s` timer event registrations while expecting %s.\".formatted(\n+                            actualCount, clazz.getCanonicalName(), expectedCount));\n+        }\n+    }\n+\n+    private static <T> T assertType(Class<T> expectedType, Object instance) {\n+        if (!expectedType.isInstance(instance)) {\n+            var expectedTypeName = expectedType.getCanonicalName();\n+            var actualTypeName = instance != null ? instance.getClass().getCanonicalName() : null;\n+            throw new AssertionError(\n+                    \"Was expecting an instance of type `%s`, found: `%s`\".formatted(\n+                            expectedTypeName, actualTypeName));\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        T typedInstance = (T) instance;\n+        return typedInstance;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/access\/java.net.http\/jdk\/internal\/net\/http\/HttpClientTimerAccess.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 8217429\n+ * @bug 8217429 8208693\n+ * @library ..\/access\n@@ -28,0 +29,1 @@\n+ *        java.net.http\/jdk.internal.net.http.HttpClientTimerAccess\n@@ -43,0 +45,1 @@\n+import java.time.Duration;\n@@ -51,0 +54,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -61,0 +65,1 @@\n+import static jdk.internal.net.http.HttpClientTimerAccess.assertNoResponseTimerEventRegistrations;\n@@ -146,0 +151,39 @@\n+    \/**\n+     * Verifies that the internally issued request to establish the WebSocket\n+     * connection does not leave any response timers registered at the client\n+     * after the WebSocket handshake.\n+     *\/\n+    @Test\n+    public void responseTimerCleanUp() throws Exception {\n+        try (var server = new DummyWebSocketServer()) {\n+            server.open();\n+            try (var client = newBuilder().proxy(NO_PROXY).build()) {\n+                var connectionEstablished = new CountDownLatch(1);\n+                var webSocketListener = new WebSocket.Listener() {\n+\n+                    @Override\n+                    public void onOpen(WebSocket webSocket) {\n+                        connectionEstablished.countDown();\n+                    }\n+\n+                };\n+                var webSocket = client\n+                        .newWebSocketBuilder()\n+                        \/\/ Explicitly configure a timeout to get a response\n+                        \/\/ timer event get registered at the client. The query\n+                        \/\/ should succeed without timing out.\n+                        .connectTimeout(Duration.ofMinutes(2))\n+                        .buildAsync(server.getURI(), webSocketListener)\n+                        .join();\n+                try {\n+                    connectionEstablished.await();\n+                    \/\/ We expect the response timer event to get evicted once\n+                    \/\/ the WebSocket handshake headers are received.\n+                    assertNoResponseTimerEventRegistrations(client);\n+                } finally {\n+                    webSocket.abort();\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketTest.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"}]}