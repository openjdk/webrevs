{"files":[{"patch":"@@ -615,17 +615,0 @@\n-    \/**\n-     * Generate an instruction pushing a constant onto the operand stack\n-     * @see Opcode.Kind#CONSTANT\n-     * @param opcode the constant instruction opcode\n-     * @param value the constant value\n-     * @return this builder\n-     * @since 23\n-     *\/\n-    default CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n-        BytecodeHelpers.validateValue(opcode, value);\n-        return with(switch (opcode) {\n-            case SIPUSH, BIPUSH -> ConstantInstruction.ofArgument(opcode, ((Number)value).intValue());\n-            case LDC, LDC_W, LDC2_W -> ConstantInstruction.ofLoad(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n-            default -> ConstantInstruction.ofIntrinsic(opcode);\n-        });\n-    }\n-\n@@ -942,2 +925,2 @@\n-     * Generate an instruction pushing a byte onto the operand stack\n-     * @param b the byte\n+     * Generate an instruction pushing an int in the range of byte onto the operand stack.\n+     * @param b the int in the range of byte\n@@ -947,1 +930,1 @@\n-        return loadConstant(Opcode.BIPUSH, b);\n+        return with(ConstantInstruction.ofArgument(Opcode.BIPUSH, b));\n@@ -2407,2 +2390,2 @@\n-     * Generate an instruction pushing a short onto the operand stack\n-     * @param s the short\n+     * Generate an instruction pushing an int in the range of short onto the operand stack.\n+     * @param s the int in the range of short\n@@ -2412,1 +2395,1 @@\n-        return loadConstant(Opcode.SIPUSH, s);\n+        return with(ConstantInstruction.ofArgument(Opcode.SIPUSH, s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -151,1 +152,2 @@\n-     *                                  or {@link Opcode#SIPUSH}\n+     *         or {@link Opcode#SIPUSH}, or if the constant value is out of range\n+     *         for the opcode\n@@ -155,1 +157,5 @@\n-        if (op != Opcode.BIPUSH && op != Opcode.SIPUSH)\n+        if (op == Opcode.BIPUSH) {\n+            BytecodeHelpers.validateBipush(value);\n+        } else if (op == Opcode.SIPUSH) {\n+            BytecodeHelpers.validateSipush(value);\n+        } else {\n@@ -157,0 +163,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-    static void validateSipush(long value) {\n-        if (value < Short.MIN_VALUE || Short.MAX_VALUE < value)\n+    public static void validateSipush(int value) {\n+        if (value != (short) value)\n@@ -240,2 +240,2 @@\n-    static void validateBipush(long value) {\n-        if (value < Byte.MIN_VALUE || Byte.MAX_VALUE < value)\n+    public static void validateBipush(int value) {\n+        if (value != (byte) value)\n@@ -247,20 +247,0 @@\n-    static void validateSipush(ConstantDesc d) {\n-        if (d instanceof Integer iVal) {\n-            validateSipush(iVal.longValue());\n-        } else if (d instanceof Long lVal) {\n-            validateSipush(lVal.longValue());\n-        } else {\n-            throw new IllegalArgumentException(\"SIPUSH: not an integral number: \".concat(d.toString()));\n-        }\n-    }\n-\n-    static void validateBipush(ConstantDesc d) {\n-        if (d instanceof Integer iVal) {\n-            validateBipush(iVal.longValue());\n-        } else if (d instanceof Long lVal) {\n-            validateBipush(lVal.longValue());\n-        } else {\n-            throw new IllegalArgumentException(\"BIPUSH: not an integral number: \".concat(d.toString()));\n-        }\n-    }\n-\n@@ -297,26 +277,0 @@\n-    public static void validateValue(Opcode opcode, ConstantDesc v) {\n-        switch (opcode) {\n-            case ACONST_NULL -> {\n-                if (v != null && v != ConstantDescs.NULL)\n-                    throw new IllegalArgumentException(\"value must be null or ConstantDescs.NULL with opcode ACONST_NULL\");\n-            }\n-            case SIPUSH ->\n-                    validateSipush(v);\n-            case BIPUSH ->\n-                    validateBipush(v);\n-            case LDC, LDC_W, LDC2_W -> {\n-                if (v == null)\n-                    throw new IllegalArgumentException(\"`null` must use ACONST_NULL\");\n-            }\n-            default -> {\n-                var exp = opcode.constantValue();\n-                if (exp == null)\n-                    throw new IllegalArgumentException(\"Can not use Opcode: \" + opcode + \" with constant()\");\n-                if (v == null || !(v.equals(exp) || (exp instanceof Long l && v.equals(l.intValue())))) {\n-                    var t = (exp instanceof Long) ? \"L\" : (exp instanceof Float) ? \"f\" : (exp instanceof Double) ? \"d\" : \"\";\n-                    throw new IllegalArgumentException(\"value must be \" + exp + t + \" with opcode \" + opcode.name());\n-                }\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":4,"deletions":50,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -261,2 +261,1 @@\n-                    cob.loadConstant(ldc.opcode(),\n-                            mapConstantValue(ldc.constantValue()));\n+                    cob.ldc(mapConstantValue(ldc.constantValue()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -831,15 +831,0 @@\n-    @Override\n-    public CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n-        BytecodeHelpers.validateValue(opcode, value);\n-        \/\/ avoid non-local enum switch for bootstrap\n-        if (opcode == BIPUSH || opcode == SIPUSH) {\n-            writeArgumentConstant(opcode, ((Number) value).intValue());\n-        } else if (opcode == LDC || opcode == LDC_W || opcode == LDC2_W) {\n-            writeLoadConstant(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n-        } else {\n-            \/\/ intrinsics\n-            writeBytecode(opcode);\n-        }\n-        return this;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n@@ -679,1 +679,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                    codeB.loadConstant(i.opcode(), val);\n+                    codeB.loadConstant(val);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,3 +67,3 @@\n-                                  c0.loadConstant(LDC, \"string0\")\n-                                    .loadConstant(LDC, \"string131\")\n-                                    .loadConstant(LDC, \"string50\")\n+                                  c0.ldc(\"string0\")\n+                                    .ldc(\"string131\")\n+                                    .ldc(\"string50\")\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Testing ClassFile constant instruction opcodes.\n+ * @summary Testing ClassFile constant instruction argument validation.\n@@ -29,4 +29,2 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -34,5 +32,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Opcode;\n-import org.junit.jupiter.api.*;\n-import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,85 +35,15 @@\n-public class OpcodesValidationTest {\n-\n-    record Case(Opcode opcode, Object constant) {}\n-\n-    static Stream<Case> positiveCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, null),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE),\n-            new Case(ICONST_M1, -1),\n-            new Case(ICONST_0, 0),\n-            new Case(ICONST_1, 1),\n-            new Case(ICONST_2, 2),\n-            new Case(ICONST_3, 3),\n-            new Case(ICONST_4, 4),\n-            new Case(ICONST_5, 5),\n-            new Case(LCONST_0, 0l),\n-            new Case(LCONST_0, 0),\n-            new Case(LCONST_1, 1l),\n-            new Case(LCONST_1, 1),\n-            new Case(FCONST_0, 0.0f),\n-            new Case(FCONST_1, 1.0f),\n-            new Case(FCONST_2, 2.0f),\n-            new Case(DCONST_0, 0.0d),\n-            new Case(DCONST_1, 1.0d)\n-        );\n-    }\n-\n-    static Stream<Case> negativeCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, 0),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE - 1),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE + 1),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE - 1),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE + 1),\n-            new Case(ICONST_M1, -1l),\n-            new Case(ICONST_0, 0l),\n-            new Case(ICONST_1, 1l),\n-            new Case(ICONST_2, 2l),\n-            new Case(ICONST_3, 3l),\n-            new Case(ICONST_4, 4l),\n-            new Case(ICONST_5, 5l),\n-            new Case(LCONST_0, null),\n-            new Case(LCONST_0, 1l),\n-            new Case(LCONST_1, 1.0d),\n-            new Case(LCONST_1, 0),\n-            new Case(FCONST_0, 0.0d),\n-            new Case(FCONST_1, 1.01f),\n-            new Case(FCONST_2, 2),\n-            new Case(DCONST_0, 0.0f),\n-            new Case(DCONST_1, 1.0f),\n-            new Case(DCONST_1, 1)\n-        );\n-    }\n-\n-    @TestFactory\n-    Stream<DynamicTest> testPositiveCases() {\n-        return positiveCases().map(c -> dynamicTest(c.toString(), () -> testPositiveCase(c.opcode, c.constant)));\n-    }\n-\n-    private void testPositiveCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                                      mb -> mb.withCode(\n-                                              codeb -> codeb.loadConstant(opcode, (ConstantDesc) constant))));\n-    }\n-\n-\n-    @TestFactory\n-    Stream<DynamicTest> testNegativeCases() {\n-        return negativeCases().map(c -> dynamicTest(\n-            c.toString(),\n-            () -> assertThrows(IllegalArgumentException.class, () -> testNegativeCase(c.opcode, c.constant))\n-        ));\n-    }\n-\n-    private void testNegativeCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                        mb -> mb .withCode(\n-                                codeb -> codeb.loadConstant(opcode, (ConstantDesc)constant))));\n+class OpcodesValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":19,"deletions":97,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                cb.loadConstant(im.opcode(), im.constantValue());\n+                cb.loadConstant(im.constantValue());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}