{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## Harfbuzz v10.4.0\n+## Harfbuzz 11.2.0\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -952,3 +952,1 @@\n-      hb_blob_t *blob = reference_png (font, glyph);\n-\n-      if (unlikely (blob == hb_blob_get_empty ()))\n+      if (unlikely (!font->get_glyph_extents (glyph, &extents, false)))\n@@ -957,1 +955,1 @@\n-      if (unlikely (!hb_font_get_glyph_extents (font, glyph, &extents)))\n+      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n@@ -960,1 +958,2 @@\n-      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n+      hb_blob_t *blob = reference_png (font, glyph);\n+      if (unlikely (hb_blob_is_immutable (blob)))\n@@ -967,1 +966,1 @@\n-                               font->slant_xy,\n+                               0.f,\n@@ -971,0 +970,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/CBDT\/CBDT.hh","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"..\/..\/..\/hb-paint-bounded.hh\"\n@@ -50,0 +51,6 @@\n+struct hb_colr_scratch_t\n+{\n+  hb_paint_bounded_context_t paint_bounded;\n+  hb_paint_extents_context_t paint_extents;\n+};\n+\n@@ -93,1 +100,2 @@\n-             font->face->table.CPAL->get_palette_colors (palette_)\n+             \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/5116\n+             font->face->table.CPAL->get_palette_colors (palette_ < font->face->table.CPAL->get_palette_count () ? palette_ : 0)\n@@ -98,1 +106,15 @@\n-  { }\n+  {\n+    if (font->is_synthetic ())\n+    {\n+      font = hb_font_create_sub_font (font);\n+      hb_font_set_synthetic_bold (font, 0, 0, true);\n+      hb_font_set_synthetic_slant (font, 0);\n+    }\n+    else\n+      hb_font_reference (font);\n+  }\n+\n+  ~hb_paint_context_t ()\n+  {\n+    hb_font_destroy (font);\n+  }\n@@ -935,1 +957,1 @@\n-    c->funcs->push_inverse_root_transform (c->data, c->font);\n+    c->funcs->push_inverse_font_transform (c->data, c->font);\n@@ -937,1 +959,1 @@\n-    c->funcs->push_root_transform (c->data, c->font);\n+    c->funcs->push_font_transform (c->data, c->font);\n@@ -1514,0 +1536,1 @@\n+    c->funcs->push_group (c->data);\n@@ -1518,0 +1541,1 @@\n+    c->funcs->pop_group (c->data, HB_PAINT_COMPOSITE_MODE_SRC_OVER);\n@@ -1615,1 +1639,1 @@\n-    case 2: u.format2.closurev1 (c);\n+    case 2: u.format2.closurev1 (c); return;\n@@ -2082,0 +2106,2 @@\n+  bool has_data () const { return has_v0_data () || version; }\n+\n@@ -2115,1 +2141,47 @@\n-    ~accelerator_t () { this->colr.destroy (); }\n+\n+    ~accelerator_t ()\n+    {\n+      auto *scratch = cached_scratch.get_relaxed ();\n+      if (scratch)\n+      {\n+        scratch->~hb_colr_scratch_t ();\n+        hb_free (scratch);\n+      }\n+\n+      colr.destroy ();\n+    }\n+\n+\n+    bool has_data () const { return colr->has_data (); }\n+\n+#ifndef HB_NO_PAINT\n+    bool\n+    get_extents (hb_font_t *font,\n+                 hb_codepoint_t glyph,\n+                 hb_glyph_extents_t *extents) const\n+    {\n+      if (unlikely (!has_data ())) return false;\n+\n+      hb_colr_scratch_t *scratch = acquire_scratch ();\n+      if (unlikely (!scratch)) return true;\n+      bool ret = colr->get_extents (font, glyph, extents, *scratch);\n+      release_scratch (scratch);\n+      return ret;\n+    }\n+\n+    bool paint_glyph (hb_font_t *font,\n+                      hb_codepoint_t glyph,\n+                      hb_paint_funcs_t *funcs, void *data,\n+                      unsigned int palette_index,\n+                      hb_color_t foreground,\n+                      bool clip = true) const\n+    {\n+      if (unlikely (!has_data ())) return false;\n+\n+      hb_colr_scratch_t *scratch = acquire_scratch ();\n+      if (unlikely (!scratch)) return true;\n+      bool ret = colr->paint_glyph (font, glyph, funcs, data, palette_index, foreground, clip, *scratch);\n+      release_scratch (scratch);\n+      return ret;\n+    }\n+#endif\n@@ -2151,0 +2223,24 @@\n+\n+    hb_colr_scratch_t *acquire_scratch () const\n+    {\n+      hb_colr_scratch_t *scratch = cached_scratch.get_acquire ();\n+\n+      if (!scratch || unlikely (!cached_scratch.cmpexch (scratch, nullptr)))\n+      {\n+        scratch = (hb_colr_scratch_t *) hb_calloc (1, sizeof (hb_colr_scratch_t));\n+        if (unlikely (!scratch))\n+          return nullptr;\n+      }\n+\n+      return scratch;\n+    }\n+    void release_scratch (hb_colr_scratch_t *scratch) const\n+    {\n+      if (!cached_scratch.cmpexch (nullptr, scratch))\n+      {\n+        scratch->~hb_colr_scratch_t ();\n+        hb_free (scratch);\n+      }\n+    }\n+\n+    public:\n@@ -2152,0 +2248,2 @@\n+    private:\n+    mutable hb_atomic_t<hb_colr_scratch_t *> cached_scratch;\n@@ -2523,1 +2621,4 @@\n-  get_extents (hb_font_t *font, hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n+  get_extents (hb_font_t *font,\n+               hb_codepoint_t glyph,\n+               hb_glyph_extents_t *extents,\n+               hb_colr_scratch_t &scratch) const\n@@ -2537,2 +2638,2 @@\n-    hb_paint_extents_context_t extents_data;\n-    bool ret = paint_glyph (font, glyph, extents_funcs, &extents_data, 0, HB_COLOR(0,0,0,0));\n+    scratch.paint_extents.clear ();\n+    bool ret = paint_glyph (font, glyph, extents_funcs, &scratch.paint_extents, 0, HB_COLOR(0,0,0,0), true, scratch);\n@@ -2540,1 +2641,1 @@\n-    hb_extents_t e = extents_data.get_extents ();\n+    auto e = scratch.paint_extents.get_extents ();\n@@ -2586,1 +2687,6 @@\n-  paint_glyph (hb_font_t *font, hb_codepoint_t glyph, hb_paint_funcs_t *funcs, void *data, unsigned int palette_index, hb_color_t foreground, bool clip = true) const\n+  paint_glyph (hb_font_t *font,\n+               hb_codepoint_t glyph,\n+               hb_paint_funcs_t *funcs, void *data,\n+               unsigned int palette_index, hb_color_t foreground,\n+               bool clip,\n+               hb_colr_scratch_t &scratch) const\n@@ -2620,2 +2726,8 @@\n-            auto *extents_funcs = hb_paint_extents_get_funcs ();\n-            hb_paint_extents_context_t extents_data;\n+            clip = false;\n+            is_bounded = false;\n+          }\n+\n+          if (!is_bounded)\n+          {\n+            auto *bounded_funcs = hb_paint_bounded_get_funcs ();\n+            scratch.paint_bounded.clear ();\n@@ -2624,1 +2736,1 @@\n-                         extents_funcs, &extents_data,\n+                         bounded_funcs, &scratch.paint_bounded,\n@@ -2626,4 +2738,2 @@\n-                         false);\n-\n-            hb_extents_t extents = extents_data.get_extents ();\n-            is_bounded = extents_data.is_bounded ();\n+                         false,\n+                         scratch);\n@@ -2631,5 +2741,1 @@\n-            c.funcs->push_clip_rectangle (c.data,\n-                                          extents.xmin,\n-                                          extents.ymin,\n-                                          extents.xmax,\n-                                          extents.ymax);\n+            is_bounded = scratch.paint_bounded.is_bounded ();\n@@ -2639,1 +2745,1 @@\n-        c.funcs->push_root_transform (c.data, font);\n+        c.funcs->push_font_transform (c.data, font);\n@@ -2717,1 +2823,0 @@\n-    c->funcs->push_group (c->data);\n@@ -2719,1 +2824,0 @@\n-    c->funcs->pop_group (c->data, HB_PAINT_COMPOSITE_MODE_SRC_OVER);\n@@ -2731,1 +2835,1 @@\n-  c->funcs->push_inverse_root_transform (c->data, c->font);\n+  c->funcs->push_inverse_font_transform (c->data, c->font);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/COLR\/COLR.hh","additions":131,"deletions":27,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n@@ -244,1 +243,1 @@\n-      if (blob == hb_blob_get_empty ())\n+      if (!font->get_glyph_extents (glyph, &extents, false))\n@@ -247,1 +246,1 @@\n-      if (!hb_font_get_glyph_extents (font, glyph, &extents))\n+      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n@@ -250,1 +249,2 @@\n-      if (unlikely (!get_extents (font, glyph, &pixel_extents, false)))\n+      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n+      if (hb_blob_is_immutable (blob))\n@@ -257,1 +257,1 @@\n-                               font->slant_xy,\n+                               0.f,\n@@ -261,0 +261,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/sbix\/sbix.hh","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -107,6 +107,6 @@\n-      funcs->image (data,\n-                    blob,\n-                    0, 0,\n-                    HB_PAINT_IMAGE_FORMAT_SVG,\n-                    font->slant_xy,\n-                    nullptr);\n+      bool ret = funcs->image (data,\n+                               blob,\n+                               0, 0,\n+                               HB_PAINT_IMAGE_FORMAT_SVG,\n+                               0.f,\n+                               nullptr);\n@@ -115,1 +115,2 @@\n-      return true;\n+\n+      return ret;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/svg\/svg.hh","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    if (glyphArray.len > glyphs->get_population () * hb_bit_storage ((unsigned) glyphArray.len) \/ 2)\n+    if (glyphArray.len > glyphs->get_population () * hb_bit_storage ((unsigned) glyphArray.len))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/CoverageFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2)\n+    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/Common\/CoverageFormat2.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,2 +208,8 @@\n-    if (!c->plan->layout_variation_idx_delta_map.has (varidx, &new_varidx_delta))\n-      return_trace (false);\n+    if (c->plan->layout_variation_idx_delta_map.has (varidx, &new_varidx_delta)) {\n+      uint32_t new_varidx = hb_first (*new_varidx_delta);\n+      int delta = hb_second (*new_varidx_delta);\n+      if (delta != 0)\n+      {\n+        if (!c->serializer->check_assign (out->coordinate, coordinate + delta, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+          return_trace (false);\n+      }\n@@ -211,6 +217,2 @@\n-    uint32_t new_varidx = hb_first (*new_varidx_delta);\n-    int delta = hb_second (*new_varidx_delta);\n-    if (delta != 0)\n-    {\n-      if (!c->serializer->check_assign (out->coordinate, coordinate + delta, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n-        return_trace (false);\n+      if (new_varidx == HB_OT_LAYOUT_NO_VARIATIONS_INDEX)\n+        return_trace (c->serializer->check_assign (out->caretValueFormat, 1, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -219,3 +221,0 @@\n-    if (new_varidx == HB_OT_LAYOUT_NO_VARIATIONS_INDEX)\n-      return_trace (c->serializer->check_assign (out->caretValueFormat, 1, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n-\n@@ -1018,1 +1017,2 @@\n-    mutable hb_cache_t<21, 3, 8> glyph_props_cache;\n+    mutable hb_cache_t<21, 3> glyph_props_cache;\n+    static_assert (sizeof (glyph_props_cache) == 512, \"\");\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GDEF\/GDEF.hh","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -155,1 +155,2 @@\n-  if (unlikely (font->slant))\n+  if (unlikely (font->slant_xy) &&\n+      HB_DIRECTION_IS_HORIZONTAL (direction))\n@@ -157,0 +158,2 @@\n+    \/* Slanting shaping results is only supported for horizontal text,\n+     * as it gets weird otherwise. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/GPOS.hh","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    if (pairSet.len > glyphs->get_population () * hb_bit_storage ((unsigned) pairSet.len) \/ 4)\n+    if (pairSet.len > glyphs->get_population () * hb_bit_storage ((unsigned) pairSet.len))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,18 @@\n+struct hb_varc_scratch_t\n+{\n+  hb_vector_t<unsigned> axisIndices;\n+  hb_vector_t<float> axisValues;\n+  hb_glyf_scratch_t glyf_scratch;\n+};\n+\n+struct hb_varc_context_t\n+{\n+  hb_font_t *font;\n+  hb_draw_session_t *draw_session;\n+  hb_extents_t *extents;\n+  mutable hb_decycler_t decycler;\n+  mutable signed edges_left;\n+  mutable signed depth_left;\n+  hb_varc_scratch_t &scratch;\n+};\n+\n@@ -47,1 +65,1 @@\n-  get_path_at (hb_font_t *font,\n+  get_path_at (const hb_varc_context_t &c,\n@@ -49,1 +67,0 @@\n-               hb_draw_session_t &draw_session,\n@@ -53,4 +70,0 @@\n-               hb_decycler_t *decycler,\n-               signed *edges_left,\n-               signed depth_left,\n-               hb_glyf_scratch_t &scratch,\n@@ -63,3 +76,2 @@\n-  get_path_at (hb_font_t *font,\n-               hb_codepoint_t glyph,\n-               hb_draw_session_t &draw_session,\n+  get_path_at (const hb_varc_context_t &c,\n+               hb_codepoint_t gid,\n@@ -69,5 +81,1 @@\n-               hb_decycler_t *decycler,\n-               signed *edges_left,\n-               signed depth_left,\n-               hb_glyf_scratch_t &scratch,\n-               VarRegionList::cache_t *cache = nullptr)\n+               VarRegionList::cache_t *cache)\n@@ -78,2 +86,3 @@\n-      record = comp.get_path_at (font, glyph,\n-                                 draw_session, coords, transform,\n+      record = comp.get_path_at (c,\n+                                 gid,\n+                                 coords, transform,\n@@ -81,1 +90,1 @@\n-                                 decycler, edges_left, depth_left, scratch, cache);\n+                                 cache);\n@@ -95,3 +104,2 @@\n-  get_path_at (hb_font_t *font,\n-               hb_codepoint_t glyph,\n-               hb_draw_session_t &draw_session,\n+  get_path_at (const hb_varc_context_t &c,\n+               hb_codepoint_t gid,\n@@ -99,6 +107,3 @@\n-               hb_transform_t transform,\n-               hb_codepoint_t parent_glyph,\n-               hb_decycler_t *decycler,\n-               signed *edges_left,\n-               signed depth_left,\n-               hb_glyf_scratch_t &scratch) const;\n+               hb_transform_t transform = HB_TRANSFORM_IDENTITY,\n+               hb_codepoint_t parent_gid = HB_CODEPOINT_INVALID,\n+               VarRegionList::cache_t *parent_cache = nullptr) const;\n@@ -110,1 +115,1 @@\n-            hb_glyf_scratch_t &scratch) const\n+            hb_varc_scratch_t &scratch) const\n@@ -112,13 +117,28 @@\n-    hb_decycler_t decycler;\n-    signed edges = HB_MAX_GRAPH_EDGE_COUNT;\n-\n-    return get_path_at (font,\n-                        gid,\n-                        draw_session,\n-                        hb_array (font->coords, font->num_coords),\n-                        HB_TRANSFORM_IDENTITY,\n-                        HB_CODEPOINT_INVALID,\n-                        &decycler,\n-                        &edges,\n-                        HB_MAX_NESTING_LEVEL,\n-                        scratch);\n+    hb_varc_context_t c {font,\n+                         &draw_session,\n+                         nullptr,\n+                         hb_decycler_t {},\n+                         HB_MAX_GRAPH_EDGE_COUNT,\n+                         HB_MAX_NESTING_LEVEL,\n+                         scratch};\n+\n+    return get_path_at (c, gid,\n+                        hb_array (font->coords, font->num_coords));\n+  }\n+\n+  bool\n+  get_extents (hb_font_t *font,\n+               hb_codepoint_t gid,\n+               hb_extents_t *extents,\n+               hb_varc_scratch_t &scratch) const\n+  {\n+    hb_varc_context_t c {font,\n+                         nullptr,\n+                         extents,\n+                         hb_decycler_t {},\n+                         HB_MAX_GRAPH_EDGE_COUNT,\n+                         HB_MAX_NESTING_LEVEL,\n+                         scratch};\n+\n+    return get_path_at (c, gid,\n+                        hb_array (font->coords, font->num_coords));\n@@ -153,1 +173,1 @@\n-        scratch->~hb_glyf_scratch_t ();\n+        scratch->~hb_varc_scratch_t ();\n@@ -165,1 +185,28 @@\n-      hb_glyf_scratch_t *scratch;\n+      auto *scratch = acquire_scratch ();\n+      if (unlikely (!scratch)) return true;\n+      bool ret = table->get_path (font, gid, draw_session, *scratch);\n+      release_scratch (scratch);\n+      return ret;\n+    }\n+\n+    bool\n+    get_extents (hb_font_t *font,\n+                 hb_codepoint_t gid,\n+                 hb_glyph_extents_t *extents) const\n+    {\n+      if (!table->has_data ()) return false;\n+\n+      hb_extents_t f_extents;\n+\n+      auto *scratch = acquire_scratch ();\n+      if (unlikely (!scratch)) return true;\n+      bool ret = table->get_extents (font, gid, &f_extents, *scratch);\n+      release_scratch (scratch);\n+\n+      if (ret)\n+        *extents = f_extents.to_glyph_extents (font->x_scale < 0, font->y_scale < 0);\n+\n+      return ret;\n+    }\n+\n+    private:\n@@ -167,1 +214,5 @@\n-      \/\/ Borrow the cached strach buffer.\n+    hb_varc_scratch_t *acquire_scratch () const\n+    {\n+      hb_varc_scratch_t *scratch = cached_scratch.get_acquire ();\n+\n+      if (!scratch || unlikely (!cached_scratch.cmpexch (scratch, nullptr)))\n@@ -169,7 +220,3 @@\n-        scratch = cached_scratch.get_acquire ();\n-        if (!scratch || unlikely (!cached_scratch.cmpexch (scratch, nullptr)))\n-        {\n-          scratch = (hb_glyf_scratch_t *) hb_calloc (1, sizeof (hb_glyf_scratch_t));\n-          if (unlikely (!scratch))\n-            return true;\n-        }\n+        scratch = (hb_varc_scratch_t *) hb_calloc (1, sizeof (hb_varc_scratch_t));\n+        if (unlikely (!scratch))\n+          return nullptr;\n@@ -178,3 +225,4 @@\n-      bool ret = table->get_path (font, gid, draw_session, *scratch);\n-\n-      \/\/ Put it back.\n+      return scratch;\n+    }\n+    void release_scratch (hb_varc_scratch_t *scratch) const\n+    {\n@@ -183,1 +231,1 @@\n-        scratch->~hb_glyf_scratch_t ();\n+        scratch->~hb_varc_scratch_t ();\n@@ -186,2 +234,0 @@\n-\n-      return ret;\n@@ -192,1 +238,1 @@\n-    hb_atomic_ptr_t<hb_glyf_scratch_t> cached_scratch;\n+    mutable hb_atomic_t<hb_varc_scratch_t *> cached_scratch;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Var\/VARC\/VARC.hh","additions":103,"deletions":57,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -432,1 +432,10 @@\n-  bool get_extents (hb_font_t *font, hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n+\n+  bool get_extents (hb_font_t *font,\n+                    hb_codepoint_t gid,\n+                    hb_glyph_extents_t *extents) const\n+  { return get_extents_at (font, gid, extents, hb_array (font->coords, font->num_coords)); }\n+\n+  bool get_extents_at (hb_font_t *font,\n+                       hb_codepoint_t gid,\n+                       hb_glyph_extents_t *extents,\n+                       hb_array_t<const int> coords) const\n@@ -437,1 +446,1 @@\n-    if (font->num_coords)\n+    if (coords)\n@@ -440,2 +449,4 @@\n-      return get_points (font, gid, points_aggregator_t (font, extents, nullptr, true),\n-                         hb_array (font->coords, font->num_coords),\n+      return get_points (font,\n+                         gid,\n+                         points_aggregator_t (font, extents, nullptr, true),\n+                         coords,\n@@ -535,1 +546,1 @@\n-  hb_atomic_ptr_t<hb_glyf_scratch_t> cached_scratch;\n+  mutable hb_atomic_t<hb_glyf_scratch_t *> cached_scratch;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf.hh","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-layout-gdef-table.hh\"\n@@ -51,0 +53,55 @@\n+struct hb_aat_scratch_t\n+{\n+  hb_aat_scratch_t () = default;\n+  hb_aat_scratch_t (const hb_aat_scratch_t &) = delete;\n+\n+  hb_aat_scratch_t (hb_aat_scratch_t &&o)\n+  {\n+    buffer_glyph_set.set_relaxed (o.buffer_glyph_set.get_relaxed ());\n+    o.buffer_glyph_set.set_relaxed (nullptr);\n+  }\n+  hb_aat_scratch_t & operator = (hb_aat_scratch_t &&o)\n+  {\n+    buffer_glyph_set.set_relaxed (o.buffer_glyph_set.get_relaxed ());\n+    o.buffer_glyph_set.set_relaxed (nullptr);\n+    return *this;\n+  }\n+  ~hb_aat_scratch_t ()\n+  {\n+    auto *s = buffer_glyph_set.get_relaxed ();\n+    if (unlikely (!s))\n+      return;\n+    s->fini ();\n+    hb_free (s);\n+  }\n+\n+  hb_bit_set_t *create_buffer_glyph_set () const\n+  {\n+    hb_bit_set_t *s = buffer_glyph_set.get_acquire ();\n+    if (s && buffer_glyph_set.cmpexch (s, nullptr))\n+      return s;\n+\n+    s = (hb_bit_set_t *) hb_calloc (1, sizeof (hb_bit_set_t));\n+    if (unlikely (!s))\n+      return nullptr;\n+    s->init ();\n+\n+    return s;\n+  }\n+  void destroy_buffer_glyph_set (hb_bit_set_t *s) const\n+  {\n+    if (unlikely (!s))\n+      return;\n+    if (buffer_glyph_set.cmpexch (nullptr, s))\n+      return;\n+    s->fini ();\n+    hb_free (s);\n+  }\n+\n+  mutable hb_atomic_t<hb_bit_set_t *> buffer_glyph_set;\n+};\n+\n+enum { DELETED_GLYPH = 0xFFFF };\n+\n+#define HB_BUFFER_SCRATCH_FLAG_AAT_HAS_DELETED HB_BUFFER_SCRATCH_FLAG_SHAPER0\n+\n@@ -67,1 +124,2 @@\n-  const OT::GDEF *gdef_table;\n+  const OT::GDEF &gdef;\n+  bool has_glyph_classes;\n@@ -70,1 +128,1 @@\n-  hb_bit_set_t buffer_glyph_set;\n+  hb_bit_set_t *buffer_glyph_set = nullptr;\n@@ -93,1 +151,1 @@\n-    using_buffer_glyph_set = buffer->len >= 4;\n+    using_buffer_glyph_set = buffer->len >= 4 && buffer_glyph_set;\n@@ -95,2 +153,2 @@\n-    if (using_buffer_glyph_set)\n-      buffer->collect_codepoints (buffer_glyph_set);\n+    if (likely (using_buffer_glyph_set))\n+      buffer->collect_codepoints (*buffer_glyph_set);\n@@ -100,2 +158,2 @@\n-    if (using_buffer_glyph_set)\n-      return buffer_glyph_set.intersects (*machine_glyph_set);\n+    if (likely (using_buffer_glyph_set))\n+      return buffer_glyph_set->intersects (*machine_glyph_set);\n@@ -109,0 +167,63 @@\n+\n+  template <typename T>\n+  HB_NODISCARD bool output_glyphs (unsigned int count,\n+                                   const T *glyphs)\n+  {\n+    if (likely (using_buffer_glyph_set))\n+      buffer_glyph_set->add_array (glyphs, count);\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (glyphs[i] == DELETED_GLYPH)\n+      {\n+        buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_AAT_HAS_DELETED;\n+        _hb_glyph_info_set_aat_deleted (&buffer->cur());\n+      }\n+      else\n+      {\n+#ifndef HB_NO_OT_LAYOUT\n+        if (has_glyph_classes)\n+          _hb_glyph_info_set_glyph_props (&buffer->cur(),\n+                                          gdef.get_glyph_props (glyphs[i]));\n+#endif\n+      }\n+      if (unlikely (!buffer->output_glyph (glyphs[i]))) return false;\n+    }\n+    return true;\n+  }\n+\n+  HB_NODISCARD bool replace_glyph (hb_codepoint_t glyph)\n+  {\n+    if (glyph == DELETED_GLYPH)\n+    {\n+      buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_AAT_HAS_DELETED;\n+      _hb_glyph_info_set_aat_deleted (&buffer->cur());\n+    }\n+\n+    if (likely (using_buffer_glyph_set))\n+      buffer_glyph_set->add (glyph);\n+#ifndef HB_NO_OT_LAYOUT\n+    if (has_glyph_classes)\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(),\n+                                      gdef.get_glyph_props (glyph));\n+#endif\n+    return buffer->replace_glyph (glyph);\n+  }\n+\n+  HB_NODISCARD bool delete_glyph ()\n+  {\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_AAT_HAS_DELETED;\n+    _hb_glyph_info_set_aat_deleted (&buffer->cur());\n+    return buffer->replace_glyph (DELETED_GLYPH);\n+  }\n+\n+  void replace_glyph_inplace (unsigned i, hb_codepoint_t glyph)\n+  {\n+    buffer->info[i].codepoint = glyph;\n+    if (likely (using_buffer_glyph_set))\n+      buffer_glyph_set->add (glyph);\n+#ifndef HB_NO_OT_LAYOUT\n+    if (has_glyph_classes)\n+      _hb_glyph_info_set_glyph_props (&buffer->info[i],\n+                                      gdef.get_glyph_props (glyph));\n+#endif\n+  }\n@@ -116,2 +237,0 @@\n-enum { DELETED_GLYPH = 0xFFFF };\n-\n@@ -182,0 +301,1 @@\n+    if (first == DELETED_GLYPH) return;\n@@ -271,0 +391,1 @@\n+    if (first == DELETED_GLYPH) return;\n@@ -371,0 +492,1 @@\n+    if (glyph == DELETED_GLYPH) return;\n@@ -749,0 +871,4 @@\n+\n+    if (filter (CLASS_DELETED_GLYPH))\n+      glyphs.add (DELETED_GLYPH);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":135,"deletions":9,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -188,0 +188,3 @@\n+  static bool initiateAction (const Entry<EntryData> &entry)\n+  { return entry.flags & Push; }\n+\n@@ -328,2 +331,3 @@\n-              o.x_advance += c->font->em_scale_x (v);\n-              o.x_offset += c->font->em_scale_x (v);\n+              auto scaled = c->font->em_scale_x (v);\n+              o.x_advance += scaled;\n+              o.x_offset += scaled;\n@@ -397,4 +401,2 @@\n-    set_t set;\n-    machine.collect_glyphs (set, num_glyphs);\n-    left_set.union_ (set);\n-    right_set.union_ (set);\n+    machine.collect_initial_glyphs (left_set, num_glyphs, *this);\n+    \/\/machine.collect_glyphs (right_set, num_glyphs); \/\/ right_set is unused for machine kerning\n@@ -674,4 +676,2 @@\n-    set_t set;\n-    machine.collect_glyphs (set, num_glyphs);\n-    left_set.union_ (set);\n-    right_set.union_ (set);\n+    machine.collect_initial_glyphs (left_set, num_glyphs, *this);\n+    \/\/machine.collect_glyphs (right_set, num_glyphs); \/\/ right_set is unused for machine kerning\n@@ -924,1 +924,12 @@\n-using kern_accelerator_data_t = hb_vector_t<hb_pair_t<hb_bit_set_t, hb_bit_set_t>>;\n+struct kern_subtable_accelerator_data_t\n+{\n+  hb_bit_set_t left_set;\n+  hb_bit_set_t right_set;\n+  mutable hb_aat_class_cache_t class_cache;\n+};\n+\n+struct kern_accelerator_data_t\n+{\n+  hb_vector_t<kern_subtable_accelerator_data_t> subtable_accels;\n+  hb_aat_scratch_t scratch;\n+};\n@@ -988,0 +999,2 @@\n+    c->setup_buffer_glyph_set ();\n+\n@@ -999,0 +1012,2 @@\n+      auto &subtable_accel = accel_data.subtable_accels[i];\n+\n@@ -1005,0 +1020,11 @@\n+      c->left_set = &subtable_accel.left_set;\n+      c->right_set = &subtable_accel.right_set;\n+      c->machine_glyph_set = &subtable_accel.left_set;\n+      c->machine_class_cache = &subtable_accel.class_cache;\n+\n+      if (!c->buffer_intersects_machine ())\n+      {\n+        (void) c->buffer->message (c->font, \"skipped subtable %u because no glyph matches\", c->lookup_index);\n+        goto skip;\n+      }\n+\n@@ -1031,3 +1057,0 @@\n-      c->left_set = &accel_data[i].first;\n-      c->right_set = &accel_data[i].second;\n-\n@@ -1109,3 +1132,7 @@\n-      hb_bit_set_t left_set, right_set;\n-      st->collect_glyphs (left_set, right_set, num_glyphs);\n-      accel_data.push (hb_pair (left_set, right_set));\n+      auto &subtable_accel = *accel_data.subtable_accels.push ();\n+      if (unlikely (accel_data.subtable_accels.in_error ()))\n+          return accel_data;\n+\n+      st->collect_glyphs (subtable_accel.left_set, subtable_accel.right_set, num_glyphs);\n+      subtable_accel.class_cache.clear ();\n+\n@@ -1140,0 +1167,1 @@\n+    hb_aat_scratch_t scratch;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-kerx-table.hh","additions":45,"deletions":17,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-#include \"hb-ot-layout-common.hh\"\n-#include \"hb-ot-layout-gdef-table.hh\"\n@@ -181,6 +179,0 @@\n-    if (!c->buffer_intersects_machine ())\n-    {\n-      (void) c->buffer->message (c->font, \"skipped chainsubtable because no glyph matches\");\n-      return_trace (false);\n-    }\n-\n@@ -245,1 +237,0 @@\n-        gdef (*c->gdef_table),\n@@ -247,1 +238,0 @@\n-        has_glyph_classes (gdef.has_glyph_classes ()),\n@@ -284,6 +274,1 @@\n-        hb_codepoint_t glyph = *replacement;\n-        buffer->info[mark].codepoint = glyph;\n-        c->buffer_glyph_set.add (glyph);\n-        if (has_glyph_classes)\n-          _hb_glyph_info_set_glyph_props (&buffer->info[mark],\n-                                          gdef.get_glyph_props (*replacement));\n+        c->replace_glyph_inplace (mark, *replacement);\n@@ -315,6 +300,1 @@\n-        hb_codepoint_t glyph = *replacement;\n-        buffer->info[idx].codepoint = glyph;\n-        c->buffer_glyph_set.add (glyph);\n-        if (has_glyph_classes)\n-          _hb_glyph_info_set_glyph_props (&buffer->info[idx],\n-                                          gdef.get_glyph_props (*replacement));\n+        c->replace_glyph_inplace (idx, *replacement);\n@@ -336,1 +316,0 @@\n-    const OT::GDEF &gdef;\n@@ -338,1 +317,0 @@\n-    bool has_glyph_classes;\n@@ -351,6 +329,0 @@\n-    if (!c->buffer_intersects_machine ())\n-    {\n-      (void) c->buffer->message (c->font, \"skipped chainsubtable because no glyph matches\");\n-      return_trace (false);\n-    }\n-\n@@ -584,1 +556,1 @@\n-            if (unlikely (!buffer->replace_glyph (lig))) return;\n+            if (unlikely (!c->replace_glyph (lig))) return;\n@@ -592,2 +564,1 @@\n-              _hb_glyph_info_set_default_ignorable (&buffer->cur());\n-              if (unlikely (!buffer->replace_glyph (DELETED_GLYPH))) return;\n+              if (!c->delete_glyph ()) return;\n@@ -627,6 +598,0 @@\n-    if (!c->buffer_intersects_machine ())\n-    {\n-      (void) c->buffer->message (c->font, \"skipped chainsubtable because no glyph matches\");\n-      return_trace (false);\n-    }\n-\n@@ -668,9 +633,0 @@\n-    if (!c->buffer_intersects_machine ())\n-    {\n-      (void) c->buffer->message (c->font, \"skipped chainsubtable because no glyph matches\");\n-      return_trace (false);\n-    }\n-\n-    const OT::GDEF &gdef (*c->gdef_table);\n-    bool has_glyph_classes = gdef.has_glyph_classes ();\n-\n@@ -706,6 +662,1 @@\n-        hb_codepoint_t glyph = *replacement;\n-        info[i].codepoint = glyph;\n-        c->buffer_glyph_set.add (glyph);\n-        if (has_glyph_classes)\n-          _hb_glyph_info_set_glyph_props (&info[i],\n-                                          gdef.get_glyph_props (*replacement));\n+        c->replace_glyph_inplace (i, *replacement);\n@@ -853,3 +804,1 @@\n-        if (unlikely (!buffer->replace_glyphs (0, count, glyphs))) return;\n-        for (unsigned int i = 0; i < count; i++)\n-          c->buffer_glyph_set.add (glyphs[i]);\n+        if (unlikely (!c->output_glyphs (count, glyphs))) return;\n@@ -884,1 +833,2 @@\n-        if (unlikely (!buffer->replace_glyphs (0, count, glyphs))) return;\n+        if (unlikely (!c->output_glyphs (count, glyphs))) return;\n+        ret = true;\n@@ -924,6 +874,0 @@\n-    if (!c->buffer_intersects_machine ())\n-    {\n-      (void) c->buffer->message (c->font, \"skipped chainsubtable because no glyph matches\");\n-      return_trace (false);\n-    }\n-\n@@ -1227,0 +1171,1 @@\n+\n@@ -1236,0 +1181,6 @@\n+      if (!c->buffer_intersects_machine ())\n+      {\n+        (void) c->buffer->message (c->font, \"skipped chainsubtable %u because no glyph matches\", c->lookup_index);\n+        goto skip;\n+      }\n+\n@@ -1379,1 +1330,1 @@\n-      this->accels = (hb_atomic_ptr_t<hb_aat_layout_chain_accelerator_t> *) hb_calloc (this->chain_count, sizeof (*accels));\n+      this->accels = (hb_atomic_t<hb_aat_layout_chain_accelerator_t *> *) hb_calloc (this->chain_count, sizeof (*accels));\n@@ -1426,1 +1377,2 @@\n-    hb_atomic_ptr_t<hb_aat_layout_chain_accelerator_t> *accels;\n+    hb_atomic_t<hb_aat_layout_chain_accelerator_t *> *accels;\n+    hb_aat_scratch_t scratch;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-morx-table.hh","additions":18,"deletions":66,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"hb-ot-stat-table.hh\"\n@@ -118,1 +119,1 @@\n-  NameID        trackNameID;    \/* The 'name' table index for this track.\n+  OT::NameID    trackNameID;    \/* The 'name' table index for this track.\n@@ -145,1 +146,1 @@\n-    while (i + 1 < count && trackTable[i + 1].get_track_value () < track)\n+    while (i + 1 < count && trackTable[i + 1].get_track_value () <= track)\n@@ -147,1 +148,1 @@\n-    while (j > 0 && trackTable[j - 1].get_track_value () > track)\n+    while (j > 0 && trackTable[j - 1].get_track_value () >= track)\n@@ -203,0 +204,40 @@\n+  hb_position_t get_tracking (hb_font_t *font, hb_direction_t dir, float track = 0.f) const\n+  {\n+#ifndef HB_NO_STYLE\n+    if (!font->face->table.STAT->has_data ())\n+      return 0;\n+    return HB_DIRECTION_IS_HORIZONTAL (dir) ?\n+      get_h_tracking (font, track) :\n+      get_v_tracking (font, track);\n+#else\n+    return 0;\n+#endif\n+  }\n+\n+  bool apply (hb_aat_apply_context_t *c, float track = 0.f) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    float ptem = c->font->ptem;\n+    if (unlikely (ptem <= 0.f))\n+    {\n+      \/* https:\/\/developer.apple.com\/documentation\/coretext\/1508745-ctfontcreatewithgraphicsfont *\/\n+      ptem = HB_CORETEXT_DEFAULT_FONT_SIZE;\n+    }\n+\n+    hb_buffer_t *buffer = c->buffer;\n+    if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n+    {\n+      hb_position_t advance_to_add = get_h_tracking (c->font, track);\n+      foreach_grapheme (buffer, start, end)\n+        buffer->pos[start].x_advance += advance_to_add;\n+    }\n+    else\n+    {\n+      hb_position_t advance_to_add = get_v_tracking (c->font, track);\n+      foreach_grapheme (buffer, start, end)\n+        buffer->pos[start].y_advance += advance_to_add;\n+    }\n+\n+    return_trace (true);\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-trak-table.hh","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"hb-aat-layout-trak-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-aat-layout-trak-table.hh\"\n@@ -61,1 +61,1 @@\n-                                                       gdef_table (\n+                                                       gdef (\n@@ -63,1 +63,1 @@\n-                                                         face->table.GDEF->table\n+                                                         *face->table.GDEF->table\n@@ -65,1 +65,1 @@\n-                                                         &Null (GDEF)\n+                                                         Null (GDEF)\n@@ -68,0 +68,1 @@\n+                                                       has_glyph_classes (gdef.has_glyph_classes ()),\n@@ -206,1 +207,1 @@\n-#ifndef HB_NO_AAT\n+#ifndef HB_NO_AAT_SHAPE\n@@ -290,3 +291,0 @@\n-  hb_aat_map_builder_t builder (font->face, plan->props);\n-  for (unsigned i = 0; i < num_features; i++)\n-    builder.add_feature (features[i]);\n@@ -294,1 +292,7 @@\n-  builder.compile (map);\n+  if (num_features)\n+  {\n+    hb_aat_map_builder_t builder (font->face, plan->props);\n+    for (unsigned i = 0; i < num_features; i++)\n+      builder.add_feature (features[i]);\n+    builder.compile (map);\n+  }\n@@ -303,1 +307,4 @@\n-      morx.apply (&c, map, accel);\n+      c.buffer_glyph_set = accel.scratch.create_buffer_glyph_set ();\n+      morx.apply (&c, num_features ? map : plan->aat_map, accel);\n+      accel.scratch.destroy_buffer_glyph_set (c.buffer_glyph_set);\n+      c.buffer_glyph_set = nullptr;\n@@ -316,1 +323,1 @@\n-      mort.apply (&c, map, accel);\n+      mort.apply (&c, num_features ? map : plan->aat_map, accel);\n@@ -323,11 +330,0 @@\n-void\n-hb_aat_layout_zero_width_deleted_glyphs (hb_buffer_t *buffer)\n-{\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  hb_glyph_position_t *pos = buffer->pos;\n-  for (unsigned int i = 0; i < count; i++)\n-    if (unlikely (info[i].codepoint == AAT::DELETED_GLYPH))\n-      pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;\n-}\n-\n@@ -337,1 +333,1 @@\n-  return info->codepoint == AAT::DELETED_GLYPH;\n+  return _hb_glyph_info_is_aat_deleted (info);\n@@ -343,1 +339,2 @@\n-  buffer->delete_glyphs_inplace (is_deleted_glyph);\n+  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_AAT_HAS_DELETED)\n+    buffer->delete_glyphs_inplace (is_deleted_glyph);\n@@ -374,0 +371,1 @@\n+  c.buffer_glyph_set = accel.scratch.create_buffer_glyph_set ();\n@@ -376,0 +374,2 @@\n+  accel.scratch.destroy_buffer_glyph_set (c.buffer_glyph_set);\n+  c.buffer_glyph_set = nullptr;\n@@ -397,0 +397,11 @@\n+void\n+hb_aat_layout_track (const hb_ot_shape_plan_t *plan,\n+                     hb_font_t *font,\n+                     hb_buffer_t *buffer)\n+{\n+  const AAT::trak& trak = *font->face->table.trak;\n+\n+  AAT::hb_aat_apply_context_t c (plan, font, buffer);\n+  trak.apply (&c);\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout.cc","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-HB_INTERNAL void\n-hb_aat_layout_zero_width_deleted_glyphs (hb_buffer_t *buffer);\n-\n@@ -74,0 +71,5 @@\n+HB_INTERNAL void\n+hb_aat_layout_track (const hb_ot_shape_plan_t *plan,\n+                     hb_font_t *font,\n+                     hb_buffer_t *buffer);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout.hh","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+  if (!features.length)\n+  {\n+    hb_aat_layout_compile_map (this, &m);\n+    return;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-map.cc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-#define _hb_memory_barrier()                    std::atomic_thread_fence(std::memory_order_ack_rel)\n@@ -87,5 +86,5 @@\n-#define hb_atomic_int_impl_add(AI, V)           (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->fetch_add ((V), std::memory_order_acq_rel))\n-#define hb_atomic_int_impl_set_relaxed(AI, V)   (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_relaxed))\n-#define hb_atomic_int_impl_set(AI, V)           (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_release))\n-#define hb_atomic_int_impl_get_relaxed(AI)      (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_relaxed))\n-#define hb_atomic_int_impl_get(AI)              (reinterpret_cast<std::atomic<std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_acquire))\n+#define hb_atomic_int_impl_add(AI, V)           (reinterpret_cast<std::atomic<typename std::decay<decltype (*(AI))>::type> *> (AI)->fetch_add ((V), std::memory_order_acq_rel))\n+#define hb_atomic_int_impl_set_relaxed(AI, V)   (reinterpret_cast<std::atomic<typename std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_relaxed))\n+#define hb_atomic_int_impl_set(AI, V)           (reinterpret_cast<std::atomic<typename std::decay<decltype (*(AI))>::type> *> (AI)->store ((V), std::memory_order_release))\n+#define hb_atomic_int_impl_get_relaxed(AI)      (reinterpret_cast<std::atomic<typename std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_relaxed))\n+#define hb_atomic_int_impl_get(AI)              (reinterpret_cast<std::atomic<typename std::decay<decltype (*(AI))>::type> const *> (AI)->load (std::memory_order_acquire))\n@@ -152,2 +151,2 @@\n-inline void hb_atomic_int_impl_set (int *AI, int v)     { _hb_memory_w_barrier (); *AI = v; }\n-inline void hb_atomic_int_impl_set (short *AI, short v) { _hb_memory_w_barrier (); *AI = v; }\n+template <typename T>\n+inline void hb_atomic_int_impl_set (T *AI, T v) { _hb_memory_w_barrier (); *AI = v; }\n@@ -156,2 +155,2 @@\n-inline int hb_atomic_int_impl_get (const int *AI)       { int v = *AI; _hb_memory_r_barrier (); return v; }\n-inline short hb_atomic_int_impl_get (const short *AI)   { short v = *AI; _hb_memory_r_barrier (); return v; }\n+template <typename T>\n+inline T hb_atomic_int_impl_get (const T *AI)   { T v = *AI; _hb_memory_r_barrier (); return v; }\n@@ -164,1 +163,2 @@\n-struct hb_atomic_short_t\n+template <typename T>\n+struct hb_atomic_t\n@@ -166,2 +166,2 @@\n-  hb_atomic_short_t () = default;\n-  constexpr hb_atomic_short_t (short v) : v (v) {}\n+  hb_atomic_t () = default;\n+  constexpr hb_atomic_t (T v) : v (v) {}\n@@ -169,2 +169,2 @@\n-  hb_atomic_short_t& operator = (short v_) { set_relaxed (v_); return *this; }\n-  operator short () const { return get_relaxed (); }\n+  hb_atomic_t& operator = (T v_) { set_relaxed (v_); return *this; }\n+  operator T () const { return get_relaxed (); }\n@@ -172,6 +172,6 @@\n-  void set_relaxed (short v_) { hb_atomic_int_impl_set_relaxed (&v, v_); }\n-  void set_release (short v_) { hb_atomic_int_impl_set (&v, v_); }\n-  short get_relaxed () const { return hb_atomic_int_impl_get_relaxed (&v); }\n-  short get_acquire () const { return hb_atomic_int_impl_get (&v); }\n-  short inc () { return hb_atomic_int_impl_add (&v,  1); }\n-  short dec () { return hb_atomic_int_impl_add (&v, -1); }\n+  void set_relaxed (T v_) { hb_atomic_int_impl_set_relaxed (&v, v_); }\n+  void set_release (T v_) { hb_atomic_int_impl_set (&v, v_); }\n+  T get_relaxed () const { return hb_atomic_int_impl_get_relaxed (&v); }\n+  T get_acquire () const { return hb_atomic_int_impl_get (&v); }\n+  T inc () { return hb_atomic_int_impl_add (&v,  1); }\n+  T dec () { return hb_atomic_int_impl_add (&v, -1); }\n@@ -179,7 +179,3 @@\n-  short v = 0;\n-};\n-\n-struct hb_atomic_int_t\n-{\n-  hb_atomic_int_t () = default;\n-  constexpr hb_atomic_int_t (int v) : v (v) {}\n+  int operator ++ (int) { return inc (); }\n+  int operator -- (int) { return dec (); }\n+  long operator |= (long v_) { set_relaxed (get_relaxed () | v_); return *this; }\n@@ -187,11 +183,1 @@\n-  hb_atomic_int_t& operator = (int v_) { set_relaxed (v_); return *this; }\n-  operator int () const { return get_relaxed (); }\n-\n-  void set_relaxed (int v_) { hb_atomic_int_impl_set_relaxed (&v, v_); }\n-  void set_release (int v_) { hb_atomic_int_impl_set (&v, v_); }\n-  int get_relaxed () const { return hb_atomic_int_impl_get_relaxed (&v); }\n-  int get_acquire () const { return hb_atomic_int_impl_get (&v); }\n-  int inc () { return hb_atomic_int_impl_add (&v,  1); }\n-  int dec () { return hb_atomic_int_impl_add (&v, -1); }\n-\n-  int v = 0;\n+  T v = 0;\n@@ -200,2 +186,2 @@\n-template <typename P>\n-struct hb_atomic_ptr_t\n+template <typename T>\n+struct hb_atomic_t<T*>\n@@ -203,5 +189,3 @@\n-  typedef hb_remove_pointer<P> T;\n-\n-  hb_atomic_ptr_t () = default;\n-  constexpr hb_atomic_ptr_t (T* v) : v (v) {}\n-  hb_atomic_ptr_t (const hb_atomic_ptr_t &other) = delete;\n+  hb_atomic_t () = default;\n+  constexpr hb_atomic_t (T* v) : v (v) {}\n+  hb_atomic_t (const hb_atomic_t &other) = delete;\n@@ -213,1 +197,1 @@\n-  bool cmpexch (const T *old, T *new_) const { return hb_atomic_ptr_impl_cmpexch ((void **) &v, (void *) old, (void *) new_); }\n+  bool cmpexch (const T *old, T *new_) { return hb_atomic_ptr_impl_cmpexch ((void **) &v, (void *) old, (void *) new_); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-atomic.hh","additions":31,"deletions":47,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  mutable hb_atomic_int_t last_page_lookup = 0;\n+  mutable hb_atomic_t<unsigned> last_page_lookup = 0;\n@@ -91,1 +91,1 @@\n-    if (pages.length < count && count <= 2)\n+    if (pages.length < count && (unsigned) pages.allocated < count && count <= 2)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BIT_VECTOR_HH\n+#define HB_BIT_VECTOR_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-atomic.hh\"\n+\n+struct hb_min_max_t\n+{\n+  void add (hb_codepoint_t v) { min_v = hb_min (min_v, v); max_v = hb_max (max_v, v); }\n+  void add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    min_v = hb_min (min_v, a);\n+    max_v = hb_max (max_v, b);\n+  }\n+\n+  template <typename set_t>\n+  void union_ (const set_t &set)\n+  {\n+    hb_codepoint_t set_min = set.get_min ();\n+    if (unlikely (set_min == HB_CODEPOINT_INVALID))\n+      return;\n+    hb_codepoint_t set_max = set.get_max ();\n+    min_v = hb_min (min_v, set_min);\n+    max_v = hb_max (max_v, set_max);\n+  }\n+\n+  hb_codepoint_t get_min () const { return min_v; }\n+  hb_codepoint_t get_max () const { return max_v; }\n+\n+  private:\n+  hb_codepoint_t min_v = HB_CODEPOINT_INVALID;\n+  hb_codepoint_t max_v = 0;\n+};\n+\n+template <bool atomic = false>\n+struct hb_bit_vector_t\n+{\n+  using int_t = uint64_t;\n+  using elt_t = typename std::conditional<atomic, hb_atomic_t<int_t>, int_t>::type;\n+\n+  hb_bit_vector_t () = delete;\n+  hb_bit_vector_t (const hb_bit_vector_t &other) = delete;\n+  hb_bit_vector_t &operator= (const hb_bit_vector_t &other) = delete;\n+\n+  \/\/ Move\n+  hb_bit_vector_t (hb_bit_vector_t &&other)\n+                : min_v (other.min_v), max_v (other.max_v), count (other.count), elts (other.elts)\n+  {\n+    other.min_v = other.max_v = other.count = 0;\n+    other.elts = nullptr;\n+  }\n+  hb_bit_vector_t &operator= (hb_bit_vector_t &&other)\n+  {\n+    hb_swap (min_v, other.min_v);\n+    hb_swap (max_v, other.max_v);\n+    hb_swap (count, other.count);\n+    hb_swap (elts, other.elts);\n+    return *this;\n+  }\n+\n+  hb_bit_vector_t (unsigned min_v, unsigned max_v)\n+    : min_v (min_v), max_v (max_v)\n+  {\n+    if (unlikely (min_v >= max_v))\n+    {\n+      min_v = max_v = count = 0;\n+      return;\n+    }\n+\n+    unsigned num = (max_v - min_v + sizeof (int_t) * 8) \/ (sizeof (int_t) * 8);\n+    elts = (elt_t *) hb_calloc (num, sizeof (int_t));\n+    if (unlikely (!elts))\n+    {\n+      min_v = max_v = count = 0;\n+      return;\n+    }\n+\n+    count = max_v - min_v + 1;\n+  }\n+  ~hb_bit_vector_t ()\n+  {\n+    hb_free (elts);\n+  }\n+\n+  void add (hb_codepoint_t g) { elt (g) |= mask (g); }\n+  void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }\n+  void set (hb_codepoint_t g, bool value) { if (value) add (g); else del (g); }\n+  bool get (hb_codepoint_t g) const { return elt (g) & mask (g); }\n+  bool has (hb_codepoint_t g) const { return get (g); }\n+  bool may_have (hb_codepoint_t g) const { return get (g); }\n+\n+  bool operator [] (hb_codepoint_t g) const { return get (g); }\n+  bool operator () (hb_codepoint_t g) const { return get (g); }\n+\n+  void add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    if (unlikely (!count || a > b || a < min_v || b > max_v))\n+      return;\n+\n+    elt_t *la = &elt (a);\n+    elt_t *lb = &elt (b);\n+    if (la == lb)\n+      *la |= (mask (b) << 1) - mask(a);\n+    else\n+    {\n+      *la |= ~(mask (a) - 1llu);\n+      la++;\n+\n+      hb_memset (la, 0xff, (char *) lb - (char *) la);\n+\n+      *lb |= ((mask (b) << 1) - 1llu);\n+    }\n+  }\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    if (unlikely (!count || a > b || a < min_v || b > max_v))\n+      return;\n+\n+    elt_t *la = &elt (a);\n+    elt_t *lb = &elt (b);\n+    if (la == lb)\n+      *la &= ~((mask (b) << 1llu) - mask(a));\n+    else\n+    {\n+      *la &= mask (a) - 1;\n+      la++;\n+\n+      hb_memset (la, 0, (char *) lb - (char *) la);\n+\n+      *lb &= ~((mask (b) << 1) - 1llu);\n+    }\n+  }\n+  void set_range (hb_codepoint_t a, hb_codepoint_t b, bool v)\n+  { if (v) add_range (a, b); else del_range (a, b); }\n+\n+  template <typename set_t>\n+  void union_ (const set_t &set)\n+  {\n+    for (hb_codepoint_t g : set)\n+      add (g);\n+  }\n+\n+  static const unsigned int ELT_BITS = sizeof (elt_t) * 8;\n+  static constexpr unsigned ELT_MASK = ELT_BITS - 1;\n+\n+  static constexpr elt_t zero = 0;\n+\n+  elt_t &elt (hb_codepoint_t g)\n+  {\n+    g -= min_v;\n+    if (unlikely (g >= count))\n+      return Crap(elt_t);\n+    return elts[g \/ ELT_BITS];\n+  }\n+  const elt_t& elt (hb_codepoint_t g) const\n+  {\n+    g -= min_v;\n+    if (unlikely (g >= count))\n+      return Null(elt_t);\n+    return elts[g \/ ELT_BITS];\n+  }\n+\n+  static constexpr int_t mask (hb_codepoint_t g) { return elt_t (1) << (g & ELT_MASK); }\n+\n+  hb_codepoint_t min_v = 0, max_v = 0, count = 0;\n+  elt_t *elts = nullptr;\n+};\n+\n+\n+#endif \/* HB_BIT_VECTOR_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-vector.hh","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n-#line 36 \"hb-buffer-deserialize-json.hh\"\n+#line 33 \"hb-buffer-deserialize-json.hh\"\n@@ -37,8 +37,9 @@\n-        0u, 0u, 9u, 123u, 9u, 123u, 9u, 34u, 97u, 117u, 120u, 121u, 34u, 34u, 9u, 58u,\n-        9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n-        48u, 57u, 9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u,\n-        9u, 125u, 120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u,\n-        34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u,\n-        9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 34u, 92u,\n-        9u, 125u, 34u, 92u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u,\n-        9u, 93u, 9u, 123u, 0u, 0u, 0\n+        0u, 0u, 9u, 34u, 97u, 121u, 120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u,\n+        9u, 125u, 9u, 125u, 9u, 93u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u,\n+        9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u,\n+        120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u,\n+        9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u,\n+        9u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 34u, 92u, 9u, 125u,\n+        34u, 92u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u,\n+        34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u, 98u, 98u, 9u, 123u, 9u, 123u, 9u, 123u,\n+        0\n@@ -48,8 +49,8 @@\n-        0, 115, 115, 26, 21, 2, 1, 50,\n-        49, 10, 117, 117, 117, 1, 50, 49,\n-        10, 117, 117, 1, 1, 50, 49, 117,\n-        117, 2, 1, 50, 49, 10, 117, 117,\n-        1, 50, 49, 10, 117, 117, 1, 1,\n-        50, 49, 117, 117, 1, 50, 49, 59,\n-        117, 59, 117, 117, 1, 50, 49, 117,\n-        85, 115, 0\n+        0, 26, 25, 2, 1, 50, 49, 10,\n+        117, 117, 85, 117, 1, 50, 49, 10,\n+        117, 117, 1, 1, 50, 49, 117, 117,\n+        2, 1, 50, 49, 10, 117, 117, 1,\n+        50, 49, 10, 117, 117, 1, 1, 50,\n+        49, 117, 117, 1, 50, 49, 59, 117,\n+        59, 117, 117, 1, 50, 49, 10, 117,\n+        1, 50, 49, 117, 1, 115, 115, 115\n@@ -59,8 +60,8 @@\n-        0, 0, 116, 232, 259, 281, 284, 286,\n-        337, 387, 398, 516, 634, 752, 754, 805,\n-        855, 866, 984, 1102, 1104, 1106, 1157, 1207,\n-        1325, 1443, 1446, 1448, 1499, 1549, 1560, 1678,\n-        1796, 1798, 1849, 1899, 1910, 2028, 2146, 2148,\n-        2150, 2201, 2251, 2369, 2487, 2489, 2540, 2590,\n-        2650, 2768, 2828, 2946, 3064, 3066, 3117, 3167,\n-        3285, 3371, 3487\n+        0, 0, 27, 53, 56, 58, 109, 159,\n+        170, 288, 406, 492, 610, 612, 663, 713,\n+        724, 842, 960, 962, 964, 1015, 1065, 1183,\n+        1301, 1304, 1306, 1357, 1407, 1418, 1536, 1654,\n+        1656, 1707, 1757, 1768, 1886, 2004, 2006, 2008,\n+        2059, 2109, 2227, 2345, 2347, 2398, 2448, 2508,\n+        2626, 2686, 2804, 2922, 2924, 2975, 3025, 3036,\n+        3154, 3156, 3207, 3257, 3375, 3377, 3493, 3609\n@@ -73,1 +74,2 @@\n-        0, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 2, 1, 3, 1, 4, 5,\n+        1, 6, 7, 8, 1, 1, 1, 1,\n@@ -75,0 +77,2 @@\n+        9, 1, 8, 10, 10, 1, 11, 12,\n+        1, 13, 1, 13, 13, 13, 13, 13,\n@@ -77,0 +81,1 @@\n+        1, 1, 13, 1, 1, 1, 1, 1,\n@@ -79,0 +84,2 @@\n+        1, 1, 1, 1, 14, 1, 14, 14,\n+        14, 14, 14, 1, 1, 1, 1, 1,\n@@ -80,8 +87,1 @@\n-        1, 1, 1, 2, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 3, 1, 2, 2, 2,\n-        2, 2, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 2, 1, 1, 1,\n+        1, 1, 1, 1, 1, 14, 1, 1,\n@@ -89,0 +89,4 @@\n+        1, 1, 15, 1, 1, 16, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 1,\n+        18, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 1, 20, 20, 20, 20, 20,\n@@ -91,0 +95,2 @@\n+        1, 1, 20, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 21, 1,\n@@ -98,2 +104,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 3,\n-        1, 4, 4, 4, 4, 4, 1, 1,\n@@ -102,2 +106,2 @@\n-        4, 1, 5, 1, 6, 1, 7, 8,\n-        1, 9, 10, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 22,\n+        1, 23, 23, 23, 23, 23, 1, 1,\n@@ -105,2 +109,0 @@\n-        11, 1, 12, 13, 1, 14, 1, 14,\n-        14, 14, 14, 14, 1, 1, 1, 1,\n@@ -108,1 +110,2 @@\n-        1, 1, 1, 1, 1, 1, 14, 1,\n+        23, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 0, 1, 1, 1,\n@@ -112,1 +115,0 @@\n-        15, 1, 15, 15, 15, 15, 15, 1,\n@@ -115,6 +117,0 @@\n-        1, 15, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 16, 1,\n-        1, 17, 18, 18, 18, 18, 18, 18,\n-        18, 18, 18, 1, 19, 20, 20, 20,\n-        20, 20, 20, 20, 20, 20, 1, 21,\n-        21, 21, 21, 21, 1, 1, 1, 1,\n@@ -122,1 +118,0 @@\n-        1, 1, 1, 1, 1, 1, 21, 1,\n@@ -124,1 +119,0 @@\n-        1, 1, 22, 1, 1, 1, 1, 1,\n@@ -127,0 +121,2 @@\n+        1, 1, 1, 1, 1, 24, 1, 24,\n+        24, 24, 24, 24, 1, 1, 1, 1,\n@@ -128,0 +124,1 @@\n+        1, 1, 1, 1, 1, 1, 24, 1,\n@@ -129,0 +126,1 @@\n+        1, 1, 25, 1, 1, 1, 1, 1,\n@@ -134,2 +132,2 @@\n-        1, 1, 1, 23, 1, 24, 24, 24,\n-        24, 24, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 25, 1, 20, 20, 20,\n+        20, 20, 1, 1, 1, 1, 1, 1,\n@@ -137,1 +135,1 @@\n-        1, 1, 1, 1, 24, 1, 1, 1,\n+        1, 1, 1, 1, 20, 1, 1, 1,\n@@ -139,1 +137,2 @@\n-        4, 1, 1, 1, 1, 1, 1, 1,\n+        21, 1, 1, 1, 19, 19, 19, 19,\n+        19, 19, 19, 19, 19, 19, 1, 1,\n@@ -148,0 +147,2 @@\n+        1, 22, 1, 26, 1, 26, 26, 26,\n+        26, 26, 1, 1, 1, 1, 1, 1,\n@@ -149,1 +150,1 @@\n-        1, 25, 1, 21, 21, 21, 21, 21,\n+        1, 1, 1, 1, 26, 1, 1, 1,\n@@ -152,4 +153,2 @@\n-        1, 1, 21, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 22, 1,\n-        1, 1, 20, 20, 20, 20, 20, 20,\n-        20, 20, 20, 20, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 27, 1,\n+        27, 27, 27, 27, 27, 1, 1, 1,\n@@ -157,0 +156,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 27,\n@@ -158,0 +158,5 @@\n+        1, 1, 1, 1, 28, 1, 1, 29,\n+        30, 30, 30, 30, 30, 30, 30, 30,\n+        30, 1, 31, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 1, 33, 33, 33,\n+        33, 33, 1, 1, 1, 1, 1, 1,\n@@ -159,0 +164,1 @@\n+        1, 1, 1, 1, 33, 1, 1, 1,\n@@ -160,0 +166,1 @@\n+        34, 1, 1, 1, 1, 1, 1, 1,\n@@ -163,2 +170,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 23,\n-        1, 26, 1, 26, 26, 26, 26, 26,\n@@ -167,1 +172,0 @@\n-        1, 1, 26, 1, 1, 1, 1, 1,\n@@ -170,2 +174,0 @@\n-        1, 1, 1, 1, 27, 1, 27, 27,\n-        27, 27, 27, 1, 1, 1, 1, 1,\n@@ -173,1 +175,0 @@\n-        1, 1, 1, 1, 1, 27, 1, 1,\n@@ -175,4 +176,1 @@\n-        1, 1, 28, 1, 1, 29, 30, 30,\n-        30, 30, 30, 30, 30, 30, 30, 1,\n-        31, 32, 32, 32, 32, 32, 32, 32,\n-        32, 32, 1, 33, 33, 33, 33, 33,\n+        1, 35, 1, 33, 33, 33, 33, 33,\n@@ -183,2 +181,2 @@\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 1, 1, 1, 1,\n@@ -193,1 +191,4 @@\n-        1, 33, 33, 33, 33, 33, 1, 1,\n+        1, 36, 1, 37, 1, 37, 37, 37,\n+        37, 37, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 37, 1, 1, 1,\n@@ -196,4 +197,2 @@\n-        33, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 34, 1, 1, 1,\n-        32, 32, 32, 32, 32, 32, 32, 32,\n-        32, 32, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 38, 1,\n+        38, 38, 38, 38, 38, 1, 1, 1,\n@@ -201,0 +200,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 38,\n@@ -202,0 +202,3 @@\n+        1, 1, 1, 1, 1, 1, 1, 39,\n+        40, 40, 40, 40, 40, 40, 40, 40,\n+        40, 1, 41, 41, 41, 41, 41, 1,\n@@ -204,0 +207,2 @@\n+        1, 41, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 42, 1, 1,\n@@ -207,2 +212,0 @@\n-        1, 1, 1, 1, 1, 35, 1, 36,\n-        1, 37, 1, 37, 37, 37, 37, 37,\n@@ -211,1 +214,0 @@\n-        1, 1, 37, 1, 1, 1, 1, 1,\n@@ -214,2 +216,0 @@\n-        1, 1, 1, 1, 38, 1, 38, 38,\n-        38, 38, 38, 1, 1, 1, 1, 1,\n@@ -217,1 +217,0 @@\n-        1, 1, 1, 1, 1, 38, 1, 1,\n@@ -219,2 +218,1 @@\n-        1, 1, 1, 1, 1, 39, 40, 40,\n-        40, 40, 40, 40, 40, 40, 40, 1,\n+        1, 1, 1, 1, 1, 1, 43, 1,\n@@ -225,1 +223,3 @@\n-        1, 1, 1, 42, 1, 1, 1, 1,\n+        1, 1, 1, 42, 1, 1, 1, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 1, 1, 1, 1, 1, 1, 1,\n@@ -233,0 +233,2 @@\n+        1, 1, 1, 1, 43, 1, 45, 46,\n+        1, 47, 1, 47, 47, 47, 47, 47,\n@@ -235,2 +237,1 @@\n-        1, 1, 1, 1, 43, 1, 41, 41,\n-        41, 41, 41, 1, 1, 1, 1, 1,\n+        1, 1, 47, 1, 1, 1, 1, 1,\n@@ -238,1 +239,0 @@\n-        1, 1, 1, 1, 1, 41, 1, 1,\n@@ -240,2 +240,2 @@\n-        1, 42, 1, 1, 1, 44, 44, 44,\n-        44, 44, 44, 44, 44, 44, 44, 1,\n+        1, 1, 1, 1, 48, 1, 48, 48,\n+        48, 48, 48, 1, 1, 1, 1, 1,\n@@ -243,0 +243,1 @@\n+        1, 1, 1, 1, 1, 48, 1, 1,\n@@ -244,0 +245,4 @@\n+        1, 1, 49, 1, 1, 50, 51, 51,\n+        51, 51, 51, 51, 51, 51, 51, 1,\n+        52, 53, 53, 53, 53, 53, 53, 53,\n+        53, 53, 1, 54, 54, 54, 54, 54,\n@@ -246,0 +251,2 @@\n+        1, 1, 54, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 55, 1,\n@@ -250,2 +257,0 @@\n-        1, 1, 43, 1, 45, 46, 1, 47,\n-        1, 47, 47, 47, 47, 47, 1, 1,\n@@ -254,1 +259,0 @@\n-        47, 1, 1, 1, 1, 1, 1, 1,\n@@ -257,2 +261,0 @@\n-        1, 1, 48, 1, 48, 48, 48, 48,\n-        48, 1, 1, 1, 1, 1, 1, 1,\n@@ -260,5 +262,1 @@\n-        1, 1, 1, 48, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        49, 1, 1, 50, 51, 51, 51, 51,\n-        51, 51, 51, 51, 51, 1, 52, 53,\n-        53, 53, 53, 53, 53, 53, 53, 53,\n+        1, 1, 1, 1, 1, 1, 1, 56,\n@@ -270,0 +268,2 @@\n+        53, 53, 53, 53, 53, 53, 53, 53,\n+        53, 53, 1, 1, 1, 1, 1, 1,\n@@ -277,0 +277,2 @@\n+        1, 1, 1, 1, 1, 56, 1, 57,\n+        1, 57, 57, 57, 57, 57, 1, 1,\n@@ -279,4 +281,1 @@\n-        1, 1, 1, 1, 1, 56, 1, 54,\n-        54, 54, 54, 54, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 54, 1,\n+        57, 1, 1, 1, 1, 1, 1, 1,\n@@ -284,2 +283,0 @@\n-        1, 1, 55, 1, 1, 1, 53, 53,\n-        53, 53, 53, 53, 53, 53, 53, 53,\n@@ -287,0 +284,2 @@\n+        1, 1, 58, 1, 58, 58, 58, 58,\n+        58, 1, 1, 1, 1, 1, 1, 1,\n@@ -288,0 +287,1 @@\n+        1, 1, 1, 58, 1, 1, 1, 1,\n@@ -289,0 +289,4 @@\n+        59, 1, 1, 60, 61, 61, 61, 61,\n+        61, 61, 61, 61, 61, 1, 62, 63,\n+        63, 63, 63, 63, 63, 63, 63, 63,\n+        1, 64, 64, 64, 64, 64, 1, 1,\n@@ -291,0 +295,2 @@\n+        64, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 65, 1, 1, 1,\n@@ -294,2 +300,0 @@\n-        1, 1, 1, 56, 1, 57, 1, 57,\n-        57, 57, 57, 57, 1, 1, 1, 1,\n@@ -297,1 +301,0 @@\n-        1, 1, 1, 1, 1, 1, 57, 1,\n@@ -301,1 +304,0 @@\n-        58, 1, 58, 58, 58, 58, 58, 1,\n@@ -304,5 +306,1 @@\n-        1, 58, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 59, 1,\n-        1, 60, 61, 61, 61, 61, 61, 61,\n-        61, 61, 61, 1, 62, 63, 63, 63,\n-        63, 63, 63, 63, 63, 63, 1, 64,\n+        1, 1, 1, 1, 1, 66, 1, 64,\n@@ -313,2 +311,2 @@\n-        1, 1, 65, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 65, 1, 1, 1, 63, 63,\n+        63, 63, 63, 63, 63, 63, 63, 63,\n@@ -323,2 +321,2 @@\n-        1, 1, 1, 66, 1, 64, 64, 64,\n-        64, 64, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 66, 1, 67, 1, 68,\n+        1, 68, 68, 68, 68, 68, 1, 1,\n@@ -326,1 +324,0 @@\n-        1, 1, 1, 1, 64, 1, 1, 1,\n@@ -328,2 +325,1 @@\n-        65, 1, 1, 1, 63, 63, 63, 63,\n-        63, 63, 63, 63, 63, 63, 1, 1,\n+        68, 1, 1, 1, 1, 1, 1, 1,\n@@ -332,0 +328,2 @@\n+        1, 1, 69, 1, 69, 69, 69, 69,\n+        69, 1, 1, 1, 1, 1, 1, 1,\n@@ -333,0 +331,1 @@\n+        1, 1, 1, 69, 1, 1, 1, 1,\n@@ -334,0 +333,3 @@\n+        1, 1, 1, 70, 71, 71, 71, 71,\n+        71, 71, 71, 71, 71, 1, 72, 72,\n+        72, 72, 72, 1, 1, 1, 1, 1,\n@@ -335,0 +337,1 @@\n+        1, 1, 1, 1, 1, 72, 1, 1,\n@@ -336,0 +339,1 @@\n+        1, 73, 1, 1, 1, 1, 1, 1,\n@@ -338,2 +342,0 @@\n-        1, 66, 1, 67, 1, 68, 1, 68,\n-        68, 68, 68, 68, 1, 1, 1, 1,\n@@ -341,1 +343,0 @@\n-        1, 1, 1, 1, 1, 1, 68, 1,\n@@ -345,1 +346,0 @@\n-        69, 1, 69, 69, 69, 69, 69, 1,\n@@ -348,1 +348,0 @@\n-        1, 69, 1, 1, 1, 1, 1, 1,\n@@ -350,2 +349,1 @@\n-        1, 70, 71, 71, 71, 71, 71, 71,\n-        71, 71, 71, 1, 72, 72, 72, 72,\n+        1, 1, 74, 1, 72, 72, 72, 72,\n@@ -356,0 +354,2 @@\n+        1, 1, 1, 75, 75, 75, 75, 75,\n+        75, 75, 75, 75, 75, 1, 1, 1,\n@@ -364,0 +364,2 @@\n+        74, 1, 76, 1, 76, 76, 76, 76,\n+        76, 1, 1, 1, 1, 1, 1, 1,\n@@ -365,0 +367,1 @@\n+        1, 1, 1, 76, 1, 1, 1, 1,\n@@ -366,1 +369,0 @@\n-        74, 1, 72, 72, 72, 72, 72, 1,\n@@ -368,0 +370,2 @@\n+        1, 1, 1, 1, 1, 77, 1, 77,\n+        77, 77, 77, 77, 1, 1, 1, 1,\n@@ -369,4 +373,13 @@\n-        1, 72, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 73, 1, 1,\n-        1, 75, 75, 75, 75, 75, 75, 75,\n-        75, 75, 75, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 77, 1,\n+        78, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 79, 80,\n+        80, 80, 80, 80, 80, 80, 80, 80,\n+        1, 82, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 81, 81, 81, 81, 81,\n+        81, 81, 81, 83, 81, 84, 84, 84,\n+        84, 84, 1, 1, 1, 1, 1, 1,\n@@ -374,0 +387,1 @@\n+        1, 1, 1, 1, 84, 1, 1, 1,\n@@ -375,0 +389,1 @@\n+        85, 1, 1, 1, 1, 1, 1, 1,\n@@ -380,2 +395,0 @@\n-        1, 1, 1, 1, 1, 1, 74, 1,\n-        76, 1, 76, 76, 76, 76, 76, 1,\n@@ -384,1 +397,0 @@\n-        1, 76, 1, 1, 1, 1, 1, 1,\n@@ -387,2 +399,1 @@\n-        1, 1, 1, 77, 1, 77, 77, 77,\n-        77, 77, 1, 1, 1, 1, 1, 1,\n+        1, 86, 1, 81, 1, 1, 1, 1,\n@@ -390,12 +401,0 @@\n-        1, 1, 1, 1, 77, 1, 78, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 79, 80, 80, 80,\n-        80, 80, 80, 80, 80, 80, 1, 82,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 81, 81, 81, 81, 81, 81, 81,\n-        81, 83, 81, 84, 84, 84, 84, 84,\n@@ -404,2 +403,0 @@\n-        1, 1, 84, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 85, 1,\n@@ -409,0 +406,2 @@\n+        1, 1, 1, 1, 1, 81, 1, 87,\n+        87, 87, 87, 87, 1, 1, 1, 1,\n@@ -410,0 +409,1 @@\n+        1, 1, 1, 1, 1, 1, 87, 1,\n@@ -411,0 +411,1 @@\n+        1, 1, 88, 1, 1, 1, 1, 1,\n@@ -415,2 +416,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 86,\n-        1, 81, 1, 1, 1, 1, 1, 1,\n@@ -422,2 +421,1 @@\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 81, 1, 87, 87, 87,\n+        1, 1, 1, 89, 1, 87, 87, 87,\n@@ -428,1 +426,2 @@\n-        88, 1, 1, 1, 1, 1, 1, 1,\n+        88, 1, 1, 1, 90, 90, 90, 90,\n+        90, 90, 90, 90, 90, 90, 1, 1,\n@@ -437,0 +436,2 @@\n+        1, 89, 1, 91, 1, 91, 91, 91,\n+        91, 91, 1, 1, 1, 1, 1, 1,\n@@ -438,1 +439,1 @@\n-        1, 89, 1, 87, 87, 87, 87, 87,\n+        1, 1, 1, 1, 91, 1, 1, 1,\n@@ -441,4 +442,2 @@\n-        1, 1, 87, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 88, 1,\n-        1, 1, 90, 90, 90, 90, 90, 90,\n-        90, 90, 90, 90, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 92, 1,\n+        92, 92, 92, 92, 92, 1, 1, 1,\n@@ -446,0 +445,1 @@\n+        1, 1, 1, 1, 1, 1, 1, 92,\n@@ -447,0 +447,5 @@\n+        1, 1, 1, 1, 93, 1, 1, 94,\n+        95, 95, 95, 95, 95, 95, 95, 95,\n+        95, 1, 23, 96, 96, 96, 96, 96,\n+        96, 96, 96, 96, 1, 23, 23, 23,\n+        23, 23, 1, 1, 1, 1, 1, 1,\n@@ -448,0 +453,1 @@\n+        1, 1, 1, 1, 23, 1, 1, 1,\n@@ -449,0 +455,2 @@\n+        0, 1, 1, 1, 96, 96, 96, 96,\n+        96, 96, 96, 96, 96, 96, 1, 1,\n@@ -452,2 +460,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 89,\n-        1, 91, 1, 91, 91, 91, 91, 91,\n@@ -456,1 +462,0 @@\n-        1, 1, 91, 1, 1, 1, 1, 1,\n@@ -459,2 +464,0 @@\n-        1, 1, 1, 1, 92, 1, 92, 92,\n-        92, 92, 92, 1, 1, 1, 1, 1,\n@@ -462,1 +465,2 @@\n-        1, 1, 1, 1, 1, 92, 1, 1,\n+        1, 24, 1, 97, 1, 97, 97, 97,\n+        97, 97, 1, 1, 1, 1, 1, 1,\n@@ -464,3 +468,1 @@\n-        1, 1, 1, 1, 1, 93, 94, 94,\n-        94, 94, 94, 94, 94, 94, 94, 1,\n-        87, 87, 87, 87, 87, 1, 1, 1,\n+        1, 1, 1, 1, 97, 1, 1, 1,\n@@ -468,1 +470,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 87,\n@@ -470,3 +471,26 @@\n-        1, 1, 1, 88, 1, 1, 1, 95,\n-        95, 95, 95, 95, 95, 95, 95, 95,\n-        95, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 98, 1,\n+        98, 98, 98, 98, 98, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 98,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 99,\n+        100, 100, 100, 100, 100, 100, 100, 100,\n+        100, 1, 87, 87, 87, 87, 87, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 87, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 88, 1, 1,\n+        1, 101, 101, 101, 101, 101, 101, 101,\n+        101, 101, 101, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 89, 1,\n+        8, 1, 102, 102, 102, 102, 102, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 102, 1, 1, 1, 1, 1, 1,\n@@ -479,0 +503,1 @@\n+        1, 1, 1, 1, 103, 1, 1, 1,\n@@ -480,2 +505,0 @@\n-        1, 1, 1, 1, 89, 1, 96, 96,\n-        96, 96, 96, 1, 1, 1, 1, 1,\n@@ -483,1 +506,0 @@\n-        1, 1, 1, 1, 1, 96, 1, 1,\n@@ -485,1 +507,2 @@\n-        1, 97, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 104, 1, 103, 103,\n+        103, 103, 103, 1, 1, 1, 1, 1,\n@@ -487,0 +510,1 @@\n+        1, 1, 1, 1, 1, 103, 1, 1,\n@@ -491,2 +515,0 @@\n-        1, 1, 98, 1, 2, 2, 2, 2,\n-        2, 1, 1, 1, 1, 1, 1, 1,\n@@ -494,1 +516,0 @@\n-        1, 1, 1, 2, 1, 1, 1, 1,\n@@ -501,0 +522,1 @@\n+        104, 1, 25, 25, 25, 25, 25, 1,\n@@ -503,0 +525,1 @@\n+        1, 25, 1, 1, 1, 1, 1, 1,\n@@ -505,2 +528,9 @@\n-        1, 1, 1, 1, 1, 1, 3, 1,\n-        1, 0\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 104, 1, 0\n@@ -510,13 +540,14 @@\n-        1, 0, 2, 3, 3, 4, 5, 19,\n-        25, 38, 44, 52, 6, 13, 7, 8,\n-        9, 10, 12, 10, 12, 11, 3, 56,\n-        11, 56, 14, 15, 16, 17, 18, 17,\n-        18, 11, 3, 56, 20, 21, 22, 23,\n-        24, 11, 3, 56, 24, 26, 32, 27,\n-        28, 29, 30, 31, 30, 31, 11, 3,\n-        56, 33, 34, 35, 36, 37, 36, 37,\n-        11, 3, 56, 39, 40, 41, 42, 43,\n-        11, 3, 56, 43, 45, 46, 47, 50,\n-        51, 47, 48, 49, 11, 3, 56, 11,\n-        3, 56, 51, 53, 54, 50, 55, 55,\n-        56, 57, 58\n+        1, 0, 2, 3, 18, 24, 37, 43,\n+        51, 56, 60, 4, 12, 5, 6, 7,\n+        8, 11, 8, 11, 9, 1, 10, 9,\n+        10, 63, 13, 14, 15, 16, 17, 16,\n+        17, 9, 1, 10, 19, 20, 21, 22,\n+        23, 9, 1, 10, 23, 25, 31, 26,\n+        27, 28, 29, 30, 29, 30, 9, 1,\n+        10, 32, 33, 34, 35, 36, 35, 36,\n+        9, 1, 10, 38, 39, 40, 41, 42,\n+        9, 1, 10, 42, 44, 45, 46, 49,\n+        50, 46, 47, 48, 9, 1, 10, 9,\n+        1, 10, 50, 52, 53, 54, 9, 55,\n+        55, 57, 58, 49, 59, 59, 61, 62,\n+        1\n@@ -526,1 +557,0 @@\n-        0, 0, 0, 1, 0, 0, 0, 0,\n@@ -528,11 +558,13 @@\n-        2, 2, 2, 0, 0, 3, 3, 4,\n-        0, 5, 0, 0, 2, 2, 2, 0,\n-        0, 6, 6, 7, 0, 0, 0, 2,\n-        2, 8, 8, 9, 0, 0, 0, 0,\n-        0, 2, 2, 2, 0, 0, 10, 10,\n-        11, 0, 0, 2, 2, 2, 0, 0,\n-        12, 12, 13, 0, 0, 0, 2, 2,\n-        14, 14, 15, 0, 0, 0, 2, 16,\n-        16, 0, 17, 0, 18, 18, 19, 20,\n-        20, 21, 17, 0, 0, 22, 22, 23,\n-        0, 0, 0\n+        0, 0, 0, 0, 0, 0, 0, 1,\n+        1, 1, 0, 0, 2, 2, 2, 0,\n+        0, 3, 0, 0, 1, 1, 1, 0,\n+        0, 4, 4, 4, 0, 0, 0, 1,\n+        1, 5, 5, 5, 0, 0, 0, 0,\n+        0, 1, 1, 1, 0, 0, 6, 6,\n+        6, 0, 0, 1, 1, 1, 0, 0,\n+        7, 7, 7, 0, 0, 0, 1, 1,\n+        8, 8, 8, 0, 0, 0, 1, 9,\n+        9, 0, 10, 0, 11, 11, 11, 12,\n+        12, 12, 10, 0, 0, 1, 1, 1,\n+        0, 0, 0, 13, 13, 14, 0, 0,\n+        15\n@@ -541,2 +573,2 @@\n-static const int deserialize_json_start = 1;\n-static const int deserialize_json_first_final = 56;\n+static const int deserialize_json_start = 61;\n+static const int deserialize_json_first_final = 61;\n@@ -545,1 +577,1 @@\n-static const int deserialize_json_en_main = 1;\n+static const int deserialize_json_en_main = 61;\n@@ -548,1 +580,1 @@\n-#line 111 \"hb-buffer-deserialize-json.rl\"\n+#line 115 \"hb-buffer-deserialize-json.rl\"\n@@ -568,1 +600,1 @@\n-#line 569 \"hb-buffer-deserialize-json.hh\"\n+#line 594 \"hb-buffer-deserialize-json.hh\"\n@@ -573,1 +605,1 @@\n-#line 574 \"hb-buffer-deserialize-json.hh\"\n+#line 597 \"hb-buffer-deserialize-json.hh\"\n@@ -598,1 +630,1 @@\n-        case 1:\n+        case 15:\n@@ -605,1 +637,1 @@\n-        case 5:\n+        case 3:\n@@ -615,1 +647,1 @@\n-        case 2:\n+        case 1:\n@@ -621,1 +653,1 @@\n-        case 17:\n+        case 10:\n@@ -625,1 +657,1 @@\n-        case 23:\n+        case 14:\n@@ -629,1 +661,1 @@\n-        case 18:\n+        case 11:\n@@ -639,1 +671,1 @@\n-        case 20:\n+        case 12:\n@@ -643,1 +675,1 @@\n-        case 8:\n+        case 5:\n@@ -647,1 +679,1 @@\n-        case 10:\n+        case 6:\n@@ -651,1 +683,1 @@\n-        case 12:\n+        case 7:\n@@ -655,1 +687,1 @@\n-        case 3:\n+        case 2:\n@@ -659,1 +691,1 @@\n-        case 6:\n+        case 4:\n@@ -663,1 +695,1 @@\n-        case 14:\n+        case 8:\n@@ -667,1 +699,1 @@\n-        case 16:\n+        case 9:\n@@ -675,1 +707,1 @@\n-        case 22:\n+        case 13:\n@@ -683,103 +715,1 @@\n-        case 19:\n-#line 58 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        \/* TODO Unescape \\\" and \\\\ if found. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok+1, p - tok - 2, \/* Skip \"\" *\/\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 21:\n-#line 66 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_uint (tok, p, &info.codepoint)) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 9:\n-#line 67 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 11:\n-#line 68 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 13:\n-#line 69 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 4:\n-#line 70 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 7:\n-#line 71 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 15:\n-#line 72 \"hb-buffer-deserialize-json.rl\"\n-        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n-#line 43 \"hb-buffer-deserialize-json.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-#line 786 \"hb-buffer-deserialize-json.hh\"\n+#line 689 \"hb-buffer-deserialize-json.hh\"\n@@ -797,1 +727,1 @@\n-#line 132 \"hb-buffer-deserialize-json.rl\"\n+#line 136 \"hb-buffer-deserialize-json.rl\"\n@@ -802,1 +732,1 @@\n-  return p == pe && *(p-1) != ']';\n+  return p == pe;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-json.hh","additions":266,"deletions":336,"binary":false,"changes":602,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#line 36 \"hb-buffer-deserialize-text-glyphs.hh\"\n+#line 33 \"hb-buffer-deserialize-text-glyphs.hh\"\n@@ -37,4 +37,7 @@\n-        0u, 0u, 48u, 57u, 45u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 48u, 57u, 45u, 57u,\n-        48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u, 43u, 124u, 9u, 124u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n-        9u, 124u, 9u, 124u, 9u, 124u, 0\n+        0u, 0u, 35u, 124u, 48u, 57u, 60u, 124u, 45u, 57u, 48u, 57u, 44u, 44u, 45u, 57u,\n+        48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 62u, 62u,\n+        93u, 124u, 45u, 57u, 48u, 57u, 35u, 124u, 45u, 57u, 48u, 57u, 35u, 124u, 35u, 124u,\n+        35u, 124u, 35u, 124u, 35u, 124u, 35u, 124u, 48u, 57u, 35u, 124u, 45u, 57u, 48u, 57u,\n+        44u, 44u, 45u, 57u, 48u, 57u, 35u, 124u, 35u, 124u, 44u, 57u, 35u, 124u, 43u, 124u,\n+        35u, 124u, 48u, 62u, 44u, 57u, 44u, 57u, 44u, 57u, 48u, 124u, 35u, 124u, 35u, 124u,\n+        35u, 124u, 0\n@@ -44,4 +47,7 @@\n-        0, 10, 13, 10, 13, 10, 10, 13,\n-        10, 1, 13, 10, 14, 82, 116, 116,\n-        116, 116, 116, 116, 116, 116, 116, 116,\n-        116, 116, 116\n+        0, 90, 10, 65, 13, 10, 1, 13,\n+        10, 1, 13, 10, 1, 13, 10, 1,\n+        32, 13, 10, 90, 13, 10, 90, 90,\n+        90, 90, 90, 90, 10, 90, 13, 10,\n+        1, 13, 10, 90, 90, 14, 90, 82,\n+        90, 15, 14, 14, 14, 77, 90, 90,\n+        90\n@@ -51,4 +57,7 @@\n-        0, 0, 11, 25, 36, 50, 61, 72,\n-        86, 97, 99, 113, 124, 139, 222, 339,\n-        456, 573, 690, 807, 924, 1041, 1158, 1275,\n-        1392, 1509, 1626\n+        0, 0, 91, 102, 168, 182, 193, 195,\n+        209, 220, 222, 236, 247, 249, 263, 274,\n+        276, 309, 323, 334, 425, 439, 450, 541,\n+        632, 723, 814, 905, 996, 1007, 1098, 1112,\n+        1123, 1125, 1139, 1150, 1241, 1332, 1347, 1438,\n+        1521, 1612, 1628, 1643, 1658, 1673, 1751, 1842,\n+        1933\n@@ -58,11 +67,25 @@\n-        0, 2, 2, 2, 2, 2, 2,\n-        2, 2, 2, 1, 3, 1, 1, 4,\n-        5, 5, 5, 5, 5, 5, 5, 5,\n-        5, 1, 6, 7, 7, 7, 7, 7,\n-        7, 7, 7, 7, 1, 8, 1, 1,\n-        9, 10, 10, 10, 10, 10, 10, 10,\n-        10, 10, 1, 11, 12, 12, 12, 12,\n-        12, 12, 12, 12, 12, 1, 13, 14,\n-        14, 14, 14, 14, 14, 14, 14, 14,\n-        1, 15, 1, 1, 16, 17, 17, 17,\n-        17, 17, 17, 17, 17, 17, 1, 18,\n+        1, 0, 0, 0, 0, 0, 0,\n+        0, 2, 3, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 4, 5, 0, 0, 6, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 7, 8, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 8, 0, 9, 10, 10, 10,\n+        10, 10, 10, 10, 10, 10, 3, 11,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        12, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 12,\n+        3, 13, 3, 3, 14, 15, 15, 15,\n+        15, 15, 15, 15, 15, 15, 3, 14,\n+        15, 15, 15, 15, 15, 15, 15, 15,\n+        15, 3, 16, 3, 17, 3, 3, 18,\n@@ -70,207 +93,228 @@\n-        19, 1, 20, 1, 21, 1, 1, 22,\n-        23, 23, 23, 23, 23, 23, 23, 23,\n-        23, 1, 24, 25, 25, 25, 25, 25,\n-        25, 25, 25, 25, 1, 20, 1, 1,\n-        1, 19, 19, 19, 19, 19, 19, 19,\n-        19, 19, 19, 1, 26, 26, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 26, 1,\n-        1, 26, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 26, 26, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 26, 1, 28,\n-        28, 28, 28, 28, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 28, 27,\n-        27, 29, 27, 27, 27, 27, 27, 27,\n-        27, 30, 1, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 31, 27, 27, 32, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 33, 1, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 27, 27, 27, 27, 27, 27,\n-        27, 27, 28, 27, 34, 34, 34, 34,\n-        34, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 34, 26, 26, 35, 26,\n-        26, 26, 26, 26, 26, 26, 36, 1,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        37, 26, 26, 38, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 39,\n-        1, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 26,\n-        26, 26, 26, 26, 26, 26, 26, 40,\n-        26, 41, 41, 41, 41, 41, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        41, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 42, 1, 43, 43,\n-        43, 43, 43, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 43, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 44, 1, 41, 41, 41, 41, 41,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 41, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 42, 1,\n-        46, 46, 46, 46, 46, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 46,\n-        1, 1, 47, 1, 1, 1, 1, 1,\n-        1, 1, 1, 48, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 49, 1, 50, 50, 50,\n-        50, 50, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 50, 1, 1, 51,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        52, 1, 50, 50, 50, 50, 50, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 50, 1, 1, 51, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 12, 12, 12, 12, 12, 12, 12,\n-        12, 12, 12, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 52, 1, 46,\n-        46, 46, 46, 46, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 46, 1,\n-        1, 47, 1, 1, 1, 1, 1, 1,\n-        1, 1, 48, 1, 1, 1, 7, 7,\n-        7, 7, 7, 7, 7, 7, 7, 7,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 49, 1, 53, 53, 53, 53,\n-        53, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 53, 1, 1, 54, 1,\n-        1, 1, 1, 1, 1, 1, 55, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 56, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 57,\n-        1, 58, 58, 58, 58, 58, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        58, 1, 1, 59, 1, 1, 1, 1,\n-        1, 1, 1, 60, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 61, 1, 58, 58,\n-        58, 58, 58, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 58, 1, 1,\n-        59, 1, 1, 1, 1, 1, 1, 1,\n-        60, 1, 1, 1, 1, 25, 25, 25,\n-        25, 25, 25, 25, 25, 25, 25, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 61, 1, 53, 53, 53, 53, 53,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 53, 1, 1, 54, 1, 1,\n-        1, 1, 1, 1, 1, 55, 1, 1,\n-        1, 1, 62, 62, 62, 62, 62, 62,\n-        62, 62, 62, 62, 1, 1, 1, 1,\n-        1, 1, 56, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 57, 1,\n-        0\n+        19, 3, 18, 19, 19, 19, 19, 19,\n+        19, 19, 19, 19, 3, 20, 3, 21,\n+        3, 3, 22, 23, 23, 23, 23, 23,\n+        23, 23, 23, 23, 3, 22, 23, 23,\n+        23, 23, 23, 23, 23, 23, 23, 3,\n+        24, 3, 25, 3, 3, 26, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 3,\n+        26, 27, 27, 27, 27, 27, 27, 27,\n+        27, 27, 3, 28, 3, 29, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 29, 3, 30, 3,\n+        3, 31, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 3, 33, 34, 34, 34,\n+        34, 34, 34, 34, 34, 34, 3, 35,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        36, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        37, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 38, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        38, 3, 39, 3, 3, 40, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 3,\n+        42, 43, 43, 43, 43, 43, 43, 43,\n+        43, 43, 3, 44, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 45, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 46, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 46, 3, 44, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 43, 43, 43, 43, 43,\n+        43, 43, 43, 43, 43, 3, 3, 45,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        46, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 46,\n+        3, 35, 3, 3, 3, 3, 3, 3,\n+        3, 3, 36, 3, 3, 3, 34, 34,\n+        34, 34, 34, 34, 34, 34, 34, 34,\n+        3, 3, 37, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 38, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 38, 3, 1, 0, 0, 0,\n+        0, 0, 0, 0, 2, 3, 47, 0,\n+        0, 48, 49, 49, 49, 49, 49, 49,\n+        49, 49, 49, 0, 0, 4, 5, 0,\n+        0, 6, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 7, 8, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 8, 0, 1,\n+        0, 0, 0, 0, 0, 0, 0, 2,\n+        3, 0, 0, 0, 48, 49, 49, 49,\n+        49, 49, 49, 49, 49, 49, 0, 0,\n+        4, 5, 0, 0, 6, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        7, 8, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        8, 0, 1, 0, 0, 0, 0, 0,\n+        0, 0, 2, 16, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 4, 5, 0, 0, 6,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 7, 8, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 8, 0, 50, 51, 51,\n+        51, 51, 51, 51, 51, 51, 51, 3,\n+        52, 3, 3, 3, 3, 3, 3, 3,\n+        53, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 54, 3, 3, 3, 55, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 56, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 56, 3, 57, 3, 3, 58, 59,\n+        59, 59, 59, 59, 59, 59, 59, 59,\n+        3, 60, 61, 61, 61, 61, 61, 61,\n+        61, 61, 61, 3, 62, 3, 63, 3,\n+        3, 64, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 3, 66, 67, 67, 67,\n+        67, 67, 67, 67, 67, 67, 3, 68,\n+        3, 3, 3, 3, 3, 3, 3, 69,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        70, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 71, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        71, 3, 68, 3, 3, 3, 3, 3,\n+        3, 3, 69, 3, 3, 3, 3, 67,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 3, 3, 70, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 71, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 71, 3, 62, 3, 3,\n+        3, 61, 61, 61, 61, 61, 61, 61,\n+        61, 61, 61, 3, 52, 3, 3, 3,\n+        3, 3, 3, 3, 53, 3, 3, 3,\n+        3, 72, 72, 72, 72, 72, 72, 72,\n+        72, 72, 72, 3, 3, 54, 3, 3,\n+        3, 55, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 56, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 56, 3, 0,\n+        0, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 0, 3, 3, 0, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        0, 0, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        0, 3, 1, 0, 0, 0, 0, 0,\n+        0, 0, 2, 16, 0, 0, 0, 49,\n+        49, 49, 49, 49, 49, 49, 49, 49,\n+        49, 0, 0, 4, 5, 0, 0, 6,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 7, 8, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 8, 0, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 27, 3,\n+        3, 3, 3, 28, 3, 24, 3, 3,\n+        3, 23, 23, 23, 23, 23, 23, 23,\n+        23, 23, 23, 3, 20, 3, 3, 3,\n+        19, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 3, 16, 3, 3, 3, 15,\n+        15, 15, 15, 15, 15, 15, 15, 15,\n+        15, 3, 73, 73, 73, 73, 73, 73,\n+        73, 73, 73, 73, 3, 3, 11, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 12,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 3, 3, 3, 3, 12, 3,\n+        75, 74, 74, 74, 74, 74, 74, 74,\n+        76, 3, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 77, 78, 74, 74, 79, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        80, 81, 82, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 82, 74, 84, 83, 83, 83, 83,\n+        83, 83, 83, 85, 3, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 86, 87, 83, 83,\n+        88, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 89, 90, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 83, 83,\n+        83, 83, 83, 83, 90, 83, 91, 74,\n+        74, 74, 74, 74, 74, 74, 92, 3,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 93,\n+        94, 74, 74, 95, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 81,\n+        96, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 74,\n+        74, 74, 74, 74, 74, 74, 74, 96,\n+        74, 0\n@@ -280,8 +324,13 @@\n-        16, 0, 18, 3, 19, 22, 19, 22,\n-        5, 20, 21, 20, 21, 23, 26, 8,\n-        9, 12, 9, 12, 10, 11, 24, 25,\n-        24, 25, 15, 15, 14, 1, 2, 6,\n-        7, 13, 15, 1, 2, 6, 7, 13,\n-        14, 17, 14, 17, 14, 18, 17, 1,\n-        4, 14, 17, 1, 14, 17, 1, 2,\n-        7, 14, 17, 1, 2, 14, 26\n+        1, 2, 17, 0, 25, 28, 30, 39,\n+        47, 3, 45, 4, 47, 5, 6, 44,\n+        7, 8, 9, 43, 10, 11, 12, 42,\n+        13, 14, 15, 41, 16, 47, 18, 19,\n+        24, 19, 24, 2, 20, 4, 47, 21,\n+        22, 23, 22, 23, 2, 4, 47, 26,\n+        27, 40, 29, 38, 2, 17, 4, 30,\n+        47, 31, 32, 37, 32, 37, 33, 34,\n+        35, 36, 35, 36, 2, 17, 4, 47,\n+        38, 45, 1, 2, 17, 25, 28, 30,\n+        48, 39, 47, 1, 2, 17, 25, 28,\n+        30, 39, 47, 2, 17, 25, 28, 30,\n+        47\n@@ -291,8 +340,13 @@\n-        1, 0, 1, 1, 1, 1, 0, 0,\n-        1, 1, 1, 0, 0, 1, 1, 1,\n-        1, 1, 0, 0, 2, 1, 1, 1,\n-        0, 0, 0, 4, 3, 5, 5, 5,\n-        5, 4, 6, 7, 7, 7, 7, 0,\n-        6, 8, 8, 0, 0, 0, 9, 10,\n-        10, 9, 11, 12, 11, 13, 14, 14,\n-        14, 13, 15, 16, 16, 15, 0\n+        0, 1, 1, 0, 1, 1, 1, 0,\n+        1, 2, 2, 3, 3, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 2, 2,\n+        2, 0, 0, 4, 4, 4, 4, 2,\n+        2, 2, 0, 0, 5, 5, 5, 0,\n+        0, 0, 2, 2, 6, 6, 6, 6,\n+        6, 2, 2, 2, 0, 0, 7, 2,\n+        2, 2, 0, 0, 8, 8, 8, 8,\n+        0, 0, 9, 10, 10, 10, 10, 10,\n+        9, 9, 10, 12, 13, 13, 13, 13,\n+        13, 12, 13, 14, 14, 14, 14, 14,\n+        14\n@@ -303,3 +357,6 @@\n-        0, 0, 0, 0, 0, 0, 3, 6,\n-        8, 0, 8, 9, 11, 11, 9, 13,\n-        15, 15, 13\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 11,\n+        0\n@@ -308,2 +365,2 @@\n-static const int deserialize_text_glyphs_start = 14;\n-static const int deserialize_text_glyphs_first_final = 14;\n+static const int deserialize_text_glyphs_start = 46;\n+static const int deserialize_text_glyphs_first_final = 46;\n@@ -312,1 +369,1 @@\n-static const int deserialize_text_glyphs_en_main = 14;\n+static const int deserialize_text_glyphs_en_main = 46;\n@@ -315,1 +372,1 @@\n-#line 98 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 101 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -325,1 +382,1 @@\n-  const char *p = buf, *pe = buf + buf_len, *eof = pe, *orig_pe = pe;\n+  const char *p = buf, *pe = buf + buf_len, *eof = pe;\n@@ -330,17 +387,0 @@\n-  while (p < pe && ISSPACE (*p))\n-    p++;\n-  if (p < pe && *p == (buffer->len ? '|' : '['))\n-    *end_ptr = ++p;\n-\n-  const char *end = strchr ((char *) p, ']');\n-  if (end)\n-    pe = eof = end;\n-  else\n-  {\n-    end = strrchr ((char *) p, '|');\n-    if (end)\n-      pe = eof = end;\n-    else\n-      pe = eof = p;\n-  }\n-\n@@ -352,1 +392,1 @@\n-#line 353 \"hb-buffer-deserialize-text-glyphs.hh\"\n+#line 386 \"hb-buffer-deserialize-text-glyphs.hh\"\n@@ -357,1 +397,1 @@\n-#line 358 \"hb-buffer-deserialize-text-glyphs.hh\"\n+#line 389 \"hb-buffer-deserialize-text-glyphs.hh\"\n@@ -382,2 +422,2 @@\n-        case 1:\n-#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 2:\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -388,2 +428,2 @@\n-        case 7:\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 1:\n+#line 54 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -398,2 +438,2 @@\n-        case 14:\n-#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 6:\n+#line 62 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -402,2 +442,2 @@\n-        case 2:\n-#line 64 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 7:\n+#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -406,2 +446,2 @@\n-        case 16:\n-#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 8:\n+#line 64 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -410,2 +450,2 @@\n-        case 10:\n-#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 4:\n+#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -414,2 +454,2 @@\n-        case 12:\n-#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 5:\n+#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -418,1 +458,5 @@\n-        case 4:\n+        case 3:\n+#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n+        break;\n+        case 9:\n@@ -424,1 +468,1 @@\n-#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -429,2 +473,2 @@\n-        case 6:\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 10:\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -432,5 +476,2 @@\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n@@ -438,1 +479,1 @@\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -440,5 +481,1 @@\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n+        tok = p;\n@@ -446,5 +483,1 @@\n-        break;\n-        case 13:\n-#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 54 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -452,2 +485,4 @@\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n@@ -455,2 +490,0 @@\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n@@ -459,3 +492,1 @@\n-        case 15:\n-#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        case 12:\n@@ -464,1 +495,1 @@\n-        buffer->add_info (info);\n+        buffer->add_info_and_pos (info, pos);\n@@ -467,1 +498,0 @@\n-        buffer->pos[buffer->len - 1] = pos;\n@@ -470,5 +500,1 @@\n-        break;\n-        case 9:\n-#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -476,5 +502,2 @@\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n+        hb_memset (&info, 0, sizeof (info));\n+        hb_memset (&pos , 0, sizeof (pos ));\n@@ -482,5 +505,1 @@\n-        break;\n-        case 11:\n-#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -488,5 +507,1 @@\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n+        tok = p;\n@@ -495,4 +510,2 @@\n-        case 8:\n-#line 68 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        case 14:\n+#line 54 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -500,2 +513,4 @@\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n@@ -503,2 +518,0 @@\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n@@ -506,2 +519,0 @@\n-        break;\n-        case 5:\n@@ -513,1 +524,1 @@\n-#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -517,1 +528,3 @@\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+        break;\n+        case 13:\n+#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -519,4 +532,2 @@\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n+        buffer->add_info_and_pos (info, pos);\n+        if (unlikely (!buffer->successful))\n@@ -524,0 +535,1 @@\n+        *end_ptr = p;\n@@ -525,2 +537,0 @@\n-        break;\n-        case 3:\n@@ -532,1 +542,1 @@\n-#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 50 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -536,1 +546,1 @@\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n+#line 54 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -543,8 +553,0 @@\n-}\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n@@ -553,1 +555,1 @@\n-#line 554 \"hb-buffer-deserialize-text-glyphs.hh\"\n+#line 523 \"hb-buffer-deserialize-text-glyphs.hh\"\n@@ -565,54 +567,0 @@\n-        case 6:\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 13:\n-#line 63 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 15:\n-#line 65 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 9:\n-#line 66 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n@@ -620,41 +568,0 @@\n-#line 67 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 8:\n-#line 68 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        { if (!parse_uint (tok, p, &info.mask    )) return false; }\n-#line 43 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 3:\n-#line 38 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        hb_memset (&info, 0, sizeof (info));\n-        hb_memset (&pos , 0, sizeof (pos ));\n-}\n-#line 51 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        tok = p;\n-}\n-#line 55 \"hb-buffer-deserialize-text-glyphs.rl\"\n-        {\n-        \/* TODO Unescape delimiters. *\/\n-        if (!hb_font_glyph_from_string (font,\n-                                        tok, p - tok,\n-                                        &info.codepoint))\n-          return false;\n-}\n@@ -663,1 +570,1 @@\n-        buffer->add_info (info);\n+        buffer->add_info_and_pos (info, pos);\n@@ -666,1 +573,0 @@\n-        buffer->pos[buffer->len - 1] = pos;\n@@ -670,1 +576,1 @@\n-#line 671 \"hb-buffer-deserialize-text-glyphs.hh\"\n+#line 542 \"hb-buffer-deserialize-text-glyphs.hh\"\n@@ -677,2 +583,1 @@\n-#line 136 \"hb-buffer-deserialize-text-glyphs.rl\"\n-\n+#line 122 \"hb-buffer-deserialize-text-glyphs.rl\"\n@@ -680,6 +585,0 @@\n-  if (pe < orig_pe && *pe == ']')\n-  {\n-    pe++;\n-    if (p == pe)\n-      p++;\n-  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text-glyphs.hh","additions":371,"deletions":472,"binary":false,"changes":843,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-        0u, 0u, 9u, 117u, 43u, 102u, 48u, 102u, 48u, 57u, 9u, 124u, 9u, 124u, 9u, 124u,\n-        9u, 124u, 0\n+        0u, 0u, 43u, 102u, 48u, 102u, 48u, 124u, 48u, 57u, 62u, 124u, 48u, 124u, 60u, 117u,\n+        85u, 117u, 85u, 117u, 0\n@@ -42,2 +42,2 @@\n-        0, 109, 60, 55, 10, 116, 116, 116,\n-        116\n+        0, 60, 55, 77, 10, 63, 77, 58,\n+        33, 33\n@@ -47,2 +47,2 @@\n-        0, 0, 110, 171, 227, 238, 355, 472,\n-        589\n+        0, 0, 61, 117, 195, 206, 270, 348,\n+        407, 441\n@@ -52,1 +52,4 @@\n-        0, 0, 0, 0, 0, 1, 1,\n+        0, 1, 1, 1, 1, 2, 2,\n+        2, 2, 2, 2, 2, 2, 2, 2,\n+        1, 1, 1, 1, 1, 1, 1, 2,\n+        2, 2, 2, 2, 2, 1, 1, 1,\n@@ -55,1 +58,5 @@\n-        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 2,\n+        2, 2, 2, 2, 2, 1, 2, 2,\n+        2, 2, 2, 2, 2, 2, 2, 2,\n+        1, 1, 1, 1, 1, 1, 1, 2,\n+        2, 2, 2, 2, 2, 1, 1, 1,\n@@ -58,0 +65,5 @@\n+        1, 1, 1, 1, 1, 1, 1, 2,\n+        2, 2, 2, 2, 2, 1, 3, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        1, 1, 1, 4, 5, 1, 1, 3,\n+        3, 3, 3, 3, 3, 1, 1, 1,\n@@ -60,0 +72,2 @@\n+        1, 1, 1, 1, 1, 1, 1, 3,\n+        3, 3, 3, 3, 3, 1, 1, 1,\n@@ -61,1 +75,0 @@\n-        1, 1, 1, 1, 1, 2, 1, 1,\n@@ -63,0 +76,2 @@\n+        1, 1, 5, 1, 6, 7, 7, 7,\n+        7, 7, 7, 7, 7, 7, 1, 8,\n@@ -65,5 +80,0 @@\n-        1, 1, 1, 1, 1, 2, 1, 3,\n-        1, 1, 1, 1, 4, 4, 4, 4,\n-        4, 4, 4, 4, 4, 4, 1, 1,\n-        1, 1, 1, 1, 1, 4, 4, 4,\n-        4, 4, 4, 1, 1, 1, 1, 1,\n@@ -72,5 +82,0 @@\n-        1, 1, 1, 1, 1, 4, 4, 4,\n-        4, 4, 4, 1, 4, 4, 4, 4,\n-        4, 4, 4, 4, 4, 4, 1, 1,\n-        1, 1, 1, 1, 1, 4, 4, 4,\n-        4, 4, 4, 1, 1, 1, 1, 1,\n@@ -79,4 +84,0 @@\n-        1, 1, 1, 1, 1, 4, 4, 4,\n-        4, 4, 4, 1, 5, 6, 6, 6,\n-        6, 6, 6, 6, 6, 6, 1, 7,\n-        7, 7, 7, 7, 1, 1, 1, 1,\n@@ -84,1 +85,3 @@\n-        1, 1, 1, 1, 1, 1, 7, 1,\n+        1, 1, 1, 1, 1, 8, 1, 9,\n+        9, 9, 9, 9, 9, 9, 9, 9,\n+        9, 1, 1, 1, 1, 8, 1, 1,\n@@ -86,4 +89,0 @@\n-        1, 1, 1, 1, 1, 1, 8, 8,\n-        8, 8, 8, 8, 8, 8, 8, 8,\n-        1, 1, 1, 9, 1, 1, 1, 8,\n-        8, 8, 8, 8, 8, 1, 1, 1,\n@@ -92,24 +91,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 8,\n-        8, 8, 8, 8, 8, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 10, 1, 11, 11, 11, 11,\n-        11, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 11, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 0,\n-        1, 12, 12, 12, 12, 12, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        12, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n@@ -120,0 +95,1 @@\n+        1, 1, 1, 8, 1, 10, 1, 1,\n@@ -122,0 +98,1 @@\n+        1, 1, 1, 1, 1, 1, 11, 1,\n@@ -125,9 +102,2 @@\n-        1, 1, 1, 1, 13, 1, 12, 12,\n-        12, 12, 12, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 12, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 14, 14, 14,\n-        14, 14, 14, 14, 14, 14, 14, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 11, 1,\n+        11, 1, 1, 1, 1, 1, 1, 1,\n@@ -137,0 +107,1 @@\n+        11, 1, 12, 1, 1, 1, 1, 1,\n@@ -140,1 +111,1 @@\n-        1, 13, 1, 0\n+        1, 1, 12, 1, 0\n@@ -144,2 +115,2 @@\n-        1, 0, 2, 3, 5, 7, 8, 6,\n-        5, 4, 1, 6, 6, 1, 8\n+        2, 0, 3, 3, 4, 9, 5, 6,\n+        9, 6, 8, 1, 1\n@@ -149,2 +120,2 @@\n-        0, 0, 1, 0, 2, 2, 2, 3,\n-        0, 4, 3, 0, 5, 5, 0\n+        0, 0, 1, 0, 2, 2, 1, 1,\n+        3, 0, 0, 4, 6\n@@ -154,2 +125,2 @@\n-        0, 0, 0, 0, 0, 3, 0, 5,\n-        5\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 5\n@@ -158,2 +129,2 @@\n-static const int deserialize_text_unicode_start = 1;\n-static const int deserialize_text_unicode_first_final = 5;\n+static const int deserialize_text_unicode_start = 7;\n+static const int deserialize_text_unicode_first_final = 7;\n@@ -162,1 +133,1 @@\n-static const int deserialize_text_unicode_en_main = 1;\n+static const int deserialize_text_unicode_en_main = 7;\n@@ -165,1 +136,1 @@\n-#line 79 \"hb-buffer-deserialize-text-unicode.rl\"\n+#line 80 \"hb-buffer-deserialize-text-unicode.rl\"\n@@ -175,19 +146,1 @@\n-  const char *p = buf, *pe = buf + buf_len, *eof = pe, *orig_pe = pe;\n-\n-  while (p < pe && ISSPACE (*p))\n-    p++;\n-  if (p < pe && *p == (buffer->len ? '|' : '<'))\n-    *end_ptr = ++p;\n-\n-  const char *end = strchr ((char *) p, '>');\n-  if (end)\n-    pe = eof = end;\n-  else\n-  {\n-    end = strrchr ((char *) p, '|');\n-    if (end)\n-      pe = eof = end;\n-    else\n-      pe = eof = p;\n-  }\n-\n+  const char *p = buf, *pe = buf + buf_len, *eof = pe;\n@@ -200,1 +153,1 @@\n-#line 201 \"hb-buffer-deserialize-text-unicode.hh\"\n+#line 154 \"hb-buffer-deserialize-text-unicode.hh\"\n@@ -205,1 +158,1 @@\n-#line 206 \"hb-buffer-deserialize-text-unicode.hh\"\n+#line 159 \"hb-buffer-deserialize-text-unicode.hh\"\n@@ -230,1 +183,1 @@\n-        case 1:\n+        case 4:\n@@ -236,1 +189,1 @@\n-        case 2:\n+        case 1:\n@@ -242,1 +195,1 @@\n-        case 4:\n+        case 2:\n@@ -247,13 +200,0 @@\n-#line 55 \"hb-buffer-deserialize-text-unicode.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        if (buffer->have_positions)\n-          buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n-        case 5:\n@@ -262,0 +202,2 @@\n+        break;\n+        case 6:\n@@ -270,0 +212,4 @@\n+}\n+#line 38 \"hb-buffer-deserialize-text-unicode.rl\"\n+        {\n+        hb_memset (&info, 0, sizeof (info));\n@@ -272,1 +218,1 @@\n-#line 273 \"hb-buffer-deserialize-text-unicode.hh\"\n+#line 219 \"hb-buffer-deserialize-text-unicode.hh\"\n@@ -284,13 +230,0 @@\n-        case 3:\n-#line 55 \"hb-buffer-deserialize-text-unicode.rl\"\n-        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-#line 42 \"hb-buffer-deserialize-text-unicode.rl\"\n-        {\n-        buffer->add_info (info);\n-        if (unlikely (!buffer->successful))\n-          return false;\n-        if (buffer->have_positions)\n-          buffer->pos[buffer->len - 1] = pos;\n-        *end_ptr = p;\n-}\n-        break;\n@@ -298,2 +231,0 @@\n-#line 57 \"hb-buffer-deserialize-text-unicode.rl\"\n-        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n@@ -310,1 +241,1 @@\n-#line 311 \"hb-buffer-deserialize-text-unicode.hh\"\n+#line 242 \"hb-buffer-deserialize-text-unicode.hh\"\n@@ -317,2 +248,1 @@\n-#line 115 \"hb-buffer-deserialize-text-unicode.rl\"\n-\n+#line 98 \"hb-buffer-deserialize-text-unicode.rl\"\n@@ -320,6 +250,0 @@\n-  if (pe < orig_pe && *pe == '>')\n-  {\n-    pe++;\n-    if (p == pe)\n-      p++;\n-  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text-unicode.hh","additions":58,"deletions":134,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -172,5 +172,7 @@\n-      hb_font_get_glyph_extents(font, info[i].codepoint, &extents);\n-      p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"xb\\\":%d,\\\"yb\\\":%d\",\n-                                extents.x_bearing, extents.y_bearing));\n-      p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"w\\\":%d,\\\"h\\\":%d\",\n-                                extents.width, extents.height));\n+      if (hb_font_get_glyph_extents(font, info[i].codepoint, &extents))\n+      {\n+        p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"xb\\\":%d,\\\"yb\\\":%d\",\n+                                  extents.x_bearing, extents.y_bearing));\n+        p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"w\\\":%d,\\\"h\\\":%d\",\n+                                  extents.width, extents.height));\n+      }\n@@ -321,2 +323,2 @@\n-      hb_font_get_glyph_extents(font, info[i].codepoint, &extents);\n-      p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"<%d,%d,%d,%d>\", extents.x_bearing, extents.y_bearing, extents.width, extents.height));\n+      if (hb_font_get_glyph_extents(font, info[i].codepoint, &extents))\n+        p += hb_max (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"<%d,%d,%d,%d>\", extents.x_bearing, extents.y_bearing, extents.width, extents.height));\n@@ -740,2 +742,1 @@\n- * Return value: `true` if parse was successful, `false` if an error\n- * occurred.\n+ * Return value: `true` if the full string was parsed, `false` otherwise.\n@@ -813,2 +814,1 @@\n- * Return value: `true` if parse was successful, `false` if an error\n- * occurred.\n+ * Return value: `true` if the full string was parsed, `false` otherwise.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-serialize.cc","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -66,3 +66,1 @@\n-  \/* Check that clusters are monotone. *\/\n-  if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES ||\n-      buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  if (!HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE (buffer->cluster_level))\n@@ -70,1 +68,3 @@\n-    bool is_forward = HB_DIRECTION_IS_FORWARD (hb_buffer_get_direction (buffer));\n+    \/* Cannot perform this check without monotone clusters. *\/\n+    return true;\n+  }\n@@ -72,2 +72,1 @@\n-    unsigned int num_glyphs;\n-    hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, &num_glyphs);\n+  bool is_forward = HB_DIRECTION_IS_FORWARD (hb_buffer_get_direction (buffer));\n@@ -75,8 +74,10 @@\n-    for (unsigned int i = 1; i < num_glyphs; i++)\n-      if (info[i-1].cluster != info[i].cluster &&\n-          (info[i-1].cluster < info[i].cluster) != is_forward)\n-      {\n-        buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"clusters are not monotone.\");\n-        return false;\n-      }\n-  }\n+  unsigned int num_glyphs;\n+  hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, &num_glyphs);\n+\n+  for (unsigned int i = 1; i < num_glyphs; i++)\n+    if (info[i-1].cluster != info[i].cluster &&\n+        (info[i-1].cluster < info[i].cluster) != is_forward)\n+    {\n+      buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"clusters are not monotone.\");\n+      return false;\n+    }\n@@ -95,2 +96,1 @@\n-  if (buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES &&\n-      buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  if (!HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE (buffer->cluster_level))\n@@ -210,2 +210,1 @@\n-  if (buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES &&\n-      buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  if (!HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE (buffer->cluster_level))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-verify.cc","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -373,0 +373,12 @@\n+void\n+hb_buffer_t::add_info_and_pos (const hb_glyph_info_t &glyph_info,\n+                               const hb_glyph_position_t &glyph_pos)\n+{\n+  if (unlikely (!ensure (len + 1))) return;\n+\n+  info[len] = glyph_info;\n+  assert (have_positions);\n+  pos[len] = glyph_pos;\n+\n+  len++;\n+}\n@@ -521,1 +533,1 @@\n-  if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)\n+  if (!HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE (cluster_level))\n@@ -554,1 +566,1 @@\n-  if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)\n+  if (!HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE (cluster_level))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.cc","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -425,0 +425,1 @@\n+ * @HB_BUFFER_CLUSTER_LEVEL_GRAPHEMES: Only group clusters, but don't enforce monotone order.\n@@ -432,0 +433,1 @@\n+ * There is also cluster merging every time the clusters will otherwise become non-monotone.\n@@ -436,1 +438,15 @@\n- * sequences of adjacent marks.\n+ * sequences of adjacent marks. The output is still monotone, but the cluster\n+ * values are more granular.\n+ *\n+ * In @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS, non-base characters are assigned their\n+ * own cluster values, which are not merged into preceding base clusters. Moreover,\n+ * the cluster values are not merged into monotone order. This is the most granular\n+ * cluster level, and it is useful for clients that need to know the exact cluster\n+ * values of each character, but is harder to use for clients, since clusters\n+ * might appear in any order.\n+ *\n+ * In @HB_BUFFER_CLUSTER_LEVEL_GRAPHEMES, non-base characters are merged into the\n+ * cluster of the base character that precedes them. This is similar to the Unicode\n+ * Grapheme Cluster algorithm, but it is not exactly the same. The output is\n+ * not forced to be monotone. This is useful for clients that want to use HarfBuzz\n+ * as a cheap implementation of the Unicode Grapheme Cluster algorithm.\n@@ -449,0 +465,1 @@\n+  HB_BUFFER_CLUSTER_LEVEL_GRAPHEMES             = 3,\n@@ -452,0 +469,42 @@\n+\/**\n+ * HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE:\n+ * @level: #hb_buffer_cluster_level_t to test\n+ *\n+ * Tests whether a cluster level groups cluster values into monotone order.\n+ * Requires that the level be valid.\n+ *\n+ * Since: 11.0.0\n+ *\/\n+#define HB_BUFFER_CLUSTER_LEVEL_IS_MONOTONE(level) \\\n+        ((bool) ((1u << (unsigned) (level)) & \\\n+                 ((1u << HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES) | \\\n+                  (1u << HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS))))\n+\n+\/**\n+ * HB_BUFFER_CLUSTER_LEVEL_IS_GRAPHEMES:\n+ * @level: #hb_buffer_cluster_level_t to test\n+ *\n+ * Tests whether a cluster level groups cluster values by graphemes. Requires\n+ * that the level be valid.\n+ *\n+ * Since: 11.0.0\n+ *\/\n+#define HB_BUFFER_CLUSTER_LEVEL_IS_GRAPHEMES(level) \\\n+        ((bool) ((1u << (unsigned) (level)) & \\\n+                 ((1u << HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES) | \\\n+                  (1u << HB_BUFFER_CLUSTER_LEVEL_GRAPHEMES))))\n+\n+\/**\n+ * HB_BUFFER_CLUSTER_LEVEL_IS_CHARACTERS\n+ * @level: #hb_buffer_cluster_level_t to test\n+ *\n+ * Tests whether a cluster level does not group cluster values by graphemes.\n+ * Requires that the level be valid.\n+ *\n+ * Since: 11.0.0\n+ *\/\n+#define HB_BUFFER_CLUSTER_LEVEL_IS_CHARACTERS(level) \\\n+        ((bool) ((1u << (unsigned) (level)) & \\\n+                 ((1u << HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARCATERS) | \\\n+                  (1u << HB_BUFFER_CLUSTER_LEVEL_CHARACTERS))))\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.h","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -232,0 +232,2 @@\n+  HB_INTERNAL void add_info_and_pos (const hb_glyph_info_t &glyph_info,\n+                                     const hb_glyph_position_t &glyph_pos);\n@@ -413,0 +415,3 @@\n+    if (unlikely (end - start > 255))\n+      return;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.hh","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-\/* Implements a lockfree cache for int->int functions.\n+\/* Implements a lockfree and thread-safe cache for int->int functions,\n+ * using (optionally) _relaxed_ atomic integer operations.\n@@ -35,2 +36,2 @@\n- * The cache is a fixed-size array of 16-bit or 32-bit integers.\n- * The key is split into two parts: the cache index and the rest.\n+ * The cache is a fixed-size array of 16-bit or 32-bit integers,\n+ * typically 256 elements.\n@@ -38,2 +39,6 @@\n- * The cache index is used to index into the array.  The rest is used\n- * to store the key and the value.\n+ * The key is split into two parts: the cache index (high bits)\n+ * and the rest (low bits).\n+ *\n+ * The cache index is used to index into the array.  The array\n+ * member is a 16-bit or 32-bit integer that is used *both*\n+ * to store the low bits of the key, and the value.\n@@ -42,3 +47,11 @@\n- * The key is stored in the most significant bits of the integer.\n- * The key is shifted by cache_bits to the left to make room for the\n- * value.\n+ * The low bits of the key are stored in the most significant bits\n+ * of the integer.\n+ *\n+ * A cache hit is detected by comparing the low bits of the key\n+ * with the high bits of the integer at the array position indexed\n+ * by the high bits of the key. If they match, the value is extracted\n+ * from the least significant bits of the integer and returned.\n+ * Otherwise, a cache miss is reported.\n+ *\n+ * Cache operations (storage and retrieval) involve just a few\n+ * arithmetic operations and a single memory access.\n@@ -55,2 +68,2 @@\n-                                                                     hb_atomic_short_t,\n-                                                                     hb_atomic_int_t>::type,\n+                                                                     hb_atomic_t<unsigned short>,\n+                                                                     hb_atomic_t<unsigned int>>::type,\n@@ -58,2 +71,2 @@\n-                                                                     short,\n-                                                                     int>::type\n+                                                                     unsigned short,\n+                                                                     unsigned int>::type\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cache.hh","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-    : SUPER (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs)\n+    : SUPER (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs),\n+      cached_scalars_vector (&acc.cached_scalars_vector)\n@@ -83,1 +84,1 @@\n-  void fini ()\n+  ~cff2_cs_interp_env_t ()\n@@ -85,1 +86,31 @@\n-    SUPER::fini ();\n+    release_scalars_vector (scalars);\n+  }\n+\n+  hb_vector_t<float> *acquire_scalars_vector () const\n+  {\n+    hb_vector_t<float> *scalars = cached_scalars_vector->get_acquire ();\n+\n+    if (!scalars || !cached_scalars_vector->cmpexch (scalars, nullptr))\n+    {\n+      scalars = (hb_vector_t<float> *) hb_calloc (1, sizeof (hb_vector_t<float>));\n+      if (unlikely (!scalars))\n+        return nullptr;\n+      scalars->init ();\n+    }\n+\n+    return scalars;\n+  }\n+\n+  void release_scalars_vector (hb_vector_t<float> *scalars) const\n+  {\n+    if (!scalars)\n+      return;\n+\n+    scalars->clear ();\n+\n+    if (!cached_scalars_vector->cmpexch (nullptr, scalars))\n+    {\n+      scalars->fini ();\n+      hb_free (scalars);\n+    }\n+    scalars = nullptr;\n@@ -114,2 +145,4 @@\n-      region_count = varStore->varStore.get_region_index_count (get_ivs ());\n-      if (do_blend)\n+      scalars = acquire_scalars_vector ();\n+      if (unlikely (!scalars))\n+        SUPER::set_error ();\n+      else\n@@ -117,5 +150,9 @@\n-        if (unlikely (!scalars.resize_exact (region_count)))\n-          SUPER::set_error ();\n-        else\n-          varStore->varStore.get_region_scalars (get_ivs (), coords, num_coords,\n-                                                 &scalars[0], region_count);\n+        region_count = varStore->varStore.get_region_index_count (get_ivs ());\n+        if (do_blend)\n+        {\n+          if (unlikely (!scalars->resize_exact (region_count)))\n+            SUPER::set_error ();\n+          else\n+            varStore->varStore.get_region_scalars (get_ivs (), coords, num_coords,\n+                                                   &(*scalars)[0], region_count);\n+        }\n@@ -152,1 +189,1 @@\n-      if (likely (scalars.length == deltas.length))\n+      if (likely (scalars && scalars->length == deltas.length))\n@@ -154,1 +191,1 @@\n-        unsigned count = scalars.length;\n+        unsigned count = scalars->length;\n@@ -156,1 +193,1 @@\n-          v += (double) scalars.arrayZ[i] * deltas.arrayZ[i].to_real ();\n+          v += (double) scalars->arrayZ[i] * deltas.arrayZ[i].to_real ();\n@@ -170,1 +207,2 @@\n-  hb_vector_t<float>  scalars;\n+  hb_vector_t<float>  *scalars = nullptr;\n+  hb_atomic_t<hb_vector_t<float> *> *cached_scalars_vector = nullptr;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff2-interp-cs.hh","additions":52,"deletions":14,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-hb_atomic_int_t _hb_options;\n+hb_atomic_t<unsigned> _hb_options;\n@@ -276,1 +276,1 @@\n-static hb_atomic_ptr_t <hb_language_item_t> langs;\n+static hb_atomic_t<hb_language_item_t *> langs;\n@@ -406,1 +406,1 @@\n-  static hb_atomic_ptr_t <hb_language_t> default_language;\n+  static hb_atomic_t<hb_language_t> default_language;\n@@ -971,0 +971,3 @@\n+ * Note that the feature value will be omitted if it is '1', but the\n+ * string won't include any whitespace.\n+ *\n@@ -1124,0 +1127,2 @@\n+ * Note that the string won't include any whitespace.\n+ *\n@@ -1215,0 +1220,52 @@\n+\/**\n+ * hb_malloc:\n+ * @size: The size of the memory to allocate.\n+ *\n+ * Allocates @size bytes of memory, using the allocator set at\n+ * compile-time. Typically just malloc().\n+ *\n+ * Return value: A pointer to the allocated memory.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+void* hb_malloc(size_t size) { return hb_malloc_impl (size); }\n+\n+\/**\n+ * hb_calloc:\n+ * @nmemb: The number of elements to allocate.\n+ * @size: The size of each element.\n+ *\n+ * Allocates @nmemb elements of @size bytes each, initialized to zero,\n+ * using the allocator set at compile-time. Typically just calloc().\n+ *\n+ * Return value: A pointer to the allocated memory.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+void* hb_calloc(size_t nmemb, size_t size) { return hb_calloc_impl (nmemb, size); }\n+\n+\/**\n+ * hb_realloc:\n+ * @ptr: The pointer to the memory to reallocate.\n+ * @size: The new size of the memory.\n+ *\n+ * Reallocates the memory pointed to by @ptr to @size bytes, using the\n+ * allocator set at compile-time. Typically just realloc().\n+ *\n+ * Return value: A pointer to the reallocated memory.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+void* hb_realloc(void *ptr, size_t size) { return hb_realloc_impl (ptr, size); }\n+\n+\/**\n+ * hb_free:\n+ * @ptr: The pointer to the memory to free.\n+ *\n+ * Frees the memory pointed to by @ptr, using the allocator set at\n+ * compile-time. Typically just free().\n+ *\n+ * Since: 11.0.0\n+ **\/\n+void  hb_free(void *ptr) { hb_free_impl (ptr); }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.cc","additions":60,"deletions":3,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include <stddef.h>\n@@ -340,431 +341,1 @@\n-\/**\n- * hb_script_t:\n- * @HB_SCRIPT_COMMON: `Zyyy`\n- * @HB_SCRIPT_INHERITED: `Zinh`\n- * @HB_SCRIPT_UNKNOWN: `Zzzz`\n- * @HB_SCRIPT_ARABIC: `Arab`\n- * @HB_SCRIPT_ARMENIAN: `Armn`\n- * @HB_SCRIPT_BENGALI: `Beng`\n- * @HB_SCRIPT_CYRILLIC: `Cyrl`\n- * @HB_SCRIPT_DEVANAGARI: `Deva`\n- * @HB_SCRIPT_GEORGIAN: `Geor`\n- * @HB_SCRIPT_GREEK: `Grek`\n- * @HB_SCRIPT_GUJARATI: `Gujr`\n- * @HB_SCRIPT_GURMUKHI: `Guru`\n- * @HB_SCRIPT_HANGUL: `Hang`\n- * @HB_SCRIPT_HAN: `Hani`\n- * @HB_SCRIPT_HEBREW: `Hebr`\n- * @HB_SCRIPT_HIRAGANA: `Hira`\n- * @HB_SCRIPT_KANNADA: `Knda`\n- * @HB_SCRIPT_KATAKANA: `Kana`\n- * @HB_SCRIPT_LAO: `Laoo`\n- * @HB_SCRIPT_LATIN: `Latn`\n- * @HB_SCRIPT_MALAYALAM: `Mlym`\n- * @HB_SCRIPT_ORIYA: `Orya`\n- * @HB_SCRIPT_TAMIL: `Taml`\n- * @HB_SCRIPT_TELUGU: `Telu`\n- * @HB_SCRIPT_THAI: `Thai`\n- * @HB_SCRIPT_TIBETAN: `Tibt`\n- * @HB_SCRIPT_BOPOMOFO: `Bopo`\n- * @HB_SCRIPT_BRAILLE: `Brai`\n- * @HB_SCRIPT_CANADIAN_SYLLABICS: `Cans`\n- * @HB_SCRIPT_CHEROKEE: `Cher`\n- * @HB_SCRIPT_ETHIOPIC: `Ethi`\n- * @HB_SCRIPT_KHMER: `Khmr`\n- * @HB_SCRIPT_MONGOLIAN: `Mong`\n- * @HB_SCRIPT_MYANMAR: `Mymr`\n- * @HB_SCRIPT_OGHAM: `Ogam`\n- * @HB_SCRIPT_RUNIC: `Runr`\n- * @HB_SCRIPT_SINHALA: `Sinh`\n- * @HB_SCRIPT_SYRIAC: `Syrc`\n- * @HB_SCRIPT_THAANA: `Thaa`\n- * @HB_SCRIPT_YI: `Yiii`\n- * @HB_SCRIPT_DESERET: `Dsrt`\n- * @HB_SCRIPT_GOTHIC: `Goth`\n- * @HB_SCRIPT_OLD_ITALIC: `Ital`\n- * @HB_SCRIPT_BUHID: `Buhd`\n- * @HB_SCRIPT_HANUNOO: `Hano`\n- * @HB_SCRIPT_TAGALOG: `Tglg`\n- * @HB_SCRIPT_TAGBANWA: `Tagb`\n- * @HB_SCRIPT_CYPRIOT: `Cprt`\n- * @HB_SCRIPT_LIMBU: `Limb`\n- * @HB_SCRIPT_LINEAR_B: `Linb`\n- * @HB_SCRIPT_OSMANYA: `Osma`\n- * @HB_SCRIPT_SHAVIAN: `Shaw`\n- * @HB_SCRIPT_TAI_LE: `Tale`\n- * @HB_SCRIPT_UGARITIC: `Ugar`\n- * @HB_SCRIPT_BUGINESE: `Bugi`\n- * @HB_SCRIPT_COPTIC: `Copt`\n- * @HB_SCRIPT_GLAGOLITIC: `Glag`\n- * @HB_SCRIPT_KHAROSHTHI: `Khar`\n- * @HB_SCRIPT_NEW_TAI_LUE: `Talu`\n- * @HB_SCRIPT_OLD_PERSIAN: `Xpeo`\n- * @HB_SCRIPT_SYLOTI_NAGRI: `Sylo`\n- * @HB_SCRIPT_TIFINAGH: `Tfng`\n- * @HB_SCRIPT_BALINESE: `Bali`\n- * @HB_SCRIPT_CUNEIFORM: `Xsux`\n- * @HB_SCRIPT_NKO: `Nkoo`\n- * @HB_SCRIPT_PHAGS_PA: `Phag`\n- * @HB_SCRIPT_PHOENICIAN: `Phnx`\n- * @HB_SCRIPT_CARIAN: `Cari`\n- * @HB_SCRIPT_CHAM: `Cham`\n- * @HB_SCRIPT_KAYAH_LI: `Kali`\n- * @HB_SCRIPT_LEPCHA: `Lepc`\n- * @HB_SCRIPT_LYCIAN: `Lyci`\n- * @HB_SCRIPT_LYDIAN: `Lydi`\n- * @HB_SCRIPT_OL_CHIKI: `Olck`\n- * @HB_SCRIPT_REJANG: `Rjng`\n- * @HB_SCRIPT_SAURASHTRA: `Saur`\n- * @HB_SCRIPT_SUNDANESE: `Sund`\n- * @HB_SCRIPT_VAI: `Vaii`\n- * @HB_SCRIPT_AVESTAN: `Avst`\n- * @HB_SCRIPT_BAMUM: `Bamu`\n- * @HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: `Egyp`\n- * @HB_SCRIPT_IMPERIAL_ARAMAIC: `Armi`\n- * @HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: `Phli`\n- * @HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: `Prti`\n- * @HB_SCRIPT_JAVANESE: `Java`\n- * @HB_SCRIPT_KAITHI: `Kthi`\n- * @HB_SCRIPT_LISU: `Lisu`\n- * @HB_SCRIPT_MEETEI_MAYEK: `Mtei`\n- * @HB_SCRIPT_OLD_SOUTH_ARABIAN: `Sarb`\n- * @HB_SCRIPT_OLD_TURKIC: `Orkh`\n- * @HB_SCRIPT_SAMARITAN: `Samr`\n- * @HB_SCRIPT_TAI_THAM: `Lana`\n- * @HB_SCRIPT_TAI_VIET: `Tavt`\n- * @HB_SCRIPT_BATAK: `Batk`\n- * @HB_SCRIPT_BRAHMI: `Brah`\n- * @HB_SCRIPT_MANDAIC: `Mand`\n- * @HB_SCRIPT_CHAKMA: `Cakm`\n- * @HB_SCRIPT_MEROITIC_CURSIVE: `Merc`\n- * @HB_SCRIPT_MEROITIC_HIEROGLYPHS: `Mero`\n- * @HB_SCRIPT_MIAO: `Plrd`\n- * @HB_SCRIPT_SHARADA: `Shrd`\n- * @HB_SCRIPT_SORA_SOMPENG: `Sora`\n- * @HB_SCRIPT_TAKRI: `Takr`\n- * @HB_SCRIPT_BASSA_VAH: `Bass`, Since: 0.9.30\n- * @HB_SCRIPT_CAUCASIAN_ALBANIAN: `Aghb`, Since: 0.9.30\n- * @HB_SCRIPT_DUPLOYAN: `Dupl`, Since: 0.9.30\n- * @HB_SCRIPT_ELBASAN: `Elba`, Since: 0.9.30\n- * @HB_SCRIPT_GRANTHA: `Gran`, Since: 0.9.30\n- * @HB_SCRIPT_KHOJKI: `Khoj`, Since: 0.9.30\n- * @HB_SCRIPT_KHUDAWADI: `Sind`, Since: 0.9.30\n- * @HB_SCRIPT_LINEAR_A: `Lina`, Since: 0.9.30\n- * @HB_SCRIPT_MAHAJANI: `Mahj`, Since: 0.9.30\n- * @HB_SCRIPT_MANICHAEAN: `Mani`, Since: 0.9.30\n- * @HB_SCRIPT_MENDE_KIKAKUI: `Mend`, Since: 0.9.30\n- * @HB_SCRIPT_MODI: `Modi`, Since: 0.9.30\n- * @HB_SCRIPT_MRO: `Mroo`, Since: 0.9.30\n- * @HB_SCRIPT_NABATAEAN: `Nbat`, Since: 0.9.30\n- * @HB_SCRIPT_OLD_NORTH_ARABIAN: `Narb`, Since: 0.9.30\n- * @HB_SCRIPT_OLD_PERMIC: `Perm`, Since: 0.9.30\n- * @HB_SCRIPT_PAHAWH_HMONG: `Hmng`, Since: 0.9.30\n- * @HB_SCRIPT_PALMYRENE: `Palm`, Since: 0.9.30\n- * @HB_SCRIPT_PAU_CIN_HAU: `Pauc`, Since: 0.9.30\n- * @HB_SCRIPT_PSALTER_PAHLAVI: `Phlp`, Since: 0.9.30\n- * @HB_SCRIPT_SIDDHAM: `Sidd`, Since: 0.9.30\n- * @HB_SCRIPT_TIRHUTA: `Tirh`, Since: 0.9.30\n- * @HB_SCRIPT_WARANG_CITI: `Wara`, Since: 0.9.30\n- * @HB_SCRIPT_AHOM: `Ahom`, Since: 0.9.30\n- * @HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: `Hluw`, Since: 0.9.30\n- * @HB_SCRIPT_HATRAN: `Hatr`, Since: 0.9.30\n- * @HB_SCRIPT_MULTANI: `Mult`, Since: 0.9.30\n- * @HB_SCRIPT_OLD_HUNGARIAN: `Hung`, Since: 0.9.30\n- * @HB_SCRIPT_SIGNWRITING: `Sgnw`, Since: 0.9.30\n- * @HB_SCRIPT_ADLAM: `Adlm`, Since: 1.3.0\n- * @HB_SCRIPT_BHAIKSUKI: `Bhks`, Since: 1.3.0\n- * @HB_SCRIPT_MARCHEN: `Marc`, Since: 1.3.0\n- * @HB_SCRIPT_OSAGE: `Osge`, Since: 1.3.0\n- * @HB_SCRIPT_TANGUT: `Tang`, Since: 1.3.0\n- * @HB_SCRIPT_NEWA: `Newa`, Since: 1.3.0\n- * @HB_SCRIPT_MASARAM_GONDI: `Gonm`, Since: 1.6.0\n- * @HB_SCRIPT_NUSHU: `Nshu`, Since: 1.6.0\n- * @HB_SCRIPT_SOYOMBO: `Soyo`, Since: 1.6.0\n- * @HB_SCRIPT_ZANABAZAR_SQUARE: `Zanb`, Since: 1.6.0\n- * @HB_SCRIPT_DOGRA: `Dogr`, Since: 1.8.0\n- * @HB_SCRIPT_GUNJALA_GONDI: `Gong`, Since: 1.8.0\n- * @HB_SCRIPT_HANIFI_ROHINGYA: `Rohg`, Since: 1.8.0\n- * @HB_SCRIPT_MAKASAR: `Maka`, Since: 1.8.0\n- * @HB_SCRIPT_MEDEFAIDRIN: `Medf`, Since: 1.8.0\n- * @HB_SCRIPT_OLD_SOGDIAN: `Sogo`, Since: 1.8.0\n- * @HB_SCRIPT_SOGDIAN: `Sogd`, Since: 1.8.0\n- * @HB_SCRIPT_ELYMAIC: `Elym`, Since: 2.4.0\n- * @HB_SCRIPT_NANDINAGARI: `Nand`, Since: 2.4.0\n- * @HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: `Hmnp`, Since: 2.4.0\n- * @HB_SCRIPT_WANCHO: `Wcho`, Since: 2.4.0\n- * @HB_SCRIPT_CHORASMIAN: `Chrs`, Since: 2.6.7\n- * @HB_SCRIPT_DIVES_AKURU: `Diak`, Since: 2.6.7\n- * @HB_SCRIPT_KHITAN_SMALL_SCRIPT: `Kits`, Since: 2.6.7\n- * @HB_SCRIPT_YEZIDI: `Yezi`, Since: 2.6.7\n- * @HB_SCRIPT_CYPRO_MINOAN: `Cpmn`, Since: 3.0.0\n- * @HB_SCRIPT_OLD_UYGHUR: `Ougr`, Since: 3.0.0\n- * @HB_SCRIPT_TANGSA: `Tnsa`, Since: 3.0.0\n- * @HB_SCRIPT_TOTO: `Toto`, Since: 3.0.0\n- * @HB_SCRIPT_VITHKUQI: `Vith`, Since: 3.0.0\n- * @HB_SCRIPT_MATH: `Zmth`, Since: 3.4.0\n- * @HB_SCRIPT_KAWI: `Kawi`, Since: 5.2.0\n- * @HB_SCRIPT_NAG_MUNDARI: `Nagm`, Since: 5.2.0\n- * @HB_SCRIPT_GARAY: `Gara`, Since: 10.0.0\n- * @HB_SCRIPT_GURUNG_KHEMA: `Gukh`, Since: 10.0.0\n- * @HB_SCRIPT_KIRAT_RAI: `Krai`, Since: 10.0.0\n- * @HB_SCRIPT_OL_ONAL: `Onao`, Since: 10.0.0\n- * @HB_SCRIPT_SUNUWAR: `Sunu`, Since: 10.0.0\n- * @HB_SCRIPT_TODHRI: `Todr`, Since: 10.0.0\n- * @HB_SCRIPT_TULU_TIGALARI: `Tutg`, Since: 10.0.0\n- * @HB_SCRIPT_INVALID: No script set\n- *\n- * Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding\n- * to the four-letter values defined by [ISO 15924](https:\/\/unicode.org\/iso15924\/).\n- *\n- * See also the Script (sc) property of the Unicode Character Database.\n- *\n- **\/\n-\n-\/* https:\/\/docs.google.com\/spreadsheets\/d\/1Y90M0Ie3MUJ6UVCRDOypOtijlMDLNNyyLk36T6iMu0o *\/\n-typedef enum\n-{\n-  HB_SCRIPT_COMMON                      = HB_TAG ('Z','y','y','y'), \/*1.1*\/\n-  HB_SCRIPT_INHERITED                   = HB_TAG ('Z','i','n','h'), \/*1.1*\/\n-  HB_SCRIPT_UNKNOWN                     = HB_TAG ('Z','z','z','z'), \/*5.0*\/\n-\n-  HB_SCRIPT_ARABIC                      = HB_TAG ('A','r','a','b'), \/*1.1*\/\n-  HB_SCRIPT_ARMENIAN                    = HB_TAG ('A','r','m','n'), \/*1.1*\/\n-  HB_SCRIPT_BENGALI                     = HB_TAG ('B','e','n','g'), \/*1.1*\/\n-  HB_SCRIPT_CYRILLIC                    = HB_TAG ('C','y','r','l'), \/*1.1*\/\n-  HB_SCRIPT_DEVANAGARI                  = HB_TAG ('D','e','v','a'), \/*1.1*\/\n-  HB_SCRIPT_GEORGIAN                    = HB_TAG ('G','e','o','r'), \/*1.1*\/\n-  HB_SCRIPT_GREEK                       = HB_TAG ('G','r','e','k'), \/*1.1*\/\n-  HB_SCRIPT_GUJARATI                    = HB_TAG ('G','u','j','r'), \/*1.1*\/\n-  HB_SCRIPT_GURMUKHI                    = HB_TAG ('G','u','r','u'), \/*1.1*\/\n-  HB_SCRIPT_HANGUL                      = HB_TAG ('H','a','n','g'), \/*1.1*\/\n-  HB_SCRIPT_HAN                         = HB_TAG ('H','a','n','i'), \/*1.1*\/\n-  HB_SCRIPT_HEBREW                      = HB_TAG ('H','e','b','r'), \/*1.1*\/\n-  HB_SCRIPT_HIRAGANA                    = HB_TAG ('H','i','r','a'), \/*1.1*\/\n-  HB_SCRIPT_KANNADA                     = HB_TAG ('K','n','d','a'), \/*1.1*\/\n-  HB_SCRIPT_KATAKANA                    = HB_TAG ('K','a','n','a'), \/*1.1*\/\n-  HB_SCRIPT_LAO                         = HB_TAG ('L','a','o','o'), \/*1.1*\/\n-  HB_SCRIPT_LATIN                       = HB_TAG ('L','a','t','n'), \/*1.1*\/\n-  HB_SCRIPT_MALAYALAM                   = HB_TAG ('M','l','y','m'), \/*1.1*\/\n-  HB_SCRIPT_ORIYA                       = HB_TAG ('O','r','y','a'), \/*1.1*\/\n-  HB_SCRIPT_TAMIL                       = HB_TAG ('T','a','m','l'), \/*1.1*\/\n-  HB_SCRIPT_TELUGU                      = HB_TAG ('T','e','l','u'), \/*1.1*\/\n-  HB_SCRIPT_THAI                        = HB_TAG ('T','h','a','i'), \/*1.1*\/\n-\n-  HB_SCRIPT_TIBETAN                     = HB_TAG ('T','i','b','t'), \/*2.0*\/\n-\n-  HB_SCRIPT_BOPOMOFO                    = HB_TAG ('B','o','p','o'), \/*3.0*\/\n-  HB_SCRIPT_BRAILLE                     = HB_TAG ('B','r','a','i'), \/*3.0*\/\n-  HB_SCRIPT_CANADIAN_SYLLABICS          = HB_TAG ('C','a','n','s'), \/*3.0*\/\n-  HB_SCRIPT_CHEROKEE                    = HB_TAG ('C','h','e','r'), \/*3.0*\/\n-  HB_SCRIPT_ETHIOPIC                    = HB_TAG ('E','t','h','i'), \/*3.0*\/\n-  HB_SCRIPT_KHMER                       = HB_TAG ('K','h','m','r'), \/*3.0*\/\n-  HB_SCRIPT_MONGOLIAN                   = HB_TAG ('M','o','n','g'), \/*3.0*\/\n-  HB_SCRIPT_MYANMAR                     = HB_TAG ('M','y','m','r'), \/*3.0*\/\n-  HB_SCRIPT_OGHAM                       = HB_TAG ('O','g','a','m'), \/*3.0*\/\n-  HB_SCRIPT_RUNIC                       = HB_TAG ('R','u','n','r'), \/*3.0*\/\n-  HB_SCRIPT_SINHALA                     = HB_TAG ('S','i','n','h'), \/*3.0*\/\n-  HB_SCRIPT_SYRIAC                      = HB_TAG ('S','y','r','c'), \/*3.0*\/\n-  HB_SCRIPT_THAANA                      = HB_TAG ('T','h','a','a'), \/*3.0*\/\n-  HB_SCRIPT_YI                          = HB_TAG ('Y','i','i','i'), \/*3.0*\/\n-\n-  HB_SCRIPT_DESERET                     = HB_TAG ('D','s','r','t'), \/*3.1*\/\n-  HB_SCRIPT_GOTHIC                      = HB_TAG ('G','o','t','h'), \/*3.1*\/\n-  HB_SCRIPT_OLD_ITALIC                  = HB_TAG ('I','t','a','l'), \/*3.1*\/\n-\n-  HB_SCRIPT_BUHID                       = HB_TAG ('B','u','h','d'), \/*3.2*\/\n-  HB_SCRIPT_HANUNOO                     = HB_TAG ('H','a','n','o'), \/*3.2*\/\n-  HB_SCRIPT_TAGALOG                     = HB_TAG ('T','g','l','g'), \/*3.2*\/\n-  HB_SCRIPT_TAGBANWA                    = HB_TAG ('T','a','g','b'), \/*3.2*\/\n-\n-  HB_SCRIPT_CYPRIOT                     = HB_TAG ('C','p','r','t'), \/*4.0*\/\n-  HB_SCRIPT_LIMBU                       = HB_TAG ('L','i','m','b'), \/*4.0*\/\n-  HB_SCRIPT_LINEAR_B                    = HB_TAG ('L','i','n','b'), \/*4.0*\/\n-  HB_SCRIPT_OSMANYA                     = HB_TAG ('O','s','m','a'), \/*4.0*\/\n-  HB_SCRIPT_SHAVIAN                     = HB_TAG ('S','h','a','w'), \/*4.0*\/\n-  HB_SCRIPT_TAI_LE                      = HB_TAG ('T','a','l','e'), \/*4.0*\/\n-  HB_SCRIPT_UGARITIC                    = HB_TAG ('U','g','a','r'), \/*4.0*\/\n-\n-  HB_SCRIPT_BUGINESE                    = HB_TAG ('B','u','g','i'), \/*4.1*\/\n-  HB_SCRIPT_COPTIC                      = HB_TAG ('C','o','p','t'), \/*4.1*\/\n-  HB_SCRIPT_GLAGOLITIC                  = HB_TAG ('G','l','a','g'), \/*4.1*\/\n-  HB_SCRIPT_KHAROSHTHI                  = HB_TAG ('K','h','a','r'), \/*4.1*\/\n-  HB_SCRIPT_NEW_TAI_LUE                 = HB_TAG ('T','a','l','u'), \/*4.1*\/\n-  HB_SCRIPT_OLD_PERSIAN                 = HB_TAG ('X','p','e','o'), \/*4.1*\/\n-  HB_SCRIPT_SYLOTI_NAGRI                = HB_TAG ('S','y','l','o'), \/*4.1*\/\n-  HB_SCRIPT_TIFINAGH                    = HB_TAG ('T','f','n','g'), \/*4.1*\/\n-\n-  HB_SCRIPT_BALINESE                    = HB_TAG ('B','a','l','i'), \/*5.0*\/\n-  HB_SCRIPT_CUNEIFORM                   = HB_TAG ('X','s','u','x'), \/*5.0*\/\n-  HB_SCRIPT_NKO                         = HB_TAG ('N','k','o','o'), \/*5.0*\/\n-  HB_SCRIPT_PHAGS_PA                    = HB_TAG ('P','h','a','g'), \/*5.0*\/\n-  HB_SCRIPT_PHOENICIAN                  = HB_TAG ('P','h','n','x'), \/*5.0*\/\n-\n-  HB_SCRIPT_CARIAN                      = HB_TAG ('C','a','r','i'), \/*5.1*\/\n-  HB_SCRIPT_CHAM                        = HB_TAG ('C','h','a','m'), \/*5.1*\/\n-  HB_SCRIPT_KAYAH_LI                    = HB_TAG ('K','a','l','i'), \/*5.1*\/\n-  HB_SCRIPT_LEPCHA                      = HB_TAG ('L','e','p','c'), \/*5.1*\/\n-  HB_SCRIPT_LYCIAN                      = HB_TAG ('L','y','c','i'), \/*5.1*\/\n-  HB_SCRIPT_LYDIAN                      = HB_TAG ('L','y','d','i'), \/*5.1*\/\n-  HB_SCRIPT_OL_CHIKI                    = HB_TAG ('O','l','c','k'), \/*5.1*\/\n-  HB_SCRIPT_REJANG                      = HB_TAG ('R','j','n','g'), \/*5.1*\/\n-  HB_SCRIPT_SAURASHTRA                  = HB_TAG ('S','a','u','r'), \/*5.1*\/\n-  HB_SCRIPT_SUNDANESE                   = HB_TAG ('S','u','n','d'), \/*5.1*\/\n-  HB_SCRIPT_VAI                         = HB_TAG ('V','a','i','i'), \/*5.1*\/\n-\n-  HB_SCRIPT_AVESTAN                     = HB_TAG ('A','v','s','t'), \/*5.2*\/\n-  HB_SCRIPT_BAMUM                       = HB_TAG ('B','a','m','u'), \/*5.2*\/\n-  HB_SCRIPT_EGYPTIAN_HIEROGLYPHS        = HB_TAG ('E','g','y','p'), \/*5.2*\/\n-  HB_SCRIPT_IMPERIAL_ARAMAIC            = HB_TAG ('A','r','m','i'), \/*5.2*\/\n-  HB_SCRIPT_INSCRIPTIONAL_PAHLAVI       = HB_TAG ('P','h','l','i'), \/*5.2*\/\n-  HB_SCRIPT_INSCRIPTIONAL_PARTHIAN      = HB_TAG ('P','r','t','i'), \/*5.2*\/\n-  HB_SCRIPT_JAVANESE                    = HB_TAG ('J','a','v','a'), \/*5.2*\/\n-  HB_SCRIPT_KAITHI                      = HB_TAG ('K','t','h','i'), \/*5.2*\/\n-  HB_SCRIPT_LISU                        = HB_TAG ('L','i','s','u'), \/*5.2*\/\n-  HB_SCRIPT_MEETEI_MAYEK                = HB_TAG ('M','t','e','i'), \/*5.2*\/\n-  HB_SCRIPT_OLD_SOUTH_ARABIAN           = HB_TAG ('S','a','r','b'), \/*5.2*\/\n-  HB_SCRIPT_OLD_TURKIC                  = HB_TAG ('O','r','k','h'), \/*5.2*\/\n-  HB_SCRIPT_SAMARITAN                   = HB_TAG ('S','a','m','r'), \/*5.2*\/\n-  HB_SCRIPT_TAI_THAM                    = HB_TAG ('L','a','n','a'), \/*5.2*\/\n-  HB_SCRIPT_TAI_VIET                    = HB_TAG ('T','a','v','t'), \/*5.2*\/\n-\n-  HB_SCRIPT_BATAK                       = HB_TAG ('B','a','t','k'), \/*6.0*\/\n-  HB_SCRIPT_BRAHMI                      = HB_TAG ('B','r','a','h'), \/*6.0*\/\n-  HB_SCRIPT_MANDAIC                     = HB_TAG ('M','a','n','d'), \/*6.0*\/\n-\n-  HB_SCRIPT_CHAKMA                      = HB_TAG ('C','a','k','m'), \/*6.1*\/\n-  HB_SCRIPT_MEROITIC_CURSIVE            = HB_TAG ('M','e','r','c'), \/*6.1*\/\n-  HB_SCRIPT_MEROITIC_HIEROGLYPHS        = HB_TAG ('M','e','r','o'), \/*6.1*\/\n-  HB_SCRIPT_MIAO                        = HB_TAG ('P','l','r','d'), \/*6.1*\/\n-  HB_SCRIPT_SHARADA                     = HB_TAG ('S','h','r','d'), \/*6.1*\/\n-  HB_SCRIPT_SORA_SOMPENG                = HB_TAG ('S','o','r','a'), \/*6.1*\/\n-  HB_SCRIPT_TAKRI                       = HB_TAG ('T','a','k','r'), \/*6.1*\/\n-\n-  \/*\n-   * Since: 0.9.30\n-   *\/\n-  HB_SCRIPT_BASSA_VAH                   = HB_TAG ('B','a','s','s'), \/*7.0*\/\n-  HB_SCRIPT_CAUCASIAN_ALBANIAN          = HB_TAG ('A','g','h','b'), \/*7.0*\/\n-  HB_SCRIPT_DUPLOYAN                    = HB_TAG ('D','u','p','l'), \/*7.0*\/\n-  HB_SCRIPT_ELBASAN                     = HB_TAG ('E','l','b','a'), \/*7.0*\/\n-  HB_SCRIPT_GRANTHA                     = HB_TAG ('G','r','a','n'), \/*7.0*\/\n-  HB_SCRIPT_KHOJKI                      = HB_TAG ('K','h','o','j'), \/*7.0*\/\n-  HB_SCRIPT_KHUDAWADI                   = HB_TAG ('S','i','n','d'), \/*7.0*\/\n-  HB_SCRIPT_LINEAR_A                    = HB_TAG ('L','i','n','a'), \/*7.0*\/\n-  HB_SCRIPT_MAHAJANI                    = HB_TAG ('M','a','h','j'), \/*7.0*\/\n-  HB_SCRIPT_MANICHAEAN                  = HB_TAG ('M','a','n','i'), \/*7.0*\/\n-  HB_SCRIPT_MENDE_KIKAKUI               = HB_TAG ('M','e','n','d'), \/*7.0*\/\n-  HB_SCRIPT_MODI                        = HB_TAG ('M','o','d','i'), \/*7.0*\/\n-  HB_SCRIPT_MRO                         = HB_TAG ('M','r','o','o'), \/*7.0*\/\n-  HB_SCRIPT_NABATAEAN                   = HB_TAG ('N','b','a','t'), \/*7.0*\/\n-  HB_SCRIPT_OLD_NORTH_ARABIAN           = HB_TAG ('N','a','r','b'), \/*7.0*\/\n-  HB_SCRIPT_OLD_PERMIC                  = HB_TAG ('P','e','r','m'), \/*7.0*\/\n-  HB_SCRIPT_PAHAWH_HMONG                = HB_TAG ('H','m','n','g'), \/*7.0*\/\n-  HB_SCRIPT_PALMYRENE                   = HB_TAG ('P','a','l','m'), \/*7.0*\/\n-  HB_SCRIPT_PAU_CIN_HAU                 = HB_TAG ('P','a','u','c'), \/*7.0*\/\n-  HB_SCRIPT_PSALTER_PAHLAVI             = HB_TAG ('P','h','l','p'), \/*7.0*\/\n-  HB_SCRIPT_SIDDHAM                     = HB_TAG ('S','i','d','d'), \/*7.0*\/\n-  HB_SCRIPT_TIRHUTA                     = HB_TAG ('T','i','r','h'), \/*7.0*\/\n-  HB_SCRIPT_WARANG_CITI                 = HB_TAG ('W','a','r','a'), \/*7.0*\/\n-\n-  HB_SCRIPT_AHOM                        = HB_TAG ('A','h','o','m'), \/*8.0*\/\n-  HB_SCRIPT_ANATOLIAN_HIEROGLYPHS       = HB_TAG ('H','l','u','w'), \/*8.0*\/\n-  HB_SCRIPT_HATRAN                      = HB_TAG ('H','a','t','r'), \/*8.0*\/\n-  HB_SCRIPT_MULTANI                     = HB_TAG ('M','u','l','t'), \/*8.0*\/\n-  HB_SCRIPT_OLD_HUNGARIAN               = HB_TAG ('H','u','n','g'), \/*8.0*\/\n-  HB_SCRIPT_SIGNWRITING                 = HB_TAG ('S','g','n','w'), \/*8.0*\/\n-\n-  \/*\n-   * Since 1.3.0\n-   *\/\n-  HB_SCRIPT_ADLAM                       = HB_TAG ('A','d','l','m'), \/*9.0*\/\n-  HB_SCRIPT_BHAIKSUKI                   = HB_TAG ('B','h','k','s'), \/*9.0*\/\n-  HB_SCRIPT_MARCHEN                     = HB_TAG ('M','a','r','c'), \/*9.0*\/\n-  HB_SCRIPT_OSAGE                       = HB_TAG ('O','s','g','e'), \/*9.0*\/\n-  HB_SCRIPT_TANGUT                      = HB_TAG ('T','a','n','g'), \/*9.0*\/\n-  HB_SCRIPT_NEWA                        = HB_TAG ('N','e','w','a'), \/*9.0*\/\n-\n-  \/*\n-   * Since 1.6.0\n-   *\/\n-  HB_SCRIPT_MASARAM_GONDI               = HB_TAG ('G','o','n','m'), \/*10.0*\/\n-  HB_SCRIPT_NUSHU                       = HB_TAG ('N','s','h','u'), \/*10.0*\/\n-  HB_SCRIPT_SOYOMBO                     = HB_TAG ('S','o','y','o'), \/*10.0*\/\n-  HB_SCRIPT_ZANABAZAR_SQUARE            = HB_TAG ('Z','a','n','b'), \/*10.0*\/\n-\n-  \/*\n-   * Since 1.8.0\n-   *\/\n-  HB_SCRIPT_DOGRA                       = HB_TAG ('D','o','g','r'), \/*11.0*\/\n-  HB_SCRIPT_GUNJALA_GONDI               = HB_TAG ('G','o','n','g'), \/*11.0*\/\n-  HB_SCRIPT_HANIFI_ROHINGYA             = HB_TAG ('R','o','h','g'), \/*11.0*\/\n-  HB_SCRIPT_MAKASAR                     = HB_TAG ('M','a','k','a'), \/*11.0*\/\n-  HB_SCRIPT_MEDEFAIDRIN                 = HB_TAG ('M','e','d','f'), \/*11.0*\/\n-  HB_SCRIPT_OLD_SOGDIAN                 = HB_TAG ('S','o','g','o'), \/*11.0*\/\n-  HB_SCRIPT_SOGDIAN                     = HB_TAG ('S','o','g','d'), \/*11.0*\/\n-\n-  \/*\n-   * Since 2.4.0\n-   *\/\n-  HB_SCRIPT_ELYMAIC                     = HB_TAG ('E','l','y','m'), \/*12.0*\/\n-  HB_SCRIPT_NANDINAGARI                 = HB_TAG ('N','a','n','d'), \/*12.0*\/\n-  HB_SCRIPT_NYIAKENG_PUACHUE_HMONG      = HB_TAG ('H','m','n','p'), \/*12.0*\/\n-  HB_SCRIPT_WANCHO                      = HB_TAG ('W','c','h','o'), \/*12.0*\/\n-\n-  \/*\n-   * Since 2.6.7\n-   *\/\n-  HB_SCRIPT_CHORASMIAN                  = HB_TAG ('C','h','r','s'), \/*13.0*\/\n-  HB_SCRIPT_DIVES_AKURU                 = HB_TAG ('D','i','a','k'), \/*13.0*\/\n-  HB_SCRIPT_KHITAN_SMALL_SCRIPT         = HB_TAG ('K','i','t','s'), \/*13.0*\/\n-  HB_SCRIPT_YEZIDI                      = HB_TAG ('Y','e','z','i'), \/*13.0*\/\n-\n-  \/*\n-   * Since 3.0.0\n-   *\/\n-  HB_SCRIPT_CYPRO_MINOAN                = HB_TAG ('C','p','m','n'), \/*14.0*\/\n-  HB_SCRIPT_OLD_UYGHUR                  = HB_TAG ('O','u','g','r'), \/*14.0*\/\n-  HB_SCRIPT_TANGSA                      = HB_TAG ('T','n','s','a'), \/*14.0*\/\n-  HB_SCRIPT_TOTO                        = HB_TAG ('T','o','t','o'), \/*14.0*\/\n-  HB_SCRIPT_VITHKUQI                    = HB_TAG ('V','i','t','h'), \/*14.0*\/\n-\n-  \/*\n-   * Since 3.4.0\n-   *\/\n-  HB_SCRIPT_MATH                        = HB_TAG ('Z','m','t','h'),\n-\n-  \/*\n-   * Since 5.2.0\n-   *\/\n-  HB_SCRIPT_KAWI                        = HB_TAG ('K','a','w','i'), \/*15.0*\/\n-  HB_SCRIPT_NAG_MUNDARI                 = HB_TAG ('N','a','g','m'), \/*15.0*\/\n-\n-  \/*\n-   * Since 10.0.0\n-   *\/\n-  HB_SCRIPT_GARAY                       = HB_TAG ('G','a','r','a'), \/*16.0*\/\n-  HB_SCRIPT_GURUNG_KHEMA                = HB_TAG ('G','u','k','h'), \/*16.0*\/\n-  HB_SCRIPT_KIRAT_RAI                   = HB_TAG ('K','r','a','i'), \/*16.0*\/\n-  HB_SCRIPT_OL_ONAL                     = HB_TAG ('O','n','a','o'), \/*16.0*\/\n-  HB_SCRIPT_SUNUWAR                     = HB_TAG ('S','u','n','u'), \/*16.0*\/\n-  HB_SCRIPT_TODHRI                      = HB_TAG ('T','o','d','r'), \/*16.0*\/\n-  HB_SCRIPT_TULU_TIGALARI               = HB_TAG ('T','u','t','g'), \/*16.0*\/\n-\n-  \/* No script set. *\/\n-  HB_SCRIPT_INVALID                     = HB_TAG_NONE,\n-\n-  \/*< private >*\/\n-\n-  \/* Dummy values to ensure any hb_tag_t value can be passed\/stored as hb_script_t\n-   * without risking undefined behavior.  We have two, for historical reasons.\n-   * HB_TAG_MAX used to be unsigned, but that was invalid Ansi C, so was changed\n-   * to _HB_SCRIPT_MAX_VALUE to be equal to HB_TAG_MAX_SIGNED as well.\n-   *\n-   * See this thread for technicalities:\n-   *\n-   *   https:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2014-March\/004150.html\n-   *\/\n-  _HB_SCRIPT_MAX_VALUE                          = HB_TAG_MAX_SIGNED, \/*< skip >*\/\n-  _HB_SCRIPT_MAX_VALUE_SIGNED                   = HB_TAG_MAX_SIGNED \/*< skip >*\/\n-\n-} hb_script_t;\n-\n+#include \"hb-script-list.h\"\n@@ -951,0 +522,10 @@\n+\/* Not of much use to clients. *\/\n+HB_EXTERN void*\n+hb_malloc (size_t size);\n+HB_EXTERN void*\n+hb_calloc (size_t nmemb, size_t size);\n+HB_EXTERN void*\n+hb_realloc (void *ptr, size_t size);\n+HB_EXTERN void\n+hb_free (void *ptr);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.h","additions":12,"deletions":431,"binary":false,"changes":443,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+#define HB_NO_PAINT\n@@ -194,1 +195,0 @@\n-#define HB_NO_OT_FONT_ADVANCE_CACHE\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-config.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  int i;\n+  unsigned i;\n@@ -55,1 +55,1 @@\n-static_assert ((sizeof (hb_atomic_int_t) >= sizeof (hb_options_union_t)), \"\");\n+static_assert ((sizeof (hb_atomic_t<unsigned>) >= sizeof (hb_options_union_t)), \"\");\n@@ -60,1 +60,1 @@\n-extern HB_INTERNAL hb_atomic_int_t _hb_options;\n+extern HB_INTERNAL hb_atomic_t<unsigned> _hb_options;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-debug.hh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -278,0 +278,42 @@\n+\/**\n+ * hb_font_draw_glyph_func_t:\n+ * @font: #hb_font_t to work upon\n+ * @font_data: @font user data pointer\n+ * @glyph: The glyph ID to query\n+ * @draw_funcs: The draw functions to send the shape data to\n+ * @draw_data: The data accompanying the draw functions\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n+ *\n+ * Since: 7.0.0\n+ * XDeprecated: REPLACEME: Use hb_font_draw_glyph_func_or_fail_t instead.\n+ **\/\n+typedef void (*hb_font_draw_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                           hb_codepoint_t glyph,\n+                                           hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                                           void *user_data);\n+\n+\/**\n+ * hb_font_paint_glyph_func_t:\n+ * @font: #hb_font_t to work upon\n+ * @font_data: @font user data pointer\n+ * @glyph: The glyph ID to query\n+ * @paint_funcs: The paint functions to use\n+ * @paint_data: The data accompanying the paint functions\n+ * @palette_index: The color palette to use\n+ * @foreground: The foreground color\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n+ *\n+ * Since: 7.0.0\n+ * XDeprecated: REPLACEME: Use hb_font_paint_glyph_or_fail_func_t instead.\n+ *\/\n+typedef hb_bool_t (*hb_font_paint_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                                 hb_codepoint_t glyph,\n+                                                 hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                                                 unsigned int palette_index,\n+                                                 hb_color_t foreground,\n+                                                 void *user_data);\n+\n@@ -291,1 +333,1 @@\n-HB_DEPRECATED_FOR (hb_font_funcs_set_draw_glyph_func)\n+HB_DEPRECATED_FOR (hb_font_funcs_set_draw_glyph_or_fail_func)\n@@ -297,1 +339,37 @@\n-HB_DEPRECATED_FOR (hb_font_draw_glyph)\n+\/**\n+ * hb_font_funcs_set_draw_glyph_func:\n+ * @ffuncs: A font-function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets the implementation function for #hb_font_draw_glyph_func_t.\n+ *\n+ * Since: 7.0.0\n+ * XDeprecated: REPLACEME: Use hb_font_funcs_set_draw_glyph_or_fail_func instead.\n+ **\/\n+HB_DEPRECATED_FOR (hb_font_funcs_set_draw_glyph_or_fail_func)\n+HB_EXTERN void\n+hb_font_funcs_set_draw_glyph_func (hb_font_funcs_t *ffuncs,\n+                                   hb_font_draw_glyph_func_t func,\n+                                   void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_paint_glyph_func:\n+ * @ffuncs: A font-function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is no longer needed\n+ *\n+ * Sets the implementation function for #hb_font_paint_glyph_func_t.\n+ *\n+ * Since: 7.0.0\n+ * XDeprecated: REPLACEME: Use hb_font_funcs_set_paint_glyph_or_fail_func() instead.\n+ *\/\n+HB_DEPRECATED_FOR (hb_font_funcs_set_paint_glyph_or_fail_func)\n+HB_EXTERN void\n+hb_font_funcs_set_paint_glyph_func (hb_font_funcs_t *ffuncs,\n+                                    hb_font_paint_glyph_func_t func,\n+                                    void *user_data, hb_destroy_func_t destroy);\n+\n+HB_DEPRECATED_FOR (hb_font_draw_glyph_or_fail)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-deprecated.h","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+#include \"hb-geometry.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+\n@@ -458,0 +463,88 @@\n+static void\n+hb_draw_extents_move_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                         void *data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_line_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                         void *data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_quadratic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                              void *data,\n+                              hb_draw_state_t *st,\n+                              float control_x, float control_y,\n+                              float to_x, float to_y,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (control_x, control_y);\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static void\n+hb_draw_extents_cubic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                          void *data,\n+                          hb_draw_state_t *st,\n+                          float control1_x, float control1_y,\n+                          float control2_x, float control2_y,\n+                          float to_x, float to_y,\n+                          void *user_data HB_UNUSED)\n+{\n+  hb_extents_t *extents = (hb_extents_t *) data;\n+\n+  extents->add_point (control1_x, control1_y);\n+  extents->add_point (control2_x, control2_y);\n+  extents->add_point (to_x, to_y);\n+}\n+\n+static inline void free_static_draw_extents_funcs ();\n+\n+static struct hb_draw_extents_funcs_lazy_loader_t : hb_draw_funcs_lazy_loader_t<hb_draw_extents_funcs_lazy_loader_t>\n+{\n+  static hb_draw_funcs_t *create ()\n+  {\n+    hb_draw_funcs_t *funcs = hb_draw_funcs_create ();\n+\n+    hb_draw_funcs_set_move_to_func (funcs, hb_draw_extents_move_to, nullptr, nullptr);\n+    hb_draw_funcs_set_line_to_func (funcs, hb_draw_extents_line_to, nullptr, nullptr);\n+    hb_draw_funcs_set_quadratic_to_func (funcs, hb_draw_extents_quadratic_to, nullptr, nullptr);\n+    hb_draw_funcs_set_cubic_to_func (funcs, hb_draw_extents_cubic_to, nullptr, nullptr);\n+\n+    hb_draw_funcs_make_immutable (funcs);\n+\n+    hb_atexit (free_static_draw_extents_funcs);\n+\n+    return funcs;\n+  }\n+} static_draw_extents_funcs;\n+\n+static inline\n+void free_static_draw_extents_funcs ()\n+{\n+  static_draw_extents_funcs.free_instance ();\n+}\n+\n+hb_draw_funcs_t *\n+hb_draw_extents_get_funcs ()\n+{\n+  return static_draw_extents_funcs.get_unconst ();\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.cc","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-#define HB_DRAW_STATE_DEFAULT {0, 0.f, 0.f, 0.f, 0.f, {0.}, {0.}, {0.}, {0.}, {0.}, {0.}, {0.}}\n+#define HB_DRAW_STATE_DEFAULT {0, 0.f, 0.f, 0.f, 0.f, {0}, {0}, {0}, {0}, {0}, {0}, {0}}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+\n@@ -112,0 +113,1 @@\n+\n@@ -113,0 +115,1 @@\n+\n@@ -124,0 +127,1 @@\n+\n@@ -125,0 +129,1 @@\n+\n@@ -137,0 +142,1 @@\n+\n@@ -138,0 +144,1 @@\n+\n@@ -171,3 +178,2 @@\n-  hb_draw_session_t (hb_draw_funcs_t *funcs_, void *draw_data_, float slant_ = 0.f)\n-    : slant {slant_}, not_slanted {slant == 0.f},\n-      funcs {funcs_}, draw_data {draw_data_}, st HB_DRAW_STATE_DEFAULT\n+  hb_draw_session_t (hb_draw_funcs_t *funcs_, void *draw_data_)\n+    : funcs {funcs_}, draw_data {draw_data_}, st HB_DRAW_STATE_DEFAULT\n@@ -181,6 +187,2 @@\n-    if (likely (not_slanted))\n-      funcs->move_to (draw_data, st,\n-                      to_x, to_y);\n-    else\n-      funcs->move_to (draw_data, st,\n-                      to_x + to_y * slant, to_y);\n+    funcs->move_to (draw_data, st,\n+                    to_x, to_y);\n@@ -191,6 +193,2 @@\n-    if (likely (not_slanted))\n-      funcs->line_to (draw_data, st,\n-                      to_x, to_y);\n-    else\n-      funcs->line_to (draw_data, st,\n-                      to_x + to_y * slant, to_y);\n+    funcs->line_to (draw_data, st,\n+                    to_x, to_y);\n@@ -203,8 +201,3 @@\n-    if (likely (not_slanted))\n-      funcs->quadratic_to (draw_data, st,\n-                           control_x, control_y,\n-                           to_x, to_y);\n-    else\n-      funcs->quadratic_to (draw_data, st,\n-                           control_x + control_y * slant, control_y,\n-                           to_x + to_y * slant, to_y);\n+    funcs->quadratic_to (draw_data, st,\n+                         control_x, control_y,\n+                         to_x, to_y);\n@@ -218,10 +211,4 @@\n-    if (likely (not_slanted))\n-      funcs->cubic_to (draw_data, st,\n-                       control1_x, control1_y,\n-                       control2_x, control2_y,\n-                       to_x, to_y);\n-    else\n-      funcs->cubic_to (draw_data, st,\n-                       control1_x + control1_y * slant, control1_y,\n-                       control2_x + control2_y * slant, control2_y,\n-                       to_x + to_y * slant, to_y);\n+    funcs->cubic_to (draw_data, st,\n+                     control1_x, control1_y,\n+                     control2_x, control2_y,\n+                     to_x, to_y);\n@@ -236,2 +223,0 @@\n-  float slant;\n-  bool not_slanted;\n@@ -243,0 +228,5 @@\n+\n+HB_INTERNAL hb_draw_funcs_t *\n+hb_draw_extents_get_funcs ();\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.hh","additions":25,"deletions":35,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -37,0 +37,10 @@\n+#ifdef HAVE_FREETYPE\n+#include \"hb-ft.h\"\n+#endif\n+#ifdef HAVE_CORETEXT\n+#include \"hb-coretext.h\"\n+#endif\n+#ifdef HAVE_DIRECTWRITE\n+#include \"hb-directwrite.h\"\n+#endif\n+\n@@ -75,6 +85,6 @@\n-  \/* TODO We shouldn't be sanitizing blob.  Port to run sanitizer and return if not sane. *\/\n-  \/* Make API signature const after. *\/\n-  hb_blob_t *sanitized = hb_sanitize_context_t ().sanitize_blob<OT::OpenTypeFontFile> (hb_blob_reference (blob));\n-  const OT::OpenTypeFontFile& ot = *sanitized->as<OT::OpenTypeFontFile> ();\n-  unsigned int ret = ot.get_face_count ();\n-  hb_blob_destroy (sanitized);\n+  hb_sanitize_context_t c (blob);\n+\n+  const char *start = hb_blob_get_data (blob, nullptr);\n+  auto *ot = reinterpret_cast<OT::OpenTypeFontFile *> (const_cast<char *> (start));\n+  if (unlikely (!ot->sanitize (&c)))\n+    return 0;\n@@ -82,1 +92,1 @@\n-  return ret;\n+  return ot->get_face_count ();\n@@ -321,0 +331,26 @@\n+\n+static struct supported_face_loaders_t {\n+        char name[16];\n+        hb_face_t * (*from_file) (const char *font_file, unsigned face_index);\n+        hb_face_t * (*from_blob) (hb_blob_t *blob, unsigned face_index);\n+} supported_face_loaders[] =\n+{\n+  {\"ot\",\n+#ifndef HB_NO_OPEN\n+   hb_face_create_from_file_or_fail,\n+#else\n+   nullptr,\n+#endif\n+   hb_face_create_or_fail\n+  },\n+#ifdef HAVE_FREETYPE\n+  {\"ft\",\n+   hb_ft_face_create_from_file_or_fail,\n+   hb_ft_face_create_from_blob_or_fail\n+  },\n+#endif\n+#ifdef HAVE_CORETEXT\n+  {\"coretext\",\n+   hb_coretext_face_create_from_file_or_fail,\n+   hb_coretext_face_create_from_blob_or_fail\n+  },\n@@ -322,0 +358,176 @@\n+#ifdef HAVE_DIRECTWRITE\n+  {\"directwrite\",\n+   hb_directwrite_face_create_from_file_or_fail,\n+   hb_directwrite_face_create_from_blob_or_fail\n+  },\n+#endif\n+};\n+\n+static const char *get_default_loader_name ()\n+{\n+  static hb_atomic_t<const char *> static_loader_name;\n+  const char *loader_name = static_loader_name.get_acquire ();\n+  if (!loader_name)\n+  {\n+    loader_name = getenv (\"HB_FACE_LOADER\");\n+    if (!loader_name)\n+      loader_name = \"\";\n+    if (!static_loader_name.cmpexch (nullptr, loader_name))\n+      loader_name = static_loader_name.get_acquire ();\n+  }\n+  return loader_name;\n+}\n+\n+\/**\n+ * hb_face_create_from_file_or_fail_using:\n+ * @file_name: A font filename\n+ * @index: The index of the face within the file\n+ * @loader_name: (nullable): The name of the loader to use, or `NULL`\n+ *\n+ * A thin wrapper around the face loader functions registered with HarfBuzz.\n+ * If @loader_name is `NULL` or the empty string, the first available loader\n+ * is used.\n+ *\n+ * For example, the FreeType (\"ft\") loader might be able to load\n+ * WOFF and WOFF2 files if FreeType is built with those features,\n+ * whereas the OpenType (\"ot\") loader will not.\n+ *\n+ * Return value: (transfer full): The new face object, or `NULL` if\n+ * the file cannot be read or the loader fails to load the face.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+hb_face_t *\n+hb_face_create_from_file_or_fail_using (const char   *file_name,\n+                                        unsigned int  index,\n+                                        const char   *loader_name)\n+{\n+  \/\/ Duplicated in hb_face_create_or_fail_using\n+  bool retry = false;\n+  if (!loader_name || !*loader_name)\n+  {\n+    loader_name = get_default_loader_name ();\n+    retry = true;\n+  }\n+  if (loader_name && !*loader_name) loader_name = nullptr;\n+\n+retry:\n+  for (unsigned i = 0; i < ARRAY_LENGTH (supported_face_loaders); i++)\n+  {\n+    if (!loader_name || (supported_face_loaders[i].from_file && !strcmp (supported_face_loaders[i].name, loader_name)))\n+      return supported_face_loaders[i].from_file (file_name, index);\n+  }\n+\n+  if (retry)\n+  {\n+    retry = false;\n+    loader_name = nullptr;\n+    goto retry;\n+  }\n+\n+  return nullptr;\n+}\n+\n+\/**\n+ * hb_face_create_or_fail_using:\n+ * @blob: #hb_blob_t to work upon\n+ * @index: The index of the face within @blob\n+ * @loader_name: (nullable): The name of the loader to use, or `NULL`\n+ *\n+ * A thin wrapper around the face loader functions registered with HarfBuzz.\n+ * If @loader_name is `NULL` or the empty string, the first available loader\n+ * is used.\n+ *\n+ * For example, the FreeType (\"ft\") loader might be able to load\n+ * WOFF and WOFF2 files if FreeType is built with those features,\n+ * whereas the OpenType (\"ot\") loader will not.\n+ *\n+ * Return value: (transfer full): The new face object, or `NULL` if\n+ * the loader fails to load the face.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+hb_face_t *\n+hb_face_create_or_fail_using (hb_blob_t    *blob,\n+                              unsigned int  index,\n+                              const char   *loader_name)\n+{\n+  \/\/ Duplicated in hb_face_create_from_file_or_fail_using\n+  bool retry = false;\n+  if (!loader_name || !*loader_name)\n+  {\n+    loader_name = get_default_loader_name ();\n+    retry = true;\n+  }\n+  if (loader_name && !*loader_name) loader_name = nullptr;\n+\n+retry:\n+  for (unsigned i = 0; i < ARRAY_LENGTH (supported_face_loaders); i++)\n+  {\n+    if (!loader_name || (supported_face_loaders[i].from_blob && !strcmp (supported_face_loaders[i].name, loader_name)))\n+      return supported_face_loaders[i].from_blob (blob, index);\n+  }\n+\n+  if (retry)\n+  {\n+    retry = false;\n+    loader_name = nullptr;\n+    goto retry;\n+  }\n+\n+  return nullptr;\n+}\n+\n+static inline void free_static_face_loader_list ();\n+\n+static const char * const nil_face_loader_list[] = {nullptr};\n+\n+static struct hb_face_loader_list_lazy_loader_t : hb_lazy_loader_t<const char *,\n+                                                                  hb_face_loader_list_lazy_loader_t>\n+{\n+  static const char ** create ()\n+  {\n+    const char **face_loader_list = (const char **) hb_calloc (1 + ARRAY_LENGTH (supported_face_loaders), sizeof (const char *));\n+    if (unlikely (!face_loader_list))\n+      return nullptr;\n+\n+    unsigned i;\n+    for (i = 0; i < ARRAY_LENGTH (supported_face_loaders); i++)\n+      face_loader_list[i] = supported_face_loaders[i].name;\n+    face_loader_list[i] = nullptr;\n+\n+    hb_atexit (free_static_face_loader_list);\n+\n+    return face_loader_list;\n+  }\n+  static void destroy (const char **l)\n+  { hb_free (l); }\n+  static const char * const * get_null ()\n+  { return nil_face_loader_list; }\n+} static_face_loader_list;\n+\n+static inline\n+void free_static_face_loader_list ()\n+{\n+  static_face_loader_list.free_instance ();\n+}\n+\n+\/**\n+ * hb_face_list_loaders:\n+ *\n+ * Retrieves the list of face loaders supported by HarfBuzz.\n+ *\n+ * Return value: (transfer none) (array zero-terminated=1): a\n+ *    `NULL`-terminated array of supported face loaders\n+ *    constant strings. The returned array is owned by HarfBuzz\n+ *    and should not be modified or freed.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+const char **\n+hb_face_list_loaders ()\n+{\n+  return static_face_loader_list.get_unconst ();\n+}\n+#endif\n+\n@@ -463,1 +675,1 @@\n-hb_face_is_immutable (const hb_face_t *face)\n+hb_face_is_immutable (hb_face_t *face)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.cc","additions":220,"deletions":8,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+HB_EXTERN hb_face_t *\n+hb_face_create_or_fail_using (hb_blob_t    *blob,\n+                              unsigned int  index,\n+                              const char   *loader_name);\n+\n@@ -70,0 +75,9 @@\n+HB_EXTERN hb_face_t *\n+hb_face_create_from_file_or_fail_using (const char   *file_name,\n+                                        unsigned int  index,\n+                                        const char   *loader_name);\n+\n+HB_EXTERN const char **\n+hb_face_list_loaders (void);\n+\n+\n@@ -120,1 +134,1 @@\n-hb_face_is_immutable (const hb_face_t *face);\n+hb_face_is_immutable (hb_face_t *face);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.h","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-  mutable hb_atomic_int_t upem;         \/* Units-per-EM. *\/\n-  mutable hb_atomic_int_t num_glyphs;   \/* Number of glyphs. *\/\n+  mutable hb_atomic_t<unsigned> upem;   \/* Units-per-EM. *\/\n+  mutable hb_atomic_t<unsigned> num_glyphs;\/* Number of glyphs. *\/\n@@ -73,1 +73,1 @@\n-  hb_atomic_ptr_t<plan_node_t> shape_plans;\n+  hb_atomic_t<plan_node_t *> shape_plans;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.hh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,16 @@\n+#ifndef HB_NO_OT_FONT\n+#include \"hb-ot.h\"\n+#endif\n+#ifdef HAVE_FREETYPE\n+#include \"hb-ft.h\"\n+#endif\n+#ifdef HAVE_FONTATIONS\n+#include \"hb-fontations.h\"\n+#endif\n+#ifdef HAVE_CORETEXT\n+#include \"hb-coretext.h\"\n+#endif\n+#ifdef HAVE_DIRECTWRITE\n+#include \"hb-directwrite.h\"\n+#endif\n+\n@@ -90,1 +106,1 @@\n-  hb_bool_t ret = font->parent->get_font_h_extents (extents);\n+  hb_bool_t ret = font->parent->get_font_h_extents (extents, false);\n@@ -115,1 +131,1 @@\n-  hb_bool_t ret = font->parent->get_font_v_extents (extents);\n+  hb_bool_t ret = font->parent->get_font_v_extents (extents, false);\n@@ -221,1 +237,1 @@\n-    font->get_glyph_h_advances (1, &glyph, 0, &ret, 0);\n+    font->get_glyph_h_advances (1, &glyph, 0, &ret, 0, false);\n@@ -224,1 +240,1 @@\n-  return font->parent_scale_x_distance (font->parent->get_glyph_h_advance (glyph));\n+  return font->parent_scale_x_distance (font->parent->get_glyph_h_advance (glyph, false));\n@@ -246,1 +262,1 @@\n-    font->get_glyph_v_advances (1, &glyph, 0, &ret, 0);\n+    font->get_glyph_v_advances (1, &glyph, 0, &ret, 0, false);\n@@ -249,1 +265,1 @@\n-  return font->parent_scale_y_distance (font->parent->get_glyph_v_advance (glyph));\n+  return font->parent_scale_y_distance (font->parent->get_glyph_v_advance (glyph, false));\n@@ -268,1 +284,1 @@\n-      *first_advance = font->get_glyph_h_advance (*first_glyph);\n+      *first_advance = font->get_glyph_h_advance (*first_glyph, false);\n@@ -277,1 +293,2 @@\n-                                      first_advance, advance_stride);\n+                                      first_advance, advance_stride,\n+                                      false);\n@@ -300,1 +317,1 @@\n-      *first_advance = font->get_glyph_v_advance (*first_glyph);\n+      *first_advance = font->get_glyph_v_advance (*first_glyph, false);\n@@ -309,1 +326,2 @@\n-                                      first_advance, advance_stride);\n+                                      first_advance, advance_stride,\n+                                      false);\n@@ -429,1 +447,1 @@\n-  hb_bool_t ret = font->parent->get_glyph_extents (glyph, extents);\n+  hb_bool_t ret = font->parent->get_glyph_extents (glyph, extents, false);\n@@ -459,1 +477,1 @@\n-  hb_bool_t ret = font->parent->get_glyph_contour_point (glyph, point_index, x, y);\n+  hb_bool_t ret = font->parent->get_glyph_contour_point (glyph, point_index, x, y, false);\n@@ -511,7 +529,7 @@\n-static void\n-hb_font_draw_glyph_nil (hb_font_t       *font HB_UNUSED,\n-                        void            *font_data HB_UNUSED,\n-                        hb_codepoint_t   glyph,\n-                        hb_draw_funcs_t *draw_funcs,\n-                        void            *draw_data,\n-                        void            *user_data HB_UNUSED)\n+static hb_bool_t\n+hb_font_draw_glyph_or_fail_nil (hb_font_t       *font HB_UNUSED,\n+                                void            *font_data HB_UNUSED,\n+                                hb_codepoint_t   glyph,\n+                                hb_draw_funcs_t *draw_funcs,\n+                                void            *draw_data,\n+                                void            *user_data HB_UNUSED)\n@@ -519,0 +537,1 @@\n+  return false;\n@@ -521,9 +540,9 @@\n-static void\n-hb_font_paint_glyph_nil (hb_font_t *font HB_UNUSED,\n-                         void *font_data HB_UNUSED,\n-                         hb_codepoint_t glyph HB_UNUSED,\n-                         hb_paint_funcs_t *paint_funcs HB_UNUSED,\n-                         void *paint_data HB_UNUSED,\n-                         unsigned int palette HB_UNUSED,\n-                         hb_color_t foreground HB_UNUSED,\n-                         void *user_data HB_UNUSED)\n+static hb_bool_t\n+hb_font_paint_glyph_or_fail_nil (hb_font_t *font HB_UNUSED,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t glyph HB_UNUSED,\n+                                 hb_paint_funcs_t *paint_funcs HB_UNUSED,\n+                                 void *paint_data HB_UNUSED,\n+                                 unsigned int palette HB_UNUSED,\n+                                 hb_color_t foreground HB_UNUSED,\n+                                 void *user_data HB_UNUSED)\n@@ -531,0 +550,1 @@\n+  return false;\n@@ -538,1 +558,0 @@\n-  float            slant;\n@@ -551,1 +570,0 @@\n-  float slant   = adaptor->slant;\n@@ -554,1 +572,1 @@\n-                                     x_scale * to_x + slant * to_y, y_scale * to_y);\n+                                     x_scale * to_x, y_scale * to_y);\n@@ -566,1 +584,0 @@\n-  float slant   = adaptor->slant;\n@@ -568,1 +585,1 @@\n-  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_x = st->current_x * x_scale;\n@@ -572,1 +589,1 @@\n-                                     x_scale * to_x + slant * to_y, y_scale * to_y);\n+                                     x_scale * to_x, y_scale * to_y);\n@@ -585,1 +602,0 @@\n-  float slant   = adaptor->slant;\n@@ -587,1 +603,1 @@\n-  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_x = st->current_x * x_scale;\n@@ -591,2 +607,2 @@\n-                                          x_scale * control_x + slant * control_y, y_scale * control_y,\n-                                          x_scale * to_x + slant * to_y, y_scale * to_y);\n+                                          x_scale * control_x, y_scale * control_y,\n+                                          x_scale * to_x, y_scale * to_y);\n@@ -606,1 +622,0 @@\n-  float slant   = adaptor->slant;\n@@ -608,1 +623,1 @@\n-  st->current_x = st->current_x * x_scale + st->current_y * slant;\n+  st->current_x = st->current_x * x_scale;\n@@ -612,3 +627,3 @@\n-                                      x_scale * control1_x + slant * control1_y, y_scale * control1_y,\n-                                      x_scale * control2_x + slant * control2_y, y_scale * control2_y,\n-                                      x_scale * to_x + slant * to_y, y_scale * to_y);\n+                                      x_scale * control1_x, y_scale * control1_y,\n+                                      x_scale * control2_x, y_scale * control2_y,\n+                                      x_scale * to_x, y_scale * to_y);\n@@ -637,7 +652,7 @@\n-static void\n-hb_font_draw_glyph_default (hb_font_t       *font,\n-                                 void            *font_data HB_UNUSED,\n-                                 hb_codepoint_t   glyph,\n-                                 hb_draw_funcs_t *draw_funcs,\n-                                 void            *draw_data,\n-                                 void            *user_data HB_UNUSED)\n+static hb_bool_t\n+hb_font_draw_glyph_or_fail_default (hb_font_t       *font,\n+                                    void            *font_data HB_UNUSED,\n+                                    hb_codepoint_t   glyph,\n+                                    hb_draw_funcs_t *draw_funcs,\n+                                    void            *draw_data,\n+                                    void            *user_data HB_UNUSED)\n@@ -649,3 +664,1 @@\n-    font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0.f,\n-    font->parent->y_scale ? (font->slant - font->parent->slant) *\n-                            (float) font->x_scale \/ (float) font->parent->y_scale : 0.f\n+    font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0.f\n@@ -654,3 +667,4 @@\n-  font->parent->draw_glyph (glyph,\n-                                 const_cast<hb_draw_funcs_t *> (&_hb_draw_funcs_default),\n-                                 &adaptor);\n+  return font->parent->draw_glyph_or_fail (glyph,\n+                                           const_cast<hb_draw_funcs_t *> (&_hb_draw_funcs_default),\n+                                           &adaptor,\n+                                           false);\n@@ -659,9 +673,9 @@\n-static void\n-hb_font_paint_glyph_default (hb_font_t *font,\n-                             void *font_data,\n-                             hb_codepoint_t glyph,\n-                             hb_paint_funcs_t *paint_funcs,\n-                             void *paint_data,\n-                             unsigned int palette,\n-                             hb_color_t foreground,\n-                             void *user_data)\n+static hb_bool_t\n+hb_font_paint_glyph_or_fail_default (hb_font_t *font,\n+                                     void *font_data,\n+                                     hb_codepoint_t glyph,\n+                                     hb_paint_funcs_t *paint_funcs,\n+                                     void *paint_data,\n+                                     unsigned int palette,\n+                                     hb_color_t foreground,\n+                                     void *user_data)\n@@ -670,6 +684,3 @@\n-    font->parent->x_scale ? (float) font->x_scale \/ (float) font->parent->x_scale : 0.f,\n-    font->parent->y_scale ? (font->slant - font->parent->slant) *\n-                            (float) font->x_scale \/ (float) font->parent->y_scale : 0.f,\n-    0.f,\n-    font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0.f,\n-    0.f, 0.f);\n+    font->parent->x_scale ? (float) font->x_scale \/ (float) font->parent->x_scale : 0, 0,\n+    0, font->parent->y_scale ? (float) font->y_scale \/ (float) font->parent->y_scale : 0,\n+    0, 0);\n@@ -677,1 +688,1 @@\n-  font->parent->paint_glyph (glyph, paint_funcs, paint_data, palette, foreground);\n+  bool ret = font->parent->paint_glyph_or_fail (glyph, paint_funcs, paint_data, palette, foreground);\n@@ -680,0 +691,2 @@\n+\n+  return ret;\n@@ -1416,0 +1429,86 @@\n+\/**\n+ * hb_font_draw_glyph_or_fail:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: The glyph ID\n+ * @dfuncs: #hb_draw_funcs_t to draw to\n+ * @draw_data: User data to pass to draw callbacks\n+ *\n+ * Draws the outline that corresponds to a glyph in the specified @font.\n+ *\n+ * This is a newer name for hb_font_draw_glyph(), that returns `false`\n+ * if the font has no outlines for the glyph.\n+ *\n+ * The outline is returned by way of calls to the callbacks of the @dfuncs\n+ * objects, with @draw_data passed to them.\n+ *\n+ * Return value: `true` if glyph was drawn, `false` otherwise\n+ *\n+ * XSince: REPLACEME\n+ **\/\n+hb_bool_t\n+hb_font_draw_glyph_or_fail (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_draw_funcs_t *dfuncs, void *draw_data)\n+{\n+  return font->draw_glyph_or_fail (glyph, dfuncs, draw_data);\n+}\n+\n+\/**\n+ * hb_font_paint_glyph_or_fail:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: The glyph ID\n+ * @pfuncs: #hb_paint_funcs_t to paint with\n+ * @paint_data: User data to pass to paint callbacks\n+ * @palette_index: The index of the font's color palette to use\n+ * @foreground: The foreground color, unpremultipled\n+ *\n+ * Paints a color glyph.\n+ *\n+ * This function is similar to, but lower-level than,\n+ * hb_font_paint_glyph(). It is suitable for clients that\n+ * need more control.  If there are no color glyphs available,\n+ * it will return `false`. The client can then fall back to\n+ * hb_font_draw_glyph_or_fail() for the monochrome outline glyph.\n+ *\n+ * The painting instructions are returned by way of calls to\n+ * the callbacks of the @funcs object, with @paint_data passed\n+ * to them.\n+ *\n+ * If the font has color palettes (see hb_ot_color_has_palettes()),\n+ * then @palette_index selects the palette to use. If the font only\n+ * has one palette, this will be 0.\n+ *\n+ * Return value: `true` if glyph was painted, `false` otherwise\n+ *\n+ * XSince: REPLACEME\n+ *\/\n+hb_bool_t\n+hb_font_paint_glyph_or_fail (hb_font_t *font,\n+                             hb_codepoint_t glyph,\n+                             hb_paint_funcs_t *pfuncs, void *paint_data,\n+                             unsigned int palette_index,\n+                             hb_color_t foreground)\n+{\n+  return font->paint_glyph_or_fail (glyph, pfuncs, paint_data, palette_index, foreground);\n+}\n+\n+\/* A bit higher-level, and with fallback *\/\n+\n+void\n+hb_font_t::paint_glyph (hb_codepoint_t glyph,\n+                        hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                        unsigned int palette,\n+                        hb_color_t foreground)\n+{\n+  if (paint_glyph_or_fail (glyph,\n+                           paint_funcs, paint_data,\n+                           palette, foreground))\n+    return;\n+\n+  \/* Fallback for outline glyph. *\/\n+  paint_funcs->push_clip_glyph (paint_data, glyph, this);\n+  paint_funcs->color (paint_data, true, foreground);\n+  paint_funcs->pop_clip (paint_data);\n+}\n+\n+\n@@ -1425,0 +1524,3 @@\n+ * This is an older name for hb_font_draw_glyph_or_fail(), with no\n+ * return value.\n+ *\n@@ -1432,2 +1534,2 @@\n-                         hb_codepoint_t glyph,\n-                         hb_draw_funcs_t *dfuncs, void *draw_data)\n+                    hb_codepoint_t glyph,\n+                    hb_draw_funcs_t *dfuncs, void *draw_data)\n@@ -1435,1 +1537,1 @@\n-  font->draw_glyph (glyph, dfuncs, draw_data);\n+  (void) hb_font_draw_glyph_or_fail (font, glyph, dfuncs, draw_data);\n@@ -1447,1 +1549,4 @@\n- * Paints the glyph.\n+ * Paints the glyph. This function is similar to\n+ * hb_font_paint_glyph_or_fail(), but if painting a color glyph\n+ * failed, it will fall back to painting an outline monochrome\n+ * glyph.\n@@ -1469,2 +1574,0 @@\n-\/* A bit higher-level, and with fallback *\/\n-\n@@ -1857,4 +1960,1 @@\n-#ifndef HB_NO_OT_FONT\n-  \/* Install our in-house, very lightweight, funcs. *\/\n-  hb_ot_font_set_funcs (font);\n-#endif\n+  hb_font_set_funcs_using (font, nullptr);\n@@ -1883,1 +1983,2 @@\n-  font->mults_changed (); \/\/ Easiest to call this to drop cached data\n+  font->changed ();\n+  font->serial_coords = font->serial;\n@@ -1938,1 +2039,2 @@\n-  font->mults_changed ();\n+  font->changed ();\n+  font->serial_coords = font->serial;\n@@ -2026,1 +2128,1 @@\n-    font->serial++;\n+    font->changed ();\n@@ -2101,1 +2203,1 @@\n-  return font->serial;\n+  return font->serial.get_acquire ();\n@@ -2120,3 +2222,1 @@\n-  font->serial++;\n-\n-  font->mults_changed ();\n+  font->changed ();\n@@ -2144,2 +2244,0 @@\n-  font->serial++;\n-\n@@ -2154,0 +2252,2 @@\n+\n+  font->changed ();\n@@ -2191,2 +2291,0 @@\n-  font->serial++;\n-\n@@ -2200,1 +2298,1 @@\n-  font->mults_changed ();\n+  font->changed ();\n@@ -2203,0 +2301,3 @@\n+\n+  font->changed ();\n+  font->serial_coords = font->serial;\n@@ -2247,2 +2348,0 @@\n-  font->serial++;\n-\n@@ -2260,0 +2359,2 @@\n+\n+  font->changed ();\n@@ -2286,2 +2387,0 @@\n-  font->serial++;\n-\n@@ -2293,0 +2392,87 @@\n+\n+  font->changed ();\n+}\n+\n+static struct supported_font_funcs_t {\n+        char name[16];\n+        void (*func) (hb_font_t *);\n+} supported_font_funcs[] =\n+{\n+#ifndef HB_NO_OT_FONT\n+  {\"ot\",        hb_ot_font_set_funcs},\n+#endif\n+#ifdef HAVE_FREETYPE\n+  {\"ft\",        hb_ft_font_set_funcs},\n+#endif\n+#ifdef HAVE_FONTATIONS\n+  {\"fontations\",hb_fontations_font_set_funcs},\n+#endif\n+#ifdef HAVE_CORETEXT\n+  {\"coretext\",  hb_coretext_font_set_funcs},\n+#endif\n+#ifdef HAVE_DIRECTWRITE\n+  {\"directwrite\",hb_directwrite_font_set_funcs},\n+#endif\n+};\n+\n+static const char *get_default_funcs_name ()\n+{\n+  static hb_atomic_t<const char *> static_funcs_name;\n+  const char *name = static_funcs_name.get_acquire ();\n+  if (!name)\n+  {\n+    name = getenv (\"HB_FONT_FUNCS\");\n+    if (!name)\n+      name = \"\";\n+    if (!static_funcs_name.cmpexch (nullptr, name))\n+      name = static_funcs_name.get_acquire ();\n+  }\n+  return name;\n+}\n+\n+\/**\n+ * hb_font_set_funcs_using:\n+ * @font: #hb_font_t to work upon\n+ * @name: The name of the font-functions structure to use, or `NULL`\n+ *\n+ * Sets the font-functions structure to use for a font, based on the\n+ * specified name.\n+ *\n+ * If @name is `NULL` or the empty string, the default (first) functioning font-functions\n+ * are used.  This default can be changed by setting the `HB_FONT_FUNCS` environment\n+ * variable to the name of the desired font-functions.\n+ *\n+ * Return value: `true` if the font-functions was found and set, `false` otherwise\n+ *\n+ * Since: 11.0.0\n+ **\/\n+hb_bool_t\n+hb_font_set_funcs_using (hb_font_t  *font,\n+                         const char *name)\n+{\n+  bool retry = false;\n+\n+  if (!name || !*name)\n+  {\n+    name = get_default_funcs_name ();\n+    retry = true;\n+  }\n+  if (name && !*name) name = nullptr;\n+\n+retry:\n+  for (unsigned i = 0; i < ARRAY_LENGTH (supported_font_funcs); i++)\n+    if (!name || strcmp (supported_font_funcs[i].name, name) == 0)\n+    {\n+      supported_font_funcs[i].func (font);\n+      if (name || font->klass != hb_font_funcs_get_empty ())\n+        return true;\n+    }\n+\n+  if (retry)\n+  {\n+    retry = false;\n+    name = nullptr;\n+    goto retry;\n+  }\n+\n+  return false;\n@@ -2295,0 +2481,51 @@\n+static inline void free_static_font_funcs_list ();\n+\n+static const char * const nil_font_funcs_list[] = {nullptr};\n+\n+static struct hb_font_funcs_list_lazy_loader_t : hb_lazy_loader_t<const char *,\n+                                                                  hb_font_funcs_list_lazy_loader_t>\n+{\n+  static const char ** create ()\n+  {\n+    const char **font_funcs_list = (const char **) hb_calloc (1 + ARRAY_LENGTH (supported_font_funcs), sizeof (const char *));\n+    if (unlikely (!font_funcs_list))\n+      return nullptr;\n+\n+    unsigned i;\n+    for (i = 0; i < ARRAY_LENGTH (supported_font_funcs); i++)\n+      font_funcs_list[i] = supported_font_funcs[i].name;\n+    font_funcs_list[i] = nullptr;\n+\n+    hb_atexit (free_static_font_funcs_list);\n+\n+    return font_funcs_list;\n+  }\n+  static void destroy (const char **l)\n+  { hb_free (l); }\n+  static const char * const * get_null ()\n+  { return nil_font_funcs_list; }\n+} static_font_funcs_list;\n+\n+static inline\n+void free_static_font_funcs_list ()\n+{\n+  static_font_funcs_list.free_instance ();\n+}\n+\n+\/**\n+ * hb_font_list_funcs:\n+ *\n+ * Retrieves the list of font functions supported by HarfBuzz.\n+ *\n+ * Return value: (transfer none) (array zero-terminated=1): a\n+ *    `NULL`-terminated array of supported font functions\n+ *    constant strings. The returned array is owned by HarfBuzz\n+ *    and should not be modified or freed.\n+ *\n+ * Since: 11.0.0\n+ **\/\n+const char **\n+hb_font_list_funcs ()\n+{\n+  return static_font_funcs_list.get_unconst ();\n+}\n@@ -2342,2 +2579,0 @@\n-  font->serial++;\n-\n@@ -2346,1 +2581,2 @@\n-  font->mults_changed ();\n+\n+  font->changed ();\n@@ -2393,2 +2629,0 @@\n-  font->serial++;\n-\n@@ -2397,0 +2631,2 @@\n+\n+  font->changed ();\n@@ -2440,2 +2676,0 @@\n-  font->serial++;\n-\n@@ -2443,0 +2677,2 @@\n+\n+  font->changed ();\n@@ -2462,0 +2698,17 @@\n+\/**\n+ * hb_font_is_synthetic:\n+ * @font: #hb_font_t to work upon\n+ *\n+ * Tests whether a font is synthetic. A synthetic font is one\n+ * that has either synthetic slant or synthetic bold set on it.\n+ *\n+ * Return value: `true` if the font is synthetic, `false` otherwise.\n+ *\n+ * XSince: REPLACEME\n+ *\/\n+hb_bool_t\n+hb_font_is_synthetic (hb_font_t *font)\n+{\n+  return font->is_synthetic ();\n+}\n+\n@@ -2479,1 +2732,1 @@\n- * hb_font_draw_glyph().\n+ * hb_font_draw_glyph_or_fail().\n@@ -2502,2 +2755,0 @@\n-  font->serial++;\n-\n@@ -2507,1 +2758,2 @@\n-  font->mults_changed ();\n+\n+  font->changed ();\n@@ -2544,1 +2796,1 @@\n- * <note>Note: The glyph shape fetched via the hb_font_draw_glyph()\n+ * <note>Note: The glyph shape fetched via the hb_font_draw_glyph_or_fail()\n@@ -2561,2 +2813,0 @@\n-  font->serial++;\n-\n@@ -2564,1 +2814,2 @@\n-  font->mults_changed ();\n+\n+  font->changed ();\n@@ -2610,2 +2861,0 @@\n-  font->serial_coords = ++font->serial;\n-\n@@ -2680,2 +2929,0 @@\n-  font->serial_coords = ++font->serial;\n-\n@@ -2752,2 +2999,0 @@\n-  font->serial_coords = ++font->serial;\n-\n@@ -2790,2 +3035,0 @@\n-  font->serial_coords = ++font->serial;\n-\n@@ -2837,2 +3080,0 @@\n-  font->serial_coords = ++font->serial;\n-\n@@ -3061,0 +3302,64 @@\n+\n+struct hb_draw_glyph_closure_t\n+{\n+  hb_font_draw_glyph_func_t func;\n+  void *user_data;\n+  hb_destroy_func_t destroy;\n+};\n+static hb_bool_t\n+hb_font_draw_glyph_trampoline (hb_font_t       *font,\n+                               void            *font_data,\n+                               hb_codepoint_t   glyph,\n+                               hb_draw_funcs_t *draw_funcs,\n+                               void            *draw_data,\n+                               void            *user_data)\n+{\n+  hb_draw_glyph_closure_t *closure = (hb_draw_glyph_closure_t *) user_data;\n+  closure->func (font, font_data, glyph, draw_funcs, draw_data, closure->user_data);\n+  return true;\n+}\n+static void\n+hb_font_draw_glyph_closure_destroy (void *user_data)\n+{\n+  hb_draw_glyph_closure_t *closure = (hb_draw_glyph_closure_t *) user_data;\n+\n+  if (closure->destroy)\n+    closure->destroy (closure->user_data);\n+  hb_free (closure);\n+}\n+static void\n+_hb_font_funcs_set_draw_glyph_func (hb_font_funcs_t           *ffuncs,\n+                                    hb_font_draw_glyph_func_t  func,\n+                                    void                      *user_data,\n+                                    hb_destroy_func_t          destroy \/* May be NULL. *\/)\n+{\n+  if (hb_object_is_immutable (ffuncs))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+  hb_draw_glyph_closure_t *closure = (hb_draw_glyph_closure_t *) hb_calloc (1, sizeof (hb_draw_glyph_closure_t));\n+  if (unlikely (!closure))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+  closure->func = func;\n+  closure->user_data = user_data;\n+  closure->destroy = destroy;\n+\n+  hb_font_funcs_set_draw_glyph_or_fail_func (ffuncs,\n+                                             hb_font_draw_glyph_trampoline,\n+                                             closure,\n+                                             hb_font_draw_glyph_closure_destroy);\n+}\n+void\n+hb_font_funcs_set_draw_glyph_func (hb_font_funcs_t           *ffuncs,\n+                                   hb_font_draw_glyph_func_t  func,\n+                                   void                      *user_data,\n+                                   hb_destroy_func_t          destroy \/* May be NULL. *\/)\n+{\n+  _hb_font_funcs_set_draw_glyph_func (ffuncs, func, user_data, destroy);\n+}\n@@ -3067,1 +3372,59 @@\n-  hb_font_funcs_set_draw_glyph_func (ffuncs, func, user_data, destroy);\n+  _hb_font_funcs_set_draw_glyph_func (ffuncs, func, user_data, destroy);\n+}\n+\n+struct hb_paint_glyph_closure_t\n+{\n+  hb_font_paint_glyph_func_t func;\n+  void *user_data;\n+  hb_destroy_func_t destroy;\n+};\n+static hb_bool_t\n+hb_font_paint_glyph_trampoline (hb_font_t        *font,\n+                                void *font_data,\n+                                hb_codepoint_t glyph,\n+                                hb_paint_funcs_t *paint_funcs,\n+                                void *paint_data,\n+                                unsigned int palette,\n+                                hb_color_t foreground,\n+                                void *user_data)\n+{\n+  hb_paint_glyph_closure_t *closure = (hb_paint_glyph_closure_t *) user_data;\n+  closure->func (font, font_data, glyph, paint_funcs, paint_data, palette, foreground, closure->user_data);\n+  return true;\n+}\n+static void\n+hb_font_paint_glyph_closure_destroy (void *user_data)\n+{\n+  hb_paint_glyph_closure_t *closure = (hb_paint_glyph_closure_t *) user_data;\n+\n+  if (closure->destroy)\n+    closure->destroy (closure->user_data);\n+  hb_free (closure);\n+}\n+void\n+hb_font_funcs_set_paint_glyph_func (hb_font_funcs_t           *ffuncs,\n+                                    hb_font_paint_glyph_func_t  func,\n+                                    void                      *user_data,\n+                                    hb_destroy_func_t          destroy \/* May be NULL. *\/)\n+{\n+  if (hb_object_is_immutable (ffuncs))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+  hb_paint_glyph_closure_t *closure = (hb_paint_glyph_closure_t *) hb_calloc (1, sizeof (hb_paint_glyph_closure_t));\n+  if (unlikely (!closure))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+  closure->func = func;\n+  closure->user_data = user_data;\n+  closure->destroy = destroy;\n+\n+  hb_font_funcs_set_paint_glyph_or_fail_func (ffuncs,\n+                                              hb_font_paint_glyph_trampoline,\n+                                              closure,\n+                                              hb_font_paint_glyph_closure_destroy);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.cc","additions":487,"deletions":124,"binary":false,"changes":611,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n- * hb_font_draw_glyph_func_t:\n+ * hb_font_draw_glyph_or_fail_func_t:\n@@ -499,1 +499,1 @@\n- * Since: 7.0.0\n+ * Return value: `true` if glyph was drawn, `false` otherwise\n@@ -501,0 +501,1 @@\n+ * XSince: REPLACEME\n@@ -502,4 +503,4 @@\n-typedef void (*hb_font_draw_glyph_func_t) (hb_font_t *font, void *font_data,\n-                                           hb_codepoint_t glyph,\n-                                           hb_draw_funcs_t *draw_funcs, void *draw_data,\n-                                           void *user_data);\n+typedef hb_bool_t (*hb_font_draw_glyph_or_fail_func_t) (hb_font_t *font, void *font_data,\n+                                                        hb_codepoint_t glyph,\n+                                                        hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                                                        void *user_data);\n@@ -508,1 +509,1 @@\n- * hb_font_paint_glyph_func_t:\n+ * hb_font_paint_glyph_or_fail_func_t:\n@@ -520,1 +521,3 @@\n- * Since: 7.0.0\n+ * Return value: `true` if glyph was painted, `false` otherwise\n+ *\n+ * XSince: REPLACEME\n@@ -522,6 +525,6 @@\n-typedef void (*hb_font_paint_glyph_func_t) (hb_font_t *font, void *font_data,\n-                                            hb_codepoint_t glyph,\n-                                            hb_paint_funcs_t *paint_funcs, void *paint_data,\n-                                            unsigned int palette_index,\n-                                            hb_color_t foreground,\n-                                            void *user_data);\n+typedef hb_bool_t (*hb_font_paint_glyph_or_fail_func_t) (hb_font_t *font, void *font_data,\n+                                                         hb_codepoint_t glyph,\n+                                                         hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                                                         unsigned int palette_index,\n+                                                         hb_color_t foreground,\n+                                                         void *user_data);\n@@ -788,1 +791,1 @@\n- * hb_font_funcs_set_draw_glyph_func:\n+ * hb_font_funcs_set_draw_glyph_or_fail_func:\n@@ -794,1 +797,1 @@\n- * Sets the implementation function for #hb_font_draw_glyph_func_t.\n+ * Sets the implementation function for #hb_font_draw_glyph_or_fail_func_t.\n@@ -796,1 +799,1 @@\n- * Since: 7.0.0\n+ * XSince: REPLACEME\n@@ -799,3 +802,3 @@\n-hb_font_funcs_set_draw_glyph_func (hb_font_funcs_t *ffuncs,\n-                                   hb_font_draw_glyph_func_t func,\n-                                   void *user_data, hb_destroy_func_t destroy);\n+hb_font_funcs_set_draw_glyph_or_fail_func (hb_font_funcs_t *ffuncs,\n+                                           hb_font_draw_glyph_or_fail_func_t func,\n+                                           void *user_data, hb_destroy_func_t destroy);\n@@ -804,1 +807,1 @@\n- * hb_font_funcs_set_paint_glyph_func:\n+ * hb_font_funcs_set_paint_glyph_or_fail_func:\n@@ -810,1 +813,1 @@\n- * Sets the implementation function for #hb_font_paint_glyph_func_t.\n+ * Sets the implementation function for #hb_font_paint_glyph_or_fail_func_t.\n@@ -812,1 +815,1 @@\n- * Since: 7.0.0\n+ * XSince: REPLACEME\n@@ -815,3 +818,3 @@\n-hb_font_funcs_set_paint_glyph_func (hb_font_funcs_t *ffuncs,\n-                                    hb_font_paint_glyph_func_t func,\n-                                    void *user_data, hb_destroy_func_t destroy);\n+hb_font_funcs_set_paint_glyph_or_fail_func (hb_font_funcs_t *ffuncs,\n+                                            hb_font_paint_glyph_or_fail_func_t func,\n+                                            void *user_data, hb_destroy_func_t destroy);\n@@ -899,4 +902,4 @@\n-HB_EXTERN void\n-hb_font_draw_glyph (hb_font_t *font,\n-                    hb_codepoint_t glyph,\n-                    hb_draw_funcs_t *dfuncs, void *draw_data);\n+HB_EXTERN hb_bool_t\n+hb_font_draw_glyph_or_fail (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_draw_funcs_t *dfuncs, void *draw_data);\n@@ -904,6 +907,6 @@\n-HB_EXTERN void\n-hb_font_paint_glyph (hb_font_t *font,\n-                     hb_codepoint_t glyph,\n-                     hb_paint_funcs_t *pfuncs, void *paint_data,\n-                     unsigned int palette_index,\n-                     hb_color_t foreground);\n+HB_EXTERN hb_bool_t\n+hb_font_paint_glyph_or_fail (hb_font_t *font,\n+                             hb_codepoint_t glyph,\n+                             hb_paint_funcs_t *pfuncs, void *paint_data,\n+                             unsigned int palette_index,\n+                             hb_color_t foreground);\n@@ -982,0 +985,13 @@\n+\/* Older alias for hb_font_draw_glyph_or_fail() with no return value. *\/\n+HB_EXTERN void\n+hb_font_draw_glyph (hb_font_t *font,\n+                    hb_codepoint_t glyph,\n+                    hb_draw_funcs_t *dfuncs, void *draw_data);\n+\n+\/* Paints color glyph; if failed, draws outline glyph. *\/\n+HB_EXTERN void\n+hb_font_paint_glyph (hb_font_t *font,\n+                     hb_codepoint_t glyph,\n+                     hb_paint_funcs_t *pfuncs, void *paint_data,\n+                     unsigned int palette_index,\n+                     hb_color_t foreground);\n@@ -1055,0 +1071,6 @@\n+HB_EXTERN hb_bool_t\n+hb_font_set_funcs_using (hb_font_t  *font,\n+                         const char *name);\n+\n+HB_EXTERN const char **\n+hb_font_list_funcs (void);\n@@ -1089,0 +1111,3 @@\n+HB_EXTERN hb_bool_t\n+hb_font_is_synthetic (hb_font_t *font);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.h","additions":61,"deletions":36,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+#include \"hb-atomic.hh\"\n+#include \"hb-draw.hh\"\n+#include \"hb-paint-extents.hh\"\n@@ -36,0 +39,1 @@\n+#include \"hb-outline.hh\"\n@@ -60,2 +64,2 @@\n-  HB_FONT_FUNC_IMPLEMENT (,draw_glyph) \\\n-  HB_FONT_FUNC_IMPLEMENT (,paint_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (,draw_glyph_or_fail) \\\n+  HB_FONT_FUNC_IMPLEMENT (,paint_glyph_or_fail) \\\n@@ -108,2 +112,2 @@\n-  unsigned int serial;\n-  unsigned int serial_coords;\n+  hb_atomic_t<unsigned> serial;\n+  hb_atomic_t<unsigned> serial_coords;\n@@ -194,4 +198,4 @@\n-    float x1 = em_fscale_x (extents->x_bearing);\n-    float y1 = em_fscale_y (extents->y_bearing);\n-    float x2 = em_fscale_x (extents->x_bearing + extents->width);\n-    float y2 = em_fscale_y (extents->y_bearing + extents->height);\n+    float x1 = em_scale_x (extents->x_bearing);\n+    float y1 = em_scale_y (extents->y_bearing);\n+    float x2 = em_scale_x (extents->x_bearing + extents->width);\n+    float y2 = em_scale_y (extents->y_bearing + extents->height);\n@@ -199,1 +203,9 @@\n-    \/* Apply slant. *\/\n+    extents->x_bearing = roundf (x1);\n+    extents->y_bearing = roundf (y1);\n+    extents->width = roundf (x2) - extents->x_bearing;\n+    extents->height = roundf (y2) - extents->y_bearing;\n+  }\n+\n+  void synthetic_glyph_extents (hb_glyph_extents_t *extents)\n+  {\n+    \/* Slant. *\/\n@@ -202,3 +214,7 @@\n-      x1 += hb_min (y1 * slant_xy, y2 * slant_xy);\n-      x2 += hb_max (y1 * slant_xy, y2 * slant_xy);\n-    }\n+      hb_position_t x1 = extents->x_bearing;\n+      hb_position_t y1 = extents->y_bearing;\n+      hb_position_t x2 = extents->x_bearing + extents->width;\n+      hb_position_t y2 = extents->y_bearing + extents->height;\n+\n+      x1 += floorf (hb_min (y1 * slant_xy, y2 * slant_xy));\n+      x2 += ceilf (hb_max (y1 * slant_xy, y2 * slant_xy));\n@@ -206,4 +222,3 @@\n-    extents->x_bearing = floorf (x1);\n-    extents->y_bearing = floorf (y1);\n-    extents->width = ceilf (x2) - extents->x_bearing;\n-    extents->height = ceilf (y2) - extents->y_bearing;\n+      extents->x_bearing = x1;\n+      extents->width = x2 - extents->x_bearing;\n+    }\n@@ -211,0 +226,1 @@\n+    \/* Embolden. *\/\n@@ -253,1 +269,2 @@\n-  hb_bool_t get_font_h_extents (hb_font_extents_t *extents)\n+  hb_bool_t get_font_h_extents (hb_font_extents_t *extents,\n+                                bool synthetic = true)\n@@ -256,3 +273,12 @@\n-    return klass->get.f.font_h_extents (this, user_data,\n-                                        extents,\n-                                        !klass->user_data ? nullptr : klass->user_data->font_h_extents);\n+    bool ret = klass->get.f.font_h_extents (this, user_data,\n+                                            extents,\n+                                            !klass->user_data ? nullptr : klass->user_data->font_h_extents);\n+\n+    if (synthetic && ret)\n+    {\n+      \/* Embolden *\/\n+      int y_shift = y_scale < 0 ? -y_strength : y_strength;\n+      extents->ascender += y_shift;\n+    }\n+\n+    return ret;\n@@ -260,1 +286,2 @@\n-  hb_bool_t get_font_v_extents (hb_font_extents_t *extents)\n+  hb_bool_t get_font_v_extents (hb_font_extents_t *extents,\n+                                bool synthetic = true)\n@@ -263,3 +290,18 @@\n-    return klass->get.f.font_v_extents (this, user_data,\n-                                        extents,\n-                                        !klass->user_data ? nullptr : klass->user_data->font_v_extents);\n+    bool ret = klass->get.f.font_v_extents (this, user_data,\n+                                            extents,\n+                                            !klass->user_data ? nullptr : klass->user_data->font_v_extents);\n+\n+    if (synthetic && ret)\n+    {\n+      \/* Embolden *\/\n+      int x_shift = x_scale < 0 ? -x_strength : x_strength;\n+      if (embolden_in_place)\n+      {\n+        extents->ascender += x_shift \/ 2;\n+        extents->descender -= x_shift - x_shift \/ 2;\n+      }\n+      else\n+        extents->ascender += x_shift;\n+    }\n+\n+    return ret;\n@@ -306,1 +348,2 @@\n-  hb_position_t get_glyph_h_advance (hb_codepoint_t glyph)\n+  hb_position_t get_glyph_h_advance (hb_codepoint_t glyph,\n+                                     bool synthetic = true)\n@@ -308,3 +351,12 @@\n-    return klass->get.f.glyph_h_advance (this, user_data,\n-                                         glyph,\n-                                         !klass->user_data ? nullptr : klass->user_data->glyph_h_advance);\n+    hb_position_t advance = klass->get.f.glyph_h_advance (this, user_data,\n+                                                          glyph,\n+                                                          !klass->user_data ? nullptr : klass->user_data->glyph_h_advance);\n+\n+    if (synthetic && x_strength && !embolden_in_place)\n+    {\n+      \/* Embolden *\/\n+      hb_position_t strength = x_scale >= 0 ? x_strength : -x_strength;\n+      advance += advance ? strength : 0;\n+    }\n+\n+    return advance;\n@@ -313,1 +365,2 @@\n-  hb_position_t get_glyph_v_advance (hb_codepoint_t glyph)\n+  hb_position_t get_glyph_v_advance (hb_codepoint_t glyph,\n+                                     bool synthetic = true)\n@@ -315,3 +368,12 @@\n-    return klass->get.f.glyph_v_advance (this, user_data,\n-                                         glyph,\n-                                         !klass->user_data ? nullptr : klass->user_data->glyph_v_advance);\n+    hb_position_t advance = klass->get.f.glyph_v_advance (this, user_data,\n+                                                          glyph,\n+                                                          !klass->user_data ? nullptr : klass->user_data->glyph_v_advance);\n+\n+    if (synthetic && y_strength && !embolden_in_place)\n+    {\n+      \/* Embolden *\/\n+      hb_position_t strength = y_scale >= 0 ? y_strength : -y_strength;\n+      advance += advance ? strength : 0;\n+    }\n+\n+    return advance;\n@@ -324,1 +386,2 @@\n-                             unsigned int advance_stride)\n+                             unsigned int advance_stride,\n+                             bool synthetic = true)\n@@ -326,5 +389,16 @@\n-    return klass->get.f.glyph_h_advances (this, user_data,\n-                                          count,\n-                                          first_glyph, glyph_stride,\n-                                          first_advance, advance_stride,\n-                                          !klass->user_data ? nullptr : klass->user_data->glyph_h_advances);\n+    klass->get.f.glyph_h_advances (this, user_data,\n+                                   count,\n+                                   first_glyph, glyph_stride,\n+                                   first_advance, advance_stride,\n+                                   !klass->user_data ? nullptr : klass->user_data->glyph_h_advances);\n+\n+    if (synthetic && x_strength && !embolden_in_place)\n+    {\n+      \/* Embolden *\/\n+      hb_position_t strength = x_scale >= 0 ? x_strength : -x_strength;\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        *first_advance += *first_advance ? strength : 0;\n+        first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+      }\n+    }\n@@ -337,1 +411,2 @@\n-                             unsigned int advance_stride)\n+                             unsigned int advance_stride,\n+                             bool synthetic = true)\n@@ -339,5 +414,16 @@\n-    return klass->get.f.glyph_v_advances (this, user_data,\n-                                          count,\n-                                          first_glyph, glyph_stride,\n-                                          first_advance, advance_stride,\n-                                          !klass->user_data ? nullptr : klass->user_data->glyph_v_advances);\n+    klass->get.f.glyph_v_advances (this, user_data,\n+                                   count,\n+                                   first_glyph, glyph_stride,\n+                                   first_advance, advance_stride,\n+                                   !klass->user_data ? nullptr : klass->user_data->glyph_v_advances);\n+\n+    if (synthetic && y_strength && !embolden_in_place)\n+    {\n+      \/* Embolden *\/\n+      hb_position_t strength = y_scale >= 0 ? y_strength : -y_strength;\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        *first_advance += *first_advance ? strength : 0;\n+        first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+      }\n+    }\n@@ -389,1 +475,2 @@\n-                               hb_glyph_extents_t *extents)\n+                               hb_glyph_extents_t *extents,\n+                               bool synthetic = true)\n@@ -392,4 +479,45 @@\n-    return klass->get.f.glyph_extents (this, user_data,\n-                                       glyph,\n-                                       extents,\n-                                       !klass->user_data ? nullptr : klass->user_data->glyph_extents);\n+\n+    \/* This is rather messy, but necessary. *\/\n+\n+    if (!synthetic)\n+    {\n+      return klass->get.f.glyph_extents (this, user_data,\n+                                         glyph,\n+                                         extents,\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_extents);\n+    }\n+    if (!is_synthetic () &&\n+        klass->get.f.glyph_extents (this, user_data,\n+                                    glyph,\n+                                    extents,\n+                                    !klass->user_data ? nullptr : klass->user_data->glyph_extents))\n+      return true;\n+\n+    \/* Try getting extents from paint(), then draw(), *then* get_extents()\n+     * and apply synthetic settings in the last case. *\/\n+\n+    hb_paint_extents_context_t paint_extents;\n+    if (paint_glyph_or_fail (glyph,\n+                             hb_paint_extents_get_funcs (), &paint_extents,\n+                             0, 0))\n+    {\n+      *extents = paint_extents.get_extents ().to_glyph_extents ();\n+      return true;\n+    }\n+\n+    hb_extents_t draw_extents;\n+    if (draw_glyph_or_fail (glyph,\n+                            hb_draw_extents_get_funcs (), &draw_extents))\n+    {\n+      *extents = draw_extents.to_glyph_extents ();\n+      return true;\n+    }\n+\n+    bool ret = klass->get.f.glyph_extents (this, user_data,\n+                                           glyph,\n+                                           extents,\n+                                           !klass->user_data ? nullptr : klass->user_data->glyph_extents);\n+    if (ret)\n+      synthetic_glyph_extents (extents);\n+\n+    return ret;\n@@ -399,1 +527,2 @@\n-                                     hb_position_t *x, hb_position_t *y)\n+                                     hb_position_t *x, hb_position_t *y,\n+                                     bool synthetic = true)\n@@ -402,4 +531,20 @@\n-    return klass->get.f.glyph_contour_point (this, user_data,\n-                                             glyph, point_index,\n-                                             x, y,\n-                                             !klass->user_data ? nullptr : klass->user_data->glyph_contour_point);\n+    bool ret = klass->get.f.glyph_contour_point (this, user_data,\n+                                                 glyph, point_index,\n+                                                 x, y,\n+                                                 !klass->user_data ? nullptr : klass->user_data->glyph_contour_point);\n+\n+    if (synthetic && ret)\n+    {\n+      \/* Slant *\/\n+      if (slant_xy)\n+        *x += roundf (*y * slant_xy);\n+\n+      \/* Embolden *\/\n+      if (!embolden_in_place)\n+      {\n+        int x_shift = x_scale < 0 ? -x_strength : x_strength;\n+        *x += x_shift;\n+      }\n+    }\n+\n+    return ret;\n@@ -429,2 +574,3 @@\n-  void draw_glyph (hb_codepoint_t glyph,\n-                   hb_draw_funcs_t *draw_funcs, void *draw_data)\n+  bool draw_glyph_or_fail (hb_codepoint_t glyph,\n+                           hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                           bool synthetic = true)\n@@ -432,4 +578,43 @@\n-    klass->get.f.draw_glyph (this, user_data,\n-                             glyph,\n-                             draw_funcs, draw_data,\n-                             !klass->user_data ? nullptr : klass->user_data->draw_glyph);\n+#ifndef HB_NO_OUTLINE\n+    bool embolden = x_strength || y_strength;\n+    bool slanted = slant_xy;\n+    synthetic = synthetic && (embolden || slanted);\n+#else\n+    synthetic = false;\n+#endif\n+\n+    if (!synthetic)\n+    {\n+      return klass->get.f.draw_glyph_or_fail (this, user_data,\n+                                              glyph,\n+                                              draw_funcs, draw_data,\n+                                              !klass->user_data ? nullptr : klass->user_data->draw_glyph_or_fail);\n+    }\n+\n+#ifndef HB_NO_OUTLINE\n+\n+    hb_outline_t outline;\n+    if (!klass->get.f.draw_glyph_or_fail (this, user_data,\n+                                          glyph,\n+                                          hb_outline_recording_pen_get_funcs (), &outline,\n+                                          !klass->user_data ? nullptr : klass->user_data->draw_glyph_or_fail))\n+      return false;\n+\n+    \/\/ Slant before embolden; produces nicer results.\n+\n+    if (slanted)\n+      outline.slant (slant_xy);\n+\n+    if (embolden)\n+    {\n+      float x_shift = embolden_in_place ? 0 : (float) x_strength \/ 2;\n+      float y_shift = (float) y_strength \/ 2;\n+      if (x_scale < 0) x_shift = -x_shift;\n+      if (y_scale < 0) y_shift = -y_shift;\n+      outline.embolden (x_strength, y_strength, x_shift, y_shift);\n+    }\n+\n+    outline.replay (draw_funcs, draw_data);\n+\n+    return true;\n+#endif\n@@ -438,4 +623,5 @@\n-  void paint_glyph (hb_codepoint_t glyph,\n-                    hb_paint_funcs_t *paint_funcs, void *paint_data,\n-                    unsigned int palette,\n-                    hb_color_t foreground)\n+  bool paint_glyph_or_fail (hb_codepoint_t glyph,\n+                            hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                            unsigned int palette,\n+                            hb_color_t foreground,\n+                            bool synthetic = true)\n@@ -443,5 +629,17 @@\n-    klass->get.f.paint_glyph (this, user_data,\n-                              glyph,\n-                              paint_funcs, paint_data,\n-                              palette, foreground,\n-                              !klass->user_data ? nullptr : klass->user_data->paint_glyph);\n+    \/* Slant *\/\n+    if (synthetic && slant_xy)\n+      hb_paint_push_transform (paint_funcs, paint_data,\n+                               1.f, 0.f,\n+                               slant_xy, 1.f,\n+                               0.f, 0.f);\n+\n+    bool ret = klass->get.f.paint_glyph_or_fail (this, user_data,\n+                                                 glyph,\n+                                                 paint_funcs, paint_data,\n+                                                 palette, foreground,\n+                                                 !klass->user_data ? nullptr : klass->user_data->paint_glyph_or_fail);\n+\n+    if (synthetic && slant_xy)\n+      hb_paint_pop_transform (paint_funcs, paint_data);\n+\n+    return ret;\n@@ -452,0 +650,6 @@\n+  HB_INTERNAL\n+  void paint_glyph (hb_codepoint_t glyph,\n+                    hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                    unsigned int palette,\n+                    hb_color_t foreground);\n+\n@@ -689,1 +893,6 @@\n-  void mults_changed ()\n+  bool is_synthetic () const\n+  {\n+    return x_embolden || y_embolden || slant;\n+  }\n+\n+  void changed ()\n@@ -700,2 +909,2 @@\n-    x_strength = fabsf (roundf (x_scale * x_embolden));\n-    y_strength = fabsf (roundf (y_scale * y_embolden));\n+    x_strength = roundf (abs (x_scale) * x_embolden);\n+    y_strength = roundf (abs (y_scale) * y_embolden);\n@@ -706,0 +915,2 @@\n+\n+    serial++;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.hh","additions":283,"deletions":72,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-#ifndef HB_NO_AAT\n-#include \"hb-aat-layout-trak-table.hh\"\n-#endif\n@@ -44,1 +41,0 @@\n-#include \"hb-ot-stat-table.hh\"\n@@ -104,1 +100,1 @@\n-  mutable unsigned cached_serial;\n+  mutable hb_atomic_t<unsigned> cached_serial;\n@@ -121,1 +117,1 @@\n-  ft_font->cached_serial = (unsigned) -1;\n+  ft_font->cached_serial = UINT_MAX;\n@@ -216,0 +212,1 @@\n+    hb_lock_t lock (ft_font->lock);\n@@ -218,1 +215,1 @@\n-    ft_font->cached_serial = font->serial;\n+    ft_font->cached_serial.set_release (font->serial.get_acquire ());\n@@ -481,1 +478,2 @@\n-  hb_position_t *orig_first_advance = first_advance;\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -522,32 +520,0 @@\n-\n-  if (font->x_strength && !font->embolden_in_place)\n-  {\n-    \/* Emboldening. *\/\n-    hb_position_t x_strength = font->x_scale >= 0 ? font->x_strength : -font->x_strength;\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += *first_advance ? x_strength : 0;\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n-  }\n-\n-#ifndef HB_NO_AAT\n-  \/* According to Ned, trak is applied by default for \"modern fonts\", as detected by presence of STAT table. *\/\n-#ifndef HB_NO_STYLE\n-  bool apply_trak = font->face->table.STAT->has_data () && font->face->table.trak->has_data ();\n-#else\n-  bool apply_trak = false;\n-#endif\n-  if (apply_trak)\n-  {\n-    hb_position_t tracking = font->face->table.trak->get_h_tracking (font);\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += tracking;\n-      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n-  }\n-#endif\n@@ -564,0 +530,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -584,2 +552,0 @@\n-  v = (int) (y_mult * v);\n-\n@@ -588,0 +554,1 @@\n+  v = ((-v + (1<<9)) >> 10);\n@@ -589,15 +556,1 @@\n-  hb_position_t y_strength = font->y_scale >= 0 ? font->y_strength : -font->y_strength;\n-  v = ((-v + (1<<9)) >> 10) + (font->embolden_in_place ? 0 : y_strength);\n-\n-#ifndef HB_NO_AAT\n-  \/* According to Ned, trak is applied by default for \"modern fonts\", as detected by presence of STAT table. *\/\n-#ifndef HB_NO_STYLE\n-  bool apply_trak = font->face->table.STAT->has_data () && font->face->table.trak->has_data ();\n-#else\n-  bool apply_trak = false;\n-#endif\n-  if (apply_trak)\n-    v += font->face->table.trak->get_v_tracking (font);\n-#endif\n-\n-  return v;\n+  return (hb_position_t) (y_mult * v);\n@@ -617,0 +570,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -661,0 +616,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -672,0 +629,35 @@\n+static bool\n+hb_ft_is_colr_glyph (hb_font_t *font,\n+                     void *font_data,\n+                     hb_codepoint_t gid)\n+{\n+#ifndef HB_NO_PAINT\n+#if (FREETYPE_MAJOR*10000 + FREETYPE_MINOR*100 + FREETYPE_PATCH) >= 21300\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+\n+  \/* COLRv1 *\/\n+  FT_OpaquePaint paint = {0};\n+  if (FT_Get_Color_Glyph_Paint (ft_face, gid,\n+                                FT_COLOR_NO_ROOT_TRANSFORM,\n+                                &paint))\n+    return true;\n+\n+  \/* COLRv0 *\/\n+  FT_LayerIterator  iterator;\n+  FT_UInt  layer_glyph_index;\n+  FT_UInt  layer_color_index;\n+  iterator.p  = NULL;\n+  if (FT_Get_Color_Glyph_Layer (ft_face,\n+                                gid,\n+                                &layer_glyph_index,\n+                                &layer_color_index,\n+                                &iterator))\n+    return true;\n+#endif\n+#endif\n+\n+  return false;\n+}\n+\n@@ -679,0 +671,4 @@\n+  \/\/ FreeType doesn't return COLR glyph extents.\n+  if (hb_ft_is_colr_glyph (font, font_data, glyph))\n+    return false;\n+\n@@ -680,0 +676,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -683,1 +681,1 @@\n-  float slant_xy = font->slant_xy;\n+\n@@ -711,27 +709,4 @@\n-  \/* Apply slant. *\/\n-  if (slant_xy)\n-  {\n-    x1 += hb_min (y1 * slant_xy, y2 * slant_xy);\n-    x2 += hb_max (y1 * slant_xy, y2 * slant_xy);\n-  }\n-\n-  extents->x_bearing = floorf (x1);\n-  extents->y_bearing = floorf (y1);\n-  extents->width = ceilf (x2) - extents->x_bearing;\n-  extents->height = ceilf (y2) - extents->y_bearing;\n-\n-  if (font->x_strength || font->y_strength)\n-  {\n-    \/* Y *\/\n-    int y_shift = font->y_strength;\n-    if (font->y_scale < 0) y_shift = -y_shift;\n-    extents->y_bearing += y_shift;\n-    extents->height -= y_shift;\n-\n-    \/* X *\/\n-    int x_shift = font->x_strength;\n-    if (font->x_scale < 0) x_shift = -x_shift;\n-    if (font->embolden_in_place)\n-      extents->x_bearing -= x_shift \/ 2;\n-    extents->width += x_shift;\n-  }\n+  extents->x_bearing = roundf (x1);\n+  extents->y_bearing = roundf (y1);\n+  extents->width = roundf (x2) - extents->x_bearing;\n+  extents->height = roundf (y2) - extents->y_bearing;\n@@ -752,0 +727,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -829,0 +806,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -860,1 +839,1 @@\n-  metrics->ascender  = (hb_position_t) (y_mult * (metrics->ascender + font->y_strength));\n+  metrics->ascender  = (hb_position_t) (y_mult * metrics->ascender);\n@@ -911,6 +890,6 @@\n-static void\n-hb_ft_draw_glyph (hb_font_t *font,\n-                  void *font_data,\n-                  hb_codepoint_t glyph,\n-                  hb_draw_funcs_t *draw_funcs, void *draw_data,\n-                  void *user_data HB_UNUSED)\n+static hb_bool_t\n+hb_ft_draw_glyph_or_fail (hb_font_t *font,\n+                          void *font_data,\n+                          hb_codepoint_t glyph,\n+                          hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                          void *user_data HB_UNUSED)\n@@ -919,0 +898,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -924,1 +905,1 @@\n-    return;\n+    return false;\n@@ -927,1 +908,1 @@\n-    return;\n+    return false;\n@@ -938,33 +919,1 @@\n-  hb_draw_session_t draw_session (draw_funcs, draw_data, font->slant_xy);\n-\n-  \/* Embolden *\/\n-  if (font->x_strength || font->y_strength)\n-  {\n-    FT_Outline_EmboldenXY (&ft_face->glyph->outline, font->x_strength, font->y_strength);\n-\n-    int x_shift = 0;\n-    int y_shift = 0;\n-    if (font->embolden_in_place)\n-    {\n-      \/* Undo the FreeType shift. *\/\n-      x_shift = -font->x_strength \/ 2;\n-      y_shift = 0;\n-      if (font->y_scale < 0) y_shift = -font->y_strength;\n-    }\n-    else\n-    {\n-      \/* FreeType applied things in the wrong direction for negative scale; fix up. *\/\n-      if (font->x_scale < 0) x_shift = -font->x_strength;\n-      if (font->y_scale < 0) y_shift = -font->y_strength;\n-    }\n-    if (x_shift || y_shift)\n-    {\n-      auto &outline = ft_face->glyph->outline;\n-      for (auto &point : hb_iter (outline.points, outline.contours[outline.n_contours - 1] + 1))\n-      {\n-        point.x += x_shift;\n-        point.y += y_shift;\n-      }\n-    }\n-  }\n-\n+  hb_draw_session_t draw_session {draw_funcs, draw_data};\n@@ -975,0 +924,2 @@\n+\n+  return true;\n@@ -983,8 +934,8 @@\n-static void\n-hb_ft_paint_glyph (hb_font_t *font,\n-                   void *font_data,\n-                   hb_codepoint_t gid,\n-                   hb_paint_funcs_t *paint_funcs, void *paint_data,\n-                   unsigned int palette_index,\n-                   hb_color_t foreground,\n-                   void *user_data)\n+static hb_bool_t\n+hb_ft_paint_glyph_or_fail (hb_font_t *font,\n+                           void *font_data,\n+                           hb_codepoint_t gid,\n+                           hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                           unsigned int palette_index,\n+                           hb_color_t foreground,\n+                           void *user_data)\n@@ -993,0 +944,2 @@\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n@@ -996,1 +949,1 @@\n-  FT_Long load_flags = ft_font->load_flags | FT_LOAD_NO_BITMAP | FT_LOAD_COLOR;\n+  FT_Long load_flags = ft_font->load_flags | FT_LOAD_COLOR;\n@@ -1005,1 +958,1 @@\n-    return;\n+    return false;\n@@ -1013,8 +966,1 @@\n-      return;\n-\n-    \/* Simple outline. *\/\n-    ft_font->lock.unlock ();\n-    paint_funcs->push_clip_glyph (paint_data, gid, font);\n-    ft_font->lock.lock ();\n-    paint_funcs->color (paint_data, true, foreground);\n-    paint_funcs->pop_clip (paint_data);\n+      return true;\n@@ -1022,1 +968,2 @@\n-    return;\n+    \/\/ Outline glyph\n+    return false;\n@@ -1028,0 +975,1 @@\n+    bool ret = false;\n@@ -1032,1 +980,1 @@\n-        return;\n+        return ret;\n@@ -1042,1 +990,1 @@\n-      if (!hb_font_get_glyph_extents (font, gid, &extents))\n+      if (!font->get_glyph_extents (gid, &extents, false))\n@@ -1045,10 +993,8 @@\n-      if (!paint_funcs->image (paint_data,\n-                               blob,\n-                               bitmap.width,\n-                               bitmap.rows,\n-                               HB_PAINT_IMAGE_FORMAT_BGRA,\n-                               font->slant_xy,\n-                               &extents))\n-      {\n-        \/* TODO Try a forced outline load and paint? *\/\n-      }\n+      if (paint_funcs->image (paint_data,\n+                              blob,\n+                              bitmap.width,\n+                              bitmap.rows,\n+                              HB_PAINT_IMAGE_FORMAT_BGRA,\n+                              0.f,\n+                              &extents))\n+        ret = true;\n@@ -1061,1 +1007,1 @@\n-    return;\n+    return ret;\n@@ -1063,0 +1009,1 @@\n+  return false;\n@@ -1082,1 +1029,0 @@\n-    \/\/hb_font_funcs_set_glyph_h_origin_func (funcs, hb_ft_get_glyph_h_origin, nullptr, nullptr);\n@@ -1085,1 +1031,0 @@\n-    \/\/hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);\n@@ -1093,1 +1038,0 @@\n-    \/\/hb_font_funcs_set_glyph_v_kerning_func (funcs, hb_ft_get_glyph_v_kerning, nullptr, nullptr);\n@@ -1100,1 +1044,1 @@\n-    hb_font_funcs_set_draw_glyph_func (funcs, hb_ft_draw_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_draw_glyph_or_fail_func (funcs, hb_ft_draw_glyph_or_fail, nullptr, nullptr);\n@@ -1105,1 +1049,1 @@\n-    hb_font_funcs_set_paint_glyph_func (funcs, hb_ft_paint_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_paint_glyph_or_fail_func (funcs, hb_ft_paint_glyph_or_fail, nullptr, nullptr);\n@@ -1459,0 +1403,4 @@\n+ * Note that as of version 11.0.0, calling this function is not necessary,\n+ * as HarfBuzz will automatically detect changes to the font and update\n+ * the underlying FT_Face as needed.\n+ *\n@@ -1590,1 +1538,2 @@\n- * but uses the FreeType library for loading the font file.\n+ * but uses the FreeType library for loading the font file. This can\n+ * be useful, for example, to load WOFF and WOFF2 font data.\n@@ -1627,0 +1576,69 @@\n+static hb_user_data_key_t ft_blob_key = {0};\n+\n+static void\n+_destroy_blob (void *p)\n+{\n+  hb_blob_destroy ((hb_blob_t *) p);\n+}\n+\n+\/**\n+ * hb_ft_face_create_from_blob_or_fail:\n+ * @blob: A blob\n+ * @index: The index of the face within the blob\n+ *\n+ * Creates an #hb_face_t face object from the specified\n+ * font blob and face index.\n+ *\n+ * This is similar in functionality to hb_face_create_from_blob_or_fail(),\n+ * but uses the FreeType library for loading the font blob. This can\n+ * be useful, for example, to load WOFF and WOFF2 font data.\n+ *\n+ * Return value: (transfer full): The new face object, or `NULL` if\n+ * loading fails (eg. blob does not contain valid font data).\n+ *\n+ * Since: 11.0.0\n+ *\/\n+hb_face_t *\n+hb_ft_face_create_from_blob_or_fail (hb_blob_t    *blob,\n+                                     unsigned int  index)\n+{\n+  FT_Library ft_library = reference_ft_library ();\n+  if (unlikely (!ft_library))\n+  {\n+    DEBUG_MSG (FT, ft_library, \"reference_ft_library failed\");\n+    return nullptr;\n+  }\n+\n+  hb_blob_make_immutable (blob);\n+  unsigned blob_size;\n+  const char *blob_data = hb_blob_get_data (blob, &blob_size);\n+\n+  FT_Face ft_face;\n+  if (unlikely (FT_New_Memory_Face (ft_library,\n+                                    (const FT_Byte *) blob_data,\n+                                    blob_size,\n+                                    index,\n+                                    &ft_face)))\n+    return nullptr;\n+\n+  hb_face_t *face = hb_ft_face_create_referenced (ft_face);\n+  FT_Done_Face (ft_face);\n+\n+  ft_face->generic.data = ft_library;\n+  ft_face->generic.finalizer = finalize_ft_library;\n+\n+  if (hb_face_is_immutable (face))\n+    return nullptr;\n+\n+  \/\/ Hook the blob to the hb_face_t, since FT_Face still needs it.\n+  hb_blob_reference (blob);\n+  if (!hb_face_set_user_data (face, &ft_blob_key, blob, _destroy_blob, true))\n+  {\n+    hb_blob_destroy (blob);\n+    hb_face_destroy (face);\n+    return nullptr;\n+  }\n+\n+  return face;\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.cc","additions":183,"deletions":165,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+HB_EXTERN hb_face_t *\n+hb_ft_face_create_from_blob_or_fail (hb_blob_t    *blob,\n+                                     unsigned int  index);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,5 @@\n+  hb_extents_t (const hb_glyph_extents_t &extents) :\n+                xmin (hb_min (extents.x_bearing, extents.x_bearing + extents.width)),\n+                ymin (hb_min (extents.y_bearing, extents.y_bearing + extents.height)),\n+                xmax (hb_max (extents.x_bearing, extents.x_bearing + extents.width)),\n+                ymax (hb_max (extents.y_bearing, extents.y_bearing + extents.height)) {}\n@@ -41,0 +46,6 @@\n+    if (o.is_empty ()) return;\n+    if (is_empty ())\n+    {\n+      *this = o;\n+      return;\n+    }\n@@ -49,0 +60,5 @@\n+    if (o.is_empty () || is_empty ())\n+    {\n+      *this = hb_extents_t {};\n+      return;\n+    }\n@@ -72,0 +88,12 @@\n+  hb_glyph_extents_t to_glyph_extents (bool xneg = false, bool yneg = false) const\n+  {\n+    hb_position_t x0 = (hb_position_t) roundf (xmin);\n+    hb_position_t y0 = (hb_position_t) roundf (ymin);\n+    hb_position_t x1 = (hb_position_t) roundf (xmax);\n+    hb_position_t y1 = (hb_position_t) roundf (ymax);\n+    return hb_glyph_extents_t {xneg ? x1 : x0,\n+                               yneg ? y0 : y1,\n+                               xneg ? x0 - x1 : x1 - x0,\n+                               yneg ? y1 - y0 : y0 - y1};\n+  }\n+\n@@ -221,1 +249,1 @@\n-  hb_bounds_t (status_t status) : status (status) {}\n+  hb_bounds_t (status_t status = UNBOUNDED) : status (status) {}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-geometry.hh","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-  hb_atomic_ptr_t<Stored *> instance;\n+  mutable hb_atomic_t<Stored *> instance;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-machinery.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  hb_mutex_t (const hb_mutex_t &) = delete;\n+  hb_mutex_t &operator= (const hb_mutex_t &) = delete;\n@@ -117,0 +119,4 @@\n+\n+  hb_lock_t (const hb_lock_t &) = delete;\n+  hb_lock_t &operator= (const hb_lock_t &) = delete;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-mutex.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  mutable hb_atomic_int_t ref_count;\n+  mutable hb_atomic_t<int> ref_count;\n@@ -216,2 +216,2 @@\n-  mutable hb_atomic_int_t writable = 0;\n-  hb_atomic_ptr_t<hb_user_data_array_t> user_data;\n+  mutable hb_atomic_t<bool> writable = false;\n+  hb_atomic_t<hb_user_data_array_t *> user_data;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-object.hh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1891,1 +1891,1 @@\n-      if (likely (run_count > 0)) return true;\n+      if (run_count > 0) return true;\n@@ -1946,0 +1946,5 @@\n+          case 0:\n+          {\n+            arrayZ += count;\n+            break;\n+          }\n@@ -1961,0 +1966,2 @@\n+\n+            p = (const unsigned char *) pp;\n@@ -1978,0 +1985,2 @@\n+\n+            p = (const unsigned char *) pp;\n@@ -1985,0 +1994,2 @@\n+\n+            p = (const unsigned char *) pp;\n@@ -1988,1 +1999,0 @@\n-        p += count * width;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-open-type.hh","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1076,1 +1076,1 @@\n-      \/* setup for run-time santization *\/\n+      \/* setup for run-time sanitization *\/\n@@ -1179,1 +1179,2 @@\n-          if (unlikely (privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n+          if (unlikely (font->privateDictInfo.size &&\n+                        privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n@@ -1194,1 +1195,2 @@\n-        if (unlikely (privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n+        if (font->privateDictInfo.size &&\n+            unlikely (privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n@@ -1486,1 +1488,1 @@\n-    mutable hb_atomic_ptr_t<hb_sorted_vector_t<gname_t>> glyph_names;\n+    mutable hb_atomic_t<hb_sorted_vector_t<gname_t> *> glyph_names;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff1-table.hh","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -105,0 +105,8 @@\n+{\n+  return get_extents_at (font, glyph, extents, hb_array (font->coords, font->num_coords));\n+}\n+\n+bool OT::cff2::accelerator_t::get_extents_at (hb_font_t *font,\n+                                              hb_codepoint_t glyph,\n+                                              hb_glyph_extents_t *extents,\n+                                              hb_array_t<const int> coords) const\n@@ -115,1 +123,1 @@\n-  cff2_cs_interp_env_t<number_t> env (str, *this, fd, font->coords, font->num_coords);\n+  cff2_cs_interp_env_t<number_t> env (str, *this, fd, coords.arrayZ, coords.length);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.cc","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-      \/* setup for run-time santization *\/\n+      \/* setup for run-time sanitization *\/\n@@ -461,1 +461,2 @@\n-        if (unlikely (privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n+        if (unlikely (font->privateDictInfo.size &&\n+                      privDictStr == (const unsigned char *) &Null (UnsizedByteStr))) goto fail;\n@@ -484,0 +485,7 @@\n+\n+      auto *scalars = cached_scalars_vector.get_acquire ();\n+      if (scalars && cached_scalars_vector.cmpexch (scalars, nullptr))\n+      {\n+        scalars->fini ();\n+        hb_free (scalars);\n+      }\n@@ -511,0 +519,2 @@\n+    mutable hb_atomic_t<hb_vector_t<float> *> cached_scalars_vector;\n+\n@@ -521,0 +531,4 @@\n+    HB_INTERNAL bool get_extents_at (hb_font_t *font,\n+                                     hb_codepoint_t glyph,\n+                                     hb_glyph_extents_t *extents,\n+                                     hb_array_t<const int> coords) const;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.hh","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2017,1 +2017,2 @@\n-    using cache_t = hb_cache_t<21, 16, 8, true>;\n+    using cache_t = hb_cache_t<21, 19>;\n+    static_assert (sizeof (cache_t) == 1024, \"\");\n@@ -2031,0 +2032,8 @@\n+#ifndef HB_NO_OT_FONT_CMAP_CACHE\n+      cache = (cache_t *) hb_malloc (sizeof (cache_t));\n+      if (cache)\n+        new (cache) cache_t ();\n+      else\n+        return; \/\/ Such that get_glyph_funcZ remains null.\n+#endif\n+\n@@ -2064,14 +2073,14 @@\n-        \/* Accelerate format 4 and format 12. *\/\n-        default:\n-          this->get_glyph_funcZ = get_glyph_from<CmapSubtable>;\n-          break;\n-        case 12:\n-          this->get_glyph_funcZ = get_glyph_from<CmapSubtableFormat12>;\n-          break;\n-        case  4:\n-        {\n-          this->format4_accel.init (&subtable->u.format4);\n-          this->get_glyph_data = &this->format4_accel;\n-          this->get_glyph_funcZ = this->format4_accel.get_glyph_func;\n-          break;\n-        }\n+          \/* Accelerate format 4 and format 12. *\/\n+          default:\n+            this->get_glyph_funcZ = get_glyph_from<CmapSubtable>;\n+            break;\n+          case 12:\n+            this->get_glyph_funcZ = get_glyph_from<CmapSubtableFormat12>;\n+            break;\n+          case  4:\n+          {\n+            this->format4_accel.init (&subtable->u.format4);\n+            this->get_glyph_data = &this->format4_accel;\n+            this->get_glyph_funcZ = this->format4_accel.get_glyph_func;\n+            break;\n+          }\n@@ -2081,1 +2090,7 @@\n-    ~accelerator_t () { this->table.destroy (); }\n+    ~accelerator_t ()\n+    {\n+#ifndef HB_NO_OT_FONT_CMAP_CACHE\n+      hb_free (cache);\n+#endif\n+      table.destroy ();\n+    }\n@@ -2084,2 +2099,1 @@\n-                             hb_codepoint_t *glyph,\n-                             cache_t *cache) const\n+                             hb_codepoint_t *glyph) const\n@@ -2087,0 +2101,2 @@\n+#ifndef HB_NO_OT_FONT_CMAP_CACHE\n+      \/\/ cache is always non-null if we have a get_glyph_funcZ\n@@ -2088,1 +2104,1 @@\n-      if (cache && cache->get (unicode, &v))\n+      if (cache->get (unicode, &v))\n@@ -2093,0 +2109,1 @@\n+#endif\n@@ -2095,1 +2112,2 @@\n-      if (cache && ret)\n+#ifndef HB_NO_OT_FONT_CMAP_CACHE\n+      if (ret)\n@@ -2097,0 +2115,2 @@\n+#endif\n+\n@@ -2101,2 +2121,1 @@\n-                            hb_codepoint_t *glyph,\n-                            cache_t *cache = nullptr) const\n+                            hb_codepoint_t *glyph) const\n@@ -2105,1 +2124,1 @@\n-      return _cached_get (unicode, glyph, cache);\n+      return _cached_get (unicode, glyph);\n@@ -2112,2 +2131,1 @@\n-                                     unsigned int glyph_stride,\n-                                     cache_t *cache = nullptr) const\n+                                     unsigned int glyph_stride) const\n@@ -2119,1 +2137,1 @@\n-           done < count && _cached_get (*first_unicode, first_glyph, cache);\n+           done < count && _cached_get (*first_unicode, first_glyph);\n@@ -2130,2 +2148,1 @@\n-                              hb_codepoint_t *glyph,\n-                              cache_t *cache = nullptr) const\n+                              hb_codepoint_t *glyph) const\n@@ -2142,1 +2159,1 @@\n-      return get_nominal_glyph (unicode, glyph, cache);\n+      return get_nominal_glyph (unicode, glyph);\n@@ -2212,2 +2229,2 @@\n-    hb_cmap_get_glyph_func_t get_glyph_funcZ;\n-    const void *get_glyph_data;\n+    hb_cmap_get_glyph_func_t get_glyph_funcZ = nullptr;\n+    const void *get_glyph_data = nullptr;\n@@ -2217,0 +2234,4 @@\n+#ifndef HB_NO_OT_FONT_CMAP_CACHE\n+    cache_t *cache = nullptr;\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":52,"deletions":31,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  return face->table.COLR->has_v0_data ();\n+  return face->table.COLR->colr->has_v0_data ();\n@@ -224,1 +224,1 @@\n-  return face->table.COLR->has_v1_data ();\n+  return face->table.COLR->colr->has_v1_data ();\n@@ -243,1 +243,1 @@\n-  return face->table.COLR->has_paint_for_glyph (glyph);\n+  return face->table.COLR->colr->has_paint_for_glyph (glyph);\n@@ -269,1 +269,1 @@\n-  return face->table.COLR->get_glyph_layers (glyph, start_offset, layer_count, layers);\n+  return face->table.COLR->colr->get_glyph_layers (glyph, start_offset, layer_count, layers);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color.cc","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-HB_OT_CORE_TABLE (OT, COLR)\n+HB_OT_ACCELERATOR (OT, COLR)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face-table-list.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"OT\/Color\/COLR\/COLR.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face.cc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"hb-outline.hh\"\n@@ -39,3 +38,0 @@\n-#ifndef HB_NO_AAT\n-#include \"hb-aat-layout-trak-table.hh\"\n-#endif\n@@ -68,6 +64,2 @@\n-using hb_ot_font_cmap_cache_t    = hb_cache_t<21, 16, 8, true>;\n-using hb_ot_font_advance_cache_t = hb_cache_t<24, 16, 8, true>;\n-\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-static hb_user_data_key_t hb_ot_font_cmap_cache_user_data_key;\n-#endif\n+using hb_ot_font_advance_cache_t = hb_cache_t<24, 16>;\n+static_assert (sizeof (hb_ot_font_advance_cache_t) == 1024, \"\");\n@@ -79,3 +71,6 @@\n-#ifndef HB_NO_AAT\n-  bool apply_trak;\n-#endif\n+  \/* h_advance caching *\/\n+  mutable hb_atomic_t<int> cached_coords_serial;\n+  struct advance_cache_t\n+  {\n+    mutable hb_atomic_t<hb_ot_font_advance_cache_t *> advance_cache;\n+    mutable hb_atomic_t<OT::ItemVariationStore::cache_t *> varStore_cache;\n@@ -83,3 +78,4 @@\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-  hb_ot_font_cmap_cache_t *cmap_cache;\n-#endif\n+    ~advance_cache_t ()\n+    {\n+      clear ();\n+    }\n@@ -87,3 +83,86 @@\n-  \/* h_advance caching *\/\n-  mutable hb_atomic_int_t cached_coords_serial;\n-  mutable hb_atomic_ptr_t<hb_ot_font_advance_cache_t> advance_cache;\n+    hb_ot_font_advance_cache_t *acquire_advance_cache () const\n+    {\n+    retry:\n+      auto *cache = advance_cache.get_acquire ();\n+      if (!cache)\n+      {\n+        cache = (hb_ot_font_advance_cache_t *) hb_malloc (sizeof (hb_ot_font_advance_cache_t));\n+        if (!cache)\n+          return nullptr;\n+        new (cache) hb_ot_font_advance_cache_t;\n+        return cache;\n+      }\n+      if (advance_cache.cmpexch (cache, nullptr))\n+        return cache;\n+      else\n+        goto retry;\n+    }\n+    void release_advance_cache (hb_ot_font_advance_cache_t *cache) const\n+    {\n+      if (!cache)\n+        return;\n+      if (!advance_cache.cmpexch (nullptr, cache))\n+        hb_free (cache);\n+    }\n+    void clear_advance_cache () const\n+    {\n+    retry:\n+      auto *cache = advance_cache.get_acquire ();\n+      if (!cache)\n+        return;\n+      if (advance_cache.cmpexch (cache, nullptr))\n+        hb_free (cache);\n+      else\n+        goto retry;\n+    }\n+\n+    OT::ItemVariationStore::cache_t *acquire_varStore_cache (const OT::ItemVariationStore &varStore) const\n+    {\n+    retry:\n+      auto *cache = varStore_cache.get_acquire ();\n+      if (!cache)\n+        return varStore.create_cache ();\n+      if (varStore_cache.cmpexch (cache, nullptr))\n+        return cache;\n+      else\n+        goto retry;\n+    }\n+    void release_varStore_cache (OT::ItemVariationStore::cache_t *cache) const\n+    {\n+      if (!cache)\n+        return;\n+      if (!varStore_cache.cmpexch (nullptr, cache))\n+        OT::ItemVariationStore::destroy_cache (cache);\n+    }\n+    void clear_varStore_cache () const\n+    {\n+    retry:\n+      auto *cache = varStore_cache.get_acquire ();\n+      if (!cache)\n+        return;\n+      if (varStore_cache.cmpexch (cache, nullptr))\n+        OT::ItemVariationStore::destroy_cache (cache);\n+      else\n+        goto retry;\n+    }\n+\n+    void clear () const\n+    {\n+      clear_advance_cache ();\n+      clear_varStore_cache ();\n+    }\n+\n+  } h, v;\n+\n+  void check_serial (hb_font_t *font) const\n+  {\n+    int font_serial = font->serial_coords.get_acquire ();\n+\n+    if (cached_coords_serial.get_acquire () == font_serial)\n+      return;\n+\n+    h.clear ();\n+    v.clear ();\n+\n+    cached_coords_serial.set_release (font_serial);\n+  }\n@@ -101,38 +180,0 @@\n-#ifndef HB_NO_AAT\n-  \/* According to Ned, trak is applied by default for \"modern fonts\", as detected by presence of STAT table. *\/\n-#ifndef HB_NO_STYLE\n-  ot_font->apply_trak = font->face->table.STAT->has_data () && font->face->table.trak->has_data ();\n-#else\n-  ot_font->apply_trak = false;\n-#endif\n-#endif\n-\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-  \/\/ retry:\n-  auto *cmap_cache  = (hb_ot_font_cmap_cache_t *) hb_face_get_user_data (font->face,\n-                                                                         &hb_ot_font_cmap_cache_user_data_key);\n-  if (!cmap_cache)\n-  {\n-    cmap_cache = (hb_ot_font_cmap_cache_t *) hb_malloc (sizeof (hb_ot_font_cmap_cache_t));\n-    if (unlikely (!cmap_cache)) goto out;\n-    new (cmap_cache) hb_ot_font_cmap_cache_t ();\n-    if (unlikely (!hb_face_set_user_data (font->face,\n-                                          &hb_ot_font_cmap_cache_user_data_key,\n-                                          cmap_cache,\n-                                          hb_free,\n-                                          false)))\n-    {\n-      hb_free (cmap_cache);\n-      cmap_cache = nullptr;\n-      \/* Normally we would retry here, but that would\n-       * infinite-loop if the face is the empty-face.\n-       * Just let it go and this font will be uncached if it\n-       * happened to collide with another thread creating the\n-       * cache at the same time. *\/\n-      \/\/ goto retry;\n-    }\n-  }\n-  out:\n-  ot_font->cmap_cache = cmap_cache;\n-#endif\n-\n@@ -147,2 +188,1 @@\n-  auto *cache = ot_font->advance_cache.get_relaxed ();\n-  hb_free (cache);\n+  ot_font->~hb_ot_font_t ();\n@@ -162,5 +202,1 @@\n-  hb_ot_font_cmap_cache_t *cmap_cache = nullptr;\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-  cmap_cache = ot_font->cmap_cache;\n-#endif\n-  return ot_face->cmap->get_nominal_glyph (unicode, glyph, cmap_cache);\n+  return ot_face->cmap->get_nominal_glyph (unicode, glyph);\n@@ -181,4 +217,0 @@\n-  hb_ot_font_cmap_cache_t *cmap_cache = nullptr;\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-  cmap_cache = ot_font->cmap_cache;\n-#endif\n@@ -187,2 +219,1 @@\n-                                            first_glyph, glyph_stride,\n-                                            cmap_cache);\n+                                            first_glyph, glyph_stride);\n@@ -201,4 +232,0 @@\n-  hb_ot_font_cmap_cache_t *cmap_cache = nullptr;\n-#ifndef HB_NO_OT_FONT_CMAP_CACHE\n-  cmap_cache = ot_font->cmap_cache;\n-#endif\n@@ -206,2 +233,1 @@\n-                                             variation_selector, glyph,\n-                                             cmap_cache);\n+                                             variation_selector, glyph);\n@@ -219,0 +245,1 @@\n+\n@@ -223,3 +250,1 @@\n-  hb_position_t *orig_first_advance = first_advance;\n-\n-#if !defined(HB_NO_VAR) && !defined(HB_NO_OT_FONT_ADVANCE_CACHE)\n+  ot_font->check_serial (font);\n@@ -228,1 +253,1 @@\n-  OT::ItemVariationStore::cache_t *varStore_cache = font->num_coords * count >= 128 ? varStore.create_cache () : nullptr;\n+  OT::ItemVariationStore::cache_t *varStore_cache = ot_font->h.acquire_varStore_cache (varStore);\n@@ -230,5 +255,1 @@\n-  bool use_cache = font->num_coords;\n-#else\n-  OT::ItemVariationStore::cache_t *varStore_cache = nullptr;\n-  bool use_cache = false;\n-#endif\n+  hb_ot_font_advance_cache_t *advance_cache = nullptr;\n@@ -236,1 +257,1 @@\n-  hb_ot_font_advance_cache_t *cache = nullptr;\n+  bool use_cache = font->num_coords;\n@@ -239,19 +260,3 @@\n-  retry:\n-    cache = ot_font->advance_cache.get_acquire ();\n-    if (unlikely (!cache))\n-    {\n-      cache = (hb_ot_font_advance_cache_t *) hb_malloc (sizeof (hb_ot_font_advance_cache_t));\n-      if (unlikely (!cache))\n-      {\n-        use_cache = false;\n-        goto out;\n-      }\n-      new (cache) hb_ot_font_advance_cache_t;\n-\n-      if (unlikely (!ot_font->advance_cache.cmpexch (nullptr, cache)))\n-      {\n-        hb_free (cache);\n-        goto retry;\n-      }\n-      ot_font->cached_coords_serial.set_release (font->serial_coords);\n-    }\n+    advance_cache = ot_font->h.acquire_advance_cache ();\n+    if (!advance_cache)\n+      use_cache = false;\n@@ -259,1 +264,0 @@\n-  out:\n@@ -272,6 +276,0 @@\n-    if (ot_font->cached_coords_serial.get_acquire () != (int) font->serial_coords)\n-    {\n-      ot_font->advance_cache->clear ();\n-      ot_font->cached_coords_serial.set_release (font->serial_coords);\n-    }\n-\n@@ -282,1 +280,1 @@\n-      if (ot_font->advance_cache->get (*first_glyph, &cv))\n+      if (advance_cache->get (*first_glyph, &cv))\n@@ -287,1 +285,1 @@\n-        ot_font->advance_cache->set (*first_glyph, v);\n+        advance_cache->set (*first_glyph, v);\n@@ -293,5 +291,0 @@\n-  }\n-\n-#if !defined(HB_NO_VAR) && !defined(HB_NO_OT_FONT_ADVANCE_CACHE)\n-  OT::ItemVariationStore::destroy_cache (varStore_cache);\n-#endif\n@@ -299,10 +292,1 @@\n-  if (font->x_strength && !font->embolden_in_place)\n-  {\n-    \/* Emboldening. *\/\n-    hb_position_t x_strength = font->x_scale >= 0 ? font->x_strength : -font->x_strength;\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += *first_advance ? x_strength : 0;\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n+    ot_font->h.release_advance_cache (advance_cache);\n@@ -311,13 +295,1 @@\n-#ifndef HB_NO_AAT\n-  if (ot_font->apply_trak)\n-  {\n-    hb_position_t tracking = font->face->table.trak->get_h_tracking (font);\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += tracking;\n-      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n-  }\n-#endif\n+  ot_font->h.release_varStore_cache (varStore_cache);\n@@ -340,2 +312,0 @@\n-  hb_position_t *orig_first_advance = first_advance;\n-\n@@ -344,1 +314,1 @@\n-#if !defined(HB_NO_VAR) && !defined(HB_NO_OT_FONT_ADVANCE_CACHE)\n+    ot_font->check_serial (font);\n@@ -347,4 +317,2 @@\n-    OT::ItemVariationStore::cache_t *varStore_cache = font->num_coords ? varStore.create_cache () : nullptr;\n-#else\n-    OT::ItemVariationStore::cache_t *varStore_cache = nullptr;\n-#endif\n+    OT::ItemVariationStore::cache_t *varStore_cache = ot_font->v.acquire_varStore_cache (varStore);\n+    \/\/ TODO Use advance_cache.\n@@ -359,3 +327,1 @@\n-#if !defined(HB_NO_VAR) && !defined(HB_NO_OT_FONT_ADVANCE_CACHE)\n-    OT::ItemVariationStore::destroy_cache (varStore_cache);\n-#endif\n+    ot_font->v.release_varStore_cache (varStore_cache);\n@@ -376,26 +342,0 @@\n-\n-  if (font->y_strength && !font->embolden_in_place)\n-  {\n-    \/* Emboldening. *\/\n-    hb_position_t y_strength = font->y_scale >= 0 ? font->y_strength : -font->y_strength;\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += *first_advance ? y_strength : 0;\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n-  }\n-\n-#ifndef HB_NO_AAT\n-  if (ot_font->apply_trak)\n-  {\n-    hb_position_t tracking = font->face->table.trak->get_v_tracking (font);\n-    first_advance = orig_first_advance;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      *first_advance += tracking;\n-      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n-      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n-    }\n-  }\n-#endif\n@@ -438,1 +378,2 @@\n-  if (ot_face->glyf->get_extents (font, glyph, &extents))\n+\n+  if (hb_font_get_glyph_extents (font, glyph, &extents))\n@@ -451,1 +392,1 @@\n-    int diff = advance - -extents.height;\n+    hb_position_t diff = advance - -extents.height;\n@@ -480,0 +421,3 @@\n+#endif\n+#ifndef HB_NO_VAR_COMPOSITES\n+  if (ot_face->VARC->get_extents (font, glyph, extents)) return true;\n@@ -531,10 +475,3 @@\n-  bool ret = _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER, &metrics->ascender) &&\n-             _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER, &metrics->descender) &&\n-             _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP, &metrics->line_gap);\n-\n-  \/* Embolden *\/\n-  int y_shift = font->y_strength;\n-  if (font->y_scale < 0) y_shift = -y_shift;\n-  metrics->ascender += y_shift;\n-\n-  return ret;\n+  return _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER, &metrics->ascender) &&\n+         _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER, &metrics->descender) &&\n+         _hb_ot_metrics_get_position_common (font, HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP, &metrics->line_gap);\n@@ -557,6 +494,6 @@\n-static void\n-hb_ot_draw_glyph (hb_font_t *font,\n-                  void *font_data HB_UNUSED,\n-                  hb_codepoint_t glyph,\n-                  hb_draw_funcs_t *draw_funcs, void *draw_data,\n-                  void *user_data)\n+static hb_bool_t\n+hb_ot_draw_glyph_or_fail (hb_font_t *font,\n+                          void *font_data HB_UNUSED,\n+                          hb_codepoint_t glyph,\n+                          hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                          void *user_data)\n@@ -564,6 +501,1 @@\n-  bool embolden = font->x_strength || font->y_strength;\n-  hb_outline_t outline;\n-\n-  { \/\/ Need draw_session to be destructed before emboldening.\n-    hb_draw_session_t draw_session (embolden ? hb_outline_recording_pen_get_funcs () : draw_funcs,\n-                                    embolden ? &outline : draw_data, font->slant_xy);\n+  hb_draw_session_t draw_session {draw_funcs, draw_data};\n@@ -571,1 +503,1 @@\n-    if (!font->face->table.VARC->get_path (font, glyph, draw_session))\n+  if (font->face->table.VARC->get_path (font, glyph, draw_session)) return true;\n@@ -573,2 +505,2 @@\n-    \/\/ Keep the following in synch with VARC::get_path_at()\n-    if (!font->face->table.glyf->get_path (font, glyph, draw_session))\n+  \/\/ Keep the following in synch with VARC::get_path_at()\n+  if (font->face->table.glyf->get_path (font, glyph, draw_session)) return true;\n@@ -576,2 +508,2 @@\n-    if (!font->face->table.cff2->get_path (font, glyph, draw_session))\n-    if (!font->face->table.cff1->get_path (font, glyph, draw_session))\n+  if (font->face->table.cff2->get_path (font, glyph, draw_session)) return true;\n+  if (font->face->table.cff1->get_path (font, glyph, draw_session)) return true;\n@@ -579,14 +511,1 @@\n-    {}\n-  }\n-\n-  if (embolden)\n-  {\n-    float x_shift = font->embolden_in_place ? 0 : (float) font->x_strength \/ 2;\n-    float y_shift = (float) font->y_strength \/ 2;\n-    if (font->x_scale < 0) x_shift = -x_shift;\n-    if (font->y_scale < 0) y_shift = -y_shift;\n-    outline.embolden (font->x_strength, font->y_strength,\n-                      x_shift, y_shift);\n-\n-    outline.replay (draw_funcs, draw_data);\n-  }\n+  return false;\n@@ -597,8 +516,8 @@\n-static void\n-hb_ot_paint_glyph (hb_font_t *font,\n-                   void *font_data,\n-                   hb_codepoint_t glyph,\n-                   hb_paint_funcs_t *paint_funcs, void *paint_data,\n-                   unsigned int palette,\n-                   hb_color_t foreground,\n-                   void *user_data)\n+static hb_bool_t\n+hb_ot_paint_glyph_or_fail (hb_font_t *font,\n+                           void *font_data,\n+                           hb_codepoint_t glyph,\n+                           hb_paint_funcs_t *paint_funcs, void *paint_data,\n+                           unsigned int palette,\n+                           hb_color_t foreground,\n+                           void *user_data)\n@@ -607,2 +526,2 @@\n-  if (font->face->table.COLR->paint_glyph (font, glyph, paint_funcs, paint_data, palette, foreground)) return;\n-  if (font->face->table.SVG->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n+  if (font->face->table.COLR->paint_glyph (font, glyph, paint_funcs, paint_data, palette, foreground)) return true;\n+  if (font->face->table.SVG->paint_glyph (font, glyph, paint_funcs, paint_data)) return true;\n@@ -610,2 +529,2 @@\n-  if (font->face->table.CBDT->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n-  if (font->face->table.sbix->paint_glyph (font, glyph, paint_funcs, paint_data)) return;\n+  if (font->face->table.CBDT->paint_glyph (font, glyph, paint_funcs, paint_data)) return true;\n+  if (font->face->table.sbix->paint_glyph (font, glyph, paint_funcs, paint_data)) return true;\n@@ -614,5 +533,1 @@\n-\n-  \/\/ Outline glyph\n-  paint_funcs->push_clip_glyph (paint_data, glyph, font);\n-  paint_funcs->color (paint_data, true, foreground);\n-  paint_funcs->pop_clip (paint_data);\n+  return false;\n@@ -645,1 +560,1 @@\n-    hb_font_funcs_set_draw_glyph_func (funcs, hb_ot_draw_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_draw_glyph_or_fail_func (funcs, hb_ot_draw_glyph_or_fail, nullptr, nullptr);\n@@ -649,1 +564,1 @@\n-    hb_font_funcs_set_paint_glyph_func (funcs, hb_ot_paint_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_paint_glyph_or_fail_func (funcs, hb_ot_paint_glyph_or_fail, nullptr, nullptr);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-font.cc","additions":155,"deletions":240,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -362,1 +362,7 @@\n-      return _glyf_get_leading_bearing_with_var_unscaled (font, glyph, T::tableTag == HB_OT_TAG_vmtx, lsb);\n+      \/\/ If there's no vmtx data, the phantom points from glyf table are not accurate,\n+      \/\/ so we cannot take the next path.\n+      bool is_vertical = T::tableTag == HB_OT_TAG_vmtx;\n+      if (is_vertical && !has_data ())\n+        return false;\n+\n+      return _glyf_get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"hb-aat-layout-common.hh\"\n@@ -403,0 +404,1 @@\n+    AAT::hb_aat_scratch_t scratch;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-kern-table.hh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-    case 3: hb_barrier (); u.format3.collect_variation_indices (varidx_set);\n+    case 3: hb_barrier (); u.format3.collect_variation_indices (varidx_set); return;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-base-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1853,1 +1853,1 @@\n-    if (glyph_set.get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2\n+    if (glyph_set.get_population () * hb_bit_storage ((unsigned) rangeRecord.len)\n@@ -1934,1 +1934,1 @@\n-    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len) \/ 2)\n+    if (rangeRecord.len > glyphs->get_population () * hb_bit_storage ((unsigned) rangeRecord.len))\n@@ -2003,1 +2003,1 @@\n-    if (count > glyphs->get_population () * hb_bit_storage (count) * 8)\n+    if (count > glyphs->get_population () * hb_bit_storage (count))\n@@ -2551,1 +2551,3 @@\n-#define REGION_CACHE_ITEM_CACHE_INVALID 2.f\n+#define REGION_CACHE_ITEM_CACHE_INVALID INT_MIN\n+#define REGION_CACHE_ITEM_MULTIPLIER (float (1 << ((sizeof (int) * 8) - 2)))\n+#define REGION_CACHE_ITEM_DIVISOR (1.f \/ float (1 << ((sizeof (int) * 8) - 2)))\n@@ -2555,1 +2557,1 @@\n-  using cache_t = float;\n+  using cache_t = hb_atomic_t<int>;\n@@ -2564,1 +2566,1 @@\n-    float *cached_value = nullptr;\n+    cache_t *cached_value = nullptr;\n@@ -2568,2 +2570,2 @@\n-      if (likely (*cached_value != REGION_CACHE_ITEM_CACHE_INVALID))\n-        return *cached_value;\n+      if (*cached_value != REGION_CACHE_ITEM_CACHE_INVALID)\n+        return *cached_value * REGION_CACHE_ITEM_DIVISOR;\n@@ -2590,1 +2592,1 @@\n-      *cached_value = v;\n+      *cached_value = v * REGION_CACHE_ITEM_MULTIPLIER;\n@@ -2733,1 +2735,1 @@\n-  using cache_t = float;\n+  using cache_t = hb_atomic_t<int>;\n@@ -2742,1 +2744,1 @@\n-    float *cached_value = nullptr;\n+    cache_t *cached_value = nullptr;\n@@ -2746,2 +2748,2 @@\n-      if (likely (*cached_value != REGION_CACHE_ITEM_CACHE_INVALID))\n-        return *cached_value;\n+      if (*cached_value != REGION_CACHE_ITEM_CACHE_INVALID)\n+        return *cached_value * REGION_CACHE_ITEM_DIVISOR;\n@@ -2755,1 +2757,1 @@\n-      *cached_value = v;\n+      *cached_value = v * REGION_CACHE_ITEM_MULTIPLIER;\n@@ -2864,1 +2866,0 @@\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -2866,0 +2867,6 @@\n+    if (!row_count) {\n+      \/\/ Nothing to serialize, will be empty.\n+      return false;\n+    }\n+\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -3190,2 +3197,2 @@\n-    auto &r = this+regions;\n-    unsigned count = r.regionCount;\n+    unsigned count = (this+regions).regionCount;\n+    if (!count) return nullptr;\n@@ -3193,1 +3200,1 @@\n-    float *cache = (float *) hb_malloc (sizeof (float) * count);\n+    cache_t *cache = (cache_t *) hb_malloc (sizeof (float) * count);\n@@ -3443,1 +3450,1 @@\n-  cache_t *create_cache (hb_array_t<float> static_cache = hb_array_t<float> ()) const\n+  cache_t *create_cache (hb_array_t<cache_t> static_cache = hb_array_t<cache_t> ()) const\n@@ -3451,1 +3458,1 @@\n-    float *cache;\n+    cache_t *cache;\n@@ -3456,1 +3463,1 @@\n-      cache = (float *) hb_malloc (sizeof (float) * count);\n+      cache = (cache_t *) hb_malloc (sizeof (float) * count);\n@@ -3467,1 +3474,1 @@\n-                             hb_array_t<float> static_cache = hb_array_t<float> ())\n+                             hb_array_t<cache_t> static_cache = hb_array_t<cache_t> ())\n@@ -4780,1 +4787,1 @@\n-  { return font->em_scalef_x (get_delta (font, store, store_cache)); }\n+  { return !font->num_coords ? 0 : font->em_scalef_x (get_delta (font, store, store_cache)); }\n@@ -4785,1 +4792,1 @@\n-  { return font->em_scalef_y (get_delta (font, store, store_cache)); }\n+  { return !font->num_coords ? 0 : font->em_scalef_y (get_delta (font, store, store_cache)); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -740,1 +740,2 @@\n-                         hb_blob_t *table_blob_) :\n+                         hb_blob_t *table_blob_,\n+                         ItemVariationStore::cache_t *var_store_cache_ = nullptr) :\n@@ -759,7 +760,1 @@\n-                        var_store_cache (\n-#ifndef HB_NO_VAR\n-                                         table_index == 1 && font->num_coords ? var_store.create_cache () : nullptr\n-#else\n-                                         nullptr\n-#endif\n-                                        ),\n+                        var_store_cache (var_store_cache_),\n@@ -773,7 +768,0 @@\n-  ~hb_ot_apply_context_t ()\n-  {\n-#ifndef HB_NO_VAR\n-    ItemVariationStore::destroy_cache (var_store_cache);\n-#endif\n-  }\n-\n@@ -4903,1 +4891,1 @@\n-      this->accels = (hb_atomic_ptr_t<hb_ot_layout_lookup_accelerator_t> *) hb_calloc (this->lookup_count, sizeof (*accels));\n+      this->accels = (hb_atomic_t<hb_ot_layout_lookup_accelerator_t *> *) hb_calloc (this->lookup_count, sizeof (*accels));\n@@ -4951,1 +4939,1 @@\n-    hb_atomic_ptr_t<hb_ot_layout_lookup_accelerator_t> *accels;\n+    hb_atomic_t<hb_ot_layout_lookup_accelerator_t *> *accels;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -134,2 +134,2 @@\n-  hb_blob_t *blob = font->face->table.kern.get_blob ();\n-  const auto& kern = *font->face->table.kern;\n+  auto &accel = *font->face->table.kern;\n+  hb_blob_t *blob = accel.get_blob ();\n@@ -140,1 +140,3 @@\n-  kern.apply (&c);\n+  c.buffer_glyph_set = accel.scratch.create_buffer_glyph_set ();\n+  accel.apply (&c);\n+  accel.scratch.destroy_buffer_glyph_set (c.buffer_glyph_set);\n@@ -2016,1 +2018,5 @@\n-  OT::hb_ot_apply_context_t c (table_index, font, buffer, proxy.accel.get_blob ());\n+\n+  auto *font_data = font->data.ot.get ();\n+  auto *var_store_cache = font_data == HB_SHAPER_DATA_SUCCEEDED ? nullptr : (OT::ItemVariationStore::cache_t *) font_data;\n+\n+  OT::hb_ot_apply_context_t c (table_index, font, buffer, proxy.accel.get_blob (), var_store_cache);\n@@ -2629,1 +2635,2 @@\n- * Fetches alternates of a glyph from a given GSUB lookup index.\n+ * Fetches alternates of a glyph from a given GSUB lookup index. Note that for one-to-one GSUB\n+ * glyph substitutions, this function fetches the substituted glyph.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.cc","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -205,1 +205,2 @@\n-  UPROPS_MASK_Cf_VS     = 0x0400u\n+  UPROPS_MASK_Cf_VS     = 0x0400u,\n+  UPROPS_MASK_Cf_AAT_DELETED    = 0x0800u\n@@ -389,0 +390,2 @@\n+  \/\/ MONOTONE_GRAPHEMES was already applied and is taken care of by _hb_grapheme_group_func.\n+  \/\/ So we just check for MONOTONE_CHARACTERS here.\n@@ -421,0 +424,12 @@\n+static inline bool\n+_hb_glyph_info_is_aat_deleted (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_format (info) && (info->unicode_props() & UPROPS_MASK_Cf_AAT_DELETED);\n+}\n+static inline void\n+_hb_glyph_info_set_aat_deleted (hb_glyph_info_t *info)\n+{\n+  _hb_glyph_info_set_general_category (info, HB_UNICODE_GENERAL_CATEGORY_FORMAT);\n+  info->unicode_props() |= UPROPS_MASK_Cf_AAT_DELETED;\n+  info->unicode_props() |= UPROPS_MASK_HIDDEN;\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.hh","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1107,0 +1107,18 @@\n+  \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4653\n+  HB_INTERNAL bool is_bad_cambria (hb_font_t *font) const\n+  {\n+#ifndef HB_NO_MATH\n+    switch HB_CODEPOINT_ENCODE3 (font->face->table.MATH.get_blob ()->length,\n+                                 get_constant (HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT, font),\n+                                 get_constant (HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT, font))\n+    {\n+      \/* sha1sum:ab4a4fe054d23061f3c039493d6f665cfda2ecf5  cambria.ttc\n+       * sha1sum:086855301bff644f9d8827b88491fcf73a6d4cb9  cambria.ttc\n+       * sha1sum:b1e5a3feaca2ea3dfcf79ccb377de749ecf60343  cambria.ttc *\/\n+      case HB_CODEPOINT_ENCODE3 (25722, 2500, 3000):\n+        return true;\n+    }\n+#endif\n+    return false;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math-table.hh","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -90,0 +90,14 @@\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4653\n+   * Cambria Math has incorrect value for displayOperatorMinHeight, and\n+   * apparently Microsoft implementation swaps displayOperatorMinHeight and\n+   * delimitedSubFormulaMinHeight, so we do the same if we detect Cambria Math\n+   * with the swapped values. *\/\n+  if ((constant == HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT ||\n+       constant == HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT) &&\n+      font->face->table.MATH->is_bad_cambria (font))\n+  {\n+    if (constant == HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT)\n+      constant = HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT;\n+    else\n+      constant = HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math.cc","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-    hb_atomic_ptr_t<uint16_t *> gids_sorted_by_name;\n+    mutable hb_atomic_t<uint16_t *> gids_sorted_by_name;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -430,0 +430,4 @@\n+      {\n+        if (_hb_glyph_info_is_hidden (&info[j]) ||\n+            _hb_glyph_info_is_default_ignorable (&info[j]))\n+          continue;\n@@ -432,0 +436,1 @@\n+      }\n@@ -458,1 +463,3 @@\n-    if (likely (!_hb_glyph_info_is_unicode_mark (&info[i]))) {\n+    if (likely (!_hb_glyph_info_is_unicode_mark (&info[i]) &&\n+                !_hb_glyph_info_is_hidden (&info[i]) &&\n+                !_hb_glyph_info_is_default_ignorable (&info[i]))) {\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-fallback.cc","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"hb-ot-layout-gdef-table.hh\"\n@@ -87,0 +88,1 @@\n+                                                , aat_map (face, props)\n@@ -109,0 +111,4 @@\n+#ifndef HB_NO_AAT_SHAPE\n+  if (apply_morx)\n+    aat_map.compile (plan.aat_map);\n+#endif\n@@ -208,0 +214,8 @@\n+\n+  \/* According to Ned, trak is applied by default for \"modern fonts\", as detected by presence of STAT table. *\/\n+#ifndef HB_NO_STYLE\n+  plan.apply_trak = hb_aat_layout_has_tracking (face) && face->table.STAT->has_data ();\n+#else\n+  plan.apply_trak = false;\n+#endif\n+\n@@ -272,0 +286,5 @@\n+\n+#ifndef HB_NO_AAT_SHAPE\n+  if (this->apply_trak)\n+    hb_aat_layout_track (this, font, buffer);\n+#endif\n@@ -408,1 +427,3 @@\n-struct hb_ot_font_data_t {};\n+struct hb_ot_font_data_t {\n+  OT::ItemVariationStore::cache_t unused; \/\/ Just for alignment\n+};\n@@ -411,1 +432,1 @@\n-_hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)\n+_hb_ot_shaper_font_data_create (hb_font_t *font)\n@@ -413,1 +434,6 @@\n-  return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+  if (!font->num_coords)\n+    return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+\n+  const OT::ItemVariationStore &var_store = font->face->table.GDEF->table->get_var_store ();\n+  auto *cache = (hb_ot_font_data_t *) var_store.create_cache ();\n+  return cache ? cache : (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n@@ -417,1 +443,1 @@\n-_hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data HB_UNUSED)\n+_hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data)\n@@ -419,0 +445,2 @@\n+  if (data == HB_SHAPER_DATA_SUCCEEDED) return;\n+  OT::ItemVariationStore::destroy_cache ((OT::ItemVariationStore::cache_t *) data);\n@@ -554,1 +582,1 @@\n-  if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+  if (HB_BUFFER_CLUSTER_LEVEL_IS_GRAPHEMES (buffer->cluster_level))\n@@ -612,1 +640,1 @@\n-       direction != horiz_dir && horiz_dir != HB_DIRECTION_INVALID) ||\n+       direction != horiz_dir && HB_DIRECTION_IS_VALID (horiz_dir)) ||\n@@ -1112,4 +1140,0 @@\n-#ifndef HB_NO_AAT_SHAPE\n-  if (c->plan->apply_morx)\n-    hb_aat_layout_zero_width_deleted_glyphs (c->buffer);\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.cc","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  hb_aat_map_t aat_map;\n@@ -111,0 +112,1 @@\n+  bool apply_trak : 1;\n@@ -114,0 +116,1 @@\n+  static constexpr bool apply_trak = false;\n@@ -144,0 +147,1 @@\n+  hb_aat_map_builder_t aat_map;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  hb_atomic_ptr_t<arabic_fallback_plan_t> fallback_plan;\n+  mutable hb_atomic_t<arabic_fallback_plan_t *> fallback_plan;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,2 +301,1 @@\n-        if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n-          buffer->merge_out_clusters (start, end);\n+        buffer->merge_out_clusters (start, end);\n@@ -375,2 +374,1 @@\n-          if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n-            buffer->merge_out_clusters (start, end);\n+          buffer->merge_out_clusters (start, end);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-hangul.cc","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-  mutable hb_atomic_int_t virama_glyph;\n+  mutable hb_atomic_t<hb_codepoint_t> virama_glyph;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-      if (start && buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+      if (start)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-thai.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-    static hb_atomic_int_t last_tag_idx; \/* Poor man's cache. *\/\n+    static hb_atomic_t<unsigned> last_tag_idx = 0; \/* Poor man's cache. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-tag.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,4 +56,0 @@\n-\n-  \/\/ VARC\n-  hb_vector_t<unsigned> axisIndices;\n-  hb_vector_t<float> axisValues;\n@@ -597,3 +593,3 @@\n-      \/* For shared tuples that only have one axis active, shared the index of\n-       * that axis as a cache. This will speed up caclulate_scalar() a lot\n-       * for fonts with lots of axes and many \"monovar\" tuples. *\/\n+      \/* For shared tuples that only have one or two axes active, shared the index\n+       * of that axis as a cache. This will speed up caclulate_scalar() a lot\n+       * for fonts with lots of axes and many \"monovar\" or \"duovar\" tuples. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-gvar-table.hh","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n- * Deprecated: 2.2.0 - use hb_ot_var_find_axis_info() instead\n+ * Deprecated: 2.2.0: use hb_ot_var_find_axis_info() instead\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,6 @@\n+void hb_outline_t::slant (float slant_xy)\n+{\n+  for (auto &p : points)\n+    p.x += slant_xy * p.y;\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.cc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  HB_INTERNAL void slant (float slant_xy);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright © 2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_PAINT\n+\n+#include \"hb-paint-bounded.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+\n+\/*\n+ * This file implements boundedness computation of COLRv1 fonts as described in:\n+ *\n+ * https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#glyph-metrics-and-boundedness\n+ *\/\n+\n+static void\n+hb_paint_bounded_push_clip_glyph (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                  void *paint_data,\n+                                  hb_codepoint_t glyph,\n+                                  hb_font_t *font,\n+                                  void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->push_clip ();\n+}\n+\n+static void\n+hb_paint_bounded_push_clip_rectangle (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                      void *paint_data,\n+                                      float xmin, float ymin, float xmax, float ymax,\n+                                      void *user_data)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->push_clip ();\n+}\n+\n+static void\n+hb_paint_bounded_pop_clip (hb_paint_funcs_t *funcs HB_UNUSED,\n+                           void *paint_data,\n+                           void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->pop_clip ();\n+}\n+\n+static void\n+hb_paint_bounded_push_group (hb_paint_funcs_t *funcs HB_UNUSED,\n+                             void *paint_data,\n+                             void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->push_group ();\n+}\n+\n+static void\n+hb_paint_bounded_pop_group (hb_paint_funcs_t *funcs HB_UNUSED,\n+                            void *paint_data,\n+                            hb_paint_composite_mode_t mode,\n+                            void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->pop_group (mode);\n+}\n+\n+static hb_bool_t\n+hb_paint_bounded_paint_image (hb_paint_funcs_t *funcs HB_UNUSED,\n+                              void *paint_data,\n+                              hb_blob_t *blob HB_UNUSED,\n+                              unsigned int width HB_UNUSED,\n+                              unsigned int height HB_UNUSED,\n+                              hb_tag_t format HB_UNUSED,\n+                              float slant HB_UNUSED,\n+                              hb_glyph_extents_t *glyph_extents,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->push_clip ();\n+  c->paint ();\n+  c->pop_clip ();\n+\n+  return true;\n+}\n+\n+static void\n+hb_paint_bounded_paint_color (hb_paint_funcs_t *funcs HB_UNUSED,\n+                              void *paint_data,\n+                              hb_bool_t use_foreground HB_UNUSED,\n+                              hb_color_t color HB_UNUSED,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_bounded_paint_linear_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                        void *paint_data,\n+                                        hb_color_line_t *color_line HB_UNUSED,\n+                                        float x0 HB_UNUSED, float y0 HB_UNUSED,\n+                                        float x1 HB_UNUSED, float y1 HB_UNUSED,\n+                                        float x2 HB_UNUSED, float y2 HB_UNUSED,\n+                                        void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_bounded_paint_radial_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                        void *paint_data,\n+                                        hb_color_line_t *color_line HB_UNUSED,\n+                                        float x0 HB_UNUSED, float y0 HB_UNUSED, float r0 HB_UNUSED,\n+                                        float x1 HB_UNUSED, float y1 HB_UNUSED, float r1 HB_UNUSED,\n+                                        void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static void\n+hb_paint_bounded_paint_sweep_gradient (hb_paint_funcs_t *funcs HB_UNUSED,\n+                                       void *paint_data,\n+                                       hb_color_line_t *color_line HB_UNUSED,\n+                                       float cx HB_UNUSED, float cy HB_UNUSED,\n+                                       float start_angle HB_UNUSED,\n+                                       float end_angle HB_UNUSED,\n+                                       void *user_data HB_UNUSED)\n+{\n+  hb_paint_bounded_context_t *c = (hb_paint_bounded_context_t *) paint_data;\n+\n+  c->paint ();\n+}\n+\n+static inline void free_static_paint_bounded_funcs ();\n+\n+static struct hb_paint_bounded_funcs_lazy_loader_t : hb_paint_funcs_lazy_loader_t<hb_paint_bounded_funcs_lazy_loader_t>\n+{\n+  static hb_paint_funcs_t *create ()\n+  {\n+    hb_paint_funcs_t *funcs = hb_paint_funcs_create ();\n+\n+    hb_paint_funcs_set_push_clip_glyph_func (funcs, hb_paint_bounded_push_clip_glyph, nullptr, nullptr);\n+    hb_paint_funcs_set_push_clip_rectangle_func (funcs, hb_paint_bounded_push_clip_rectangle, nullptr, nullptr);\n+    hb_paint_funcs_set_pop_clip_func (funcs, hb_paint_bounded_pop_clip, nullptr, nullptr);\n+    hb_paint_funcs_set_push_group_func (funcs, hb_paint_bounded_push_group, nullptr, nullptr);\n+    hb_paint_funcs_set_pop_group_func (funcs, hb_paint_bounded_pop_group, nullptr, nullptr);\n+    hb_paint_funcs_set_color_func (funcs, hb_paint_bounded_paint_color, nullptr, nullptr);\n+    hb_paint_funcs_set_image_func (funcs, hb_paint_bounded_paint_image, nullptr, nullptr);\n+    hb_paint_funcs_set_linear_gradient_func (funcs, hb_paint_bounded_paint_linear_gradient, nullptr, nullptr);\n+    hb_paint_funcs_set_radial_gradient_func (funcs, hb_paint_bounded_paint_radial_gradient, nullptr, nullptr);\n+    hb_paint_funcs_set_sweep_gradient_func (funcs, hb_paint_bounded_paint_sweep_gradient, nullptr, nullptr);\n+\n+    hb_paint_funcs_make_immutable (funcs);\n+\n+    hb_atexit (free_static_paint_bounded_funcs);\n+\n+    return funcs;\n+  }\n+} static_paint_bounded_funcs;\n+\n+static inline\n+void free_static_paint_bounded_funcs ()\n+{\n+  static_paint_bounded_funcs.free_instance ();\n+}\n+\n+hb_paint_funcs_t *\n+hb_paint_bounded_get_funcs ()\n+{\n+  return static_paint_bounded_funcs.get_unconst ();\n+}\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-bounded.cc","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright © 2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_PAINT_BOUNDED_HH\n+#define HB_PAINT_BOUNDED_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-paint.h\"\n+\n+#include \"hb-geometry.hh\"\n+\n+\n+typedef struct  hb_paint_bounded_context_t hb_paint_bounded_context_t;\n+\n+struct hb_paint_bounded_context_t\n+{\n+  void clear ()\n+  {\n+    clips = 0;\n+    bounded = true;\n+    groups.clear ();\n+  }\n+\n+  hb_paint_bounded_context_t ()\n+  {\n+    clear ();\n+  }\n+\n+  bool is_bounded ()\n+  {\n+    return bounded;\n+  }\n+\n+  void push_clip ()\n+  {\n+    clips++;\n+  }\n+\n+  void pop_clip ()\n+  {\n+    if (clips == 0) return;\n+    clips--;\n+  }\n+\n+  void push_group ()\n+  {\n+    groups.push (bounded);\n+    bounded = true;\n+  }\n+\n+  void pop_group (hb_paint_composite_mode_t mode)\n+  {\n+    const bool src_bounded = bounded;\n+    bounded = groups.pop ();\n+    bool &backdrop_bounded = bounded;\n+\n+    \/\/ https:\/\/learn.microsoft.com\/en-us\/typography\/opentype\/spec\/colr#format-32-paintcomposite\n+    switch ((int) mode)\n+    {\n+      case HB_PAINT_COMPOSITE_MODE_CLEAR:\n+        backdrop_bounded = true;\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_SRC:\n+      case HB_PAINT_COMPOSITE_MODE_SRC_OUT:\n+        backdrop_bounded = src_bounded;\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_DEST:\n+      case HB_PAINT_COMPOSITE_MODE_DEST_OUT:\n+        break;\n+      case HB_PAINT_COMPOSITE_MODE_SRC_IN:\n+      case HB_PAINT_COMPOSITE_MODE_DEST_IN:\n+        backdrop_bounded = backdrop_bounded && src_bounded;\n+        break;\n+      default:\n+        backdrop_bounded = backdrop_bounded || src_bounded;\n+        break;\n+     }\n+  }\n+\n+  void paint ()\n+  {\n+    if (!clips)\n+      bounded = false;\n+  }\n+\n+  protected:\n+  bool bounded; \/\/ true if current drawing bounded\n+  unsigned clips; \/\/ number of active clips\n+  hb_vector_t<bool> groups; \/\/ true if group bounded\n+};\n+\n+HB_INTERNAL hb_paint_funcs_t *\n+hb_paint_bounded_get_funcs ();\n+\n+\n+#endif \/* HB_PAINT_BOUNDED_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-bounded.hh","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-draw.h\"\n+#include \"hb-draw.hh\"\n@@ -37,2 +37,1 @@\n- * This file implements bounds-extraction as well as boundedness\n- * computation of COLRv1 fonts as described in:\n+ * This file implements bounds-extraction computation of COLRv1 fonts as described in:\n@@ -66,87 +65,0 @@\n-static void\n-hb_draw_extents_move_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n-                         void *data,\n-                         hb_draw_state_t *st,\n-                         float to_x, float to_y,\n-                         void *user_data HB_UNUSED)\n-{\n-  hb_extents_t *extents = (hb_extents_t *) data;\n-\n-  extents->add_point (to_x, to_y);\n-}\n-\n-static void\n-hb_draw_extents_line_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n-                         void *data,\n-                         hb_draw_state_t *st,\n-                         float to_x, float to_y,\n-                         void *user_data HB_UNUSED)\n-{\n-  hb_extents_t *extents = (hb_extents_t *) data;\n-\n-  extents->add_point (to_x, to_y);\n-}\n-\n-static void\n-hb_draw_extents_quadratic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n-                              void *data,\n-                              hb_draw_state_t *st,\n-                              float control_x, float control_y,\n-                              float to_x, float to_y,\n-                              void *user_data HB_UNUSED)\n-{\n-  hb_extents_t *extents = (hb_extents_t *) data;\n-\n-  extents->add_point (control_x, control_y);\n-  extents->add_point (to_x, to_y);\n-}\n-\n-static void\n-hb_draw_extents_cubic_to (hb_draw_funcs_t *dfuncs HB_UNUSED,\n-                          void *data,\n-                          hb_draw_state_t *st,\n-                          float control1_x, float control1_y,\n-                          float control2_x, float control2_y,\n-                          float to_x, float to_y,\n-                          void *user_data HB_UNUSED)\n-{\n-  hb_extents_t *extents = (hb_extents_t *) data;\n-\n-  extents->add_point (control1_x, control1_y);\n-  extents->add_point (control2_x, control2_y);\n-  extents->add_point (to_x, to_y);\n-}\n-\n-static inline void free_static_draw_extents_funcs ();\n-\n-static struct hb_draw_extents_funcs_lazy_loader_t : hb_draw_funcs_lazy_loader_t<hb_draw_extents_funcs_lazy_loader_t>\n-{\n-  static hb_draw_funcs_t *create ()\n-  {\n-    hb_draw_funcs_t *funcs = hb_draw_funcs_create ();\n-\n-    hb_draw_funcs_set_move_to_func (funcs, hb_draw_extents_move_to, nullptr, nullptr);\n-    hb_draw_funcs_set_line_to_func (funcs, hb_draw_extents_line_to, nullptr, nullptr);\n-    hb_draw_funcs_set_quadratic_to_func (funcs, hb_draw_extents_quadratic_to, nullptr, nullptr);\n-    hb_draw_funcs_set_cubic_to_func (funcs, hb_draw_extents_cubic_to, nullptr, nullptr);\n-\n-    hb_draw_funcs_make_immutable (funcs);\n-\n-    hb_atexit (free_static_draw_extents_funcs);\n-\n-    return funcs;\n-  }\n-} static_draw_extents_funcs;\n-\n-static inline\n-void free_static_draw_extents_funcs ()\n-{\n-  static_draw_extents_funcs.free_instance ();\n-}\n-\n-static hb_draw_funcs_t *\n-hb_draw_extents_get_funcs ()\n-{\n-  return static_draw_extents_funcs.get_unconst ();\n-}\n-\n@@ -224,0 +136,3 @@\n+  if (!glyph_extents)\n+    return false; \/\/ Happens with SVG images.\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-extents.cc","additions":5,"deletions":90,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  hb_paint_extents_context_t ()\n+  void clear ()\n@@ -40,0 +40,4 @@\n+    transforms.clear ();\n+    clips.clear ();\n+    groups.clear ();\n+\n@@ -45,0 +49,5 @@\n+  hb_paint_extents_context_t ()\n+  {\n+    clear ();\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint-extents.hh","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                    float slant_xy,\n+                    float slant_xy_deprecated,\n@@ -467,0 +467,36 @@\n+\/**\n+ * hb_paint_push_font_transform:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @font: a font\n+ *\n+ * Push the transform reflecting the font's scale and slant\n+ * settings onto the paint functions.\n+ *\n+ * Since: 11.0.0\n+ *\/\n+void\n+hb_paint_push_font_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                              const hb_font_t *font)\n+{\n+  funcs->push_font_transform (paint_data, font);\n+}\n+\n+\/**\n+ * hb_paint_push_inverse_font_transform:\n+ * @funcs: paint functions\n+ * @paint_data: associated data passed by the caller\n+ * @font: a font\n+ *\n+ * Push the inverse of the transform reflecting the font's\n+ * scale and slant settings onto the paint functions.\n+ *\n+ * Since: 11.0.0\n+ *\/\n+void\n+hb_paint_push_inverse_font_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                                      const hb_font_t *font)\n+{\n+  funcs->push_inverse_font_transform (paint_data, font);\n+}\n+\n@@ -582,1 +618,1 @@\n- * @slant: the synthetic slant ratio to be applied to the image during rendering\n+ * @slant: Deprecated. set to 0.0\n@@ -595,1 +631,1 @@\n-                float slant,\n+                HB_UNUSED float slant,\n@@ -598,1 +634,1 @@\n-  funcs->image (paint_data, image, width, height, format, slant, extents);\n+  funcs->image (paint_data, image, width, height, format, 0.f, extents);\n@@ -649,1 +685,1 @@\n-  funcs->radial_gradient (paint_data, color_line, x0, y0, r0, y1, x1, r1);\n+  funcs->radial_gradient (paint_data, color_line, x0, y0, r0, x1, y1, r1);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.cc","additions":41,"deletions":5,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -170,2 +170,4 @@\n- * The coordinates of the glyph outline are interpreted according\n- * to the current transform.\n+ * The coordinates of the glyph outline are expected in the\n+ * current @font scale (ie. the results of calling\n+ * hb_font_draw_glyph() with @font). The outline is\n+ * transformed by the current transform.\n@@ -284,1 +286,1 @@\n- * @slant: the synthetic slant ratio to be applied to the image during rendering\n+ * @slant: Deprecated. Always set to 0.0.\n@@ -959,0 +961,8 @@\n+HB_EXTERN void\n+hb_paint_push_font_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                              const hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_paint_push_inverse_font_transform (hb_paint_funcs_t *funcs, void *paint_data,\n+                                      const hb_font_t *font);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.h","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  void push_root_transform (void *paint_data,\n+  void push_font_transform (void *paint_data,\n@@ -165,1 +165,0 @@\n-    float slant = font->slant_xy;\n@@ -168,1 +167,3 @@\n-                    xscale\/upem, 0, slant * yscale\/upem, yscale\/upem, 0, 0);\n+                    xscale\/upem, 0,\n+                    0, yscale\/upem,\n+                    0, 0);\n@@ -171,2 +172,2 @@\n-  void push_inverse_root_transform (void *paint_data,\n-                                    hb_font_t *font)\n+  void push_inverse_font_transform (void *paint_data,\n+                                    const hb_font_t *font)\n@@ -177,1 +178,0 @@\n-    float slant = font->slant_xy;\n@@ -180,1 +180,3 @@\n-                    upem\/xscale, 0, -slant * upem\/xscale, upem\/yscale, 0, 0);\n+                    upem\/xscale, 0,\n+                    0, upem\/yscale,\n+                    0, 0);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.hh","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#if !defined(HB_H_IN) && !defined(HB_NO_SINGLE_HEADER_ERROR)\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_SCRIPT_LIST_H\n+#define HB_SCRIPT_LIST_H\n+\n+\/* This file belongs to the middle of hb-common.h.\n+ * The reason it has been surgically extracted is because\n+ * FreeType imports types and enums from hb-common.h,\n+ * and since this enum is large and growing, we want to\n+ * make it easy to just copy the file over to FreeType.\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/5271\n+ *\/\n+\n+\/* Dummy lines to make our checks happy.  *\/\n+#if 0\n+#include \"hb-common.h\"\n+HB_BEGIN_DECLS\n+HB_END_DECLS\n+#endif\n+\n+\n+\/**\n+ * hb_script_t:\n+ * @HB_SCRIPT_COMMON: `Zyyy`\n+ * @HB_SCRIPT_INHERITED: `Zinh`\n+ * @HB_SCRIPT_UNKNOWN: `Zzzz`\n+ * @HB_SCRIPT_ARABIC: `Arab`\n+ * @HB_SCRIPT_ARMENIAN: `Armn`\n+ * @HB_SCRIPT_BENGALI: `Beng`\n+ * @HB_SCRIPT_CYRILLIC: `Cyrl`\n+ * @HB_SCRIPT_DEVANAGARI: `Deva`\n+ * @HB_SCRIPT_GEORGIAN: `Geor`\n+ * @HB_SCRIPT_GREEK: `Grek`\n+ * @HB_SCRIPT_GUJARATI: `Gujr`\n+ * @HB_SCRIPT_GURMUKHI: `Guru`\n+ * @HB_SCRIPT_HANGUL: `Hang`\n+ * @HB_SCRIPT_HAN: `Hani`\n+ * @HB_SCRIPT_HEBREW: `Hebr`\n+ * @HB_SCRIPT_HIRAGANA: `Hira`\n+ * @HB_SCRIPT_KANNADA: `Knda`\n+ * @HB_SCRIPT_KATAKANA: `Kana`\n+ * @HB_SCRIPT_LAO: `Laoo`\n+ * @HB_SCRIPT_LATIN: `Latn`\n+ * @HB_SCRIPT_MALAYALAM: `Mlym`\n+ * @HB_SCRIPT_ORIYA: `Orya`\n+ * @HB_SCRIPT_TAMIL: `Taml`\n+ * @HB_SCRIPT_TELUGU: `Telu`\n+ * @HB_SCRIPT_THAI: `Thai`\n+ * @HB_SCRIPT_TIBETAN: `Tibt`\n+ * @HB_SCRIPT_BOPOMOFO: `Bopo`\n+ * @HB_SCRIPT_BRAILLE: `Brai`\n+ * @HB_SCRIPT_CANADIAN_SYLLABICS: `Cans`\n+ * @HB_SCRIPT_CHEROKEE: `Cher`\n+ * @HB_SCRIPT_ETHIOPIC: `Ethi`\n+ * @HB_SCRIPT_KHMER: `Khmr`\n+ * @HB_SCRIPT_MONGOLIAN: `Mong`\n+ * @HB_SCRIPT_MYANMAR: `Mymr`\n+ * @HB_SCRIPT_OGHAM: `Ogam`\n+ * @HB_SCRIPT_RUNIC: `Runr`\n+ * @HB_SCRIPT_SINHALA: `Sinh`\n+ * @HB_SCRIPT_SYRIAC: `Syrc`\n+ * @HB_SCRIPT_THAANA: `Thaa`\n+ * @HB_SCRIPT_YI: `Yiii`\n+ * @HB_SCRIPT_DESERET: `Dsrt`\n+ * @HB_SCRIPT_GOTHIC: `Goth`\n+ * @HB_SCRIPT_OLD_ITALIC: `Ital`\n+ * @HB_SCRIPT_BUHID: `Buhd`\n+ * @HB_SCRIPT_HANUNOO: `Hano`\n+ * @HB_SCRIPT_TAGALOG: `Tglg`\n+ * @HB_SCRIPT_TAGBANWA: `Tagb`\n+ * @HB_SCRIPT_CYPRIOT: `Cprt`\n+ * @HB_SCRIPT_LIMBU: `Limb`\n+ * @HB_SCRIPT_LINEAR_B: `Linb`\n+ * @HB_SCRIPT_OSMANYA: `Osma`\n+ * @HB_SCRIPT_SHAVIAN: `Shaw`\n+ * @HB_SCRIPT_TAI_LE: `Tale`\n+ * @HB_SCRIPT_UGARITIC: `Ugar`\n+ * @HB_SCRIPT_BUGINESE: `Bugi`\n+ * @HB_SCRIPT_COPTIC: `Copt`\n+ * @HB_SCRIPT_GLAGOLITIC: `Glag`\n+ * @HB_SCRIPT_KHAROSHTHI: `Khar`\n+ * @HB_SCRIPT_NEW_TAI_LUE: `Talu`\n+ * @HB_SCRIPT_OLD_PERSIAN: `Xpeo`\n+ * @HB_SCRIPT_SYLOTI_NAGRI: `Sylo`\n+ * @HB_SCRIPT_TIFINAGH: `Tfng`\n+ * @HB_SCRIPT_BALINESE: `Bali`\n+ * @HB_SCRIPT_CUNEIFORM: `Xsux`\n+ * @HB_SCRIPT_NKO: `Nkoo`\n+ * @HB_SCRIPT_PHAGS_PA: `Phag`\n+ * @HB_SCRIPT_PHOENICIAN: `Phnx`\n+ * @HB_SCRIPT_CARIAN: `Cari`\n+ * @HB_SCRIPT_CHAM: `Cham`\n+ * @HB_SCRIPT_KAYAH_LI: `Kali`\n+ * @HB_SCRIPT_LEPCHA: `Lepc`\n+ * @HB_SCRIPT_LYCIAN: `Lyci`\n+ * @HB_SCRIPT_LYDIAN: `Lydi`\n+ * @HB_SCRIPT_OL_CHIKI: `Olck`\n+ * @HB_SCRIPT_REJANG: `Rjng`\n+ * @HB_SCRIPT_SAURASHTRA: `Saur`\n+ * @HB_SCRIPT_SUNDANESE: `Sund`\n+ * @HB_SCRIPT_VAI: `Vaii`\n+ * @HB_SCRIPT_AVESTAN: `Avst`\n+ * @HB_SCRIPT_BAMUM: `Bamu`\n+ * @HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: `Egyp`\n+ * @HB_SCRIPT_IMPERIAL_ARAMAIC: `Armi`\n+ * @HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: `Phli`\n+ * @HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: `Prti`\n+ * @HB_SCRIPT_JAVANESE: `Java`\n+ * @HB_SCRIPT_KAITHI: `Kthi`\n+ * @HB_SCRIPT_LISU: `Lisu`\n+ * @HB_SCRIPT_MEETEI_MAYEK: `Mtei`\n+ * @HB_SCRIPT_OLD_SOUTH_ARABIAN: `Sarb`\n+ * @HB_SCRIPT_OLD_TURKIC: `Orkh`\n+ * @HB_SCRIPT_SAMARITAN: `Samr`\n+ * @HB_SCRIPT_TAI_THAM: `Lana`\n+ * @HB_SCRIPT_TAI_VIET: `Tavt`\n+ * @HB_SCRIPT_BATAK: `Batk`\n+ * @HB_SCRIPT_BRAHMI: `Brah`\n+ * @HB_SCRIPT_MANDAIC: `Mand`\n+ * @HB_SCRIPT_CHAKMA: `Cakm`\n+ * @HB_SCRIPT_MEROITIC_CURSIVE: `Merc`\n+ * @HB_SCRIPT_MEROITIC_HIEROGLYPHS: `Mero`\n+ * @HB_SCRIPT_MIAO: `Plrd`\n+ * @HB_SCRIPT_SHARADA: `Shrd`\n+ * @HB_SCRIPT_SORA_SOMPENG: `Sora`\n+ * @HB_SCRIPT_TAKRI: `Takr`\n+ * @HB_SCRIPT_BASSA_VAH: `Bass`, Since: 0.9.30\n+ * @HB_SCRIPT_CAUCASIAN_ALBANIAN: `Aghb`, Since: 0.9.30\n+ * @HB_SCRIPT_DUPLOYAN: `Dupl`, Since: 0.9.30\n+ * @HB_SCRIPT_ELBASAN: `Elba`, Since: 0.9.30\n+ * @HB_SCRIPT_GRANTHA: `Gran`, Since: 0.9.30\n+ * @HB_SCRIPT_KHOJKI: `Khoj`, Since: 0.9.30\n+ * @HB_SCRIPT_KHUDAWADI: `Sind`, Since: 0.9.30\n+ * @HB_SCRIPT_LINEAR_A: `Lina`, Since: 0.9.30\n+ * @HB_SCRIPT_MAHAJANI: `Mahj`, Since: 0.9.30\n+ * @HB_SCRIPT_MANICHAEAN: `Mani`, Since: 0.9.30\n+ * @HB_SCRIPT_MENDE_KIKAKUI: `Mend`, Since: 0.9.30\n+ * @HB_SCRIPT_MODI: `Modi`, Since: 0.9.30\n+ * @HB_SCRIPT_MRO: `Mroo`, Since: 0.9.30\n+ * @HB_SCRIPT_NABATAEAN: `Nbat`, Since: 0.9.30\n+ * @HB_SCRIPT_OLD_NORTH_ARABIAN: `Narb`, Since: 0.9.30\n+ * @HB_SCRIPT_OLD_PERMIC: `Perm`, Since: 0.9.30\n+ * @HB_SCRIPT_PAHAWH_HMONG: `Hmng`, Since: 0.9.30\n+ * @HB_SCRIPT_PALMYRENE: `Palm`, Since: 0.9.30\n+ * @HB_SCRIPT_PAU_CIN_HAU: `Pauc`, Since: 0.9.30\n+ * @HB_SCRIPT_PSALTER_PAHLAVI: `Phlp`, Since: 0.9.30\n+ * @HB_SCRIPT_SIDDHAM: `Sidd`, Since: 0.9.30\n+ * @HB_SCRIPT_TIRHUTA: `Tirh`, Since: 0.9.30\n+ * @HB_SCRIPT_WARANG_CITI: `Wara`, Since: 0.9.30\n+ * @HB_SCRIPT_AHOM: `Ahom`, Since: 0.9.30\n+ * @HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: `Hluw`, Since: 0.9.30\n+ * @HB_SCRIPT_HATRAN: `Hatr`, Since: 0.9.30\n+ * @HB_SCRIPT_MULTANI: `Mult`, Since: 0.9.30\n+ * @HB_SCRIPT_OLD_HUNGARIAN: `Hung`, Since: 0.9.30\n+ * @HB_SCRIPT_SIGNWRITING: `Sgnw`, Since: 0.9.30\n+ * @HB_SCRIPT_ADLAM: `Adlm`, Since: 1.3.0\n+ * @HB_SCRIPT_BHAIKSUKI: `Bhks`, Since: 1.3.0\n+ * @HB_SCRIPT_MARCHEN: `Marc`, Since: 1.3.0\n+ * @HB_SCRIPT_OSAGE: `Osge`, Since: 1.3.0\n+ * @HB_SCRIPT_TANGUT: `Tang`, Since: 1.3.0\n+ * @HB_SCRIPT_NEWA: `Newa`, Since: 1.3.0\n+ * @HB_SCRIPT_MASARAM_GONDI: `Gonm`, Since: 1.6.0\n+ * @HB_SCRIPT_NUSHU: `Nshu`, Since: 1.6.0\n+ * @HB_SCRIPT_SOYOMBO: `Soyo`, Since: 1.6.0\n+ * @HB_SCRIPT_ZANABAZAR_SQUARE: `Zanb`, Since: 1.6.0\n+ * @HB_SCRIPT_DOGRA: `Dogr`, Since: 1.8.0\n+ * @HB_SCRIPT_GUNJALA_GONDI: `Gong`, Since: 1.8.0\n+ * @HB_SCRIPT_HANIFI_ROHINGYA: `Rohg`, Since: 1.8.0\n+ * @HB_SCRIPT_MAKASAR: `Maka`, Since: 1.8.0\n+ * @HB_SCRIPT_MEDEFAIDRIN: `Medf`, Since: 1.8.0\n+ * @HB_SCRIPT_OLD_SOGDIAN: `Sogo`, Since: 1.8.0\n+ * @HB_SCRIPT_SOGDIAN: `Sogd`, Since: 1.8.0\n+ * @HB_SCRIPT_ELYMAIC: `Elym`, Since: 2.4.0\n+ * @HB_SCRIPT_NANDINAGARI: `Nand`, Since: 2.4.0\n+ * @HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: `Hmnp`, Since: 2.4.0\n+ * @HB_SCRIPT_WANCHO: `Wcho`, Since: 2.4.0\n+ * @HB_SCRIPT_CHORASMIAN: `Chrs`, Since: 2.6.7\n+ * @HB_SCRIPT_DIVES_AKURU: `Diak`, Since: 2.6.7\n+ * @HB_SCRIPT_KHITAN_SMALL_SCRIPT: `Kits`, Since: 2.6.7\n+ * @HB_SCRIPT_YEZIDI: `Yezi`, Since: 2.6.7\n+ * @HB_SCRIPT_CYPRO_MINOAN: `Cpmn`, Since: 3.0.0\n+ * @HB_SCRIPT_OLD_UYGHUR: `Ougr`, Since: 3.0.0\n+ * @HB_SCRIPT_TANGSA: `Tnsa`, Since: 3.0.0\n+ * @HB_SCRIPT_TOTO: `Toto`, Since: 3.0.0\n+ * @HB_SCRIPT_VITHKUQI: `Vith`, Since: 3.0.0\n+ * @HB_SCRIPT_MATH: `Zmth`, Since: 3.4.0\n+ * @HB_SCRIPT_KAWI: `Kawi`, Since: 5.2.0\n+ * @HB_SCRIPT_NAG_MUNDARI: `Nagm`, Since: 5.2.0\n+ * @HB_SCRIPT_GARAY: `Gara`, Since: 10.0.0\n+ * @HB_SCRIPT_GURUNG_KHEMA: `Gukh`, Since: 10.0.0\n+ * @HB_SCRIPT_KIRAT_RAI: `Krai`, Since: 10.0.0\n+ * @HB_SCRIPT_OL_ONAL: `Onao`, Since: 10.0.0\n+ * @HB_SCRIPT_SUNUWAR: `Sunu`, Since: 10.0.0\n+ * @HB_SCRIPT_TODHRI: `Todr`, Since: 10.0.0\n+ * @HB_SCRIPT_TULU_TIGALARI: `Tutg`, Since: 10.0.0\n+ * @HB_SCRIPT_INVALID: No script set\n+ *\n+ * Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding\n+ * to the four-letter values defined by [ISO 15924](https:\/\/unicode.org\/iso15924\/).\n+ *\n+ * See also the Script (sc) property of the Unicode Character Database.\n+ *\n+ **\/\n+\n+\/* https:\/\/docs.google.com\/spreadsheets\/d\/1Y90M0Ie3MUJ6UVCRDOypOtijlMDLNNyyLk36T6iMu0o *\/\n+typedef enum\n+{\n+  HB_SCRIPT_COMMON                      = HB_TAG ('Z','y','y','y'), \/*1.1*\/\n+  HB_SCRIPT_INHERITED                   = HB_TAG ('Z','i','n','h'), \/*1.1*\/\n+  HB_SCRIPT_UNKNOWN                     = HB_TAG ('Z','z','z','z'), \/*5.0*\/\n+\n+  HB_SCRIPT_ARABIC                      = HB_TAG ('A','r','a','b'), \/*1.1*\/\n+  HB_SCRIPT_ARMENIAN                    = HB_TAG ('A','r','m','n'), \/*1.1*\/\n+  HB_SCRIPT_BENGALI                     = HB_TAG ('B','e','n','g'), \/*1.1*\/\n+  HB_SCRIPT_CYRILLIC                    = HB_TAG ('C','y','r','l'), \/*1.1*\/\n+  HB_SCRIPT_DEVANAGARI                  = HB_TAG ('D','e','v','a'), \/*1.1*\/\n+  HB_SCRIPT_GEORGIAN                    = HB_TAG ('G','e','o','r'), \/*1.1*\/\n+  HB_SCRIPT_GREEK                       = HB_TAG ('G','r','e','k'), \/*1.1*\/\n+  HB_SCRIPT_GUJARATI                    = HB_TAG ('G','u','j','r'), \/*1.1*\/\n+  HB_SCRIPT_GURMUKHI                    = HB_TAG ('G','u','r','u'), \/*1.1*\/\n+  HB_SCRIPT_HANGUL                      = HB_TAG ('H','a','n','g'), \/*1.1*\/\n+  HB_SCRIPT_HAN                         = HB_TAG ('H','a','n','i'), \/*1.1*\/\n+  HB_SCRIPT_HEBREW                      = HB_TAG ('H','e','b','r'), \/*1.1*\/\n+  HB_SCRIPT_HIRAGANA                    = HB_TAG ('H','i','r','a'), \/*1.1*\/\n+  HB_SCRIPT_KANNADA                     = HB_TAG ('K','n','d','a'), \/*1.1*\/\n+  HB_SCRIPT_KATAKANA                    = HB_TAG ('K','a','n','a'), \/*1.1*\/\n+  HB_SCRIPT_LAO                         = HB_TAG ('L','a','o','o'), \/*1.1*\/\n+  HB_SCRIPT_LATIN                       = HB_TAG ('L','a','t','n'), \/*1.1*\/\n+  HB_SCRIPT_MALAYALAM                   = HB_TAG ('M','l','y','m'), \/*1.1*\/\n+  HB_SCRIPT_ORIYA                       = HB_TAG ('O','r','y','a'), \/*1.1*\/\n+  HB_SCRIPT_TAMIL                       = HB_TAG ('T','a','m','l'), \/*1.1*\/\n+  HB_SCRIPT_TELUGU                      = HB_TAG ('T','e','l','u'), \/*1.1*\/\n+  HB_SCRIPT_THAI                        = HB_TAG ('T','h','a','i'), \/*1.1*\/\n+\n+  HB_SCRIPT_TIBETAN                     = HB_TAG ('T','i','b','t'), \/*2.0*\/\n+\n+  HB_SCRIPT_BOPOMOFO                    = HB_TAG ('B','o','p','o'), \/*3.0*\/\n+  HB_SCRIPT_BRAILLE                     = HB_TAG ('B','r','a','i'), \/*3.0*\/\n+  HB_SCRIPT_CANADIAN_SYLLABICS          = HB_TAG ('C','a','n','s'), \/*3.0*\/\n+  HB_SCRIPT_CHEROKEE                    = HB_TAG ('C','h','e','r'), \/*3.0*\/\n+  HB_SCRIPT_ETHIOPIC                    = HB_TAG ('E','t','h','i'), \/*3.0*\/\n+  HB_SCRIPT_KHMER                       = HB_TAG ('K','h','m','r'), \/*3.0*\/\n+  HB_SCRIPT_MONGOLIAN                   = HB_TAG ('M','o','n','g'), \/*3.0*\/\n+  HB_SCRIPT_MYANMAR                     = HB_TAG ('M','y','m','r'), \/*3.0*\/\n+  HB_SCRIPT_OGHAM                       = HB_TAG ('O','g','a','m'), \/*3.0*\/\n+  HB_SCRIPT_RUNIC                       = HB_TAG ('R','u','n','r'), \/*3.0*\/\n+  HB_SCRIPT_SINHALA                     = HB_TAG ('S','i','n','h'), \/*3.0*\/\n+  HB_SCRIPT_SYRIAC                      = HB_TAG ('S','y','r','c'), \/*3.0*\/\n+  HB_SCRIPT_THAANA                      = HB_TAG ('T','h','a','a'), \/*3.0*\/\n+  HB_SCRIPT_YI                          = HB_TAG ('Y','i','i','i'), \/*3.0*\/\n+\n+  HB_SCRIPT_DESERET                     = HB_TAG ('D','s','r','t'), \/*3.1*\/\n+  HB_SCRIPT_GOTHIC                      = HB_TAG ('G','o','t','h'), \/*3.1*\/\n+  HB_SCRIPT_OLD_ITALIC                  = HB_TAG ('I','t','a','l'), \/*3.1*\/\n+\n+  HB_SCRIPT_BUHID                       = HB_TAG ('B','u','h','d'), \/*3.2*\/\n+  HB_SCRIPT_HANUNOO                     = HB_TAG ('H','a','n','o'), \/*3.2*\/\n+  HB_SCRIPT_TAGALOG                     = HB_TAG ('T','g','l','g'), \/*3.2*\/\n+  HB_SCRIPT_TAGBANWA                    = HB_TAG ('T','a','g','b'), \/*3.2*\/\n+\n+  HB_SCRIPT_CYPRIOT                     = HB_TAG ('C','p','r','t'), \/*4.0*\/\n+  HB_SCRIPT_LIMBU                       = HB_TAG ('L','i','m','b'), \/*4.0*\/\n+  HB_SCRIPT_LINEAR_B                    = HB_TAG ('L','i','n','b'), \/*4.0*\/\n+  HB_SCRIPT_OSMANYA                     = HB_TAG ('O','s','m','a'), \/*4.0*\/\n+  HB_SCRIPT_SHAVIAN                     = HB_TAG ('S','h','a','w'), \/*4.0*\/\n+  HB_SCRIPT_TAI_LE                      = HB_TAG ('T','a','l','e'), \/*4.0*\/\n+  HB_SCRIPT_UGARITIC                    = HB_TAG ('U','g','a','r'), \/*4.0*\/\n+\n+  HB_SCRIPT_BUGINESE                    = HB_TAG ('B','u','g','i'), \/*4.1*\/\n+  HB_SCRIPT_COPTIC                      = HB_TAG ('C','o','p','t'), \/*4.1*\/\n+  HB_SCRIPT_GLAGOLITIC                  = HB_TAG ('G','l','a','g'), \/*4.1*\/\n+  HB_SCRIPT_KHAROSHTHI                  = HB_TAG ('K','h','a','r'), \/*4.1*\/\n+  HB_SCRIPT_NEW_TAI_LUE                 = HB_TAG ('T','a','l','u'), \/*4.1*\/\n+  HB_SCRIPT_OLD_PERSIAN                 = HB_TAG ('X','p','e','o'), \/*4.1*\/\n+  HB_SCRIPT_SYLOTI_NAGRI                = HB_TAG ('S','y','l','o'), \/*4.1*\/\n+  HB_SCRIPT_TIFINAGH                    = HB_TAG ('T','f','n','g'), \/*4.1*\/\n+\n+  HB_SCRIPT_BALINESE                    = HB_TAG ('B','a','l','i'), \/*5.0*\/\n+  HB_SCRIPT_CUNEIFORM                   = HB_TAG ('X','s','u','x'), \/*5.0*\/\n+  HB_SCRIPT_NKO                         = HB_TAG ('N','k','o','o'), \/*5.0*\/\n+  HB_SCRIPT_PHAGS_PA                    = HB_TAG ('P','h','a','g'), \/*5.0*\/\n+  HB_SCRIPT_PHOENICIAN                  = HB_TAG ('P','h','n','x'), \/*5.0*\/\n+\n+  HB_SCRIPT_CARIAN                      = HB_TAG ('C','a','r','i'), \/*5.1*\/\n+  HB_SCRIPT_CHAM                        = HB_TAG ('C','h','a','m'), \/*5.1*\/\n+  HB_SCRIPT_KAYAH_LI                    = HB_TAG ('K','a','l','i'), \/*5.1*\/\n+  HB_SCRIPT_LEPCHA                      = HB_TAG ('L','e','p','c'), \/*5.1*\/\n+  HB_SCRIPT_LYCIAN                      = HB_TAG ('L','y','c','i'), \/*5.1*\/\n+  HB_SCRIPT_LYDIAN                      = HB_TAG ('L','y','d','i'), \/*5.1*\/\n+  HB_SCRIPT_OL_CHIKI                    = HB_TAG ('O','l','c','k'), \/*5.1*\/\n+  HB_SCRIPT_REJANG                      = HB_TAG ('R','j','n','g'), \/*5.1*\/\n+  HB_SCRIPT_SAURASHTRA                  = HB_TAG ('S','a','u','r'), \/*5.1*\/\n+  HB_SCRIPT_SUNDANESE                   = HB_TAG ('S','u','n','d'), \/*5.1*\/\n+  HB_SCRIPT_VAI                         = HB_TAG ('V','a','i','i'), \/*5.1*\/\n+\n+  HB_SCRIPT_AVESTAN                     = HB_TAG ('A','v','s','t'), \/*5.2*\/\n+  HB_SCRIPT_BAMUM                       = HB_TAG ('B','a','m','u'), \/*5.2*\/\n+  HB_SCRIPT_EGYPTIAN_HIEROGLYPHS        = HB_TAG ('E','g','y','p'), \/*5.2*\/\n+  HB_SCRIPT_IMPERIAL_ARAMAIC            = HB_TAG ('A','r','m','i'), \/*5.2*\/\n+  HB_SCRIPT_INSCRIPTIONAL_PAHLAVI       = HB_TAG ('P','h','l','i'), \/*5.2*\/\n+  HB_SCRIPT_INSCRIPTIONAL_PARTHIAN      = HB_TAG ('P','r','t','i'), \/*5.2*\/\n+  HB_SCRIPT_JAVANESE                    = HB_TAG ('J','a','v','a'), \/*5.2*\/\n+  HB_SCRIPT_KAITHI                      = HB_TAG ('K','t','h','i'), \/*5.2*\/\n+  HB_SCRIPT_LISU                        = HB_TAG ('L','i','s','u'), \/*5.2*\/\n+  HB_SCRIPT_MEETEI_MAYEK                = HB_TAG ('M','t','e','i'), \/*5.2*\/\n+  HB_SCRIPT_OLD_SOUTH_ARABIAN           = HB_TAG ('S','a','r','b'), \/*5.2*\/\n+  HB_SCRIPT_OLD_TURKIC                  = HB_TAG ('O','r','k','h'), \/*5.2*\/\n+  HB_SCRIPT_SAMARITAN                   = HB_TAG ('S','a','m','r'), \/*5.2*\/\n+  HB_SCRIPT_TAI_THAM                    = HB_TAG ('L','a','n','a'), \/*5.2*\/\n+  HB_SCRIPT_TAI_VIET                    = HB_TAG ('T','a','v','t'), \/*5.2*\/\n+\n+  HB_SCRIPT_BATAK                       = HB_TAG ('B','a','t','k'), \/*6.0*\/\n+  HB_SCRIPT_BRAHMI                      = HB_TAG ('B','r','a','h'), \/*6.0*\/\n+  HB_SCRIPT_MANDAIC                     = HB_TAG ('M','a','n','d'), \/*6.0*\/\n+\n+  HB_SCRIPT_CHAKMA                      = HB_TAG ('C','a','k','m'), \/*6.1*\/\n+  HB_SCRIPT_MEROITIC_CURSIVE            = HB_TAG ('M','e','r','c'), \/*6.1*\/\n+  HB_SCRIPT_MEROITIC_HIEROGLYPHS        = HB_TAG ('M','e','r','o'), \/*6.1*\/\n+  HB_SCRIPT_MIAO                        = HB_TAG ('P','l','r','d'), \/*6.1*\/\n+  HB_SCRIPT_SHARADA                     = HB_TAG ('S','h','r','d'), \/*6.1*\/\n+  HB_SCRIPT_SORA_SOMPENG                = HB_TAG ('S','o','r','a'), \/*6.1*\/\n+  HB_SCRIPT_TAKRI                       = HB_TAG ('T','a','k','r'), \/*6.1*\/\n+\n+  \/*\n+   * Since: 0.9.30\n+   *\/\n+  HB_SCRIPT_BASSA_VAH                   = HB_TAG ('B','a','s','s'), \/*7.0*\/\n+  HB_SCRIPT_CAUCASIAN_ALBANIAN          = HB_TAG ('A','g','h','b'), \/*7.0*\/\n+  HB_SCRIPT_DUPLOYAN                    = HB_TAG ('D','u','p','l'), \/*7.0*\/\n+  HB_SCRIPT_ELBASAN                     = HB_TAG ('E','l','b','a'), \/*7.0*\/\n+  HB_SCRIPT_GRANTHA                     = HB_TAG ('G','r','a','n'), \/*7.0*\/\n+  HB_SCRIPT_KHOJKI                      = HB_TAG ('K','h','o','j'), \/*7.0*\/\n+  HB_SCRIPT_KHUDAWADI                   = HB_TAG ('S','i','n','d'), \/*7.0*\/\n+  HB_SCRIPT_LINEAR_A                    = HB_TAG ('L','i','n','a'), \/*7.0*\/\n+  HB_SCRIPT_MAHAJANI                    = HB_TAG ('M','a','h','j'), \/*7.0*\/\n+  HB_SCRIPT_MANICHAEAN                  = HB_TAG ('M','a','n','i'), \/*7.0*\/\n+  HB_SCRIPT_MENDE_KIKAKUI               = HB_TAG ('M','e','n','d'), \/*7.0*\/\n+  HB_SCRIPT_MODI                        = HB_TAG ('M','o','d','i'), \/*7.0*\/\n+  HB_SCRIPT_MRO                         = HB_TAG ('M','r','o','o'), \/*7.0*\/\n+  HB_SCRIPT_NABATAEAN                   = HB_TAG ('N','b','a','t'), \/*7.0*\/\n+  HB_SCRIPT_OLD_NORTH_ARABIAN           = HB_TAG ('N','a','r','b'), \/*7.0*\/\n+  HB_SCRIPT_OLD_PERMIC                  = HB_TAG ('P','e','r','m'), \/*7.0*\/\n+  HB_SCRIPT_PAHAWH_HMONG                = HB_TAG ('H','m','n','g'), \/*7.0*\/\n+  HB_SCRIPT_PALMYRENE                   = HB_TAG ('P','a','l','m'), \/*7.0*\/\n+  HB_SCRIPT_PAU_CIN_HAU                 = HB_TAG ('P','a','u','c'), \/*7.0*\/\n+  HB_SCRIPT_PSALTER_PAHLAVI             = HB_TAG ('P','h','l','p'), \/*7.0*\/\n+  HB_SCRIPT_SIDDHAM                     = HB_TAG ('S','i','d','d'), \/*7.0*\/\n+  HB_SCRIPT_TIRHUTA                     = HB_TAG ('T','i','r','h'), \/*7.0*\/\n+  HB_SCRIPT_WARANG_CITI                 = HB_TAG ('W','a','r','a'), \/*7.0*\/\n+\n+  HB_SCRIPT_AHOM                        = HB_TAG ('A','h','o','m'), \/*8.0*\/\n+  HB_SCRIPT_ANATOLIAN_HIEROGLYPHS       = HB_TAG ('H','l','u','w'), \/*8.0*\/\n+  HB_SCRIPT_HATRAN                      = HB_TAG ('H','a','t','r'), \/*8.0*\/\n+  HB_SCRIPT_MULTANI                     = HB_TAG ('M','u','l','t'), \/*8.0*\/\n+  HB_SCRIPT_OLD_HUNGARIAN               = HB_TAG ('H','u','n','g'), \/*8.0*\/\n+  HB_SCRIPT_SIGNWRITING                 = HB_TAG ('S','g','n','w'), \/*8.0*\/\n+\n+  \/*\n+   * Since 1.3.0\n+   *\/\n+  HB_SCRIPT_ADLAM                       = HB_TAG ('A','d','l','m'), \/*9.0*\/\n+  HB_SCRIPT_BHAIKSUKI                   = HB_TAG ('B','h','k','s'), \/*9.0*\/\n+  HB_SCRIPT_MARCHEN                     = HB_TAG ('M','a','r','c'), \/*9.0*\/\n+  HB_SCRIPT_OSAGE                       = HB_TAG ('O','s','g','e'), \/*9.0*\/\n+  HB_SCRIPT_TANGUT                      = HB_TAG ('T','a','n','g'), \/*9.0*\/\n+  HB_SCRIPT_NEWA                        = HB_TAG ('N','e','w','a'), \/*9.0*\/\n+\n+  \/*\n+   * Since 1.6.0\n+   *\/\n+  HB_SCRIPT_MASARAM_GONDI               = HB_TAG ('G','o','n','m'), \/*10.0*\/\n+  HB_SCRIPT_NUSHU                       = HB_TAG ('N','s','h','u'), \/*10.0*\/\n+  HB_SCRIPT_SOYOMBO                     = HB_TAG ('S','o','y','o'), \/*10.0*\/\n+  HB_SCRIPT_ZANABAZAR_SQUARE            = HB_TAG ('Z','a','n','b'), \/*10.0*\/\n+\n+  \/*\n+   * Since 1.8.0\n+   *\/\n+  HB_SCRIPT_DOGRA                       = HB_TAG ('D','o','g','r'), \/*11.0*\/\n+  HB_SCRIPT_GUNJALA_GONDI               = HB_TAG ('G','o','n','g'), \/*11.0*\/\n+  HB_SCRIPT_HANIFI_ROHINGYA             = HB_TAG ('R','o','h','g'), \/*11.0*\/\n+  HB_SCRIPT_MAKASAR                     = HB_TAG ('M','a','k','a'), \/*11.0*\/\n+  HB_SCRIPT_MEDEFAIDRIN                 = HB_TAG ('M','e','d','f'), \/*11.0*\/\n+  HB_SCRIPT_OLD_SOGDIAN                 = HB_TAG ('S','o','g','o'), \/*11.0*\/\n+  HB_SCRIPT_SOGDIAN                     = HB_TAG ('S','o','g','d'), \/*11.0*\/\n+\n+  \/*\n+   * Since 2.4.0\n+   *\/\n+  HB_SCRIPT_ELYMAIC                     = HB_TAG ('E','l','y','m'), \/*12.0*\/\n+  HB_SCRIPT_NANDINAGARI                 = HB_TAG ('N','a','n','d'), \/*12.0*\/\n+  HB_SCRIPT_NYIAKENG_PUACHUE_HMONG      = HB_TAG ('H','m','n','p'), \/*12.0*\/\n+  HB_SCRIPT_WANCHO                      = HB_TAG ('W','c','h','o'), \/*12.0*\/\n+\n+  \/*\n+   * Since 2.6.7\n+   *\/\n+  HB_SCRIPT_CHORASMIAN                  = HB_TAG ('C','h','r','s'), \/*13.0*\/\n+  HB_SCRIPT_DIVES_AKURU                 = HB_TAG ('D','i','a','k'), \/*13.0*\/\n+  HB_SCRIPT_KHITAN_SMALL_SCRIPT         = HB_TAG ('K','i','t','s'), \/*13.0*\/\n+  HB_SCRIPT_YEZIDI                      = HB_TAG ('Y','e','z','i'), \/*13.0*\/\n+\n+  \/*\n+   * Since 3.0.0\n+   *\/\n+  HB_SCRIPT_CYPRO_MINOAN                = HB_TAG ('C','p','m','n'), \/*14.0*\/\n+  HB_SCRIPT_OLD_UYGHUR                  = HB_TAG ('O','u','g','r'), \/*14.0*\/\n+  HB_SCRIPT_TANGSA                      = HB_TAG ('T','n','s','a'), \/*14.0*\/\n+  HB_SCRIPT_TOTO                        = HB_TAG ('T','o','t','o'), \/*14.0*\/\n+  HB_SCRIPT_VITHKUQI                    = HB_TAG ('V','i','t','h'), \/*14.0*\/\n+\n+  \/*\n+   * Since 3.4.0\n+   *\/\n+  HB_SCRIPT_MATH                        = HB_TAG ('Z','m','t','h'),\n+\n+  \/*\n+   * Since 5.2.0\n+   *\/\n+  HB_SCRIPT_KAWI                        = HB_TAG ('K','a','w','i'), \/*15.0*\/\n+  HB_SCRIPT_NAG_MUNDARI                 = HB_TAG ('N','a','g','m'), \/*15.0*\/\n+\n+  \/*\n+   * Since 10.0.0\n+   *\/\n+  HB_SCRIPT_GARAY                       = HB_TAG ('G','a','r','a'), \/*16.0*\/\n+  HB_SCRIPT_GURUNG_KHEMA                = HB_TAG ('G','u','k','h'), \/*16.0*\/\n+  HB_SCRIPT_KIRAT_RAI                   = HB_TAG ('K','r','a','i'), \/*16.0*\/\n+  HB_SCRIPT_OL_ONAL                     = HB_TAG ('O','n','a','o'), \/*16.0*\/\n+  HB_SCRIPT_SUNUWAR                     = HB_TAG ('S','u','n','u'), \/*16.0*\/\n+  HB_SCRIPT_TODHRI                      = HB_TAG ('T','o','d','r'), \/*16.0*\/\n+  HB_SCRIPT_TULU_TIGALARI               = HB_TAG ('T','u','t','g'), \/*16.0*\/\n+\n+  \/* No script set. *\/\n+  HB_SCRIPT_INVALID                     = HB_TAG_NONE,\n+\n+  \/*< private >*\/\n+\n+  \/* Dummy values to ensure any hb_tag_t value can be passed\/stored as hb_script_t\n+   * without risking undefined behavior.  We have two, for historical reasons.\n+   * HB_TAG_MAX used to be unsigned, but that was invalid Ansi C, so was changed\n+   * to _HB_SCRIPT_MAX_VALUE to be equal to HB_TAG_MAX_SIGNED as well.\n+   *\n+   * See this thread for technicalities:\n+   *\n+   *   https:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2014-March\/004150.html\n+   *\/\n+  _HB_SCRIPT_MAX_VALUE                          = HB_TAG_MAX_SIGNED, \/*< skip >*\/\n+  _HB_SCRIPT_MAX_VALUE_SIGNED                   = HB_TAG_MAX_SIGNED \/*< skip >*\/\n+\n+} hb_script_t;\n+\n+\n+#endif \/* HB_SCRIPT_LIST_H *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-script-list.h","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -34,5 +34,4 @@\n- * The set-digests here implement various \"filters\" that support\n- * \"approximate member query\".  Conceptually these are like Bloom\n- * Filter and Quotient Filter, however, much smaller, faster, and\n- * designed to fit the requirements of our uses for glyph coverage\n- * queries.\n+ * The set-digests implement \"filters\" that support \"approximate\n+ * member query\".  Conceptually these are like Bloom Filter and\n+ * Quotient Filter, however, much smaller, faster, and designed\n+ * to fit the requirements of our uses for glyph coverage queries.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set-digest.hh","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-bit-vector.hh\" \/\/ Just to include\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,2 +94,4 @@\n- * Return value: (transfer none) (array zero-terminated=1): an array of\n- *    constant strings\n+ * Return value: (transfer none) (array zero-terminated=1): a\n+ *    `NULL`-terminated array of supported shapers constant string.\n+ *    The returned array is owned by HarfBuzz and should not be\n+ *    modified or freed.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.cc","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-static.cc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-  mutable hb_atomic_ptr_t<glyph_to_sid_map_t> glyph_to_sid_map;\n+  mutable hb_atomic_t<glyph_to_sid_map_t *> glyph_to_sid_map;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff-common.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-          printf (\"Non-ascii character detected, ignored...This API supports ascii characters only for mac platform\\n\");\n+          \/\/ Non-ascii character detected, ignored...\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"hb-subset.h\"\n+#include \"hb-unicode.h\"\n@@ -36,3 +38,0 @@\n-#include \"hb-ot-layout-gdef-table.hh\"\n-#include \"hb-ot-layout-gpos-table.hh\"\n-#include \"hb-ot-layout-gsub-table.hh\"\n@@ -45,1 +44,0 @@\n-#include \"hb-ot-var-avar-table.hh\"\n@@ -49,4 +47,0 @@\n-using OT::Layout::GSUB;\n-using OT::Layout::GPOS;\n-\n-\n@@ -66,1 +60,0 @@\n-typedef hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> script_langsys_map;\n@@ -101,3 +94,3 @@\n-static void\n-_remap_indexes (const hb_set_t *indexes,\n-                hb_map_t       *mapping \/* OUT *\/)\n+void\n+remap_indexes (const hb_set_t *indexes,\n+               hb_map_t       *mapping \/* OUT *\/)\n@@ -107,397 +100,0 @@\n-\n-}\n-\n-#ifndef HB_NO_SUBSET_LAYOUT\n-\n-\/*\n- * Removes all tags from 'tags' that are not in filter. Additionally eliminates any duplicates.\n- * Returns true if anything was removed (not including duplicates).\n- *\/\n-static bool _filter_tag_list(hb_vector_t<hb_tag_t>* tags, \/* IN\/OUT *\/\n-                             const hb_set_t* filter)\n-{\n-  hb_vector_t<hb_tag_t> out;\n-  out.alloc (tags->get_size() + 1); \/\/ +1 is to allocate room for the null terminator.\n-\n-  bool removed = false;\n-  hb_set_t visited;\n-\n-  for (hb_tag_t tag : *tags)\n-  {\n-    if (!tag) continue;\n-    if (visited.has (tag)) continue;\n-\n-    if (!filter->has (tag))\n-    {\n-      removed = true;\n-      continue;\n-    }\n-\n-    visited.add (tag);\n-    out.push (tag);\n-  }\n-\n-  \/\/ The collect function needs a null element to signal end of the array.\n-  out.push (HB_TAG_NONE);\n-\n-  hb_swap (out, *tags);\n-  return removed;\n-}\n-\n-template <typename T>\n-static void _collect_layout_indices (hb_subset_plan_t     *plan,\n-                                     const T&              table,\n-                                     hb_set_t             *lookup_indices, \/* OUT *\/\n-                                     hb_set_t             *feature_indices, \/* OUT *\/\n-                                     hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map, \/* OUT *\/\n-                                     hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map, \/* OUT *\/\n-                                     hb_set_t& catch_all_record_feature_idxes, \/* OUT *\/\n-                                     hb_hashmap_t<unsigned, hb_pair_t<const void*, const void*>>& catch_all_record_idx_feature_map \/* OUT *\/)\n-{\n-  unsigned num_features = table.get_feature_count ();\n-  hb_vector_t<hb_tag_t> features;\n-  if (!plan->check_success (features.resize (num_features))) return;\n-  table.get_feature_tags (0, &num_features, features.arrayZ);\n-  bool retain_all_features = !_filter_tag_list (&features, &plan->layout_features);\n-\n-  unsigned num_scripts = table.get_script_count ();\n-  hb_vector_t<hb_tag_t> scripts;\n-  if (!plan->check_success (scripts.resize (num_scripts))) return;\n-  table.get_script_tags (0, &num_scripts, scripts.arrayZ);\n-  bool retain_all_scripts = !_filter_tag_list (&scripts, &plan->layout_scripts);\n-\n-  if (!plan->check_success (!features.in_error ()) || !features\n-      || !plan->check_success (!scripts.in_error ()) || !scripts)\n-    return;\n-\n-  hb_ot_layout_collect_features (plan->source,\n-                                 T::tableTag,\n-                                 retain_all_scripts ? nullptr : scripts.arrayZ,\n-                                 nullptr,\n-                                 retain_all_features ? nullptr : features.arrayZ,\n-                                 feature_indices);\n-\n-#ifndef HB_NO_VAR\n-  \/\/ collect feature substitutes with variations\n-  if (!plan->user_axes_location.is_empty ())\n-  {\n-    hb_hashmap_t<hb::shared_ptr<hb_map_t>, unsigned> conditionset_map;\n-    OT::hb_collect_feature_substitutes_with_var_context_t c =\n-    {\n-      &plan->axes_old_index_tag_map,\n-      &plan->axes_location,\n-      feature_record_cond_idx_map,\n-      feature_substitutes_map,\n-      catch_all_record_feature_idxes,\n-      feature_indices,\n-      false,\n-      false,\n-      false,\n-      0,\n-      &conditionset_map\n-    };\n-    table.collect_feature_substitutes_with_variations (&c);\n-  }\n-#endif\n-\n-  for (unsigned feature_index : *feature_indices)\n-  {\n-    const OT::Feature* f = &(table.get_feature (feature_index));\n-    const OT::Feature **p = nullptr;\n-    if (feature_substitutes_map->has (feature_index, &p))\n-      f = *p;\n-\n-    f->add_lookup_indexes_to (lookup_indices);\n-  }\n-\n-#ifndef HB_NO_VAR\n-  if (catch_all_record_feature_idxes)\n-  {\n-    for (unsigned feature_index : catch_all_record_feature_idxes)\n-    {\n-      const OT::Feature& f = table.get_feature (feature_index);\n-      f.add_lookup_indexes_to (lookup_indices);\n-      const void *tag = reinterpret_cast<const void*> (&(table.get_feature_list ().get_tag (feature_index)));\n-      catch_all_record_idx_feature_map.set (feature_index, hb_pair (&f, tag));\n-    }\n-  }\n-\n-  \/\/ If all axes are pinned then all feature variations will be dropped so there's no need\n-  \/\/ to collect lookups from them.\n-  if (!plan->all_axes_pinned)\n-    table.feature_variation_collect_lookups (feature_indices,\n-                                             plan->user_axes_location.is_empty () ? nullptr: feature_record_cond_idx_map,\n-                                             lookup_indices);\n-#endif\n-}\n-\n-\n-static inline void\n-_GSUBGPOS_find_duplicate_features (const OT::GSUBGPOS &g,\n-                                   const hb_map_t *lookup_indices,\n-                                   const hb_set_t *feature_indices,\n-                                   const hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map,\n-                                   hb_map_t *duplicate_feature_map \/* OUT *\/)\n-{\n-  if (feature_indices->is_empty ()) return;\n-  hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_set_t>> unique_features;\n-  \/\/find out duplicate features after subset\n-  for (unsigned i : feature_indices->iter ())\n-  {\n-    hb_tag_t t = g.get_feature_tag (i);\n-    if (t == HB_MAP_VALUE_INVALID) continue;\n-    if (!unique_features.has (t))\n-    {\n-      if (unlikely (!unique_features.set (t, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n-        return;\n-      if (unique_features.has (t))\n-        unique_features.get (t)->add (i);\n-      duplicate_feature_map->set (i, i);\n-      continue;\n-    }\n-\n-    bool found = false;\n-\n-    hb_set_t* same_tag_features = unique_features.get (t);\n-    for (unsigned other_f_index : same_tag_features->iter ())\n-    {\n-      const OT::Feature* f = &(g.get_feature (i));\n-      const OT::Feature **p = nullptr;\n-      if (feature_substitutes_map->has (i, &p))\n-        f = *p;\n-\n-      const OT::Feature* other_f = &(g.get_feature (other_f_index));\n-      if (feature_substitutes_map->has (other_f_index, &p))\n-        other_f = *p;\n-\n-      auto f_iter =\n-      + hb_iter (f->lookupIndex)\n-      | hb_filter (lookup_indices)\n-      ;\n-\n-      auto other_f_iter =\n-      + hb_iter (other_f->lookupIndex)\n-      | hb_filter (lookup_indices)\n-      ;\n-\n-      bool is_equal = true;\n-      for (; f_iter && other_f_iter; f_iter++, other_f_iter++)\n-      {\n-        unsigned a = *f_iter;\n-        unsigned b = *other_f_iter;\n-        if (a != b) { is_equal = false; break; }\n-      }\n-\n-      if (is_equal == false || f_iter || other_f_iter) continue;\n-\n-      found = true;\n-      duplicate_feature_map->set (i, other_f_index);\n-      break;\n-    }\n-\n-    if (found == false)\n-    {\n-      same_tag_features->add (i);\n-      duplicate_feature_map->set (i, i);\n-    }\n-  }\n-}\n-\n-template <typename T>\n-static inline void\n-_closure_glyphs_lookups_features (hb_subset_plan_t   *plan,\n-                                  hb_set_t           *gids_to_retain,\n-                                  hb_map_t           *lookups,\n-                                  hb_map_t           *features,\n-                                  script_langsys_map *langsys_map,\n-                                  hb_hashmap_t<unsigned, hb::shared_ptr<hb_set_t>> *feature_record_cond_idx_map,\n-                                  hb_hashmap_t<unsigned, const OT::Feature*> *feature_substitutes_map,\n-                                  hb_set_t &catch_all_record_feature_idxes,\n-                                  hb_hashmap_t<unsigned, hb_pair_t<const void*, const void*>>& catch_all_record_idx_feature_map)\n-{\n-  hb_blob_ptr_t<T> table = plan->source_table<T> ();\n-  hb_tag_t table_tag = table->tableTag;\n-  hb_set_t lookup_indices, feature_indices;\n-  _collect_layout_indices<T> (plan,\n-                              *table,\n-                              &lookup_indices,\n-                              &feature_indices,\n-                              feature_record_cond_idx_map,\n-                              feature_substitutes_map,\n-                              catch_all_record_feature_idxes,\n-                              catch_all_record_idx_feature_map);\n-\n-  if (table_tag == HB_OT_TAG_GSUB && !(plan->flags & HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE))\n-    hb_ot_layout_lookups_substitute_closure (plan->source,\n-                                             &lookup_indices,\n-                                             gids_to_retain);\n-  table->closure_lookups (plan->source,\n-                          gids_to_retain,\n-                          &lookup_indices);\n-  _remap_indexes (&lookup_indices, lookups);\n-\n-  \/\/ prune features\n-  table->prune_features (lookups,\n-                         plan->user_axes_location.is_empty () ? nullptr : feature_record_cond_idx_map,\n-                         feature_substitutes_map,\n-                         &feature_indices);\n-  hb_map_t duplicate_feature_map;\n-  _GSUBGPOS_find_duplicate_features (*table, lookups, &feature_indices, feature_substitutes_map, &duplicate_feature_map);\n-\n-  feature_indices.clear ();\n-  table->prune_langsys (&duplicate_feature_map, &plan->layout_scripts, langsys_map, &feature_indices);\n-  _remap_indexes (&feature_indices, features);\n-\n-  table.destroy ();\n-}\n-\n-#endif\n-\n-#ifndef HB_NO_VAR\n-static inline void\n-_generate_varstore_inner_maps (const hb_set_t& varidx_set,\n-                               unsigned subtable_count,\n-                               hb_vector_t<hb_inc_bimap_t> &inner_maps \/* OUT *\/)\n-{\n-  if (varidx_set.is_empty () || subtable_count == 0) return;\n-\n-  if (unlikely (!inner_maps.resize (subtable_count))) return;\n-  for (unsigned idx : varidx_set)\n-  {\n-    uint16_t major = idx >> 16;\n-    uint16_t minor = idx & 0xFFFF;\n-\n-    if (major >= subtable_count)\n-      continue;\n-    inner_maps[major].add (minor);\n-  }\n-}\n-\n-static inline hb_font_t*\n-_get_hb_font_with_variations (const hb_subset_plan_t *plan)\n-{\n-  hb_font_t *font = hb_font_create (plan->source);\n-\n-  hb_vector_t<hb_variation_t> vars;\n-  if (!vars.alloc (plan->user_axes_location.get_population ())) {\n-    hb_font_destroy (font);\n-    return nullptr;\n-  }\n-\n-  for (auto _ : plan->user_axes_location)\n-  {\n-    hb_variation_t var;\n-    var.tag = _.first;\n-    var.value = _.second.middle;\n-    vars.push (var);\n-  }\n-\n-#ifndef HB_NO_VAR\n-  hb_font_set_variations (font, vars.arrayZ, plan->user_axes_location.get_population ());\n-#endif\n-  return font;\n-}\n-\n-static inline void\n-_remap_variation_indices (const OT::ItemVariationStore &var_store,\n-                          const hb_set_t &variation_indices,\n-                          const hb_vector_t<int>& normalized_coords,\n-                          bool calculate_delta, \/* not pinned at default *\/\n-                          bool no_variations, \/* all axes pinned *\/\n-                          hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> &variation_idx_delta_map \/* OUT *\/)\n-{\n-  if (&var_store == &Null (OT::ItemVariationStore)) return;\n-  unsigned subtable_count = var_store.get_sub_table_count ();\n-  float *store_cache = var_store.create_cache ();\n-\n-  unsigned new_major = 0, new_minor = 0;\n-  unsigned last_major = (variation_indices.get_min ()) >> 16;\n-  for (unsigned idx : variation_indices)\n-  {\n-    int delta = 0;\n-    if (calculate_delta)\n-      delta = roundf (var_store.get_delta (idx, normalized_coords.arrayZ,\n-                                           normalized_coords.length, store_cache));\n-\n-    if (no_variations)\n-    {\n-      variation_idx_delta_map.set (idx, hb_pair_t<unsigned, int> (HB_OT_LAYOUT_NO_VARIATIONS_INDEX, delta));\n-      continue;\n-    }\n-\n-    uint16_t major = idx >> 16;\n-    if (major >= subtable_count) break;\n-    if (major != last_major)\n-    {\n-      new_minor = 0;\n-      ++new_major;\n-    }\n-\n-    unsigned new_idx = (new_major << 16) + new_minor;\n-    variation_idx_delta_map.set (idx, hb_pair_t<unsigned, int> (new_idx, delta));\n-    ++new_minor;\n-    last_major = major;\n-  }\n-  var_store.destroy_cache (store_cache);\n-}\n-\n-static inline void\n-_collect_layout_variation_indices (hb_subset_plan_t* plan)\n-{\n-  hb_blob_ptr_t<OT::GDEF> gdef = plan->source_table<OT::GDEF> ();\n-  hb_blob_ptr_t<GPOS> gpos = plan->source_table<GPOS> ();\n-\n-  if (!gdef->has_data () || !gdef->has_var_store ())\n-  {\n-    gdef.destroy ();\n-    gpos.destroy ();\n-    return;\n-  }\n-\n-  hb_set_t varidx_set;\n-  OT::hb_collect_variation_indices_context_t c (&varidx_set,\n-                                                &plan->_glyphset_gsub,\n-                                                &plan->gpos_lookups);\n-  gdef->collect_variation_indices (&c);\n-\n-  if (hb_ot_layout_has_positioning (plan->source))\n-    gpos->collect_variation_indices (&c);\n-\n-  _remap_variation_indices (gdef->get_var_store (),\n-                            varidx_set, plan->normalized_coords,\n-                            !plan->pinned_at_default,\n-                            plan->all_axes_pinned,\n-                            plan->layout_variation_idx_delta_map);\n-\n-  unsigned subtable_count = gdef->get_var_store ().get_sub_table_count ();\n-  _generate_varstore_inner_maps (varidx_set, subtable_count, plan->gdef_varstore_inner_maps);\n-\n-  gdef.destroy ();\n-  gpos.destroy ();\n-}\n-\n-#ifndef HB_NO_BASE\n-static inline void\n-_collect_base_variation_indices (hb_subset_plan_t* plan)\n-{\n-  hb_blob_ptr_t<OT::BASE> base = plan->source_table<OT::BASE> ();\n-  if (!base->has_var_store ())\n-  {\n-    base.destroy ();\n-    return;\n-  }\n-\n-  hb_set_t varidx_set;\n-  base->collect_variation_indices (plan, varidx_set);\n-  const OT::ItemVariationStore &var_store = base->get_var_store ();\n-  unsigned subtable_count = var_store.get_sub_table_count ();\n-\n-\n-  _remap_variation_indices (var_store, varidx_set,\n-                            plan->normalized_coords,\n-                            !plan->pinned_at_default,\n-                            plan->all_axes_pinned,\n-                            plan->base_variation_idx_map);\n-  _generate_varstore_inner_maps (varidx_set, subtable_count, plan->base_varstore_inner_maps);\n-\n-  base.destroy ();\n@@ -506,3 +102,0 @@\n-#endif\n-#endif\n-\n@@ -518,35 +111,0 @@\n-#ifndef HB_NO_VAR\n-static void\n-_remap_colrv1_delta_set_index_indices (const OT::DeltaSetIndexMap &index_map,\n-                                       const hb_set_t &delta_set_idxes,\n-                                       hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> &variation_idx_delta_map, \/* IN\/OUT *\/\n-                                       hb_map_t &new_deltaset_idx_varidx_map \/* OUT *\/)\n-{\n-  if (!index_map.get_map_count ())\n-    return;\n-\n-  hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> delta_set_idx_delta_map;\n-  unsigned new_delta_set_idx = 0;\n-  for (unsigned delta_set_idx : delta_set_idxes)\n-  {\n-    unsigned var_idx = index_map.map (delta_set_idx);\n-    unsigned new_varidx = HB_OT_LAYOUT_NO_VARIATIONS_INDEX;\n-    int delta = 0;\n-\n-    if (var_idx != HB_OT_LAYOUT_NO_VARIATIONS_INDEX)\n-    {\n-      hb_pair_t<unsigned, int> *new_varidx_delta;\n-      if (!variation_idx_delta_map.has (var_idx, &new_varidx_delta)) continue;\n-\n-      new_varidx = hb_first (*new_varidx_delta);\n-      delta = hb_second (*new_varidx_delta);\n-    }\n-\n-    new_deltaset_idx_varidx_map.set (new_delta_set_idx, new_varidx);\n-    delta_set_idx_delta_map.set (delta_set_idx, hb_pair_t<unsigned, int> (new_delta_set_idx, delta));\n-    new_delta_set_idx++;\n-  }\n-  variation_idx_delta_map = std::move (delta_set_idx_delta_map);\n-}\n-#endif\n-\n@@ -572,1 +130,1 @@\n-  _remap_indexes (&layer_indices, &plan->colrv1_layers);\n+  remap_indexes (&layer_indices, &plan->colrv1_layers);\n@@ -581,1 +139,1 @@\n-  _generate_varstore_inner_maps (variation_indices, subtable_count, plan->colrv1_varstore_inner_maps);\n+  generate_varstore_inner_maps (variation_indices, subtable_count, plan->colrv1_varstore_inner_maps);\n@@ -593,1 +151,1 @@\n-    _remap_variation_indices (var_store,\n+    remap_variation_indices (var_store,\n@@ -601,1 +159,1 @@\n-      _remap_colrv1_delta_set_index_indices (colr.get_delta_set_index_map (),\n+      remap_colrv1_delta_set_index_indices (colr.get_delta_set_index_map (),\n@@ -619,19 +177,0 @@\n-static inline void\n-_remap_used_mark_sets (hb_subset_plan_t *plan,\n-                       hb_map_t& used_mark_sets_map)\n-{\n-  hb_blob_ptr_t<OT::GDEF> gdef = plan->source_table<OT::GDEF> ();\n-\n-  if (!gdef->has_data () || !gdef->has_mark_glyph_sets ())\n-  {\n-    gdef.destroy ();\n-    return;\n-  }\n-\n-  hb_set_t used_mark_sets;\n-  gdef->get_mark_glyph_sets ().collect_used_mark_sets (plan->_glyphset_gsub, used_mark_sets);\n-  gdef.destroy ();\n-\n-  _remap_indexes (&used_mark_sets, &used_mark_sets_map);\n-}\n-\n@@ -675,0 +214,28 @@\n+\/*\n+ * Finds additional unicode codepoints which are reachable from the input unicode set.\n+ * Currently this adds in mirrored variants (needed for bidi) of any input unicodes.\n+ *\/\n+static hb_set_t\n+_unicode_closure (const hb_set_t* unicodes, bool bidi_closure) {\n+  \/\/ TODO: we may want to also consider pulling in reachable unicode composition and decompositions.\n+  \/\/       see: https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2283\n+  hb_set_t out = *unicodes;\n+  if (!bidi_closure) return out;\n+\n+  if (out.is_inverted()) {\n+    \/\/ don't closure inverted sets, they are asking to specifically exclude certain codepoints.\n+    \/\/ otherwise everything is already included.\n+    return out;\n+  }\n+\n+  auto unicode_funcs = hb_unicode_funcs_get_default ();\n+  for (hb_codepoint_t cp : *unicodes) {\n+   hb_codepoint_t mirror = hb_unicode_mirroring(unicode_funcs, cp);\n+   if (unlikely (mirror != cp)) {\n+     out.add(mirror);\n+   }\n+  }\n+\n+  return out;\n+}\n+\n@@ -676,1 +243,1 @@\n-_populate_unicodes_to_retain (const hb_set_t *unicodes,\n+_populate_unicodes_to_retain (const hb_set_t *unicodes_in,\n@@ -680,0 +247,3 @@\n+  hb_set_t unicodes = _unicode_closure(unicodes_in,\n+    !(plan->flags & HB_SUBSET_FLAGS_NO_BIDI_CLOSURE));\n+\n@@ -683,1 +253,1 @@\n-  if (glyphs->is_empty () && unicodes->get_population () < size_threshold)\n+  if (glyphs->is_empty () && unicodes.get_population () < size_threshold)\n@@ -693,1 +263,1 @@\n-    plan->unicode_to_new_gid_list.alloc (unicodes->get_population ());\n+    plan->unicode_to_new_gid_list.alloc (unicodes.get_population ());\n@@ -695,1 +265,1 @@\n-      _fill_unicode_and_glyph_map(plan, unicodes->iter(), [&] (hb_codepoint_t cp) {\n+      _fill_unicode_and_glyph_map(plan, unicodes.iter(), [&] (hb_codepoint_t cp) {\n@@ -707,1 +277,1 @@\n-      _fill_unicode_and_glyph_map(plan, unicodes->iter(), [&] (hb_codepoint_t cp) {\n+      _fill_unicode_and_glyph_map(plan, unicodes.iter(), [&] (hb_codepoint_t cp) {\n@@ -724,1 +294,1 @@\n-      plan->unicode_to_new_gid_list.alloc (hb_min(unicodes->get_population ()\n+      plan->unicode_to_new_gid_list.alloc (hb_min(unicodes.get_population ()\n@@ -733,1 +303,1 @@\n-        unicodes->get_population () < cmap_unicodes->get_population () &&\n+        unicodes.get_population () < cmap_unicodes->get_population () &&\n@@ -736,1 +306,1 @@\n-      plan->codepoint_to_glyph->alloc (unicodes->get_population () + glyphs->get_population ());\n+      plan->codepoint_to_glyph->alloc (unicodes.get_population () + glyphs->get_population ());\n@@ -751,1 +321,1 @@\n-      _fill_unicode_and_glyph_map(plan, unicodes->iter(), [&] (hb_codepoint_t cp) {\n+      _fill_unicode_and_glyph_map(plan, unicodes.iter(), [&] (hb_codepoint_t cp) {\n@@ -772,1 +342,1 @@\n-          if (!unicodes->has (cp) && !glyphs->has (gid))\n+          if (!unicodes.has (cp) && !glyphs->has (gid))\n@@ -863,12 +433,1 @@\n-  if (!drop_tables->has (HB_OT_TAG_GPOS))\n-  {\n-    hb_blob_ptr_t<GPOS> gpos = plan->source_table<GPOS> ();\n-    gpos->collect_name_ids (&plan->gpos_features, &plan->name_ids);\n-    gpos.destroy ();\n-  }\n-  if (!drop_tables->has (HB_OT_TAG_GSUB))\n-  {\n-    hb_blob_ptr_t<GSUB> gsub = plan->source_table<GSUB> ();\n-    gsub->collect_name_ids (&plan->gsub_features, &plan->name_ids);\n-    gsub.destroy ();\n-  }\n+  layout_nameid_closure(plan, drop_tables);\n@@ -896,24 +455,1 @@\n-  if (!drop_tables->has (HB_OT_TAG_GSUB))\n-    \/\/ closure all glyphs\/lookups\/features needed for GSUB substitutions.\n-    _closure_glyphs_lookups_features<GSUB> (\n-        plan,\n-        &plan->_glyphset_gsub,\n-        &plan->gsub_lookups,\n-        &plan->gsub_features,\n-        &plan->gsub_langsys,\n-        &plan->gsub_feature_record_cond_idx_map,\n-        &plan->gsub_feature_substitutes_map,\n-        plan->gsub_old_features,\n-        plan->gsub_old_feature_idx_tag_map);\n-\n-  if (!drop_tables->has (HB_OT_TAG_GPOS))\n-    _closure_glyphs_lookups_features<GPOS> (\n-        plan,\n-        &plan->_glyphset_gsub,\n-        &plan->gpos_lookups,\n-        &plan->gpos_features,\n-        &plan->gpos_langsys,\n-        &plan->gpos_feature_record_cond_idx_map,\n-        &plan->gpos_feature_substitutes_map,\n-        plan->gpos_old_features,\n-        plan->gpos_old_feature_idx_tag_map);\n+  layout_populate_gids_to_retain(plan, drop_tables);\n@@ -921,0 +457,1 @@\n+\n@@ -965,0 +502,1 @@\n+#ifndef HB_NO_SUBSET_LAYOUT\n@@ -966,1 +504,2 @@\n-    _collect_layout_variation_indices (plan);\n+    collect_layout_variation_indices (plan);\n+#endif\n@@ -1080,187 +619,0 @@\n-#ifndef HB_NO_VAR\n-static void\n-_normalize_axes_location (hb_face_t *face, hb_subset_plan_t *plan)\n-{\n-  if (plan->user_axes_location.is_empty ())\n-    return;\n-\n-  hb_array_t<const OT::AxisRecord> axes = face->table.fvar->get_axes ();\n-  plan->normalized_coords.resize (axes.length);\n-\n-  bool has_avar = face->table.avar->has_data ();\n-  const OT::SegmentMaps *seg_maps = nullptr;\n-  unsigned avar_axis_count = 0;\n-  if (has_avar)\n-  {\n-    seg_maps = face->table.avar->get_segment_maps ();\n-    avar_axis_count = face->table.avar->get_axis_count();\n-  }\n-\n-  bool axis_not_pinned = false;\n-  unsigned old_axis_idx = 0, new_axis_idx = 0;\n-  for (const auto& axis : axes)\n-  {\n-    hb_tag_t axis_tag = axis.get_axis_tag ();\n-    plan->axes_old_index_tag_map.set (old_axis_idx, axis_tag);\n-\n-    if (!plan->user_axes_location.has (axis_tag) ||\n-        !plan->user_axes_location.get (axis_tag).is_point ())\n-    {\n-      axis_not_pinned = true;\n-      plan->axes_index_map.set (old_axis_idx, new_axis_idx);\n-      plan->axis_tags.push (axis_tag);\n-      new_axis_idx++;\n-    }\n-\n-    Triple *axis_range;\n-    if (plan->user_axes_location.has (axis_tag, &axis_range))\n-    {\n-      plan->axes_triple_distances.set (axis_tag, axis.get_triple_distances ());\n-\n-      int normalized_min = axis.normalize_axis_value (axis_range->minimum);\n-      int normalized_default = axis.normalize_axis_value (axis_range->middle);\n-      int normalized_max = axis.normalize_axis_value (axis_range->maximum);\n-\n-      if (has_avar && old_axis_idx < avar_axis_count)\n-      {\n-        normalized_min = seg_maps->map (normalized_min);\n-        normalized_default = seg_maps->map (normalized_default);\n-        normalized_max = seg_maps->map (normalized_max);\n-      }\n-      plan->axes_location.set (axis_tag, Triple (static_cast<double> (normalized_min \/ 16384.0),\n-                                                 static_cast<double> (normalized_default \/ 16384.0),\n-                                                 static_cast<double> (normalized_max \/ 16384.0)));\n-\n-      if (normalized_default != 0)\n-        plan->pinned_at_default = false;\n-\n-      plan->normalized_coords[old_axis_idx] = normalized_default;\n-    }\n-\n-    old_axis_idx++;\n-\n-    if (has_avar && old_axis_idx < avar_axis_count)\n-      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n-  }\n-  plan->all_axes_pinned = !axis_not_pinned;\n-}\n-\n-static void\n-_update_instance_metrics_map_from_cff2 (hb_subset_plan_t *plan)\n-{\n-  if (!plan->normalized_coords) return;\n-  OT::cff2::accelerator_t cff2 (plan->source);\n-  if (!cff2.is_valid ()) return;\n-\n-  hb_font_t *font = _get_hb_font_with_variations (plan);\n-  if (unlikely (!plan->check_success (font != nullptr)))\n-  {\n-    hb_font_destroy (font);\n-    return;\n-  }\n-\n-  hb_glyph_extents_t extents = {0x7FFF, -0x7FFF};\n-  OT::hmtx_accelerator_t _hmtx (plan->source);\n-  float *hvar_store_cache = nullptr;\n-  if (_hmtx.has_data () && _hmtx.var_table.get_length ())\n-    hvar_store_cache = _hmtx.var_table->get_var_store ().create_cache ();\n-\n-  OT::vmtx_accelerator_t _vmtx (plan->source);\n-  float *vvar_store_cache = nullptr;\n-  if (_vmtx.has_data () && _vmtx.var_table.get_length ())\n-    vvar_store_cache = _vmtx.var_table->get_var_store ().create_cache ();\n-\n-  for (auto p : *plan->glyph_map)\n-  {\n-    hb_codepoint_t old_gid = p.first;\n-    hb_codepoint_t new_gid = p.second;\n-    if (!cff2.get_extents (font, old_gid, &extents)) continue;\n-    bool has_bounds_info = true;\n-    if (extents.x_bearing == 0 && extents.width == 0 &&\n-        extents.height == 0 && extents.y_bearing == 0)\n-      has_bounds_info = false;\n-\n-    if (has_bounds_info)\n-    {\n-      plan->head_maxp_info.xMin = hb_min (plan->head_maxp_info.xMin, extents.x_bearing);\n-      plan->head_maxp_info.xMax = hb_max (plan->head_maxp_info.xMax, extents.x_bearing + extents.width);\n-      plan->head_maxp_info.yMax = hb_max (plan->head_maxp_info.yMax, extents.y_bearing);\n-      plan->head_maxp_info.yMin = hb_min (plan->head_maxp_info.yMin, extents.y_bearing + extents.height);\n-    }\n-\n-    if (_hmtx.has_data ())\n-    {\n-      int hori_aw = _hmtx.get_advance_without_var_unscaled (old_gid);\n-      if (_hmtx.var_table.get_length ())\n-        hori_aw += (int) roundf (_hmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n-                                                                              hvar_store_cache));\n-      int lsb = extents.x_bearing;\n-      if (!has_bounds_info)\n-      {\n-        if (!_hmtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb))\n-          continue;\n-      }\n-      plan->hmtx_map.set (new_gid, hb_pair ((unsigned) hori_aw, lsb));\n-      plan->bounds_width_vec[new_gid] = extents.width;\n-    }\n-\n-    if (_vmtx.has_data ())\n-    {\n-      int vert_aw = _vmtx.get_advance_without_var_unscaled (old_gid);\n-      if (_vmtx.var_table.get_length ())\n-        vert_aw += (int) roundf (_vmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n-                                                                              vvar_store_cache));\n-\n-      int tsb = extents.y_bearing;\n-      if (!has_bounds_info)\n-      {\n-        if (!_vmtx.get_leading_bearing_without_var_unscaled (old_gid, &tsb))\n-          continue;\n-      }\n-      plan->vmtx_map.set (new_gid, hb_pair ((unsigned) vert_aw, tsb));\n-      plan->bounds_height_vec[new_gid] = extents.height;\n-    }\n-  }\n-  hb_font_destroy (font);\n-  if (hvar_store_cache)\n-    _hmtx.var_table->get_var_store ().destroy_cache (hvar_store_cache);\n-  if (vvar_store_cache)\n-    _vmtx.var_table->get_var_store ().destroy_cache (vvar_store_cache);\n-}\n-\n-static bool\n-_get_instance_glyphs_contour_points (hb_subset_plan_t *plan)\n-{\n-  \/* contour_points vector only needed for updating gvar table (infer delta and\n-   * iup delta optimization) during partial instancing *\/\n-  if (plan->user_axes_location.is_empty () || plan->all_axes_pinned)\n-    return true;\n-\n-  OT::glyf_accelerator_t glyf (plan->source);\n-\n-  for (auto &_ : plan->new_to_old_gid_list)\n-  {\n-    hb_codepoint_t new_gid = _.first;\n-    contour_point_vector_t all_points;\n-    if (new_gid == 0 && !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE))\n-    {\n-      if (unlikely (!plan->new_gid_contour_points_map.set (new_gid, all_points)))\n-        return false;\n-      continue;\n-    }\n-\n-    hb_codepoint_t old_gid = _.second;\n-    auto glyph = glyf.glyph_for_gid (old_gid);\n-    if (unlikely (!glyph.get_all_points_without_var (plan->source, all_points)))\n-      return false;\n-    if (unlikely (!plan->new_gid_contour_points_map.set (new_gid, all_points)))\n-      return false;\n-\n-    \/* composite new gids are only needed by iup delta optimization *\/\n-    if ((plan->flags & HB_SUBSET_FLAGS_OPTIMIZE_IUP_DELTAS) && glyph.is_composite ())\n-      plan->composite_new_gids.add (new_gid);\n-  }\n-  return true;\n-}\n-#endif\n-\n@@ -1327,1 +679,1 @@\n-  _normalize_axes_location (face, this);\n+  normalize_axes_location (face, this);\n@@ -1368,0 +720,1 @@\n+#ifndef HB_NO_SUBSET_LAYOUT\n@@ -1369,1 +722,2 @@\n-    _remap_used_mark_sets (this, used_mark_sets_map);\n+    remap_used_mark_sets (this, used_mark_sets_map);\n+#endif\n@@ -1374,1 +728,1 @@\n-    _collect_base_variation_indices (this);\n+    collect_base_variation_indices (this);\n@@ -1382,2 +736,2 @@\n-  _update_instance_metrics_map_from_cff2 (this);\n-  if (!check_success (_get_instance_glyphs_contour_points (this)))\n+  update_instance_metrics_map_from_cff2 (this);\n+  if (!check_success (get_instance_glyphs_contour_points (this)))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.cc","additions":63,"deletions":709,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -299,0 +299,70 @@\n+\/\/ hb-subset-plan implementation is split into multiple files to keep\n+\/\/ compile times more reasonable:\n+\/\/ - hb-subset-plan.cc\n+\/\/ - hb-subset-plan-layout.cc\n+\/\/\n+\/\/ The functions below are those needed to connect the split files\n+\/\/ above together.\n+HB_INTERNAL void\n+remap_indexes (const hb_set_t *indexes,\n+               hb_map_t       *mapping \/* OUT *\/);\n+\n+\n+#ifndef HB_NO_VAR\n+template<typename ItemVarStore>\n+HB_INTERNAL void\n+remap_variation_indices (const ItemVarStore &var_store,\n+                         const hb_set_t &variation_indices,\n+                         const hb_vector_t<int>& normalized_coords,\n+                         bool calculate_delta, \/* not pinned at default *\/\n+                         bool no_variations, \/* all axes pinned *\/\n+                         hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> &variation_idx_delta_map \/* OUT *\/);\n+\n+\n+template<typename DeltaSetIndexMap>\n+HB_INTERNAL void\n+remap_colrv1_delta_set_index_indices (const DeltaSetIndexMap &index_map,\n+                                      const hb_set_t &delta_set_idxes,\n+                                      hb_hashmap_t<unsigned, hb_pair_t<unsigned, int>> &variation_idx_delta_map, \/* IN\/OUT *\/\n+                                      hb_map_t &new_deltaset_idx_varidx_map \/* OUT *\/);\n+\n+\n+HB_INTERNAL void\n+generate_varstore_inner_maps (const hb_set_t& varidx_set,\n+                              unsigned subtable_count,\n+                              hb_vector_t<hb_inc_bimap_t> &inner_maps \/* OUT *\/);\n+\n+HB_INTERNAL void\n+normalize_axes_location (hb_face_t *face, hb_subset_plan_t *plan);\n+\n+HB_INTERNAL void\n+update_instance_metrics_map_from_cff2 (hb_subset_plan_t *plan);\n+\n+HB_INTERNAL bool\n+get_instance_glyphs_contour_points (hb_subset_plan_t *plan);\n+\n+#ifndef HB_NO_BASE\n+HB_INTERNAL void\n+collect_base_variation_indices (hb_subset_plan_t* plan);\n+#endif\n+#endif\n+\n+#ifndef HB_NO_SUBSET_LAYOUT\n+typedef hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> script_langsys_map;\n+\n+HB_INTERNAL void\n+remap_used_mark_sets (hb_subset_plan_t *plan,\n+                      hb_map_t& used_mark_sets_map);\n+\n+HB_INTERNAL void\n+layout_nameid_closure (hb_subset_plan_t* plan,\n+                       hb_set_t* drop_tables);\n+\n+HB_INTERNAL void\n+layout_populate_gids_to_retain (hb_subset_plan_t* plan,\n+                                hb_set_t* drop_tables);\n+\n+HB_INTERNAL void\n+collect_layout_variation_indices (hb_subset_plan_t* plan);\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.hh","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -711,0 +711,104 @@\n+\n+\n+#ifdef HB_EXPERIMENTAL_API\n+\n+#include \"hb-ot-cff1-table.hh\"\n+\n+template<typename accel_t>\n+static hb_blob_t* get_charstrings_data(accel_t& accel, hb_codepoint_t glyph_index) {\n+  if (!accel.is_valid()) {\n+    return hb_blob_get_empty ();\n+  }\n+\n+  hb_ubytes_t bytes = (*accel.charStrings)[glyph_index];\n+  if (!bytes) {\n+    return hb_blob_get_empty ();\n+  }\n+\n+  hb_blob_t* cff_blob = accel.get_blob();\n+  uint32_t length;\n+  const char* cff_data = hb_blob_get_data(cff_blob, &length) ;\n+\n+  long int offset = (const char*) bytes.arrayZ - cff_data;\n+  if (offset < 0 || offset > INT32_MAX) {\n+    return hb_blob_get_empty ();\n+  }\n+\n+  return hb_blob_create_sub_blob(cff_blob, (uint32_t) offset, bytes.length);\n+}\n+\n+template<typename accel_t>\n+static hb_blob_t* get_charstrings_index(accel_t& accel) {\n+  if (!accel.is_valid()) {\n+    return hb_blob_get_empty ();\n+  }\n+\n+  const char* charstrings_start = (const char*) accel.charStrings;\n+  unsigned charstrings_length = accel.charStrings->get_size();\n+\n+  hb_blob_t* cff_blob = accel.get_blob();\n+  uint32_t length;\n+  const char* cff_data = hb_blob_get_data(cff_blob, &length) ;\n+\n+  long int offset = charstrings_start - cff_data;\n+  if (offset < 0 || offset > INT32_MAX) {\n+    return hb_blob_get_empty ();\n+  }\n+\n+  return hb_blob_create_sub_blob(cff_blob, (uint32_t) offset, charstrings_length);\n+}\n+\n+\/**\n+ * hb_subset_cff_get_charstring_data:\n+ * @face: A face object\n+ * @glyph_index: Glyph index to get data for.\n+ *\n+ * Returns the raw outline data from the CFF\/CFF2 table associated with the given glyph index.\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff_get_charstring_data(hb_face_t* face, hb_codepoint_t glyph_index) {\n+  return get_charstrings_data(*face->table.cff1, glyph_index);\n+}\n+\n+\/**\n+ * hb_subset_cff_get_charstrings_index:\n+ * @face: A face object\n+ *\n+ * Returns the raw CFF CharStrings INDEX from the CFF table.\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff_get_charstrings_index (hb_face_t* face) {\n+  return get_charstrings_index (*face->table.cff1);\n+}\n+\n+\/**\n+ * hb_subset_cff2_get_charstring_data:\n+ * @face: A face object\n+ * @glyph_index: Glyph index to get data for.\n+ *\n+ * Returns the raw outline data from the CFF\/CFF2 table associated with the given glyph index.\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff2_get_charstring_data(hb_face_t* face, hb_codepoint_t glyph_index) {\n+  return get_charstrings_data(*face->table.cff2, glyph_index);\n+}\n+\n+\/**\n+ * hb_subset_cff2_get_charstrings_index:\n+ * @face: A face object\n+ *\n+ * Returns the raw CFF2 CharStrings INDEX from the CFF2 table.\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff2_get_charstrings_index (hb_face_t* face) {\n+  return get_charstrings_index (*face->table.cff2);\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * @HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE: If set don't perform glyph closure on layout\n+ * @HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE: If set do not perform glyph closure on layout\n@@ -78,0 +78,2 @@\n+ * @HB_SUBSET_FLAGS_NO_BIDI_CLOSURE: If set do not pull mirrored versions of input\n+ * codepoints into the subset. Since: 11.1.0\n@@ -99,0 +101,1 @@\n+  HB_SUBSET_FLAGS_NO_BIDI_CLOSURE         =  0x00000800u,\n@@ -100,1 +103,1 @@\n-  HB_SUBSET_FLAGS_IFTB_REQUIREMENTS       =  0x00000800u,\n+  HB_SUBSET_FLAGS_IFTB_REQUIREMENTS       =  0x00001000u,\n@@ -227,0 +230,17 @@\n+\n+\n+\/*\n+* Raw outline data access\n+*\/\n+\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff_get_charstring_data (hb_face_t* face, hb_codepoint_t glyph_index);\n+\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff_get_charstrings_index (hb_face_t* face);\n+\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff2_get_charstring_data (hb_face_t* face, hb_codepoint_t glyph_index);\n+\n+HB_EXTERN hb_blob_t*\n+hb_subset_cff2_get_charstrings_index (hb_face_t* face);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.h","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -93,1 +93,7 @@\n-      alloc (hb_len (iter), true);\n+    {\n+      if (unlikely (!alloc (hb_len (iter), true)))\n+        return;\n+      unsigned count = hb_len (iter);\n+      for (unsigned i = 0; i < count; i++)\n+        push_has_room (*iter++);\n+    }\n@@ -439,1 +445,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-vector.hh","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#define HB_VERSION_MAJOR 10\n+#define HB_VERSION_MAJOR 11\n@@ -50,1 +50,1 @@\n-#define HB_VERSION_MINOR 4\n+#define HB_VERSION_MINOR 2\n@@ -63,1 +63,1 @@\n-#define HB_VERSION_STRING \"10.4.0\"\n+#define HB_VERSION_STRING \"11.2.0\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-version.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#pragma GCC diagnostic error   \"-Wuninitialized\"\n@@ -233,27 +234,0 @@\n-\/* Compile-time custom allocator support. *\/\n-\n-#if !defined(HB_CUSTOM_MALLOC) \\\n-  && defined(hb_malloc_impl) \\\n-  && defined(hb_calloc_impl) \\\n-  && defined(hb_realloc_impl) \\\n-  && defined(hb_free_impl)\n-#define HB_CUSTOM_MALLOC\n-#endif\n-\n-#ifdef HB_CUSTOM_MALLOC\n-extern \"C\" void* hb_malloc_impl(size_t size);\n-extern \"C\" void* hb_calloc_impl(size_t nmemb, size_t size);\n-extern \"C\" void* hb_realloc_impl(void *ptr, size_t size);\n-extern \"C\" void  hb_free_impl(void *ptr);\n-#define hb_malloc hb_malloc_impl\n-#define hb_calloc hb_calloc_impl\n-#define hb_realloc hb_realloc_impl\n-#define hb_free hb_free_impl\n-#else\n-#define hb_malloc malloc\n-#define hb_calloc calloc\n-#define hb_realloc realloc\n-#define hb_free free\n-#endif\n-\n-\n@@ -285,1 +259,1 @@\n-#if defined(__MINGW32__) && (__GNUC__ >= 3)\n+#if defined(__MINGW32__) && (__GNUC__ >= 3) && !defined(__clang__)\n@@ -494,1 +468,1 @@\n-#    define hb_atexit(f) static hb_atexit_t<f> _hb_atexit_##__LINE__;\n+#    define hb_atexit(f) static hb_atexit_t<f> _hb_atexit_##__LINE__\n@@ -542,0 +516,23 @@\n+\/* Compile-time custom allocator support. *\/\n+\n+#if !defined(HB_CUSTOM_MALLOC) \\\n+  && defined(hb_malloc_impl) \\\n+  && defined(hb_calloc_impl) \\\n+  && defined(hb_realloc_impl) \\\n+  && defined(hb_free_impl)\n+#define HB_CUSTOM_MALLOC\n+#endif\n+\n+#ifdef HB_CUSTOM_MALLOC\n+extern \"C\" void* hb_malloc_impl(size_t size);\n+extern \"C\" void* hb_calloc_impl(size_t nmemb, size_t size);\n+extern \"C\" void* hb_realloc_impl(void *ptr, size_t size);\n+extern \"C\" void  hb_free_impl(void *ptr);\n+#else\n+#define hb_malloc_impl malloc\n+#define hb_calloc_impl calloc\n+#define hb_realloc_impl realloc\n+#define hb_free_impl free\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.hh","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"}]}