{"files":[{"patch":"@@ -804,1 +804,6 @@\n-            writer.writeLocalVar(op, slot);\n+            var op = this.op;\n+            if (op.sizeIfFixed() == 1) {\n+                writer.writeBytecode(op);\n+            } else {\n+                writer.writeLocalVar(op, slot);\n+            }\n@@ -835,1 +840,6 @@\n-            writer.writeLocalVar(op, slot);\n+            var op = this.op;\n+            if (op.sizeIfFixed() == 1) {\n+                writer.writeBytecode(op);\n+            } else {\n+                writer.writeLocalVar(op, slot);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -464,1 +464,0 @@\n-            pool.writeU1(TAG_UTF8);\n@@ -466,1 +465,1 @@\n-                pool.writeU2(rawLen);\n+                pool.writeU1U2(TAG_UTF8, rawLen);\n@@ -471,1 +470,1 @@\n-                pool.writeUTF(stringValue);\n+                pool.writeUtfEntry(stringValue);\n@@ -505,2 +504,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(ref1.index());\n+            pool.writeU1U2(tag(), ref1.index());\n@@ -535,3 +533,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(ref1.index());\n-            pool.writeU2(ref2.index());\n+            pool.writeU1U2U2(tag(), ref1.index(), ref2.index());\n@@ -867,3 +863,1 @@\n-            pool.writeU1(tag());\n-            pool.writeU2(bsmIndex);\n-            pool.writeU2(nameAndType.index());\n+            pool.writeU1U2U2(tag(), bsmIndex, nameAndType.index());\n@@ -987,3 +981,1 @@\n-            pool.writeU1(TAG_METHOD_HANDLE);\n-            pool.writeU1(refKind);\n-            pool.writeU2(reference.index());\n+            pool.writeU1U1U2(TAG_METHOD_HANDLE, refKind, reference.index());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -318,2 +318,1 @@\n-                buf.writeU1(tpbt.typeParameterIndex());\n-                buf.writeU1(tpbt.boundIndex());\n+                buf.writeU1U1(tpbt.typeParameterIndex(), tpbt.boundIndex());\n@@ -330,3 +329,1 @@\n-                    buf.writeU2(startPc);\n-                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n-                    buf.writeU2(e.index());\n+                    buf.writeU2U2U2(startPc, labelToBci(lr, e.endLabel(), ta) - startPc, e.index());\n@@ -346,2 +343,1 @@\n-            buf.writeU1(component.typePathKind().tag());\n-            buf.writeU1(component.typeArgumentIndex());\n+            buf.writeU1U1(component.typePathKind().tag(), component.typeArgumentIndex());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.Arrays;\n@@ -34,1 +33,3 @@\n-    private final List<Attribute<?>> attributes = new ArrayList<>();\n+    private static final Attribute<?>[] EMPTY_ATTRIBUTE_ARRAY = {};\n+    private int attributesCount = 0;\n+    private Attribute<?>[] attributes = EMPTY_ATTRIBUTE_ARRAY;\n@@ -42,2 +43,10 @@\n-        if (!am.allowMultiple() && isPresent(am)) {\n-            remove(am);\n+        int attributesCount = this.attributesCount;\n+        var attributes = this.attributes;\n+        if (!am.allowMultiple()) {\n+            \/\/ remove if\n+            for (int i = attributesCount - 1; i >= 0; i--) {\n+                if (attributes[i].attributeMapper() == am) {\n+                    attributesCount--;\n+                    System.arraycopy(attributes, i + 1, attributes, i, attributesCount - i);\n+                }\n+            }\n@@ -45,1 +54,8 @@\n-        attributes.add(a);\n+\n+        \/\/ add attribute\n+        if (attributesCount >= attributes.length) {\n+            int newCapacity = attributesCount + 4;\n+            this.attributes = attributes = Arrays.copyOf(attributes, newCapacity);\n+        }\n+        attributes[attributesCount] = a;\n+        this.attributesCount = attributesCount + 1;\n@@ -49,1 +65,1 @@\n-        return attributes.size();\n+        return attributesCount;\n@@ -53,1 +69,5 @@\n-        Util.writeAttributes(buf, attributes);\n+        int attributesCount = this.attributesCount;\n+        buf.writeU2(attributesCount);\n+        for (int i = 0; i < attributesCount; i++) {\n+            Util.writeAttribute(buf, attributes[i]);\n+        }\n@@ -58,1 +78,2 @@\n-        for (Attribute<?> a : attributes)\n+        for (int i = 0; i < attributesCount; i++) {\n+            Attribute<?> a = attributes[i];\n@@ -60,1 +81,2 @@\n-                return (A)a;\n+                return (A) a;\n+        }\n@@ -65,2 +87,2 @@\n-        for (Attribute<?> a : attributes)\n-            if (a.attributeMapper() == am)\n+        for (int i = 0; i < attributesCount; i++) {\n+            if (attributes[i].attributeMapper() == am)\n@@ -68,0 +90,1 @@\n+        }\n@@ -70,4 +93,0 @@\n-\n-    private void remove(AttributeMapper<?> am) {\n-        attributes.removeIf(a -> a.attributeMapper() == am);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import static java.lang.classfile.constantpool.PoolEntry.TAG_UTF8;\n@@ -117,0 +118,77 @@\n+    @ForceInline\n+    public void writeU1U1(int x1, int x2) {\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        this.offset = offset + 2;\n+    }\n+\n+    public void writeU1U2(int u1, int u2) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) u1;\n+        elems[offset + 1] = (byte) (u2 >> 8);\n+        elems[offset + 2] = (byte) u2;\n+        this.offset = offset + 3;\n+    }\n+\n+    public void writeU1U1U1(int x1, int x2, int x3) {\n+        reserveSpace(3);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        elems[offset + 2] = (byte) x3;\n+        this.offset = offset + 3;\n+    }\n+\n+    public void writeU1U1U2(int x1, int x2, int x3) {\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) x2;\n+        elems[offset + 2] = (byte) (x3 >> 8);\n+        elems[offset + 3] = (byte) x3;\n+        this.offset = offset + 4;\n+    }\n+\n+    public void writeU1U2U2(int x1, int x2, int x3) {\n+        reserveSpace(5);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) x1;\n+        elems[offset + 1] = (byte) (x2 >> 8);\n+        elems[offset + 2] = (byte) x2;\n+        elems[offset + 3] = (byte) (x3 >> 8);\n+        elems[offset + 4] = (byte) x3;\n+        this.offset = offset + 5;\n+    }\n+\n+    public void writeU2U2(int x1, int x2) {\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) (x2 >> 8);\n+        elems[offset + 3] = (byte) x2;\n+        this.offset = offset + 4;\n+    }\n+\n+    public void writeU2U2U2(int x1, int x2, int x3) {\n+        reserveSpace(6);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x1 >> 8);\n+        elems[offset + 1] = (byte) x1;\n+        elems[offset + 2] = (byte) (x2 >> 8);\n+        elems[offset + 3] = (byte) x2;\n+        elems[offset + 4] = (byte) (x3 >> 8);\n+        elems[offset + 5] = (byte) x3;\n+        this.offset = offset + 6;\n+    }\n+\n@@ -165,1 +243,1 @@\n-    void writeUTF(String str) {\n+    void writeUtfEntry(String str) {\n@@ -172,1 +250,1 @@\n-        reserveSpace(utflen + 2);\n+        reserveSpace(utflen + 3);\n@@ -177,3 +255,4 @@\n-        elems[offset    ] = (byte) (utflen >> 8);\n-        elems[offset + 1] = (byte)  utflen;\n-        offset += 2;\n+        elems[offset    ] = (byte) TAG_UTF8;\n+        elems[offset + 1] = (byte) (utflen >> 8);\n+        elems[offset + 2] = (byte)  utflen;\n+        offset += 3;\n@@ -272,3 +351,1 @@\n-    @ForceInline\n-    @Override\n-    public void writeIndex(PoolEntry entry) {\n+    public int cpIndex(PoolEntry entry) {\n@@ -278,1 +355,11 @@\n-        writeU2(idx);\n+        return idx;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    public void writeIndex(PoolEntry entry) {\n+        writeU2(cpIndex(entry));\n+    }\n+\n+    public void writeIndex(int bytecode, PoolEntry entry) {\n+        writeU1U2(bytecode, cpIndex(entry));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":96,"deletions":9,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -267,0 +267,5 @@\n+    public static int returnBytecode(TypeKind tk) {\n+        int kind = Math.max(0, tk.ordinal() - 4); \/\/ BYTE, SHORT, CHAR, BOOLEAN becomes INT\n+        return IRETURN + kind;\n+    }\n+\n@@ -281,0 +286,14 @@\n+    public static int arrayLoadBytecode(TypeKind tk) {\n+        return switch (tk) {\n+            case BYTE, BOOLEAN -> BALOAD;\n+            case SHORT -> SALOAD;\n+            case INT -> IALOAD;\n+            case FLOAT -> FALOAD;\n+            case LONG -> LALOAD;\n+            case DOUBLE -> DALOAD;\n+            case REFERENCE -> AALOAD;\n+            case CHAR -> CALOAD;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n@@ -295,0 +314,14 @@\n+    public static int arrayStoreBytecode(TypeKind tk) {\n+        return switch (tk) {\n+            case BYTE, BOOLEAN -> BASTORE;\n+            case SHORT -> SASTORE;\n+            case INT -> IASTORE;\n+            case FLOAT -> FASTORE;\n+            case LONG -> LASTORE;\n+            case DOUBLE -> DASTORE;\n+            case REFERENCE -> AASTORE;\n+            case CHAR -> CASTORE;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+        };\n+    }\n+\n@@ -317,0 +350,23 @@\n+    public static int reverseBranchOpcode(int bytecode) {\n+        return switch (bytecode) {\n+            case IFEQ -> IFNE;\n+            case IFNE -> IFEQ;\n+            case IFLT -> IFGE;\n+            case IFGE -> IFLT;\n+            case IFGT -> IFLE;\n+            case IFLE -> IFGT;\n+            case IF_ICMPEQ -> IF_ICMPNE;\n+            case IF_ICMPNE -> IF_ICMPEQ;\n+            case IF_ICMPLT -> IF_ICMPGE;\n+            case IF_ICMPGE -> IF_ICMPLT;\n+            case IF_ICMPGT -> IF_ICMPLE;\n+            case IF_ICMPLE -> IF_ICMPGT;\n+            case IF_ACMPEQ -> IF_ACMPNE;\n+            case IF_ACMPNE -> IF_ACMPEQ;\n+            case IFNULL -> IFNONNULL;\n+            case IFNONNULL -> IFNULL;\n+            default -> throw new IllegalArgumentException(\n+                    String.format(\"Wrong opcode kind specified; found %d, expected %s\", bytecode, Opcode.Kind.BRANCH));\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -356,1 +356,5 @@\n-        throw new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + index);\n+        throw checkTypeError(index, cls);\n+    }\n+\n+    private static ConstantPoolException checkTypeError(int index, Class<?> cls) {\n+        return new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -33,0 +34,1 @@\n+import java.util.Arrays;\n@@ -57,0 +59,2 @@\n+    static final Util.Writable[] EMPTY_WRITABLE_ARRAY = {};\n+    static final ClassEntry[] EMPTY_CLASS_ENTRY_ARRAY = {};\n@@ -58,2 +62,4 @@\n-    private final List<Util.Writable> fields = new ArrayList<>();\n-    private final List<Util.Writable> methods = new ArrayList<>();\n+    private Util.Writable[] fields = EMPTY_WRITABLE_ARRAY;\n+    private Util.Writable[] methods = EMPTY_WRITABLE_ARRAY;\n+    private int fieldsCount = 0;\n+    private int methodsCount = 0;\n@@ -140,1 +146,5 @@\n-        fields.add(field);\n+        if (fieldsCount >= fields.length) {\n+            int newCapacity = fieldsCount + 8;\n+            this.fields = Arrays.copyOf(fields, newCapacity);\n+        }\n+        fields[fieldsCount++] = field;\n@@ -145,1 +155,5 @@\n-        methods.add(method);\n+        if (methodsCount >= methods.length) {\n+            int newCapacity = methodsCount + 8;\n+            this.methods = Arrays.copyOf(methods, newCapacity);\n+        }\n+        methods[methodsCount++] = method;\n@@ -187,3 +201,1 @@\n-        List<ClassEntry> ies = new ArrayList<>(interfaceEntriesSize);\n-        for (int i = 0; i < interfaceEntriesSize; i++)\n-            ies.add(AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i)));\n+        ClassEntry[] ies = interfaceEntriesSize == 0 ? EMPTY_CLASS_ENTRY_ARRAY : buildInterfaceEnties(interfaceEntriesSize);\n@@ -198,2 +210,2 @@\n-        Util.writeList(tail, fields);\n-        Util.writeList(tail, methods);\n+        Util.writeList(tail, fields, fieldsCount);\n+        Util.writeList(tail, methods, methodsCount);\n@@ -214,2 +226,1 @@\n-        head.writeU2(flags);\n-        head.writeIndex(thisClassEntry);\n+        head.writeU2U2(flags, head.cpIndex(thisClassEntry));\n@@ -217,1 +228,4 @@\n-        Util.writeListIndices(head, ies);\n+        head.writeU2(interfaceEntriesSize);\n+        for (int i = 0; i < interfaceEntriesSize; i++) {\n+            head.writeIndex(ies[i]);\n+        }\n@@ -222,0 +236,7 @@\n+\n+    private ClassEntry[] buildInterfaceEnties(int interfaceEntriesSize) {\n+        var ies = new ClassEntry[interfaceEntriesSize];\n+        for (int i = 0; i < interfaceEntriesSize; i++)\n+            ies[i] = AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i));\n+        return ies;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -55,1 +57,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -57,0 +58,1 @@\n+import java.util.Arrays;\n@@ -65,2 +67,0 @@\n-import static java.lang.classfile.Opcode.*;\n-\n@@ -68,0 +68,1 @@\n+import static jdk.internal.classfile.impl.RawBytecodeHelper.*;\n@@ -72,1 +73,7 @@\n-    private final List<CharacterRange> characterRanges = new ArrayList<>();\n+    private static final CharacterRange[] EMPTY_CHARACTER_RANGE = {};\n+    private static final DeferredLabel[] EMPTY_LABEL_ARRAY = {};\n+    private static final LocalVariable[] EMPTY_LOCAL_VARIABLE_ARRAY = {};\n+    private static final LocalVariableType[] EMPTY_LOCAL_VARIABLE_TYPE_ARRAY = {};\n+    private static final AbstractPseudoInstruction.ExceptionCatchImpl[] EMPTY_HANDLER_ARRAY = {};\n+    private static final DeferredLabel[] EMPTY_DEFERRED_LABEL_ARRAY = {};\n+\n@@ -74,3 +81,7 @@\n-    private final List<LocalVariable> localVariables = new ArrayList<>();\n-    private final List<LocalVariableType> localVariableTypes = new ArrayList<>();\n-    private final boolean transformFwdJumps, transformBackJumps;\n+    private CharacterRange[] characterRanges = EMPTY_CHARACTER_RANGE;\n+    private LocalVariable[] localVariables = EMPTY_LOCAL_VARIABLE_ARRAY;\n+    private LocalVariableType[] localVariableTypes = EMPTY_LOCAL_VARIABLE_TYPE_ARRAY;\n+    private int characterRangesCount = 0;\n+    private int localVariablesCount = 0;\n+    private int localVariableTypesCount = 0;\n+    private final boolean transformDeferredJumps, transformKnownJumps;\n@@ -86,1 +97,2 @@\n-    List<DeferredLabel> deferredLabels;\n+    private DeferredLabel[] deferredLabels = EMPTY_DEFERRED_LABEL_ARRAY;\n+    private int deferredLabelsCount = 0;\n@@ -120,1 +132,1 @@\n-                              boolean transformFwdJumps) {\n+                              boolean transformDeferredJumps) {\n@@ -124,2 +136,2 @@\n-        this.transformFwdJumps = transformFwdJumps;\n-        this.transformBackJumps = context.fixShortJumps();\n+        this.transformDeferredJumps = transformDeferredJumps;\n+        this.transformKnownJumps = context.fixShortJumps();\n@@ -211,3 +223,1 @@\n-                buf.writeU2(startPc);\n-                buf.writeU2(endPc);\n-                buf.writeU2(handlerPc);\n+                buf.writeU2U2U2(startPc, endPc, handlerPc);\n@@ -230,1 +240,1 @@\n-            if (!characterRanges.isEmpty()) {\n+            if (characterRangesCount > 0) {\n@@ -236,1 +246,1 @@\n-                        int crSize = characterRanges.size();\n+                        int crSize = characterRangesCount;\n@@ -238,1 +248,2 @@\n-                        for (CharacterRange cr : characterRanges) {\n+                        for (int i = 0; i < characterRangesCount; i++) {\n+                            CharacterRange cr = characterRanges[i];\n@@ -248,2 +259,1 @@\n-                                b.writeU2(start);\n-                                b.writeU2(end - 1);\n+                                b.writeU2U2(start, end - 1);\n@@ -255,1 +265,1 @@\n-                        if (crSize < characterRanges.size())\n+                        if (crSize < characterRangesCount)\n@@ -262,1 +272,1 @@\n-            if (!localVariables.isEmpty()) {\n+            if (localVariablesCount > 0) {\n@@ -267,1 +277,1 @@\n-                        int lvSize = localVariables.size();\n+                        int lvSize = localVariablesCount;\n@@ -269,1 +279,2 @@\n-                        for (LocalVariable l : localVariables) {\n+                        for (int i = 0; i < localVariablesCount; i++) {\n+                            LocalVariable l = localVariables[i];\n@@ -278,1 +289,1 @@\n-                        if (lvSize < localVariables.size())\n+                        if (lvSize < localVariablesCount)\n@@ -285,1 +296,1 @@\n-            if (!localVariableTypes.isEmpty()) {\n+            if (localVariableTypesCount > 0) {\n@@ -290,3 +301,4 @@\n-                        int lvtSize = localVariableTypes.size();\n-                        b.writeU2(localVariableTypes.size());\n-                        for (LocalVariableType l : localVariableTypes) {\n+                        int lvtSize = localVariableTypesCount;\n+                        b.writeU2(lvtSize);\n+                        for (int i = 0; i < localVariableTypesCount; i++) {\n+                            LocalVariableType l = localVariableTypes[i];\n@@ -301,1 +313,1 @@\n-                        if (lvtSize < localVariableTypes.size())\n+                        if (lvtSize < localVariableTypesCount)\n@@ -318,2 +330,1 @@\n-                    buf.writeU2(originalAttribute.maxStack());\n-                    buf.writeU2(originalAttribute.maxLocals());\n+                    buf.writeU2U2(originalAttribute.maxStack(), originalAttribute.maxLocals());\n@@ -322,2 +333,1 @@\n-                    buf.writeU2(cntr.maxStack());\n-                    buf.writeU2(cntr.maxLocals());\n+                    buf.writeU2U2(cntr.maxStack(), cntr.maxLocals());\n@@ -330,4 +340,4 @@\n-                StackMapGenerator gen = StackMapGenerator.of(DirectCodeBuilder.this, buf);\n-                attributes.withAttribute(gen.stackMapTableAttribute());\n-                buf.writeU2(gen.maxStack());\n-                buf.writeU2(gen.maxLocals());\n+                var dcb = DirectCodeBuilder.this;\n+                StackMapGenerator gen = StackMapGenerator.of(dcb, buf);\n+                dcb.attributes.withAttribute(gen.stackMapTableAttribute());\n+                buf.writeU2U2(gen.maxStack(), gen.maxLocals());\n@@ -355,1 +365,2 @@\n-                buf.setLabelContext(DirectCodeBuilder.this);\n+                DirectCodeBuilder dcb = DirectCodeBuilder.this;\n+                buf.setLabelContext(dcb);\n@@ -362,2 +373,2 @@\n-                            methodInfo.methodName().stringValue(),\n-                            methodInfo.methodTypeSymbol().displayDescriptor()));\n+                            dcb.methodInfo.methodName().stringValue(),\n+                            dcb.methodInfo.methodTypeSymbol().displayDescriptor()));\n@@ -366,1 +377,2 @@\n-                if (codeAndExceptionsMatch(codeLength)) {\n+                var context = dcb.context;\n+                if (dcb.original != null && codeAndExceptionsMatch(codeLength)) {\n@@ -368,1 +380,1 @@\n-                        attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n+                        dcb.attributes.withAttribute(dcb.original.findAttribute(Attributes.stackMapTable()).orElse(null));\n@@ -386,3 +398,3 @@\n-                buf.writeBytes(bytecodesBufWriter);\n-                writeExceptionHandlers(buf);\n-                attributes.writeTo(buf);\n+                buf.writeBytes(dcb.bytecodesBufWriter);\n+                dcb.writeExceptionHandlers(buf);\n+                dcb.attributes.writeTo(buf);\n@@ -408,2 +420,1 @@\n-                buf.writeU2(lastPc);\n-                buf.writeU2(lastLine);\n+                buf.writeU2U2(lastPc, lastLine);\n@@ -459,15 +470,0 @@\n-    private void writeLabelOffset(int nBytes, int instructionPc, Label label) {\n-        int targetBci = labelToBci(label);\n-        if (targetBci == -1) {\n-            int pc = bytecodesBufWriter.skip(nBytes);\n-            if (deferredLabels == null)\n-                deferredLabels = new ArrayList<>();\n-            deferredLabels.add(new DeferredLabel(pc, nBytes, instructionPc, label));\n-        }\n-        else {\n-            int branchOffset = targetBci - instructionPc;\n-            if (nBytes == 2 && (short)branchOffset != branchOffset) throw new LabelOverflowException();\n-            bytecodesBufWriter.writeIntBytes(nBytes, branchOffset);\n-        }\n-    }\n-\n@@ -475,10 +471,9 @@\n-        if (deferredLabels != null) {\n-            for (DeferredLabel dl : deferredLabels) {\n-                int branchOffset = labelToBci(dl.label) - dl.instructionPc;\n-                if (dl.size == 2) {\n-                    if ((short)branchOffset != branchOffset) throw new LabelOverflowException();\n-                    bytecodesBufWriter.patchU2(dl.labelPc, branchOffset);\n-                } else {\n-                    assert dl.size == 4;\n-                    bytecodesBufWriter.patchInt(dl.labelPc, branchOffset);\n-                }\n+        for (int i = 0; i < deferredLabelsCount; i++) {\n+            DeferredLabel dl = deferredLabels[i];\n+            int branchOffset = labelToBci(dl.label) - dl.instructionPc;\n+            if (dl.size == 2) {\n+                if ((short) branchOffset != branchOffset) throw new LabelOverflowException();\n+                bytecodesBufWriter.patchU2(dl.labelPc, branchOffset);\n+            } else {\n+                assert dl.size == 4;\n+                bytecodesBufWriter.patchInt(dl.labelPc, branchOffset);\n@@ -492,0 +487,6 @@\n+        assert !opcode.isWide();\n+        bytecodesBufWriter.writeU1(opcode.bytecode());\n+    }\n+\n+    \/\/ Instruction version, refer to opcode\n+    public void writeLocalVar(Opcode opcode, int slot) {\n@@ -493,1 +494,1 @@\n-            bytecodesBufWriter.writeU2(opcode.bytecode());\n+            bytecodesBufWriter.writeU2U2(opcode.bytecode(), slot);\n@@ -495,1 +496,1 @@\n-            bytecodesBufWriter.writeU1(opcode.bytecode());\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), slot);\n@@ -499,7 +500,7 @@\n-    public void writeLocalVar(Opcode opcode, int localVar) {\n-        writeBytecode(opcode);\n-        switch (opcode.sizeIfFixed()) {\n-            case 1 -> { }\n-            case 2 -> bytecodesBufWriter.writeU1(localVar);\n-            case 4 -> bytecodesBufWriter.writeU2(localVar);\n-            default -> throw new IllegalArgumentException(\"Unexpected instruction size: \" + opcode);\n+    \/\/ Shortcut version, refer to and validate slot\n+    private void writeLocalVar(int bytecode, int slot) {\n+        \/\/ TODO validation like (slot & 0xFFFF) == slot\n+        if (slot < 256) {\n+            bytecodesBufWriter.writeU1U1(bytecode, slot);\n+        } else {\n+            bytecodesBufWriter.writeU1U1U2(WIDE, bytecode, slot);\n@@ -511,6 +512,1 @@\n-            bytecodesBufWriter.writeU1(RawBytecodeHelper.WIDE);\n-        }\n-        bytecodesBufWriter.writeU1(RawBytecodeHelper.IINC);\n-        if (wide) {\n-            bytecodesBufWriter.writeU2(slot);\n-            bytecodesBufWriter.writeU2(val);\n+            bytecodesBufWriter.writeU2U2U2((WIDE << 8) | IINC, slot, val);\n@@ -518,2 +514,1 @@\n-            bytecodesBufWriter.writeU1(slot);\n-            bytecodesBufWriter.writeU1(val);\n+            bytecodesBufWriter.writeU1U1U1(IINC, slot, val);\n@@ -524,0 +519,25 @@\n+        if (op.sizeIfFixed() == 3) {\n+            writeShortJump(op.bytecode(), target);\n+        } else {\n+            writeLongJump(op.bytecode(), target);\n+        }\n+    }\n+\n+    private void writeLongLabelOffset(int instructionPc, Label label) {\n+        int targetBci = labelToBci(label);\n+\n+        \/\/ algebraic union of jump | (instructionPc, target), distinguished by null == target.\n+        int jumpOrInstructionPc;\n+        Label nullOrTarget;\n+        if (targetBci == -1) {\n+            jumpOrInstructionPc = instructionPc;\n+            nullOrTarget = label;\n+        } else {\n+            jumpOrInstructionPc = targetBci - instructionPc;\n+            nullOrTarget = null;\n+        }\n+\n+        writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+    }\n+\n+    private void writeShortJump(int bytecode, Label target) {\n@@ -526,0 +546,12 @@\n+\n+        \/\/ algebraic union of jump | (instructionPc, target), distinguished by null == target.\n+        int jumpOrInstructionPc;\n+        Label nullOrTarget;\n+        if (targetBci == -1) {\n+            jumpOrInstructionPc = instructionPc;\n+            nullOrTarget = target;\n+        } else {\n+            jumpOrInstructionPc = targetBci - instructionPc;\n+            nullOrTarget = null;\n+        }\n+\n@@ -527,10 +559,28 @@\n-        if (op.sizeIfFixed() == 3 && (targetBci == -1\n-                                      ? transformFwdJumps\n-                                      : (transformBackJumps\n-                                         && targetBci - instructionPc < Short.MIN_VALUE))) {\n-            if (op == GOTO) {\n-                writeBytecode(GOTO_W);\n-                writeLabelOffset(4, instructionPc, target);\n-            } else if (op == JSR) {\n-                writeBytecode(JSR_W);\n-                writeLabelOffset(4, instructionPc, target);\n+        if (transformDeferredJumps || transformKnownJumps && nullOrTarget == null && jumpOrInstructionPc < Short.MIN_VALUE) {\n+            fixShortJump(bytecode, jumpOrInstructionPc, nullOrTarget);\n+        } else {\n+            bytecodesBufWriter.writeU1(bytecode);\n+            writeParsedShortLabel(jumpOrInstructionPc, nullOrTarget);\n+        }\n+    }\n+\n+    private void writeLongJump(int bytecode, Label target) {\n+        int instructionPc = curPc();\n+        bytecodesBufWriter.writeU1(bytecode);\n+        writeLongLabelOffset(instructionPc, target);\n+    }\n+\n+    private void fixShortJump(int bytecode, int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (bytecode == GOTO) {\n+            bytecodesBufWriter.writeU1(GOTO_W);\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+        } else if (bytecode == JSR) {\n+            bytecodesBufWriter.writeU1(JSR_W);\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget);\n+        } else {\n+            bytecodesBufWriter.writeU1U2(\n+                    BytecodeHelpers.reverseBranchOpcode(bytecode),   \/\/ u1\n+                    8); \/\/ u1 + s2 + u1 + s4                         \/\/ s2\n+            bytecodesBufWriter.writeU1(GOTO_W);                      \/\/ u1\n+            if (nullOrTarget == null) {\n+                jumpOrInstructionPc -= 3; \/\/ jump -= 3;\n@@ -538,6 +588,1 @@\n-                writeBytecode(BytecodeHelpers.reverseBranchOpcode(op));\n-                Label bypassJump = newLabel();\n-                writeLabelOffset(2, instructionPc, bypassJump);\n-                writeBytecode(GOTO_W);\n-                writeLabelOffset(4, instructionPc + 3, target);\n-                labelBinding(bypassJump);\n+                jumpOrInstructionPc += 3; \/\/ instructionPc += 3;\n@@ -545,0 +590,9 @@\n+            writeParsedLongLabel(jumpOrInstructionPc, nullOrTarget); \/\/ s4\n+        }\n+    }\n+\n+    private void writeParsedShortLabel(int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (nullOrTarget == null) {\n+            if ((short) jumpOrInstructionPc != jumpOrInstructionPc)\n+                throw new LabelOverflowException();\n+            bytecodesBufWriter.writeU2(jumpOrInstructionPc);\n@@ -546,2 +600,11 @@\n-            writeBytecode(op);\n-            writeLabelOffset(op.sizeIfFixed() == 3 ? 2 : 4, instructionPc, target);\n+            int pc = bytecodesBufWriter.skip(2);\n+            addLabel(new DeferredLabel(pc, 2, jumpOrInstructionPc, nullOrTarget));\n+        }\n+    }\n+\n+    private void writeParsedLongLabel(int jumpOrInstructionPc, Label nullOrTarget) {\n+        if (nullOrTarget == null) {\n+            bytecodesBufWriter.writeInt(jumpOrInstructionPc);\n+        } else {\n+            int pc = bytecodesBufWriter.skip(4);\n+            addLabel(new DeferredLabel(pc, 4, jumpOrInstructionPc, nullOrTarget));\n@@ -553,1 +616,1 @@\n-        writeBytecode(LOOKUPSWITCH);\n+        bytecodesBufWriter.writeU1(LOOKUPSWITCH);\n@@ -557,1 +620,1 @@\n-        writeLabelOffset(4, instructionPc, defaultTarget);\n+        writeLongLabelOffset(instructionPc, defaultTarget);\n@@ -568,1 +631,2 @@\n-            writeLabelOffset(4, instructionPc, c.target());\n+            var target = c.target();\n+            writeLongLabelOffset(instructionPc, target);\n@@ -574,1 +638,1 @@\n-        writeBytecode(TABLESWITCH);\n+        bytecodesBufWriter.writeU1(TABLESWITCH);\n@@ -578,1 +642,1 @@\n-        writeLabelOffset(4, instructionPc, defaultTarget);\n+        writeLongLabelOffset(instructionPc, defaultTarget);\n@@ -586,1 +650,2 @@\n-            writeLabelOffset(4, instructionPc, caseMap.getOrDefault((int)l, defaultTarget));\n+            var target = caseMap.getOrDefault((int)l, defaultTarget);\n+            writeLongLabelOffset(instructionPc, target);\n@@ -591,2 +656,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -596,2 +660,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -603,4 +666,2 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(ref);\n-        bytecodesBufWriter.writeU1(count);\n-        bytecodesBufWriter.writeU1(0);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n+        bytecodesBufWriter.writeU1U1(count, 0);\n@@ -610,2 +671,1 @@\n-        writeBytecode(INVOKEDYNAMIC);\n-        bytecodesBufWriter.writeIndex(ref);\n+        bytecodesBufWriter.writeIndex(INVOKEDYNAMIC, ref);\n@@ -616,2 +676,1 @@\n-        writeBytecode(NEW);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(NEW, type);\n@@ -621,2 +680,1 @@\n-        writeBytecode(NEWARRAY);\n-        bytecodesBufWriter.writeU1(newArrayCode);\n+        bytecodesBufWriter.writeU1U1(NEWARRAY, newArrayCode);\n@@ -626,2 +684,1 @@\n-        writeBytecode(ANEWARRAY);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(ANEWARRAY, type);\n@@ -631,2 +688,1 @@\n-        writeBytecode(MULTIANEWARRAY);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(MULTIANEWARRAY, type);\n@@ -637,2 +693,1 @@\n-        writeBytecode(opcode);\n-        bytecodesBufWriter.writeIndex(type);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), type);\n@@ -642,1 +697,0 @@\n-        writeBytecode(opcode);\n@@ -644,1 +698,1 @@\n-            bytecodesBufWriter.writeU2(value);\n+            bytecodesBufWriter.writeU1U2(opcode.bytecode(), value);\n@@ -646,1 +700,1 @@\n-            bytecodesBufWriter.writeU1(value);\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), value);\n@@ -654,1 +708,0 @@\n-        Opcode op = opcode;\n@@ -656,1 +709,1 @@\n-            op = LDC2_W;\n+            opcode = Opcode.LDC2_W;\n@@ -658,1 +711,1 @@\n-            op = LDC_W;\n+            opcode = Opcode.LDC_W;\n@@ -660,3 +713,3 @@\n-        writeBytecode(op);\n-        if (op.sizeIfFixed() == 3) {\n-            bytecodesBufWriter.writeU2(index);\n+        assert !opcode.isWide();\n+        if (opcode.sizeIfFixed() == 3) {\n+            bytecodesBufWriter.writeU1U2(opcode.bytecode(), index);\n@@ -664,1 +717,1 @@\n-            bytecodesBufWriter.writeU1(index);\n+            bytecodesBufWriter.writeU1U1(opcode.bytecode(), index);\n@@ -680,1 +733,5 @@\n-        else if (context == mruParent) {\n+        return labelToBci(context, lab);\n+    }\n+\n+    private int labelToBci(LabelContext context, LabelImpl lab) {\n+        if (context == mruParent) {\n@@ -720,3 +777,1 @@\n-        LabelContext context = lab.labelContext();\n-\n-        if (context == this) {\n+        if (lab.labelContext() == this) {\n@@ -726,0 +781,2 @@\n+        } else {\n+            setLabelTarget(lab, bci);\n@@ -727,1 +784,5 @@\n-        else if (context == mruParent) {\n+    }\n+\n+    private void setLabelTarget(LabelImpl lab, int bci) {\n+        LabelContext context = lab.labelContext();\n+        if (context == mruParent) {\n@@ -742,1 +803,1 @@\n-            mruParentTable[lab.getBCI()] = bci + 1;\n+            table[lab.getBCI()] = bci + 1;\n@@ -754,1 +815,13 @@\n-        characterRanges.add(element);\n+        if (characterRangesCount >= characterRanges.length) {\n+            int newCapacity = characterRangesCount + 8;\n+            this.characterRanges = Arrays.copyOf(characterRanges, newCapacity);\n+        }\n+        characterRanges[characterRangesCount++] = element;\n+    }\n+\n+    public void addLabel(DeferredLabel label) {\n+        if (deferredLabelsCount >= deferredLabels.length) {\n+            int newCapacity = deferredLabelsCount + 8;\n+            this.deferredLabels = Arrays.copyOf(deferredLabels, newCapacity);\n+        }\n+        deferredLabels[deferredLabelsCount++] = label;\n@@ -766,1 +839,5 @@\n-        localVariables.add(element);\n+        if (localVariablesCount >= localVariables.length) {\n+            int newCapacity = localVariablesCount + 8;\n+            this.localVariables = Arrays.copyOf(localVariables, newCapacity);\n+        }\n+        localVariables[localVariablesCount++] = element;\n@@ -770,1 +847,5 @@\n-        localVariableTypes.add(element);\n+        if (localVariableTypesCount >= localVariableTypes.length) {\n+            int newCapacity = localVariableTypesCount + 8;\n+            this.localVariableTypes = Arrays.copyOf(localVariableTypes, newCapacity);\n+        }\n+        localVariableTypes[localVariableTypesCount++] = element;\n@@ -791,0 +872,6 @@\n+    @Override\n+    public CodeBuilder return_() {\n+        bytecodesBufWriter.writeU1(RETURN);\n+        return this;\n+    }\n+\n@@ -793,1 +880,1 @@\n-        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        bytecodesBufWriter.writeU1(returnBytecode(tk));\n@@ -799,1 +886,14 @@\n-        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return switch (tk) {\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> istore(slot);\n+            case LONG      -> lstore(slot);\n+            case DOUBLE    -> dstore(slot);\n+            case FLOAT     -> fstore(slot);\n+            case REFERENCE -> astore(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    @Override\n+    public CodeBuilder labelBinding(Label label) {\n+        setLabelTarget(label, curPc());\n@@ -805,2 +905,9 @@\n-        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n-        return this;\n+        return switch (tk) {\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> iload(slot);\n+            case LONG      -> lload(slot);\n+            case DOUBLE    -> dload(slot);\n+            case FLOAT     -> fload(slot);\n+            case REFERENCE -> aload(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n@@ -811,1 +918,1 @@\n-        if (opcode == INVOKEINTERFACE) {\n+        if (opcode == Opcode.INVOKEINTERFACE) {\n@@ -820,0 +927,24 @@\n+    @Override\n+    public CodeBuilder invokespecial(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(ClassDesc owner, String name, MethodTypeDesc type) {\n+        bytecodesBufWriter.writeIndex(INVOKEVIRTUAL, constantPool().methodRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder getfield(ClassDesc owner, String name, ClassDesc type) {\n+        bytecodesBufWriter.writeIndex(GETFIELD, constantPool().fieldRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n@@ -822,1 +953,1 @@\n-        writeFieldAccess(opcode, ref);\n+        bytecodesBufWriter.writeIndex(opcode.bytecode(), ref);\n@@ -828,1 +959,1 @@\n-        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        bytecodesBufWriter.writeU1(BytecodeHelpers.arrayLoadBytecode(tk));\n@@ -834,1 +965,1 @@\n-        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        bytecodesBufWriter.writeU1(BytecodeHelpers.arrayStoreBytecode(tk));\n@@ -846,1 +977,1 @@\n-        writeBytecode(NOP);\n+        bytecodesBufWriter.writeU1(NOP);\n@@ -852,1 +983,1 @@\n-        writeBytecode(ACONST_NULL);\n+        bytecodesBufWriter.writeU1(ACONST_NULL);\n@@ -858,1 +989,5 @@\n-        writeLocalVar(BytecodeHelpers.aload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ALOAD_0 + slot);\n+        } else {\n+            writeLocalVar(ALOAD, slot);\n+        }\n@@ -870,1 +1005,7 @@\n-        writeBytecode(ARRAYLENGTH);\n+        bytecodesBufWriter.writeU1(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder areturn() {\n+        bytecodesBufWriter.writeU1(ARETURN);\n@@ -876,1 +1017,5 @@\n-        writeLocalVar(BytecodeHelpers.astore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ASTORE_0 + slot);\n+        } else {\n+            writeLocalVar(ASTORE, slot);\n+        }\n@@ -882,1 +1027,1 @@\n-        writeBytecode(ATHROW);\n+        bytecodesBufWriter.writeU1(ATHROW);\n@@ -889,1 +1034,1 @@\n-        writeArgumentConstant(BIPUSH, b);\n+        bytecodesBufWriter.writeU1U1(BIPUSH, b);\n@@ -895,1 +1040,1 @@\n-        writeTypeCheck(CHECKCAST, type);\n+        bytecodesBufWriter.writeIndex(CHECKCAST, type);\n@@ -901,1 +1046,1 @@\n-        writeBytecode(D2F);\n+        bytecodesBufWriter.writeU1(D2F);\n@@ -907,1 +1052,1 @@\n-        writeBytecode(D2I);\n+        bytecodesBufWriter.writeU1(D2I);\n@@ -913,1 +1058,1 @@\n-        writeBytecode(D2L);\n+        bytecodesBufWriter.writeU1(D2L);\n@@ -919,1 +1064,1 @@\n-        writeBytecode(DADD);\n+        bytecodesBufWriter.writeU1(DADD);\n@@ -925,1 +1070,1 @@\n-        writeBytecode(DCMPG);\n+        bytecodesBufWriter.writeU1(DCMPG);\n@@ -931,1 +1076,1 @@\n-        writeBytecode(DCMPL);\n+        bytecodesBufWriter.writeU1(DCMPL);\n@@ -937,1 +1082,1 @@\n-        writeBytecode(DCONST_0);\n+        bytecodesBufWriter.writeU1(DCONST_0);\n@@ -943,1 +1088,1 @@\n-        writeBytecode(DCONST_1);\n+        bytecodesBufWriter.writeU1(DCONST_1);\n@@ -949,1 +1094,1 @@\n-        writeBytecode(DDIV);\n+        bytecodesBufWriter.writeU1(DDIV);\n@@ -955,1 +1100,5 @@\n-        writeLocalVar(BytecodeHelpers.dload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(DLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(DLOAD, slot);\n+        }\n@@ -961,1 +1110,1 @@\n-        writeBytecode(DMUL);\n+        bytecodesBufWriter.writeU1(DMUL);\n@@ -967,1 +1116,1 @@\n-        writeBytecode(DNEG);\n+        bytecodesBufWriter.writeU1(DNEG);\n@@ -973,1 +1122,7 @@\n-        writeBytecode(DREM);\n+        bytecodesBufWriter.writeU1(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dreturn() {\n+        bytecodesBufWriter.writeU1(DRETURN);\n@@ -979,1 +1134,5 @@\n-        writeLocalVar(BytecodeHelpers.dstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(DSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(DSTORE, slot);\n+        }\n@@ -985,1 +1144,1 @@\n-        writeBytecode(DSUB);\n+        bytecodesBufWriter.writeU1(DSUB);\n@@ -991,1 +1150,1 @@\n-        writeBytecode(DUP);\n+        bytecodesBufWriter.writeU1(DUP);\n@@ -997,1 +1156,1 @@\n-        writeBytecode(DUP2);\n+        bytecodesBufWriter.writeU1(DUP2);\n@@ -1003,1 +1162,1 @@\n-        writeBytecode(DUP2_X1);\n+        bytecodesBufWriter.writeU1(DUP2_X1);\n@@ -1009,1 +1168,1 @@\n-        writeBytecode(DUP2_X2);\n+        bytecodesBufWriter.writeU1(DUP2_X2);\n@@ -1015,1 +1174,1 @@\n-        writeBytecode(DUP_X1);\n+        bytecodesBufWriter.writeU1(DUP_X1);\n@@ -1021,1 +1180,1 @@\n-        writeBytecode(DUP_X2);\n+        bytecodesBufWriter.writeU1(DUP_X2);\n@@ -1027,1 +1186,1 @@\n-        writeBytecode(F2D);\n+        bytecodesBufWriter.writeU1(F2D);\n@@ -1033,1 +1192,1 @@\n-        writeBytecode(F2I);\n+        bytecodesBufWriter.writeU1(F2I);\n@@ -1039,1 +1198,1 @@\n-        writeBytecode(F2L);\n+        bytecodesBufWriter.writeU1(F2L);\n@@ -1045,1 +1204,1 @@\n-        writeBytecode(FADD);\n+        bytecodesBufWriter.writeU1(FADD);\n@@ -1051,1 +1210,1 @@\n-        writeBytecode(FCMPG);\n+        bytecodesBufWriter.writeU1(FCMPG);\n@@ -1057,1 +1216,1 @@\n-        writeBytecode(FCMPL);\n+        bytecodesBufWriter.writeU1(FCMPL);\n@@ -1063,1 +1222,1 @@\n-        writeBytecode(FCONST_0);\n+        bytecodesBufWriter.writeU1(FCONST_0);\n@@ -1069,1 +1228,1 @@\n-        writeBytecode(FCONST_1);\n+        bytecodesBufWriter.writeU1(FCONST_1);\n@@ -1075,1 +1234,1 @@\n-        writeBytecode(FCONST_2);\n+        bytecodesBufWriter.writeU1(FCONST_2);\n@@ -1081,1 +1240,1 @@\n-        writeBytecode(FDIV);\n+        bytecodesBufWriter.writeU1(FDIV);\n@@ -1087,1 +1246,5 @@\n-        writeLocalVar(BytecodeHelpers.fload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(FLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(FLOAD, slot);\n+        }\n@@ -1093,1 +1256,1 @@\n-        writeBytecode(FMUL);\n+        bytecodesBufWriter.writeU1(FMUL);\n@@ -1099,1 +1262,1 @@\n-        writeBytecode(FNEG);\n+        bytecodesBufWriter.writeU1(FNEG);\n@@ -1105,1 +1268,7 @@\n-        writeBytecode(FREM);\n+        bytecodesBufWriter.writeU1(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder freturn() {\n+        bytecodesBufWriter.writeU1(FRETURN);\n@@ -1111,1 +1280,5 @@\n-        writeLocalVar(BytecodeHelpers.fstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(FSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(FSTORE, slot);\n+        }\n@@ -1117,1 +1290,13 @@\n-        writeBytecode(FSUB);\n+        bytecodesBufWriter.writeU1(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder getstatic(ClassDesc owner, String name, ClassDesc type) {\n+        bytecodesBufWriter.writeIndex(GETSTATIC, constantPool().fieldRefEntry(owner, name, type));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder goto_(Label target) {\n+        writeShortJump(GOTO, target);\n@@ -1123,1 +1308,1 @@\n-        writeBytecode(I2B);\n+        bytecodesBufWriter.writeU1(I2B);\n@@ -1129,1 +1314,1 @@\n-        writeBytecode(I2C);\n+        bytecodesBufWriter.writeU1(I2C);\n@@ -1135,1 +1320,1 @@\n-        writeBytecode(I2D);\n+        bytecodesBufWriter.writeU1(I2D);\n@@ -1141,1 +1326,1 @@\n-        writeBytecode(I2F);\n+        bytecodesBufWriter.writeU1(I2F);\n@@ -1147,1 +1332,1 @@\n-        writeBytecode(I2L);\n+        bytecodesBufWriter.writeU1(I2L);\n@@ -1153,1 +1338,1 @@\n-        writeBytecode(I2S);\n+        bytecodesBufWriter.writeU1(I2S);\n@@ -1159,1 +1344,1 @@\n-        writeBytecode(IADD);\n+        bytecodesBufWriter.writeU1(IADD);\n@@ -1165,1 +1350,1 @@\n-        writeBytecode(IAND);\n+        bytecodesBufWriter.writeU1(IAND);\n@@ -1171,1 +1356,1 @@\n-        writeBytecode(ICONST_0);\n+        bytecodesBufWriter.writeU1(ICONST_0);\n@@ -1177,1 +1362,1 @@\n-        writeBytecode(ICONST_1);\n+        bytecodesBufWriter.writeU1(ICONST_1);\n@@ -1183,1 +1368,1 @@\n-        writeBytecode(ICONST_2);\n+        bytecodesBufWriter.writeU1(ICONST_2);\n@@ -1189,1 +1374,1 @@\n-        writeBytecode(ICONST_3);\n+        bytecodesBufWriter.writeU1(ICONST_3);\n@@ -1195,1 +1380,1 @@\n-        writeBytecode(ICONST_4);\n+        bytecodesBufWriter.writeU1(ICONST_4);\n@@ -1201,1 +1386,1 @@\n-        writeBytecode(ICONST_5);\n+        bytecodesBufWriter.writeU1(ICONST_5);\n@@ -1207,1 +1392,1 @@\n-        writeBytecode(ICONST_M1);\n+        bytecodesBufWriter.writeU1(ICONST_M1);\n@@ -1213,1 +1398,97 @@\n-        writeBytecode(IDIV);\n+        bytecodesBufWriter.writeU1(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_acmpeq(Label target) {\n+        writeShortJump(IF_ACMPEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_acmpne(Label target) {\n+        writeShortJump(IF_ACMPNE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpeq(Label target) {\n+        writeShortJump(IF_ICMPEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpge(Label target) {\n+        writeShortJump(IF_ICMPGE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpgt(Label target) {\n+        writeShortJump(IF_ICMPGT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmple(Label target) {\n+        writeShortJump(IF_ICMPLE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmplt(Label target) {\n+        writeShortJump(IF_ICMPLT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder if_icmpne(Label target) {\n+        writeShortJump(IF_ICMPNE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifnonnull(Label target) {\n+        writeShortJump(IFNONNULL, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifnull(Label target) {\n+        writeShortJump(IFNULL, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifeq(Label target) {\n+        writeShortJump(IFEQ, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifge(Label target) {\n+        writeShortJump(IFGE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifgt(Label target) {\n+        writeShortJump(IFGT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifle(Label target) {\n+        writeShortJump(IFLE, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iflt(Label target) {\n+        writeShortJump(IFLT, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ifne(Label target) {\n+        writeShortJump(IFNE, target);\n@@ -1225,1 +1506,5 @@\n-        writeLocalVar(BytecodeHelpers.iload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ILOAD_0 + slot);\n+        } else {\n+            writeLocalVar(ILOAD, slot);\n+        }\n@@ -1231,1 +1516,1 @@\n-        writeBytecode(IMUL);\n+        bytecodesBufWriter.writeU1(IMUL);\n@@ -1237,1 +1522,1 @@\n-        writeBytecode(INEG);\n+        bytecodesBufWriter.writeU1(INEG);\n@@ -1243,1 +1528,1 @@\n-        writeTypeCheck(INSTANCEOF, target);\n+        bytecodesBufWriter.writeIndex(INSTANCEOF, target);\n@@ -1255,1 +1540,1 @@\n-        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        writeInvokeInterface(Opcode.INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n@@ -1261,1 +1546,1 @@\n-        writeInvokeNormal(INVOKESPECIAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, ref);\n@@ -1267,1 +1552,1 @@\n-        writeInvokeNormal(INVOKESPECIAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESPECIAL, ref);\n@@ -1273,1 +1558,1 @@\n-        writeInvokeNormal(INVOKESTATIC, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, ref);\n@@ -1279,1 +1564,1 @@\n-        writeInvokeNormal(INVOKESTATIC, ref);\n+        bytecodesBufWriter.writeIndex(INVOKESTATIC, ref);\n@@ -1285,1 +1570,1 @@\n-        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        bytecodesBufWriter.writeIndex(INVOKEVIRTUAL, ref);\n@@ -1291,1 +1576,1 @@\n-        writeBytecode(IOR);\n+        bytecodesBufWriter.writeU1(IOR);\n@@ -1297,1 +1582,7 @@\n-        writeBytecode(IREM);\n+        bytecodesBufWriter.writeU1(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ireturn() {\n+        bytecodesBufWriter.writeU1(IRETURN);\n@@ -1303,1 +1594,1 @@\n-        writeBytecode(ISHL);\n+        bytecodesBufWriter.writeU1(ISHL);\n@@ -1309,1 +1600,1 @@\n-        writeBytecode(ISHR);\n+        bytecodesBufWriter.writeU1(ISHR);\n@@ -1315,1 +1606,5 @@\n-        writeLocalVar(BytecodeHelpers.istore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(ISTORE_0 + slot);\n+        } else {\n+            writeLocalVar(ISTORE, slot);\n+        }\n@@ -1321,1 +1616,1 @@\n-        writeBytecode(ISUB);\n+        bytecodesBufWriter.writeU1(ISUB);\n@@ -1327,1 +1622,1 @@\n-        writeBytecode(IUSHR);\n+        bytecodesBufWriter.writeU1(IUSHR);\n@@ -1333,1 +1628,1 @@\n-        writeBytecode(IXOR);\n+        bytecodesBufWriter.writeU1(IXOR);\n@@ -1345,1 +1640,1 @@\n-        writeBytecode(L2D);\n+        bytecodesBufWriter.writeU1(L2D);\n@@ -1351,1 +1646,1 @@\n-        writeBytecode(L2F);\n+        bytecodesBufWriter.writeU1(L2F);\n@@ -1357,1 +1652,1 @@\n-        writeBytecode(L2I);\n+        bytecodesBufWriter.writeU1(L2I);\n@@ -1363,1 +1658,1 @@\n-        writeBytecode(LADD);\n+        bytecodesBufWriter.writeU1(LADD);\n@@ -1369,1 +1664,1 @@\n-        writeBytecode(LAND);\n+        bytecodesBufWriter.writeU1(LAND);\n@@ -1375,1 +1670,1 @@\n-        writeBytecode(LCMP);\n+        bytecodesBufWriter.writeU1(LCMP);\n@@ -1381,1 +1676,1 @@\n-        writeBytecode(LCONST_0);\n+        bytecodesBufWriter.writeU1(LCONST_0);\n@@ -1387,1 +1682,1 @@\n-        writeBytecode(LCONST_1);\n+        bytecodesBufWriter.writeU1(LCONST_1);\n@@ -1399,1 +1694,1 @@\n-        writeBytecode(LDIV);\n+        bytecodesBufWriter.writeU1(LDIV);\n@@ -1405,1 +1700,5 @@\n-        writeLocalVar(BytecodeHelpers.lload(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(LLOAD_0 + slot);\n+        } else {\n+            writeLocalVar(LLOAD, slot);\n+        }\n@@ -1411,1 +1710,1 @@\n-        writeBytecode(LMUL);\n+        bytecodesBufWriter.writeU1(LMUL);\n@@ -1417,1 +1716,1 @@\n-        writeBytecode(LNEG);\n+        bytecodesBufWriter.writeU1(LNEG);\n@@ -1423,1 +1722,1 @@\n-        writeBytecode(LOR);\n+        bytecodesBufWriter.writeU1(LOR);\n@@ -1429,1 +1728,7 @@\n-        writeBytecode(LREM);\n+        bytecodesBufWriter.writeU1(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lreturn() {\n+        bytecodesBufWriter.writeU1(LRETURN);\n@@ -1435,1 +1740,1 @@\n-        writeBytecode(LSHL);\n+        bytecodesBufWriter.writeU1(LSHL);\n@@ -1441,1 +1746,1 @@\n-        writeBytecode(LSHR);\n+        bytecodesBufWriter.writeU1(LSHR);\n@@ -1447,1 +1752,5 @@\n-        writeLocalVar(BytecodeHelpers.lstore(slot), slot);\n+        if (slot >= 0 && slot <= 3) {\n+            bytecodesBufWriter.writeU1(LSTORE_0 + slot);\n+        } else {\n+            writeLocalVar(LSTORE, slot);\n+        }\n@@ -1453,1 +1762,1 @@\n-        writeBytecode(LSUB);\n+        bytecodesBufWriter.writeU1(LSUB);\n@@ -1459,1 +1768,1 @@\n-        writeBytecode(LUSHR);\n+        bytecodesBufWriter.writeU1(LUSHR);\n@@ -1465,1 +1774,1 @@\n-        writeBytecode(LXOR);\n+        bytecodesBufWriter.writeU1(LXOR);\n@@ -1471,1 +1780,1 @@\n-        writeBytecode(MONITORENTER);\n+        bytecodesBufWriter.writeU1(MONITORENTER);\n@@ -1477,1 +1786,1 @@\n-        writeBytecode(MONITOREXIT);\n+        bytecodesBufWriter.writeU1(MONITOREXIT);\n@@ -1504,1 +1813,1 @@\n-        writeBytecode(POP);\n+        bytecodesBufWriter.writeU1(POP);\n@@ -1510,1 +1819,1 @@\n-        writeBytecode(POP2);\n+        bytecodesBufWriter.writeU1(POP2);\n@@ -1517,1 +1826,1 @@\n-        writeArgumentConstant(SIPUSH, s);\n+        bytecodesBufWriter.writeU1U2(SIPUSH, s);\n@@ -1523,1 +1832,1 @@\n-        writeBytecode(SWAP);\n+        bytecodesBufWriter.writeU1(SWAP);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":574,"deletions":265,"binary":false,"changes":839,"status":"modified"},{"patch":"@@ -151,3 +151,1 @@\n-        buf.writeU2(flags);\n-        buf.writeIndex(name);\n-        buf.writeIndex(desc);\n+        buf.writeU2U2U2(flags, buf.cpIndex(name), buf.cpIndex(desc));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+        var data = this.data;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/EntryMap.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Objects;\n-\n@@ -55,1 +53,1 @@\n-        this.labelContext = Objects.requireNonNull(labelContext);\n+        this.labelContext = labelContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Objects;\n@@ -90,1 +89,1 @@\n-            throw new ConstantPoolException(\"Bad CP index: \" + index);\n+            throw badCP(index);\n@@ -96,1 +95,1 @@\n-            throw new ConstantPoolException(\"Unusable CP index: \" + index);\n+            throw unusableCP(index);\n@@ -101,0 +100,8 @@\n+    private static ConstantPoolException badCP(int index) {\n+        return new ConstantPoolException(\"Bad CP index: \" + index);\n+    }\n+\n+    private static ConstantPoolException unusableCP(int index) {\n+        return new ConstantPoolException(\"Unusable CP index: \" + index);\n+    }\n+\n@@ -103,1 +110,0 @@\n-        Objects.requireNonNull(cls);\n@@ -168,0 +174,2 @@\n+        int parentSize = this.parentSize;\n+        var map = this.map;\n@@ -169,1 +177,1 @@\n-            map = new EntryMap(Math.max(size, 1024), .75f);\n+            this.map = map = new EntryMap(Math.max(size, 1024), .75f);\n@@ -206,0 +214,2 @@\n+        int bsmSize = this.bsmSize;\n+        var bsmMap = this.bsmMap;\n@@ -207,1 +217,1 @@\n-            bsmMap = new EntryMap(Math.max(bsmSize, 16), .75f);\n+            this.bsmMap = bsmMap = new EntryMap(Math.max(bsmSize, 16), .75f);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = new StackMapFrameInfo[0];\n+    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = {};\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    private static final Frame[] EMPTY_FRAME_ARRAY = new Frame[0];\n+    private static final Frame[] EMPTY_FRAME_ARRAY = {};\n@@ -1222,1 +1222,3 @@\n-        void writeTo(BufWriter out, Frame prevFrame, ConstantPoolBuilder cp) {\n+        void writeTo(BufWriterImpl out, Frame prevFrame, ConstantPoolBuilder cp) {\n+            int localsSize = this.localsSize;\n+            int stackSize = this.stackSize;\n@@ -1231,2 +1233,1 @@\n-                        out.writeU1(251 + diffLocalsSize);\n-                        out.writeU2(offsetDelta);\n+                        out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n@@ -1241,2 +1242,1 @@\n-                    out.writeU1(247);\n-                    out.writeU2(offsetDelta);\n+                    out.writeU1U2(247, offsetDelta);\n@@ -1248,2 +1248,1 @@\n-            out.writeU1(255);\n-            out.writeU2(offsetDelta);\n+            out.writeU1U2(255, offsetDelta);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    public static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n@@ -255,2 +255,1 @@\n-    static void writeList(BufWriterImpl buf, List<Writable> list) {\n-        int size = list.size();\n+    static void writeList(BufWriterImpl buf, Writable[] array, int size) {\n@@ -259,1 +258,1 @@\n-            list.get(i).writeTo(buf);\n+            array[i].writeTo(buf);\n@@ -404,0 +403,1 @@\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n@@ -414,1 +414,1 @@\n-        return digit == 0 ? 1 : powers[powersIndex(digit, index)];\n+        return digit == 0 ? 1 : powers[powersIndex(digit, index) & 0x3F]; \/\/ & 0x3F eliminates bound check\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,7 +290,24 @@\n-        int len = 2 + returnType.descriptorString().length();\n-        for (ClassDesc argType : argTypes) {\n-            len += argType.descriptorString().length();\n-        }\n-        StringBuilder sb = new StringBuilder(len).append('(');\n-        for (ClassDesc argType : argTypes) {\n-            sb.append(argType.descriptorString());\n+        return buildDescriptorString();\n+    }\n+\n+    private String buildDescriptorString() {\n+        var returnType = this.returnType;\n+        var returnTypeDesc = returnType.descriptorString();\n+        var argTypes = this.argTypes;\n+        String desc;\n+        if (argTypes.length == 0) {\n+            \/\/ getter\n+            desc = \"()\".concat(returnTypeDesc);\n+        } else if (argTypes.length == 1 && returnType == ConstantDescs.CD_void) {\n+            \/\/ setter\n+            desc = ConstantUtils.concat(\"(\", argTypes[0].descriptorString(), \")V\");\n+        } else {\n+            int len = 2 + returnTypeDesc.length();\n+            for (ClassDesc argType : argTypes) {\n+                len += argType.descriptorString().length();\n+            }\n+            StringBuilder sb = new StringBuilder(len).append('(');\n+            for (ClassDesc argType : argTypes) {\n+                sb.append(argType.descriptorString());\n+            }\n+            desc = sb.append(')').append(returnTypeDesc).toString();\n@@ -298,1 +315,0 @@\n-        desc = sb.append(')').append(returnType.descriptorString()).toString();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        int[] powers = new int[7 * UtilAccess.significantOctalDigits()];\n+        int[] powers = new int[64];\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,3 @@\n-                      .withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n-                                              .invoke(INVOKESPECIAL, CD_Object, INIT_NAME, MTD_void, false)\n-                                              .return_(VOID)\n+                      .withCode(codeb -> codeb.aload(0)\n+                                              .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                              .return_()\n@@ -183,48 +183,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public byte[] jdkTreePrimitive() {\n-\n-        byte[] bytes = ClassFile.of().build(CD_MyClass, cb -> {\n-            cb.withFlags(AccessFlag.PUBLIC);\n-            cb.withVersion(52, 0);\n-            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n-              .withMethod(INIT_NAME, MTD_void, 0,\n-                          mb -> mb.withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n-                                                          .invokespecial(CD_Object, INIT_NAME, MTD_void, false)\n-                                                          .return_()\n-                          )\n-              );\n-            for (int xi = 0; xi < 40; ++xi) {\n-                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MTD_void_StringArray,\n-                              ACC_PUBLIC | ACC_STATIC,\n-                              mb -> mb.withCode(c0 -> {\n-                                  java.lang.classfile.Label loopTop = c0.newLabel();\n-                                  java.lang.classfile.Label loopEnd = c0.newLabel();\n-                                  int vFac = 1;\n-                                  int vI = 2;\n-                                  c0.iconst_1()         \/\/ 0\n-                                    .istore(1)          \/\/ 1\n-                                    .iconst_1()         \/\/ 2\n-                                    .istore(2)          \/\/ 3\n-                                    .labelBinding(loopTop)\n-                                    .iload(2)           \/\/ 4\n-                                    .bipush(10)         \/\/ 5\n-                                    .if_icmpge(loopEnd) \/\/ 6\n-                                    .iload(1)           \/\/ 7\n-                                    .iload(2)           \/\/ 8\n-                                    .imul()             \/\/ 9\n-                                    .istore(1)          \/\/ 10\n-                                    .iinc(2, 1)         \/\/ 11\n-                                    .goto_(loopTop)     \/\/ 12\n-                                    .labelBinding(loopEnd)\n-                                    .getstatic(CD_System, \"out\", CD_PrintStream)  \/\/ 13\n-                                    .iload(1)\n-                                    .invokevirtual(CD_PrintStream, \"println\", MTD_void_int)  \/\/ 15\n-                                    .return_();\n-                        }));\n-            }\n-        });\n-        if (writeClassBc) writeClass(bytes, checkFileBc);\n-        return bytes;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":3,"deletions":51,"binary":false,"changes":54,"status":"modified"}]}