{"files":[{"patch":"@@ -0,0 +1,1472 @@\n+package com.sun.crypto.provider;\n+\n+import java.io.Serial;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import sun.security.provider.SHA3.SHAKE256;\n+import sun.security.provider.SHA3Parallel.Shake128Parallel;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\n+public final class ML_KEM {\n+\n+    private final int mlKem_size;\n+    private final int mlKem_k;\n+    private final int mlKem_eta1;\n+    private final int mlKem_eta2;\n+\n+    private final int mlKem_du;\n+    private final int mlKem_dv;\n+    public final int encapsulationSize;\n+    private ML_KEM_EncapsulationKey encapsulationKey = null;\n+    private ML_KEM_DecapsulationKey decapsulationKey = null;\n+    private SecureRandom secureRandom = null;\n+\n+    public static final int secretSize = 32;\n+\n+    private static final int mlKem_q = 3329;\n+    private static final int mlKem_n = 256;\n+\n+    \/\/ mlKemXofBlockLen + mlKemXofPad should be divisible by 192 as that is\n+    \/\/ the granularity of what the intrinsics for twelve2Sixteen() can deal with\n+    private static final int mlKemXofBlockLen = 168; \/\/ the block length for SHAKE128\n+    private static final int mlKemXofPad = 24;\n+    private static final int montRBits = 20;\n+    private static final int montQ = 3329;\n+    private static final int montRSquareModQ = 152;\n+    private static final int montQInvModR = 586497;\n+\n+    \/\/ toMont((mlKem_n \/ 2)^-1 mod mlKem_q) using R = 2^montRbits\n+    private static final int montDimHalfInverse = 1534;\n+    private static final int mlKemBarrettMultiplier = 20159;\n+    private static final int mlKemBarrettShift = 26;\n+    private static final int[] montZetasForNtt = new int[]{\n+            1188, 914, -969, 585, -551, 1263, -97, 593,\n+            -35, -1400, -417, -1253, 742, -281, 185, -819,\n+            -1226, 895, -530, 52, 25, 1000, 1249, -909,\n+            -373, -1604, -259, -1369, -82, 49, 1496, -406,\n+            445, 1155, -405, -714, 553, -1183, -1401, 1598,\n+            -128, 1538, -669, 744, 1382, -1313, 201, -332,\n+            -1440, -1007, -36, -1617, 567, -623, 1429, 290,\n+            -1269, -825, -1613, 510, -395, 845, -426, -1003,\n+            222, -1107, 172, -42, 620, 1497, -1649, 94,\n+            -595, -497, -431, -1327, -702, -1448, -184, -607,\n+            -868, -1430, 977, 884, 425, 355, 1259, 1192,\n+            317, -636, -1074, 30, -1394, 833, -1200, -244,\n+            907, -339, -227, 1178, -586, -137, -514, 534,\n+            1153, -486, -1386, -668, 191, 982, 88, 1014,\n+            -1177, -474, -612, -857, -348, -604, 990, 1601,\n+            -1599, -709, -789, -1317, -57, 1049, -584\n+    };\n+\n+    private static final short[] montZetasForVectorNttArr = new short[]{\n+            \/\/ level 0\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            -758, -758, -758, -758, -758, -758, -758, -758,\n+            \/\/ level 1\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -359, -359, -359, -359, -359, -359, -359, -359,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            -1517, -1517, -1517, -1517, -1517, -1517, -1517, -1517,\n+            \/\/ level 2\n+            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n+            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n+            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n+            1493, 1493, 1493, 1493, 1493, 1493, 1493, 1493,\n+            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n+            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n+            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n+            1422, 1422, 1422, 1422, 1422, 1422, 1422, 1422,\n+            287, 287, 287, 287, 287, 287, 287, 287,\n+            287, 287, 287, 287, 287, 287, 287, 287,\n+            287, 287, 287, 287, 287, 287, 287, 287,\n+            287, 287, 287, 287, 287, 287, 287, 287,\n+            202, 202, 202, 202, 202, 202, 202, 202,\n+            202, 202, 202, 202, 202, 202, 202, 202,\n+            202, 202, 202, 202, 202, 202, 202, 202,\n+            202, 202, 202, 202, 202, 202, 202, 202,\n+            \/\/ level 3\n+            -171, -171, -171, -171, -171, -171, -171, -171,\n+            -171, -171, -171, -171, -171, -171, -171, -171,\n+            622, 622, 622, 622, 622, 622, 622, 622,\n+            622, 622, 622, 622, 622, 622, 622, 622,\n+            1577, 1577, 1577, 1577, 1577, 1577, 1577, 1577,\n+            1577, 1577, 1577, 1577, 1577, 1577, 1577, 1577,\n+            182, 182, 182, 182, 182, 182, 182, 182,\n+            182, 182, 182, 182, 182, 182, 182, 182,\n+            962, 962, 962, 962, 962, 962, 962, 962,\n+            962, 962, 962, 962, 962, 962, 962, 962,\n+            -1202, -1202, -1202, -1202, -1202, -1202, -1202, -1202,\n+            -1202, -1202, -1202, -1202, -1202, -1202, -1202, -1202,\n+            -1474, -1474, -1474, -1474, -1474, -1474, -1474, -1474,\n+            -1474, -1474, -1474, -1474, -1474, -1474, -1474, -1474,\n+            1468, 1468, 1468, 1468, 1468, 1468, 1468, 1468,\n+            1468, 1468, 1468, 1468, 1468, 1468, 1468, 1468,\n+            \/\/ level 4\n+            573, 573, 573, 573, 573, 573, 573, 573,\n+            -1325, -1325, -1325, -1325, -1325, -1325, -1325, -1325,\n+            264, 264, 264, 264, 264, 264, 264, 264,\n+            383, 383, 383, 383, 383, 383, 383, 383,\n+            -829, -829, -829, -829, -829, -829, -829, -829,\n+            1458, 1458, 1458, 1458, 1458, 1458, 1458, 1458,\n+            -1602, -1602, -1602, -1602, -1602, -1602, -1602, -1602,\n+            -130, -130, -130, -130, -130, -130, -130, -130,\n+            -681, -681, -681, -681, -681, -681, -681, -681,\n+            1017, 1017, 1017, 1017, 1017, 1017, 1017, 1017,\n+            732, 732, 732, 732, 732, 732, 732, 732,\n+            608, 608, 608, 608, 608, 608, 608, 608,\n+            -1542, -1542, -1542, -1542, -1542, -1542, -1542, -1542,\n+            411, 411, 411, 411, 411, 411, 411, 411,\n+            -205, -205, -205, -205, -205, -205, -205, -205,\n+            -1571, -1571, -1571, -1571, -1571, -1571, -1571, -1571,\n+            \/\/ level 5\n+            1223, 1223, 1223, 1223, 652, 652, 652, 652,\n+            -552, -552, -552, -552, 1015, 1015, 1015, 1015,\n+            -1293, -1293, -1293, -1293, 1491, 1491, 1491, 1491,\n+            -282, -282, -282, -282, -1544, -1544, -1544, -1544,\n+            516, 516, 516, 516, -8, -8, -8, -8,\n+            -320, -320, -320, -320, -666, -666, -666, -666,\n+            1711, 1711, 1711, 1711, -1162, -1162, -1162, -1162,\n+            126, 126, 126, 126, 1469, 1469, 1469, 1469,\n+            -853, -853, -853, -853, -90, -90, -90, -90,\n+            -271, -271, -271, -271, 830, 830, 830, 830,\n+            107, 107, 107, 107, -1421, -1421, -1421, -1421,\n+            -247, -247, -247, -247, -951, -951, -951, -951,\n+            -398, -398, -398, -398, 961, 961, 961, 961,\n+            -1508, -1508, -1508, -1508, -725, -725, -725, -725,\n+            448, 448, 448, 448, -1065, -1065, -1065, -1065,\n+            677, 677, 677, 677, -1275, -1275, -1275, -1275,\n+            \/\/ level 6\n+            -1103, -1103, 430, 430, 555, 555, 843, 843,\n+            -1251, -1251, 871, 871, 1550, 1550, 105, 105,\n+            422, 422, 587, 587, 177, 177, -235, -235,\n+            -291, -291, -460, -460, 1574, 1574, 1653, 1653,\n+            -246, -246, 778, 778, 1159, 1159, -147, -147,\n+            -777, -777, 1483, 1483, -602, -602, 1119, 1119,\n+            -1590, -1590, 644, 644, -872, -872, 349, 349,\n+            418, 418, 329, 329, -156, -156, -75, -75,\n+            817, 817, 1097, 1097, 603, 603, 610, 610,\n+            1322, 1322, -1285, -1285, -1465, -1465, 384, 384,\n+            -1215, -1215, -136, -136, 1218, 1218, -1335, -1335,\n+            -874, -874, 220, 220, -1187, -1187, 1670, 1670,\n+            -1185, -1185, -1530, -1530, -1278, -1278, 794, 794,\n+            -1510, -1510, -854, -854, -870, -870, 478, 478,\n+            -108, -108, -308, -308, 996, 996, 991, 991,\n+            958, 958, -1460, -1460, 1522, 1522, 1628, 1628\n+    };\n+    private static final int[] montZetasForInverseNtt = new int[]{\n+            584, -1049, 57, 1317, 789, 709, 1599, -1601,\n+            -990, 604, 348, 857, 612, 474, 1177, -1014,\n+            -88, -982, -191, 668, 1386, 486, -1153, -534,\n+            514, 137, 586, -1178, 227, 339, -907, 244,\n+            1200, -833, 1394, -30, 1074, 636, -317, -1192,\n+            -1259, -355, -425, -884, -977, 1430, 868, 607,\n+            184, 1448, 702, 1327, 431, 497, 595, -94,\n+            1649, -1497, -620, 42, -172, 1107, -222, 1003,\n+            426, -845, 395, -510, 1613, 825, 1269, -290,\n+            -1429, 623, -567, 1617, 36, 1007, 1440, 332,\n+            -201, 1313, -1382, -744, 669, -1538, 128, -1598,\n+            1401, 1183, -553, 714, 405, -1155, -445, 406,\n+            -1496, -49, 82, 1369, 259, 1604, 373, 909,\n+            -1249, -1000, -25, -52, 530, -895, 1226, 819,\n+            -185, 281, -742, 1253, 417, 1400, 35, -593,\n+            97, -1263, 551, -585, 969, -914, -1188\n+    };\n+\n+    private static final short[] montZetasForVectorInverseNttArr = new short[]{\n+            \/\/ level 0\n+            -1628, -1628, -1522, -1522, 1460, 1460, -958, -958,\n+            -991, -991, -996, -996, 308, 308, 108, 108,\n+            -478, -478, 870, 870, 854, 854, 1510, 1510,\n+            -794, -794, 1278, 1278, 1530, 1530, 1185, 1185,\n+            1659, 1659, 1187, 1187, -220, -220, 874, 874,\n+            1335, 1335, -1218, -1218, 136, 136, 1215, 1215,\n+            -384, -384, 1465, 1465, 1285, 1285, -1322, -1322,\n+            -610, -610, -603, -603, -1097, -1097, -817, -817,\n+            75, 75, 156, 156, -329, -329, -418, -418,\n+            -349, -349, 872, 872, -644, -644, 1590, 1590,\n+            -1119, -1119, 602, 602, -1483, -1483, 777, 777,\n+            147, 147, -1159, -1159, -778, -778, 246, 246,\n+            -1653, -1653, -1574, -1574, 460, 460, 291, 291,\n+            235, 235, -177, -177, -587, -587, -422, -422,\n+            -105, -105, -1550, -1550, -871, -871, 1251, 1251,\n+            -843, -843, -555, -555, -430, -430, 1103, 1103,\n+            \/\/ level 1\n+            1275, 1275, 1275, 1275, -677, -677, -677, -677,\n+            1065, 1065, 1065, 1065, -448, -448, -448, -448,\n+            725, 725, 725, 725, 1508, 1508, 1508, 1508,\n+            -961, -961, -961, -961, 398, 398, 398, 398,\n+            951, 951, 951, 951, 247, 247, 247, 247,\n+            1421, 1421, 1421, 1421, -107, -107, -107, -107,\n+            -830, -830, -830, -830, 271, 271, 271, 271,\n+            90, 90, 90, 90, 853, 853, 853, 853,\n+            -1469, -1469, -1469, -1469, -126, -126, -126, -126,\n+            1162, 1162, 1162, 1162, 1618, 1618, 1618, 1618,\n+            666, 666, 666, 666, 320, 320, 320, 320,\n+            8, 8, 8, 8, -516, -516, -516, -516,\n+            1544, 1544, 1544, 1544, 282, 282, 282, 282,\n+            -1491, -1491, -1491, -1491, 1293, 1293, 1293, 1293,\n+            -1015, -1015, -1015, -1015, 552, 552, 552, 552,\n+            -652, -652, -652, -652, -1223, -1223, -1223, -1223,\n+            \/\/ level 2\n+            1571, 1571, 1571, 1571, 1571, 1571, 1571, 1571,\n+            205, 205, 205, 205, 205, 205, 205, 205,\n+            -411, -411, -411, -411, -411, -411, -411, -411,\n+            1542, 1542, 1542, 1542, 1542, 1542, 1542, 1542,\n+            -608, -608, -608, -608, -608, -608, -608, -608,\n+            -732, -732, -732, -732, -732, -732, -732, -732,\n+            -1017, -1017, -1017, -1017, -1017, -1017, -1017, -1017,\n+            681, 681, 681, 681, 681, 681, 681, 681,\n+            130, 130, 130, 130, 130, 130, 130, 130,\n+            1602, 1602, 1602, 1602, 1602, 1602, 1602, 1602,\n+            -1458, -1458, -1458, -1458, -1458, -1458, -1458, -1458,\n+            829, 829, 829, 829, 829, 829, 829, 829,\n+            -383, -383, -383, -383, -383, -383, -383, -383,\n+            -264, -264, -264, -264, -264, -264, -264, -264,\n+            1325, 1325, 1325, 1325, 1325, 1325, 1325, 1325,\n+            -573, -573, -573, -573, -573, -573, -573, -573,\n+            \/\/ level 3\n+            -1468, -1468, -1468, -1468, -1468, -1468, -1468, -1468,\n+            -1468, -1468, -1468, -1468, -1468, -1468, -1468, -1468,\n+            1474, 1474, 1474, 1474, 1474, 1474, 1474, 1474,\n+            1474, 1474, 1474, 1474, 1474, 1474, 1474, 1474,\n+            1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202,\n+            1202, 1202, 1202, 1202, 1202, 1202, 1202, 1202,\n+            -962, -962, -962, -962, -962, -962, -962, -962,\n+            -962, -962, -962, -962, -962, -962, -962, -962,\n+            -182, -182, -182, -182, -182, -182, -182, -182,\n+            -182, -182, -182, -182, -182, -182, -182, -182,\n+            -1577, -1577, -1577, -1577, -1577, -1577, -1577, -1577,\n+            -1577, -1577, -1577, -1577, -1577, -1577, -1577, -1577,\n+            -622, -622, -622, -622, -622, -622, -622, -622,\n+            -622, -622, -622, -622, -622, -622, -622, -622,\n+            171, 171, 171, 171, 171, 171, 171, 171,\n+            171, 171, 171, 171, 171, 171, 171, 171,\n+            \/\/ level 4\n+            -202, -202, -202, -202, -202, -202, -202, -202,\n+            -202, -202, -202, -202, -202, -202, -202, -202,\n+            -202, -202, -202, -202, -202, -202, -202, -202,\n+            -202, -202, -202, -202, -202, -202, -202, -202,\n+            -287, -287, -287, -287, -287, -287, -287, -287,\n+            -287, -287, -287, -287, -287, -287, -287, -287,\n+            -287, -287, -287, -287, -287, -287, -287, -287,\n+            -287, -287, -287, -287, -287, -287, -287, -287,\n+            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n+            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n+            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n+            -1422, -1422, -1422, -1422, -1422, -1422, -1422, -1422,\n+            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n+            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n+            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n+            -1493, -1493, -1493, -1493, -1493, -1493, -1493, -1493,\n+            \/\/ level 5\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            1517, 1517, 1517, 1517, 1517, 1517, 1517, 1517,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            359, 359, 359, 359, 359, 359, 359, 359,\n+            \/\/ level 6\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758,\n+            758, 758, 758, 758, 758, 758, 758, 758\n+    };\n+\n+    private static final int[] montZetasForNttMult = new int[]{\n+            -1003, 1003, 222, -222, -1107, 1107, 172, -172,\n+            -42, 42, 620, -620, 1497, -1497, -1649, 1649,\n+            94, -94, -595, 595, -497, 497, -431, 431,\n+            -1327, 1327, -702, 702, -1448, 1448, -184, 184,\n+            -607, 607, -868, 868, -1430, 1430, 977, -977,\n+            884, -884, 425, -425, 355, -355, 1259, -1259,\n+            1192, -1192, 317, -317, -636, 636, -1074, 1074,\n+            30, -30, -1394, 1394, 833, -833, -1200, 1200,\n+            -244, 244, 907, -907, -339, 339, -227, 227,\n+            1178, -1178, -586, 586, -137, 137, -514, 514,\n+            534, -534, 1153, -1153, -486, 486, -1386, 1386,\n+            -668, 668, 191, -191, 982, -982, 88, -88,\n+            1014, -1014, -1177, 1177, -474, 474, -612, 612,\n+            -857, 857, -348, 348, -604, 604, 990, -990,\n+            1601, -1601, -1599, 1599, -709, 709, -789, 789,\n+            -1317, 1317, -57, 57, 1049, -1049, -584, 584\n+    };\n+\n+    private static final short[] montZetasForVectorNttMultArr = new short[]{\n+            -1103, 1103, 430, -430, 555, -555, 843, -843,\n+            -1251, 1251, 871, -871, 1550, -1550, 105, -105,\n+            422, -422, 587, -587, 177, -177, -235, 235,\n+            -291, 291, -460, 460, 1574, -1574, 1653, -1653,\n+            -246, 246, 778, -778, 1159, -1159, -147, 147,\n+            -777, 777, 1483, -1483, -602, 602, 1119, -1119,\n+            -1590, 1590, 644, -644, -872, 872, 349, -349,\n+            418, -418, 329, -329, -156, 156, -75, 75,\n+            817, -817, 1097, -1097, 603, -603, 610, -610,\n+            1322, -1322, -1285, 1285, -1465, 1465, 384, -384,\n+            -1215, 1215, -136, 136, 1218, -1218, -1335, 1335,\n+            -874, 874, 220, -220, -1187, 1187, 1670, 1659,\n+            -1185, 1185, -1530, 1530, -1278, 1278, 794, -794,\n+            -1510, 1510, -854, 854, -870, 870, 478, -478,\n+            -108, 108, -308, 308, 996, -996, 991, -991,\n+            958, -958, -1460, 1460, 1522, -1522, 1628, -1628\n+    };\n+\n+    public ML_KEM(int size) {\n+        switch (size) {\n+            case 512 -> {\n+                mlKem_k = 2;\n+                mlKem_eta1 = 3;\n+                mlKem_eta2 = 2;\n+                mlKem_du = 10;\n+                mlKem_dv = 4;\n+            }\n+            case 768 -> {\n+                mlKem_k = 3;\n+                mlKem_eta1 = 2;\n+                mlKem_eta2 = 2;\n+                mlKem_du = 10;\n+                mlKem_dv = 4;\n+            }\n+            case 1024 -> {\n+                mlKem_k = 4;\n+                mlKem_eta1 = 2;\n+                mlKem_eta2 = 2;\n+                mlKem_du = 11;\n+                mlKem_dv = 5;\n+            }\n+            default -> throw new IllegalArgumentException(\n+                    \"Bad size for ML_KEM-\" + size);\n+        }\n+        mlKem_size = size;\n+        encapsulationSize = (mlKem_k * mlKem_du + mlKem_dv) * 32;\n+    }\n+\n+    \/*\n+    Classes for the internal K_PKE scheme\n+     *\/\n+    public record K_PKE_EncryptionKey(byte[] keyBytes) {\n+    }\n+\n+    public record K_PKE_DecryptionKey(byte[] keyBytes) {\n+        static K_PKE_DecryptionKey from(ML_KEM_DecapsulationKey key) {\n+            return new K_PKE_DecryptionKey(key.keyBytes);\n+        }\n+    }\n+\n+    public record K_PKE_KeyPair(\n+            K_PKE_DecryptionKey privateKey, K_PKE_EncryptionKey publicKey) {\n+    }\n+\n+    public record K_PKE_CipherText(byte[] encryptedBytes) {\n+    }\n+\n+    private boolean isValidCipherText(K_PKE_CipherText cipherText) {\n+        return (cipherText.encryptedBytes.length == encapsulationSize);\n+    }\n+\n+    \/*\n+    Classes for internal KEM scheme\n+     *\/\n+    public record ML_KEM_EncapsulationKey(byte[] keyBytes) {\n+    }\n+\n+    public record ML_KEM_DecapsulationKey(byte[] keyBytes) {\n+    }\n+\n+    public record ML_KEM_KeyPair(ML_KEM_EncapsulationKey encapsulationKey,\n+                                 ML_KEM_DecapsulationKey decapsulationKey) {\n+    }\n+\n+    public record ML_KEM_EncapsulateResult(\n+            K_PKE_CipherText cipherText, byte[] sharedSecret) {\n+    }\n+\n+    private boolean isValidEncapsulationKey(ML_KEM_EncapsulationKey key) {\n+        byte[] keyBytes = key.keyBytes;\n+        if (keyBytes.length != mlKem_k * 384 + 32) {\n+            return false;\n+        }\n+        int x, y, z, a, b;\n+        for (int i = 0; i < mlKem_k * 384; i += 3) {\n+            x = keyBytes[i] & 0xFF;\n+            y = keyBytes[i + 1] & 0xFF;\n+            z = keyBytes[i + 2] & 0xFF;\n+            a = x + ((y & 0xF) << 8);\n+            b = (y >> 4) + (z << 4);\n+            if ((a >= mlKem_q) || (b >= mlKem_q)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isValidDecapsulationKey(ML_KEM_DecapsulationKey key) {\n+        return (key.keyBytes.length == mlKem_k * 768 + 96);\n+    }\n+\n+    \/*\n+    Main internal algorithms from Section 6 of specification\n+     *\/\n+    public ML_KEM_KeyPair generateKemKeyPair(\n+        byte[] kem_d, byte[] kem_z)\n+        throws NoSuchAlgorithmException, DigestException {\n+        var mlKemH = MessageDigest.getInstance(\"SHA3-256\");\n+\n+        \/\/Generate K-PKE keys\n+        var kPkeKeyPair = generateK_PkeKeyPair(kem_d);\n+        byte[] encapsKey = kPkeKeyPair.publicKey.keyBytes; \/\/encaps key = kPke encryption key\n+\n+        \/\/Derive decapsulation key = kPkePrivatKey || encapsKey || H(encapsKey) || kem_Z\n+        byte[] kPkePrivateKey = kPkeKeyPair.privateKey.keyBytes;\n+        byte[] decapsKey = new byte[encapsKey.length + kPkePrivateKey.length + 64];\n+        System.arraycopy(kPkePrivateKey, 0, decapsKey, 0, kPkePrivateKey.length);\n+        System.arraycopy(encapsKey, 0, decapsKey, kPkePrivateKey.length, encapsKey.length);\n+\n+        mlKemH.update(encapsKey);\n+        mlKemH.digest(decapsKey, kPkePrivateKey.length + encapsKey.length, 32);\n+        System.arraycopy(kem_z, 0, decapsKey, kPkePrivateKey.length + encapsKey.length + 32, 32);\n+\n+        return new ML_KEM_KeyPair(\n+            new ML_KEM_EncapsulationKey(encapsKey),\n+            new ML_KEM_DecapsulationKey(decapsKey));\n+    }\n+\n+    public ML_KEM_EncapsulateResult encapsulate(\n+            ML_KEM_EncapsulationKey encapsulationKey, byte[] randomMessage)\n+            throws NoSuchAlgorithmException, InvalidKeyException {\n+        var mlKemH = MessageDigest.getInstance(\"SHA3-256\");\n+        var mlKemG = MessageDigest.getInstance(\"SHA3-512\");\n+\n+        if (!isValidEncapsulationKey(encapsulationKey)) {\n+            throw new InvalidKeyException(\"Invalid encapsulation key\");\n+        }\n+        mlKemH.update(encapsulationKey.keyBytes);\n+        mlKemG.update(randomMessage);\n+        mlKemG.update(mlKemH.digest());\n+        var kHatAndRandomCoins = mlKemG.digest();\n+        var randomCoins = Arrays.copyOfRange(kHatAndRandomCoins, 32, 64);\n+        var cipherText = kPkeEncrypt(new K_PKE_EncryptionKey(encapsulationKey.keyBytes),\n+            randomMessage, randomCoins);\n+        Arrays.fill(randomMessage, (byte) 0);\n+        Arrays.fill(randomCoins, (byte) 0);\n+        byte[] sharedSecret = Arrays.copyOfRange(kHatAndRandomCoins, 0, 32);\n+        Arrays.fill(kHatAndRandomCoins, (byte) 0);\n+\n+        return new ML_KEM_EncapsulateResult(cipherText, sharedSecret);\n+    }\n+\n+    public byte[] decapsulate(ML_KEM_DecapsulationKey decapsulationKey,\n+                              K_PKE_CipherText cipherText)\n+            throws NoSuchAlgorithmException,\n+            InvalidKeyException, DecapsulateException {\n+\n+        \/\/Check input validity\n+        if (!isValidDecapsulationKey(decapsulationKey)) {\n+            throw new InvalidKeyException(\"Invalid decapsulation key\");\n+        }\n+        if (!isValidCipherText(cipherText)) {\n+            throw new DecapsulateException(\"Invalid ciphertext\");\n+        }\n+\n+        int encode12PolyLen = 12 * mlKem_n \/ 8;\n+        var decapsKeyBytes = decapsulationKey.keyBytes;\n+        var mlKemG = MessageDigest.getInstance(\"SHA3-512\");\n+        var mlKemJ = new SHAKE256(32);\n+\n+        byte[] kPkePrivateKeyBytes = new byte[mlKem_k * encode12PolyLen];\n+        System.arraycopy(decapsKeyBytes, 0, kPkePrivateKeyBytes, 0, kPkePrivateKeyBytes.length);\n+        byte[] encapsKeyBytes = new byte[mlKem_k * encode12PolyLen + 32];\n+        System.arraycopy(decapsKeyBytes, mlKem_k * encode12PolyLen,\n+                encapsKeyBytes, 0, encapsKeyBytes.length);\n+        var mCandidate = kPkeDecrypt(\n+                new K_PKE_DecryptionKey(kPkePrivateKeyBytes), cipherText);\n+        mlKemG.update(mCandidate);\n+        mlKemG.update(decapsKeyBytes, decapsKeyBytes.length - 64, 32);\n+        var kAndCoins = mlKemG.digest();\n+        var realResult = Arrays.copyOfRange(kAndCoins, 0, 32);\n+        var coins = Arrays.copyOfRange(kAndCoins, 32, 64);\n+        mlKemJ.update(decapsKeyBytes, decapsKeyBytes.length - 32, 32);\n+        mlKemJ.update(cipherText.encryptedBytes);\n+        var fakeResult = mlKemJ.digest();\n+        var computedCipherText = kPkeEncrypt(\n+                new K_PKE_EncryptionKey(encapsKeyBytes), mCandidate, coins);\n+\n+        \/\/ The rest of this method implements the following in constant time\n+        \/\/\n+        \/\/        if (Arrays.equals(cipherText.encryptedBytes,\n+        \/\/                computedCipherText.encryptedBytes)) {\n+        \/\/            return realResult;\n+        \/\/        } else {\n+        \/\/            return fakeResult;\n+        \/\/        }\n+\n+        int mask = 0;\n+        byte[] origCiphertestBytes = cipherText.encryptedBytes;\n+        byte[] compCipherTextBytes = computedCipherText.encryptedBytes;\n+        for (int i = 0; i < cipherText.encryptedBytes.length; i++) {\n+            mask |= (origCiphertestBytes[i] ^ compCipherTextBytes[i]);\n+        }\n+        mask = - (mask & 0xff); \/\/ sets mask to negative or 0\n+        mask >>= 31; \/\/ sets mask to all 1-bits or all 0-bits\n+        int notMask = ~mask;\n+\n+        byte[] result = realResult;\n+        for (int i = 0; i < realResult.length; i ++) {\n+            result[i] = (byte)((notMask & realResult[i]) | (mask & fakeResult[i]));\n+        }\n+\n+        return result;\n+    }\n+\n+    \/*\n+    K-PKE subroutines defined in Section 5 of spec\n+     *\/\n+    private K_PKE_KeyPair generateK_PkeKeyPair(byte[] seed)\n+            throws NoSuchAlgorithmException {\n+        var mlKemG = MessageDigest.getInstance(\"SHA3-512\");\n+        var mlKemJ = new SHAKE256(64 * mlKem_eta1);\n+\n+        mlKemG.update(seed);\n+        mlKemG.update((byte)mlKem_k);\n+\n+        var rhoSigma = mlKemG.digest();\n+        var rho = Arrays.copyOfRange(rhoSigma, 0, 32);\n+        var sigma = Arrays.copyOfRange(rhoSigma, 32, 64);\n+\n+        var keyGenA = generateA(rho, false);\n+\n+        int keyGenN = 0;\n+        byte[] prfSeed = new byte[sigma.length + 1];\n+        System.arraycopy(sigma, 0, prfSeed, 0, sigma.length);\n+        byte[] cbdInput;\n+        short[][] keyGenS = new short[mlKem_k][];\n+        short[][] keyGenE = new short[mlKem_k][];\n+        for (int i = 0; i < mlKem_k; i++) {\n+            prfSeed[sigma.length] = (byte) (keyGenN++);\n+            mlKemJ.update(prfSeed);\n+            cbdInput = mlKemJ.digest();\n+            keyGenS[i] = centeredBinomialDistribution(mlKem_eta1, cbdInput);\n+        }\n+        for (int i = 0; i < mlKem_k; i++) {\n+            prfSeed[sigma.length] = (byte) (keyGenN++);\n+            mlKemJ.update(prfSeed);\n+            cbdInput = mlKemJ.digest();\n+            keyGenE[i] = centeredBinomialDistribution(mlKem_eta1, cbdInput);\n+        }\n+\n+        short[][] keyGenSHat = mlKemVectorNTT(keyGenS);\n+        keyGenSHat = mlKemVectorReduce(keyGenSHat);\n+        short[][] keyGenEHat = mlKemVectorNTT(keyGenE);\n+\n+        short[][] keyGenTHat =\n+                mlKemMatrixVectorMuladd(keyGenA, keyGenSHat, keyGenEHat);\n+\n+        byte[] pkEncoded = new byte[(mlKem_k * mlKem_n * 12) \/ 8 + rho.length];\n+        byte[] skEncoded = new byte[(mlKem_k * mlKem_n * 12) \/ 8];\n+        byte[] encodedPoly;\n+        for (int i = 0; i < mlKem_k; i++) {\n+            encodedPoly = encodePoly(12, keyGenTHat[i]);\n+            System.arraycopy(encodedPoly, 0,\n+                    pkEncoded, i * ((mlKem_n * 12) \/ 8), (mlKem_n * 12) \/ 8);\n+            encodedPoly = encodePoly(12, keyGenSHat[i]);\n+            System.arraycopy(encodedPoly, 0,\n+                    skEncoded, i * ((mlKem_n * 12) \/ 8), (mlKem_n * 12) \/ 8);\n+        }\n+        System.arraycopy(rho, 0,\n+                pkEncoded, (mlKem_k * mlKem_n * 12) \/ 8, rho.length);\n+\n+        var kPkekp = new K_PKE_KeyPair(\n+                new K_PKE_DecryptionKey(skEncoded),\n+                new K_PKE_EncryptionKey(pkEncoded));\n+\n+        return kPkekp;\n+    }\n+\n+    private K_PKE_CipherText kPkeEncrypt(\n+            K_PKE_EncryptionKey publicKey, byte[] message, byte[] sigma) {\n+        short[][] zeroes = new short[mlKem_k][mlKem_n];\n+        byte[] pkBytes = publicKey.keyBytes;\n+        byte[] rho = Arrays.copyOfRange(pkBytes,\n+                pkBytes.length - 32, pkBytes.length);\n+        byte[] tHatBytes = Arrays.copyOfRange(pkBytes,\n+                0, pkBytes.length - 32);\n+        var encryptTHat = decodeVector(12, tHatBytes);\n+        var encryptA = generateA(rho, true);\n+        short[][] encryptR = new short[mlKem_k][];\n+        short[][] encryptE1 = new short[mlKem_k][];\n+        int encryptN = 0;\n+        byte[] prfSeed = new byte[sigma.length + 1];\n+        System.arraycopy(sigma, 0, prfSeed, 0, sigma.length);\n+\n+        var kPkePRFeta1 = new SHAKE256(64 * mlKem_eta1);\n+        var kPkePRFeta2 = new SHAKE256(64 * mlKem_eta2);\n+        for (int i = 0; i < mlKem_k; i++) {\n+            prfSeed[sigma.length] = (byte) (encryptN++);\n+            kPkePRFeta1.update(prfSeed);\n+            byte[] cbdInput = kPkePRFeta1.digest();\n+            encryptR[i] = centeredBinomialDistribution(mlKem_eta1, cbdInput);\n+        }\n+        for (int i = 0; i < mlKem_k; i++) {\n+            prfSeed[sigma.length] = (byte) (encryptN++);\n+            kPkePRFeta2.update(prfSeed);\n+            byte[] cbdInput = kPkePRFeta2.digest();\n+            encryptE1[i] = centeredBinomialDistribution(mlKem_eta2, cbdInput);\n+        }\n+        prfSeed[sigma.length] = (byte) encryptN;\n+        kPkePRFeta2.reset();\n+        kPkePRFeta2.update(prfSeed);\n+        byte[] cbdInput = kPkePRFeta2.digest();\n+        var encryptE2 = centeredBinomialDistribution(mlKem_eta2, cbdInput);\n+\n+        var encryptRHat = mlKemVectorNTT(encryptR);\n+        var encryptUHat = mlKemMatrixVectorMuladd(encryptA, encryptRHat, zeroes);\n+        var encryptU = mlKemVectorInverseNTT(encryptUHat);\n+        encryptU = mlKemAddVec(encryptU, encryptE1);\n+        var encryptVHat = mlKemVectorScalarMult(encryptTHat, encryptRHat);\n+        var encryptV = mlKemInverseNTT(encryptVHat);\n+        encryptV = mlKemAddPoly(encryptV, encryptE2, decompressDecode1(message));\n+        var encryptC1 = encodeVector(mlKem_du, compressVector10_11(encryptU, mlKem_du));\n+        var encryptC2 = encodePoly(mlKem_dv, compressPoly4_5(encryptV, mlKem_dv));\n+\n+        byte[] result = new byte[encryptC1.length + encryptC2.length];\n+        System.arraycopy(encryptC1, 0,\n+                result, 0, encryptC1.length);\n+        System.arraycopy(encryptC2, 0,\n+                result, encryptC1.length, encryptC2.length);\n+\n+        return new K_PKE_CipherText(result);\n+    }\n+\n+    private byte[] kPkeDecrypt(K_PKE_DecryptionKey privateKey,\n+                               K_PKE_CipherText cipherText) {\n+        int uBytesLen = mlKem_k * mlKem_du * mlKem_n \/ 8;\n+        byte[] uBytes = Arrays.copyOfRange(cipherText.encryptedBytes,\n+                0, uBytesLen);\n+        byte[] vBytes = Arrays.copyOfRange(cipherText.encryptedBytes,\n+                uBytesLen, cipherText.encryptedBytes.length);\n+        var decryptU = decompressVector(decodeVector(mlKem_du, uBytes), mlKem_du);\n+        var decryptV = decompressPoly(\n+                decodePoly(mlKem_dv, vBytes, 0), mlKem_dv);\n+        var decryptSHat = decodeVector(12, privateKey.keyBytes);\n+        var decryptSU = mlKemInverseNTT(\n+                mlKemVectorScalarMult(decryptSHat, mlKemVectorNTT(decryptU)));\n+        decryptV = mlKemSubtractPoly(decryptV, decryptSU);\n+\n+        return encodeCompress1(decryptV);\n+    }\n+\n+    \/*\n+    Sampling algorithms from Section 4.2.2 of the spec\n+     *\/\n+\n+    \/\/Combination of SampleNTT and KeyGen\/Encrypt generation of A\n+    private short[][][] generateA(byte[] rho, Boolean transposed) {\n+        short[][][] a = new short[mlKem_k][mlKem_k][];\n+\n+        int nrPar = 2;\n+        int rhoLen = rho.length;\n+        byte[] seedBuf = new byte[mlKemXofBlockLen];\n+        System.arraycopy(rho, 0, seedBuf, 0, rho.length);\n+        seedBuf[rhoLen + 2] = 0x1F;\n+        seedBuf[mlKemXofBlockLen - 1] = (byte)0x80;\n+        byte[][] xofBufArr = new byte[nrPar][mlKemXofBlockLen + mlKemXofPad];\n+        int[] iIndex = new int[nrPar];\n+        int[] jIndex = new int[nrPar];\n+\n+        short[] parsedBuf = new short[(xofBufArr[0].length \/ 3) * 2];\n+\n+        int parInd = 0;\n+        boolean allDone;\n+        int[] ofs = new int[nrPar];\n+        Arrays.fill(ofs, 0);\n+        short[][] aij = new short[nrPar][];\n+        Shake128Parallel parXof = new Shake128Parallel(xofBufArr);;\n+\n+        for (int i = 0; i < mlKem_k; i++) {\n+            for (int j = 0; j < mlKem_k; j++) {\n+                xofBufArr[parInd] = seedBuf.clone();\n+                if (transposed) {\n+                    xofBufArr[parInd][rhoLen] = (byte) i;\n+                    xofBufArr[parInd][rhoLen + 1] = (byte) j;\n+                } else {\n+                    xofBufArr[parInd][rhoLen] = (byte) j;\n+                    xofBufArr[parInd][rhoLen + 1] = (byte) i;\n+                }\n+                iIndex[parInd] = i;\n+                jIndex[parInd] = j;\n+                ofs[parInd] = 0;\n+                aij[parInd] = new short[mlKem_n];\n+                parInd++;\n+\n+                if ((parInd == nrPar) ||\n+                        ((i == mlKem_k - 1) && (j == mlKem_k - 1))) {\n+                    parXof.reset(xofBufArr);\n+\n+                    allDone = false;\n+                    while (!allDone) {\n+                        allDone = true;\n+                        parXof.squeezeBlock();\n+                        for (int k = 0; k < parInd; k++) {\n+                            int parsedOfs = 0;\n+                            int tmp;\n+                            if (ofs[k] < mlKem_n) {\n+                                twelve2Sixteen(xofBufArr[k], 0,\n+                                        parsedBuf, (mlKemXofBlockLen \/ 3) * 2);\n+                            }\n+                            while ((ofs[k] < mlKem_n) &&\n+                                    (parsedOfs < (mlKemXofBlockLen \/ 3) * 2)) {\n+                                tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n+                                if (tmp < mlKem_q) {\n+                                    aij[k][ofs[k]] = (short) tmp;\n+                                    ofs[k]++;\n+                                }\n+                                tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n+                                if ((ofs[k] < mlKem_n) && (tmp < mlKem_q)) {\n+                                    aij[k][ofs[k]] = (short) tmp;\n+                                    ofs[k]++;\n+                                }\n+                            }\n+                            if (ofs[k] < mlKem_n) {\n+                                allDone = false;\n+                            }\n+                        }\n+                    }\n+\n+                    for (int k = 0; k < parInd; k ++) {\n+                        a[iIndex[k]][jIndex[k]] = aij[k];\n+                    }\n+                    parInd = 0;\n+                }\n+            }\n+        }\n+\n+        return a;\n+    }\n+\n+    private short[] centeredBinomialDistribution(int eta, byte[] input) {\n+        if (eta == 2) return centeredBinomialDistribution2(input);\n+        if (eta == 3) return centeredBinomialDistribution3(input);\n+        short[] result = new short[mlKem_n];\n+        int index = 0;\n+        int shift = 8;\n+        int currentByte = input[0];\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int a = 0;\n+            int b = 0;\n+            for (int j = 0; j < eta; j++) {\n+                if (shift == 8) {\n+                    currentByte = input[index++];\n+                    shift = 0;\n+                }\n+                a += (currentByte >> shift) & 1;\n+                shift++;\n+            }\n+            for (int j = 0; j < eta; j++) {\n+                if (shift == 8) {\n+                    currentByte = input[index++];\n+                    shift = 0;\n+                }\n+                b += (currentByte >> shift) & 1;\n+                shift++;\n+            }\n+            result[m] = (short) (a - b);\n+        }\n+        return result;\n+    }\n+\n+    private short[] centeredBinomialDistribution2(byte[] input) {\n+        short[] result = new short[mlKem_n];\n+        long bits = 0x0112f001f001eff0L;\n+        int j = 0;\n+\n+        for (int i = 0; i < input.length; i++) {\n+            int a = input[i];\n+            int shift1 = (a << 2) & 0x3c;\n+            int shift2 = (a >> 2) & 0x3c;\n+            result[j++] = (short) ((bits << shift1) >> 60);\n+            result[j++] = (short) ((bits << shift2) >> 60);\n+        }\n+\n+        return result;\n+    }\n+\n+    private short[] centeredBinomialDistribution3(byte[] input) {\n+        short[] result = new short[mlKem_n];\n+        int bits = 0x01121223;\n+        int j = 0;\n+\n+        for (int i = 0; i < input.length; i += 3) {\n+            int a1 = input[i];\n+            int a2 = input[i + 1];\n+            int a3 = input[i + 2];\n+            int shift1 = (a1 << 2) & 0x1c;\n+            int shift2 = (a1 >> 1) & 0x1c;\n+            int shift3 = ((a1 >> 4) & 0x0c) | ((a2 << 4) & 0x10);\n+            int shift4 = (a2 << 1) & 0x1c;\n+            int shift5 = (a2 >> 2) & 0x1c;\n+            int shift6 = ((a2 >> 5) & 0x04) | ((a3 << 3) & 0x18);\n+            int shift7 = a3 & 0x1c;\n+            int shift8 = (a3 >> 3) & 0x1c;\n+            result[j++] = (short)\n+                    (((bits << shift1) >> 28) - ((bits << shift2) >> 28));\n+            result[j++] = (short)\n+                    (((bits << shift3) >> 28) - ((bits << shift4) >> 28));\n+            result[j++] = (short)\n+                    (((bits << shift5) >> 28) - ((bits << shift6) >> 28));\n+            result[j++] = (short)\n+                    (((bits << shift7) >> 28) - ((bits << shift8) >> 28));\n+        }\n+\n+        return result;\n+    }\n+\n+    \/*\n+    NTT algorithms from Section 4.3 of the specification\n+     *\/\n+\n+    \/\/ Works in place, it returns its (modified) input so that it can be used in\n+    \/\/ expressions\n+    private short[][] mlKemVectorNTT(short[][] vector) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            mlKemNTT(vector[i]);\n+        }\n+        return vector;\n+    }\n+\n+    \/\/ Works in place, it returns its (modified) input so that it can be used in\n+    \/\/ expressions\n+    private short[][] mlKemVectorReduce(short[][] vector) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            mlKemBarrettReduce(vector[i]);\n+        }\n+        return vector;\n+    }\n+\n+    \/\/ Works in place, it returns its (modified) input so that it can be used in\n+    \/\/ expressions\n+    private short[][] mlKemVectorInverseNTT(short[][] vector) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            vector[i] = mlKemInverseNTT(vector[i]);\n+        }\n+        return vector;\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemNtt(short[] poly, short[] ntt_zetas) {\n+        implMlKemNttJava(poly);\n+        return 1;\n+    }\n+\n+    static void implMlKemNttJava(short[] poly) {\n+        int[] coeffs = new int[mlKem_n];\n+        for (int m = 0; m < mlKem_n; m++) {\n+            coeffs[m] = poly[m];\n+        }\n+        seilerNTT(coeffs);\n+        for (int m = 0; m < mlKem_n; m++) {\n+            poly[m] = (short) coeffs[m];\n+        }\n+    }\n+\n+    \/\/ The elements of poly should be in the range [-mlKem_q, mlKem_q]\n+    \/\/ The elements of poly at return will be in the range of [0, mlKem_q]\n+    private void mlKemNTT(short[] poly) {\n+        implMlKemNtt(poly, montZetasForVectorNttArr);\n+        mlKemBarrettReduce(poly);\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemInverseNtt(short[] poly, short[] zetas) {\n+        implMlKemInverseNttJava(poly);\n+        return 1;\n+    }\n+\n+    static void implMlKemInverseNttJava(short[] poly) {\n+        int[] coeffs = new int[mlKem_n];\n+        for (int m = 0; m < mlKem_n; m++) {\n+            coeffs[m] = poly[m];\n+        }\n+        seilerInverseNTT(coeffs);\n+        for (int m = 0; m < mlKem_n; m++) {\n+            poly[m] = (short) coeffs[m];\n+        }\n+    }\n+\n+    \/\/ Works in place, but also returns its (modified) input so that it can\n+    \/\/ be used in expressions\n+    private short[] mlKemInverseNTT(short[] poly) {\n+        implMlKemInverseNtt(poly, montZetasForVectorInverseNttArr);\n+        return poly;\n+    }\n+\n+    \/\/ Implements the ML_KEM NTT algorithm similarly to that described\n+    \/\/ in https:\/\/eprint.iacr.org\/2018\/039.pdf .\n+    \/\/ It works in place, replaces the elements of the input coeffs array\n+    \/\/ by the transformed representation.\n+    \/\/ The input elements should be in the range [-montQ, montQ].\n+    \/\/ The result elements will fit into the range of short\n+    \/\/ (i.e. [-32768, 32767]).\n+    private static void seilerNTT(int[] coeffs) {\n+        int dimension = mlKem_n;\n+        int zetaIndex = 0;\n+        for (int l = dimension \/ 2; l > 1; l \/= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = montMul(montZetasForNtt[zetaIndex], coeffs[j + l]);\n+                    coeffs[j + l] = coeffs[j] - tmp;\n+                    coeffs[j] = coeffs[j] + tmp;\n+                }\n+                zetaIndex++;\n+            }\n+        }\n+    }\n+\n+    \/\/ Implements the ML_KEM inverse NTT algorithm similarly to that described\n+    \/\/ in https:\/\/eprint.iacr.org\/2018\/039.pdf .\n+    \/\/ It works in place, replaces the elements of the input coeffs array\n+    \/\/ by the transformed representation.\n+    \/\/ The input elements should be in the range [-montQ, montQ).\n+    \/\/ The output elements will be in the range (-montQ, montQ).\n+    private static void seilerInverseNTT(int[] coeffs) {\n+        int dimension = mlKem_n;\n+        int zetaIndex = 0;\n+        for (int l = 2; l < dimension; l *= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = coeffs[j];\n+                    coeffs[j] = (tmp + coeffs[j + l]);\n+                    coeffs[j + l] = montMul(\n+                            tmp - coeffs[j + l],\n+                            montZetasForInverseNtt[zetaIndex]);\n+                }\n+                zetaIndex++;\n+            }\n+        }\n+\n+        for (int i = 0; i < dimension; i++) {\n+            int r = montMul(coeffs[i], montDimHalfInverse);\n+            coeffs[i] = r;\n+        }\n+    }\n+\n+    \/\/ Performs A o b + c where\n+    \/\/ A is a mlKem_k by mlKem_k matrix,\n+    \/\/ b and c are mlKem_k long vectors of degree mlKem_n - 1\n+    \/\/ polynomials in the NTT domain representation.\n+    \/\/ The coefficients in the result are in the range [0, mlKem_q).\n+    private short[][] mlKemMatrixVectorMuladd(\n+            short[][][] a, short[][] b, short[][] c) {\n+        short[] product = new short[mlKem_n];\n+\n+        for (int i = 0; i < mlKem_k; i++) {\n+            for (int j = 0; j < mlKem_k; j++) {\n+                nttMult(product, a[i][j], b[j]);\n+                mlKemAddPoly(c[i], product);\n+            }\n+            mlKemBarrettReduce(c[i]);\n+        }\n+        return c;\n+    }\n+\n+    \/\/ Performs a^T o b where a and b are mlKem_k long vectors\n+    \/\/ of degree mlKem_n - 1 polynomials in the NTT representation,\n+    \/\/ with coefficients in the range [-mlKem_q, mlKem_q].\n+    \/\/ The coefficients in the result are in the range [0, mlKem_q).\n+    private short[] mlKemVectorScalarMult(short[][] a, short[][] b) {\n+        short[] result = new short[mlKem_n];\n+        short[] product = new short[mlKem_n];\n+        short[] ntta;\n+        short[] nttb;\n+\n+        int j;\n+        for (j = 0; j < mlKem_k; j++) {\n+            ntta = a[j];\n+            nttb = b[j];\n+            nttMult(product, ntta, nttb);\n+            mlKemAddPoly(result, product);\n+        }\n+        mlKemBarrettReduce(result);\n+\n+        return result;\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemNttMult(short[] result, short[] ntta, short[] nttb,\n+                                short[] zetas) {\n+        implMlKemNttMultJava(result, ntta, nttb);\n+        return 1;\n+    }\n+\n+    static void implMlKemNttMultJava(short[] result, short[] ntta, short[] nttb) {\n+        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+            int a0 = ntta[2 * m];\n+            int a1 = ntta[2 * m + 1];\n+            int b0 = nttb[2 * m];\n+            int b1 = nttb[2 * m + 1];\n+            int r = montMul(a0, b0) +\n+                    montMul(montMul(a1, b1), montZetasForNttMult[m]);\n+            result[2 * m] = (short) montMul(r, montRSquareModQ);\n+            result[2 * m + 1] = (short) montMul(\n+                    (montMul(a0, b1) + montMul(a1, b0)), montRSquareModQ);\n+        }\n+    }\n+\n+    \/\/ Multiplies two polynomials represented in the NTT domain.\n+    \/\/ The result is a representation of the product still in the NTT domain.\n+    \/\/ The coefficients in the result are in the range (-mlKem_q, mlKem_q).\n+    private void nttMult(short[] result, short[] ntta, short[] nttb) {\n+        implMlKemNttMult(result, ntta, nttb, montZetasForVectorNttMultArr);\n+    }\n+\n+    \/\/ Adds the vector of polynomials b to a in place, i.e. a will hold\n+    \/\/ the result. It also returns (the modified) a so that it can be used\n+    \/\/ in an expression.\n+    \/\/ The coefficiens in all polynomials of both vectors are supposed to be\n+    \/\/ greater than -mlKem_q and less than mlKem_q.\n+    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    private short[][] mlKemAddVec(short[][] a, short[][] b) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            mlKemAddPoly(a[i], b[i]);\n+            mlKemBarrettReduce(a[i]);\n+        }\n+        return a;\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemAddPoly(short[] result, short[] a, short[] b) {\n+        implMlKemAddPolyJava(result, a, b);\n+        return 1;\n+    }\n+\n+    static void implMlKemAddPolyJava(short[] result, short[] a, short[] b) {\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int r = a[m] + b[m] + mlKem_q; \/\/ This makes r > -mlKem_q\n+            result[m] = (short) r;\n+        }\n+    }\n+\n+    \/\/ Adds the polynomial b to a in place, i.e. (the modified) a will hold\n+    \/\/ the result.\n+    \/\/ The coefficients are supposed be greater than -mlKem_q in a and\n+    \/\/ greater than -mlKem_q and less than mlKem_q in b.\n+    \/\/ The coefficients in the result are greater than -mlKem_q.\n+    private void mlKemAddPoly(short[] a, short[] b) {\n+        implMlKemAddPoly(a, a, b);\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemAddPoly(short[] result, short[] a, short[] b, short[] c) {\n+        implMlKemAddPolyJava(result, a, b, c);\n+        return 1;\n+    }\n+\n+    static void implMlKemAddPolyJava(short[] result, short[] a, short[] b, short[] c) {\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int r = a[m] + b[m] + c[m] + 2 * mlKem_q; \/\/ This makes r > - mlKem_q\n+            result[m] = (short) r;\n+        }\n+    }\n+\n+    \/\/ Adds the polynomials b and c to a in place, i.e. a will hold the sum.\n+    \/\/ a is also returned so that this function can be used in an expression.\n+    \/\/ The coefficients in all three polynomials are supposed to be\n+    \/\/ greater than -mlKem_q and less than mlKem_q.\n+    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    private short[] mlKemAddPoly(short[] a, short[] b, short[] c) {\n+        implMlKemAddPoly(a, a, b, c);\n+        mlKemBarrettReduce(a);\n+        return a;\n+    }\n+\n+    \/\/ Subtracts the polynomial b from a in place, i.e. the result is\n+    \/\/ stored in a. It also returns (the modified) a, so that it can be used\n+    \/\/ in an expression.\n+    \/\/ The coefficiens in both are assumed to be greater than -mlKem_q\n+    \/\/ and less than mlKem_q.\n+    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    private short[] mlKemSubtractPoly(short[] a, short[] b) {\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int r = a[m] - b[m] + mlKem_q; \/\/ This makes r > -mlKem_q\n+            a[m] = (short) r;\n+        }\n+        mlKemBarrettReduce(a);\n+        return a;\n+    }\n+\n+    private byte[] encodeVector(int l, short[][] vector) {\n+        return encodeVector(l, vector, mlKem_k);\n+    }\n+\n+    private static byte[] encodeVector(int l, short[][] vector, int k) {\n+        int encodedPolyLength = mlKem_n * l \/ 8;\n+        byte[] result = new byte[k * encodedPolyLength];\n+\n+        for (int i = 0; i < k; i++) {\n+            byte[] resultBytes = encodePoly(l, vector[i]);\n+            System.arraycopy(resultBytes, 0,\n+                    result, i * encodedPolyLength, encodedPolyLength);\n+        }\n+        return result;\n+    }\n+\n+    private static void encodePoly12(short[] poly, byte[] result) {\n+        int low;\n+        int high;\n+        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+            low = poly[2 * m];\n+            low += ((low >> 31) & mlKem_q);\n+            low = low & 0xfff;\n+            high = poly[2 * m + 1];\n+            high += ((high >> 31) & mlKem_q);\n+            high = high & 0xfff;\n+\n+            result[m * 3] = (byte) low;\n+            result[m * 3 + 1] = (byte) ((high << 4) + (low >> 8));\n+            result[m * 3 + 2] = (byte) (high >> 4);\n+        }\n+    }\n+\n+    private static void encodePoly4(short[] poly, byte[] result) {\n+        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+            result[m] = (byte) ((poly[2 * m] & 0xf) + (poly[2 * m + 1] << 4));\n+        }\n+    }\n+\n+    \/\/ Computes the byte array containing the packed l-bit representation\n+    \/\/ of a polynomial. The coefficients in poly should be either nonnegative\n+    \/\/ or elements of Z_(mlKem_q) represented by a 16-bit value\n+    \/\/ between -mlKem_q and mlKem_q.\n+    private static byte[] encodePoly(int l, short[] poly) {\n+        byte[] result = new byte[mlKem_n \/ 8 * l];\n+        if (l == 12) {\n+            encodePoly12(poly, result);\n+        } else if (l == 4) {\n+            encodePoly4(poly, result);\n+        } else {\n+            int mask = (1 << l) - 1;\n+            int shift = 0;\n+            int index = 0;\n+            int current = 0;\n+            for (int m = 0; m < mlKem_n; m++) {\n+                int currentShort = poly[m];\n+                currentShort += (currentShort >> 31) & mlKem_q;\n+                current += ((currentShort & mask) << shift);\n+                shift += l;\n+                while (shift >= 8) {\n+                    result[index++] = (byte) current;\n+                    current >>>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    static byte[] encodeCompress1(short[] poly) {\n+        byte[] result = new byte[mlKem_n \/ 8];\n+        int xx;\n+        int currentByte;\n+        for (int i = 0; i < mlKem_n \/ 8; i++) {\n+            currentByte = 0;\n+            xx = poly[i * 8];\n+            currentByte |= (((832 - xx) & (xx - 2497)) >>> 31);\n+            xx = poly[i * 8 + 1];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 30) & 2);\n+            xx = poly[i * 8 + 2];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 29) & 4);\n+            xx = poly[i * 8 + 3];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 28) & 8);\n+            xx = poly[i * 8 + 4];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 27) & 16);\n+            xx = poly[i * 8 + 5];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 26) & 32);\n+            xx = poly[i * 8 + 6];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 25) & 64);\n+            xx = poly[i * 8 + 7];\n+            currentByte |= ((((832 - xx) & (xx - 2497)) >>> 24) & 128);\n+            result[i] = (byte) currentByte;\n+        }\n+        return result;\n+    }\n+\n+    private short[][] decodeVector(int l, byte[] encodedVector) {\n+        short[][] result = new short[mlKem_k][];\n+        for (int i = 0; i < mlKem_k; i++) {\n+            result[i] = decodePoly(l, encodedVector, (i * mlKem_n * l) \/ 8);\n+        }\n+        return result;\n+    }\n+\n+    public static byte[] normalizeDecapsKeyBytes(byte[] decapsKeyBytes) {\n+        byte[] result = decapsKeyBytes.clone();\n+        int k = (decapsKeyBytes.length - 64) \/ ((mlKem_n * 3) \/ 2);\n+        short[][] vector = new short[k][];\n+        for (int i = 0; i < k; i++) {\n+            vector[i] = new short[mlKem_n];\n+            implMlKem12To16(decapsKeyBytes, i * ((mlKem_n * 3)\/ 2), vector[i], mlKem_n);\n+            implMlKemBarrettReduce(vector[i]);\n+        }\n+        var normalized = encodeVector(12, vector, k);\n+        System.arraycopy(normalized, 0, result, 0, normalized.length);\n+        return result;\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    private static int implMlKem12To16(byte[] condensed, int index, short[] parsed, int parsedLength) {\n+        implMlKem12To16Java(condensed, index, parsed, parsedLength);\n+        return 1;\n+    }\n+\n+    private static void implMlKem12To16Java(byte[] condensed, int index, short[] parsed, int parsedLength) {\n+        for (int i = 0; i < parsedLength * 3 \/ 2; i += 3) {\n+            parsed[(i \/ 3) * 2] = (short) ((condensed[i + index] & 0xff) +\n+                    256 * (condensed[i + index + 1] & 0xf));\n+            parsed[(i \/ 3) * 2 + 1] = (short) (((condensed[i + index + 1] >>> 4) & 0xf) +\n+                    16 * (condensed[i + index + 2] & 0xff));\n+        }\n+    }\n+\n+    \/\/ The intrinsic implementations assume that the input and output buffers\n+    \/\/ are such that condensed can be read in 192-byte chunks and\n+    \/\/ parsed can be written in 128 shorts chunks. In other words,\n+    \/\/ if (i - 1) * 128 < parsedLengths <= i * 128 then\n+    \/\/ parsed.size should be at least i * 128 and\n+    \/\/ condensed.size should be at least index + i * 192\n+    private void twelve2Sixteen(byte[] condensed, int index, short[] parsed, int parsedLength) {\n+        implMlKem12To16(condensed, index, parsed, parsedLength);\n+    }\n+\n+    private static void decodePoly5(byte[] condensed, int index, short[] parsed) {\n+        int j = index;\n+        for (int i = 0; i < mlKem_n; i += 8) {\n+            parsed[i] = (short) (condensed[j] & 0x1f);\n+            parsed[i + 1] = (short) ((((condensed[j] & 0xff) >>> 5) +\n+                    (condensed[j + 1] << 3) & 0x1f));\n+            parsed[i + 2] = (short) ((condensed[j + 1] & 0x7f) >>> 2);\n+            parsed[i + 3] = (short) ((((condensed[j + 1] & 0xff) >>> 7) +\n+                    (condensed[j + 2] << 1)) & 0x1f);\n+            parsed[i + 4] = (short) ((((condensed[j + 2] & 0xff) >>> 4) +\n+                    (condensed[j + 3] << 4)) & 0x1f);\n+            parsed[i + 5] = (short) ((condensed[j + 3] & 0x3f) >>> 1);\n+            parsed[i + 6] = (short) ((((condensed[j + 3] & 0xff) >>> 6) +\n+                    (condensed[j + 4] << 2)) & 0x1f);\n+            parsed[i + 7] = (short) ((condensed[j + 4] & 0xff) >>> 3);\n+            j += 5;\n+        }\n+    }\n+\n+    private static void decodePoly4(byte[] condensed, int index, short[] parsed) {\n+        for (int i = 0; i < mlKem_n \/ 2; i++) {\n+            parsed[i * 2] = (short) (condensed[i + index] & 0xf);\n+            parsed[i * 2 + 1] = (short) ((condensed[i + index] >>> 4) & 0xf);\n+        }\n+    }\n+\n+    \/\/ Recovers the 16-bit coefficients of a polynomial from a byte array\n+    \/\/ containing a packed l-bit representation.\n+    \/\/ The recovered coefficients will be in the range 0 <= coeff < 2^l .\n+    private short[] decodePoly(int l, byte[] input, int index) {\n+        short[] poly = new short[mlKem_n];\n+        short[] poly1 = new short[mlKem_n];\n+        if (l == 12) {\n+            twelve2Sixteen(input, index, poly, mlKem_n);\n+        } else if (l == 4) {\n+            decodePoly4(input, index, poly);\n+        } else if (l == 5) {\n+            decodePoly5(input, index, poly);\n+        } else {\n+            int mask = (1 << l) - 1;\n+            int top = 0;\n+            int shift = 0;\n+            int acc = 0;\n+            for (int m = 0; m < mlKem_n; m++) {\n+                while (top - shift < l) {\n+                    acc += ((input[index++] & 0xff) << top);\n+                    top += 8;\n+                }\n+                poly[m] = (short) ((acc >> shift) & mask);\n+                shift += l;\n+                while (shift >= 8) {\n+                    top -= 8;\n+                    shift -= 8;\n+                    acc >>>= 8;\n+                }\n+            }\n+        }\n+\n+        return poly;\n+    }\n+\n+    \/\/ Prerequisite: d == 10 or d == 11\n+    \/\/ Compresses a vector in place, i.e. it modifies the coefficients of the\n+    \/\/ polynomials of its input vector. It returns its (modified) input so that\n+    \/\/ the function can be used in an expression.\n+    private short[][] compressVector10_11(short[][] vector, int d) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            vector[i] = compressPoly10_11(vector[i], d);\n+        }\n+        return vector;\n+    }\n+\n+    \/\/ Prerequisite: for all m, 0 <= poly[m] < mlKem_q, d == 4 or d == 5\n+    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ mlKem_q) mod 2^d for all m,\n+    \/\/ where round(z) is the integer closest to z, i.e.\n+    \/\/ compresses a polynomial in place.\n+    private static short[] compressPoly4_5(short[] poly, int d) {\n+        int xx;\n+        for (int m = 0; m < mlKem_n; m++) {\n+            xx = (poly[m] << d) + mlKem_q \/ 2;\n+            poly[m] = (short)((xx * 315) >> 20);\n+        }\n+        return poly;\n+    }\n+\n+    \/\/ Prerequisite: for all m, 0 <= poly[m] < mlKem_q, d == 10 or d == 11\n+    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ mlKem_q) mod 2^d for all m,\n+    \/\/ where round(z) is the integer closest to z, i.e.\n+    \/\/ compresses a polynomial in place.\n+    private static short[] compressPoly10_11(short[] poly, int d) {\n+        long xx;\n+        for (int m = 0; m < mlKem_n; m++) {\n+            xx = (poly[m] << d) + mlKem_q \/ 2;\n+            poly[m] = (short)((xx * 161271L) >> 29);\n+        }\n+        return poly;\n+    }\n+\n+    \/\/ Decompresses a vector in place, i.e. it modifies the coefficients of the\n+    \/\/ polynomials of its input vector. It returns its (modified) input so that\n+    \/\/ the function can be used in an expression.\n+    private short[][] decompressVector(short[][] vector, int d) {\n+        for (int i = 0; i < mlKem_k; i++) {\n+            vector[i] = decompressPoly(vector[i], d);\n+        }\n+        return vector;\n+    }\n+\n+    \/\/ Decompresses a polynomial in place, i.e. it modifies the coefficients\n+    \/\/ in its input. It returns its (modified) input so that the function can\n+    \/\/ be used in an expression.\n+    \/\/ Prerequisite: 0 <= x[i] < 2^d < mlKem_q .\n+    \/\/ Computes Round(mlKem_q * x[i] \/ 2^d),\n+    \/\/ where Round(z) is the integer closest to z,\n+    \/\/ for each coefficient of a polynomial\n+    private static short[] decompressPoly(short[] poly, int d) {\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int qx = mlKem_q * poly[m];\n+            poly[m] = (short) ((qx >> d) + ((qx >> (d - 1)) & 1));\n+        }\n+        return poly;\n+    }\n+\n+    private static short[] decompressDecode1 (byte[] input) {\n+        short[] result = new short[256];\n+        for (int i = 0; i < 32; i++) {\n+            int currentByte = input[i] & 0xFF;\n+            result [i * 8] = (short)(((currentByte << 31 ) >> 31) & 1665);\n+            result [i * 8 + 1] = (short)(((currentByte << 30 ) >> 31) & 1665);\n+            result [i * 8 + 2] = (short)(((currentByte << 29 ) >> 31) & 1665);\n+            result [i * 8 + 3] = (short)(((currentByte << 28 ) >> 31) & 1665);\n+            result [i * 8 + 4] = (short)(((currentByte << 27 ) >> 31) & 1665);\n+            result [i * 8 + 5] = (short)(((currentByte << 26 ) >> 31) & 1665);\n+            result [i * 8 + 6] = (short)(((currentByte << 25 ) >> 31) & 1665);\n+            result [i * 8 + 7] = (short)(((currentByte << 24 ) >> 31) & 1665);\n+        }\n+        return result;\n+    }\n+\n+\/\/    @IntrinsicCandidate\n+    static int implMlKemBarrettReduce(short[] coeffs) {\n+        implMlKemBarrettReduceJava(coeffs);\n+        return 1;\n+    }\n+\n+    static void implMlKemBarrettReduceJava(short[] coeffs) {\n+        for (int m = 0; m < mlKem_n; m++) {\n+            int tmp = ((int) coeffs[m] * mlKemBarrettMultiplier) >>\n+                    mlKemBarrettShift;\n+            coeffs[m] = (short) (coeffs[m] - tmp * mlKem_q);\n+        }\n+    }\n+\n+    \/\/ The input elements can have any short value.\n+    \/\/ Modifies poly such that upon return poly[i] will be\n+    \/\/ in the range [0, mlKem_q] and will be congruent with the original\n+    \/\/ poly[i] modulo mlKem_q, for all i in [0, mlKem_n).\n+    \/\/ At return, poly[i] == mlKem_q if and only if the original poly[i] was\n+    \/\/ a negative integer multiple of mlKem_q.\n+    \/\/ That means that if the original poly[i] > -mlKem_q then at return it\n+    \/\/ will be in the range [0, mlKem_q), i.e. it will be the canonical\n+    \/\/ representative of its residue class.\n+    private void mlKemBarrettReduce(short[] poly) {\n+        implMlKemBarrettReduce(poly);\n+    }\n+\n+    \/\/ Precondition: -(2^montRBits -1) * montQ <= b * c < (2^montRBits - 1) * montQ .\n+    \/\/ Computes b * c * 2^-montRBits mod montQ .\n+    \/\/ The result is between  -montQ and montQ.\n+    private static int montMul(int b, int c) {\n+        int a = b * c;\n+        int aHigh = a >> montRBits;\n+        int aLow = a & ((1 << montRBits) - 1);\n+        int m = ((montQInvModR * aLow) << (32 - montRBits)) >>\n+                (32 - montRBits); \/\/ signed low product\n+\n+        return (aHigh - ((m * montQ) >> montRBits)); \/\/ subtract signed high product\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":1472,"deletions":0,"binary":false,"changes":1472,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKEM;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+\n+import java.security.*;\n+import java.util.Map;\n+\n+import javax.crypto.DecapsulateException;\n+\n+public final class ML_KEM_Provider {\n+\n+    static int name2int(String name) {\n+        if (name.endsWith(\"512\")) return 512;\n+        else if (name.endsWith(\"768\")) return 768;\n+        else if (name.endsWith(\"1024\")) return 1024;\n+        else throw new ProviderException();\n+    }\n+\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            \/\/ ML-KEM-768 is the default\n+            super(\"ML-KEM\", \"ML-KEM-768\", \"ML-KEM-512\", \"ML-KEM-1024\");\n+        }\n+\n+        protected KPG(String pname) {\n+            super(\"ML-KEM\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom random) {\n+            byte[] seed = new byte[32];\n+            random.nextBytes(seed);\n+            byte[] z = new byte[32];\n+            random.nextBytes(z);\n+\n+            ML_KEM mlKem = new ML_KEM(name2int(name));\n+            ML_KEM.ML_KEM_KeyPair kp;\n+            try {\n+                kp = mlKem.generateKemKeyPair(seed, z);\n+            } catch (NoSuchAlgorithmException | DigestException e) {\n+                throw new RuntimeException(\"internal error\", e);\n+            }\n+            return new byte[][] {\n+                kp.encapsulationKey().keyBytes(),\n+                kp.decapsulationKey().keyBytes() };\n+        }\n+    }\n+\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"ML-KEM-512\");\n+        }\n+    }\n+\n+    public static class KPG3 extends KPG {\n+        public KPG3() {\n+            super(\"ML-KEM-768\");\n+        }\n+    }\n+\n+    public static class KPG5 extends KPG {\n+        public KPG5() {\n+            super(\"ML-KEM-1024\");\n+        }\n+    }\n+\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"ML-KEM\", \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n+        }\n+        public KF(String name) {\n+            super(\"ML-KEM\", name);\n+        }\n+    }\n+\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"ML-KEM-512\");\n+        }\n+    }\n+\n+    public static class KF3 extends KF {\n+        public KF3() {\n+            super(\"ML-KEM-768\");\n+        }\n+    }\n+\n+    public static class KF5 extends KF {\n+        public KF5() {\n+            super(\"ML-KEM-1024\");\n+        }\n+    }\n+\n+    public static class K extends NamedKEM {\n+        @Override\n+        public byte[][] implEncapsulate(String name, byte[] encapsulationKey, Object ek, SecureRandom secureRandom) {\n+            byte[] randomBytes = new byte[32];\n+            secureRandom.nextBytes(randomBytes);\n+\n+            ML_KEM mlKem = new ML_KEM(name2int(name));\n+            ML_KEM.ML_KEM_EncapsulateResult mlKemEncapsulateResult = null;\n+            try {\n+                mlKemEncapsulateResult = mlKem.encapsulate(\n+                    new ML_KEM.ML_KEM_EncapsulationKey(encapsulationKey), randomBytes);\n+            } catch (NoSuchAlgorithmException | InvalidKeyException e) {\n+                throw new RuntimeException(e); \/\/ should not happen\n+            }\n+\n+            return new byte[][] {\n+                mlKemEncapsulateResult.cipherText().encryptedBytes(),\n+                mlKemEncapsulateResult.sharedSecret() };\n+        }\n+\n+        @Override\n+        public byte[] implDecapsulate(String name, byte[] decapsulationKey, Object dk, byte[] cipherText) {\n+            ML_KEM mlKem = new ML_KEM(name2int(name));\n+            var kpkeCipherText = new ML_KEM.K_PKE_CipherText(cipherText);\n+\n+            byte[] decapsulateResult = null;\n+            try {\n+                decapsulateResult = mlKem.decapsulate(\n+                    new ML_KEM.ML_KEM_DecapsulationKey(decapsulationKey), kpkeCipherText);\n+            } catch (NoSuchAlgorithmException | InvalidKeyException | DecapsulateException e) {\n+                throw new RuntimeException(e); \/\/ should not happen\n+            }\n+\n+            return decapsulateResult;\n+        }\n+\n+        @Override\n+        public int implSecretSize(String name) {return ML_KEM.secretSize;}\n+\n+        @Override\n+        public int implEncapsulationSize(String name) {\n+            ML_KEM mlKem = new ML_KEM(name2int(name));\n+            return mlKem.encapsulationSize;\n+        }\n+\n+        public K() {\n+            super(\"ML-KEM\", \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n+        }\n+\n+        public K(String name) {\n+            super(\"ML-KEM\", name);\n+        }\n+    }\n+\n+    public static class K2 extends K {\n+        public K2() {\n+            super(\"ML-KEM-512\");\n+        }\n+    }\n+\n+    public static class K3 extends K {\n+        public K3() {\n+            super(\"ML-KEM-768\");\n+        }\n+    }\n+\n+    public static class K5 extends K {\n+        public K5() {\n+            super(\"ML-KEM-1024\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Provider.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+package sun.security.provider;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+import java.util.Arrays;\n+\n+import static sun.security.provider.ByteArrayAccess.b2lLittle;\n+import static sun.security.provider.ByteArrayAccess.l2bLittle;\n+\n+import static sun.security.provider.SHA3.keccak;\n+\n+public class SHA3Parallel {\n+    private int blockSize = 0;\n+    private static final int WIDTH = 200; \/\/ in bytes, e.g. 1600 bits\n+    private static final int DM = 5; \/\/ dimension of lanesArr\n+    private static final int NR = 24; \/\/ number of rounds\n+\n+    \/\/ precomputed round constants needed by the step mapping Iota\n+    private static final long[] RC_CONSTANTS = {\n+            0x01L, 0x8082L, 0x800000000000808aL,\n+            0x8000000080008000L, 0x808bL, 0x80000001L,\n+            0x8000000080008081L, 0x8000000000008009L, 0x8aL,\n+            0x88L, 0x80008009L, 0x8000000aL,\n+            0x8000808bL, 0x800000000000008bL, 0x8000000000008089L,\n+            0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+            0x800aL, 0x800000008000000aL, 0x8000000080008081L,\n+            0x8000000000008080L, 0x80000001L, 0x8000000080008008L,\n+    };\n+    private byte[][] buffers;\n+    private long[][] lanesArr;\n+    private long[] fakeLanes = new long[DM * DM];\n+    private int nrPar;\n+\n+    private SHA3Parallel(byte[][] buffers, int blockSize) {\n+        nrPar = buffers.length;\n+        this.buffers = buffers;\n+        this.blockSize = blockSize;\n+        lanesArr = new long[nrPar][];\n+        for (int i = 0; i < nrPar; i++) {\n+            lanesArr[i] = new long[DM * DM];\n+            b2lLittle(buffers[i], 0, lanesArr[i], 0, blockSize);\n+        }\n+    }\n+\n+    public void reset(byte[][] buffers) {\n+        nrPar = buffers.length;\n+        this.buffers = buffers;\n+        boolean newSize = (nrPar > lanesArr.length);\n+        if (newSize) {\n+            lanesArr = new long[nrPar][];\n+        }\n+        for (int i = 0; i < nrPar; i++) {\n+            if (newSize) {\n+                lanesArr[i] = new long[DM * DM];\n+            } else {\n+                Arrays.fill(lanesArr[i], 0L);\n+            }\n+            b2lLittle(buffers[i], 0, lanesArr[i], 0, blockSize);\n+        }\n+    }\n+\n+    public int squeezeBlock() {\n+        int retVal = parKeccak();\n+        for (int i = 0; i < nrPar; i++) {\n+            l2bLittle(lanesArr[i], 0, buffers[i], 0, blockSize);\n+        }\n+        return retVal;\n+    }\n+\n+    private int parKeccak() {\n+        int inlined = 0;\n+        for (int i = 0; i < (nrPar + 1) \/ 2; i ++) {\n+            inlined = doubleKeccak(lanesArr[2 * i],\n+                    2 * i + 1 == nrPar ? fakeLanes : lanesArr[2 * i + 1]);\n+        }\n+        return inlined;\n+    }\n+\n+    @IntrinsicCandidate\n+    private static int doubleKeccak(long[] lanes0, long[] lanes1) {\n+        doubleKeccakJava(lanes0, lanes1);\n+        return 1;\n+    }\n+\n+    private static int doubleKeccakJava(long[] lanes0, long[] lanes1) {\n+        keccak(lanes0);\n+        keccak(lanes1);\n+        return 1;\n+    }\n+\n+    public static final class Shake128Parallel extends SHA3Parallel {\n+        public Shake128Parallel(byte[][] buf) {\n+            super(buf, 168);\n+        }\n+    }\n+\n+    public static final class Shake256Parallel extends SHA3Parallel {\n+        public Shake256Parallel(byte[][] buf) {\n+            super(buf, 136);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SHA3Parallel.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -759,0 +759,17 @@\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        ps(\"KEM\", \"ML-KEM\", \"com.sun.crypto.provider.ML_KEM_Provider$K\", null, attrs);\n+        psA(\"KEM\", \"ML-KEM-512\", \"com.sun.crypto.provider.ML_KEM_Provider$K2\", attrs);\n+        psA(\"KEM\", \"ML-KEM-768\", \"com.sun.crypto.provider.ML_KEM_Provider$K3\", attrs);\n+        psA(\"KEM\", \"ML-KEM-1024\", \"com.sun.crypto.provider.ML_KEM_Provider$K5\",attrs);\n+\n+        ps(\"KeyPairGenerator\", \"ML-KEM\", \"com.sun.crypto.provider.ML_KEM_Provider$KPG\", null, attrs);\n+        psA(\"KeyPairGenerator\", \"ML-KEM-512\", \"com.sun.crypto.provider.ML_KEM_Provider$KPG2\", attrs);\n+        psA(\"KeyPairGenerator\", \"ML-KEM-768\", \"com.sun.crypto.provider.ML_KEM_Provider$KPG3\", attrs);\n+        psA(\"KeyPairGenerator\", \"ML-KEM-1024\", \"com.sun.crypto.provider.ML_KEM_Provider$KPG5\", attrs);\n+\n+        ps(\"KeyFactory\", \"ML-KEM\", \"com.sun.crypto.provider.ML_KEM_Provider$KF\", null, attrs);\n+        psA(\"KeyFactory\", \"ML-KEM-512\", \"com.sun.crypto.provider.ML_KEM_Provider$KF2\", attrs);\n+        psA(\"KeyFactory\", \"ML-KEM-768\", \"com.sun.crypto.provider.ML_KEM_Provider$KF3\", attrs);\n+        psA(\"KeyFactory\", \"ML-KEM-1024\", \"com.sun.crypto.provider.ML_KEM_Provider$KF5\", attrs);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -316,0 +316,5 @@\n+    \/\/ PQC\n+    ML_KEM_512(\"1.3.6.1.4.1.22554.5.6.1\", \"ML-KEM-512\"),\n+    ML_KEM_768(\"1.3.6.1.4.1.22554.5.6.2\", \"ML-KEM-768\"),\n+    ML_KEM_1024(\"1.3.6.1.4.1.22554.5.6.3\", \"ML-KEM-1024\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}