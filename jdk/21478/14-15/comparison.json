{"files":[{"patch":"@@ -37,10 +37,1 @@\n-    private final int mlKem_size;\n-    private final int mlKem_k;\n-    private final int mlKem_eta1;\n-    private final int mlKem_eta2;\n-\n-    private final int mlKem_du;\n-    private final int mlKem_dv;\n-    public final int encapsulationSize;\n-\n-    public static final int secretSize = 32;\n+    public static final int SECRET_SIZE = 32;\n@@ -48,2 +39,2 @@\n-    private static final int mlKem_q = 3329;\n-    private static final int mlKem_n = 256;\n+    private static final int ML_KEM_Q = 3329;\n+    private static final int ML_KEM_N = 256;\n@@ -51,1 +42,1 @@\n-    \/\/ mlKemXofBlockLen + mlKemXofPad should be divisible by 192 as that is\n+    \/\/ XOF_BLOCK_LEN + XOF_PAD should be divisible by 192 as that is\n@@ -53,12 +44,12 @@\n-    private static final int mlKemXofBlockLen = 168; \/\/ the block length for SHAKE128\n-    private static final int mlKemXofPad = 24;\n-    private static final int montRBits = 20;\n-    private static final int montQ = 3329;\n-    private static final int montRSquareModQ = 152;\n-    private static final int montQInvModR = 586497;\n-\n-    \/\/ toMont((mlKem_n \/ 2)^-1 mod mlKem_q) using R = 2^montRbits\n-    private static final int montDimHalfInverse = 1534;\n-    private static final int mlKemBarrettMultiplier = 20159;\n-    private static final int mlKemBarrettShift = 26;\n-    private static final int[] montZetasForNtt = new int[]{\n+    private static final int XOF_BLOCK_LEN = 168; \/\/ the block length for SHAKE128\n+    private static final int XOF_PAD = 24;\n+    private static final int MONT_R_BITS = 20;\n+    private static final int MONT_Q = 3329;\n+    private static final int MONT_R_SQUARE_MOD_Q = 152;\n+    private static final int MONT_Q_INV_MOD_R = 586497;\n+\n+    \/\/ toMont((ML_KEM_N \/ 2)^-1 mod ML_KEM_Q) using R = 2^MONT_R_BITS\n+    private static final int MONT_DIM_HALF_INVERSE = 1534;\n+    private static final int BARRETT_MULTIPLIER = 20159;\n+    private static final int BARRETT_SHIFT = 26;\n+    private static final int[] MONT_ZETAS_FOR_NTT = new int[]{\n@@ -83,1 +74,1 @@\n-    private static final short[] montZetasForVectorNttArr = new short[]{\n+    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_ARR = new short[]{\n@@ -204,1 +195,1 @@\n-    private static final int[] montZetasForInverseNtt = new int[]{\n+    private static final int[] MONT_ZETAS_FOR_INVERSE_NTT = new int[]{\n@@ -223,1 +214,1 @@\n-    private static final short[] montZetasForVectorInverseNttArr = new short[]{\n+    private static final short[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT_ARR = new short[]{\n@@ -345,1 +336,1 @@\n-    private static final int[] montZetasForNttMult = new int[]{\n+    private static final int[] MONT_ZETAS_FOR_NTT_MULT = new int[]{\n@@ -364,1 +355,1 @@\n-    private static final short[] montZetasForVectorNttMultArr = new short[]{\n+    private static final short[] MONT_ZETAS_FOR_VECTOR_NTT_MULT_ARR = new short[]{\n@@ -383,0 +374,9 @@\n+    private final int mlKem_size;\n+    private final int mlKem_k;\n+    private final int mlKem_eta1;\n+    private final int mlKem_eta2;\n+\n+    private final int mlKem_du;\n+    private final int mlKem_dv;\n+    public final int encapsulationSize;\n+\n@@ -465,1 +465,1 @@\n-            if ((a >= mlKem_q) || (b >= mlKem_q)) {\n+            if ((a >= ML_KEM_Q) || (b >= ML_KEM_Q)) {\n@@ -552,1 +552,1 @@\n-        int encode12PolyLen = 12 * mlKem_n \/ 8;\n+        int encode12PolyLen = 12 * ML_KEM_N \/ 8;\n@@ -645,2 +645,2 @@\n-        byte[] pkEncoded = new byte[(mlKem_k * mlKem_n * 12) \/ 8 + rho.length];\n-        byte[] skEncoded = new byte[(mlKem_k * mlKem_n * 12) \/ 8];\n+        byte[] pkEncoded = new byte[(mlKem_k * ML_KEM_N * 12) \/ 8 + rho.length];\n+        byte[] skEncoded = new byte[(mlKem_k * ML_KEM_N * 12) \/ 8];\n@@ -651,1 +651,1 @@\n-                    pkEncoded, i * ((mlKem_n * 12) \/ 8), (mlKem_n * 12) \/ 8);\n+                    pkEncoded, i * ((ML_KEM_N * 12) \/ 8), (ML_KEM_N * 12) \/ 8);\n@@ -654,1 +654,1 @@\n-                    skEncoded, i * ((mlKem_n * 12) \/ 8), (mlKem_n * 12) \/ 8);\n+                    skEncoded, i * ((ML_KEM_N * 12) \/ 8), (ML_KEM_N * 12) \/ 8);\n@@ -658,1 +658,1 @@\n-                pkEncoded, (mlKem_k * mlKem_n * 12) \/ 8, rho.length);\n+                pkEncoded, (mlKem_k * ML_KEM_N * 12) \/ 8, rho.length);\n@@ -668,1 +668,1 @@\n-        short[][] zeroes = new short[mlKem_k][mlKem_n];\n+        short[][] zeroes = new short[mlKem_k][ML_KEM_N];\n@@ -723,1 +723,1 @@\n-        int uBytesLen = mlKem_k * mlKem_du * mlKem_n \/ 8;\n+        int uBytesLen = mlKem_k * mlKem_du * ML_KEM_N \/ 8;\n@@ -749,1 +749,1 @@\n-        byte[] seedBuf = new byte[mlKemXofBlockLen];\n+        byte[] seedBuf = new byte[XOF_BLOCK_LEN];\n@@ -752,2 +752,2 @@\n-        seedBuf[mlKemXofBlockLen - 1] = (byte)0x80;\n-        byte[][] xofBufArr = new byte[nrPar][mlKemXofBlockLen + mlKemXofPad];\n+        seedBuf[XOF_BLOCK_LEN - 1] = (byte)0x80;\n+        byte[][] xofBufArr = new byte[nrPar][XOF_BLOCK_LEN + XOF_PAD];\n@@ -779,1 +779,1 @@\n-                aij[parInd] = new short[mlKem_n];\n+                aij[parInd] = new short[ML_KEM_N];\n@@ -793,1 +793,1 @@\n-                            if (ofs[k] < mlKem_n) {\n+                            if (ofs[k] < ML_KEM_N) {\n@@ -795,1 +795,1 @@\n-                                        parsedBuf, (mlKemXofBlockLen \/ 3) * 2);\n+                                        parsedBuf, (XOF_BLOCK_LEN \/ 3) * 2);\n@@ -797,2 +797,2 @@\n-                            while ((ofs[k] < mlKem_n) &&\n-                                    (parsedOfs < (mlKemXofBlockLen \/ 3) * 2)) {\n+                            while ((ofs[k] < ML_KEM_N) &&\n+                                    (parsedOfs < (XOF_BLOCK_LEN \/ 3) * 2)) {\n@@ -800,1 +800,1 @@\n-                                if (tmp < mlKem_q) {\n+                                if (tmp < ML_KEM_Q) {\n@@ -805,1 +805,1 @@\n-                                if ((ofs[k] < mlKem_n) && (tmp < mlKem_q)) {\n+                                if ((ofs[k] < ML_KEM_N) && (tmp < ML_KEM_Q)) {\n@@ -810,1 +810,1 @@\n-                            if (ofs[k] < mlKem_n) {\n+                            if (ofs[k] < ML_KEM_N) {\n@@ -830,1 +830,1 @@\n-        short[] result = new short[mlKem_n];\n+        short[] result = new short[ML_KEM_N];\n@@ -834,1 +834,1 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n+        for (int m = 0; m < ML_KEM_N; m++) {\n@@ -859,1 +859,1 @@\n-        short[] result = new short[mlKem_n];\n+        short[] result = new short[ML_KEM_N];\n@@ -875,1 +875,1 @@\n-        short[] result = new short[mlKem_n];\n+        short[] result = new short[ML_KEM_N];\n@@ -942,2 +942,2 @@\n-        int[] coeffs = new int[mlKem_n];\n-        for (int m = 0; m < mlKem_n; m++) {\n+        int[] coeffs = new int[ML_KEM_N];\n+        for (int m = 0; m < ML_KEM_N; m++) {\n@@ -947,1 +947,1 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n+        for (int m = 0; m < ML_KEM_N; m++) {\n@@ -952,2 +952,2 @@\n-    \/\/ The elements of poly should be in the range [-mlKem_q, mlKem_q]\n-    \/\/ The elements of poly at return will be in the range of [0, mlKem_q]\n+    \/\/ The elements of poly should be in the range [-ML_KEM_Q, ML_KEM_Q]\n+    \/\/ The elements of poly at return will be in the range of [0, ML_KEM_Q]\n@@ -955,1 +955,1 @@\n-        implMlKemNtt(poly, montZetasForVectorNttArr);\n+        implMlKemNtt(poly, MONT_ZETAS_FOR_VECTOR_NTT_ARR);\n@@ -966,2 +966,2 @@\n-        int[] coeffs = new int[mlKem_n];\n-        for (int m = 0; m < mlKem_n; m++) {\n+        int[] coeffs = new int[ML_KEM_N];\n+        for (int m = 0; m < ML_KEM_N; m++) {\n@@ -971,1 +971,1 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n+        for (int m = 0; m < ML_KEM_N; m++) {\n@@ -979,1 +979,1 @@\n-        implMlKemInverseNtt(poly, montZetasForVectorInverseNttArr);\n+        implMlKemInverseNtt(poly, MONT_ZETAS_FOR_VECTOR_INVERSE_NTT_ARR);\n@@ -987,1 +987,1 @@\n-    \/\/ The input elements should be in the range [-montQ, montQ].\n+    \/\/ The input elements should be in the range [-MONT_Q, MONT_Q].\n@@ -991,1 +991,1 @@\n-        int dimension = mlKem_n;\n+        int dimension = ML_KEM_N;\n@@ -996,1 +996,1 @@\n-                    int tmp = montMul(montZetasForNtt[zetaIndex], coeffs[j + l]);\n+                    int tmp = montMul(MONT_ZETAS_FOR_NTT[zetaIndex], coeffs[j + l]);\n@@ -1009,2 +1009,2 @@\n-    \/\/ The input elements should be in the range [-montQ, montQ).\n-    \/\/ The output elements will be in the range (-montQ, montQ).\n+    \/\/ The input elements should be in the range [-MONT_Q, MONT_Q).\n+    \/\/ The output elements will be in the range (-MONT_Q, MONT_Q).\n@@ -1012,1 +1012,1 @@\n-        int dimension = mlKem_n;\n+        int dimension = ML_KEM_N;\n@@ -1021,1 +1021,1 @@\n-                            montZetasForInverseNtt[zetaIndex]);\n+                            MONT_ZETAS_FOR_INVERSE_NTT[zetaIndex]);\n@@ -1028,1 +1028,1 @@\n-            int r = montMul(coeffs[i], montDimHalfInverse);\n+            int r = montMul(coeffs[i], MONT_DIM_HALF_INVERSE);\n@@ -1035,1 +1035,1 @@\n-    \/\/ b and c are mlKem_k long vectors of degree mlKem_n - 1\n+    \/\/ b and c are mlKem_k long vectors of degree ML_KEM_N - 1\n@@ -1037,1 +1037,1 @@\n-    \/\/ The coefficients in the result are in the range [0, mlKem_q).\n+    \/\/ The coefficients in the result are in the range [0, ML_KEM_Q).\n@@ -1040,1 +1040,1 @@\n-        short[] product = new short[mlKem_n];\n+        short[] product = new short[ML_KEM_N];\n@@ -1053,3 +1053,3 @@\n-    \/\/ of degree mlKem_n - 1 polynomials in the NTT representation,\n-    \/\/ with coefficients in the range [-mlKem_q, mlKem_q].\n-    \/\/ The coefficients in the result are in the range [0, mlKem_q).\n+    \/\/ of degree ML_KEM_N - 1 polynomials in the NTT representation,\n+    \/\/ with coefficients in the range [-ML_KEM_Q, ML_KEM_Q].\n+    \/\/ The coefficients in the result are in the range [0, ML_KEM_Q).\n@@ -1057,2 +1057,2 @@\n-        short[] result = new short[mlKem_n];\n-        short[] product = new short[mlKem_n];\n+        short[] result = new short[ML_KEM_N];\n+        short[] product = new short[ML_KEM_N];\n@@ -1082,1 +1082,1 @@\n-        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+        for (int m = 0; m < ML_KEM_N \/ 2; m++) {\n@@ -1088,2 +1088,2 @@\n-                    montMul(montMul(a1, b1), montZetasForNttMult[m]);\n-            result[2 * m] = (short) montMul(r, montRSquareModQ);\n+                    montMul(montMul(a1, b1), MONT_ZETAS_FOR_NTT_MULT[m]);\n+            result[2 * m] = (short) montMul(r, MONT_R_SQUARE_MOD_Q);\n@@ -1091,1 +1091,1 @@\n-                    (montMul(a0, b1) + montMul(a1, b0)), montRSquareModQ);\n+                    (montMul(a0, b1) + montMul(a1, b0)), MONT_R_SQUARE_MOD_Q);\n@@ -1097,1 +1097,1 @@\n-    \/\/ The coefficients in the result are in the range (-mlKem_q, mlKem_q).\n+    \/\/ The coefficients in the result are in the range (-ML_KEM_Q, ML_KEM_Q).\n@@ -1099,1 +1099,1 @@\n-        implMlKemNttMult(result, ntta, nttb, montZetasForVectorNttMultArr);\n+        implMlKemNttMult(result, ntta, nttb, MONT_ZETAS_FOR_VECTOR_NTT_MULT_ARR);\n@@ -1106,2 +1106,2 @@\n-    \/\/ greater than -mlKem_q and less than mlKem_q.\n-    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    \/\/ greater than -ML_KEM_Q and less than ML_KEM_Q.\n+    \/\/ The coefficients in the result are nonnegative and less than ML_KEM_Q.\n@@ -1123,2 +1123,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            int r = a[m] + b[m] + mlKem_q; \/\/ This makes r > -mlKem_q\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int r = a[m] + b[m] + ML_KEM_Q; \/\/ This makes r > -ML_KEM_Q\n@@ -1131,3 +1131,3 @@\n-    \/\/ The coefficients are supposed be greater than -mlKem_q in a and\n-    \/\/ greater than -mlKem_q and less than mlKem_q in b.\n-    \/\/ The coefficients in the result are greater than -mlKem_q.\n+    \/\/ The coefficients are supposed be greater than -ML_KEM_Q in a and\n+    \/\/ greater than -ML_KEM_Q and less than ML_KEM_Q in b.\n+    \/\/ The coefficients in the result are greater than -ML_KEM_Q.\n@@ -1145,2 +1145,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            int r = a[m] + b[m] + c[m] + 2 * mlKem_q; \/\/ This makes r > - mlKem_q\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int r = a[m] + b[m] + c[m] + 2 * ML_KEM_Q; \/\/ This makes r > - ML_KEM_Q\n@@ -1154,2 +1154,2 @@\n-    \/\/ greater than -mlKem_q and less than mlKem_q.\n-    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    \/\/ greater than -ML_KEM_Q and less than ML_KEM_Q.\n+    \/\/ The coefficients in the result are nonnegative and less than ML_KEM_Q.\n@@ -1165,3 +1165,3 @@\n-    \/\/ The coefficiens in both are assumed to be greater than -mlKem_q\n-    \/\/ and less than mlKem_q.\n-    \/\/ The coefficients in the result are nonnegative and less than mlKem_q.\n+    \/\/ The coefficiens in both are assumed to be greater than -ML_KEM_Q\n+    \/\/ and less than ML_KEM_Q.\n+    \/\/ The coefficients in the result are nonnegative and less than ML_KEM_Q.\n@@ -1169,2 +1169,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            int r = a[m] - b[m] + mlKem_q; \/\/ This makes r > -mlKem_q\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int r = a[m] - b[m] + ML_KEM_Q; \/\/ This makes r > -ML_KEM_Q\n@@ -1182,1 +1182,1 @@\n-        int encodedPolyLength = mlKem_n * l \/ 8;\n+        int encodedPolyLength = ML_KEM_N * l \/ 8;\n@@ -1196,1 +1196,1 @@\n-        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+        for (int m = 0; m < ML_KEM_N \/ 2; m++) {\n@@ -1198,1 +1198,1 @@\n-            low += ((low >> 31) & mlKem_q);\n+            low += ((low >> 31) & ML_KEM_Q);\n@@ -1201,1 +1201,1 @@\n-            high += ((high >> 31) & mlKem_q);\n+            high += ((high >> 31) & ML_KEM_Q);\n@@ -1211,1 +1211,1 @@\n-        for (int m = 0; m < mlKem_n \/ 2; m++) {\n+        for (int m = 0; m < ML_KEM_N \/ 2; m++) {\n@@ -1218,2 +1218,2 @@\n-    \/\/ or elements of Z_(mlKem_q) represented by a 16-bit value\n-    \/\/ between -mlKem_q and mlKem_q.\n+    \/\/ or elements of Z_(ML_KEM_Q) represented by a 16-bit value\n+    \/\/ between -ML_KEM_Q and ML_KEM_Q.\n@@ -1221,1 +1221,1 @@\n-        byte[] result = new byte[mlKem_n \/ 8 * l];\n+        byte[] result = new byte[ML_KEM_N \/ 8 * l];\n@@ -1231,1 +1231,1 @@\n-            for (int m = 0; m < mlKem_n; m++) {\n+            for (int m = 0; m < ML_KEM_N; m++) {\n@@ -1233,1 +1233,1 @@\n-                currentShort += (currentShort >> 31) & mlKem_q;\n+                currentShort += (currentShort >> 31) & ML_KEM_Q;\n@@ -1248,1 +1248,1 @@\n-        byte[] result = new byte[mlKem_n \/ 8];\n+        byte[] result = new byte[ML_KEM_N \/ 8];\n@@ -1251,1 +1251,1 @@\n-        for (int i = 0; i < mlKem_n \/ 8; i++) {\n+        for (int i = 0; i < ML_KEM_N \/ 8; i++) {\n@@ -1277,1 +1277,1 @@\n-            result[i] = decodePoly(l, encodedVector, (i * mlKem_n * l) \/ 8);\n+            result[i] = decodePoly(l, encodedVector, (i * ML_KEM_N * l) \/ 8);\n@@ -1284,1 +1284,1 @@\n-        int k = (decapsKeyBytes.length - 64) \/ ((mlKem_n * 3) \/ 2);\n+        int k = (decapsKeyBytes.length - 64) \/ ((ML_KEM_N * 3) \/ 2);\n@@ -1287,2 +1287,2 @@\n-            vector[i] = new short[mlKem_n];\n-            implMlKem12To16(decapsKeyBytes, i * ((mlKem_n * 3)\/ 2), vector[i], mlKem_n);\n+            vector[i] = new short[ML_KEM_N];\n+            implMlKem12To16(decapsKeyBytes, i * ((ML_KEM_N * 3)\/ 2), vector[i], ML_KEM_N);\n@@ -1323,1 +1323,1 @@\n-        for (int i = 0; i < mlKem_n; i += 8) {\n+        for (int i = 0; i < ML_KEM_N; i += 8) {\n@@ -1341,1 +1341,1 @@\n-        for (int i = 0; i < mlKem_n \/ 2; i++) {\n+        for (int i = 0; i < ML_KEM_N \/ 2; i++) {\n@@ -1351,1 +1351,1 @@\n-        short[] poly = new short[mlKem_n];\n+        short[] poly = new short[ML_KEM_N];\n@@ -1353,1 +1353,1 @@\n-            twelve2Sixteen(input, index, poly, mlKem_n);\n+            twelve2Sixteen(input, index, poly, ML_KEM_N);\n@@ -1363,1 +1363,1 @@\n-            for (int m = 0; m < mlKem_n; m++) {\n+            for (int m = 0; m < ML_KEM_N; m++) {\n@@ -1392,2 +1392,2 @@\n-    \/\/ Prerequisite: for all m, 0 <= poly[m] < mlKem_q, d == 4 or d == 5\n-    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ mlKem_q) mod 2^d for all m,\n+    \/\/ Prerequisite: for all m, 0 <= poly[m] < ML_KEM_Q, d == 4 or d == 5\n+    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ ML_KEM_Q) mod 2^d for all m,\n@@ -1398,2 +1398,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            xx = (poly[m] << d) + mlKem_q \/ 2;\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            xx = (poly[m] << d) + ML_KEM_Q \/ 2;\n@@ -1405,2 +1405,2 @@\n-    \/\/ Prerequisite: for all m, 0 <= poly[m] < mlKem_q, d == 10 or d == 11\n-    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ mlKem_q) mod 2^d for all m,\n+    \/\/ Prerequisite: for all m, 0 <= poly[m] < ML_KEM_Q, d == 10 or d == 11\n+    \/\/ Replaces poly[m] with round(2^d * poly[m] \/ ML_KEM_Q) mod 2^d for all m,\n@@ -1411,2 +1411,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            xx = (poly[m] << d) + mlKem_q \/ 2;\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            xx = (poly[m] << d) + ML_KEM_Q \/ 2;\n@@ -1431,2 +1431,2 @@\n-    \/\/ Prerequisite: 0 <= x[i] < 2^d < mlKem_q .\n-    \/\/ Computes Round(mlKem_q * x[i] \/ 2^d),\n+    \/\/ Prerequisite: 0 <= x[i] < 2^d < ML_KEM_Q .\n+    \/\/ Computes Round(ML_KEM_Q * x[i] \/ 2^d),\n@@ -1436,2 +1436,2 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            int qx = mlKem_q * poly[m];\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int qx = ML_KEM_Q * poly[m];\n@@ -1466,4 +1466,4 @@\n-        for (int m = 0; m < mlKem_n; m++) {\n-            int tmp = ((int) coeffs[m] * mlKemBarrettMultiplier) >>\n-                    mlKemBarrettShift;\n-            coeffs[m] = (short) (coeffs[m] - tmp * mlKem_q);\n+        for (int m = 0; m < ML_KEM_N; m++) {\n+            int tmp = ((int) coeffs[m] * BARRETT_MULTIPLIER) >>\n+                    BARRETT_SHIFT;\n+            coeffs[m] = (short) (coeffs[m] - tmp * ML_KEM_Q);\n@@ -1475,6 +1475,6 @@\n-    \/\/ in the range [0, mlKem_q] and will be congruent with the original\n-    \/\/ poly[i] modulo mlKem_q, for all i in [0, mlKem_n).\n-    \/\/ At return, poly[i] == mlKem_q if and only if the original poly[i] was\n-    \/\/ a negative integer multiple of mlKem_q.\n-    \/\/ That means that if the original poly[i] > -mlKem_q then at return it\n-    \/\/ will be in the range [0, mlKem_q), i.e. it will be the canonical\n+    \/\/ in the range [0, ML_KEM_Q] and will be congruent with the original\n+    \/\/ poly[i] modulo ML_KEM_Q, for all i in [0, ML_KEM_N).\n+    \/\/ At return, poly[i] == ML_KEM_Q if and only if the original poly[i] was\n+    \/\/ a negative integer multiple of ML_KEM_Q.\n+    \/\/ That means that if the original poly[i] > -ML_KEM_Q then at return it\n+    \/\/ will be in the range [0, ML_KEM_Q), i.e. it will be the canonical\n@@ -1486,3 +1486,3 @@\n-    \/\/ Precondition: -(2^montRBits -1) * montQ <= b * c < (2^montRBits - 1) * montQ .\n-    \/\/ Computes b * c * 2^-montRBits mod montQ .\n-    \/\/ The result is between  -montQ and montQ.\n+    \/\/ Precondition: -(2^MONT_R_BITS -1) * MONT_Q <= b * c < (2^MONT_R_BITS - 1) * MONT_Q .\n+    \/\/ Computes b * c * 2^-MONT_R_BITS mod MONT_Q .\n+    \/\/ The result is between  -MONT_Q and MONT_Q.\n@@ -1491,4 +1491,4 @@\n-        int aHigh = a >> montRBits;\n-        int aLow = a & ((1 << montRBits) - 1);\n-        int m = ((montQInvModR * aLow) << (32 - montRBits)) >>\n-                (32 - montRBits); \/\/ signed low product\n+        int aHigh = a >> MONT_R_BITS;\n+        int aLow = a & ((1 << MONT_R_BITS) - 1);\n+        int m = ((MONT_Q_INV_MOD_R * aLow) << (32 - MONT_R_BITS)) >>\n+                (32 - MONT_R_BITS); \/\/ signed low product\n@@ -1496,1 +1496,1 @@\n-        return (aHigh - ((m * montQ) >> montRBits)); \/\/ subtract signed high product\n+        return (aHigh - ((m * MONT_Q) >> MONT_R_BITS)); \/\/ subtract signed high product\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":153,"deletions":153,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        public int implSecretSize(String name) {return ML_KEM.secretSize;}\n+        public int implSecretSize(String name) {return ML_KEM.SECRET_SIZE;}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Provider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}