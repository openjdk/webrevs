{"files":[{"patch":"@@ -197,19 +197,0 @@\n-    private static final int[] MONT_ZETAS_FOR_INVERSE_NTT = new int[]{\n-            584, -1049, 57, 1317, 789, 709, 1599, -1601,\n-            -990, 604, 348, 857, 612, 474, 1177, -1014,\n-            -88, -982, -191, 668, 1386, 486, -1153, -534,\n-            514, 137, 586, -1178, 227, 339, -907, 244,\n-            1200, -833, 1394, -30, 1074, 636, -317, -1192,\n-            -1259, -355, -425, -884, -977, 1430, 868, 607,\n-            184, 1448, 702, 1327, 431, 497, 595, -94,\n-            1649, -1497, -620, 42, -172, 1107, -222, 1003,\n-            426, -845, 395, -510, 1613, 825, 1269, -290,\n-            -1429, 623, -567, 1617, 36, 1007, 1440, 332,\n-            -201, 1313, -1382, -744, 669, -1538, 128, -1598,\n-            1401, 1183, -553, 714, 405, -1155, -445, 406,\n-            -1496, -49, 82, 1369, 259, 1604, 373, 909,\n-            -1249, -1000, -25, -52, 530, -895, 1226, 819,\n-            -185, 281, -742, 1253, 417, 1400, 35, -593,\n-            97, -1263, 551, -585, 969, -914, -1188\n-    };\n-\n@@ -418,1 +399,1 @@\n-    public record K_PKE_EncryptionKey(byte[] keyBytes) {}\n+    private record K_PKE_EncryptionKey(byte[] keyBytes) {}\n@@ -420,1 +401,1 @@\n-    public record K_PKE_DecryptionKey(byte[] keyBytes) {}\n+    private record K_PKE_DecryptionKey(byte[] keyBytes) {}\n@@ -422,2 +403,2 @@\n-    public record K_PKE_KeyPair(\n-            K_PKE_DecryptionKey privateKey, K_PKE_EncryptionKey publicKey) {\n+    private record K_PKE_KeyPair(\n+            K_PKE_EncryptionKey publicKey, K_PKE_DecryptionKey privateKey) {\n@@ -426,1 +407,1 @@\n-    public record K_PKE_CipherText(byte[] encryptedBytes) {\n+    protected record K_PKE_CipherText(byte[] encryptedBytes) {\n@@ -436,1 +417,1 @@\n-    public record ML_KEM_EncapsulationKey(byte[] keyBytes) {\n+    protected record ML_KEM_EncapsulationKey(byte[] keyBytes) {\n@@ -439,1 +420,1 @@\n-    public record ML_KEM_DecapsulationKey(byte[] keyBytes) {\n+    protected record ML_KEM_DecapsulationKey(byte[] keyBytes) {\n@@ -442,1 +423,1 @@\n-    public record ML_KEM_KeyPair(ML_KEM_EncapsulationKey encapsulationKey,\n+    protected record ML_KEM_KeyPair(ML_KEM_EncapsulationKey encapsulationKey,\n@@ -446,1 +427,1 @@\n-    public record ML_KEM_EncapsulateResult(\n+    protected record ML_KEM_EncapsulateResult(\n@@ -450,4 +431,2 @@\n-    \/*\n-    Key check functions from the beginning of sections 7.2 and 7.3 of the spec\n-     *\/\n-    public Object checkPublicKey(byte[] pk) throws InvalidKeyException {\n+    \/\/ Encapsulation key checks from section 7.2 of spec\n+    protected Object checkPublicKey(byte[] pk) throws InvalidKeyException {\n@@ -474,1 +453,2 @@\n-    public Object checkPrivateKey(byte[] sk) throws InvalidKeyException {\n+    \/\/ Decapsulation key checks from Section 7.3 of spec\n+    protected Object checkPrivateKey(byte[] sk) throws InvalidKeyException {\n@@ -499,1 +479,1 @@\n-    public ML_KEM_KeyPair generateKemKeyPair(\n+    protected ML_KEM_KeyPair generateKemKeyPair(\n@@ -524,1 +504,1 @@\n-    public ML_KEM_EncapsulateResult encapsulate(\n+    protected ML_KEM_EncapsulateResult encapsulate(\n@@ -544,1 +524,1 @@\n-    public byte[] decapsulate(ML_KEM_DecapsulationKey decapsulationKey,\n+    protected byte[] decapsulate(ML_KEM_DecapsulationKey decapsulationKey,\n@@ -664,2 +644,2 @@\n-            new K_PKE_DecryptionKey(skEncoded),\n-            new K_PKE_EncryptionKey(pkEncoded));\n+            new K_PKE_EncryptionKey(pkEncoded),\n+            new K_PKE_DecryptionKey(skEncoded));\n@@ -710,1 +690,1 @@\n-        encryptV = mlKemAddPoly(encryptV, encryptE2, decompressDecode1(message));\n+        encryptV = mlKemAddPoly(encryptV, encryptE2, decompressDecode(message));\n@@ -738,1 +718,1 @@\n-        return encodeCompress1(decryptV);\n+        return encodeCompress(decryptV);\n@@ -766,39 +746,33 @@\n-        Shake128Parallel parXof = new Shake128Parallel(xofBufArr);\n-\n-        for (int i = 0; i < mlKem_k; i++) {\n-            for (int j = 0; j < mlKem_k; j++) {\n-                xofBufArr[parInd] = seedBuf.clone();\n-                if (transposed) {\n-                    xofBufArr[parInd][rhoLen] = (byte) i;\n-                    xofBufArr[parInd][rhoLen + 1] = (byte) j;\n-                } else {\n-                    xofBufArr[parInd][rhoLen] = (byte) j;\n-                    xofBufArr[parInd][rhoLen + 1] = (byte) i;\n-                }\n-                iIndex[parInd] = i;\n-                jIndex[parInd] = j;\n-                ofs[parInd] = 0;\n-                aij[parInd] = new short[ML_KEM_N];\n-                parInd++;\n-\n-                if ((parInd == nrPar) ||\n-                        ((i == mlKem_k - 1) && (j == mlKem_k - 1))) {\n-                    parXof.reset(xofBufArr);\n-\n-                    allDone = false;\n-                    while (!allDone) {\n-                        allDone = true;\n-                        parXof.squeezeBlock();\n-                        for (int k = 0; k < parInd; k++) {\n-                            int parsedOfs = 0;\n-                            int tmp;\n-                            if (ofs[k] < ML_KEM_N) {\n-                                twelve2Sixteen(xofBufArr[k], 0,\n-                                        parsedBuf, (XOF_BLOCK_LEN \/ 3) * 2);\n-                            }\n-                            while ((ofs[k] < ML_KEM_N) &&\n-                                    (parsedOfs < (XOF_BLOCK_LEN \/ 3) * 2)) {\n-                                tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n-                                if (tmp < ML_KEM_Q) {\n-                                    aij[k][ofs[k]] = (short) tmp;\n-                                    ofs[k]++;\n+        try {\n+            Shake128Parallel parXof = new Shake128Parallel(xofBufArr);\n+\n+            for (int i = 0; i < mlKem_k; i++) {\n+                for (int j = 0; j < mlKem_k; j++) {\n+                    xofBufArr[parInd] = seedBuf.clone();\n+                    if (transposed) {\n+                        xofBufArr[parInd][rhoLen] = (byte) i;\n+                        xofBufArr[parInd][rhoLen + 1] = (byte) j;\n+                    } else {\n+                        xofBufArr[parInd][rhoLen] = (byte) j;\n+                        xofBufArr[parInd][rhoLen + 1] = (byte) i;\n+                    }\n+                    iIndex[parInd] = i;\n+                    jIndex[parInd] = j;\n+                    ofs[parInd] = 0;\n+                    aij[parInd] = new short[ML_KEM_N];\n+                    parInd++;\n+\n+                    if ((parInd == nrPar) ||\n+                            ((i == mlKem_k - 1) && (j == mlKem_k - 1))) {\n+                        parXof.reset(xofBufArr);\n+\n+                        allDone = false;\n+                        while (!allDone) {\n+                            allDone = true;\n+                            parXof.squeezeBlock();\n+                            for (int k = 0; k < parInd; k++) {\n+                                int parsedOfs = 0;\n+                                int tmp;\n+                                if (ofs[k] < ML_KEM_N) {\n+                                    twelve2Sixteen(xofBufArr[k], 0,\n+                                            parsedBuf, (XOF_BLOCK_LEN \/ 3) * 2);\n@@ -806,4 +780,15 @@\n-                                tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n-                                if ((ofs[k] < ML_KEM_N) && (tmp < ML_KEM_Q)) {\n-                                    aij[k][ofs[k]] = (short) tmp;\n-                                    ofs[k]++;\n+                                while ((ofs[k] < ML_KEM_N) &&\n+                                        (parsedOfs < (XOF_BLOCK_LEN \/ 3) * 2)) {\n+                                    tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n+                                    if (tmp < ML_KEM_Q) {\n+                                        aij[k][ofs[k]] = (short) tmp;\n+                                        ofs[k]++;\n+                                    }\n+                                    tmp = parsedBuf[parsedOfs++] & 0xFFFF;\n+                                    if ((ofs[k] < ML_KEM_N) && (tmp < ML_KEM_Q)) {\n+                                        aij[k][ofs[k]] = (short) tmp;\n+                                        ofs[k]++;\n+                                    }\n+                                }\n+                                if (ofs[k] < ML_KEM_N) {\n+                                    allDone = false;\n@@ -811,3 +796,0 @@\n-                            }\n-                            if (ofs[k] < ML_KEM_N) {\n-                                allDone = false;\n@@ -816,1 +798,0 @@\n-                    }\n@@ -818,2 +799,4 @@\n-                    for (int k = 0; k < parInd; k ++) {\n-                        a[iIndex[k]][jIndex[k]] = aij[k];\n+                        for (int k = 0; k < parInd; k++) {\n+                            a[iIndex[k]][jIndex[k]] = aij[k];\n+                        }\n+                        parInd = 0;\n@@ -821,1 +804,0 @@\n-                    parInd = 0;\n@@ -824,0 +806,3 @@\n+        } catch (InvalidAlgorithmParameterException e) {\n+            \/\/ This cannot happen since xofBufArr is of the correct size\n+            throw new RuntimeException(\"Internal error.\");\n@@ -952,1 +937,1 @@\n-    static void implMlKemNttJava(short[] poly) {\n+    private static void implMlKemNttJava(short[] poly) {\n@@ -976,1 +961,1 @@\n-    static void implMlKemInverseNttJava(short[] poly) {\n+    private static void implMlKemInverseNttJava(short[] poly) {\n@@ -1024,1 +1009,1 @@\n-        int zetaIndex = 0;\n+        int zetaIndex = MONT_ZETAS_FOR_NTT.length - 1;\n@@ -1032,1 +1017,1 @@\n-                            MONT_ZETAS_FOR_INVERSE_NTT[zetaIndex]);\n+                            -MONT_ZETAS_FOR_NTT[zetaIndex]);\n@@ -1034,1 +1019,1 @@\n-                zetaIndex++;\n+                zetaIndex--;\n@@ -1092,1 +1077,1 @@\n-    static void implMlKemNttMultJava(short[] result, short[] ntta, short[] nttb) {\n+    private static void implMlKemNttMultJava(short[] result, short[] ntta, short[] nttb) {\n@@ -1133,1 +1118,1 @@\n-    static void implMlKemAddPolyJava(short[] result, short[] a, short[] b) {\n+    private static void implMlKemAddPolyJava(short[] result, short[] a, short[] b) {\n@@ -1155,1 +1140,1 @@\n-    static void implMlKemAddPolyJava(short[] result, short[] a, short[] b, short[] c) {\n+    private static void implMlKemAddPolyJava(short[] result, short[] a, short[] b, short[] c) {\n@@ -1258,1 +1243,1 @@\n-    static byte[] encodeCompress1(short[] poly) {\n+    private static byte[] encodeCompress(short[] poly) {\n@@ -1293,14 +1278,0 @@\n-    public static byte[] normalizeDecapsKeyBytes(byte[] decapsKeyBytes) {\n-        byte[] result = decapsKeyBytes.clone();\n-        int k = (decapsKeyBytes.length - 64) \/ ((ML_KEM_N * 3) \/ 2);\n-        short[][] vector = new short[k][];\n-        for (int i = 0; i < k; i++) {\n-            vector[i] = new short[ML_KEM_N];\n-            implMlKem12To16(decapsKeyBytes, i * ((ML_KEM_N * 3)\/ 2), vector[i], ML_KEM_N);\n-            implMlKemBarrettReduce(vector[i]);\n-        }\n-        var normalized = encodeVector(12, vector, k);\n-        System.arraycopy(normalized, 0, result, 0, normalized.length);\n-        return result;\n-    }\n-\n@@ -1454,1 +1425,1 @@\n-    private static short[] decompressDecode1 (byte[] input) {\n+    private static short[] decompressDecode(byte[] input) {\n@@ -1476,1 +1447,1 @@\n-    static void implMlKemBarrettReduceJava(short[] coeffs) {\n+    private static void implMlKemBarrettReduceJava(short[] coeffs) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":86,"deletions":115,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.security.InvalidAlgorithmParameterException;\n@@ -39,1 +40,0 @@\n-    private static final int WIDTH = 200; \/\/ in bytes, e.g. 1600 bits\n@@ -41,13 +41,0 @@\n-    private static final int NR = 24; \/\/ number of rounds\n-\n-    \/\/ precomputed round constants needed by the step mapping Iota\n-    private static final long[] RC_CONSTANTS = {\n-            0x01L, 0x8082L, 0x800000000000808aL,\n-            0x8000000080008000L, 0x808bL, 0x80000001L,\n-            0x8000000080008081L, 0x8000000000008009L, 0x8aL,\n-            0x88L, 0x80008009L, 0x8000000aL,\n-            0x8000808bL, 0x800000000000008bL, 0x8000000000008089L,\n-            0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n-            0x800aL, 0x800000008000000aL, 0x8000000080008081L,\n-            0x8000000000008080L, 0x80000001L, 0x8000000080008008L,\n-    };\n@@ -56,2 +43,1 @@\n-    private long[] fakeLanes = new long[DM * DM];\n-    private int nrPar;\n+    private static final int NRPAR = 2;\n@@ -59,2 +45,4 @@\n-    private SHA3Parallel(byte[][] buffers, int blockSize) {\n-        nrPar = buffers.length;\n+    private SHA3Parallel(byte[][] buffers, int blockSize) throws InvalidAlgorithmParameterException {\n+        if ((buffers.length != NRPAR) || (buffers[0].length < blockSize)) {\n+            throw new InvalidAlgorithmParameterException(\"Bad buffersize.\");\n+        }\n@@ -63,2 +51,2 @@\n-        lanesArr = new long[nrPar][];\n-        for (int i = 0; i < nrPar; i++) {\n+        lanesArr = new long[NRPAR][];\n+        for (int i = 0; i < NRPAR; i++) {\n@@ -70,6 +58,3 @@\n-    public void reset(byte[][] buffers) {\n-        nrPar = buffers.length;\n-        this.buffers = buffers;\n-        boolean newSize = (nrPar > lanesArr.length);\n-        if (newSize) {\n-            lanesArr = new long[nrPar][];\n+    public void reset(byte[][] buffers) throws InvalidAlgorithmParameterException {\n+        if ((buffers.length != NRPAR) || (buffers[0].length < blockSize)) {\n+            throw new InvalidAlgorithmParameterException(\"Bad buffersize.\");\n@@ -77,6 +62,3 @@\n-        for (int i = 0; i < nrPar; i++) {\n-            if (newSize) {\n-                lanesArr[i] = new long[DM * DM];\n-            } else {\n-                Arrays.fill(lanesArr[i], 0L);\n-            }\n+        this.buffers = buffers;\n+        for (int i = 0; i < NRPAR; i++) {\n+            Arrays.fill(lanesArr[i], 0L);\n@@ -88,2 +70,2 @@\n-        int retVal = parKeccak();\n-        for (int i = 0; i < nrPar; i++) {\n+        int retVal = doubleKeccak(lanesArr[0], lanesArr[1]);\n+        for (int i = 0; i < NRPAR; i++) {\n@@ -95,9 +77,0 @@\n-    private int parKeccak() {\n-        int inlined = 0;\n-        for (int i = 0; i < (nrPar + 1) \/ 2; i ++) {\n-            inlined = doubleKeccak(lanesArr[2 * i],\n-                    2 * i + 1 == nrPar ? fakeLanes : lanesArr[2 * i + 1]);\n-        }\n-        return inlined;\n-    }\n-\n@@ -117,1 +90,1 @@\n-        public Shake128Parallel(byte[][] buf) {\n+        public Shake128Parallel(byte[][] buf) throws InvalidAlgorithmParameterException {\n@@ -123,1 +96,1 @@\n-        public Shake256Parallel(byte[][] buf) {\n+        public Shake256Parallel(byte[][] buf) throws InvalidAlgorithmParameterException {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SHA3Parallel.java","additions":18,"deletions":45,"binary":false,"changes":63,"status":"modified"}]}