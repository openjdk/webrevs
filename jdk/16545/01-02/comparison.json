{"files":[{"patch":"@@ -815,0 +815,10 @@\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  static constexpr size_t TABLE_SIZE = 1031;\n+\n+  \/\/ Maintain the cache for N classes. This limits memory footprint\n+  \/\/ impact, regardless of how many classes we have in the dump.\n+  \/\/ This also improves look up performance by keeping the statically\n+  \/\/ sized table from overloading.\n+  static constexpr int CACHE_TOP = 256;\n+\n@@ -820,3 +830,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n-  \/\/ use 1031 which is the first prime after 1024.\n-  typedef ResourceHashtable<void*, DumperClassCacheTableEntry*, 1031, AnyObj::C_HEAP, mtServiceability,\n+  typedef ResourceHashtable<void*, DumperClassCacheTableEntry*, TABLE_SIZE, AnyObj::C_HEAP, mtServiceability,\n@@ -831,0 +839,11 @@\n+  void unlink_all(PtrTable* table) {\n+    class CleanupEntry: StackObj {\n+    public:\n+      bool do_entry(void*& key, DumperClassCacheTableEntry*& entry) {\n+        delete entry;\n+        return true;\n+      }\n+    } cleanup;\n+    table->unlink(&cleanup);\n+  }\n+\n@@ -850,0 +869,8 @@\n+\n+      if (_ptrs->number_of_entries() >= CACHE_TOP) {\n+        \/\/ We do not track the individual hit rates for table entries.\n+        \/\/ Purge the entire table, and let the cache catch up with new\n+        \/\/ distribution.\n+        unlink_all(_ptrs);\n+      }\n+\n@@ -865,8 +892,1 @@\n-    class CleanupEntry: StackObj {\n-    public:\n-      bool do_entry(void*& key, DumperClassCacheTableEntry*& entry) {\n-        delete entry;\n-        return true;\n-      }\n-    } cleanup;\n-    _ptrs->unlink(&cleanup);\n+    unlink_all(_ptrs);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"}]}