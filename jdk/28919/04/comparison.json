{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * invocation for an object whose last client has terminated abnorally\n+ * invocation for an object whose last client has terminated abnormally\n@@ -37,1 +37,0 @@\n- * @author Peter Jones\n@@ -48,0 +47,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -50,1 +51,0 @@\n-import java.rmi.registry.LocateRegistry;\n@@ -54,0 +54,3 @@\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.CountDownLatch;\n@@ -58,0 +61,1 @@\n+    \/\/ lease expiry time (milliseconds)\n@@ -59,1 +63,3 @@\n-    private static final long TIMEOUT = 20000;\n+    \/\/ the maximum allowed duration between the lease expiration and\n+    \/\/ the Unreferenced.unreferenced() callback method to be invoked\n+    private static final Duration EXPECTED_MAX_DURATION = Duration.ofMinutes(1);\n@@ -61,2 +67,2 @@\n-    private Object lock = new Object();\n-    private boolean unreferencedInvoked = false;\n+    \/\/ will be counted down when Unreferenced.unreferenced() is invoked\n+    private static final CountDownLatch callbackInvocationLatch = new CountDownLatch(1);\n@@ -64,0 +70,1 @@\n+    @Override\n@@ -65,5 +72,2 @@\n-        System.err.println(\"unreferenced() method invoked\");\n-        synchronized (lock) {\n-            unreferencedInvoked = true;\n-            lock.notify();\n-        }\n+        System.err.println(\"[\" + Instant.now() + \"] unreferenced() method invoked\");\n+        callbackInvocationLatch.countDown();\n@@ -73,3 +77,0 @@\n-\n-        System.err.println(\"\\nRegression test for bug 4285878\\n\");\n-\n@@ -93,1 +94,1 @@\n-            System.err.println(\"created local registry\");\n+            System.err.println(\"created local registry on port \" + registryPort);\n@@ -98,26 +99,22 @@\n-            synchronized (obj.lock) {\n-                System.err.println(\"starting remote client VM...\");\n-                jvm = new JavaVM(\"SelfTerminator\", \"-Drmi.registry.port=\" +\n-                            registryPort, \"\");\n-                jvm.start();\n-\n-                System.err.println(\"waiting for unreferenced() callback...\");\n-                obj.lock.wait(TIMEOUT);\n-\n-                if (obj.unreferencedInvoked) {\n-                    System.err.println(\"TEST PASSED: \" +\n-                        \"unreferenced() invoked in timely fashion\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"TEST FAILED: unreferenced() not invoked after \" +\n-                        ((double) TIMEOUT \/ 1000.0) + \" seconds\");\n-                }\n-            }\n-\n-        } catch (Exception e) {\n-            if (e instanceof RuntimeException) {\n-                throw (RuntimeException) e;\n-            } else {\n-                throw new RuntimeException(\n-                    \"TEST FAILED: unexpected exception: \" + e.toString());\n-            }\n+            Path outputFile = Files.createTempFile(Path.of(\".\"), \"4285878-\", \".txt\");\n+            System.err.println(\"starting remote client VM...\");\n+            jvm = new JavaVM(\"SelfTerminator\", \"-Drmi.registry.port=\" +\n+                        registryPort, outputFile.toAbsolutePath().toString());\n+            \/\/ launch the self terminating java application which will lookup\n+            \/\/ the bound object and then terminate itself. before terminating\n+            \/\/ it will write the time at which it is terminating, into the\n+            \/\/ output file\n+            jvm.start();\n+\n+            System.err.println(\"waiting for unreferenced() callback...\");\n+            callbackInvocationLatch.await();\n+            Instant waitEndedAt = Instant.now();\n+            final String content = Files.readString(outputFile);\n+            System.err.println(\"content in \" + outputFile + \": \" + content);\n+            \/\/ parse the time, representing the time at which the SelfTerminator\n+            \/\/ application termination started\n+            final Instant terminationStartedAt = Instant.parse(content);\n+            final Duration waitDuration = assertWithinExpectedTimeLimit(waitEndedAt,\n+                    terminationStartedAt);\n+            System.err.println(\"TEST PASSED: unreferenced() invoked in timely\" +\n+                    \" fashion (duration=\" + waitDuration + \")\");\n@@ -138,0 +135,18 @@\n+\n+    \/*\n+     * Verifies that the duration between the lease expiration and the callback\n+     * invocation is within the expected limit. Throws an exception if the wait\n+     * duration is larger than expected limit, else returns the actual wait duration.\n+     *\/\n+    private static Duration assertWithinExpectedTimeLimit(final Instant waitEndedAt,\n+                                                          final Instant terminationStartedAt) {\n+\n+        final Duration waitDuration = Duration.between(terminationStartedAt, waitEndedAt);\n+        System.out.println(\"wait completed in \" + waitDuration);\n+        if (waitDuration.compareTo(EXPECTED_MAX_DURATION) > 0) {\n+            throw new RuntimeException(\"Took unexpectedly long (duration=\" +\n+                    waitDuration + \") to invoke Unreferenced.unreferenced(),\" +\n+                    \" expected max duration=\" + EXPECTED_MAX_DURATION);\n+        }\n+        return waitDuration;\n+    }\n","filename":"test\/jdk\/java\/rmi\/server\/Unreferenced\/leaseCheckInterval\/LeaseCheckInterval.java","additions":57,"deletions":42,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,2 @@\n-\/*\n- *\n- *\/\n-\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -31,0 +29,1 @@\n+import java.time.Instant;\n@@ -34,1 +33,1 @@\n-    public static void main(String[] args) {\n+    public static void main(String[] args) throws Exception {\n@@ -36,0 +35,3 @@\n+            log(\"main() invoked\");\n+            Path outputFile = Path.of(args[0]);\n+            log(\"output file \" + outputFile);\n@@ -41,0 +43,3 @@\n+            log(\"looked up binding, now terminating the process\");\n+            \/\/ write out the time at which we are terminating the process\n+            Files.writeString(outputFile, Instant.now().toString());\n@@ -42,2 +47,4 @@\n-        } catch (Exception e) {\n-            e.printStackTrace();\n+        } catch (Throwable t) {\n+            log(\"failure: \" + t);\n+            t.printStackTrace();\n+            throw t; \/\/ propagate any failures and fail the process\n@@ -46,0 +53,5 @@\n+\n+    private static void log(final String message) {\n+        final Instant now = Instant.now();\n+        System.err.println(\"[\" + now + \"] \" + SelfTerminator.class.getName() + \" - \" + message);\n+    }\n","filename":"test\/jdk\/java\/rmi\/server\/Unreferenced\/leaseCheckInterval\/SelfTerminator.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"}]}