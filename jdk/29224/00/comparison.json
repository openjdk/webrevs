{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-#ifdef _LP64\n@@ -40,3 +39,0 @@\n-#else\n-    \"eax\", \"ecx\", \"edx\", \"ebx\", \"esp\", \"ebp\", \"esi\", \"edi\"\n-#endif \/\/ _LP64\n@@ -57,1 +53,0 @@\n-#ifdef _LP64\n@@ -61,1 +56,0 @@\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-\/\/ The implementation of integer registers for the x86\/x64 architectures.\n+\/\/ The implementation of integer registers for the x64 architectures.\n@@ -47,5 +47,3 @@\n-  enum {\n-    number_of_registers      = LP64_ONLY( 32 ) NOT_LP64( 8 ),\n-    number_of_byte_registers = LP64_ONLY( 32 ) NOT_LP64( 4 ),\n-    max_slots_per_register   = LP64_ONLY(  2 ) NOT_LP64( 1 )\n-  };\n+  static const int number_of_registers      = 32;\n+  static const int number_of_byte_registers = 32;\n+  static const int max_slots_per_register   =  2;\n@@ -82,1 +80,0 @@\n-#ifdef _LP64\n@@ -86,1 +83,0 @@\n-#endif \/\/ _LP64\n@@ -119,3 +115,2 @@\n-#ifdef _LP64\n-constexpr Register r8  = as_Register( 8);\n-constexpr Register r9  = as_Register( 9);\n+constexpr Register r8  = as_Register(8);\n+constexpr Register r9  = as_Register(9);\n@@ -144,1 +139,0 @@\n-#endif \/\/ _LP64\n@@ -157,4 +151,2 @@\n-  enum {\n-    number_of_registers    = 8,\n-    max_slots_per_register = 2\n-  };\n+  static const int number_of_registers    = 8;\n+  static const int max_slots_per_register = 2;\n@@ -220,4 +212,2 @@\n-  enum {\n-    number_of_registers    = LP64_ONLY( 32 ) NOT_LP64(  8 ),\n-    max_slots_per_register = LP64_ONLY( 16 ) NOT_LP64( 16 )   \/\/ 512-bit\n-  };\n+  static const int number_of_registers    =  32;\n+  static const int max_slots_per_register =  16; \/\/ 512-bit\n@@ -253,1 +243,0 @@\n-#ifdef _LP64\n@@ -257,1 +246,0 @@\n-#endif \/\/ _LP64\n@@ -290,1 +278,0 @@\n-#ifdef _LP64\n@@ -315,1 +302,0 @@\n-#endif \/\/ _LP64\n@@ -397,5 +383,4 @@\n-  enum {\n-    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n-    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n-    max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register,\n-    max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register,\n+    static const int max_gpr = Register::number_of_registers * Register::max_slots_per_register;\n+    static const int max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register;\n+    static const int max_xmm = max_fpr + XMMRegister::number_of_registers * XMMRegister::max_slots_per_register;\n+    static const int max_kpr = max_xmm + KRegister::number_of_registers * KRegister::max_slots_per_register;\n@@ -407,9 +392,2 @@\n-\n-    \/\/ x86_32.ad defines additional dummy FILL0-FILL7 registers, in order to tally\n-    \/\/ REG_COUNT (computed by ADLC based on the number of reg_defs seen in .ad files)\n-    \/\/ with ConcreteRegisterImpl::number_of_registers additional count of 8 is being\n-    \/\/ added for 32 bit jvm.\n-    number_of_registers = max_kpr +       \/\/ gpr\/fpr\/xmm\/kpr\n-                          NOT_LP64( 8 + ) \/\/ FILL0-FILL7 in x86_32.ad\n-                          1               \/\/ eflags\n-  };\n+    static const int number_of_registers = max_kpr + \/\/ gpr\/fpr\/xmm\/kpr\n+                                           1;        \/\/ eflags\n","filename":"src\/hotspot\/cpu\/x86\/register_x86.hpp","additions":17,"deletions":39,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-#ifdef AMD64\n@@ -37,1 +36,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,4 +55,1 @@\n-\n-  assert( is_Register(), \"must be\");\n-  \/\/ Yuk\n-#ifdef AMD64\n+  assert(is_Register(), \"must be\");\n@@ -60,3 +57,0 @@\n-#else\n-  return ::as_Register(value());\n-#endif \/\/ AMD64\n@@ -85,3 +79,0 @@\n-#ifndef AMD64\n-  if (is_Register()) return true;\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-  return VMRegImpl::as_VMReg(encoding() LP64_ONLY( << 1 ));\n+  return VMRegImpl::as_VMReg(encoding() << 1);\n","filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}