{"files":[{"patch":"@@ -1,4 +1,3 @@\n-\/* Copyright (c) 2018, Cavium. All rights reserved. (By BELLSOFT)\n- * Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n- * Intel Math Library (LIBM) Source Code\n- *\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_log.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+        failures += testLogMonotonicityNeighborhoods();\n+        failures += testLogMinValueEquality();\n@@ -95,0 +97,64 @@\n+\n+    \/**\n+     * Neighborhood monotonicity: probe tight neighborhoods around\n+     * exp(k) and powers-of-two boundaries using nextDown\/nextUp.\n+     * For each center value c, build array:\n+     * {nextDown(nextDown(c)), nextDown(c), c, nextUp(c), nextUp(nextUp(c))}\n+     * and assert non-decreasing order for Math.log and StrictMath.log.\n+     *\/\n+    private static int testLogMonotonicityNeighborhoods() {\n+        int failures = 0;\n+        \/\/ exp(k) neighborhoods\n+        failures += probeNeighborhoods(k -> StrictMath.pow(Math.E, k));\n+        \/\/ 2^k neighborhoods\n+        failures += probeNeighborhoods(k -> Math.scalb(1.0, k));\n+        return failures;\n+    }\n+\n+    private static int probeNeighborhoods(java.util.function.IntToDoubleFunction centerFunc) {\n+        int failures = 0;\n+        for (int k = -36; k <= 36; k++) {\n+            double c = centerFunc.applyAsDouble(k);\n+            if (!(c > 0.0) || Double.isInfinite(c) || Double.isNaN(c)) continue; \/\/ skip invalid centers\n+            double[] n = new double[5];\n+            n[2] = c;\n+            n[1] = Math.nextDown(c);\n+            n[0] = Math.nextDown(n[1]);\n+            n[3] = Math.nextUp(c);\n+            n[4] = Math.nextUp(n[3]);\n+            double[] ml = new double[5];\n+            double[] sl = new double[5];\n+            for (int i = 0; i < n.length; i++) {\n+                ml[i] = Math.log(n[i]);\n+                sl[i] = StrictMath.log(n[i]);\n+            }\n+            for (int i = 0; i < n.length - 1; i++) {\n+                if (ml[i] > ml[i+1]) {\n+                    failures++;\n+                    System.err.println(\"Monotonicity failure Math.log at k=\" + k + \" values \" + n[i] + \", \" + n[i+1]);\n+                }\n+                if (sl[i] > sl[i+1]) {\n+                    failures++;\n+                    System.err.println(\"Monotonicity failure StrictMath.log at k=\" + k + \" values \" + n[i] + \", \" + n[i+1]);\n+                }\n+            }\n+        }\n+        return failures;\n+    }\n+\n+    \/**\n+     * Equality check: Math.log(Double.MIN_VALUE) should equal StrictMath.log(Double.MIN_VALUE)\n+     * (Used to be a standalone TestLogMinValue.java). Ensures intrinsic does not diverge at subnormal minimum.\n+     *\/\n+    private static int testLogMinValueEquality() {\n+        int failures = 0;\n+        double x = Double.MIN_VALUE;\n+        double mathLog = Math.log(x);\n+        double strictLog = StrictMath.log(x);\n+        if (Double.doubleToRawLongBits(mathLog) != Double.doubleToRawLongBits(strictLog)) {\n+            failures++;\n+            System.err.println(\"Mismatch: Math.log(Double.MIN_VALUE)=\" + mathLog +\n+                               \" StrictMath.log(Double.MIN_VALUE)=\" + strictLog);\n+        }\n+        return failures;\n+    }\n","filename":"test\/jdk\/java\/lang\/Math\/LogTests.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8308776\n- * @build Tests\n- * @summary Compare Math.log and StrictMath.log for Double.MIN_VALUE (denormal smallest positive) to ensure consistency.\n- * @run main TestLogMinValue\n- *\/\n-public class TestLogMinValue {\n-    public static void main(String[] args) {\n-        double x = Double.MIN_VALUE; \/\/ 4.9E-324\n-        double mathLog = Math.log(x);\n-        double strictLog = StrictMath.log(x);\n-        if (Double.isNaN(mathLog) || Double.isNaN(strictLog)) {\n-            throw new AssertionError(\"Unexpected NaN for log(Double.MIN_VALUE)\");\n-        }\n-        if (mathLog != strictLog) {\n-            throw new AssertionError(\"Mismatch: Math.log=\" + mathLog + \" StrictMath.log=\" + strictLog);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Math\/TestLogMinValue.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test 8308776\n- * @summary Validate monotonicity of Math.log over an ascending sequence of positive double values\n- * @run main TestLogMonotonicity\n- *\/\n-public class TestLogMonotonicity {\n-    public static void main(String[] args) {\n-        double[] values = buildAscendingValues();\n-        double prev = Double.NEGATIVE_INFINITY;\n-        for (double v : values) {\n-            double lv = Math.log(v);\n-            if (Double.isNaN(lv)) {\n-                throw new AssertionError(\"Unexpected NaN for Math.log(\" + v + \")\");\n-            }\n-            if (!(lv > prev)) {\n-                throw new AssertionError(\"Math.log not strictly increasing: prev=\" + prev + \" current=\" + lv + \" value=\" + v);\n-            }\n-            prev = lv;\n-        }\n-    }\n-\n-    private static double[] buildAscendingValues() {\n-        java.util.ArrayList<Double> list = new java.util.ArrayList<>();\n-        \/\/ Subnormal range doubling until normal threshold\n-        double v = Double.MIN_VALUE;\n-        while (v < Double.MIN_NORMAL) {\n-            list.add(v);\n-            double nv = v * 2.0;\n-            if (nv == v)\n-                break;\n-            v = nv;\n-        }\n-        \/\/ Transition normals\n-        list.add(Double.MIN_NORMAL);\n-        list.add(Double.MIN_NORMAL * 2);\n-        \/\/ Powers of two 2^1 .. 2^16\n-        for (int i = 1; i <= 16; i++) {\n-            list.add(Math.pow(2.0, i));\n-        }\n-        \/\/ Some arbitrary increasing magnitudes\n-        list.add(Double.MAX_VALUE \/ 2.0); \/\/ large but avoid overflow\n-        list.add(Double.MAX_VALUE);\n-        double[] arr = new double[list.size()];\n-        for (int i = 0; i < list.size(); i++) arr[i] = list.get(i);\n-        return arr;\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Math\/TestLogMonotonicity.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"}]}