{"files":[{"patch":"@@ -52,0 +52,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -868,2 +869,0 @@\n-            \"RootPane.altPress\", true,\n-\n@@ -1460,0 +1459,17 @@\n+\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                addKeyEventPostProcessor(MnemonicHandler.altProcessor);\n+\n+        \/\/ By default mnemonics are hidden for GTK L&F\n+        MnemonicHandler.setMnemonicHidden(true);\n+    }\n+\n+    \/**\n+     * Called by UIManager when this look and feel is uninstalled.\n+     *\/\n+    @Override\n+    public void uninitialize() {\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                removeKeyEventPostProcessor(MnemonicHandler.altProcessor);\n+        MnemonicHandler.setMnemonicHidden(false);\n+        super.uninitialize();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.awt.Container;\n@@ -36,1 +35,0 @@\n-import java.awt.Window;\n@@ -38,1 +36,0 @@\n-import javax.swing.AbstractButton;\n@@ -42,1 +39,0 @@\n-import javax.swing.JLabel;\n@@ -45,1 +41,0 @@\n-import javax.swing.UIManager;\n@@ -51,0 +46,1 @@\n+import sun.swing.MnemonicHandler;\n@@ -676,2 +672,1 @@\n-                if (UIManager.getBoolean(\"RootPane.altPress\")\n-                    && SynthLookAndFeel.isMnemonicHidden()) {\n+                if (mnemIndex >= 0 && MnemonicHandler.isMnemonicHidden()) {\n@@ -747,37 +742,0 @@\n-\n-    \/*\n-     * Repaints all the components with the mnemonics in the given window and all its owned windows.\n-     *\/\n-    static void repaintMnemonicsInWindow(final Window w) {\n-        if (w == null || !w.isShowing()) {\n-            return;\n-        }\n-\n-        final Window[] ownedWindows = w.getOwnedWindows();\n-        for (final Window element : ownedWindows) {\n-            repaintMnemonicsInWindow(element);\n-        }\n-\n-        repaintMnemonicsInContainer(w);\n-    }\n-\n-    \/*\n-     * Repaints all the components with the mnemonics in container.\n-     * Recursively searches for all the subcomponents.\n-     *\/\n-    static void repaintMnemonicsInContainer(final Container cont) {\n-        final Component[] elements = cont.getComponents();\n-        for (final Component c : elements) {\n-            if (c == null || !c.isVisible()) {\n-                continue;\n-            } else if (c instanceof AbstractButton && ((AbstractButton) c).getMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            } else if (c instanceof JLabel && ((JLabel) c).getDisplayedMnemonic() != '\\0') {\n-                c.repaint();\n-                continue;\n-            } else if (c instanceof Container){\n-                repaintMnemonicsInContainer((Container) c);\n-            }\n-        }\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthGraphicsUtils.java","additions":2,"deletions":44,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1044,30 +1044,0 @@\n-\n-    \/\/ Toggle flag for drawing the mnemonic state\n-    private static boolean isMnemonicHidden = true;\n-\n-    \/*\n-     * Sets the state of the hide mnemonic flag. This flag is used by the\n-     * component UI delegates to determine if the mnemonic should be rendered.\n-     * This method is a non operation if the underlying operating system\n-     * does not support the mnemonic hiding feature.\n-     *\/\n-    static void setMnemonicHidden(boolean hide) {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        } else {\n-            isMnemonicHidden = hide;\n-        }\n-    }\n-\n-    \/*\n-     * Gets the state of the hide mnemonic flag. This only has meaning\n-     * if this feature is supported by the underlying OS.\n-     *\/\n-    static boolean isMnemonicHidden() {\n-        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n-            \/\/ Do not hide mnemonics if the UI defaults do not support this\n-            isMnemonicHidden = false;\n-        }\n-        return isMnemonicHidden;\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthLookAndFeel.java","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.event.KeyEvent;\n@@ -44,2 +43,0 @@\n-    static final AltProcessor altProcessor = new AltProcessor();\n-    static boolean altProcessorInstalledFlag;\n@@ -80,5 +77,0 @@\n-        if (altProcessorInstalledFlag || UIManager.getBoolean(\"RootPane.altPress\")) {\n-            KeyboardFocusManager.getCurrentKeyboardFocusManager().\n-                    removeKeyEventPostProcessor(altProcessor);\n-            altProcessorInstalledFlag = false;\n-        }\n@@ -113,6 +105,0 @@\n-\n-        if (!altProcessorInstalledFlag && UIManager.getBoolean(\"RootPane.altPress\")) {\n-            KeyboardFocusManager.getCurrentKeyboardFocusManager().\n-                    addKeyEventPostProcessor(altProcessor);\n-            altProcessorInstalledFlag = true;\n-        }\n@@ -190,21 +176,0 @@\n-\n-    static class AltProcessor implements KeyEventPostProcessor {\n-        public boolean postProcessKeyEvent(KeyEvent ev) {\n-            if (ev.getKeyCode() != KeyEvent.VK_ALT) {\n-                return false;\n-            }\n-            final JRootPane root = SwingUtilities.getRootPane(ev.getComponent());\n-            final Window winAncestor = (root == null ? null : SwingUtilities.getWindowAncestor(root));\n-            switch(ev.getID()) {\n-                case KeyEvent.KEY_PRESSED:\n-                    SynthLookAndFeel.setMnemonicHidden(false);\n-                    break;\n-\n-                case KeyEvent.KEY_RELEASED:\n-                    SynthLookAndFeel.setMnemonicHidden(true);\n-                    break;\n-            }\n-            SynthGraphicsUtils.repaintMnemonicsInWindow(winAncestor);\n-            return false;\n-        }\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthRootPaneUI.java","additions":1,"deletions":36,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.swing;\n+\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.KeyEventPostProcessor;\n+import java.awt.Window;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.AbstractButton;\n+import javax.swing.JLabel;\n+import javax.swing.JRootPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+public class MnemonicHandler {\n+    public static final AltProcessor altProcessor = new AltProcessor();\n+\n+    protected static boolean isMnemonicHidden;\n+\n+    \/**\n+     * Gets the state of the hide mnemonic flag.\n+     * This only has meaning if this feature is supported by the underlying OS.\n+     *\n+     * @return true if mnemonics are hidden, otherwise, false\n+     *\/\n+    public static boolean isMnemonicHidden() {\n+        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n+            \/\/ Do not hide mnemonics if the UI defaults do not support this\n+            isMnemonicHidden = false;\n+        }\n+        return isMnemonicHidden;\n+    }\n+\n+    \/**\n+     * Sets the state of the hide mnemonic flag. This flag is used by the\n+     * component UI delegates to determine if the mnemonic should be rendered.\n+     * This method is a non operation if the underlying operating system\n+     * does not support the mnemonic hiding feature.\n+     *\n+     * @param hide true if mnemonics should be hidden\n+     *\/\n+    public static void setMnemonicHidden(final boolean hide) {\n+        if (UIManager.getBoolean(\"Button.showMnemonics\")) {\n+            \/\/ Do not hide mnemonics if the UI defaults do not support this\n+            isMnemonicHidden = false;\n+        } else {\n+            isMnemonicHidden = hide;\n+        }\n+    }\n+\n+    static class AltProcessor implements KeyEventPostProcessor {\n+        public boolean postProcessKeyEvent(final KeyEvent ev) {\n+            if (ev.getKeyCode() != KeyEvent.VK_ALT) {\n+                return false;\n+            }\n+\n+            final JRootPane root = SwingUtilities.getRootPane(ev.getComponent());\n+            final Window winAncestor = (root == null ? null : SwingUtilities.getWindowAncestor(root));\n+\n+            switch(ev.getID()) {\n+                case KeyEvent.KEY_PRESSED:\n+                    setMnemonicHidden(false);\n+                    break;\n+                case KeyEvent.KEY_RELEASED:\n+                    setMnemonicHidden(true);\n+                    break;\n+            }\n+\n+            repaintMnemonicsInWindow(winAncestor);\n+\n+            return false;\n+        }\n+    }\n+\n+    \/*\n+     * Repaints all the components with the mnemonics in the given window and all its owned windows.\n+     *\/\n+    static void repaintMnemonicsInWindow(final Window w) {\n+        if (w == null || !w.isShowing()) {\n+            return;\n+        }\n+\n+        final Window[] ownedWindows = w.getOwnedWindows();\n+        for (final Window element : ownedWindows) {\n+            repaintMnemonicsInWindow(element);\n+        }\n+\n+        repaintMnemonicsInContainer(w);\n+    }\n+\n+    \/*\n+     * Repaints all the components with the mnemonics in container.\n+     * Recursively searches for all the subcomponents.\n+     *\/\n+    static void repaintMnemonicsInContainer(final Container cont) {\n+        final Component[] elements = cont.getComponents();\n+        for (final Component c : elements) {\n+            if (c == null || !c.isVisible()) {\n+                continue;\n+            } else if (c instanceof AbstractButton && ((AbstractButton) c).getMnemonic() != '\\0') {\n+                c.repaint();\n+                continue;\n+            } else if (c instanceof JLabel && ((JLabel) c).getDisplayedMnemonic() != '\\0') {\n+                c.repaint();\n+                continue;\n+            } else if (c instanceof Container) {\n+                repaintMnemonicsInContainer((Container) c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/MnemonicHandler.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -24,11 +24,0 @@\n-\/*\n- * @test\n- * @bug 8326458\n- * @key headful\n- * @requires (os.family == \"linux\")\n- * @library \/javax\/swing\/regtesthelpers\n- * @build Util\n- * @summary Verifies if menu mnemonic toggle on Alt press in GTK LAF\n- * @run main TestMenuMnemonicOnAltPress\n- *\/\n-\n@@ -51,0 +40,11 @@\n+\/*\n+ * @test\n+ * @bug 8155030\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @library \/javax\/swing\/regtesthelpers\n+ * @build Util\n+ * @summary Verifies if menu mnemonic toggle on Alt press in GTK LAF\n+ * @run main TestMenuMnemonicOnAltPress\n+ *\/\n+\n@@ -55,3 +55,1 @@\n-    private static volatile Point pt;\n-    private static volatile int fileMenuWidth;\n-    private static volatile int fileMenuHeight;\n+    private static volatile Rectangle fileMenuRect;\n@@ -70,3 +68,2 @@\n-                pt = fileMenu.getLocationOnScreen();\n-                fileMenuWidth = fileMenu.getWidth();\n-                fileMenuHeight = fileMenu.getHeight();\n+                fileMenuRect = new Rectangle(fileMenu.getLocationOnScreen(),\n+                        fileMenu.getSize());\n@@ -78,2 +75,1 @@\n-            BufferedImage img1 = robot.createScreenCapture(new Rectangle(pt.x, pt.y,\n-                    fileMenuWidth, fileMenuHeight));\n+            BufferedImage img1 = robot.createScreenCapture(fileMenuRect);\n@@ -84,2 +80,1 @@\n-            BufferedImage img2 = robot.createScreenCapture(new Rectangle(pt.x, pt.y,\n-                    fileMenuWidth, fileMenuHeight));\n+            BufferedImage img2 = robot.createScreenCapture(fileMenuRect);\n@@ -89,2 +84,2 @@\n-                    ImageIO.write(img1, \"png\", new File(\"img1.png\"));\n-                    ImageIO.write(img2, \"png\", new File(\"img2.png\"));\n+                    ImageIO.write(img1, \"png\", new File(\"Menu_With_Mnemonic.png\"));\n+                    ImageIO.write(img2, \"png\", new File(\"Menu_Without_Mnemonic.png\"));\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/gtk\/TestMenuMnemonicOnAltPress.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"}]}