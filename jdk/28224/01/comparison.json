{"files":[{"patch":"@@ -2193,0 +2193,33 @@\n+\/\/ A supporting closure used to process ClassLoaderData roots.\n+class CLDRootsClosure: public OopClosure {\n+private:\n+  bool _continue;\n+public:\n+  CLDRootsClosure(): _continue(true) {}\n+\n+  inline bool stopped() {\n+    return !_continue;\n+  }\n+\n+  void do_oop(oop* obj_p) {\n+    if (stopped()) {\n+      return;\n+    }\n+\n+    oop o = NativeAccess<AS_NO_KEEPALIVE>::oop_load(obj_p);\n+    \/\/ ignore null\n+    if (o == nullptr) {\n+      return;\n+    }\n+\n+    jvmtiHeapReferenceKind kind = JVMTI_HEAP_REFERENCE_OTHER;\n+    if (o->klass() == vmClasses::Class_klass()) {\n+      kind = JVMTI_HEAP_REFERENCE_SYSTEM_CLASS;\n+    }\n+\n+    \/\/ invoke the callback\n+    _continue = CallbackInvoker::report_simple_root(kind, o);\n+  }\n+  virtual void do_oop(narrowOop* obj_p) { ShouldNotReachHere(); }\n+};\n+\n@@ -2779,2 +2812,2 @@\n-  blk.set_kind(JVMTI_HEAP_REFERENCE_SYSTEM_CLASS);\n-  CLDToOopClosure cld_closure(&blk, ClassLoaderData::_claim_none);\n+  CLDRootsClosure cld_roots_closure;\n+  CLDToOopClosure cld_closure(&cld_roots_closure, ClassLoaderData::_claim_none);\n@@ -2782,1 +2815,1 @@\n-  if (blk.stopped()) {\n+  if (cld_roots_closure.stopped()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371083\n+ * @summary Verify FollowReferences does not report non-classes roots as JVMTI_HEAP_REFERENCE_SYSTEM_CLASS\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:KindSystemClass\n+ *                          KindSystemClass\n+ *\/\n+\n+public class KindSystemClass {\n+\n+    static native int tagSysClasses();\n+    static native Object[] getObjectsWithTags();\n+\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"KindSystemClass\");\n+\n+        int tagged = tagSysClasses();\n+        System.out.println(\"Tagged \" + tagged + \" classes\");\n+\n+        Object[] objs = getObjectsWithTags();\n+        System.out.println(\"Tagged objects (total \" + objs.length + \"):\");\n+        int nonClassesCnt = 0;\n+        for (int i = 0; i < objs.length; i++) {\n+            Object obj = objs[i];\n+            String s;\n+            if (obj instanceof Class cls) {\n+                s = \"OK: \" + cls;\n+            } else {\n+                nonClassesCnt++;\n+                s = \"ERROR, not a class: \" + obj;\n+            }\n+            System.out.println(\"[\" + i + \"] \" + s);\n+        }\n+        if (nonClassesCnt != 0) {\n+            throw new RuntimeException(\"Found \" + nonClassesCnt + \" non-classes\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FollowReferences\/KindSystemClass\/KindSystemClass.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include \"jvmti_common.hpp\"\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static int class_counter = 0;\n+static int other_counter = 0;\n+\n+static jint JNICALL\n+heap_reference_callback(jvmtiHeapReferenceKind reference_kind,\n+                        const jvmtiHeapReferenceInfo* reference_info,\n+                        jlong class_tag,\n+                        jlong referrer_class_tag,\n+                        jlong size,\n+                        jlong* tag_ptr,\n+                        jlong* referrer_tag_ptr,\n+                        jint length,\n+                        void* user_data) {\n+  switch (reference_kind) {\n+  case JVMTI_HEAP_REFERENCE_SYSTEM_CLASS:\n+    *tag_ptr = ++class_counter;\n+    break;\n+  case JVMTI_HEAP_REFERENCE_OTHER:\n+    ++other_counter;\n+    break;\n+  default:\n+    break;\n+  }\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Java_KindSystemClass_tagSysClasses(JNIEnv* jni, jclass clazz) {\n+  jvmtiHeapCallbacks callbacks = {};\n+  callbacks.heap_reference_callback = heap_reference_callback;\n+\n+  jvmtiError err = jvmti->FollowReferences(0 \/* filter nothing *\/,\n+                                           nullptr \/* no class filter *\/,\n+                                           nullptr \/* no initial object, follow roots *\/,\n+                                           &callbacks,\n+                                           nullptr);\n+  check_jvmti_error(err, \"FollowReferences failed\");\n+\n+  LOG(\"JVMTI_HEAP_REFERENCE_SYSTEM_CLASS: %d, JVMTI_HEAP_REFERENCE_OTHER: %d\\n\", class_counter, other_counter);\n+\n+  return class_counter;\n+}\n+\n+extern \"C\" JNIEXPORT jobjectArray JNICALL\n+Java_KindSystemClass_getObjectsWithTags(JNIEnv* jni, jclass clazz) {\n+  \/\/ request tagged objects with tags 1..class_counter\n+  jlong* tags = nullptr;\n+  jvmtiError err = jvmti->Allocate(class_counter * sizeof(jlong), (unsigned char**)&tags);\n+  check_jvmti_error(err, \"Allocate failed\");\n+\n+  for (int i = 0; i < class_counter; i++) {\n+    tags[i] = i + 1;\n+  }\n+\n+  jint count = 0;\n+  jobject* objects = nullptr;\n+\n+  err = jvmti->GetObjectsWithTags(class_counter, tags,\n+                                  &count, &objects, nullptr);\n+  check_jvmti_error(err, \"GetObjectsWithTags failed\");\n+\n+  jclass object_klass = jni->FindClass(\"java\/lang\/Object\");\n+  jobjectArray array = jni->NewObjectArray(count, object_klass, nullptr);\n+\n+  for (jint i = 0; i < count; i++) {\n+    jni->SetObjectArrayElement(array, i, objects[i]);\n+  }\n+\n+  deallocate(jvmti, jni, objects);\n+\n+  return array;\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv(reinterpret_cast<void**>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    abort();\n+  }\n+  jvmtiCapabilities capabilities;\n+  memset(&capabilities, 0, sizeof(capabilities));\n+  capabilities.can_tag_objects = 1;\n+  check_jvmti_error(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+  return JVMTI_ERROR_NONE;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FollowReferences\/KindSystemClass\/libKindSystemClass.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"}]}