{"files":[{"patch":"@@ -4415,1 +4415,1 @@\n-operand immI8_shift8()\n+operand immIDupV()\n@@ -4417,2 +4417,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4427,1 +4426,1 @@\n-operand immL8_shift8()\n+operand immLDupV()\n@@ -4429,2 +4428,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4438,0 +4436,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immHDupV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -4878,1 +4878,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -4901,1 +4901,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -4912,2 +4912,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -4915,1 +4916,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -4917,1 +4918,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -4919,6 +4919,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3110,1 +3110,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -3133,1 +3133,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -3144,2 +3144,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -3147,1 +3148,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -3149,1 +3150,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -3151,6 +3151,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -437,0 +437,5 @@\n+bool Assembler::operand_valid_for_sve_dup_immediate(int64_t imm) {\n+  return ((imm >= -128 && imm <= 127) ||\n+          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32512));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4327,0 +4327,1 @@\n+  static bool operand_valid_for_sve_dup_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/* Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8361582\n+* @summary Ensure the correct backend replicate node is being generated for\n+*          half precision float constants on >16B SVE machines\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm compiler.c2.aarch64.TestFloat16Replicate\n+*\/\n+\n+package compiler.c2.aarch64;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Arrays;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.*;\n+\n+import static java.lang.Float.*;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class TestFloat16Replicate {\n+    private static short[] input;\n+    private static short[] output;\n+\n+    \/\/ Choose FP16_IN_RANGE which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_IN_RANGE = Float16.shortBitsToFloat16((short)512);\n+\n+    \/\/ Choose a value out of the range of [-128 << 8, 127 << 8] or a non multiple of 256 for FP16_OUT_OF_RANGE\n+    private static final Float16 FP16_OUT_OF_RANGE = Float16.shortBitsToFloat16((short)1035);\n+\n+    private static final int LEN = 1024;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n+    }\n+\n+    static {\n+        input  = new short[LEN];\n+        output = new short[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            input[i] = (short) i;\n+        }\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 immediate is a signed value within the\n+    \/\/ range [-128, 127] or a signed multiple of 256 in the range [-32768, 32512] for element widths of\n+    \/\/ 16 bits or higher then the backend should generate the \"replicateHF_imm_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF_IMM8, \">0\"},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_IN_RANGE));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddInRange\")\n+    public void checkResultFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_IN_RANGE.floatValue());\n+            if (expected != output[i]) {\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_IN_RANGE + \" actual = \" + output[i] +  \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 constant falls outside the immediate\n+    \/\/ range accepted by the SVE \"dup\" instruction, the backend must:\n+    \/\/   1. Generate the \"loadConH\" machnode to load the FP16 constant from the constant pool.\n+    \/\/   2. Emit the \"replicateHF\" machnode to broadcast this loaded constant into an SVE register.\n+    \/\/ In this case, the backend should not generate the \"replicateHF_imm8_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF, \">0\"},\n+        failOn = {IRNode.REPLICATE_HF_IMM8},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_OUT_OF_RANGE));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddOutOfRange\")\n+    public void checkResultFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_OUT_OF_RANGE.floatValue());\n+            if (expected != output[i]) {\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_OUT_OF_RANGE + \" actual = \" + output[i] +  \" expected = \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2899,0 +2899,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}