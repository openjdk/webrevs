{"files":[{"patch":"@@ -439,1 +439,1 @@\n-          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32767));\n+          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32512));\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-*          half precision float constants on >=32B SVE machines\n+*          half precision float constants on >16B SVE machines\n@@ -35,1 +35,0 @@\n-import compiler.lib.generators.*;\n@@ -37,1 +36,0 @@\n-import java.lang.Math;\n@@ -39,1 +37,0 @@\n-import java.util.stream.IntStream;\n@@ -43,1 +40,0 @@\n-import static compiler.lib.generators.Generators.G;\n@@ -51,2 +47,2 @@\n-   \/\/ Choose FP16_CONST1 which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n-    private static final Float16 FP16_CONST1 = Float16.shortBitsToFloat16((short)512);\n+   \/\/ Choose FP16_IN_RANGE which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_IN_RANGE = Float16.shortBitsToFloat16((short)512);\n@@ -54,2 +50,2 @@\n-    \/\/ Choose a value out of the range of [-128 << 8, 127 << 8] or a non multiple of 256 for FP16_CONST2\n-    private static final Float16 FP16_CONST2 = Float16.shortBitsToFloat16((short)1035);\n+    \/\/ Choose a value out of the range of [-128 << 8, 127 << 8] or a non multiple of 256 for FP16_OUT_OF_RANGE\n+    private static final Float16 FP16_OUT_OF_RANGE = Float16.shortBitsToFloat16((short)1035);\n@@ -67,2 +63,3 @@\n-        Generator<Short> gen = G.float16s();\n-        IntStream.range(0, LEN).forEach(i -> {input[i] = gen.next();});\n+        for (int i = 0; i < LEN; i++) {\n+            input[i] = (short) i;\n+        }\n@@ -71,4 +68,5 @@\n-    \/\/ For a loop which is vectorizable and has an FP16 constant as one of the inputs, the (dst (Replicate con)) IR\n-    \/\/ will be generated. On SVE machines with vector length > 16B, the backend machnode - \"replicateHF_imm_gt128b\"\n-    \/\/ should be generated if the immediate is a signed value within the range [-128, 127] or a signed multiple of\n-    \/\/ 256 in the range [-32768, 32512] for element widths of 16 bits or higher\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 immediate is a signed value within the\n+    \/\/ range [-128, 127] or a signed multiple of 256 in the range [-32768, 32512] for element widths of\n+    \/\/ 16 bits or higher then the backend should generate the \"replicateHF_imm_gt128b\" machnode.\n@@ -79,1 +77,1 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n@@ -81,1 +79,1 @@\n-    public void Float16AddConstInput1() {\n+    public void TestFloat16AddInRange() {\n@@ -83,1 +81,1 @@\n-            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_CONST1));\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_IN_RANGE));\n@@ -87,2 +85,2 @@\n-    @Check(test=\"Float16AddConstInput1\")\n-    public void checkResultFloat16AddConstInput1() {\n+    @Check(test=\"TestFloat16AddInRange\")\n+    public void checkResultFloat16AddInRange() {\n@@ -90,1 +88,1 @@\n-            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_CONST1.floatValue());\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_IN_RANGE.floatValue());\n@@ -92,1 +90,1 @@\n-                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_CONST1 + \" actual = \" + output[i] +  \" expected = \" + expected);\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_IN_RANGE + \" actual = \" + output[i] +  \" expected = \" + expected);\n@@ -97,6 +95,7 @@\n-    \/\/ For a loop which is vectorizable and has an FP16 constant as one of the inputs, the (dst (Replicate con)) IR\n-    \/\/ will be generated. On SVE machines with vector length > 16B, the backend machnode - \"replicateHF\" should be\n-    \/\/ generated in cases where the immediate falls out of the permissible range of values that are acceptable by the\n-    \/\/ SVE \"dup\" instruction. This results in loading the FP16 constant from the constant pool which is then broadcasted\n-    \/\/ to an SVE register for further operations. The backend machnode - \"replicateHF_imm8_gt128b\" should not be\n-    \/\/ generated.\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 constant falls outside the immediate\n+    \/\/ range accepted by the SVE \"dup\" instruction, the backend must:\n+    \/\/   1. Generate the \"loadConH\" machnode to load the FP16 constant from the constant pool.\n+    \/\/   2. Emit the \"replicateHF\" machnode to broadcast this loaded constant into an SVE register.\n+    \/\/ In this case, the backend should not generate the \"replicateHF_imm8_gt128b\" machnode.\n@@ -108,1 +107,1 @@\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n@@ -110,1 +109,1 @@\n-    public void Float16AddConstInput2() {\n+    public void TestFloat16AddOutOfRange() {\n@@ -112,1 +111,1 @@\n-            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_CONST2));\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_OUT_OF_RANGE));\n@@ -116,2 +115,2 @@\n-    @Check(test=\"Float16AddConstInput2\")\n-    public void checkResultFloat16AddConstInput2() {\n+    @Check(test=\"TestFloat16AddOutOfRange\")\n+    public void checkResultFloat16AddOutOfRange() {\n@@ -119,1 +118,1 @@\n-            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_CONST2.floatValue());\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_OUT_OF_RANGE.floatValue());\n@@ -121,1 +120,1 @@\n-                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_CONST2 + \" actual = \" + output[i] +  \" expected = \" + expected);\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_OUT_OF_RANGE + \" actual = \" + output[i] +  \" expected = \" + expected);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"}]}