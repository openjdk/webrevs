{"files":[{"patch":"@@ -4417,2 +4417,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4429,2 +4428,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4438,0 +4436,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immH8_shift8()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4912,2 +4912,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -4915,1 +4916,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -4917,1 +4918,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -4919,6 +4919,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ as specified for the operand - immH8_shift8\n+instruct replicateHF_imm8_gt128b(vReg dst, immH8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3144,2 +3144,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -3147,1 +3148,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -3149,1 +3150,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -3151,6 +3151,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ as specified for the operand - immH8_shift8\n+instruct replicateHF_imm8_gt128b(vReg dst, immH8_shift8 con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -437,0 +437,5 @@\n+bool Assembler::operand_valid_for_sve_dup_immediate(int64_t imm) {\n+  return ((imm <= 127 && imm >= -128) ||\n+          (imm <= 32767 && imm >= -32768 && (imm & 0xff) == 0));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4327,0 +4327,1 @@\n+  static bool operand_valid_for_sve_dup_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/* Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8361582\n+* @summary Ensure the correct backend replicate node is being generated for\n+*          half precision float constants on >=32B SVE machines\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm compiler.c2.aarch64.TestFloat16Replicate\n+*\/\n+\n+package compiler.c2.aarch64;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import java.lang.Math;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.*;\n+\n+import static compiler.lib.generators.Generators.G;\n+import static java.lang.Float.*;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class TestFloat16Replicate {\n+    private static short[] input;\n+    private static short[] output;\n+\n+   \/\/ Choose FP16_CONST1 which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_CONST1 = Float16.shortBitsToFloat16((short)512);\n+\n+    \/\/ Choose a value out of the range of [-128 << 8, 127 << 8] or a non multiple of 256 for FP16_CONST2\n+    private static final Float16 FP16_CONST2 = Float16.shortBitsToFloat16((short)1035);\n+\n+    private static final int LEN = 1024;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n+    }\n+\n+    static {\n+        input  = new short[LEN];\n+        output = new short[LEN];\n+\n+        Generator<Short> gen = G.float16s();\n+        IntStream.range(0, LEN).forEach(i -> {input[i] = gen.next();});\n+    }\n+\n+    \/\/ For a loop which is vectorizable and has an FP16 constant as one of the inputs, the (dst (Replicate con)) IR\n+    \/\/ will be generated. On SVE machines with vector length > 16B, the backend machnode - \"replicateHF_imm_gt128b\"\n+    \/\/ should be generated if the immediate is a signed value within the range [-128, 127] or a signed multiple of\n+    \/\/ 256 in the range [-32768, 32512] for element widths of 16 bits or higher\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF_IMM8, \">0\"},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void Float16AddConstInput1() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_CONST1));\n+        }\n+    }\n+\n+    @Check(test=\"Float16AddConstInput1\")\n+    public void checkResultFloat16AddConstInput1() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_CONST1.floatValue());\n+            if (expected != output[i]) {\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_CONST1 + \" actual = \" + output[i] +  \" expected = \" + expected);\n+            }\n+        }\n+    }\n+\n+    \/\/ For a loop which is vectorizable and has an FP16 constant as one of the inputs, the (dst (Replicate con)) IR\n+    \/\/ will be generated. On SVE machines with vector length > 16B, the backend machnode - \"replicateHF\" should be\n+    \/\/ generated in cases where the immediate falls out of the permissible range of values that are acceptable by the\n+    \/\/ SVE \"dup\" instruction. This results in loading the FP16 constant from the constant pool which is then broadcasted\n+    \/\/ to an SVE register for further operations. The backend machnode - \"replicateHF_imm8_gt128b\" should not be\n+    \/\/ generated.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF, \">0\"},\n+        failOn = {IRNode.REPLICATE_HF_IMM8},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void Float16AddConstInput2() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_CONST2));\n+        }\n+    }\n+\n+    @Check(test=\"Float16AddConstInput2\")\n+    public void checkResultFloat16AddConstInput2() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input[i]) + FP16_CONST2.floatValue());\n+            if (expected != output[i]) {\n+                throw new AssertionError(\"Result Mismatch!, input = \" + input[i] + \" constant = \" + FP16_CONST2 + \" actual = \" + output[i] +  \" expected = \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -2899,0 +2899,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}