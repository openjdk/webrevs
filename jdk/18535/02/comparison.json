{"files":[{"patch":"@@ -0,0 +1,860 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment IntArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment LongArray\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8310190\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native\n+ *\/\n+\n+\/\/ FAILS: mixed providers currently do not vectorize. Maybe there is some inlining issue.\n+\/\/ \/*\n+\/\/  * @test id=mixed-array\n+\/\/  * @bug 8310190\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedArray\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=MixedBuffer\n+\/\/  * @bug 8310190\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment MixedBuffer\n+\/\/  *\/\n+\/\/\n+\/\/ \/*\n+\/\/  * @test id=mixed\n+\/\/  * @bug 8310190\n+\/\/  * @summary Test vectorization of loops over MemorySegment\n+\/\/  * @library \/test\/lib \/\n+\/\/  * @run driver compiler.loopopts.superword.TestMemorySegment Mixed\n+\/\/  *\/\n+\n+public class TestMemorySegment {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> ( () -> { return newMemorySegmentOfByteArray(); } );\n+            case \"CharArray\"        -> ( () -> { return newMemorySegmentOfCharArray(); } );\n+            case \"ShortArray\"       -> ( () -> { return newMemorySegmentOfShortArray(); } );\n+            case \"IntArray\"         -> ( () -> { return newMemorySegmentOfIntArray(); } );\n+            case \"LongArray\"        -> ( () -> { return newMemorySegmentOfLongArray(); } );\n+            case \"FloatArray\"       -> ( () -> { return newMemorySegmentOfFloatArray(); } );\n+            case \"DoubleArray\"      -> ( () -> { return newMemorySegmentOfDoubleArray(); } );\n+            case \"ByteBuffer\"       -> ( () -> { return newMemorySegmentOfByteBuffer(); } );\n+            case \"ByteBufferDirect\" -> ( () -> { return newMemorySegmentOfByteBufferDirect(); } );\n+            case \"Native\"           -> ( () -> { return newMemorySegmentOfNative(); } );\n+            case \"MixedArray\"       -> ( () -> { return newMemorySegmentOfMixedArray(); } );\n+            case \"MixedBuffer\"      -> ( () -> { return newMemorySegmentOfMixedBuffer(); } );\n+            case \"Mixed\"            -> ( () -> { return newMemorySegmentOfMixed(); } );\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ List of tests\n+    Map<String, TestFunction> tests = new HashMap<>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String, Object[]> golds = new HashMap<>();\n+\n+    public TestMemorySegmentImpl () {\n+        \/\/ Generate two MemorySegments as inputs\n+        MemorySegment a = newMemorySegment();\n+        MemorySegment b = newMemorySegment();\n+        fillRandom(a);\n+        fillRandom(b);\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"testMemorySegmentBadExitCheck\", () -> {\n+            return testMemorySegmentBadExitCheck(copy(a));\n+        });\n+        tests.put(\"testIntLoop_iv_byte\", () -> {\n+            return testIntLoop_iv_byte(copy(a));\n+        });\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_byte\", () -> {\n+            return testIntLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_byte\", () -> {\n+            return testIntLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_intInvar_byte\", () -> {\n+            return testIntLoop_longIndex_intInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_longInvar_byte\", () -> {\n+            return testIntLoop_longIndex_longInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_intIndex_intInvar_byte\", () -> {\n+            return testIntLoop_intIndex_intInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_iv_int\", () -> {\n+            return testIntLoop_iv_int(copy(a));\n+        });\n+        tests.put(\"testIntLoop_longIndex_intInvar_sameAdr_int\", () -> {\n+            return testIntLoop_longIndex_intInvar_sameAdr_int(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_longInvar_sameAdr_int\", () -> {\n+            return testIntLoop_longIndex_longInvar_sameAdr_int(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_intInvar_int\", () -> {\n+            return testIntLoop_longIndex_intInvar_int(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_longIndex_longInvar_int\", () -> {\n+            return testIntLoop_longIndex_longInvar_int(copy(a), 0);\n+        });\n+        tests.put(\"testIntLoop_intIndex_intInvar_int\", () -> {\n+            return testIntLoop_intIndex_intInvar_int(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_iv_byte\", () -> {\n+            return testLongLoop_iv_byte(copy(a));\n+        });\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_byte\", () -> {\n+            return testLongLoop_longIndex_intInvar_sameAdr_byte(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_byte\", () -> {\n+            return testLongLoop_longIndex_longInvar_sameAdr_byte(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_intInvar_byte\", () -> {\n+            return testLongLoop_longIndex_intInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_longInvar_byte\", () -> {\n+            return testLongLoop_longIndex_longInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_intIndex_intInvar_byte\", () -> {\n+            return testLongLoop_intIndex_intInvar_byte(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_iv_int\", () -> {\n+            return testLongLoop_iv_int(copy(a));\n+        });\n+        tests.put(\"testLongLoop_longIndex_intInvar_sameAdr_int\", () -> {\n+            return testLongLoop_longIndex_intInvar_sameAdr_int(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_longInvar_sameAdr_int\", () -> {\n+            return testLongLoop_longIndex_longInvar_sameAdr_int(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_intInvar_int\", () -> {\n+            return testLongLoop_longIndex_intInvar_int(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_longIndex_longInvar_int\", () -> {\n+            return testLongLoop_longIndex_longInvar_int(copy(a), 0);\n+        });\n+        tests.put(\"testLongLoop_intIndex_intInvar_int\", () -> {\n+            return testLongLoop_intIndex_intInvar_int(copy(a), 0);\n+        });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        MemorySegment.copy(src, 0, dst, 0, src.byteSize());\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static void fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+    }\n+\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate objects (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+\n+            if (!(g instanceof MemorySegment && r instanceof MemorySegment)) {\n+                throw new RuntimeException(\"verify \" + name + \": only MemorySegment supported, i=\" + i);\n+            }\n+\n+            MemorySegment mg = (MemorySegment)g;\n+            MemorySegment mr = (MemorySegment)r;\n+\n+            if (mg.byteSize() != mr.byteSize()) {\n+                throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same byteSize:\" +\n+                                       \" gold[\" + i + \"].byteSize = \" + mg.byteSize() +\n+                                       \" result[\" + i + \"].byteSize = \" + mr.byteSize());\n+            }\n+\n+            for (int j = 0; j < (int)mg.byteSize(); j++) {\n+                byte vg = mg.get(ValueLayout.JAVA_BYTE, j);\n+                byte vr = mr.get(ValueLayout.JAVA_BYTE, j);\n+                if (vg != vr) {\n+                    throw new RuntimeException(\"verify \" + name + \": MemorySegment must have same content:\" +\n+                                               \" gold[\" + i + \"][\" + j + \"] = \" + vg +\n+                                               \" result[\" + i + \"][\" + j + \"] = \" + vr);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = {\"testMemorySegmentBadExitCheck\",\n+                 \"testIntLoop_iv_byte\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testIntLoop_longIndex_intInvar_byte\",\n+                 \"testIntLoop_longIndex_longInvar_byte\",\n+                 \"testIntLoop_intIndex_intInvar_byte\",\n+                 \"testIntLoop_iv_int\",\n+                 \"testIntLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testIntLoop_longIndex_intInvar_int\",\n+                 \"testIntLoop_longIndex_longInvar_int\",\n+                 \"testIntLoop_intIndex_intInvar_int\",\n+                 \"testLongLoop_iv_byte\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_byte\",\n+                 \"testLongLoop_longIndex_intInvar_byte\",\n+                 \"testLongLoop_longIndex_longInvar_byte\",\n+                 \"testLongLoop_intIndex_intInvar_byte\",\n+                 \"testLongLoop_iv_int\",\n+                 \"testLongLoop_longIndex_intInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_longInvar_sameAdr_int\",\n+                 \"testLongLoop_longIndex_intInvar_int\",\n+                 \"testLongLoop_longIndex_longInvar_int\",\n+                 \"testLongLoop_intIndex_intInvar_int\"})\n+    void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS\n+    \/\/ Exit check: iv < long_limit      ->     (long)iv < long_limit\n+    \/\/ Thus, we have an int-iv, but a long-exit-check.\n+    \/\/ Is not properly recognized by either CountedLoop or LongCountedLoop\n+    static Object[] testMemorySegmentBadExitCheck(MemorySegment a) {\n+        for (int i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_byte(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize(); i++) {\n+            int int_index = i + invar;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_iv_int(MemorySegment a) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testIntLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testIntLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testIntLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (int i = 0; i < (int)a.byteSize()\/4; i++) {\n+            int int_index = i + invar;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_byte(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = i;\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr);\n+            a.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_byte(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            long adr1 = (long)(i) + (long)(invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, adr1);\n+            long adr2 = (long)(i) + (long)(invar);\n+            a.set(ValueLayout.JAVA_BYTE, adr2, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.ADD_VB,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_byte(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            int int_index = (int)(i + invar);\n+            byte v = a.get(ValueLayout.JAVA_BYTE, int_index);\n+            a.set(ValueLayout.JAVA_BYTE, int_index, (byte)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testLongLoop_iv_int(MemorySegment a) {\n+        for (long i = 0; i < a.byteSize()\/4; i++ ) {\n+            long adr = 4L * i;\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_intInvar_sameAdr_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    \/\/@IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+    \/\/              IRNode.ADD_VI,        \"> 0\",\n+    \/\/              IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/    applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/    applyIf = {\"AlignVector\", \"false\"},\n+    \/\/    applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: for native memory. I think it is because of invariants, but need investigation.\n+    \/\/        The long -> int loop conversion introduces extra invariants.\n+    static Object[] testLongLoop_longIndex_longInvar_sameAdr_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n+    \/\/ See: JDK-8330274\n+    static Object[] testLongLoop_longIndex_longInvar_int(MemorySegment a, long invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            long adr1 = 4L * (long)(i) + 4L * (long)(invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, adr1);\n+            long adr2 = 4L * (long)(i) + 4L * (long)(invar);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, adr2, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: RangeCheck cannot be eliminated because of int_index\n+    static Object[] testLongLoop_intIndex_intInvar_int(MemorySegment a, int invar) {\n+        for (long i = 0; i < a.byteSize()\/4; i++) {\n+            int int_index = (int)(i + invar);\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index);\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * int_index, (int)(v + 1));\n+        }\n+        return new Object[]{ a };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":860,"deletions":0,"binary":false,"changes":860,"status":"added"}]}