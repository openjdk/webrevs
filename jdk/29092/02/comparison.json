{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,5 @@\n-            readHeader(in);\n+            \/\/ we don't expect the stream to be at EOF\n+            \/\/ and if it is, then we want readHeader to\n+            \/\/ raise an exception, so we pass \"true\" for\n+            \/\/ the \"failOnEOF\" param.\n+            readHeader(in, true);\n@@ -193,0 +197,5 @@\n+     * If failOnEOF is false and if the given InputStream has already\n+     * reached EOF when this method was invoked, then this method returns\n+     * -1 (indicating that there's no GZIP member header).\n+     * In all other cases of malformed header or EOF being detected\n+     * when reading the header, this method will throw an IOException.\n@@ -194,1 +203,1 @@\n-    private int readHeader(InputStream this_in) throws IOException {\n+    private int readHeader(InputStream this_in, boolean failOnEOF) throws IOException {\n@@ -197,0 +206,23 @@\n+\n+        int magic;\n+        if (!failOnEOF) {\n+            \/\/ read an unsigned short value representing the GZIP magic header.\n+            \/\/ this is the same as calling readUShort(in), except that here,\n+            \/\/ when reading the first byte, we don't raise an EOFException\n+            \/\/ if the stream has already reached EOF.\n+\n+            \/\/ read unsigned byte\n+            int b = in.read();\n+            if (b == -1) { \/\/ EOF\n+                crc.reset();\n+                return -1; \/\/ represents no header bytes available\n+            }\n+            checkUnexpectedByte(b);\n+            \/\/ read the next unsigned byte to form the unsigned\n+            \/\/ short. we throw the usual EOFException\/ZipException\n+            \/\/ from this point on if there is no more data or\n+            \/\/ the data doesn't represent a header.\n+            magic = (readUByte(in) << 8) | b;\n+        } else {\n+            magic = readUShort(in);\n+        }\n@@ -198,1 +230,1 @@\n-        if (readUShort(in) != GZIP_MAGIC) {\n+        if (magic != GZIP_MAGIC) {\n@@ -264,1 +296,5 @@\n-            m += readHeader(in);    \/\/ next.header\n+            int numNextHeaderBytes = readHeader(in, false); \/\/ next.header (if available)\n+            if (numNextHeaderBytes == -1) {\n+                return true; \/\/ end of stream reached\n+            }\n+            m += numNextHeaderBytes;\n@@ -298,0 +334,5 @@\n+        checkUnexpectedByte(b);\n+        return b;\n+    }\n+\n+    private void checkUnexpectedByte(final int b) throws IOException {\n@@ -299,1 +340,1 @@\n-            \/\/ Report on this.in, not argument in; see read{Header, Trailer}.\n+            \/\/ report the InputStream type which returned this unexpected byte\n@@ -301,1 +342,1 @@\n-                + \".read() returned value out of range -1..255: \" + b);\n+                    + \".read() returned value out of range -1..255: \" + b);\n@@ -303,1 +344,0 @@\n-        return b;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"}]}