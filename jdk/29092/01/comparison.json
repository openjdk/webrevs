{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-            readHeader(in);\n+            readHeader(in, true);\n@@ -193,0 +193,5 @@\n+     * If failOnEOF is false and if the given InputStream has already\n+     * reached EOF when this method was invoked, then this method returns\n+     * -1 (indicating that there's no GZIP member header).\n+     * In all other cases of malformed header or EOF being detected\n+     * when reading the header, this method will throw an IOException.\n@@ -194,1 +199,1 @@\n-    private int readHeader(InputStream this_in) throws IOException {\n+    private int readHeader(InputStream this_in, boolean failOnEOF) throws IOException {\n@@ -197,0 +202,18 @@\n+\n+        int magic;\n+        if (!failOnEOF) {\n+            \/\/ read unsigned byte\n+            int b = in.read();\n+            if (b == -1) { \/\/ EOF\n+                crc.reset();\n+                return -1; \/\/ represents no header bytes available\n+            }\n+            checkUnexpectedByte(b);\n+            \/\/ read the next unsigned byte to form the unsigned\n+            \/\/ short. we throw the usual EOFException\/ZipException\n+            \/\/ from this point on if there is no more data or\n+            \/\/ the data doesn't represent a header.\n+            magic = (readUByte(in) << 8) | b;\n+        } else {\n+            magic = readUShort(in);\n+        }\n@@ -198,1 +221,1 @@\n-        if (readUShort(in) != GZIP_MAGIC) {\n+        if (magic != GZIP_MAGIC) {\n@@ -237,0 +260,1 @@\n+        assert n > 0 : \"incorrect number of header bytes: \" + n;\n@@ -264,1 +288,5 @@\n-            m += readHeader(in);    \/\/ next.header\n+            int numNextHeaderBytes = readHeader(in, false); \/\/ next.header (if available)\n+            if (numNextHeaderBytes == -1) {\n+                return true; \/\/ end of stream reached\n+            }\n+            m += numNextHeaderBytes;\n@@ -298,0 +326,5 @@\n+        checkUnexpectedByte(b);\n+        return b;\n+    }\n+\n+    private void checkUnexpectedByte(final int b) throws IOException {\n@@ -299,1 +332,1 @@\n-            \/\/ Report on this.in, not argument in; see read{Header, Trailer}.\n+            \/\/ report the InputStream type which returned this unexpected byte\n@@ -301,1 +334,1 @@\n-                + \".read() returned value out of range -1..255: \" + b);\n+                    + \".read() returned value out of range -1..255: \" + b);\n@@ -303,1 +336,0 @@\n-        return b;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"}]}