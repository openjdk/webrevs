{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.NestingKind;\n-import javax.lang.model.element.TypeElement;\n@@ -115,1 +112,0 @@\n-     * @return the list of top-level types defined in the source file\n@@ -118,1 +114,1 @@\n-    List<String> compileProgram() throws Fault {\n+    void compileProgram() throws Fault {\n@@ -129,21 +125,0 @@\n-        var fileUri = descriptor.fileObject().toUri();\n-        var names = new ArrayList<String>();\n-        task.addTaskListener(new TaskListener() {\n-            @Override\n-            public void started(TaskEvent event) {\n-                if (event.getKind() != TaskEvent.Kind.ANALYZE) return;\n-                TypeElement element = event.getTypeElement();\n-                if (element.getNestingKind() != NestingKind.TOP_LEVEL) return;\n-                JavaFileObject source = event.getSourceFile();\n-                if (source == null) return;\n-                if (!source.toUri().equals(fileUri)) return;\n-                ElementKind kind = element.getKind();\n-                if (kind != ElementKind.CLASS\n-                        && kind != ElementKind.ENUM\n-                        && kind != ElementKind.INTERFACE\n-                        && kind != ElementKind.RECORD)\n-                    return;\n-                var name = element.getQualifiedName().toString();\n-                names.add(name);\n-            }\n-        });\n@@ -154,4 +129,0 @@\n-        if (names.isEmpty()) {\n-            throw new Fault(Errors.NoClass);\n-        }\n-        return List.copyOf(names);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/MemoryContext.java","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.source.tree.ClassTree;\n@@ -36,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -49,1 +51,5 @@\n-public record ProgramDescriptor(ProgramFileObject fileObject, Optional<String> packageName, Path sourceRootPath) {\n+public record ProgramDescriptor(\n+        ProgramFileObject fileObject,\n+        Optional<String> packageName,\n+        List<String> qualifiedTypeNames,\n+        Path sourceRootPath) {\n@@ -52,0 +58,3 @@\n+        var packageName = \"\"; \/\/ empty string will be converted into an empty optional\n+        var packageNameAndDot = \"\"; \/\/ empty string or packageName + '.'\n+        var qualifiedTypeNames = new ArrayList<String>();\n@@ -57,6 +66,9 @@\n-            for (var tree : task.parse()) {\n-                var packageTree = tree.getPackage();\n-                if (packageTree != null) {\n-                    var packageName = packageTree.getPackageName().toString();\n-                    var root = computeSourceRootPath(file, packageName);\n-                    return new ProgramDescriptor(fileObject, Optional.of(packageName), root);\n+            var tree = task.parse().iterator().next(); \/\/ single compilation unit\n+            var packageTree = tree.getPackage();\n+            if (packageTree != null) {\n+                packageName = packageTree.getPackageName().toString();\n+                packageNameAndDot = packageName + '.';\n+            }\n+            for (var type : tree.getTypeDecls()) {\n+                if (type instanceof ClassTree classType) {\n+                    qualifiedTypeNames.add(packageNameAndDot + classType.getSimpleName());\n@@ -68,2 +80,8 @@\n-        var root = computeSourceRootPath(file, \"\");\n-        return new ProgramDescriptor(fileObject, Optional.empty(), root);\n+        if (qualifiedTypeNames.isEmpty()) {\n+            throw new Fault(Errors.NoClass);\n+        }\n+        return new ProgramDescriptor(\n+                fileObject,\n+                packageName.isEmpty() ? Optional.empty() : Optional.of(packageName),\n+                List.copyOf(qualifiedTypeNames),\n+                computeSourceRootPath(file, packageName));\n@@ -72,1 +90,1 @@\n-    public static Path computeSourceRootPath(Path program, String packageName) {\n+    public static Path computeSourceRootPath(Path program, String packageName) throws Fault {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/ProgramDescriptor.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-        List<String> names = context.compileProgram();\n+        context.compileProgram();\n@@ -153,1 +153,1 @@\n-        var appClass = execute(names, mainArgs, context);\n+        var appClass = execute(context, mainArgs);\n@@ -187,1 +187,0 @@\n-     * @param topLevelClassNames the names of classes in the program compilation unit\n@@ -193,1 +192,1 @@\n-    private Class<?> execute(List<String> topLevelClassNames, String[] mainArgs, MemoryContext context)\n+    private Class<?> execute(MemoryContext context, String[] mainArgs)\n@@ -197,0 +196,1 @@\n+        ProgramDescriptor program = context.getProgramDescriptor();\n@@ -200,1 +200,1 @@\n-        String firstClassName = topLevelClassNames.getFirst();\n+        String firstClassName = program.qualifiedTypeNames().getFirst();\n@@ -211,1 +211,1 @@\n-            var compilationUnitName = context.getProgramDescriptor().fileObject().getFile().getFileName().toString();\n+            var compilationUnitName = program.fileObject().getFile().getFileName().toString();\n@@ -213,2 +213,6 @@\n-            var expectedName = compilationUnitName.substring(0, compilationUnitName.length() - 5);\n-            var actualName = topLevelClassNames.stream()\n+            var expectedSimpleName = compilationUnitName.substring(0, compilationUnitName.length() - 5);\n+            var expectedPackageName = program.packageName().orElse(\"\");\n+            var expectedName = expectedPackageName.isEmpty()\n+                    ? expectedSimpleName\n+                    : expectedPackageName + '.' + expectedSimpleName;\n+            var actualName = program.qualifiedTypeNames().stream()\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/SourceLauncher.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8192920 8204588 8246774 8248843 8268869 8235876\n+ * @bug 8192920 8204588 8246774 8248843 8268869 8235876 8328339\n@@ -113,0 +113,21 @@\n+    @Test\n+    public void testHelloWorldInPackageWithStaticImport(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                \"\"\"\n+                package hello;\n+                import static hello.Helper.*;\n+                import java.util.Arrays;\n+                class World {\n+                    public static void main(String... args) {\n+                        m(args);\n+                    }\n+                }\n+                class Helper {\n+                    static void m(String... args) {\n+                        System.out.println(\"Hello World! \" + Arrays.toString(args));\n+                    }\n+                }\n+                \"\"\");\n+        testSuccess(base.resolve(\"hello\").resolve(\"World.java\"), \"Hello World! [1, 2, 3]\\n\");\n+    }\n+\n@@ -303,1 +324,1 @@\n-        Files.write(file, List.of(\"package p;\"));\n+        Files.write(file, List.of(\"package p; class MismatchOfPathAndPackage {}\"));\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"}]}