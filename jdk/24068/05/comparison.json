{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import sun.security.util.PBEUtil;\n@@ -70,11 +71,1 @@\n-        \/\/ Accept \"\\0\" to signify \"zero-length password with no terminator\".\n-        if (!(passwd.length == 1 && passwd[0] == 0)) {\n-            for (int i=0; i<passwd.length; i++) {\n-                if ((passwd[i] < '\\u0020') || (passwd[i] > '\\u007E')) {\n-                    throw new InvalidKeySpecException(\"Password is not ASCII\");\n-                }\n-            }\n-        }\n-        this.key = new byte[passwd.length];\n-        for (int i=0; i<passwd.length; i++)\n-            this.key[i] = (byte) (passwd[i] & 0x7f);\n+        this.key = PBEUtil.encodePassword(passwd);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n@@ -48,2 +46,1 @@\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n+import sun.security.util.PBEUtil;\n@@ -75,12 +72,0 @@\n-    private static byte[] getPasswordBytes(char[] passwd) {\n-        CharBuffer cb = CharBuffer.wrap(passwd);\n-        ByteBuffer bb = UTF_8.encode(cb);\n-\n-        int len = bb.limit();\n-        byte[] passwdBytes = new byte[len];\n-        bb.get(passwdBytes, 0, len);\n-        bb.clear().put(new byte[len]);\n-\n-        return passwdBytes;\n-    }\n-\n@@ -96,2 +81,2 @@\n-        \/\/ Convert the password from char[] to byte[]\n-        byte[] passwdBytes = getPasswordBytes(this.passwd);\n+        \/\/ Convert the password from char[] to byte[] in UTF-8\n+        byte[] passwdBytes = PBEUtil.encodePassword(this.passwd);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc.\n@@ -28,0 +28,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.StandardCharsets;\n@@ -198,4 +201,1 @@\n-                passwdChars = new char[passwdBytes.length];\n-                for (int i = 0; i < passwdChars.length; i++) {\n-                    passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-                }\n+                passwdChars = decodePassword(passwdBytes);\n@@ -257,1 +257,1 @@\n-        char[] passwdChars;\n+        char[] passwdChars = null;\n@@ -270,4 +270,1 @@\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i = 0; i < passwdChars.length; i++) {\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-            }\n+            passwdChars = decodePassword(passwdBytes);\n@@ -289,5 +286,1 @@\n-            } else if (!(params instanceof PBEParameterSpec)) {\n-                throw new InvalidAlgorithmParameterException(\n-                        \"PBEParameterSpec type required\");\n-            } else {\n-                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n+            } else if (params instanceof PBEParameterSpec pbeParams) {\n@@ -313,0 +306,3 @@\n+            } else {\n+                throw new InvalidAlgorithmParameterException(\n+                        \"PBEParameterSpec type required\");\n@@ -314,0 +310,1 @@\n+\n@@ -327,1 +324,3 @@\n-            Arrays.fill(passwdChars, '\\0');\n+            if (passwdChars != null) {\n+                Arrays.fill(passwdChars, '\\0');\n+            }\n@@ -332,3 +331,2 @@\n-     * Check that the key implements the PBEKey interface. If params is an\n-     * instance of PBEParameterSpec, validate consistency with the key's\n-     * derivation data. Used by P11Mac and P11PBECipher (SunPKCS11).\n+     * Converts the password char[] to the UTF-8 encoded byte[]. Used by PBEKey\n+     * and PBKDF2KeyImpl (SunJCE).\n@@ -336,18 +334,19 @@\n-    public static void checkKeyAndParams(Key key,\n-            AlgorithmParameterSpec params, String algorithm)\n-            throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        if (key instanceof javax.crypto.interfaces.PBEKey pbeKey) {\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                if (pbeParams.getIterationCount() !=\n-                        pbeKey.getIterationCount() ||\n-                        !Arrays.equals(pbeParams.getSalt(), pbeKey.getSalt())) {\n-                    throw new InvalidAlgorithmParameterException(\n-                            \"Salt or iteration count parameters are \" +\n-                            \"not consistent with PBE key\");\n-                }\n-            }\n-        } else {\n-            throw new InvalidKeyException(\n-                    \"Cannot use a \" + algorithm + \" service with a key that \" +\n-                    \"does not implement javax.crypto.interfaces.PBEKey\");\n-        }\n+    public static byte[] encodePassword(char[] passwd) {\n+        ByteBuffer bb = StandardCharsets.UTF_8.encode(CharBuffer.wrap(passwd));\n+        int len = bb.limit();\n+        byte[] passwdBytes = new byte[len];\n+        bb.get(passwdBytes, 0, len);\n+        bb.clear().put(new byte[len]);\n+\n+        return passwdBytes;\n+    }\n+\n+    \/\/ converts the UTF-8 encoded byte[] to the password char[]\n+    private static char[] decodePassword(byte[] passwdBytes) {\n+        CharBuffer cb = StandardCharsets.UTF_8.decode(\n+                ByteBuffer.wrap(passwdBytes));\n+        int len = cb.limit();\n+        char[] passwd = new char[len];\n+        cb.get(passwd);\n+        cb.clear().put(new char[len]);\n+        return passwd;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/PBEUtil.java","additions":36,"deletions":37,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -359,1 +359,3 @@\n-    static SecretKey pbeKey(Session session, long keyID, String algorithm,\n+    \/\/ for PBKDF2 and the deprecated PBE-based key derivation method defined\n+    \/\/ in RFC 7292 PKCS#12 B.2\n+    static SecretKey pbkdfKey(Session session, long keyID, String algorithm,\n@@ -367,1 +369,1 @@\n-        return new P11PBEKey(session, keyID, algorithm, keyLength,\n+        return new P11PBKDFKey(session, keyID, algorithm, keyLength,\n@@ -505,1 +507,1 @@\n-    static final class P11PBEKey extends P11SecretKey\n+    static final class P11PBKDFKey extends P11SecretKey\n@@ -511,1 +513,1 @@\n-        P11PBEKey(Session session, long keyID, String algorithm,\n+        P11PBKDFKey(Session session, long keyID, String keyAlgo,\n@@ -514,1 +516,1 @@\n-            super(session, keyID, algorithm, keyLength, attributes);\n+            super(session, keyID, keyAlgo, keyLength, attributes);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,27 +199,17 @@\n-            if (key instanceof P11Key) {\n-                \/\/ If the key is a P11Key, it must come from a PBE derivation\n-                \/\/ because this is a PBE Mac service. In addition to checking\n-                \/\/ the key, check that params (if passed) are consistent.\n-                PBEUtil.checkKeyAndParams(key, params, algorithm);\n-            } else {\n-                \/\/ If the key is not a P11Key, a derivation is needed. Data for\n-                \/\/ derivation has to be carried either as part of the key or\n-                \/\/ params. Use SunPKCS11 PBE key derivation to obtain a P11Key.\n-                \/\/ Assign the derived key to p11Key because conversion is never\n-                \/\/ needed for this case.\n-                PBEKeySpec pbeKeySpec = PBEUtil.getPBAKeySpec(key, params);\n-                try {\n-                    P11Key.P11PBEKey p11PBEKey =\n-                            P11SecretKeyFactory.derivePBEKey(token,\n-                            pbeKeySpec, svcPbeKi);\n-                    \/\/ This Mac service uses the token where the derived key\n-                    \/\/ lives so there won't be any need to re-derive and use\n-                    \/\/ the password. The p11Key cannot be accessed out of this\n-                    \/\/ class.\n-                    p11PBEKey.clearPassword();\n-                    p11Key = p11PBEKey;\n-                } catch (InvalidKeySpecException e) {\n-                    throw new InvalidKeyException(e);\n-                } finally {\n-                    pbeKeySpec.clearPassword();\n-                }\n+            \/\/ Do key derivation using P11SecretKeyFactory, then store the\n+            \/\/ derived key to p11Key\n+            PBEKeySpec pbeKeySpec = PBEUtil.getPBAKeySpec(key, params);\n+            try {\n+                P11Key.P11PBKDFKey derivedKey =\n+                        P11SecretKeyFactory.derivePBEKey(token,\n+                        pbeKeySpec, svcPbeKi);\n+                \/\/ This Mac service uses the token where the derived key\n+                \/\/ lives so there won't be any need to re-derive and use\n+                \/\/ the password. The p11Key cannot be accessed out of this\n+                \/\/ class.\n+                derivedKey.clearPassword();\n+                p11Key = derivedKey;\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            } finally {\n+                pbeKeySpec.clearPassword();\n@@ -233,0 +223,2 @@\n+        } else { \/\/ for the non-PBE case\n+            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n@@ -238,5 +230,0 @@\n-        \/\/ In non-PBE cases and PBE cases where we didn't derive,\n-        \/\/ a key conversion might be needed.\n-        if (p11Key == null) {\n-            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n-        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc.\n@@ -25,1 +25,0 @@\n-\n@@ -42,1 +41,0 @@\n-import javax.crypto.spec.PBEParameterSpec;\n@@ -131,40 +129,17 @@\n-        if (key instanceof P11Key) {\n-            \/\/ If the key is a P11Key, it must come from a PBE derivation\n-            \/\/ because this is a PBE Cipher service. In addition to checking the\n-            \/\/ key, check that params (if passed) are consistent.\n-            PBEUtil.checkKeyAndParams(key, params, pbeAlg);\n-            \/\/ At this point, we know that the key is a P11PBEKey.\n-            P11Key.P11PBEKey p11PBEKey = (P11Key.P11PBEKey) key;\n-            \/\/ PBE services require a PBE key of the same algorithm and the\n-            \/\/ underlying service (non-PBE) won't check it.\n-            if (!pbeAlg.equals(p11PBEKey.getAlgorithm())) {\n-                throw new InvalidKeyException(\"Cannot use a \" +\n-                        p11PBEKey.getAlgorithm() + \" key for a \" + pbeAlg +\n-                        \" service\");\n-            }\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                params = pbeParams.getParameterSpec();\n-            }\n-            pbes2Params.initialize(blkSize, opmode,\n-                    p11PBEKey.getIterationCount(), p11PBEKey.getSalt(), params,\n-                    random);\n-        } else {\n-            \/\/ If the key is not a P11Key, a derivation is needed. Data for\n-            \/\/ derivation has to be carried either as part of the key or params.\n-            \/\/ Use SunPKCS11 PBE key derivation to obtain a P11Key.\n-            PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n-                    blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n-            try {\n-                P11Key.P11PBEKey p11PBEKey = P11SecretKeyFactory.derivePBEKey(\n-                        token, pbeSpec, svcPbeKi);\n-                \/\/ The internal Cipher service uses the token where the\n-                \/\/ derived key lives so there won't be any need to re-derive\n-                \/\/ and use the password. The key cannot be accessed out of this\n-                \/\/ class.\n-                p11PBEKey.clearPassword();\n-                key = p11PBEKey;\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(e);\n-            } finally {\n-                pbeSpec.clearPassword();\n-            }\n+        \/\/ do key derivation, use P11SecretKeyFactory\n+        PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n+                blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n+        try {\n+            P11Key.P11PBKDFKey derivedKey =\n+                    P11SecretKeyFactory.derivePBEKey(\n+                    token, pbeSpec, svcPbeKi);\n+            \/\/ The internal Cipher service uses the token where the\n+            \/\/ derived key lives so there won't be any need to re-derive\n+            \/\/ and use the password. The key cannot be accessed out of this\n+            \/\/ class.\n+            derivedKey.clearPassword();\n+            key = derivedKey;\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            pbeSpec.clearPassword();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PBECipher.java","additions":18,"deletions":43,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -338,0 +338,6 @@\n+        KeyInfo ki = getKeyInfo(keyAlgo);\n+        if (ki == null) {\n+            throw new InvalidKeyException(\"Unknown algorithm \" + keyAlgo);\n+        }\n+\n+        KeyInfo si;\n@@ -340,0 +346,6 @@\n+            si = ki;\n+        } else {\n+            si = getKeyInfo(svcAlgo);\n+            if (si == null) {\n+                throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n+            }\n@@ -341,5 +353,1 @@\n-        KeyInfo ki = null;\n-        KeyInfo si = getKeyInfo(svcAlgo);\n-        if (si == null) {\n-            throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n-        }\n+\n@@ -348,4 +356,3 @@\n-        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo)) {\n-            ki = getKeyInfo(keyAlgo);\n-            if (ki == null || !KeyInfo.checkUse(ki, si)) {\n-                throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n+        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo) &&\n+                !KeyInfo.checkUse(ki, si)) {\n+            throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n@@ -353,1 +360,0 @@\n-            }\n@@ -355,0 +361,1 @@\n+\n@@ -385,1 +392,0 @@\n-            ki = ki == null ? getKeyInfo(keyAlgo) : ki;\n@@ -417,1 +423,3 @@\n-    static P11Key.P11PBEKey derivePBEKey(Token token, PBEKeySpec keySpec,\n+    \/\/ utility method for deriving secret keys using PBKDF2 or the legacy\n+    \/\/ PKCS#12 B.2 method.\n+    static P11Key.P11PBKDFKey derivePBEKey(Token token, PBEKeySpec keySpec,\n@@ -432,1 +440,1 @@\n-            int keySize = keySpec.getKeyLength();\n+            int keySize = keySpec.getKeyLength(); \/\/ in bits\n@@ -498,1 +506,1 @@\n-            return (P11Key.P11PBEKey) P11Key.pbeKey(session, keyID, pbeKi.algo,\n+            return (P11Key.P11PBKDFKey) P11Key.pbkdfKey(session, keyID, pbeKi.algo,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -739,40 +739,0 @@\n-        \/*\n-         * PBE Secret Key Factories\n-         *\n-         * KeyDerivationPrf must be supported for these services\n-         * to be available.\n-         *\n-        *\/\n-        d(SKF, \"PBEWithHmacSHA1AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n-        d(SKF, \"PBEWithHmacSHA224AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n-        d(SKF, \"PBEWithHmacSHA256AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n-        d(SKF, \"PBEWithHmacSHA384AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n-        d(SKF, \"PBEWithHmacSHA512AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n-        d(SKF, \"PBEWithHmacSHA1AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n-        d(SKF, \"PBEWithHmacSHA224AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n-        d(SKF, \"PBEWithHmacSHA256AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n-        d(SKF, \"PBEWithHmacSHA384AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n-        d(SKF, \"PBEWithHmacSHA512AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n-        \/*\n-         * PBA Secret Key Factories\n-         *\/\n-        d(SKF, \"HmacPBESHA1\",       P11SecretKeyFactory,\n-                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n-        d(SKF, \"HmacPBESHA224\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA256\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA384\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA512\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc.\n@@ -43,1 +43,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -50,1 +50,1 @@\n-    private static final char[] password = \"123456\".toCharArray();\n+    private static final char[] password = \"123456\\uA4F7\".toCharArray();\n@@ -65,4 +65,0 @@\n-        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n-        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Cipher.\n-        SecretKeyFactoryDerivedKey,\n-\n@@ -119,2 +115,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"ba1c9614d550912925d99e0bc8969032\" +\n-                    \"7ac6258b72117dcf750c19ee6ca73dd4\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"9e097796e8d8224f2a7f5c950677d879\" +\n+                    \"c0c578340147c7ae357550e2f4d4c6ce\"),\n@@ -122,2 +118,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"41960c43ca99cf2184511aaf2f0508a9\" +\n-                    \"7da3762ee6c2b7e2027c8076811f2e52\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"7b915941d8e3a87c00e2fbd8ad67a578\" +\n+                    \"9a25648933b737706de4e4d48bdb61b6\"),\n@@ -125,2 +121,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"6bb6a3dc3834e81e5ca6b5e70073ff46\" +\n-                    \"903b188940a269ed26db2ffe622b8e16\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"c23912d15599908f47cc32c9da56b37f\" +\n+                    \"e41e958e9c3a6c6e4e631a2a9e6cd20f\"),\n@@ -128,2 +124,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"22aabf7a6a059415dc4ca7d985f3de06\" +\n-                    \"8f8300ca48d8de585d802670f4c1d9bd\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"f05c6b2dea545d59f2a6fde845170dd6\" +\n+                    \"7aebd6b1cc28904699d7dcff1a0a238c\"),\n@@ -131,2 +127,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"b523e7c462a0b7fd74e492b3a6550464\" +\n-                    \"ceebe81f08649ae163673afc242ad8a2\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"949c0c01a29375b9d421f6e2bf6ed0d7\" +\n+                    \"15a118e0980494797d3a3b799b67daf6\"),\n@@ -134,2 +130,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"1e7c25e166afae069cec68ef9affca61\" +\n-                    \"aea02ab1c3dc7471cb767ed7d6e37af0\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"7bd686b15bc09e5fb5aa1f881c92aa5a\" +\n+                    \"e72bdcd864c74e62395b9aaea7443bcd\"),\n@@ -137,2 +133,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"6701f1cc75b6494ec4bd27158aa2c15d\" +\n-                    \"7d10bc2f1fbb7d92d8277c7edfd1dd57\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"df58a1b26cca7e9e297da61ada03ddc4\" +\n+                    \"39d2a5699753433f19891de33f8741a2\"),\n@@ -140,2 +136,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"f82eb2fc016505baeb23ecdf85163933\" +\n-                    \"5e8d6d48b48631185641febb75898a1d\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"f6ae5a15ec2c18eaa25927858f1da990\" +\n+                    \"6df58a3b4830dbaaaa4c4317e53d717d\"),\n@@ -143,2 +139,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"ee9528022e58cdd9be80cd88443e03b3\" +\n-                    \"de13376cf97c53d946d5c5dfc88097be\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"5795625f51ec701594506944e5ed79f0\" +\n+                    \"c9d8e82319762f00f8ff06a8b6195ac4\"),\n@@ -146,2 +142,2 @@\n-                    \"AES\/CBC\/PKCS5Padding\", \"18f472912ffaa31824e20a5486324e14\" +\n-                    \"0225e20cb158762e8647b1216fe0ab7e\"),\n+                    \"AES\/CBC\/PKCS5Padding\", \"ddf55933f80f42f2a8d4e8726290766e\" +\n+                    \"024f225b76b594e8005c00227d553d05\"),\n@@ -204,5 +200,0 @@\n-            case SecretKeyFactoryDerivedKey -> {\n-                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n-                cipher.init(Cipher.ENCRYPT_MODE, key,\n-                        pbeSpec.getParameterSpec());\n-            }\n@@ -225,6 +216,0 @@\n-    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n-            String algorithm) throws GeneralSecurityException {\n-        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n-                .generateSecret(new PBEKeySpec(password, salt, iterations));\n-    }\n-\n@@ -232,1 +217,3 @@\n-            boolean isPbeCipherSvc) {\n+            boolean isPbeCipherSvc) throws GeneralSecurityException {\n+        byte[] enc = (isPbeCipherSvc ?\n+                    getPasswordOnlyPBEKey().getEncoded() : null);\n@@ -239,10 +226,1 @@\n-            public byte[] getEncoded() {\n-                byte[] encodedKey = null;\n-                if (isPbeCipherSvc) {\n-                    encodedKey = new byte[password.length];\n-                    for (int i = 0; i < password.length; i++) {\n-                        encodedKey[i] = (byte) (password[i] & 0x7f);\n-                    }\n-                }\n-                return encodedKey;\n-            }\n+            public byte[] getEncoded() { return enc; }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/PBECipher.java","additions":27,"deletions":49,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc.\n@@ -40,1 +40,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -47,1 +47,1 @@\n-    private static final char[] password = \"123456\".toCharArray();\n+    private static final char[] password = \"123456\\uA4F7\".toCharArray();\n@@ -59,4 +59,0 @@\n-        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n-        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Mac.\n-        SecretKeyFactoryDerivedKey,\n-\n@@ -109,1 +105,1 @@\n-                    \"707606929395e4297adc63d520ac7d22f3f5fa66\"),\n+                    \"8611414ddb1875d9f576282199ab492a802b7d49\"),\n@@ -111,1 +107,1 @@\n-                    \"4ffb5ad4974a7a9fca5a36ebe3e34dd443c07fb68c392f8b611657e6\"),\n+                    \"cebb12b48eb90c07336c695f771d1d0ef4ccf5b9524fc0ab6fb9813a\"),\n@@ -113,2 +109,2 @@\n-                    \"9e8c102c212d2fd1334dc497acb4e002b04e84713b7eda5a63807af2\" +\n-                    \"989d3e50\"),\n+                    \"d83a6a4e8b0e1ec939d05790f385dd774bd2b7c17cfa2dd004efc894\" +\n+                    \"e5d53f51\"),\n@@ -116,2 +112,2 @@\n-                    \"77f31a785d4f2220251143a4ba80f5610d9d0aeaebb4a278b8a7535c\" +\n-                    \"8cea8e8211809ba450458e351c5b66d691839c23\"),\n+                    \"ae6b69cf9edfd9cd8c3b51cdf2b0243502f35a3e6007f33b1ab73568\" +\n+                    \"2ea81ea562f4383bb9512ff70752367b7259b16f\"),\n@@ -119,3 +115,3 @@\n-                    \"a53f942a844b234a69c1f92cba20ef272c4394a3cf4024dc16d9dbac\" +\n-                    \"1969870b1c2b28b897149a1a3b9ad80a7ca8c547dfabf3ed5f144c6b\" +\n-                    \"593900b62e120c45\"),\n+                    \"46f6d09b0e7e50a66fa559ea4c4e9737a9d9e258b94f0075230d0acb\" +\n+                    \"40f2c926f96a152c4f6b03b631efc7f99c84f052f1c78d79e07f2a9e\" +\n+                    \"4a96164f5b46e70b\"),\n@@ -137,1 +133,1 @@\n-    private static void testWith(Provider sunPKCS11, AssertionData data,\n+    private static void testWith(Provider p, AssertionData data,\n@@ -143,1 +139,1 @@\n-        BigInteger mac = computeMac(sunPKCS11, svcAlgo, data.pbeHmacAlgo, conf);\n+        BigInteger mac = computeMac(p, svcAlgo, data.pbeHmacAlgo, conf);\n@@ -161,4 +157,0 @@\n-            case SecretKeyFactoryDerivedKey -> {\n-                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n-                mac.init(key);\n-            }\n@@ -169,0 +161,1 @@\n+            default -> throw new RuntimeException(\"Unsupported configuration\");\n@@ -170,0 +163,1 @@\n+\n@@ -180,6 +174,0 @@\n-    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n-            String algorithm) throws GeneralSecurityException {\n-        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n-                .generateSecret(new PBEKeySpec(password, salt, iterations));\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/PBAMac.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335288\n+ * @bug 8335288 8348732\n@@ -56,5 +56,5 @@\n-        new TestData(\"SKF\", \"PBEWithHmacSHA1AndAES_128\", false),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA224AndAES_128\", true),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA256AndAES_128\", true),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA384AndAES_128\", false),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA512AndAES_128\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA1\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA224\", true),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA256\", true),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA384\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA512\", false),\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/RequiredMechCheck.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Red Hat, Inc.\n+ * Copyright (c) 2023, 2025, Red Hat, Inc.\n@@ -25,3 +25,0 @@\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.ReflectiveOperationException;\n@@ -46,1 +43,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -77,32 +74,0 @@\n-    private static AssertionData p12PBKDAssertionData(String algo,\n-            char[] password, int keyLen, String hashAlgo, int blockLen,\n-            String staticExpectedKeyString) {\n-        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n-        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n-                16);\n-        BigInteger expectedKey;\n-        try {\n-            \/\/ Since we need to access an internal\n-            \/\/ SunJCE API, we use reflection.\n-            Class<?> PKCS12PBECipherCore = Class.forName(\n-                    \"com.sun.crypto.provider.PKCS12PBECipherCore\");\n-\n-            Field macKeyField = PKCS12PBECipherCore.getDeclaredField(\"MAC_KEY\");\n-            macKeyField.setAccessible(true);\n-            int MAC_KEY = (int) macKeyField.get(null);\n-\n-            Method deriveMethod = PKCS12PBECipherCore.getDeclaredMethod(\n-                    \"derive\", char[].class, byte[].class, int.class,\n-                    int.class, int.class, String.class, int.class);\n-            deriveMethod.setAccessible(true);\n-            expectedKey = i((byte[]) deriveMethod.invoke(null,\n-                    keySpec.getPassword(), keySpec.getSalt(),\n-                    keySpec.getIterationCount(), keySpec.getKeyLength() \/ 8,\n-                    MAC_KEY, hashAlgo, blockLen));\n-            checkAssertionValues(expectedKey, staticExpectedKey);\n-        } catch (ReflectiveOperationException ignored) {\n-            expectedKey = staticExpectedKey;\n-        }\n-        return new AssertionData(algo, keySpec, expectedKey);\n-    }\n-\n@@ -110,2 +75,1 @@\n-            char[] password, int keyLen, String kdfAlgo,\n-            String staticExpectedKeyString) {\n+            char[] password, int keyLen, String staticExpectedKeyString) {\n@@ -118,1 +82,1 @@\n-                expectedKey = i(SecretKeyFactory.getInstance(kdfAlgo, sunJCE)\n+                expectedKey = i(SecretKeyFactory.getInstance(algo, sunJCE)\n@@ -150,10 +114,4 @@\n-    private static final AssertionData hmacPBESHA1Data =\n-            p12PBKDAssertionData(\"HmacPBESHA1\", pwd, 160, \"SHA-1\", 64,\n-                    \"13156c6bee8e13ef568231e0174651afa5a358b0\");\n-    private static final AssertionData hmacPBESHA224Data =\n-            p12PBKDAssertionData(\"HmacPBESHA224\", pwd, 224, \"SHA-224\", 64,\n-                    \"d93acf4b3bea8a89d098e290928840c0b693a30cad0117f70ace50c2\");\n-    private static final AssertionData pbeWithHmacSHA512AndAES256Data =\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n-                    \"7e3077595f90b60ab96d4f29203927b0\");\n+    private static final AssertionData pbkdf2WithHmacSHA512Data =\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", pwd, 256,\n+                    \"845560159e2f3f51dad8d6e0feccc8987e3077595f90b60ab96d4f29\" +\n+                    \"203927b0\");\n@@ -162,3 +120,2 @@\n-                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n-                    \"44984e3e9b619488a42b93dd6453f630ae3e2ad7ed809fa9e98a7921\" +\n-                    \"87d62e84\");\n+                    \"6851e387278dd5a3a0d05e4d742f59d844984e3e9b619488a42b93dd\" +\n+                    \"6453f630ae3e2ad7ed809fa9e98a792187d62e84\");\n@@ -166,24 +123,12 @@\n-            hmacPBESHA1Data,\n-            hmacPBESHA224Data,\n-            p12PBKDAssertionData(\"HmacPBESHA256\", pwd, 256, \"SHA-256\", 64,\n-                    \"1bb3ed1ffb784ed32f59b4d7515971699af99cf67a2e574000964c8e\" +\n-                    \"1eba1c45\"),\n-            p12PBKDAssertionData(\"HmacPBESHA384\", pwd, 384, \"SHA-384\", 128,\n-                    \"d4ce121d3cec88a8c8b0c6225f7f996b72d76017c2d91bc51fd47985\" +\n-                    \"86d1012d1ad03a39fdcd0fdc438d164ab50259fc\"),\n-            p12PBKDAssertionData(\"HmacPBESHA512\", pwd, 512, \"SHA-512\", 128,\n-                    \"5f80b350986e5156669193eaa42a107e7d6636d82fb550f67af5b2c2\" +\n-                    \"f546d977b70e52bbbcb6bb8976f9d3f0eaf9bfef5306c50ee5ccda3e\" +\n-                    \"e4c4c7c8421fe4d\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 128,\n+                    \"29958f3f1c942e50903189eb7f1ba09d\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 128,\n+                    \"e328140e31f4ffb15af806986c23ee4e\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 128,\n+                    \"6851e387278dd5a3a0d05e4d742f59d8\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 128,\n+                    \"5570e2fb1a664910f055b71643b52351\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", pwd, 128,\n+                    \"845560159e2f3f51dad8d6e0feccc898\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 256,\n+                    \"29958f3f1c942e50903189eb7f1ba09d40\" +\n@@ -191,2 +136,2 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 256,\n+                    \"e328140e31f4ffb15af806986c23ee4e\" +\n@@ -194,2 +139,2 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 256,\n+                    \"6851e387278dd5a3a0d05e4d742f59d8\" +\n@@ -197,2 +142,2 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 256,\n+                    \"5570e2fb1a664910f055b71643b52351\" +\n@@ -200,1 +145,1 @@\n-            pbeWithHmacSHA512AndAES256Data,\n+            pbkdf2WithHmacSHA512Data,\n@@ -202,2 +147,2 @@\n-                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n-                    \"b5552da5e645dad4b5911ce0f2\"),\n+                    \"29958f3f1c942e50903189eb7f1ba09d40b5552da5e645dad4b5911c\" +\n+                    \"e0f2\"),\n@@ -205,2 +150,2 @@\n-                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\" +\n-                    \"7daa2119fee8c64aef7c1f4c1871724e0ea628577e0ab54fa7c6\"),\n+                    \"e328140e31f4ffb15af806986c23ee4e7daa2119fee8c64aef7c1f4c\" +\n+                    \"1871724e0ea628577e0ab54fa7c6\"),\n@@ -209,3 +154,3 @@\n-                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n-                    \"d7d0ad3a18912086f80d974f2acc2efba52650d4bf872455820f24c8\" +\n-                    \"46742161da84a1b4c3f197f4347308e8841a8971cf686aef29107396\"),\n+                    \"5570e2fb1a664910f055b71643b52351d7d0ad3a18912086f80d974f\" +\n+                    \"2acc2efba52650d4bf872455820f24c846742161da84a1b4c3f197f4\" +\n+                    \"347308e8841a8971cf686aef29107396\"),\n@@ -213,11 +158,7 @@\n-                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n-                    \"7e3077595f90b60ab96d4f29203927b00aa1a11e4d19d4f275a7f453\" +\n-                    \"14be500dacc3c1de9f704827b396463ccaa8957344d41bd64d9d09ff\" +\n-                    \"474e776469d326b1ee6ee5a5d854b86d3d7a25084afd6d6f\"),\n-            p12PBKDAssertionData(\"HmacPBESHA512\", emptyPwd, 512, \"SHA-512\",\n-                    128, \"90b6e088490c6c5e6b6e81209bd769d27df3868cae79591577a\" +\n-                    \"c35b46e4c6ebcc4b90f4943e3cb165f9d1789d938235f4b35ba74df9\" +\n-                    \"e509fbbb7aa329a432445\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", emptyPwd, 256,\n-                    \"PBKDF2WithHmacSHA512\", \"3a5c5fd11e4d381b32e11baa93d7b128\" +\n-                    \"09e016e48e0542c5d3453fc240a0fa76\"),\n+                    \"845560159e2f3f51dad8d6e0feccc8987e3077595f90b60ab96d4f29\" +\n+                    \"203927b00aa1a11e4d19d4f275a7f45314be500dacc3c1de9f704827\" +\n+                    \"b396463ccaa8957344d41bd64d9d09ff474e776469d326b1ee6ee5a5\" +\n+                    \"d854b86d3d7a25084afd6d6f\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", emptyPwd, 256,\n+                    \"3a5c5fd11e4d381b32e11baa93d7b12809e016e48e0542c5d3453fc2\" +\n+                    \"40a0fa76\"),\n@@ -395,1 +336,1 @@\n-                hmacPBESHA1Data.algo, sunPKCS11);\n+                pbkdf2WithHmacSHA512Data.algo, sunPKCS11);\n@@ -399,2 +340,3 @@\n-        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n-                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        PBEKey p11PbkdfKey = (PBEKey) skf3.translateKey(getAnonymousPBEKey(\n+                skf3.getAlgorithm(), pbkdf2WithHmacSHA256Data.keySpec));\n+\n@@ -405,2 +347,2 @@\n-                () -> skf1.translateKey(new SecretKeySpec(\n-                        new byte[10], hmacPBESHA1Data.algo)));\n+                () -> skf3.translateKey(new SecretKeySpec(\n+                        new byte[10], skf3.getAlgorithm())));\n@@ -410,4 +352,3 @@\n-        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n-                hmacPBESHA224Data.algo + \" service\",\n-                () -> SecretKeyFactory.getInstance(hmacPBESHA224Data.algo,\n-                        sunPKCS11).translateKey(p11PbeKey));\n+        assertThrows(e, \"Cannot use a \" + pbkdf2WithHmacSHA256Data.algo +\n+                \" key for a \" + pbkdf2WithHmacSHA512Data.algo + \" service\",\n+                () -> skf1.translateKey(p11PbkdfKey));\n@@ -416,3 +357,5 @@\n-        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n-                skf2.getAlgorithm() + \" service\",\n-                () -> skf2.translateKey(p11PbeKey));\n+        String keyAlg1 = \"HmacPBESHA1\";\n+        PBEKeySpec kSpec1 = new PBEKeySpec(pwd, salt, 1, 16);\n+        assertThrows(e, \"Cannot use a \" + keyAlg1 + \" key for a \" +\n+                skf2.getAlgorithm() + \" service\", () ->\n+                skf2.translateKey(getAnonymousPBEKey(keyAlg1, kSpec1)));\n@@ -420,1 +363,1 @@\n-        System.out.println(\" * Inconsistent key length between key and \" +\n+        System.out.println(\" * Inconsistent key length between key and its \" +\n@@ -422,1 +365,1 @@\n-        PBEKeySpec kSpec1 = new PBEKeySpec(pwd, salt, 1, 16);\n+        String keyAlg2 = \"PBEWithHmacSHA1AndAES_128\";\n@@ -424,5 +367,3 @@\n-                \"length is invalid for \" + skf1.getAlgorithm() + \" (expecting\" +\n-                \" \" + hmacPBESHA1Data.keySpec.getKeyLength() + \" but was \" +\n-                kSpec1.getKeyLength() + \")\",\n-                () -> skf1.translateKey(getAnonymousPBEKey(\n-                        skf1.getAlgorithm(), kSpec1)));\n+                \"length is invalid for \" + keyAlg2 + \" (expecting 128 but \" +\n+                \"was \" + kSpec1.getKeyLength() + \")\", () ->\n+                skf2.translateKey(getAnonymousPBEKey(keyAlg2, kSpec1)));\n@@ -446,6 +387,2 @@\n-                hmacPBESHA1Data.algo, sunPKCS11);\n-        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n-                pbeWithHmacSHA512AndAES256Data.algo, sunPKCS11);\n-        SecretKeyFactory skf3 = SecretKeyFactory.getInstance(\n-                \"PBKDF2WithHmacSHA512\", sunPKCS11);\n-        SecretKeyFactory skf4 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n+                pbkdf2WithHmacSHA512Data.algo, sunPKCS11);\n+        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\"AES\", sunPKCS11);\n@@ -458,12 +395,0 @@\n-        System.out.println(\" * Inconsistent key length between spec and \" +\n-                \"algorithm\");\n-        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n-        assertThrows(e, \"Key length is invalid for \" + skf1.getAlgorithm() +\n-                \" (expecting \" + hmacPBESHA1Data.keySpec.getKeyLength() +\n-                \" but was \" + kSpec.getKeyLength() + \")\",\n-                () -> skf1.generateSecret(kSpec));\n-        assertThrows(e, \"Key length is invalid for \" + skf2.getAlgorithm() +\n-                \" (expecting \" + pbeWithHmacSHA512AndAES256Data.keySpec\n-                .getKeyLength() + \" but was \" + kSpec.getKeyLength() + \")\",\n-                () -> skf2.generateSecret(kSpec));\n-\n@@ -473,1 +398,1 @@\n-                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1)));\n+                () -> skf1.generateSecret(new PBEKeySpec(pwd, salt, 1)));\n@@ -475,1 +400,1 @@\n-                () -> skf3.generateSecret(new PBEKeySpec(pwd, salt, 1, 3)));\n+                () -> skf1.generateSecret(new PBEKeySpec(pwd, salt, 1, 3)));\n@@ -478,0 +403,1 @@\n+        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n@@ -479,1 +405,1 @@\n-                () -> skf4.generateSecret(kSpec));\n+                () -> skf2.generateSecret(kSpec));\n@@ -490,1 +416,1 @@\n-                hmacPBESHA1Data.algo, sunPKCS11);\n+                pbkdf2WithHmacSHA256Data.algo, sunPKCS11);\n@@ -493,2 +419,2 @@\n-        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n-                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        PBEKey p11PbkdfKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n+                skf1.getAlgorithm(), pbkdf2WithHmacSHA256Data.keySpec));\n@@ -499,1 +425,1 @@\n-                () -> skf1.getKeySpec(p11PbeKey, null));\n+                () -> skf1.getKeySpec(p11PbkdfKey, null));\n@@ -509,1 +435,1 @@\n-                () -> skf2.getKeySpec(p11PbeKey, PBEKeySpec.class));\n+                () -> skf2.getKeySpec(p11PbkdfKey, PBEKeySpec.class));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestPBKD.java","additions":73,"deletions":147,"binary":false,"changes":220,"status":"modified"}]}