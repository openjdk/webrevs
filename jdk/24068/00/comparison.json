{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,11 +70,1 @@\n-        \/\/ Accept \"\\0\" to signify \"zero-length password with no terminator\".\n-        if (!(passwd.length == 1 && passwd[0] == 0)) {\n-            for (int i=0; i<passwd.length; i++) {\n-                if ((passwd[i] < '\\u0020') || (passwd[i] > '\\u007E')) {\n-                    throw new InvalidKeySpecException(\"Password is not ASCII\");\n-                }\n-            }\n-        }\n-        this.key = new byte[passwd.length];\n-        for (int i=0; i<passwd.length; i++)\n-            this.key[i] = (byte) (passwd[i] & 0x7f);\n+        this.key = PBKDF2KeyImpl.getPasswordBytes(passwd);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-    private static byte[] getPasswordBytes(char[] passwd) {\n+    \/\/ also used by com.sun.crypto.provider.PBEKey constructor\n+    static byte[] getPasswordBytes(char[] passwd) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBKDF2KeyImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -359,1 +359,3 @@\n-    static SecretKey pbeKey(Session session, long keyID, String algorithm,\n+    \/\/ for PBKDF2 and the deprecated PBE-based key derivation method defined\n+    \/\/ in RFC 7292 PKCS#12 B.2\n+    static SecretKey pbkdfKey(Session session, long keyID, String algorithm,\n@@ -367,1 +369,1 @@\n-        return new P11PBEKey(session, keyID, algorithm, keyLength,\n+        return new P11PBKDFKey(session, keyID, algorithm, keyLength,\n@@ -505,1 +507,1 @@\n-    static final class P11PBEKey extends P11SecretKey\n+    static final class P11PBKDFKey extends P11SecretKey\n@@ -511,1 +513,1 @@\n-        P11PBEKey(Session session, long keyID, String algorithm,\n+        P11PBKDFKey(Session session, long keyID, String keyAlgo,\n@@ -514,1 +516,1 @@\n-            super(session, keyID, algorithm, keyLength, attributes);\n+            super(session, keyID, keyAlgo, keyLength, attributes);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Key.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,27 +199,17 @@\n-            if (key instanceof P11Key) {\n-                \/\/ If the key is a P11Key, it must come from a PBE derivation\n-                \/\/ because this is a PBE Mac service. In addition to checking\n-                \/\/ the key, check that params (if passed) are consistent.\n-                PBEUtil.checkKeyAndParams(key, params, algorithm);\n-            } else {\n-                \/\/ If the key is not a P11Key, a derivation is needed. Data for\n-                \/\/ derivation has to be carried either as part of the key or\n-                \/\/ params. Use SunPKCS11 PBE key derivation to obtain a P11Key.\n-                \/\/ Assign the derived key to p11Key because conversion is never\n-                \/\/ needed for this case.\n-                PBEKeySpec pbeKeySpec = PBEUtil.getPBAKeySpec(key, params);\n-                try {\n-                    P11Key.P11PBEKey p11PBEKey =\n-                            P11SecretKeyFactory.derivePBEKey(token,\n-                            pbeKeySpec, svcPbeKi);\n-                    \/\/ This Mac service uses the token where the derived key\n-                    \/\/ lives so there won't be any need to re-derive and use\n-                    \/\/ the password. The p11Key cannot be accessed out of this\n-                    \/\/ class.\n-                    p11PBEKey.clearPassword();\n-                    p11Key = p11PBEKey;\n-                } catch (InvalidKeySpecException e) {\n-                    throw new InvalidKeyException(e);\n-                } finally {\n-                    pbeKeySpec.clearPassword();\n-                }\n+            \/\/ Do key derivation using P11SecretKeyFactory, then store the\n+            \/\/ derived key to p11Key\n+            PBEKeySpec pbeKeySpec = PBEUtil.getPBAKeySpec(key, params);\n+            try {\n+                P11Key.P11PBKDFKey derivedKey =\n+                        P11SecretKeyFactory.derivePBEKey(token,\n+                        pbeKeySpec, svcPbeKi);\n+                \/\/ This Mac service uses the token where the derived key\n+                \/\/ lives so there won't be any need to re-derive and use\n+                \/\/ the password. The p11Key cannot be accessed out of this\n+                \/\/ class.\n+                derivedKey.clearPassword();\n+                p11Key = derivedKey;\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(e);\n+            } finally {\n+                pbeKeySpec.clearPassword();\n@@ -233,0 +223,2 @@\n+        } else { \/\/ for the non-PBE case\n+            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n@@ -238,5 +230,0 @@\n-        \/\/ In non-PBE cases and PBE cases where we didn't derive,\n-        \/\/ a key conversion might be needed.\n-        if (p11Key == null) {\n-            p11Key = P11SecretKeyFactory.convertKey(token, key, algorithm);\n-        }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -131,40 +130,17 @@\n-        if (key instanceof P11Key) {\n-            \/\/ If the key is a P11Key, it must come from a PBE derivation\n-            \/\/ because this is a PBE Cipher service. In addition to checking the\n-            \/\/ key, check that params (if passed) are consistent.\n-            PBEUtil.checkKeyAndParams(key, params, pbeAlg);\n-            \/\/ At this point, we know that the key is a P11PBEKey.\n-            P11Key.P11PBEKey p11PBEKey = (P11Key.P11PBEKey) key;\n-            \/\/ PBE services require a PBE key of the same algorithm and the\n-            \/\/ underlying service (non-PBE) won't check it.\n-            if (!pbeAlg.equals(p11PBEKey.getAlgorithm())) {\n-                throw new InvalidKeyException(\"Cannot use a \" +\n-                        p11PBEKey.getAlgorithm() + \" key for a \" + pbeAlg +\n-                        \" service\");\n-            }\n-            if (params instanceof PBEParameterSpec pbeParams) {\n-                params = pbeParams.getParameterSpec();\n-            }\n-            pbes2Params.initialize(blkSize, opmode,\n-                    p11PBEKey.getIterationCount(), p11PBEKey.getSalt(), params,\n-                    random);\n-        } else {\n-            \/\/ If the key is not a P11Key, a derivation is needed. Data for\n-            \/\/ derivation has to be carried either as part of the key or params.\n-            \/\/ Use SunPKCS11 PBE key derivation to obtain a P11Key.\n-            PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n-                    blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n-            try {\n-                P11Key.P11PBEKey p11PBEKey = P11SecretKeyFactory.derivePBEKey(\n-                        token, pbeSpec, svcPbeKi);\n-                \/\/ The internal Cipher service uses the token where the\n-                \/\/ derived key lives so there won't be any need to re-derive\n-                \/\/ and use the password. The key cannot be accessed out of this\n-                \/\/ class.\n-                p11PBEKey.clearPassword();\n-                key = p11PBEKey;\n-            } catch (InvalidKeySpecException e) {\n-                throw new InvalidKeyException(e);\n-            } finally {\n-                pbeSpec.clearPassword();\n-            }\n+        \/\/ do key derivation, use P11SecretKeyFactory\n+        PBEKeySpec pbeSpec = pbes2Params.getPBEKeySpec(\n+                blkSize, svcPbeKi.keyLen, opmode, key, params, random);\n+        try {\n+            P11Key.P11PBKDFKey derivedKey =\n+                    P11SecretKeyFactory.derivePBEKey(\n+                    token, pbeSpec, svcPbeKi);\n+            \/\/ The internal Cipher service uses the token where the\n+            \/\/ derived key lives so there won't be any need to re-derive\n+            \/\/ and use the password. The key cannot be accessed out of this\n+            \/\/ class.\n+            derivedKey.clearPassword();\n+            key = derivedKey;\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            pbeSpec.clearPassword();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PBECipher.java","additions":17,"deletions":41,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -338,0 +338,6 @@\n+        KeyInfo ki = getKeyInfo(keyAlgo);\n+        if (ki == null) {\n+            throw new InvalidKeyException(\"Unknown algorithm \" + keyAlgo);\n+        }\n+\n+        KeyInfo si;\n@@ -340,0 +346,6 @@\n+            si = ki;\n+        } else {\n+            si = getKeyInfo(svcAlgo);\n+            if (si == null) {\n+                throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n+            }\n@@ -341,5 +353,1 @@\n-        KeyInfo ki = null;\n-        KeyInfo si = getKeyInfo(svcAlgo);\n-        if (si == null) {\n-            throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n-        }\n+\n@@ -348,4 +356,3 @@\n-        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo)) {\n-            ki = getKeyInfo(keyAlgo);\n-            if (ki == null || !KeyInfo.checkUse(ki, si)) {\n-                throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n+        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo) &&\n+                !KeyInfo.checkUse(ki, si)) {\n+            throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n@@ -353,1 +360,0 @@\n-            }\n@@ -355,0 +361,1 @@\n+\n@@ -385,1 +392,0 @@\n-            ki = ki == null ? getKeyInfo(keyAlgo) : ki;\n@@ -417,1 +423,3 @@\n-    static P11Key.P11PBEKey derivePBEKey(Token token, PBEKeySpec keySpec,\n+    \/\/ utility method for deriving secret keys using PBKDF2 or the legacy\n+    \/\/ PKCS#12 B.2 method.\n+    static P11Key.P11PBKDFKey derivePBEKey(Token token, PBEKeySpec keySpec,\n@@ -432,1 +440,1 @@\n-            int keySize = keySpec.getKeyLength();\n+            int keySize = keySpec.getKeyLength(); \/\/ in bits\n@@ -498,1 +506,1 @@\n-            return (P11Key.P11PBEKey) P11Key.pbeKey(session, keyID, pbeKi.algo,\n+            return (P11Key.P11PBKDFKey) P11Key.pbkdfKey(session, keyID, pbeKi.algo,\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -739,40 +739,0 @@\n-        \/*\n-         * PBE Secret Key Factories\n-         *\n-         * KeyDerivationPrf must be supported for these services\n-         * to be available.\n-         *\n-        *\/\n-        d(SKF, \"PBEWithHmacSHA1AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n-        d(SKF, \"PBEWithHmacSHA224AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n-        d(SKF, \"PBEWithHmacSHA256AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n-        d(SKF, \"PBEWithHmacSHA384AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n-        d(SKF, \"PBEWithHmacSHA512AndAES_128\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n-        d(SKF, \"PBEWithHmacSHA1AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA_1_HMAC));\n-        d(SKF, \"PBEWithHmacSHA224AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA224_HMAC));\n-        d(SKF, \"PBEWithHmacSHA256AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA256_HMAC));\n-        d(SKF, \"PBEWithHmacSHA384AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA384_HMAC));\n-        d(SKF, \"PBEWithHmacSHA512AndAES_256\",\n-                P11SecretKeyFactory, m(CKM_PKCS5_PBKD2), m(CKM_SHA512_HMAC));\n-        \/*\n-         * PBA Secret Key Factories\n-         *\/\n-        d(SKF, \"HmacPBESHA1\",       P11SecretKeyFactory,\n-                m(CKM_PBA_SHA1_WITH_SHA1_HMAC));\n-        d(SKF, \"HmacPBESHA224\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA224_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA256\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA256_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA384\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA384_HMAC_KEY_GEN));\n-        d(SKF, \"HmacPBESHA512\",     P11SecretKeyFactory,\n-                m(CKM_NSS_PKCS12_PBE_SHA512_HMAC_KEY_GEN));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -65,4 +65,0 @@\n-        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n-        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Cipher.\n-        SecretKeyFactoryDerivedKey,\n-\n@@ -204,5 +200,0 @@\n-            case SecretKeyFactoryDerivedKey -> {\n-                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n-                cipher.init(Cipher.ENCRYPT_MODE, key,\n-                        pbeSpec.getParameterSpec());\n-            }\n@@ -225,6 +216,0 @@\n-    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n-            String algorithm) throws GeneralSecurityException {\n-        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n-                .generateSecret(new PBEKeySpec(password, salt, iterations));\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/PBECipher.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -59,4 +59,0 @@\n-        \/\/ Derive a key using SunPKCS11's SecretKeyFactory (wrapping password,\n-        \/\/ salt and iterations in a PBEKeySpec), and pass it to a Mac.\n-        SecretKeyFactoryDerivedKey,\n-\n@@ -137,1 +133,1 @@\n-    private static void testWith(Provider sunPKCS11, AssertionData data,\n+    private static void testWith(Provider p, AssertionData data,\n@@ -143,1 +139,1 @@\n-        BigInteger mac = computeMac(sunPKCS11, svcAlgo, data.pbeHmacAlgo, conf);\n+        BigInteger mac = computeMac(p, svcAlgo, data.pbeHmacAlgo, conf);\n@@ -161,4 +157,0 @@\n-            case SecretKeyFactoryDerivedKey -> {\n-                SecretKey key = getDerivedSecretKey(p, keyAlgo);\n-                mac.init(key);\n-            }\n@@ -169,0 +161,1 @@\n+            default -> throw new RuntimeException(\"Unsupported configuration\");\n@@ -170,0 +163,1 @@\n+\n@@ -180,6 +174,0 @@\n-    private static SecretKey getDerivedSecretKey(Provider sunPKCS11,\n-            String algorithm) throws GeneralSecurityException {\n-        return SecretKeyFactory.getInstance(algorithm, sunPKCS11)\n-                .generateSecret(new PBEKeySpec(password, salt, iterations));\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/PBAMac.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335288\n+ * @bug 8335288 8348732\n@@ -56,5 +56,5 @@\n-        new TestData(\"SKF\", \"PBEWithHmacSHA1AndAES_128\", false),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA224AndAES_128\", true),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA256AndAES_128\", true),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA384AndAES_128\", false),\n-        new TestData(\"SKF\", \"PBEWithHmacSHA512AndAES_128\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA1\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA224\", true),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA256\", true),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA384\", false),\n+        new TestData(\"SKF\", \"PBKDF2WithHmacSHA512\", false),\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/RequiredMechCheck.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @bug 8301553\n+ * @bug 8301553 8348732\n@@ -77,32 +77,0 @@\n-    private static AssertionData p12PBKDAssertionData(String algo,\n-            char[] password, int keyLen, String hashAlgo, int blockLen,\n-            String staticExpectedKeyString) {\n-        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterations, keyLen);\n-        BigInteger staticExpectedKey = new BigInteger(staticExpectedKeyString,\n-                16);\n-        BigInteger expectedKey;\n-        try {\n-            \/\/ Since we need to access an internal\n-            \/\/ SunJCE API, we use reflection.\n-            Class<?> PKCS12PBECipherCore = Class.forName(\n-                    \"com.sun.crypto.provider.PKCS12PBECipherCore\");\n-\n-            Field macKeyField = PKCS12PBECipherCore.getDeclaredField(\"MAC_KEY\");\n-            macKeyField.setAccessible(true);\n-            int MAC_KEY = (int) macKeyField.get(null);\n-\n-            Method deriveMethod = PKCS12PBECipherCore.getDeclaredMethod(\n-                    \"derive\", char[].class, byte[].class, int.class,\n-                    int.class, int.class, String.class, int.class);\n-            deriveMethod.setAccessible(true);\n-            expectedKey = i((byte[]) deriveMethod.invoke(null,\n-                    keySpec.getPassword(), keySpec.getSalt(),\n-                    keySpec.getIterationCount(), keySpec.getKeyLength() \/ 8,\n-                    MAC_KEY, hashAlgo, blockLen));\n-            checkAssertionValues(expectedKey, staticExpectedKey);\n-        } catch (ReflectiveOperationException ignored) {\n-            expectedKey = staticExpectedKey;\n-        }\n-        return new AssertionData(algo, keySpec, expectedKey);\n-    }\n-\n@@ -150,10 +118,0 @@\n-    private static final AssertionData hmacPBESHA1Data =\n-            p12PBKDAssertionData(\"HmacPBESHA1\", pwd, 160, \"SHA-1\", 64,\n-                    \"13156c6bee8e13ef568231e0174651afa5a358b0\");\n-    private static final AssertionData hmacPBESHA224Data =\n-            p12PBKDAssertionData(\"HmacPBESHA224\", pwd, 224, \"SHA-224\", 64,\n-                    \"d93acf4b3bea8a89d098e290928840c0b693a30cad0117f70ace50c2\");\n-    private static final AssertionData pbeWithHmacSHA512AndAES256Data =\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n-                    \"7e3077595f90b60ab96d4f29203927b0\");\n@@ -166,13 +124,1 @@\n-            hmacPBESHA1Data,\n-            hmacPBESHA224Data,\n-            p12PBKDAssertionData(\"HmacPBESHA256\", pwd, 256, \"SHA-256\", 64,\n-                    \"1bb3ed1ffb784ed32f59b4d7515971699af99cf67a2e574000964c8e\" +\n-                    \"1eba1c45\"),\n-            p12PBKDAssertionData(\"HmacPBESHA384\", pwd, 384, \"SHA-384\", 128,\n-                    \"d4ce121d3cec88a8c8b0c6225f7f996b72d76017c2d91bc51fd47985\" +\n-                    \"86d1012d1ad03a39fdcd0fdc438d164ab50259fc\"),\n-            p12PBKDAssertionData(\"HmacPBESHA512\", pwd, 512, \"SHA-512\", 128,\n-                    \"5f80b350986e5156669193eaa42a107e7d6636d82fb550f67af5b2c2\" +\n-                    \"f546d977b70e52bbbcb6bb8976f9d3f0eaf9bfef5306c50ee5ccda3e\" +\n-                    \"e4c4c7c8421fe4d\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_128\", pwd, 128,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 128,\n@@ -180,9 +126,4 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_128\", pwd, 128,\n-                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA1AndAES_256\", pwd, 256,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 240,\n+                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n+                    \"b5552da5e645dad4b5911ce0f2\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 256,\n@@ -191,1 +132,3 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA224AndAES_256\", pwd, 256,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA224\", \"e328140e31f4ffb15af806986c23ee4e\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA224\", pwd, 256,\n@@ -194,10 +137,0 @@\n-            pbkd2AssertionData(\"PBEWithHmacSHA256AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n-                    \"44984e3e9b619488a42b93dd6453f630\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA384AndAES_256\", pwd, 256,\n-                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n-                    \"d7d0ad3a18912086f80d974f2acc2efb\"),\n-            pbeWithHmacSHA512AndAES256Data,\n-            pbkd2AssertionData(\"PBKDF2WithHmacSHA1\", pwd, 240,\n-                    \"PBKDF2WithHmacSHA1\", \"29958f3f1c942e50903189eb7f1ba09d40\" +\n-                    \"b5552da5e645dad4b5911ce0f2\"),\n@@ -207,0 +140,5 @@\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA256\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA256\", \"6851e387278dd5a3a0d05e4d742f59d8\" +\n+                    \"44984e3e9b619488a42b93dd6453f630\"),\n@@ -208,0 +146,5 @@\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 128,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\"),\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA384\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA384\", \"5570e2fb1a664910f055b71643b52351\" +\n+                    \"d7d0ad3a18912086f80d974f2acc2efb\"),\n@@ -212,0 +155,3 @@\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", pwd, 256,\n+                    \"PBKDF2WithHmacSHA512\", \"845560159e2f3f51dad8d6e0feccc898\" +\n+                    \"7e3077595f90b60ab96d4f29203927b0\"),\n@@ -217,5 +163,1 @@\n-            p12PBKDAssertionData(\"HmacPBESHA512\", emptyPwd, 512, \"SHA-512\",\n-                    128, \"90b6e088490c6c5e6b6e81209bd769d27df3868cae79591577a\" +\n-                    \"c35b46e4c6ebcc4b90f4943e3cb165f9d1789d938235f4b35ba74df9\" +\n-                    \"e509fbbb7aa329a432445\"),\n-            pbkd2AssertionData(\"PBEWithHmacSHA512AndAES_256\", emptyPwd, 256,\n+            pbkd2AssertionData(\"PBKDF2WithHmacSHA512\", emptyPwd, 256,\n@@ -394,2 +336,0 @@\n-        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n-                hmacPBESHA1Data.algo, sunPKCS11);\n@@ -399,2 +339,3 @@\n-        PBEKey p11PbeKey = (PBEKey) skf1.translateKey(getAnonymousPBEKey(\n-                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+        PBEKey p11PbeKey = (PBEKey) skf3.translateKey(getAnonymousPBEKey(\n+                skf3.getAlgorithm(), pbkdf2WithHmacSHA256Data.keySpec));\n+\n@@ -404,25 +345,3 @@\n-        assertThrows(e, \"PBE service requires a PBE key\",\n-                () -> skf1.translateKey(new SecretKeySpec(\n-                        new byte[10], hmacPBESHA1Data.algo)));\n-\n-        System.out.println(\" * PBEKey key to PBE SecretKeyFactory of a \" +\n-                \"different algorithm\");\n-        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n-                hmacPBESHA224Data.algo + \" service\",\n-                () -> SecretKeyFactory.getInstance(hmacPBESHA224Data.algo,\n-                        sunPKCS11).translateKey(p11PbeKey));\n-\n-        System.out.println(\" * Non-AES PBEKey key to AES SecretKeyFactory\");\n-        assertThrows(e, \"Cannot use a \" + hmacPBESHA1Data.algo + \" key for a \" +\n-                skf2.getAlgorithm() + \" service\",\n-                () -> skf2.translateKey(p11PbeKey));\n-\n-        System.out.println(\" * Inconsistent key length between key and \" +\n-                \"algorithm\");\n-        PBEKeySpec kSpec1 = new PBEKeySpec(pwd, salt, 1, 16);\n-        assertThrows(e, InvalidKeySpecException.class.getName() + \": Key \" +\n-                \"length is invalid for \" + skf1.getAlgorithm() + \" (expecting\" +\n-                \" \" + hmacPBESHA1Data.keySpec.getKeyLength() + \" but was \" +\n-                kSpec1.getKeyLength() + \")\",\n-                () -> skf1.translateKey(getAnonymousPBEKey(\n-                        skf1.getAlgorithm(), kSpec1)));\n+        assertThrows(e, \"Cannot use a AES key for a \" +\n+                pbkdf2WithHmacSHA256Data.algo + \" service\",\n+                () -> skf3.translateKey(new SecretKeySpec(new byte[10], \"AES\")));\n@@ -445,4 +364,0 @@\n-        SecretKeyFactory skf1 = SecretKeyFactory.getInstance(\n-                hmacPBESHA1Data.algo, sunPKCS11);\n-        SecretKeyFactory skf2 = SecretKeyFactory.getInstance(\n-                pbeWithHmacSHA512AndAES256Data.algo, sunPKCS11);\n@@ -454,16 +369,0 @@\n-        System.out.println(\" * Missing salt and iteration count\");\n-        assertThrows(e, \"Salt not found\",\n-                () -> skf1.generateSecret(new PBEKeySpec(pwd)));\n-\n-        System.out.println(\" * Inconsistent key length between spec and \" +\n-                \"algorithm\");\n-        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n-        assertThrows(e, \"Key length is invalid for \" + skf1.getAlgorithm() +\n-                \" (expecting \" + hmacPBESHA1Data.keySpec.getKeyLength() +\n-                \" but was \" + kSpec.getKeyLength() + \")\",\n-                () -> skf1.generateSecret(kSpec));\n-        assertThrows(e, \"Key length is invalid for \" + skf2.getAlgorithm() +\n-                \" (expecting \" + pbeWithHmacSHA512AndAES256Data.keySpec\n-                .getKeyLength() + \" but was \" + kSpec.getKeyLength() + \")\",\n-                () -> skf2.generateSecret(kSpec));\n-\n@@ -478,0 +377,1 @@\n+        PBEKeySpec kSpec = new PBEKeySpec(pwd, salt, 1, 16);\n@@ -490,1 +390,1 @@\n-                hmacPBESHA1Data.algo, sunPKCS11);\n+                pbkdf2WithHmacSHA256Data.algo, sunPKCS11);\n@@ -494,1 +394,1 @@\n-                skf1.getAlgorithm(), hmacPBESHA1Data.keySpec));\n+                skf1.getAlgorithm(), pbkdf2WithHmacSHA256Data.keySpec));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestPBKD.java","additions":32,"deletions":132,"binary":false,"changes":164,"status":"modified"}]}