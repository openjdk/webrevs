{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    Node * volatile _next;\n+    Atomic<Node*> _next;\n@@ -83,2 +83,2 @@\n-    void set_next(Node* node)         { _next = node; }\n-    Node* const volatile * next_ptr() { return &_next; }\n+    void set_next(Node* node) { _next.store_relaxed(node); }\n+    const Atomic<Node*>* next_ptr() const { return &_next; }\n@@ -126,1 +126,1 @@\n-    Node * volatile _first;\n+    Atomic<Node*> _first;\n@@ -160,0 +160,5 @@\n+    NONCOPYABLE(Bucket);\n+\n+    \/\/ Copy bucket's first entry to this.\n+    void assign(const Bucket& bucket);\n+\n@@ -166,1 +171,1 @@\n-    Node* const volatile * first_ptr() { return &_first; }\n+    const Atomic<Node*>* first_ptr() const { return &_first; }\n@@ -173,1 +178,1 @@\n-    void release_assign_node_ptr(Node* const volatile * dst, Node* node) const;\n+    void release_assign_node_ptr(const Atomic<Node*>* dst, Node* node) const;\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  return AtomicAccess::load_acquire(&_next);\n+  return _next.load_acquire();\n@@ -75,1 +75,1 @@\n-  return AtomicAccess::load_acquire(&_first);\n+  return _first.load_acquire();\n@@ -81,1 +81,1 @@\n-    typename ConcurrentHashTable<CONFIG, MT>::Node* const volatile * dst,\n+    const Atomic<typename ConcurrentHashTable<CONFIG, MT>::Node*>* dst,\n@@ -86,2 +86,9 @@\n-  Node** tmp = (Node**)dst;\n-  AtomicAccess::release_store(tmp, clear_set_state(node, *dst));\n+  Atomic<Node*>* tmp = const_cast<Atomic<Node*>*>(dst);\n+  tmp->release_store(clear_set_state(node, dst->load_relaxed()));\n+}\n+\n+template <typename CONFIG, MemTag MT>\n+inline void ConcurrentHashTable<CONFIG, MT>::\n+  Bucket::assign(const Bucket& bucket)\n+{\n+  _first.store_relaxed(bucket._first.load_relaxed());\n@@ -96,1 +103,1 @@\n-  return clear_state(AtomicAccess::load_acquire(&_first));\n+  return clear_state(_first.load_acquire());\n@@ -137,3 +144,3 @@\n-  Node* const volatile * ret = first_ptr();\n-  while (clear_state(*ret) != nullptr) {\n-    ret = clear_state(*ret)->next_ptr();\n+  const Atomic<Node*>* ret = first_ptr();\n+  while (clear_state(ret->load_relaxed()) != nullptr) {\n+    ret = clear_state(ret->load_relaxed())->next_ptr();\n@@ -153,1 +160,1 @@\n-  if (AtomicAccess::cmpxchg(&_first, expect, node) == expect) {\n+  if (_first.compare_exchange(expect, node) == expect) {\n@@ -168,1 +175,1 @@\n-  if (AtomicAccess::cmpxchg(&_first, tmp, set_state(tmp, STATE_LOCK_BIT)) == tmp) {\n+  if (_first.compare_exchange(tmp, set_state(tmp, STATE_LOCK_BIT)) == tmp) {\n@@ -181,1 +188,1 @@\n-  AtomicAccess::release_store(&_first, clear_state(first()));\n+  _first.release_store(clear_state(first()));\n@@ -189,1 +196,1 @@\n-  AtomicAccess::release_store(&_first, set_state(_first, STATE_REDIRECT_BIT));\n+  _first.release_store(set_state(_first.load_relaxed(), STATE_REDIRECT_BIT));\n@@ -416,2 +423,2 @@\n-    _new_table->get_buckets()[even_index] = *bucket;\n-    _new_table->get_buckets()[odd_index] = *bucket;\n+    _new_table->get_buckets()[even_index].assign(*bucket);\n+    _new_table->get_buckets()[odd_index].assign(*bucket);\n@@ -448,1 +455,1 @@\n-  Node* const volatile * rem_n_prev = bucket->first_ptr();\n+  const Atomic<Node*>* rem_n_prev = bucket->first_ptr();\n@@ -537,1 +544,1 @@\n-  Node* const volatile * rem_n_prev = bucket->first_ptr();\n+  const Atomic<Node*>* rem_n_prev = bucket->first_ptr();\n@@ -646,2 +653,2 @@\n-  Node* const volatile * even = new_table->get_bucket(even_index)->first_ptr();\n-  Node* const volatile * odd = new_table->get_bucket(odd_index)->first_ptr();\n+  const Atomic<Node*>* even = new_table->get_bucket(even_index)->first_ptr();\n+  const Atomic<Node*>* odd = new_table->get_bucket(odd_index)->first_ptr();\n@@ -745,1 +752,1 @@\n-    _new_table->get_buckets()[bucket_it] = *b_old_even;\n+    _new_table->get_buckets()[bucket_it].assign(*b_old_even);\n@@ -749,1 +756,1 @@\n-      release_assign_last_node_next(*(b_old_odd->first_ptr()));\n+      release_assign_last_node_next(b_old_odd->first_ptr()->load_relaxed());\n@@ -984,1 +991,1 @@\n-  Node* const volatile * rem_n_prev = bucket->first_ptr();\n+  const Atomic<Node*>* rem_n_prev = bucket->first_ptr();\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"}]}