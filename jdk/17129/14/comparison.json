{"files":[{"patch":"@@ -58,0 +58,2 @@\n+\n+import jdk.internal.event.SerializationMisdeclarationEvent;\n@@ -462,0 +464,4 @@\n+\n+        if (SerializationMisdeclarationEvent.enabled() && serializable) {\n+            SerializationMisdeclarationChecker.checkMisdeclarations(cl);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+\n+import static jdk.internal.event.SerializationMisdeclarationEvent.*;\n+import static java.lang.reflect.Modifier.*;\n+\n+final class SerializationMisdeclarationChecker {\n+\n+    private static final String SUID_NAME = \"serialVersionUID\";\n+    private static final String SERIAL_PERSISTENT_FIELDS_NAME = \"serialPersistentFields\";\n+    private static final String WRITE_OBJECT_NAME = \"writeObject\";\n+    private static final String READ_OBJECT_NAME = \"readObject\";\n+    private static final String READ_OBJECT_NO_DATA_NAME = \"readObjectNoData\";\n+    private static final String WRITE_REPLACE_NAME = \"writeReplace\";\n+    private static final String READ_RESOLVE_NAME = \"readResolve\";\n+\n+    private static final Class<?>[] WRITE_OBJECT_PARAM_TYPES = {ObjectOutputStream.class};\n+    private static final Class<?>[] READ_OBJECT_PARAM_TYPES = {ObjectInputStream.class};\n+\n+    \/*\n+     * The sharing of a single Class<?>[] instance here is just to avoid wasting\n+     * space, and should not be considered as a conceptual sharing of types.\n+     *\/\n+    private static final Class<?>[] READ_OBJECT_NO_DATA_PARAM_TYPES = {};\n+    private static final Class<?>[] WRITE_REPLACE_PARAM_TYPES = READ_OBJECT_NO_DATA_PARAM_TYPES;\n+    private static final Class<?>[] READ_RESOLVE_PARAM_TYPES = READ_OBJECT_NO_DATA_PARAM_TYPES;\n+\n+    static void checkMisdeclarations(Class<?> cl) {\n+        checkSerialVersionUID(cl);\n+        checkSerialPersistentFields(cl);\n+\n+        checkPrivateMethod(cl, WRITE_OBJECT_NAME,\n+                WRITE_OBJECT_PARAM_TYPES, Void.TYPE);\n+        checkPrivateMethod(cl, READ_OBJECT_NAME,\n+                READ_OBJECT_PARAM_TYPES, Void.TYPE);\n+        checkPrivateMethod(cl, READ_OBJECT_NO_DATA_NAME,\n+                READ_OBJECT_NO_DATA_PARAM_TYPES, Void.TYPE);\n+\n+        checkAccessibleMethod(cl, WRITE_REPLACE_NAME,\n+                WRITE_REPLACE_PARAM_TYPES, Object.class);\n+        checkAccessibleMethod(cl, READ_RESOLVE_NAME,\n+                READ_RESOLVE_PARAM_TYPES, Object.class);\n+    }\n+\n+    private static void checkSerialVersionUID(Class<?> cl) {\n+        Field f = privilegedDeclaredField(cl, SUID_NAME);\n+        if (f == null) {\n+            if (isOrdinaryClass(cl)) {\n+                commitEvent(cl, SUID_NAME + \" should be declared explicitly\" +\n+                        \" as a private static final long field\");\n+            }\n+            return;\n+        }\n+        if (cl.isEnum()) {\n+            commitEvent(cl, SUID_NAME + \" should not be declared in an enum class\");\n+        }\n+        if (!isPrivate(f)) {\n+            commitEvent(cl, SUID_NAME + \" should be private\");\n+        }\n+        if (!isStatic(f)) {\n+            commitEvent(cl, SUID_NAME + \" must be static\");\n+        }\n+        if (!isFinal(f)) {\n+            commitEvent(cl, SUID_NAME + \" must be final\");\n+        }\n+        if (f.getType() != Long.TYPE) {\n+            commitEvent(cl, SUID_NAME + \" must be of type long\");\n+        }\n+    }\n+\n+    private static void checkSerialPersistentFields(Class<?> cl) {\n+        Field f = privilegedDeclaredField(cl, SERIAL_PERSISTENT_FIELDS_NAME);\n+        if (f == null) {\n+            return;\n+        }\n+        if (cl.isRecord()) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME +\n+                    \" should not be declared in a record class\");\n+        } else if (cl.isEnum()) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME +\n+                    \" should not be declared in an enum class\");\n+        }\n+        if (!isPrivate(f)) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME + \" must be private\");\n+        }\n+        if (!isStatic(f)) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME + \" must be static\");\n+        }\n+        if (!isFinal(f)) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME + \" must be final\");\n+        }\n+        if (f.getType() != ObjectStreamField[].class) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME +\n+                    \" should be of type ObjectStreamField[]\");\n+        }\n+        if (!isStatic(f)) {\n+            return;\n+        }\n+        f.setAccessible(true);\n+        Object spf = objectFromStatic(f);\n+        if (spf == null) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME + \" should be non-null\");\n+            return;\n+        }\n+        if (!(spf instanceof ObjectStreamField[])) {\n+            commitEvent(cl, SERIAL_PERSISTENT_FIELDS_NAME +\n+                    \" must be an instance of ObjectStreamField[]\");\n+        }\n+    }\n+\n+    private static void checkPrivateMethod(Class<?> cl,\n+            String name, Class<?>[] paramTypes, Class<?> retType) {\n+        for (Method m : privilegedDeclaredMethods(cl)) {\n+            if (m.getName().equals(name)) {\n+                checkPrivateMethod(cl, m, paramTypes, retType);\n+            }\n+        }\n+    }\n+\n+    private static void checkPrivateMethod(Class<?> cl,\n+            Method m, Class<?>[] paramTypes, Class<?> retType) {\n+        if (cl.isEnum()) {\n+            commitEvent(cl, \"method \" + m + \" should not be declared in an enum class\");\n+        } else if (cl.isRecord()) {\n+            commitEvent(cl, \"method \" + m + \" should not be declared in a record class\");\n+        }\n+        if (!isPrivate(m)) {\n+            commitEvent(cl, \"method \" + m + \" must be private\");\n+        }\n+        if (isStatic(m)) {\n+            commitEvent(cl, \"method \" + m + \" must be non-static\");\n+        }\n+        if (m.getReturnType() != retType) {\n+            commitEvent(cl, \"method \" + m + \" must have return type \" + retType);\n+        }\n+        if (!Arrays.equals(m.getParameterTypes(), paramTypes)) {\n+            commitEvent(cl, \"method \" + m + \" must have parameter types \" + Arrays.toString(paramTypes));\n+        }\n+    }\n+\n+    private static void checkAccessibleMethod(Class<?> cl,\n+            String name, Class<?>[] paramTypes, Class<?> retType) {\n+        for (Class<?> superCl = cl; superCl != null; superCl = superCl.getSuperclass()) {\n+            for (Method m : privilegedDeclaredMethods(superCl)) {\n+                if (m.getName().equals(name)) {\n+                    checkAccessibleMethod(cl, superCl, m, paramTypes, retType);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkAccessibleMethod(Class<?> cl,\n+            Class<?> superCl, Method m, Class<?>[] paramTypes, Class<?> retType) {\n+        if (superCl.isEnum()) {\n+            commitEvent(cl, \"method \" + m + \" should not be declared in an enum class\");\n+        }\n+        if (isAbstract(m)) {\n+            commitEvent(cl, \"method \" + m + \" must be non-abstract\");\n+        }\n+        if (isStatic(m)) {\n+            commitEvent(cl, \"method \" + m + \" must be non-static\");\n+        }\n+        if (m.getReturnType() != retType) {\n+            commitEvent(cl, \"method \" + m + \" must have return type \" + retType);\n+        }\n+        if (!Arrays.equals(m.getParameterTypes(), paramTypes)) {\n+            commitEvent(cl, \"method \" + m + \" must have parameter types \" + Arrays.toString(paramTypes));\n+        }\n+        if (isPrivate(m) && cl != superCl\n+                || isPackageProtected(m) && !isSamePackage(cl, superCl)) {\n+            commitEvent(cl, \"method \" + m + \" is not accessible\");\n+        }\n+    }\n+\n+    private static boolean isSamePackage(Class<?> cl0, Class<?> cl1) {\n+        return cl0.getClassLoader() == cl1.getClassLoader()\n+                && cl0.getPackageName().equals(cl1.getPackageName());\n+    }\n+\n+    private static boolean isOrdinaryClass(Class<?> cl) {\n+        \/* class Enum and class Record are not considered ordinary classes *\/\n+        return !(cl.isRecord() || cl.isEnum() || cl.isArray()\n+                || Enum.class == cl || Record.class == cl\n+                || Proxy.isProxyClass(cl));\n+    }\n+\n+    private static boolean isPrivate(Member m) {\n+        return (m.getModifiers() & PRIVATE) != 0;\n+    }\n+\n+    private static boolean isPackageProtected(Member m) {\n+        return (m.getModifiers() & (PRIVATE | PROTECTED | PUBLIC)) == 0;\n+    }\n+\n+    private static boolean isAbstract(Member m) {\n+        return (m.getModifiers() & ABSTRACT) != 0;\n+    }\n+\n+    private static boolean isFinal(Member m) {\n+        return (m.getModifiers() & FINAL) != 0;\n+    }\n+\n+    private static boolean isStatic(Member m) {\n+        return (m.getModifiers() & STATIC) != 0;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Field privilegedDeclaredField(Class<?> cl, String name) {\n+        if (System.getSecurityManager() == null) {\n+            return declaredField(cl, name);\n+        }\n+        return AccessController.doPrivileged((PrivilegedAction<Field>) () ->\n+                declaredField(cl, name));\n+    }\n+\n+    private static Field declaredField(Class<?> cl, String name) {\n+        try {\n+            return cl.getDeclaredField(name);\n+        } catch (NoSuchFieldException ignored) {\n+        }\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static Method[] privilegedDeclaredMethods(Class<?> cl) {\n+        if (System.getSecurityManager() == null) {\n+            return cl.getDeclaredMethods();\n+        }\n+        return AccessController.doPrivileged(\n+                (PrivilegedAction<Method[]>) cl::getDeclaredMethods);\n+    }\n+\n+    private static Object objectFromStatic(Field f) {\n+        try {\n+            return f.get(null);\n+        } catch (IllegalAccessException ignored) {\n+        }\n+        return null;\n+    }\n+\n+    private static void commitEvent(Class<?> cl, String msg) {\n+        commit(timestamp(), cl, msg);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/SerializationMisdeclarationChecker.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.event;\n+\n+\/**\n+ * A JFR event for serialization misdeclarations.\n+ * This event is mirrored in {@code jdk.jfr.events.SerializationMisdeclarationEvent}\n+ * where the metadata for the event is provided with annotations.\n+ * Some of the methods are replaced by generated methods when jfr is enabled.\n+ * Note that the order of the arguments of the {@link #commit(long,Class,String)}\n+ * method must be the same as the order of the fields.\n+ *\/\n+public class SerializationMisdeclarationEvent extends Event {\n+\n+    public Class<?> misdeclaredClass;\n+    public String message;\n+\n+    \/**\n+     * Commit a serialization misdeclaration event.\n+     * The implementation of this method is generated automatically if jfr is enabled.\n+     * The order of the fields must be the same as the parameters in this method.\n+     * {@code commit(long,Class,String)}\n+     *\n+     * @param start             timestamp of the start of the operation\n+     * @param misdeclaredClass  the affected class\n+     * @param message           the specific event message\n+     *\/\n+    public static void commit(long start, Class<?> misdeclaredClass, String message) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    \/**\n+     * Determine if an event should be emitted.  The duration of the operation\n+     * must exceed some threshold in order to commit the event.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @param duration  time in nanoseconds to complete the operation\n+     * @return  true if the event should be commited\n+     *\/\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    \/**\n+     * Determine if this kind of event is enabled.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @return whether serialization misdeclaration events are enabled\n+     *\/\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    \/**\n+     * Fetch the current timestamp in nanoseconds.  This method is used\n+     * to determine the start and end of an operation.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @return  the current timestamp value\n+     *\/\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SerializationMisdeclarationEvent.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+import jdk.jfr.internal.RemoveFields;\n+import jdk.jfr.internal.Type;\n+\n+@Name(Type.EVENT_NAME_PREFIX + \"SerializationMisdeclaration\")\n+@Label(\"Serialization Misdeclaration\")\n+@Category({\"Java Development Kit\", \"Serialization\"})\n+@Description(\"Methods and fields misdeclarations.\" +\n+        \" The checks are usually performed just once per serializable class,\" +\n+        \" the first time it is used by serialization.\" +\n+        \" Under high memory pressure, a class might be re-checked again.\")\n+@MirrorEvent(className = \"jdk.internal.event.SerializationMisdeclarationEvent\")\n+@RemoveFields({\"duration\", \"stackTrace\", \"eventThread\"})\n+public final class SerializationMisdeclarationEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Misdeclared Class\")\n+    public Class<?> misdeclaredClass;\n+\n+    @Label(\"Message\")\n+    public String message;\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SerializationMisdeclarationEvent.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.jfr.events.SerializationMisdeclarationEvent;\n@@ -55,0 +56,1 @@\n+        SerializationMisdeclarationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        jdk.internal.event.SerializationMisdeclarationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -757,0 +757,4 @@\n+    <\/event>\n+\n+    <event name=\"jdk.SerializationMisdeclaration\">\n+        <setting name=\"enabled\">false<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -758,0 +758,4 @@\n+\n+    <event name=\"jdk.SerializationMisdeclaration\">\n+        <setting name=\"enabled\">true<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serial;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static jdk.test.lib.jfr.EventNames.SerializationMisdeclaration;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+\/*\n+ * @test\n+ * @bug 8275338\n+ * @summary Check generation of JFR events for misdeclared fields and methods\n+ *          relevant to serialization\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run junit\/othervm jdk.jfr.event.io.TestSerializationMisdeclarationEvent\n+ *\/\n+public class TestSerializationMisdeclarationEvent {\n+\n+    private static final List<RecordedEvent> events = new ArrayList<>();\n+\n+    @BeforeAll\n+    static void recordEvents() {\n+        try (var rs = new RecordingStream()) {\n+            rs.enable(SerializationMisdeclaration);\n+            rs.onEvent(SerializationMisdeclaration, events::add);\n+            rs.startAsync();\n+            doLookups();\n+            rs.stop();\n+        }\n+    }\n+\n+    static Arguments[] testSingleClassMisdeclarations() {\n+        return new Arguments[] {\n+                arguments(NoSUID.class, new String[] {\"serialVersionUID\", \"should\", \"explicitly\"}),\n+                arguments(NoSUID.class, new String[] {\"serialPersistentFields\", \"should\", \"non-null\"}),\n+\n+                arguments(BadClass.class, new String[] {\"serialVersionUID\", \"should\", \"private\"}),\n+                arguments(BadClass.class, new String[] {\"serialVersionUID\", \"must\", \"type\", \"long\"}),\n+                arguments(BadClass.class, new String[] {\"serialVersionUID\", \"must\", \"final\"}),\n+                arguments(BadClass.class, new String[] {\"serialVersionUID\", \"must\", \"static\"}),\n+                arguments(BadClass.class, new String[] {\"serialPersistentFields\", \"must\", \"private\"}),\n+                arguments(BadClass.class, new String[] {\"serialPersistentFields\", \"must\", \"static\"}),\n+                arguments(BadClass.class, new String[] {\"serialPersistentFields\", \"must\", \"final\"}),\n+                arguments(BadClass.class, new String[] {\"serialPersistentFields\", \"should\", \"type\", \"ObjectStreamField[]\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"writeObject\", \"must\", \"private\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"writeObject\", \"must\", \"non-static\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"writeObject\", \"must\", \"return\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"writeObject\", \"must\", \"parameter\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"readObject(\", \"must\", \"parameter\"}),\n+                arguments(BadClass.class, new String[] {\"method\", \"readObjectNoData\", \"must\", \"parameter\"}),\n+\n+                arguments(EnumClass.class, new String[] {\"serialVersionUID\", \"enum\"}),\n+                arguments(EnumClass.class, new String[] {\"serialPersistentFields\", \"enum\"}),\n+                arguments(EnumClass.class, new String[] {\"method\", \"writeObject\", \"enum\"}),\n+                arguments(EnumClass.class, new String[] {\"method\", \"readResolve\", \"enum\"}),\n+\n+                arguments(RecordClass.class, new String[] {\"serialPersistentFields\", \"record\"}),\n+                arguments(RecordClass.class, new String[] {\"method\", \"record\"}),\n+\n+                arguments(C.class, new String[] {\"method\", \"not\", \"accessible\"}),\n+\n+                arguments(Acc.class, new String[] {\"serialPersistentFields\", \"should\", \"type\", \"ObjectStreamField[]\"}),\n+                arguments(Acc.class, new String[] {\"serialPersistentFields\", \"must\", \"instance\", \"ObjectStreamField[]\"}),\n+                arguments(Acc.class, new String[] {\"method\", \"readResolve\", \"must\", \"non-abstract\"}),\n+                arguments(Acc.class, new String[] {\"method\", \"writeReplace\", \"must\", \"non-static\"}),\n+                arguments(Acc.class, new String[] {\"method\", \"writeReplace\", \"must\", \"return\"}),\n+                arguments(Acc.class, new String[] {\"method\", \"writeReplace\", \"must\", \"parameter\"}),\n+        };\n+    }\n+\n+    static Arguments[] testGoodClass() {\n+        return new Arguments[] {\n+                arguments(A.class),\n+                arguments(B.class),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSingleClassMisdeclarations(Class<?> cls, String[] keywords) {\n+        singleClassEvent(cls, keywords);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGoodClass(Class<?> cls) {\n+        assertEquals(0, getEventsFor(cls).size(), cls.getName());\n+    }\n+\n+    private static void doLookups() {\n+        ObjectStreamClass.lookup(NoSUID.class);\n+        ObjectStreamClass.lookup(BadClass.class);\n+        ObjectStreamClass.lookup(EnumClass.class);\n+        ObjectStreamClass.lookup(RecordClass.class);\n+        ObjectStreamClass.lookup(Acc.class);\n+\n+        ObjectStreamClass.lookup(A.class);\n+        ObjectStreamClass.lookup(B.class);\n+        ObjectStreamClass.lookup(C.class);\n+    }\n+\n+    private static void singleClassEvent(Class<?> cls, String[] keywords) {\n+        assertEquals(1, getEventsFor(cls, keywords).size(), cls.getName());\n+    }\n+\n+    private static List<RecordedEvent> getEventsFor(Class<?> cls, String[] keywords) {\n+        return events.stream()\n+                .filter(e -> e.getClass(\"misdeclaredClass\").getName().equals(cls.getName())\n+                        && matchesAllKeywords(e.getString(\"message\"), keywords))\n+                .toList();\n+    }\n+\n+    private static boolean matchesAllKeywords(String msg, String[] keywords) {\n+        return Arrays.stream(keywords).allMatch(msg::contains);\n+    }\n+\n+    private static List<RecordedEvent> getEventsFor(Class<?> cls) {\n+        return events.stream()\n+                .filter(e -> e.getClass(\"misdeclaredClass\").getName().equals(cls.getName()))\n+                .toList();\n+    }\n+\n+    private static class A implements Serializable {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xAAAAL;\n+\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n+\n+        @Serial\n+        private void writeObject(ObjectOutputStream oos) {\n+        }\n+\n+        @Serial\n+        private void readObject(ObjectInputStream ois) {\n+        }\n+\n+        @Serial\n+        private void readObjectNoData() {\n+        }\n+\n+        @Serial\n+        Object writeReplace() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private static class B extends A {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xBBBBL;\n+\n+        @Serial\n+        private Object readResolve() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private static final class C extends B {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xCCCCL;\n+\n+        \/*\n+         * readResolve() in superclass is not accessible\n+         *\/\n+\n+    }\n+\n+    private static final class NoSUID implements Serializable {\n+\n+        \/*\n+         * should declare serialVersionUID\n+         *\/\n+\n+        \/*\n+         * value should be non-null\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields = null;\n+\n+    }\n+\n+    private static final class BadClass implements Serializable {\n+        \/*\n+         * should be private\n+         * must be long\n+         * must be final\n+         *\/\n+        Object serialVersionUID = 1.2;\n+\n+        \/*\n+         * must be private\n+         * must be static\n+         * must be final\n+         * should be ObjectStreamField[]\n+         *\/\n+        Object serialPersistentFields = new String[0];\n+\n+        \/*\n+         * must be private\n+         * must be non-static\n+         * must return void\n+         * must accept ObjectOutputStream\n+         *\/\n+        static int writeObject(int i) {\n+            return 0;\n+        }\n+\n+        \/*\n+         * must accept ObjectInputStream\n+         *\/\n+        private void readObject(ObjectOutputStream oos) {\n+        }\n+\n+        \/*\n+         * must not accept parameters\n+         *\/\n+        private void readObjectNoData(ObjectInputStream ois) {\n+        }\n+\n+    }\n+\n+    private enum EnumClass implements Serializable {\n+        __;  \/\/ ignored constant\n+\n+        \/*\n+         * non-effective on enum\n+         *\/\n+        private static final long serialVersionUID = 0xABCDL;\n+\n+        \/*\n+         * non-effective on enum\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n+\n+        \/*\n+         * non-effective on enum\n+         *\/\n+        private void writeObject(ObjectOutputStream oos) {\n+        }\n+\n+        \/*\n+         * non-effective on enum\n+         *\/\n+        public Object readResolve() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private record RecordClass() implements Serializable {\n+\n+        \/*\n+         * allowed on records\n+         *\/\n+        private static final long serialVersionUID = 0x1234L;\n+\n+        \/*\n+         * non-effective on records\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n+\n+        \/*\n+         * non-effective on records\n+         *\/\n+        static int writeObject(int i) {\n+            return 0;\n+        }\n+\n+    }\n+\n+    private abstract static class Acc implements Serializable {\n+\n+        private static final long serialVersionUID = 0x5678L;\n+\n+        private static final Object serialPersistentFields = new String[0];\n+        \/*\n+         * must be non-abstract\n+         *\/\n+        abstract Object readResolve();\n+\n+        \/*\n+         * must be non-static\n+         *\/\n+        static Object writeReplace() {\n+            return null;\n+        }\n+\n+        \/*\n+         * must return Object\n+         * must have empty parameter types\n+         *\/\n+        String writeReplace(String s) {\n+            return null;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSerializationMisdeclarationEvent.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -212,0 +212,1 @@\n+    public static final String SerializationMisdeclaration = PREFIX + \"SerializationMisdeclaration\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}