{"files":[{"patch":"@@ -58,0 +58,2 @@\n+\n+import jdk.internal.event.SerializationMisdeclarationEvent;\n@@ -462,0 +464,4 @@\n+\n+        if (SerializationMisdeclarationEvent.enabled() && serializable) {\n+            new SerializationMisdeclarationChecker(cl).checkMisdeclarations();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+\n+import static jdk.internal.event.SerializationMisdeclarationEvent.*;\n+import static java.lang.reflect.Modifier.*;\n+\n+final class SerializationMisdeclarationChecker {\n+\n+    private static final String SUID_NAME = \"serialVersionUID\";\n+    private static final String SERIAL_PERSISTENT_FIELDS_NAME = \"serialPersistentFields\";\n+    private static final String WRITE_OBJECT_NAME = \"writeObject\";\n+    private static final String READ_OBJECT_NAME = \"readObject\";\n+    private static final String READ_OBJECT_NO_DATA_NAME = \"readObjectNoData\";\n+    private static final String WRITE_REPLACE_NAME = \"writeReplace\";\n+    private static final String READ_RESOLVE_NAME = \"readResolve\";\n+\n+    private static final Class<?>[] WRITE_OBJECT_PARAM_TYPES = {ObjectOutputStream.class};\n+    private static final Class<?>[] READ_OBJECT_PARAM_TYPES = {ObjectInputStream.class};\n+    private static final Class<?>[] READ_OBJECT_NO_DATA_PARAM_TYPES = {};\n+    private static final Class<?>[] WRITE_REPLACE_PARAM_TYPES = {};\n+    private static final Class<?>[] READ_RESOLVE_PARAM_TYPES = {};\n+\n+    private final Class<?> cl;\n+\n+    SerializationMisdeclarationChecker(Class<?> cl) {\n+        this.cl = cl;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    void checkMisdeclarations() {\n+        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n+            privilegedCheckSerialVersionUID();\n+            privilegedCheckSerialPersistentFields();\n+\n+            privilegedCheckPrivateMethod(WRITE_OBJECT_NAME, WRITE_OBJECT_PARAM_TYPES, Void.TYPE);\n+            privilegedCheckPrivateMethod(READ_OBJECT_NAME, READ_OBJECT_PARAM_TYPES, Void.TYPE);\n+            privilegedCheckPrivateMethod(READ_OBJECT_NO_DATA_NAME, READ_OBJECT_NO_DATA_PARAM_TYPES, Void.TYPE);\n+\n+            privilegedCheckAccessibleMethod(WRITE_REPLACE_NAME, WRITE_REPLACE_PARAM_TYPES, Object.class);\n+            privilegedCheckAccessibleMethod(READ_RESOLVE_NAME, READ_RESOLVE_PARAM_TYPES, Object.class);\n+\n+            return null;\n+        });\n+    }\n+\n+    private void privilegedCheckSerialVersionUID() {\n+        Field f = declaredField(cl, SUID_NAME);\n+        if (f == null) {\n+            if (isOrdinaryClass()) {\n+                commitEvent(SUID_EXPLICIT,\n+                        \"a private static final long \" + SUID_NAME +\n+                                \" field should be declared\");\n+            }\n+            return;\n+        }\n+        if (cl.isEnum()) {\n+            commitEvent(SUID_INEFFECTIVE_ENUM,\n+                    SUID_NAME + \" is not effective in an enum class\");\n+        }\n+        if (!isPrivate(f)) {\n+            commitEvent(SUID_PRIVATE,\n+                    SUID_NAME + \" should be declared private\");\n+        }\n+        if (!isStatic(f)) {\n+            commitEvent(SUID_STATIC,\n+                    SUID_NAME + \" must be declared static to be effective\");\n+        }\n+        if (!isFinal(f)) {\n+            commitEvent(SUID_FINAL,\n+                    SUID_NAME + \" must be declared final to be effective\");\n+        }\n+        if (f.getType() != Long.TYPE) {\n+            commitEvent(SUID_LONG,\n+                    SUID_NAME + \" should be declared of type long\");\n+        }\n+        if (!isStatic(f)) {\n+            return;\n+        }\n+        f.setAccessible(true);\n+        if (getLong(f) == null) {\n+            commitEvent(SUID_CONVERTIBLE_TO_LONG,\n+                    SUID_NAME + \" must be convertible to long via widening to be effective\");\n+        }\n+    }\n+\n+    private void privilegedCheckSerialPersistentFields() {\n+        Field f = declaredField(cl, SERIAL_PERSISTENT_FIELDS_NAME);\n+        if (f == null) {\n+            return;\n+        }\n+        if (cl.isRecord()) {\n+            commitEvent(SER_PERS_INEFFECTIVE_RECORD,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" is not effective in a record class\");\n+        } else if (cl.isEnum()) {\n+            commitEvent(SER_PERS_INEFFECTIVE_ENUM,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" is not effective in an enum class\");\n+        }\n+        if (!isPrivate(f)) {\n+            commitEvent(SER_PERS_PRIVATE,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" must be declared private to be effective\");\n+        }\n+        if (!isStatic(f)) {\n+            commitEvent(SER_PERS_STATIC,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" must be declared static to be effective\");\n+        }\n+        if (!isFinal(f)) {\n+            commitEvent(SER_PERS_FINAL,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" must be declared final to be effective\");\n+        }\n+        if (f.getType() != ObjectStreamField[].class) {\n+            commitEvent(SER_PERS_TYPE_OSF_ARRAY,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" should be declared of type ObjectStreamField[]\");\n+        }\n+        if (!isStatic(f)) {\n+            return;\n+        }\n+        f.setAccessible(true);\n+        Object spf = getObject(f);\n+        if (spf == null) {\n+            commitEvent(SER_PERS_NOT_NULL,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" must not be null to be effective\");\n+            return;\n+        }\n+        if (!(spf instanceof ObjectStreamField[])) {\n+            commitEvent(SER_PERS_VALUE_OSF_ARRAY,\n+                    SERIAL_PERSISTENT_FIELDS_NAME + \" must be an instance of ObjectStreamField[] to be effective\");\n+        }\n+    }\n+\n+    private void privilegedCheckPrivateMethod(String name, Class<?>[] paramTypes, Class<?> retType) {\n+        for (Method m : cl.getDeclaredMethods()) {\n+            if (m.getName().equals(name)) {\n+                privilegedCheckPrivateMethod(m, paramTypes, retType);\n+            }\n+        }\n+    }\n+\n+    private void privilegedCheckPrivateMethod(Method m, Class<?>[] paramTypes, Class<?> retType) {\n+        if (cl.isEnum()) {\n+            commitEvent(PRIV_METH_INEFFECTIVE_ENUM,\n+                    m + \" is not effective on an enum class\");\n+        } else if (cl.isRecord()) {\n+            commitEvent(PRIV_METH_INEFFECTIVE_RECORD,\n+                    m + \" is not effective on a record class\");\n+        }\n+        if (!isPrivate(m)) {\n+            commitEvent(PRIV_METH_PRIV,\n+                    m + \" must be private to be effective\");\n+        }\n+        if (isStatic(m)) {\n+            commitEvent(PRIV_METH_NON_STATIC,\n+                    m + \" must be non-static to be effective\");\n+        }\n+        if (m.getReturnType() != retType) {\n+            commitEvent(PRIV_METH_RET_TYPE,\n+                    m + \" must have return type \" + retType + \" to be effective\");\n+        }\n+        if (!Arrays.equals(m.getParameterTypes(), paramTypes)) {\n+            commitEvent(PRIV_METH_PARAM_TYPES,\n+                    m + \" must have parameter types \" + Arrays.toString(paramTypes) + \" to be effective\");\n+        }\n+    }\n+\n+    private void privilegedCheckAccessibleMethod(String name,\n+            Class<?>[] paramTypes, Class<?> retType) {\n+        for (Class<?> cls = cl; cls != null; cls = cls.getSuperclass()) {\n+            for (Method m : cls.getDeclaredMethods()) {\n+                if (m.getName().equals(name)) {\n+                    privilegedCheckAccessibleMethod(cls, m, paramTypes, retType);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void privilegedCheckAccessibleMethod(Class<?> cls, Method m,\n+            Class<?>[] paramTypes, Class<?> retType) {\n+        if (cls.isEnum()) {\n+            commitEvent(cls, ACC_METH_INEFFECTIVE_ENUM,\n+                    m + \" is not effective on an enum class\");\n+        }\n+        if (isAbstract(m)) {\n+            commitEvent(ACC_METH_NON_ABSTRACT,\n+                    m + \" must be non-abstract to be effective\");\n+        }\n+        if (isStatic(m)) {\n+            commitEvent(ACC_METH_NON_STATIC,\n+                    m + \" must be non-static to be effective\");\n+        }\n+        if (m.getReturnType() != retType) {\n+            commitEvent(ACC_METH_RET_TYPE,\n+                    m + \" must have return type \" + retType + \" to be effective\");\n+        }\n+        if (!Arrays.equals(m.getParameterTypes(), paramTypes)) {\n+            commitEvent(ACC_METH_PARAM_TYPES,\n+                    m + \" must have parameter types \" + Arrays.toString(paramTypes) + \" to be effective\");\n+        }\n+        if (isPrivate(m) && cl != cls\n+                || isPackageProtected(m) && !isSamePackage(cl, cls)) {\n+            commitEvent(ACC_METH_NON_ACCESSIBLE,\n+                    m + \" is not accessible\");\n+        }\n+    }\n+\n+    private static boolean isSamePackage(Class<?> cl0, Class<?> cl1) {\n+        return cl0.getClassLoader() == cl1.getClassLoader()\n+                && cl0.getPackageName().equals(cl1.getPackageName());\n+    }\n+\n+    private boolean isOrdinaryClass() {\n+        \/* class Enum and class Record are not considered ordinary classes *\/\n+        return !(cl.isRecord() || cl.isEnum() || cl.isArray()\n+                || Enum.class == cl || Record.class == cl\n+                || Proxy.isProxyClass(cl));\n+    }\n+\n+    private static boolean isPrivate(Member m) {\n+        return (m.getModifiers() & PRIVATE) != 0;\n+    }\n+\n+    private static boolean isPackageProtected(Member m) {\n+        return (m.getModifiers() & (PRIVATE | PROTECTED | PUBLIC)) == 0;\n+    }\n+\n+    private static boolean isAbstract(Member m) {\n+        return (m.getModifiers() & ABSTRACT) != 0;\n+    }\n+\n+    private static boolean isFinal(Member m) {\n+        return (m.getModifiers() & FINAL) != 0;\n+    }\n+\n+    private static boolean isStatic(Member m) {\n+        return (m.getModifiers() & STATIC) != 0;\n+    }\n+\n+    private static Field declaredField(Class<?> cl, String name) {\n+        try {\n+            return cl.getDeclaredField(name);\n+        } catch (NoSuchFieldException ignored) {\n+        }\n+        return null;\n+    }\n+\n+    private static Object getObject(Field f) {\n+        try {\n+            return f.get(null);\n+        } catch (IllegalAccessException ignored) {\n+        }\n+        return null;\n+    }\n+\n+    private static Long getLong(Field f) {\n+        try {\n+            return f.getLong(null);\n+        } catch (IllegalArgumentException | IllegalAccessException ignored) {\n+        }\n+        return null;\n+    }\n+\n+    private void commitEvent(int kind, String msg, Object... args) {\n+        commitEvent(cl, kind, msg);\n+    }\n+\n+    private static void commitEvent(Class<?> cls, int kind, String msg) {\n+        commit(timestamp(), 0, cls, kind, msg);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/SerializationMisdeclarationChecker.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+package jdk.internal.event;\n+\n+\/**\n+ * A JFR event for serialization misdeclarations.\n+ * This event is mirrored in {@code jdk.jfr.events.SerializationMisdeclarationEvent}\n+ * where the metadata for the event is provided with annotations.\n+ * Some of the methods are replaced by generated methods when jfr is enabled.\n+ * Note that the order of the arguments of the {@link #commit(long,long,Class,int,String)}\n+ * method must be the same as the order of the fields.\n+ *\/\n+public class SerializationMisdeclarationEvent extends Event {\n+\n+    public Class<?> cls;\n+    public int kind;\n+    public String message;\n+\n+    \/**\n+     * Commit a serialization misdeclaration event.\n+     * The implementation of this method is generated automatically if jfr is enabled.\n+     * The order of the fields must be the same as the parameters in this method.\n+     * {@code commit(..., Class, int, String)}\n+     *\n+     * @param start         timestamp of the start of the operation\n+     * @param duration      time in nanoseconds to complete the operation\n+     * @param cls           the affected class\n+     * @param kind          the kind of misdeclaration event\n+     * @param message       the specific event message\n+     *\/\n+    public static void commit(long start, long duration,\n+            Class<?> cls, int kind, String message) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    \/**\n+     * Determine if an event should be emitted.  The duration of the operation\n+     * must exceed some threshold in order to commit the event.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @param duration  time in nanoseconds to complete the operation\n+     * @return  true if the event should be commited\n+     *\/\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    \/**\n+     * Determine if this kind of event is enabled.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @return whether serialization misdeclaration events are enabled\n+     *\/\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    \/**\n+     * Fetch the current timestamp in nanoseconds.  This method is used\n+     * to determine the start and end of an operation.  The implementation\n+     * of this method is generated automatically if jfr is enabled.\n+     *\n+     * @return  the current timestamp value\n+     *\/\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+    \/*\n+     * These constants are not final on purpose.\n+     *\/\n+    public static int SUID_EXPLICIT                   = 100;\n+    public static int SUID_INEFFECTIVE_ENUM           = 101;\n+    public static int SUID_PRIVATE                    = 102;\n+    public static int SUID_STATIC                     = 103;\n+    public static int SUID_FINAL                      = 104;\n+    public static int SUID_LONG                       = 105;\n+    public static int SUID_CONVERTIBLE_TO_LONG        = 106;\n+\n+    public static int SER_PERS_INEFFECTIVE_ENUM       = 200;\n+    public static int SER_PERS_INEFFECTIVE_RECORD     = 201;\n+    public static int SER_PERS_PRIVATE                = 202;\n+    public static int SER_PERS_STATIC                 = 203;\n+    public static int SER_PERS_FINAL                  = 204;\n+    public static int SER_PERS_NOT_NULL               = 205;\n+    public static int SER_PERS_TYPE_OSF_ARRAY         = 206;\n+    public static int SER_PERS_VALUE_OSF_ARRAY        = 207;\n+\n+    public static int PRIV_METH_INEFFECTIVE_ENUM      = 300;\n+    public static int PRIV_METH_INEFFECTIVE_RECORD    = 301;\n+    public static int PRIV_METH_PRIV                  = 302;\n+    public static int PRIV_METH_NON_STATIC            = 303;\n+    public static int PRIV_METH_RET_TYPE              = 304;\n+    public static int PRIV_METH_PARAM_TYPES           = 305;\n+\n+    public static int ACC_METH_INEFFECTIVE_ENUM       = 400;\n+    public static int ACC_METH_NON_ABSTRACT           = 401;\n+    public static int ACC_METH_NON_STATIC             = 402;\n+    public static int ACC_METH_RET_TYPE               = 403;\n+    public static int ACC_METH_PARAM_TYPES            = 404;\n+    public static int ACC_METH_NON_ACCESSIBLE         = 405;\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/SerializationMisdeclarationEvent.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+import jdk.jfr.internal.Type;\n+\n+@Name(Type.EVENT_NAME_PREFIX + \"SerializationMisdeclaration\")\n+@Label(\"Serialization Deserialization\")\n+@Category({\"Java Development Kit\", \"Serialization\"})\n+@Description(\"Methods and fields misdeclarations\")\n+@MirrorEvent(className = \"jdk.internal.event.SerializationMisdeclarationEvent\")\n+public final class SerializationMisdeclarationEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Class\")\n+    public Class<?> cls;\n+\n+    @Label(\"Kind\")\n+    public int kind;\n+\n+    @Label(\"Message\")\n+    public String message;\n+\n+    \/*\n+     * These constants are not final on purpose.\n+     *\/\n+    public static int SUID_EXPLICIT                   = jdk.internal.event.SerializationMisdeclarationEvent.SUID_EXPLICIT;\n+    public static int SUID_INEFFECTIVE_ENUM           = jdk.internal.event.SerializationMisdeclarationEvent.SUID_INEFFECTIVE_ENUM;\n+    public static int SUID_PRIVATE                    = jdk.internal.event.SerializationMisdeclarationEvent.SUID_PRIVATE;\n+    public static int SUID_STATIC                     = jdk.internal.event.SerializationMisdeclarationEvent.SUID_STATIC;\n+    public static int SUID_FINAL                      = jdk.internal.event.SerializationMisdeclarationEvent.SUID_FINAL;\n+    public static int SUID_LONG                       = jdk.internal.event.SerializationMisdeclarationEvent.SUID_LONG;\n+    public static int SUID_CONVERTIBLE_TO_LONG        = jdk.internal.event.SerializationMisdeclarationEvent.SUID_CONVERTIBLE_TO_LONG;\n+\n+    public static int SER_PERS_INEFFECTIVE_ENUM       = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_INEFFECTIVE_ENUM;\n+    public static int SER_PERS_INEFFECTIVE_RECORD     = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_INEFFECTIVE_RECORD;\n+    public static int SER_PERS_PRIVATE                = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_PRIVATE;\n+    public static int SER_PERS_STATIC                 = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_STATIC;\n+    public static int SER_PERS_FINAL                  = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_FINAL;\n+    public static int SER_PERS_NOT_NULL               = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_NOT_NULL;\n+    public static int SER_PERS_TYPE_OSF_ARRAY         = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_TYPE_OSF_ARRAY;\n+    public static int SER_PERS_VALUE_OSF_ARRAY        = jdk.internal.event.SerializationMisdeclarationEvent.SER_PERS_VALUE_OSF_ARRAY;\n+\n+    public static int PRIV_METH_INEFFECTIVE_ENUM      = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_INEFFECTIVE_ENUM;\n+    public static int PRIV_METH_INEFFECTIVE_RECORD    = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_INEFFECTIVE_RECORD;\n+    public static int PRIV_METH_PRIV                  = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_PRIV;\n+    public static int PRIV_METH_NON_STATIC            = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_NON_STATIC;\n+    public static int PRIV_METH_RET_TYPE              = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_RET_TYPE;\n+    public static int PRIV_METH_PARAM_TYPES           = jdk.internal.event.SerializationMisdeclarationEvent.PRIV_METH_PARAM_TYPES;\n+\n+    public static int ACC_METH_INEFFECTIVE_ENUM       = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_INEFFECTIVE_ENUM;\n+    public static int ACC_METH_NON_ABSTRACT           = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_NON_ABSTRACT;\n+    public static int ACC_METH_NON_STATIC             = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_NON_STATIC;\n+    public static int ACC_METH_RET_TYPE               = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_RET_TYPE;\n+    public static int ACC_METH_PARAM_TYPES            = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_PARAM_TYPES;\n+    public static int ACC_METH_NON_ACCESSIBLE         = jdk.internal.event.SerializationMisdeclarationEvent.ACC_METH_NON_ACCESSIBLE;\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SerializationMisdeclarationEvent.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.jfr.events.SerializationMisdeclarationEvent;\n@@ -55,0 +56,1 @@\n+        SerializationMisdeclarationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+        jdk.internal.event.SerializationMisdeclarationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -759,0 +759,6 @@\n+    <event name=\"jdk.SerializationMisdeclaration\">\n+        <setting name=\"enabled\">false<\/setting>\n+        <setting name=\"stackTrace\">false<\/setting>\n+        <setting name=\"threshold\">0 ns<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -758,0 +758,6 @@\n+\n+    <event name=\"jdk.SerializationMisdeclaration\">\n+        <setting name=\"enabled\">false<\/setting>\n+        <setting name=\"stackTrace\">false<\/setting>\n+        <setting name=\"threshold\">0 ns<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingStream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.internal.event.SerializationMisdeclarationEvent.*;\n+import static jdk.test.lib.jfr.EventNames.SerializationMisdeclaration;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+\/*\n+ * @test\n+ * @bug 8275338\n+ * @summary Check generation of JFR events for misdeclared fields and methods\n+ *          relevant to serialization\n+ * @modules java.base\/jdk.internal.event\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run junit\/othervm jdk.jfr.event.io.TestSerializationMisdeclarationEvent\n+ *\/\n+public class TestSerializationMisdeclarationEvent {\n+\n+    private static final List<RecordedEvent> events;\n+\n+    static Arguments[] testSingleClassMisdeclarations() {\n+        return new Arguments[] {\n+                arguments(NoSUID.class, SUID_EXPLICIT),\n+                arguments(NoSUID.class, SER_PERS_NOT_NULL),\n+\n+                arguments(NonLongSUID.class, SUID_LONG),\n+                arguments(NonLongSUID.class, SUID_CONVERTIBLE_TO_LONG),\n+\n+                arguments(EnumClass.class, SUID_INEFFECTIVE_ENUM),\n+                arguments(EnumClass.class, SUID_PRIVATE),\n+                arguments(EnumClass.class, SUID_LONG),\n+                arguments(EnumClass.class, SUID_STATIC),\n+                arguments(EnumClass.class, SUID_FINAL),\n+                arguments(EnumClass.class, SER_PERS_INEFFECTIVE_ENUM),\n+                arguments(EnumClass.class, SER_PERS_PRIVATE),\n+                arguments(EnumClass.class, SER_PERS_STATIC),\n+                arguments(EnumClass.class, SER_PERS_FINAL),\n+                arguments(EnumClass.class, SER_PERS_TYPE_OSF_ARRAY),\n+                arguments(EnumClass.class, PRIV_METH_PRIV),\n+                arguments(EnumClass.class, PRIV_METH_NON_STATIC),\n+                arguments(EnumClass.class, PRIV_METH_RET_TYPE),\n+                arguments(EnumClass.class, PRIV_METH_PARAM_TYPES),\n+                arguments(EnumClass.class, PRIV_METH_INEFFECTIVE_ENUM),\n+                arguments(EnumClass.class, ACC_METH_INEFFECTIVE_ENUM),\n+\n+                arguments(RecordClass.class, SER_PERS_INEFFECTIVE_RECORD),\n+                arguments(RecordClass.class, SER_PERS_TYPE_OSF_ARRAY),\n+                arguments(RecordClass.class, SER_PERS_VALUE_OSF_ARRAY),\n+                arguments(RecordClass.class, PRIV_METH_INEFFECTIVE_RECORD),\n+\n+                arguments(C.class, ACC_METH_NON_ACCESSIBLE),\n+\n+                arguments(Acc.class, ACC_METH_NON_ABSTRACT),\n+                arguments(Acc.class, ACC_METH_NON_STATIC),\n+                arguments(Acc.class, ACC_METH_RET_TYPE),\n+                arguments(Acc.class, ACC_METH_PARAM_TYPES),\n+        };\n+    }\n+\n+    static Arguments[] testGoodClass() {\n+        return new Arguments[] {\n+                arguments(A.class),\n+                arguments(B.class),\n+        };\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSingleClassMisdeclarations(Class<?> cls, int kind) {\n+        singleClassEvent(cls, kind);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGoodClass(Class<?> cls) {\n+        assertEquals(0, getEventsFor(cls).size());\n+    }\n+\n+    private static void doLookups() {\n+        ObjectStreamClass.lookup(NoSUID.class);\n+        ObjectStreamClass.lookup(NonLongSUID.class);\n+        ObjectStreamClass.lookup(EnumClass.class);\n+        ObjectStreamClass.lookup(RecordClass.class);\n+        ObjectStreamClass.lookup(Acc.class);\n+\n+        ObjectStreamClass.lookup(A.class);\n+        ObjectStreamClass.lookup(B.class);\n+        ObjectStreamClass.lookup(C.class);\n+    }\n+\n+    private static void singleClassEvent(Class<?> cls, int kind) {\n+        assertEquals(1, getEventsFor(cls, kind).size());\n+    }\n+\n+    private static List<RecordedEvent> getEventsFor(Class<?> cls, int kind) {\n+        return events.stream()\n+                .filter(e -> e.getClass(\"cls\").getName().equals(cls.getName())\n+                        && e.getInt(\"kind\") == kind)\n+                .toList();\n+    }\n+\n+    private static List<RecordedEvent> getEventsFor(Class<?> cls) {\n+        return events.stream()\n+                .filter(e -> e.getClass(\"cls\").getName().equals(cls.getName()))\n+                .toList();\n+    }\n+\n+    static {\n+        events = new ArrayList<>();\n+        try (var rs = new RecordingStream()) {\n+            rs.enable(SerializationMisdeclaration)\n+                    .withoutThreshold()\n+                    .withoutStackTrace();\n+            rs.onEvent(SerializationMisdeclaration, events::add);\n+            rs.startAsync();\n+            doLookups();\n+            rs.stop();\n+        }\n+    }\n+\n+    private static class A implements Serializable {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xAAAA;\n+\n+        @Serial\n+        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n+\n+        @Serial\n+        private void writeObject(ObjectOutputStream oos) {\n+        }\n+\n+        @Serial\n+        private void readObject(ObjectInputStream ois) {\n+        }\n+\n+        @Serial\n+        private void readObjectNoData() {\n+        }\n+\n+        @Serial\n+        Object writeReplace() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private static class B extends A {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xBBBB;\n+\n+        @Serial\n+        private Object readResolve() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private static final class C extends B {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xCCCCL;\n+\n+    }\n+\n+    private static final class NoSUID implements Serializable {\n+\n+        private static final ObjectStreamField[] serialPersistentFields = null;\n+\n+    }\n+\n+    private static final class NonLongSUID implements Serializable {\n+        private static final Object serialVersionUID = 1.2;\n+\n+    }\n+\n+    private enum EnumClass implements Serializable {\n+        __;  \/\/ ignored constant\n+\n+        Object serialVersionUID = 1.2;\n+        Object serialPersistentFields = new String[0];\n+\n+        static int writeObject(int i) {\n+            return 0;\n+        }\n+\n+        public Object readResolve() {\n+            return null;\n+        }\n+\n+    }\n+\n+    private record RecordClass() implements Serializable {\n+\n+        private static final Object serialPersistentFields = new String[0];\n+\n+        static int writeObject(int i) {\n+            return 0;\n+        }\n+\n+    }\n+\n+    private abstract static class Acc implements Serializable {\n+\n+        @Serial\n+        private static final long serialVersionUID = 0xAcc;\n+\n+        @Serial\n+        abstract Object readResolve();\n+\n+        @Serial\n+        static Object writeReplace() {\n+            return null;\n+        }\n+\n+        String writeReplace(String s) {\n+            return null;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestSerializationMisdeclarationEvent.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -212,0 +212,1 @@\n+    public static final String SerializationMisdeclaration = PREFIX + \"SerializationMisdeclaration\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}