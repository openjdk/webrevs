{"files":[{"patch":"@@ -461,1 +461,1 @@\n-                    if (JavaCompiler.explicitAnnotationProcessingRequested(options)) {\n+                    if (JavaCompiler.explicitAnnotationProcessingRequested(options, fileManager)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+import com.sun.tools.javac.code.Lint;\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -88,0 +90,1 @@\n+\n@@ -99,0 +102,1 @@\n+import static javax.tools.StandardLocation.ANNOTATION_PROCESSOR_PATH;\n@@ -235,0 +239,4 @@\n+    \/** Whether or not the options lint category was initially disabled\n+     *\/\n+    boolean optionsCheckingInitiallyDisabled;\n+\n@@ -427,0 +435,6 @@\n+        \/\/ See if lint options checking was explicitly disabled by the\n+        \/\/ user; this is distinct from the options check being\n+        \/\/ enabled\/disabled.\n+        optionsCheckingInitiallyDisabled =\n+            options.isSet(Option.XLINT_CUSTOM, \"-options\") ||\n+            options.isSet(Option.XLINT_CUSTOM, \"none\");\n@@ -1142,0 +1156,5 @@\n+                if (!explicitAnnotationProcessingRequested() &&\n+                    !optionsCheckingInitiallyDisabled) {\n+                    log.note(Notes.ImplicitAnnotationProcessing);\n+                }\n+\n@@ -1289,1 +1308,1 @@\n-            explicitAnnotationProcessingRequested(options);\n+            explicitAnnotationProcessingRequested(options, fileManager);\n@@ -1292,1 +1311,1 @@\n-    static boolean explicitAnnotationProcessingRequested(Options options) {\n+    static boolean explicitAnnotationProcessingRequested(Options options, JavaFileManager fileManager) {\n@@ -1300,1 +1319,2 @@\n-            options.isSet(XPRINT);\n+            options.isSet(XPRINT) ||\n+            fileManager.hasLocation(ANNOTATION_PROCESSOR_PATH);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -313,0 +313,4 @@\n+                 *\n+                 * Note: if an explicit processor path is not set,\n+                 * only the class path and _not_ the module path are\n+                 * searched for processors.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1772,0 +1772,9 @@\n+compiler.note.implicit.annotation.processing=\\\n+    Annotation processing is enabled because one or more processors were found\\n\\\n+    on the class path. A future release of javac may disable annotation processing\\n\\\n+    unless at least one processor is specified by name (-processor), or a search\\n\\\n+    path is specified (--processor-path, --processor-module-path), or annotation\\n\\\n+    processing is enabled explicitly (-proc:only, -proc:full).\\n\\\n+    Use -Xlint:-options to suppress this message.\\n\\\n+    Use -proc:none to disable annotation processing.\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,2 @@\n-                             \"-processorpath\", apDir.toString())\n+                             \"-processorpath\", apDir.toString(),\n+                             \"-Xlint:-options\")\n","filename":"test\/langtools\/tools\/javac\/annotations\/8218152\/MalformedAnnotationProcessorTests.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-compiler.err.annotation.unrecognized.attribute.name\n\\ No newline at end of file\n+compiler.err.annotation.unrecognized.attribute.name\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ key: compiler.note.implicit.annotation.processing\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ProcUseProcOrImplicit\/ProcUseProcOrImplicit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-            return Arrays.asList(\"-Xlint:rawtypes\", \"-XDrawDiagnostics\");\n+            return Arrays.asList(\"-Xlint:rawtypes\", \"-XDrawDiagnostics\", \"-proc:full\");\n","filename":"test\/langtools\/tools\/javac\/platform\/PlatformProviderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-        compiler.getTask(outputWriter, fileManager, null, List.of(\"-XDrawDiagnostics\", \"--module\", \"mod\"), null, null).call();\n+        compiler.getTask(outputWriter, fileManager, null, List.of(\"-XDrawDiagnostics\", \"--module\", \"mod\", \"-proc:full\"), null, null).call();\n","filename":"test\/langtools\/tools\/javac\/processing\/ReportOnImportedModuleAnnotation\/ReportOnImportedModuleAnnotation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8310061\n+ * @summary Verify a note is issued for implicit annotation processing\n+ *\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask JavacTestingAbstractProcessor\n+ * @run main TestNoteOnImplicitProcessing\n+ *\/\n+\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import javax.annotation.processing.Processor;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Expect;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JarTask;\n+\n+\/*\n+ * Generates note and the processor runs:\n+ * $ javac -cp ImplicitProcTestProc.jar                                     HelloWorldTest.java\n+ *\n+ * Does _not_ generate a note and the processor runs:\n+ * $ javac -processorpath ImplicitProcTestProc.jar                          HelloWorldTest.java\n+ * $ javac -cp ImplicitProcTestProc.jar -processor ImplicitProcTestProc.jar HelloWorldTest.java\n+ * $ javac -cp ImplicitProcTestProc.jar -proc:full                          HelloWorldTest.java\n+ * $ javac -cp ImplicitProcTestProc.jar -proc:only                          HelloWorldTest.java\n+ * $ javac -cp ImplicitProcTestProc.jar -Xlint:-options                     HelloWorldTest.java\n+ * $ javac -cp ImplicitProcTestProc.jar -Xlint:none                         HelloWorldTest.java\n+ *\n+ * Does _not_ generate a note and the processor _doesn't_ run.\n+ * $ javac -cp ImplicitProcTestProc.jar -proc:none                          HelloWorldTest.java\n+ *\/\n+\n+public class TestNoteOnImplicitProcessing extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+\n+        var self  = new TestNoteOnImplicitProcessing();\n+        Path jarFilePath = self.createProcessorJarFile();\n+        self.runTests(m -> new Object[] { Paths.get(m.getName()), jarFilePath });\n+    }\n+\n+    private ToolBox tb = new ToolBox();\n+    private String processorName = \"ImplicitProcTestProc\";\n+\n+    public TestNoteOnImplicitProcessing() {\n+        super(System.err);\n+    }\n+\n+    private Path createProcessorJarFile() throws Exception {\n+        Path apDir = Paths.get(\".\");\n+\n+        \/\/ Write out shared-use source file\n+        tb.writeJavaFiles(apDir,\n+                          \"\"\"\n+                          public class HelloWorldTest {\n+                              public static void main(String... args) {\n+                                  System.out.println(\"Hello world test.\");\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        JarTask jarTask = new JarTask(tb, processorName + \".jar\");\n+\n+        \/\/ write out META-INF\/services file for the processor\n+        Path servicesFile =\n+            apDir\n+            .resolve(\"META-INF\")\n+            .resolve(\"services\")\n+            .resolve(Processor.class.getCanonicalName());\n+        tb.writeFile(servicesFile, processorName);\n+\n+        \/\/ write out processor source file\n+        tb.writeJavaFiles(apDir,\n+                          \"\"\"\n+                          import java.util.Set;\n+                          import javax.annotation.processing.*;\n+                          import javax.lang.model.SourceVersion;\n+                          import javax.lang.model.element.TypeElement;\n+\n+                          @SupportedAnnotationTypes(\"*\")\n+                          public class ImplicitProcTestProc extends AbstractProcessor {\n+                              public ImplicitProcTestProc() {super();}\n+\n+                              @Override\n+                              public boolean process(Set<? extends TypeElement> annotations,\n+                                                     RoundEnvironment roundEnv) {\n+                                  if (roundEnv.processingOver()) {\n+                                      System.out.println(\"ImplicitProcTestProc run\");\n+                                  }\n+                                  return true;\n+                              }\n+\n+                              @Override\n+                              public SourceVersion getSupportedSourceVersion() {\n+                                  return SourceVersion.latest();\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        \/\/ Compile the processor\n+        new JavacTask(tb)\n+            .files(processorName + \".java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        \/\/ Create jar file\n+        jarTask\n+            .files(servicesFile.toString(),\n+                   apDir.resolve(processorName + \".class\").toString())\n+            .run();\n+\n+        return Paths.get(processorName + \".jar\");\n+    }\n+\n+    @Test\n+    public void generateWarning(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, true);\n+    }\n+\n+    @Test\n+    public void processorPath(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-processorpath\", jarFile.toString(),\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void processor(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-processor\", processorName,\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void procFull(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-proc:full\",\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void procOnly(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-proc:only\",\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void lintOptions(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-Xlint:-options\",\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void lintNone(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-Xlint:none\",\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, true);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    @Test\n+    public void procNone(Path base, Path jarFile) {\n+        Task.Result javacResult =\n+            new JavacTask(tb)\n+            .options(\"-classpath\", jarFile.toString(),\n+                     \"-proc:none\",\n+                     \"-XDrawDiagnostics\")\n+            .files(\"HelloWorldTest.java\")\n+            .run(Expect.SUCCESS)\n+            .writeAll();\n+\n+        checkForProcessorMessage(javacResult, false);\n+        checkForCompilerNote(javacResult, false);\n+    }\n+\n+    private void checkForProcessorMessage(Task.Result javacResult, boolean expectedPresent) {\n+        List<String> outputLines = javacResult.getOutputLines(Task.OutputKind.STDOUT);\n+\n+        if (!expectedPresent && outputLines.isEmpty()) {\n+            return;\n+        }\n+\n+        if (expectedPresent ^ outputLines.get(0).contains(\"ImplicitProcTestProc run\")) {\n+            throw new RuntimeException(\"Expected processor message not printed\");\n+        }\n+    }\n+\n+    private void checkForCompilerNote(Task.Result javacResult, boolean expectedPresent) {\n+        List<String> outputLines = javacResult.getOutputLines(Task.OutputKind.DIRECT);\n+\n+        if (!expectedPresent && outputLines.isEmpty()) {\n+            return;\n+        }\n+\n+        if (expectedPresent ^\n+            outputLines.get(0).contains(\"- compiler.note.implicit.annotation.processing\")) {\n+            throw new RuntimeException(\"Expected note not printed\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/TestNoteOnImplicitProcessing.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}