{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -231,1 +231,0 @@\n-  \/\/ We must call bind with the actual socketaddr length. This is obligatory for AS400.\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"libo4.hpp\"\n-\n-\/\/ global variables\n-\n-\/\/ whether initialization worked\n-static bool g_initialized = false;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/  class libo4 - impl  \/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-bool libo4::init() {\n-  if (g_initialized) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-void libo4::cleanup() {\n-  if (g_initialized) {\n-    g_initialized = false;\n-  }\n-}\n-\n-bool libo4::get_memory_info(unsigned long long* p_virt_total,\n-                            unsigned long long* p_real_total,\n-                            unsigned long long* p_real_free,\n-                            unsigned long long* p_pgsp_total,\n-                            unsigned long long* p_pgsp_free) {\n-  return false;\n-}\n-\n-bool libo4::get_load_avg(double* p_avg1, double* p_avg5, double* p_avg15) {\n-  return false;\n-}\n-\n-bool libo4::realpath(const char* file_name, char* resolved_name,\n-                     int resolved_name_len) {\n-  return false;\n-}\n-\n-bool libo4::removeEscapeMessageFromJoblogByContext(const void* context) {\n-  \/\/ Note: no tracing here! We run in signal handling context\n-\n-  return false;\n-}\n","filename":"src\/hotspot\/os\/aix\/libo4.cpp","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/\/ Class libo4 is a C++ wrapper around the libo4 porting library. It handles\n-\/\/ basic stuff like dynamic loading, library initialization etc.\n-\/\/ The libo4 porting library is a set of functions that bridge from the AIX\n-\/\/ runtime environment on OS\/400 (aka PASE layer) into native OS\/400\n-\/\/ functionality (aka ILE layer) to close some functional gaps that exist in\n-\/\/ the PASE layer.\n-\n-#ifndef OS_AIX_LIBO4_HPP\n-#define OS_AIX_LIBO4_HPP\n-\n-class libo4 {\n-public:\n-  \/\/ Initialize the libo4 porting library.\n-  \/\/ Returns true if succeeded, false if error.\n-  static bool init();\n-\n-  \/\/ Triggers cleanup of the libo4 porting library.\n-  static void cleanup();\n-\n-  \/\/ Returns a number of memory statistics from OS\/400.\n-  \/\/\n-  \/\/ See libo4.h for details on this API.\n-  \/\/\n-  \/\/ Specify null for numbers you are not interested in.\n-  \/\/\n-  \/\/ Returns false if an error happened. Activate OsMisc trace for\n-  \/\/ trace output.\n-  \/\/\n-  static bool get_memory_info(unsigned long long* p_virt_total,\n-                              unsigned long long* p_real_total,\n-                              unsigned long long* p_real_free,\n-                              unsigned long long* p_pgsp_total,\n-                              unsigned long long* p_pgsp_free);\n-\n-  \/\/ Returns information about system load\n-  \/\/ (similar to \"loadavg()\" under other Unices)\n-  \/\/\n-  \/\/ See libo4.h for details on this API.\n-  \/\/\n-  \/\/ Specify null for numbers you are not interested in.\n-  \/\/\n-  \/\/ Returns false if an error happened. Activate OsMisc trace for\n-  \/\/ trace output.\n-  \/\/\n-  static bool get_load_avg(double* p_avg1, double* p_avg5, double* p_avg15);\n-\n-  \/\/ This is a replacement for the \"realpath()\" API which does not really work\n-  \/\/ in PASE together with the (case insensitive but case preserving)\n-  \/\/ filesystem on OS\/400.\n-  \/\/\n-  \/\/ See libo4.h for details on this API.\n-  \/\/\n-  \/\/ Returns false if an error happened. Activate OsMisc trace for\n-  \/\/ trace output.\n-  \/\/\n-  static bool realpath(const char* file_name, char* resolved_name,\n-                       int resolved_name_len);\n-\n-  \/\/ Call libo4_RemoveEscapeMessageFromJoblogByContext API to remove messages\n-  \/\/ from the OS\/400 job log.\n-  \/\/\n-  \/\/ See libo4.h for details on this API.\n-  static bool removeEscapeMessageFromJoblogByContext(const void* context);\n-};\n-\n-#endif \/\/ OS_AIX_LIBO4_HPP\n","filename":"src\/hotspot\/os\/aix\/libo4.hpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024 SAP SE. All rights reserved.\n@@ -33,1 +33,0 @@\n-\n@@ -36,2 +35,0 @@\n-\/\/ It only exists on AIX, not on PASE. In order to share binaries\n-\/\/ between AIX and PASE, we can't directly link against it.\n","filename":"src\/hotspot\/os\/aix\/libodm_aix.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-\/\/ instead of statically linking against it. The libperfstat library is an\n-\/\/ AIX-specific library which only exists on AIX, not on PASE. If I want to\n-\/\/ share binaries between AIX and PASE, I cannot directly link against libperfstat.so.\n+\/\/ instead of statically linking against it.\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"libo4.hpp\"\n@@ -178,3 +177,0 @@\n-\/\/ -1 = uninitialized, 0 if AIX, 1 if OS\/400 pase\n-int       os::Aix::_on_pase = -1;\n-\n@@ -270,4 +266,0 @@\n-  \/\/ Avoid expensive API call here, as returned value will always be null.\n-  if (os::Aix::on_pase()) {\n-    return 0x0LL;\n-  }\n@@ -303,1 +295,1 @@\n-\/\/ because we cannot use disclaim64() on AS\/400 and old AIX releases.\n+\/\/ because we cannot use disclaim64() on old AIX releases.\n@@ -447,9 +439,0 @@\n-  \/\/ Now probe for support of 64K pages and 16M pages.\n-\n-  \/\/ Before OS\/400 V6R1, there is no support for pages other than 4K.\n-  if (os::Aix::on_pase_V5R4_or_older()) {\n-    trcVerbose(\"OS\/400 < V6R1 - no large page support.\");\n-    g_multipage_support.error = ERROR_MP_OS_TOO_OLD;\n-    goto query_multipage_support_end;\n-  }\n-\n@@ -622,1 +605,0 @@\n-\n@@ -625,16 +607,13 @@\n-  if (os::Aix::on_pase()) {\n-    \/\/ On PASE, use the libo4 porting library.\n-\n-    unsigned long long virt_total = 0;\n-    unsigned long long real_total = 0;\n-    unsigned long long real_free = 0;\n-    unsigned long long pgsp_total = 0;\n-    unsigned long long pgsp_free = 0;\n-    if (libo4::get_memory_info(&virt_total, &real_total, &real_free, &pgsp_total, &pgsp_free)) {\n-      pmi->virt_total = virt_total;\n-      pmi->real_total = real_total;\n-      pmi->real_free = real_free;\n-      pmi->pgsp_total = pgsp_total;\n-      pmi->pgsp_free = pgsp_free;\n-      return true;\n-    }\n+  \/\/ On AIX, I use the (dynamically loaded) perfstat library to retrieve memory statistics\n+  \/\/ See:\n+  \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n+  \/\/        ?topic=\/com.ibm.aix.basetechref\/doc\/basetrf1\/perfstat_memtot.htm\n+  \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n+  \/\/        ?topic=\/com.ibm.aix.files\/doc\/aixfiles\/libperfstat.h.htm\n+\n+  perfstat_memory_total_t psmt;\n+  memset (&psmt, '\\0', sizeof(psmt));\n+  const int rc = libperfstat::perfstat_memory_total(nullptr, &psmt, sizeof(psmt), 1);\n+  if (rc == -1) {\n+    trcVerbose(\"perfstat_memory_total() failed (errno=%d)\", errno);\n+    assert(0, \"perfstat_memory_total() failed\");\n@@ -642,0 +621,1 @@\n+  }\n@@ -643,29 +623,1 @@\n-  } else {\n-\n-    \/\/ On AIX, I use the (dynamically loaded) perfstat library to retrieve memory statistics\n-    \/\/ See:\n-    \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n-    \/\/        ?topic=\/com.ibm.aix.basetechref\/doc\/basetrf1\/perfstat_memtot.htm\n-    \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n-    \/\/        ?topic=\/com.ibm.aix.files\/doc\/aixfiles\/libperfstat.h.htm\n-\n-    perfstat_memory_total_t psmt;\n-    memset (&psmt, '\\0', sizeof(psmt));\n-    const int rc = libperfstat::perfstat_memory_total(nullptr, &psmt, sizeof(psmt), 1);\n-    if (rc == -1) {\n-      trcVerbose(\"perfstat_memory_total() failed (errno=%d)\", errno);\n-      assert(0, \"perfstat_memory_total() failed\");\n-      return false;\n-    }\n-\n-    assert(rc == 1, \"perfstat_memory_total() - weird return code\");\n-\n-    \/\/ excerpt from\n-    \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n-    \/\/        ?topic=\/com.ibm.aix.files\/doc\/aixfiles\/libperfstat.h.htm\n-    \/\/ The fields of perfstat_memory_total_t:\n-    \/\/ u_longlong_t virt_total         Total virtual memory (in 4 KB pages).\n-    \/\/ u_longlong_t real_total         Total real memory (in 4 KB pages).\n-    \/\/ u_longlong_t real_free          Free real memory (in 4 KB pages).\n-    \/\/ u_longlong_t pgsp_total         Total paging space (in 4 KB pages).\n-    \/\/ u_longlong_t pgsp_free          Free paging space (in 4 KB pages).\n+  assert(rc == 1, \"perfstat_memory_total() - weird return code\");\n@@ -673,5 +625,14 @@\n-    pmi->virt_total = psmt.virt_total * 4096;\n-    pmi->real_total = psmt.real_total * 4096;\n-    pmi->real_free = psmt.real_free * 4096;\n-    pmi->pgsp_total = psmt.pgsp_total * 4096;\n-    pmi->pgsp_free = psmt.pgsp_free * 4096;\n+  \/\/ excerpt from\n+  \/\/ http:\/\/publib.boulder.ibm.com\/infocenter\/systems\/index.jsp\n+  \/\/        ?topic=\/com.ibm.aix.files\/doc\/aixfiles\/libperfstat.h.htm\n+  \/\/ The fields of perfstat_memory_total_t:\n+  \/\/ u_longlong_t virt_total         Total virtual memory (in 4 KB pages).\n+  \/\/ u_longlong_t real_total         Total real memory (in 4 KB pages).\n+  \/\/ u_longlong_t real_free          Free real memory (in 4 KB pages).\n+  \/\/ u_longlong_t pgsp_total         Total paging space (in 4 KB pages).\n+  \/\/ u_longlong_t pgsp_free          Free paging space (in 4 KB pages).\n+  pmi->virt_total = psmt.virt_total * 4096;\n+  pmi->real_total = psmt.real_total * 4096;\n+  pmi->real_free = psmt.real_free * 4096;\n+  pmi->pgsp_total = psmt.pgsp_total * 4096;\n+  pmi->pgsp_free = psmt.pgsp_free * 4096;\n@@ -679,3 +640,1 @@\n-    return true;\n-\n-  }\n+  return true;\n@@ -960,6 +919,0 @@\n-\/\/ On PASE: mread_real_time will always return RTC_POWER_PC data, so no\n-\/\/ conversion is necessary. However, mread_real_time will not return\n-\/\/ monotonic results but merely matches read_real_time. So we need a tweak\n-\/\/ to ensure monotonic results.\n-\/\/\n-\/\/ For PASE no public documentation exists, just word by IBM\n@@ -969,28 +922,4 @@\n-  if (os::Aix::on_pase()) {\n-    assert(rc == RTC_POWER, \"expected time format RTC_POWER from mread_real_time in PASE\");\n-    jlong now = jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);\n-    jlong prev = max_real_time;\n-    if (now <= prev) {\n-      return prev;   \/\/ same or retrograde time;\n-    }\n-    jlong obsv = Atomic::cmpxchg(&max_real_time, prev, now);\n-    assert(obsv >= prev, \"invariant\");   \/\/ Monotonicity\n-    \/\/ If the CAS succeeded then we're done and return \"now\".\n-    \/\/ If the CAS failed and the observed value \"obsv\" is >= now then\n-    \/\/ we should return \"obsv\".  If the CAS failed and now > obsv > prv then\n-    \/\/ some other thread raced this thread and installed a new value, in which case\n-    \/\/ we could either (a) retry the entire operation, (b) retry trying to install now\n-    \/\/ or (c) just return obsv.  We use (c).   No loop is required although in some cases\n-    \/\/ we might discard a higher \"now\" value in deference to a slightly lower but freshly\n-    \/\/ installed obsv value.   That's entirely benign -- it admits no new orderings compared\n-    \/\/ to (a) or (b) -- and greatly reduces coherence traffic.\n-    \/\/ We might also condition (c) on the magnitude of the delta between obsv and now.\n-    \/\/ Avoiding excessive CAS operations to hot RW locations is critical.\n-    \/\/ See https:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-    return (prev == obsv) ? now : obsv;\n-  } else {\n-    if (rc != RTC_POWER) {\n-      rc = time_base_to_time(&time, TIMEBASE_SZ);\n-      assert(rc != -1, \"error calling time_base_to_time()\");\n-    }\n-    return jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);\n+\n+  if (rc != RTC_POWER) {\n+    rc = time_base_to_time(&time, TIMEBASE_SZ);\n+    assert(rc != -1, \"error calling time_base_to_time()\");\n@@ -998,0 +927,1 @@\n+  return jlong(time.tb_high) * NANOSECS_PER_SEC + jlong(time.tb_low);\n@@ -1567,6 +1497,0 @@\n-  \/\/ For old AS\/400's (V5R4 and older) we should not even be here - System V shared memory is not\n-  \/\/ really supported (max size 4GB), so reserve_mmapped_memory should have been used instead.\n-  if (os::Aix::on_pase_V5R4_or_older()) {\n-    ShouldNotReachHere();\n-  }\n-\n@@ -2089,21 +2013,0 @@\n-\n-    if (!rc) {\n-      if (os::Aix::on_pase()) {\n-        \/\/ There is an issue on older PASE systems where mprotect() will return success but the\n-        \/\/ memory will not be protected.\n-        \/\/ This has nothing to do with the problem of using mproect() on SPEC1170 incompatible\n-        \/\/ machines; we only see it rarely, when using mprotect() to protect the guard page of\n-        \/\/ a stack. It is an OS error.\n-        \/\/\n-        \/\/ A valid strategy is just to try again. This usually works. :-\/\n-\n-        ::usleep(1000);\n-        Events::log(nullptr, \"Protecting memory [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] with protection modes %x\", p2i(addr), p2i(addr+size), prot);\n-        if (::mprotect(addr, size, prot) == 0) {\n-          const bool read_protected_2 =\n-            (SafeFetch32((int*)addr, 0x12345678) == 0x12345678 &&\n-            SafeFetch32((int*)addr, 0x76543210) == 0x76543210) ? true : false;\n-          rc = true;\n-        }\n-      }\n-    }\n@@ -2235,1 +2138,0 @@\n-\/\/ We use the same values for AIX and PASE.\n@@ -2323,2 +2225,1 @@\n-  \/\/ First off, we need to know whether we run on AIX or PASE, and\n-  \/\/ the OS level we run on.\n+  \/\/ First off, we need to know the OS level we run on.\n@@ -2346,1 +2247,1 @@\n-  \/\/ 4K           no                                  4K                              old systems (aix 5.2, as\/400 v5r4) or new systems with AME activated\n+  \/\/ 4K           no                                  4K                              old systems (aix 5.2) or new systems with AME activated\n@@ -2399,6 +2300,2 @@\n-  \/\/ Next, we need to initialize libo4 and libperfstat libraries.\n-  if (os::Aix::on_pase()) {\n-    os::Aix::initialize_libo4();\n-  } else {\n-    os::Aix::initialize_libperfstat();\n-  }\n+  \/\/ Next, we need to initialize libperfstat\n+  os::Aix::initialize_libperfstat();\n@@ -2428,6 +2325,0 @@\n-  if (os::Aix::on_pase()) {\n-    trcVerbose(\"Running on PASE.\");\n-  } else {\n-    trcVerbose(\"Running on AIX (not PASE).\");\n-  }\n-\n@@ -2756,12 +2647,5 @@\n-  if (os::Aix::on_pase()) {\n-\n-    \/\/ AS\/400 PASE: use libo4 porting library\n-    double v[3] = { 0.0, 0.0, 0.0 };\n-\n-    if (libo4::get_load_avg(v, v + 1, v + 2)) {\n-      for (int i = 0; i < nelem; i ++) {\n-        values[i] = v[i];\n-      }\n-      return nelem;\n-    } else {\n-      return -1;\n+  \/\/ AIX: use libperfstat\n+  libperfstat::cpuinfo_t ci;\n+  if (libperfstat::get_cpuinfo(&ci)) {\n+    for (int i = 0; i < nelem; i++) {\n+      values[i] = ci.loadavg[i];\n@@ -2769,1 +2653,0 @@\n-\n@@ -2771,11 +2654,1 @@\n-\n-    \/\/ AIX: use libperfstat\n-    libperfstat::cpuinfo_t ci;\n-    if (libperfstat::get_cpuinfo(&ci)) {\n-      for (int i = 0; i < nelem; i++) {\n-        values[i] = ci.loadavg[i];\n-      }\n-    } else {\n-      return -1;\n-    }\n-    return nelem;\n+    return -1;\n@@ -2783,0 +2656,1 @@\n+  return nelem;\n@@ -2793,2 +2667,1 @@\n-\/\/ OS recognitions (PASE\/AIX, OS level) call this before calling any\n-\/\/ one of Aix::on_pase(), Aix::os_version() static\n+\/\/ OS recognitions (OS level) call this before calling Aix::os_version()\n@@ -2797,1 +2670,1 @@\n-  assert(_on_pase == -1 && _os_version == 0, \"already called.\");\n+  assert(_os_version == 0, \"already called.\");\n@@ -2804,1 +2677,1 @@\n-    guarantee(0, \"Could not determine whether we run on AIX or PASE\");\n+    guarantee(0, \"Could not determine uname information\");\n@@ -2816,10 +2689,2 @@\n-    if (strcmp(uts.sysname, \"OS400\") == 0) {\n-      \/\/ We run on AS\/400 PASE. We do not support versions older than V5R4M0.\n-      _on_pase = 1;\n-      if (os_version_short() < 0x0504) {\n-        trcVerbose(\"OS\/400 releases older than V5R4M0 not supported.\");\n-        assert(false, \"OS\/400 release too old.\");\n-      }\n-      name_str = \"OS\/400 (pase)\";\n-      jio_snprintf(ver_str, sizeof(ver_str), \"%u.%u\", major, minor);\n-    } else if (strcmp(uts.sysname, \"AIX\") == 0) {\n+\n+    if (strcmp(uts.sysname, \"AIX\") == 0) {\n@@ -2827,1 +2692,0 @@\n-      _on_pase = 0;\n@@ -2843,1 +2707,1 @@\n-  guarantee(_on_pase != -1 && _os_version, \"Could not determine AIX\/OS400 release\");\n+  guarantee(_os_version, \"Could not determine AIX release\");\n@@ -2898,5 +2762,0 @@\n-  if (os::Aix::on_pase()) {\n-    p = ::getenv(\"QIBM_MULTI_THREADED\");\n-    trcVerbose(\"QIBM_MULTI_THREADED=%s.\", p ? p : \"<unset>\");\n-  }\n-\n@@ -2905,6 +2764,0 @@\n-  if (os::Aix::on_pase() && os::Aix::os_version_short() == 0x0701) {\n-    if (p && ::strstr(p, \"TEXTPSIZE\")) {\n-      trcVerbose(\"*** WARNING - LDR_CNTRL contains TEXTPSIZE. \"\n-        \"you may experience hangs or crashes on OS\/400 V7R1.\");\n-    }\n-  }\n@@ -2917,11 +2770,0 @@\n-\/\/ PASE: initialize the libo4 library (PASE porting library).\n-void os::Aix::initialize_libo4() {\n-  guarantee(os::Aix::on_pase(), \"OS\/400 only.\");\n-  if (!libo4::init()) {\n-    trcVerbose(\"libo4 initialization failed.\");\n-    assert(false, \"libo4 initialization failed\");\n-  } else {\n-    trcVerbose(\"libo4 initialized.\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":53,"deletions":211,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-  \/\/ -1 = uninitialized, 0 = AIX, 1 = OS\/400 (PASE)\n-  static int _on_pase;\n-\n@@ -48,1 +45,0 @@\n-  \/\/  for OS\/400 e.g. 0x0504 for OS\/400 V5R4\n@@ -66,2 +62,1 @@\n-  \/\/ OS recognitions (PASE\/AIX, OS level) call this before calling any\n-  \/\/ one of Aix::on_pase(), Aix::os_version().\n+  \/\/ OS recognitions (AIX OS level) call this before calling Aix::os_version().\n@@ -77,1 +72,1 @@\n-  \/\/ Initialize libo4 (on PASE) and libperfstat (on AIX). Call this\n+  \/\/ Initialize libperfstat; call this\n@@ -79,1 +74,0 @@\n-  static void initialize_libo4();\n@@ -97,7 +91,0 @@\n-  \/\/ Function returns true if we run on OS\/400 (pase), false if we run\n-  \/\/ on AIX.\n-  static bool on_pase() {\n-    assert(_on_pase != -1, \"not initialized\");\n-    return _on_pase ? true : false;\n-  }\n-\n@@ -115,2 +102,1 @@\n-  \/\/ For AIX, e.g. 0x0601 for AIX 6.1\n-  \/\/ for OS\/400 e.g. 0x0504 for OS\/400 V5R4\n+  \/\/ For AIX, e.g. 0x0701 for AIX 7.1\n@@ -121,5 +107,0 @@\n-  \/\/ Convenience method: returns true if running on PASE V5R4 or older.\n-  static bool on_pase_V5R4_or_older() {\n-    return on_pase() && os_version_short() <= 0x0504;\n-  }\n-\n@@ -158,2 +139,1 @@\n-  \/\/ Functions to retrieve memory information on AIX, PASE.\n-  \/\/ (on AIX, using libperfstat, on PASE with libo4.so).\n+  \/\/ function to retrieve memory information, using libperfstat\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-        \/* We must call bind with the actual socketaddr length. This is obligatory for AS400. *\/\n","filename":"src\/jdk.attach\/aix\/native\/libattach\/VirtualMachineImpl.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}