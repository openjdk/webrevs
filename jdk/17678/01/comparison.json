{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -749,0 +749,4 @@\n+     * @implSpec A {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR} in the input\n+     * text will match any other {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR}s\n+     * in the pattern with the lenient parsing; otherwise, it will not match.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1490,1 +1490,2 @@\n-                if (start >= textLength || text.charAt(start) != (char)count) {\n+                if (start >= textLength ||\n+                        !charEquals(text.charAt(start), (char)count)) {\n@@ -1500,1 +1501,2 @@\n-                    if (start >= textLength || text.charAt(start) != compiledPattern[i++]) {\n+                    if (start >= textLength ||\n+                            !charEquals(text.charAt(start), compiledPattern[i++])) {\n@@ -1583,0 +1585,7 @@\n+    private boolean charEquals(char ch1, char ch2) {\n+        return ch1 == ch2 ||\n+            isLenient() &&\n+                Character.getType(ch1) == Character.SPACE_SEPARATOR &&\n+                Character.getType(ch2) == Character.SPACE_SEPARATOR;\n+     }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/SimpleDateFormat.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -356,0 +356,4 @@\n+     * @implSpec A {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR} in the input\n+     * text will not match any other {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR}s\n+     * in the pattern with the strict parse style.\n+     *\n@@ -375,0 +379,4 @@\n+     * @implSpec A {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR} in the input\n+     * text will match any other {@link Character#SPACE_SEPARATOR SPACE_SEPARATOR}s\n+     * in the pattern with the lenient parse style.\n+     *\n@@ -2734,0 +2742,1 @@\n+        private final boolean isSpaceSeparator;\n@@ -2737,0 +2746,1 @@\n+            isSpaceSeparator = Character.getType(literal) == Character.SPACE_SEPARATOR;\n@@ -2753,1 +2763,1 @@\n-                if (context.isCaseSensitive() ||\n+                if ((context.isCaseSensitive() ||\n@@ -2755,1 +2765,2 @@\n-                         Character.toLowerCase(ch) != Character.toLowerCase(literal))) {\n+                         Character.toLowerCase(ch) != Character.toLowerCase(literal))) &&\n+                        !spaceEquals(context, ch)) {\n@@ -2769,0 +2780,6 @@\n+\n+        private boolean spaceEquals(DateTimeParseContext context, char ch) {\n+            return !context.isStrict() && isSpaceSeparator &&\n+                    Character.getType(ch) == Character.SPACE_SEPARATOR;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324665\n+ * @summary Checks if SPACE_SEPARATOR are correctly parsed in lenient mode\n+ * @run junit LenientSpaceParsingTest\n+ *\/\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.util.stream.Stream;\n+\n+public class LenientSpaceParsingTest {\n+    @MethodSource\n+    private static Stream<Arguments> strictSpaces() {\n+        \/\/ input, pattern\n+        return Stream.of(\n+                Arguments.of(\"00\\u002000\", \"H\\u0020m\"),\n+                Arguments.of(\"00\\u202f00\", \"H\\u202fm\"),\n+                Arguments.of(\"00\\u00a000\", \"H\\u00a0m\"),\n+                Arguments.of(\"00\\u0020\\u202f\\u0020\\u00a000\", \"H\\u0020\\u202f\\u0020\\u00a0m\")\n+        );\n+    }\n+\n+    @MethodSource\n+    private static Stream<Arguments> lenientSpaces() {\n+        \/\/ input, pattern\n+        return Stream.of(\n+                Arguments.of(\"00\\u002000\", \"H\\u202fm\"),\n+                Arguments.of(\"00\\u202f00\", \"H\\u0020m\"),\n+                Arguments.of(\"00\\u00a000\", \"H\\u0020m\"),\n+                Arguments.of(\"00\\u002000\", \"H\\u00a0m\"),\n+                Arguments.of(\"00\\u0020\\u202f\\u0020\\u00a000\", \"H\\u0020\\u0020\\u0020\\u0020m\"),\n+                Arguments.of(\"00\\u0020\\u202f\\u0020\\u00a000\", \"H\\u202f\\u00a0\\u202f\\u00a0m\")\n+        );\n+    }\n+\n+    @MethodSource\n+    private static Stream<Arguments> nonSpaces() {\n+        \/\/ input, pattern\n+        return Stream.of(\n+                Arguments.of(\"00a00\", \"H\\u202fm\"),\n+                Arguments.of(\"00a00\", \"H\\u00a0m\"),\n+                Arguments.of(\"00a00\", \"H\\u0020m\"),\n+                Arguments.of(\"00aa00\", \"H\\u0020\\u0020m\"),\n+                Arguments.of(\"00aa00\", \"H\\u00a0\\u202fm\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"strictSpaces\", \"lenientSpaces\"})\n+    public void checkDateTimeFormatter_Lenient(String input, String pattern) {\n+        new DateTimeFormatterBuilder().parseLenient().appendPattern(pattern).toFormatter().parse(input);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonSpaces\")\n+    public void checkDateTimeFormatter_Lenient_Exception(String input, String pattern) {\n+        var dtf = new DateTimeFormatterBuilder().parseLenient().appendPattern(pattern).toFormatter();\n+        assertThrows(DateTimeParseException.class, () -> {\n+            dtf.parse(input);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strictSpaces\")\n+    public void checkDateTimeFormatter_Strict(String input, String pattern) {\n+        new DateTimeFormatterBuilder().parseStrict().appendPattern(pattern).toFormatter().parse(input);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"lenientSpaces\", \"nonSpaces\"})\n+    public void checkDateTimeFormatter_Strict_Exception(String input, String pattern) {\n+        var dtf = new DateTimeFormatterBuilder().parseStrict().appendPattern(pattern).toFormatter();\n+        assertThrows(DateTimeParseException.class, () -> {\n+            dtf.parse(input);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"strictSpaces\", \"lenientSpaces\"})\n+    public void checkSimpleDateFormat_Lenient(String input, String pattern) throws ParseException {\n+        new SimpleDateFormat(pattern).parse(input);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonSpaces\")\n+    public void checkSimpleDateFormat_Lenient_Exception(String input, String pattern) {\n+        var sdf = new SimpleDateFormat(pattern);\n+        assertThrows(ParseException.class, () -> {\n+            sdf.parse(input);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strictSpaces\")\n+    public void checkSimpleDateFormat_Strict(String input, String pattern) throws ParseException {\n+        var sdf = new SimpleDateFormat(pattern);\n+        sdf.setLenient(false);\n+        sdf.parse(input);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"lenientSpaces\", \"nonSpaces\"})\n+    public void checkSimpleDateFormat_Strict_Exception(String input, String pattern) {\n+        var sdf = new SimpleDateFormat(pattern);\n+        sdf.setLenient(false);\n+        assertThrows(ParseException.class, () -> {\n+            sdf.parse(input);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/LenientSpaceParsingTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}