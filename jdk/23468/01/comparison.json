{"files":[{"patch":"@@ -100,1 +100,7 @@\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : nullptr;\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    return TypeNode::Ideal(phase, can_reshape);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) {\n+    return Node::Ideal(phase, can_reshape);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -700,0 +700,7 @@\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n@@ -802,0 +809,7 @@\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+  Node* progress = TypeNode::Ideal(phase, can_reshape);\n+  if (progress != nullptr) {\n+    return progress;\n+  }\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3050,0 +3050,73 @@\n+\n+void TypeNode::make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j) {\n+  Node* c = ctrl_use->in(j);\n+  if (igvn->type(c) != Type::TOP) {\n+    igvn->replace_input_of(ctrl_use, j, igvn->C->top());\n+    create_halt_path(igvn, c, loop);\n+  }\n+}\n+\n+\/\/ This Type node is dead. It could be because the type that it captures and the type of the node computed from its\n+\/\/ inputs do not intersect anymore. That node has some uses along some control flow paths. Those control flow paths must\n+\/\/ be unreachable as using a dead value makes no sense. For the Type node to capture a narrowed down type, some control\n+\/\/ flow construct must guard the Type node (an If node usually). When the Type node becomes dead, the guard usually\n+\/\/ constant fold and the control flow that leads to the Type node becomes unreachable. There are cases where that doesn't\n+\/\/ happen, however. They are handled here by following uses of the Type node until a CFG or a Phi to find dead paths.\n+\/\/ The dead paths are then replaced by a Halt node.\n+void TypeNode::make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop) {\n+  Unique_Node_List wq;\n+  wq.push(this);\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast kmax, k = n->fast_outs(kmax); k < kmax; k++) {\n+      Node* u = n->fast_out(k);\n+      if (u->is_CFG()) {\n+        assert(!u->is_Region(), \"Can't reach a Region without going through a Phi\");\n+        make_path_dead(igvn, loop, u, 0);\n+      } else if (u->is_Phi()) {\n+        Node* r = u->in(0);\n+        assert(r->is_Region() || r->is_top(), \"unexpected Phi's control\");\n+        if (r->is_Region()) {\n+          for (uint j = 1; j < u->req(); ++j) {\n+            if (u->in(j) == n) {\n+              make_path_dead(igvn, loop, r, j);\n+            }\n+          }\n+        }\n+      } else {\n+        wq.push(u);\n+      }\n+    }\n+  }\n+}\n+\n+void TypeNode::create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop) const {\n+  Node* frame = new ParmNode(igvn->C->start(), TypeFunc::FramePtr);\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(frame);\n+  } else {\n+    loop->register_new_node(frame, igvn->C->start());\n+  }\n+  Node* halt = new HaltNode(c, frame, \"dead path discovered by TypeNode\");\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(halt);\n+  } else {\n+    loop->register_control(halt, loop->ltree_root(), c);\n+  }\n+  igvn->add_input_to(igvn->C->root(), halt);\n+}\n+\n+Node* TypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (can_reshape && Value(phase) == Type::TOP) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    Node* top = igvn->C->top();\n+    ResourceMark rm;\n+    make_paths_from_here_dead(igvn, nullptr);\n+    return top;\n+  }\n+\n+  return Node::Ideal(phase, can_reshape);\n+}\n+\n+\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+class PhaseIdealLoop;\n@@ -2039,0 +2040,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -2041,0 +2043,2 @@\n+\n+  void make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j);\n@@ -2045,0 +2049,2 @@\n+  void make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop);\n+  void create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1829,0 +1829,5 @@\n+    if (n->is_Type()) {\n+      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+      \/\/ nodes that become dead.\n+      _type_nodes.push(n);\n+    }\n@@ -2061,0 +2066,8 @@\n+  for (uint i = 0; i < _type_nodes.size(); ++i) {\n+    Node* type_node = _type_nodes.at(i);\n+    if (type(type_node) == Type::TOP) {\n+      ResourceMark rm;\n+      type_node->as_Type()->make_paths_from_here_dead(this, nullptr);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+  Unique_Node_List _type_nodes;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349479\n+ * @summary C2: when a Type node becomes dead, make CFG path that uses it unreachable\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,TestGuardOfCastIIDoesntFold::notInlined\n+ *                   TestGuardOfCastIIDoesntFold\n+ *\/\n+\n+public class TestGuardOfCastIIDoesntFold {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(1, 0, 0, false);\n+            helper1(1, 0, 0, true);\n+            helper2(0, 0);\n+        }\n+    }\n+\n+    private static int test1(int i, int j, int k, boolean flag) {\n+        int l;\n+        for (l = 0; l < 10; l++) {\n+        }\n+        j = helper2(j, l);\n+        return helper1(i, j, k, flag);\n+    }\n+\n+    private static int helper2(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.MAX_VALUE-1;\n+        }\n+        return j;\n+    }\n+\n+    private static int helper1(int i, int j, int k, boolean flag) {\n+        if (flag) {\n+            k = Integer.max(k, -2);\n+            int[] array = new int[i + k];\n+            notInlined(array);\n+            return array[j];\n+        }\n+        volatileField = 42;\n+        return volatileField;\n+    }\n+\n+    private static void notInlined(int[] array) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestGuardOfCastIIDoesntFold.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}