{"files":[{"patch":"@@ -16300,1 +16300,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8995,1 +8995,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -14702,1 +14702,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10850,1 +10850,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -10083,1 +10083,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3033,1 +3033,2 @@\n-      __ stop(_halt_reason);\n+      const char* str = __ code_string(_halt_reason);\n+      __ stop(str);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,4 +47,1 @@\n-      const size_t len = ss.size();\n-      char* store = NEW_ARENA_ARRAY(&_text_storage, char, len + 1);\n-      memcpy(store, ss.base(), len + 1);\n-      (*cached_frame_text) = store;\n+      (*cached_frame_text) = ss.as_string(&_text_storage);\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -821,0 +821,6 @@\n+                                                                            \\\n+  develop(bool, KillPathsReachableByDeadTypeNode, true,                     \\\n+          \"When a Type node becomes top, make paths where the node is \"     \\\n+          \"used dead by replacing them with a Halt node. Turning this off \" \\\n+          \"could corrupt the graph in rare cases and should be used with \"  \\\n+          \"care.\")                                                          \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,2 +99,8 @@\n-Node *ConstraintCastNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  return (in(0) && remove_dead_region(phase, can_reshape)) ? this : nullptr;\n+Node* ConstraintCastNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(0) != nullptr && remove_dead_region(phase, can_reshape)) {\n+    return this;\n+  }\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    return TypeNode::Ideal(phase, can_reshape);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape) {\n+    return Node::Ideal(phase, can_reshape);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/connode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -692,1 +692,8 @@\n-Node *ConvI2LNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ConvI2LNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n@@ -794,1 +801,8 @@\n-Node *ConvL2INode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+Node* ConvL2INode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (in(1) != nullptr && phase->type(in(1)) != Type::TOP) {\n+    Node* progress = TypeNode::Ideal(phase, can_reshape);\n+    if (progress != nullptr) {\n+      return progress;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+  Node* progress = TypeNode::Ideal(phase, can_reshape);\n+  if (progress != nullptr) {\n+    return progress;\n+  }\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3079,0 +3079,75 @@\n+\n+void TypeNode::make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j, const char* phase_str) {\n+  Node* c = ctrl_use->in(j);\n+  if (igvn->type(c) != Type::TOP) {\n+    igvn->replace_input_of(ctrl_use, j, igvn->C->top());\n+    create_halt_path(igvn, c, loop, phase_str);\n+  }\n+}\n+\n+\/\/ This Type node is dead. It could be because the type that it captures and the type of the node computed from its\n+\/\/ inputs do not intersect anymore. That node has some uses along some control flow paths. Those control flow paths must\n+\/\/ be unreachable as using a dead value makes no sense. For the Type node to capture a narrowed down type, some control\n+\/\/ flow construct must guard the Type node (an If node usually). When the Type node becomes dead, the guard usually\n+\/\/ constant folds and the control flow that leads to the Type node becomes unreachable. There are cases where that\n+\/\/ doesn't happen, however. They are handled here by following uses of the Type node until a CFG or a Phi to find dead\n+\/\/ paths. The dead paths are then replaced by a Halt node.\n+void TypeNode::make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, const char* phase_str) {\n+  Unique_Node_List wq;\n+  wq.push(this);\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* n = wq.at(i);\n+    for (DUIterator_Fast kmax, k = n->fast_outs(kmax); k < kmax; k++) {\n+      Node* u = n->fast_out(k);\n+      if (u->is_CFG()) {\n+        assert(!u->is_Region(), \"Can't reach a Region without going through a Phi\");\n+        make_path_dead(igvn, loop, u, 0, phase_str);\n+      } else if (u->is_Phi()) {\n+        Node* r = u->in(0);\n+        assert(r->is_Region() || r->is_top(), \"unexpected Phi's control\");\n+        if (r->is_Region()) {\n+          for (uint j = 1; j < u->req(); ++j) {\n+            if (u->in(j) == n) {\n+              make_path_dead(igvn, loop, r, j, phase_str);\n+            }\n+          }\n+        }\n+      } else {\n+        wq.push(u);\n+      }\n+    }\n+  }\n+}\n+\n+void TypeNode::create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop, const char* phase_str) const {\n+  Node* frame = new ParmNode(igvn->C->start(), TypeFunc::FramePtr);\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(frame);\n+  } else {\n+    loop->register_new_node(frame, igvn->C->start());\n+  }\n+\n+  stringStream ss;\n+  ss.print(\"dead path discovered by TypeNode during %s\", phase_str);\n+\n+  Node* halt = new HaltNode(c, frame, ss.as_string(igvn->C->comp_arena()));\n+  if (loop == nullptr) {\n+    igvn->register_new_node_with_optimizer(halt);\n+  } else {\n+    loop->register_control(halt, loop->ltree_root(), c);\n+  }\n+  igvn->add_input_to(igvn->C->root(), halt);\n+}\n+\n+Node* TypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  if (KillPathsReachableByDeadTypeNode && can_reshape && Value(phase) == Type::TOP) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    Node* top = igvn->C->top();\n+    ResourceMark rm;\n+    make_paths_from_here_dead(igvn, nullptr, \"igvn\");\n+    return top;\n+  }\n+\n+  return Node::Ideal(phase, can_reshape);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+class PhaseIdealLoop;\n@@ -2047,0 +2048,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -2049,0 +2051,2 @@\n+\n+  void make_path_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, Node* ctrl_use, uint j, const char* phase_str);\n@@ -2053,0 +2057,2 @@\n+  void make_paths_from_here_dead(PhaseIterGVN* igvn, PhaseIdealLoop* loop, const char* phase_str);\n+  void create_halt_path(PhaseIterGVN* igvn, Node* c, PhaseIdealLoop* loop, const char* phase_str) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1831,0 +1831,5 @@\n+    if (n->is_Type()) {\n+      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+      \/\/ nodes that become dead.\n+      _type_nodes.push(n);\n+    }\n@@ -2063,0 +2068,10 @@\n+  if (KillPathsReachableByDeadTypeNode) {\n+    for (uint i = 0; i < _type_nodes.size(); ++i) {\n+      Node* type_node = _type_nodes.at(i);\n+      if (type(type_node) == Type::TOP) {\n+        ResourceMark rm;\n+        type_node->as_Type()->make_paths_from_here_dead(this, nullptr, \"ccp\");\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+  Unique_Node_List _type_nodes;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,0 +440,7 @@\n+char* stringStream::as_string(Arena* arena) const {\n+  char* copy = NEW_ARENA_ARRAY(arena, char, _written + 1);\n+  ::memcpy(copy, _buffer, _written);\n+  copy[_written] = '\\0';  \/\/ terminating null\n+  return copy;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -273,0 +273,1 @@\n+  char* as_string(Arena* arena) const;\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349479\n+ * @summary C2: when a Type node becomes dead, make CFG path that uses it unreachable\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileCommand=dontinline,TestGuardOfCastIIDoesntFold::notInlined\n+ *                   TestGuardOfCastIIDoesntFold\n+ * @run main TestGuardOfCastIIDoesntFold\n+ *\/\n+\n+public class TestGuardOfCastIIDoesntFold {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(1, 0, 0, false);\n+            helper1(1, 0, 0, true);\n+            helper2(0, 0);\n+        }\n+    }\n+\n+    private static int test1(int i, int j, int k, boolean flag) {\n+        int l;\n+        for (l = 0; l < 10; l++) {\n+        }\n+        j = helper2(j, l);\n+        return helper1(i, j, k, flag);\n+    }\n+\n+    private static int helper2(int j, int l) {\n+        if (l == 10) {\n+            j = Integer.MAX_VALUE-1;\n+        }\n+        return j;\n+    }\n+\n+    private static int helper1(int i, int j, int k, boolean flag) {\n+        if (flag) {\n+            k = Integer.max(k, -2);\n+            int[] array = new int[i + k];\n+            notInlined(array);\n+            return array[j];\n+        }\n+        volatileField = 42;\n+        return volatileField;\n+    }\n+\n+    private static void notInlined(int[] array) {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestGuardOfCastIIDoesntFold.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -46,0 +47,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -57,0 +59,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -68,0 +71,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -79,0 +83,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -90,0 +95,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -101,0 +107,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -112,0 +119,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -123,0 +131,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -134,0 +143,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -144,0 +154,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -155,0 +166,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -166,0 +178,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -177,0 +190,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n@@ -188,0 +202,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}