{"files":[{"patch":"@@ -47,7 +47,12 @@\n-        List<TypeParam> typeParamTypes = parseParamTypes();\n-        RefTypeSig superclass = referenceTypeSig();\n-        ArrayList<RefTypeSig> superinterfaces = null;\n-        while (sigp < sig.length()) {\n-            if (superinterfaces == null)\n-                superinterfaces = new ArrayList<>();\n-            superinterfaces.add(referenceTypeSig());\n+        try {\n+            List<TypeParam> typeParamTypes = parseParamTypes();\n+            RefTypeSig superclass = referenceTypeSig();\n+            ArrayList<RefTypeSig> superinterfaces = null;\n+            while (sigp < sig.length()) {\n+                if (superinterfaces == null)\n+                    superinterfaces = new ArrayList<>();\n+                superinterfaces.add(referenceTypeSig());\n+            }\n+            return new ClassSignatureImpl(typeParamTypes, superclass, null2Empty(superinterfaces));\n+        } catch (IndexOutOfBoundsException e) {\n+            throw error(\"Not a valid class signature\");\n@@ -55,1 +60,0 @@\n-        return new ClassSignatureImpl(typeParamTypes, superclass, null2Empty(superinterfaces));\n@@ -61,13 +65,10 @@\n-        List<TypeParam> typeParamTypes = parseParamTypes();\n-        assert sig.charAt(sigp) == '(';\n-        sigp++;\n-        ArrayList<Signature> paramTypes = null;\n-        while (sig.charAt(sigp) != ')') {\n-            if (paramTypes == null)\n-                 paramTypes = new ArrayList<>();\n-            paramTypes.add(typeSig());\n-        }\n-        sigp++;\n-        Signature returnType = typeSig();\n-        ArrayList<ThrowableSig> throwsTypes = null;\n-        while (sigp < sig.length() && sig.charAt(sigp) == '^') {\n+        try {\n+            List<TypeParam> typeParamTypes = parseParamTypes();\n+            if (sig.charAt(sigp) != '(') throw error(\"Expected ( at possition %d of signature\".formatted(sigp));\n+            sigp++;\n+            ArrayList<Signature> paramTypes = null;\n+            while (sig.charAt(sigp) != ')') {\n+                if (paramTypes == null)\n+                     paramTypes = new ArrayList<>();\n+                paramTypes.add(typeSig());\n+            }\n@@ -75,7 +76,16 @@\n-            if (throwsTypes == null)\n-                throwsTypes = new ArrayList<>();\n-            var t = typeSig();\n-            if (t instanceof ThrowableSig ts)\n-                throwsTypes.add(ts);\n-            else\n-                throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n+            Signature returnType = typeSig();\n+            ArrayList<ThrowableSig> throwsTypes = null;\n+            while (sigp < sig.length()) {\n+                if (sig.charAt(sigp) != '^') throw error(\"Expected ^ at possition %d of signature\".formatted(sigp));\n+                sigp++;\n+                if (throwsTypes == null)\n+                    throwsTypes = new ArrayList<>();\n+                var t = referenceTypeSig();\n+                if (t instanceof ThrowableSig ts)\n+                    throwsTypes.add(ts);\n+                else\n+                    throw error(\"Not a valid throwable signature %s in\".formatted(t.signatureString()));\n+            }\n+            return new MethodSignatureImpl(typeParamTypes, null2Empty(throwsTypes), returnType, null2Empty(paramTypes));\n+        } catch (IndexOutOfBoundsException e) {\n+            throw error(\"Not a valid method signature\");\n@@ -83,1 +93,0 @@\n-        return new MethodSignatureImpl(typeParamTypes, null2Empty(throwsTypes), returnType, null2Empty(paramTypes));\n@@ -89,1 +98,7 @@\n-        return typeSig();\n+        try {\n+            var s = typeSig();\n+            if (sigp == signature.length())\n+                return s;\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+        throw error(\"Not a valid type signature\");\n@@ -160,1 +175,1 @@\n-        throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n+        throw error(\"Unexpected character %c at possition %d of signature\".formatted(c, sigp - 1));\n@@ -295,0 +310,4 @@\n+\n+    private IllegalArgumentException error(String message) {\n+        return new IllegalArgumentException(\"%s: %s\".formatted(message, sig));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":50,"deletions":31,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8321540\n@@ -49,0 +50,1 @@\n+import org.junit.jupiter.api.Assertions;\n@@ -51,0 +53,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -189,0 +193,75 @@\n+\n+    @Test\n+    void testBadTypeSignatures() {\n+        \"\"\"\n+        LObject\n+        LObject;B\n+        LIterable<LFoo>\n+        LIterable<<\n+        TBar\n+        TBar<LFoo;>\n+        B<LFoo;>\n+        B<LFoo;>;V\n+        X\n+        [LObject\n+        [LIterable<LFoo>\n+        [LIterable<<\n+        [TBar\n+        [TBar<LFoo;>\n+        [B<LFoo;>\n+        [X\n+        LSet<+Kind<**>;>;\n+        LSet<?Kind<*>;>;\n+        ()V\n+        \"\"\".lines().forEach(assertThrows(Signature::parseFrom));\n+    }\n+\n+    @Test\n+    void testBadClassSignatures() {\n+        \"\"\"\n+        Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n+        LObject\n+        LObject;B\n+        LIterable<LFoo>\n+        LIterable<<\n+        TBar\n+        TBar<LFoo;>\n+        B<LFoo;>\n+        B<LFoo;>;V\n+        X\n+        LFoo<TK;>.It;L\n+        <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n+        <K:LObject;>>LFoo<TK;>;\n+        <K:LObject;>LFoo<+>;\n+        ()V\n+        \"\"\".lines().forEach(assertThrows(ClassSignature::parseFrom));\n+    }\n+\n+    @Test\n+    void testBadMethodSignatures() {\n+        \"\"\"\n+        LObject;\n+        B\n+        ()V^\n+        ()V^B\n+        ()V^X\n+        (LObject;)\n+        (LObject)V\n+        ()LIterable<LFoo>\n+        ()LIterable<<\n+        ()TBar\n+        ()TBar;B\n+        (TBar<LFoo;>)V\n+        (B<LFoo;>)V\n+        (X)\n+        ()X\n+        ()VB\n+        ()LSet<+Kind<**>;>;\n+        (LSet<?Kind<*>;>;)V\n+        <T::LA>()V\n+        \"\"\".lines().forEach(assertThrows(MethodSignature::parseFrom));\n+    }\n+\n+    private Consumer<String> assertThrows(Function<String, ?> parser) {\n+        return s -> Assertions.assertThrows(IllegalArgumentException.class, () -> parser.apply(s), s);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"}]}