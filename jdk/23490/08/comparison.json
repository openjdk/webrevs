{"files":[{"patch":"@@ -421,1 +421,1 @@\n-JvmtiExport::get_jvmti_thread_state(JavaThread *thread) {\n+JvmtiExport::get_jvmti_thread_state(JavaThread *thread, bool allow_suspend) {\n@@ -425,0 +425,6 @@\n+    if (allow_suspend && thread->is_suspended()) {\n+      \/\/ Suspend here if thread_started got a suspend request during its execution.\n+      \/\/ Within thread_started we could block on a VM mutex and pick up a suspend\n+      \/\/ request from debug agent which we need to honor before proceeding.\n+      ThreadBlockInVM tbivm(thread, true \/* allow suspend *\/);\n+    }\n@@ -2631,1 +2637,1 @@\n-  JvmtiThreadState *state = get_jvmti_thread_state(thread);\n+  JvmtiThreadState *state = get_jvmti_thread_state(thread, false \/* allow_suspend *\/);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -312,1 +312,5 @@\n-  static JvmtiThreadState* get_jvmti_thread_state(JavaThread *thread);\n+  \/\/ The 'allow_suspend' parameter is passed as 'true' by default which work for almost all call sites.\n+  \/\/ It means that a suspend point need to be organized by this function for virtual threads if the call\n+  \/\/ to jvmtiEventController::thread_started hits a safepoint and gets a new suspend request.\n+  \/\/ The 'allow_suspend' parameter must be passed as 'false' if thread is holding a VM lock.\n+  static JvmtiThreadState* get_jvmti_thread_state(JavaThread *thread, bool allow_suspend = true);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}