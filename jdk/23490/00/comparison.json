{"files":[{"patch":"@@ -707,0 +707,3 @@\n+  if (_handshakee->is_virtual()) {\n+    _lock.notify();\n+  }\n@@ -739,0 +742,3 @@\n+    if (_handshakee->is_virtual()) {\n+      _lock.notify();\n+    }\n@@ -789,0 +795,11 @@\n+\n+    if (st.did_suspend() && _handshakee->is_virtual()) {\n+      \/\/ Thread suspension works under JvmtiVTMSTransitionDisabler protection, so we need to wait\n+      \/\/ for virtual thread to reach a safe state before the JVMTI SuspendThread is returned.\n+      while (_handshakee->thread_state() != _thread_blocked &&\n+             _handshakee->thread_state() != _thread_in_native) {\n+        ThreadBlockInVM tbivm(self);\n+        MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+        _lock.wait_without_safepoint_check(1);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -707,0 +707,5 @@\n+  inline bool is_virtual() const {\n+    ContinuationEntry* ce = last_continuation();\n+    return ce != nullptr && ce->is_virtual_thread();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}