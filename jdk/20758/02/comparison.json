{"files":[{"patch":"@@ -41,0 +41,4 @@\n+product(bool, EnableAllLargePageSizesForWindows, false,                   \\\n+        \"Enable support for multiple large page sizes on \"                \\\n+        \"Windows Server\")                                                 \\\n+                                                                          \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3126,1 +3126,1 @@\n-static bool request_lock_memory_privilege() {\n+bool os::win32::request_lock_memory_privilege() {\n@@ -3310,1 +3310,1 @@\n-static size_t large_page_init_decide_size() {\n+size_t os::win32::large_page_init_decide_size() {\n@@ -3315,1 +3315,1 @@\n-#define WARN(msg) if (warn_on_failure) { warning(msg); }\n+#define WARN(...) if (warn_on_failure) { warning(__VA_ARGS__); }\n@@ -3317,1 +3317,1 @@\n-  if (!request_lock_memory_privilege()) {\n+  if (!os::win32::request_lock_memory_privilege()) {\n@@ -3328,2 +3328,2 @@\n-#if defined(IA32) || defined(AMD64)\n-  if (size > 4*M || LargePageSizeInBytes > 4*M) {\n+#if defined(IA32)\n+  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n@@ -3333,0 +3333,7 @@\n+#elif defined(AMD64)\n+  if (!EnableAllLargePageSizesForWindows) {\n+    if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n+      WARN(\"JVM cannot use large pages bigger than 4mb.\");\n+      return 0;\n+    }\n+  }\n@@ -3335,2 +3342,6 @@\n-  if (LargePageSizeInBytes > 0 && LargePageSizeInBytes % size == 0) {\n-    size = LargePageSizeInBytes;\n+  if (LargePageSizeInBytes > 0) {\n+    if (LargePageSizeInBytes % size == 0) {\n+      size = LargePageSizeInBytes;\n+    } else {\n+      WARN(\"The specified large page size (%d) is not a multiple of the minimum large page size (%d), defaulting to minimum page size.\", LargePageSizeInBytes, size);\n+    }\n@@ -3349,1 +3360,1 @@\n-  _large_page_size = large_page_init_decide_size();\n+  _large_page_size = os::win32::large_page_init_decide_size();\n@@ -3352,0 +3363,11 @@\n+#if !defined(IA32)\n+    if (EnableAllLargePageSizesForWindows) {\n+      size_t min_size = GetLargePageMinimum();\n+\n+      \/\/ Populate _page_sizes with large page sizes less than or equal to _large_page_size, ensuring each page size is double the size of the previous one.\n+      for (size_t page_size = min_size; page_size < _large_page_size; page_size *= 2) {\n+        _page_sizes.add(page_size);\n+      }\n+    }\n+#endif\n+\n@@ -3354,1 +3376,1 @@\n-\n+  \/\/ Set UseLargePages based on whether a large page size was successfully determined\n@@ -3618,1 +3640,0 @@\n-  assert(page_size == os::large_page_size(), \"Currently only support one large page size on Windows\");\n@@ -3627,0 +3648,6 @@\n+  \/\/ Ensure GetLargePageMinimum() returns a valid positive value\n+  size_t large_page_min = GetLargePageMinimum();\n+  if (large_page_min <= 0) {\n+    return nullptr;\n+  }\n+\n@@ -3631,1 +3658,1 @@\n-  if (addr == nullptr && alignment > page_size) {\n+  if (addr == nullptr && alignment > large_page_min) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+  static bool   request_lock_memory_privilege();\n+  static size_t large_page_init_decide_size();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -725,0 +725,108 @@\n+TEST_VM(os_windows, large_page_init_multiple_sizes) {\n+  \/\/ Call request_lock_memory_privilege() and check the result\n+  if (!os::win32::request_lock_memory_privilege()) {\n+    GTEST_SKIP() << \"Skipping test because lock memory privilege is not granted.\";\n+  }\n+  \/\/ Set globals to make sure we hit the correct code path\n+  AutoSaveRestore<bool> guardUseLargePages(UseLargePages);\n+  AutoSaveRestore<bool> guardEnableAllLargePageSizesForWindows(EnableAllLargePageSizesForWindows);\n+  AutoSaveRestore<size_t> guardLargePageSizeInBytes(LargePageSizeInBytes);\n+  FLAG_SET_CMDLINE(UseLargePages, true);\n+  FLAG_SET_CMDLINE(EnableAllLargePageSizesForWindows, true);\n+\n+  \/\/ Determine the minimum page size\n+  const size_t min_size = GetLargePageMinimum();\n+\n+  \/\/ End the test if GetLargePageMinimum returns 0\n+  if (min_size == 0) {\n+    GTEST_SKIP() << \"Large pages are not supported on this system.\";\n+    return;\n+  }\n+\n+  \/\/ Set LargePageSizeInBytes to 4 times the minimum page size\n+  FLAG_SET_CMDLINE(LargePageSizeInBytes, 4 * min_size); \/\/ Set a value for multiple page sizes\n+\n+  \/\/ Initialize large page settings\n+  os::large_page_init();\n+\n+  \/\/ Verify that large pages are enabled\n+  EXPECT_TRUE(UseLargePages) << \"UseLargePages should be true after initialization for LargePageSizeInBytes = 4 * min_size\";\n+\n+  \/\/ Verify that decided_large_page_size is greater than the default page size\n+  const size_t default_page_size = os::vm_page_size();\n+  size_t decided_large_page_size = os::win32::large_page_init_decide_size();\n+  EXPECT_GT(decided_large_page_size, default_page_size) << \"Large page size should be greater than the default page size for LargePageSizeInBytes = 4 * min_size\";\n+\n+#if !defined(IA32)\n+  size_t page_size_count = 0;\n+  size_t page_size = os::page_sizes().largest();\n+\n+  do {\n+    ++page_size_count;\n+    page_size = os::page_sizes().next_smaller(page_size);\n+  } while (page_size >= os::page_sizes().smallest());\n+\n+  EXPECT_GT(page_size_count, 1u) << \"There should be multiple large page sizes available.\";\n+\n+  size_t large_page_size = decided_large_page_size;\n+\n+  for (size_t page_size = os::page_sizes().largest(); page_size >= min_size; page_size = os::page_sizes().next_smaller(page_size)) {\n+    EXPECT_TRUE(page_size % min_size == 0) << \"Each page size should be a multiple of the minimum large page size.\";\n+    EXPECT_LE(page_size, large_page_size) << \"Page size should not exceed the determined large page size.\";\n+  }\n+#endif\n+}\n+\n+TEST_VM(os_windows, large_page_init_decide_size) {\n+  \/\/ Initial setup\n+    \/\/ Call request_lock_memory_privilege() and check the result\n+  if (!os::win32::request_lock_memory_privilege()) {\n+    GTEST_SKIP() << \"Skipping test because lock memory privilege is not granted.\";\n+  }\n+  AutoSaveRestore<bool> guardUseLargePages(UseLargePages);\n+  AutoSaveRestore<size_t> guardLargePageSizeInBytes(LargePageSizeInBytes);\n+  FLAG_SET_CMDLINE(UseLargePages, true);\n+  FLAG_SET_CMDLINE(LargePageSizeInBytes, 0); \/\/ Reset to default\n+\n+  \/\/ Test for large page support\n+  size_t decided_size = os::win32::large_page_init_decide_size();\n+  size_t min_size = GetLargePageMinimum();\n+  if (min_size == 0) {\n+    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n+    return;\n+  }\n+\n+  \/\/ Scenario 1: Test with 2MB large page size\n+  if (min_size == 2 * M) {\n+    FLAG_SET_CMDLINE(LargePageSizeInBytes, 2 * M); \/\/ Set large page size to 2MB\n+    decided_size = os::win32::large_page_init_decide_size(); \/\/ Recalculate decided size\n+    EXPECT_EQ(decided_size, 2 * M) << \"Expected decided size to be 2M when large page and OS reported size are both 2M\";\n+  }\n+\n+  \/\/ Scenario 2: Test with 1MB large page size\n+  if (min_size == 2 * M) {\n+    FLAG_SET_CMDLINE(LargePageSizeInBytes, 1 * M); \/\/ Set large page size to 1MB\n+    decided_size = os::win32::large_page_init_decide_size(); \/\/ Recalculate decided size\n+    EXPECT_EQ(decided_size, 2 * M) << \"Expected decided size to be 2M when large page is 1M and OS reported size is 2M\";\n+  }\n+\n+#if defined(IA32) || defined(AMD64)\n+  FLAG_SET_CMDLINE(LargePageSizeInBytes, 5 * M); \/\/ Set large page size to 5MB\n+  if (!EnableAllLargePageSizesForWindows) {\n+    decided_size = os::win32::large_page_init_decide_size(); \/\/ Recalculate decided size\n+    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n+  }\n+#endif\n+\n+  \/\/ Additional check for non-multiple of minimum size\n+  \/\/ Set an arbitrary large page size which is not a multiple of min_size\n+  FLAG_SET_CMDLINE(LargePageSizeInBytes, 5 * min_size + 1);\n+\n+  \/\/ Recalculate decided size\n+  decided_size = os::win32::large_page_init_decide_size();\n+\n+  \/\/ Assert that the decided size defaults to minimum page size when LargePageSizeInBytes\n+  \/\/ is not a multiple of the minimum size, assuming conditions are always met\n+  EXPECT_EQ(decided_size, 0) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"}]}