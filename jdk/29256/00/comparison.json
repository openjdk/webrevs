{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -85,1 +86,1 @@\n-  _rcu_counter = 0;\n+  _rcu_counter.store_relaxed(0);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -241,1 +242,1 @@\n-  volatile uintx _rcu_counter;\n+  Atomic<uintx> _rcu_counter;\n@@ -243,1 +244,1 @@\n-  volatile uintx* get_rcu_counter() {\n+  Atomic<uintx>* get_rcu_counter() {\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -44,1 +44,1 @@\n-      uintx cnt = AtomicAccess::load_acquire(thread->get_rcu_counter());\n+      uintx cnt = thread->get_rcu_counter()->load_acquire();\n@@ -60,3 +60,3 @@\n-  assert((*Thread::current()->get_rcu_counter() & COUNTER_ACTIVE) == 0x0, \"must be outside a critcal section\");\n-  \/\/ AtomicAccess::add must provide fence since we have storeload dependency.\n-  uintx gbl_cnt = AtomicAccess::add(&_global_counter._counter, COUNTER_INCREMENT);\n+  assert((Thread::current()->get_rcu_counter()->load_relaxed() & COUNTER_ACTIVE) == 0x0, \"must be outside a critcal section\");\n+  \/\/ Atomic add must provide fence since we have storeload dependency.\n+  uintx gbl_cnt = _global_counter._counter.add_then_fetch(COUNTER_INCREMENT);\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -50,1 +51,1 @@\n-    volatile uintx _counter;\n+    Atomic<uintx> _counter;\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -36,1 +36,1 @@\n-  uintx old_cnt = AtomicAccess::load(thread->get_rcu_counter());\n+  uintx old_cnt = thread->get_rcu_counter()->load_relaxed();\n@@ -41,1 +41,1 @@\n-    new_cnt = AtomicAccess::load(&_global_counter._counter) | COUNTER_ACTIVE;\n+    new_cnt = _global_counter._counter.load_relaxed() | COUNTER_ACTIVE;\n@@ -43,1 +43,1 @@\n-  AtomicAccess::release_store_fence(thread->get_rcu_counter(), new_cnt);\n+  thread->get_rcu_counter()->release_store_fence(new_cnt);\n@@ -50,1 +50,1 @@\n-  assert((*thread->get_rcu_counter() & COUNTER_ACTIVE) == COUNTER_ACTIVE, \"must be in critical section\");\n+  assert((thread->get_rcu_counter()->load_relaxed() & COUNTER_ACTIVE) == COUNTER_ACTIVE, \"must be in critical section\");\n@@ -52,2 +52,1 @@\n-  AtomicAccess::release_store(thread->get_rcu_counter(),\n-                              static_cast<uintx>(context));\n+  thread->get_rcu_counter()->release_store(static_cast<uintx>(context));\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.inline.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}