{"files":[{"patch":"@@ -192,5 +192,0 @@\n-  Address(Register base, Register index, intptr_t disp = 0) :\n-    _base(base),\n-    _index(index),\n-    _disp(disp) {}\n-\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -859,1 +859,1 @@\n-  return 0; \/\/ unused\n+  return Address(); \/\/ unused\n@@ -865,1 +865,1 @@\n-  return 0; \/\/ unused\n+  return Address(); \/\/ unused\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -76,1 +76,1 @@\n-                 as_Register(int_arg_nr) + Z_ARG1->encoding() : Z_R0;\n+                 as_Register(int_arg_nr + Z_ARG1->encoding()) : Z_R0;\n@@ -87,1 +87,1 @@\n-                 as_Register(int_arg_nr) + Z_ARG1->encoding() : Z_R0;\n+                 as_Register(int_arg_nr + Z_ARG1->encoding()) : Z_R0;\n@@ -118,1 +118,1 @@\n-                  as_Register(int_arg_nr) + Z_ARG1->encoding() : Z_R0;\n+                  as_Register(int_arg_nr + Z_ARG1->encoding()) : Z_R0;\n","filename":"src\/hotspot\/cpu\/s390\/interpreterRT_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -641,1 +641,1 @@\n-  assert((Z_ARG5->encoding() - Z_ARG1->encoding() + 1) == RegisterImpl::number_of_arg_registers, \"Oops\");\n+  assert((Z_ARG5->encoding() - Z_ARG1->encoding() + 1) == Register::number_of_arg_registers, \"Oops\");\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -30,1 +30,1 @@\n-const int ConcreteRegisterImpl::max_gpr = RegisterImpl::number_of_registers * 2;\n+const int ConcreteRegisterImpl::max_gpr = Register::number_of_registers * 2;\n@@ -32,1 +32,1 @@\n-                                          FloatRegisterImpl::number_of_registers * 2;\n+                                          FloatRegister::number_of_registers * 2;\n@@ -34,1 +34,1 @@\n-const char* RegisterImpl::name() const {\n+const char* Register::name() const {\n@@ -42,1 +42,1 @@\n-const char* FloatRegisterImpl::name() const {\n+const char* FloatRegister::name() const {\n@@ -44,2 +44,2 @@\n-    \"Z_F0\",  \"Z_F1\",   \"Z_F2\",  \"Z_F3\",   \"Z_F4\",  \"Z_F5\",   \"Z_F6\",  \"Z_F7\",   \"Z_F8\",  \"Z_F9\",\n-    \"Z_F10\", \"Z_F11\",  \"Z_F12\", \"Z_F13\",  \"Z_F14\", \"Z_F15\"\n+    \"Z_F0\",  \"Z_F1\",   \"Z_F2\",  \"Z_F3\",   \"Z_F4\",  \"Z_F5\",   \"Z_F6\",  \"Z_F7\",\n+    \"Z_F8\",  \"Z_F9\",  \"Z_F10\", \"Z_F11\",  \"Z_F12\", \"Z_F13\",  \"Z_F14\", \"Z_F15\"\n@@ -50,1 +50,1 @@\n-const char* VectorRegisterImpl::name() const {\n+const char* VectorRegister::name() const {\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -32,2 +32,1 @@\n-class Address;\n-class VMRegImpl;\n+#define NOREG_ENCODING -1\n@@ -35,0 +34,2 @@\n+\/\/ forward declaration\n+class VMRegImpl;\n@@ -60,4 +61,0 @@\n-\/\/ Use Register as shortcut.\n-class RegisterImpl;\n-typedef RegisterImpl* Register;\n-\n@@ -65,7 +62,3 @@\n-\n-inline Register as_Register(int encoding) {\n-  return (Register)(long)encoding;\n-}\n-\n-class RegisterImpl: public AbstractRegisterImpl {\n- public:\n+class Register {\n+  int _encoding;\n+public:\n@@ -77,2 +70,4 @@\n-  \/\/ general construction\n-  inline friend Register as_Register(int encoding);\n+  constexpr Register(int encoding = NOREG_ENCODING) : _encoding(encoding) {}\n+  bool operator==(const Register rhs) const { return _encoding == rhs._encoding; }\n+  bool operator!=(const Register rhs) const { return _encoding != rhs._encoding; }\n+  const Register* operator->()        const { return this; }\n@@ -80,1 +75,2 @@\n-  inline VMReg as_VMReg();\n+  \/\/ general construction\n+  inline constexpr friend Register as_Register(int encoding);\n@@ -83,1 +79,0 @@\n-  int   encoding() const      { assert(is_valid(), \"invalid register\"); return value(); }\n@@ -85,0 +80,2 @@\n+  inline VMReg as_VMReg() const;\n+  constexpr int encoding() const { assert(is_valid(), \"invalid register\"); return _encoding; }\n@@ -86,7 +83,0 @@\n-  \/\/ testers\n-  bool is_valid() const       { return (0 <= (value()&0x7F) && (value()&0x7F) < number_of_registers); }\n-  bool is_even() const        { return (encoding() & 1) == 0; }\n-  bool is_volatile() const    { return (0 <= (value()&0x7F) && (value()&0x7F) <= 5) || (value()&0x7F)==14; }\n-  bool is_nonvolatile() const { return is_valid() && !is_volatile(); }\n-\n- public:\n@@ -94,2 +84,8 @@\n-  Register predecessor() const { return as_Register((encoding()-1) & (number_of_registers-1)); }\n-  Register successor() const   { return as_Register((encoding() + 1) & (number_of_registers-1)); }\n+  Register predecessor() const { return Register((encoding() - 1) & (number_of_registers - 1)); }\n+  Register successor()   const { return Register((encoding() + 1) & (number_of_registers - 1)); }\n+\n+  \/\/ testers\n+  constexpr bool is_valid()       const { return (0 <= _encoding && _encoding < number_of_registers); }\n+  constexpr bool is_even()        const { return (_encoding & 1) == 0; }\n+  constexpr bool is_volatile()    const { return (0 <= _encoding && _encoding <= 5) || _encoding == 14; }\n+  constexpr bool is_nonvolatile() const { return is_valid() && !is_volatile(); }\n@@ -98,1 +94,5 @@\n-\/\/ The integer registers of the z\/Architecture.\n+inline constexpr Register as_Register(int encoding) {\n+  assert(encoding == NOREG_ENCODING ||\n+        (0 <= encoding && encoding < Register::number_of_registers), \"bad register encoding\");\n+  return Register(encoding);\n+}\n@@ -100,18 +100,19 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n-\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R0,   (0));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R1,   (1));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R2,   (2));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R3,   (3));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R4,   (4));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R5,   (5));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R6,   (6));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R7,   (7));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R8,   (8));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R9,   (9));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R10, (10));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R11, (11));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R12, (12));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R13, (13));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R14, (14));\n-CONSTANT_REGISTER_DECLARATION(Register, Z_R15, (15));\n+\/\/ The integer registers of the z\/Architecture.\n+constexpr Register noreg = as_Register(NOREG_ENCODING);\n+\n+constexpr Register  Z_R0 = as_Register( 0);\n+constexpr Register  Z_R1 = as_Register( 1);\n+constexpr Register  Z_R2 = as_Register( 2);\n+constexpr Register  Z_R3 = as_Register( 3);\n+constexpr Register  Z_R4 = as_Register( 4);\n+constexpr Register  Z_R5 = as_Register( 5);\n+constexpr Register  Z_R6 = as_Register( 6);\n+constexpr Register  Z_R7 = as_Register( 7);\n+constexpr Register  Z_R8 = as_Register( 8);\n+constexpr Register  Z_R9 = as_Register( 9);\n+constexpr Register Z_R10 = as_Register(10);\n+constexpr Register Z_R11 = as_Register(11);\n+constexpr Register Z_R12 = as_Register(12);\n+constexpr Register Z_R13 = as_Register(13);\n+constexpr Register Z_R14 = as_Register(14);\n+constexpr Register Z_R15 = as_Register(15);\n@@ -124,4 +125,0 @@\n-\/\/ Use ConditionRegister as shortcut\n-class ConditionRegisterImpl;\n-typedef ConditionRegisterImpl* ConditionRegister;\n-\n@@ -130,3 +127,3 @@\n-class ConditionRegisterImpl: public AbstractRegisterImpl {\n- public:\n-\n+class ConditionRegister {\n+  int _encoding;\n+public:\n@@ -137,0 +134,5 @@\n+  constexpr ConditionRegister(int encoding = NOREG_ENCODING) : _encoding(encoding) {}\n+  bool operator==(const ConditionRegister rhs) const { return _encoding == rhs._encoding; }\n+  bool operator!=(const ConditionRegister rhs) const { return _encoding != rhs._encoding; }\n+  const ConditionRegister* operator->()        const { return this; }\n+\n@@ -138,3 +140,2 @@\n-  int encoding() const {\n-    assert(is_valid(), \"invalid register\"); return value();\n-  }\n+  constexpr int encoding() const { assert(is_valid(), \"invalid register\"); return _encoding; }\n+  inline VMReg  as_VMReg() const;\n@@ -143,9 +144,3 @@\n-  bool is_valid() const {\n-    return (0 <= value() && value() < number_of_registers);\n-  }\n-  bool is_volatile() const {\n-    return true;\n-  }\n-  bool is_nonvolatile() const {\n-    return false;\n-  }\n+  constexpr bool is_valid()       const { return (0 <= _encoding && _encoding < number_of_registers); }\n+  constexpr bool is_volatile()    const { return true; }\n+  constexpr bool is_nonvolatile() const { return false;}\n@@ -154,3 +149,1 @@\n-  inline friend ConditionRegister as_ConditionRegister(int encoding);\n-\n-  inline VMReg as_VMReg();\n+  inline constexpr friend ConditionRegister as_ConditionRegister(int encoding);\n@@ -159,3 +152,4 @@\n-inline ConditionRegister as_ConditionRegister(int encoding) {\n-  assert(encoding >= 0 && encoding < ConditionRegisterImpl::number_of_registers, \"bad condition register encoding\");\n-  return (ConditionRegister)(long)encoding;\n+inline constexpr ConditionRegister as_ConditionRegister(int encoding) {\n+  assert(encoding == NOREG_ENCODING ||\n+        (encoding >= 0 && encoding < ConditionRegister::number_of_registers), \"bad condition register encoding\");\n+  return ConditionRegister(encoding);\n@@ -166,34 +160,1 @@\n-CONSTANT_REGISTER_DECLARATION(ConditionRegister, Z_CR, (0));\n-\n-\/\/ Because z\/Architecture has so many registers, #define'ing values for them is\n-\/\/ beneficial in code size and is worth the cost of some of the\n-\/\/ dangers of defines.\n-\/\/ If a particular file has a problem with these defines then it's possible\n-\/\/ to turn them off in that file by defining\n-\/\/ DONT_USE_REGISTER_DEFINES. Register_definitions_s390.cpp does that\n-\/\/ so that it's able to provide real definitions of these registers\n-\/\/ for use in debuggers and such.\n-\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define noreg ((Register)(noreg_RegisterEnumValue))\n-\n-#define Z_R0  ((Register)(Z_R0_RegisterEnumValue))\n-#define Z_R1  ((Register)(Z_R1_RegisterEnumValue))\n-#define Z_R2  ((Register)(Z_R2_RegisterEnumValue))\n-#define Z_R3  ((Register)(Z_R3_RegisterEnumValue))\n-#define Z_R4  ((Register)(Z_R4_RegisterEnumValue))\n-#define Z_R5  ((Register)(Z_R5_RegisterEnumValue))\n-#define Z_R6  ((Register)(Z_R6_RegisterEnumValue))\n-#define Z_R7  ((Register)(Z_R7_RegisterEnumValue))\n-#define Z_R8  ((Register)(Z_R8_RegisterEnumValue))\n-#define Z_R9  ((Register)(Z_R9_RegisterEnumValue))\n-#define Z_R10 ((Register)(Z_R10_RegisterEnumValue))\n-#define Z_R11 ((Register)(Z_R11_RegisterEnumValue))\n-#define Z_R12 ((Register)(Z_R12_RegisterEnumValue))\n-#define Z_R13 ((Register)(Z_R13_RegisterEnumValue))\n-#define Z_R14 ((Register)(Z_R14_RegisterEnumValue))\n-#define Z_R15 ((Register)(Z_R15_RegisterEnumValue))\n-\n-#define Z_CR ((ConditionRegister)(Z_CR_ConditionRegisterEnumValue))\n-#endif \/\/ DONT_USE_REGISTER_DEFINES\n-\n+constexpr ConditionRegister Z_CR = as_ConditionRegister(0);\n@@ -205,4 +166,0 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef FloatRegisterImpl* FloatRegister;\n-\n@@ -211,6 +168,3 @@\n-inline FloatRegister as_FloatRegister(int encoding) {\n-  return (FloatRegister)(long)encoding;\n-}\n-\n-class FloatRegisterImpl: public AbstractRegisterImpl {\n- public:\n+class FloatRegister {\n+  int _encoding;\n+public:\n@@ -222,2 +176,4 @@\n-  \/\/ construction\n-  inline friend FloatRegister as_FloatRegister(int encoding);\n+  constexpr FloatRegister(int encoding = NOREG_ENCODING) : _encoding(encoding) {}\n+  bool operator==(const FloatRegister rhs) const { return _encoding == rhs._encoding; }\n+  bool operator!=(const FloatRegister rhs) const { return _encoding != rhs._encoding; }\n+  const FloatRegister* operator->()        const { return this; }\n@@ -225,1 +181,2 @@\n-  inline VMReg as_VMReg();\n+  \/\/ construction\n+  inline constexpr friend FloatRegister as_FloatRegister(int encoding);\n@@ -228,3 +185,3 @@\n-  int encoding() const                                {\n-     assert(is_valid(), \"invalid register\"); return value();\n-  }\n+  constexpr int encoding()  const { assert(is_valid(), \"invalid register\"); return _encoding; }\n+  inline VMReg  as_VMReg()  const;\n+  FloatRegister successor() const { return FloatRegister((encoding() + 1) & (number_of_registers - 1)); }\n@@ -232,3 +189,4 @@\n-  bool  is_valid() const          { return 0 <= value() && value() < number_of_registers; }\n-  bool is_volatile() const        { return (0 <= (value()&0x7F) && (value()&0x7F) <= 7); }\n-  bool is_nonvolatile() const     { return (8 <= (value()&0x7F) && (value()&0x7F) <= 15); }\n+  \/\/ tester\n+  constexpr bool is_valid()       const { return 0 <= _encoding && _encoding < number_of_registers; }\n+  constexpr bool is_volatile()    const { return (0 <= _encoding && _encoding <= 7); }\n+  constexpr bool is_nonvolatile() const { return (8 <= _encoding && _encoding <= 15); }\n@@ -237,2 +195,0 @@\n-\n-  FloatRegister successor() const { return as_FloatRegister(encoding() + 1); }\n@@ -241,1 +197,5 @@\n-\/\/ The float registers of z\/Architecture.\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  assert(encoding == NOREG_ENCODING ||\n+        (encoding >= 0 && encoding < FloatRegister::number_of_registers), \"bad float register encoding\");\n+  return FloatRegister(encoding);\n+}\n@@ -243,38 +203,19 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));\n-\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F0,  (0));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F1,  (1));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F2,  (2));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F3,  (3));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F4,  (4));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F5,  (5));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F6,  (6));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F7,  (7));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F8,  (8));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister,  Z_F9,  (9));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F10, (10));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F11, (11));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F12, (12));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F13, (13));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F14, (14));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Z_F15, (15));\n-\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define fnoreg ((FloatRegister)(fnoreg_FloatRegisterEnumValue))\n-#define Z_F0  ((FloatRegister)(   Z_F0_FloatRegisterEnumValue))\n-#define Z_F1  ((FloatRegister)(   Z_F1_FloatRegisterEnumValue))\n-#define Z_F2  ((FloatRegister)(   Z_F2_FloatRegisterEnumValue))\n-#define Z_F3  ((FloatRegister)(   Z_F3_FloatRegisterEnumValue))\n-#define Z_F4  ((FloatRegister)(   Z_F4_FloatRegisterEnumValue))\n-#define Z_F5  ((FloatRegister)(   Z_F5_FloatRegisterEnumValue))\n-#define Z_F6  ((FloatRegister)(   Z_F6_FloatRegisterEnumValue))\n-#define Z_F7  ((FloatRegister)(   Z_F7_FloatRegisterEnumValue))\n-#define Z_F8  ((FloatRegister)(   Z_F8_FloatRegisterEnumValue))\n-#define Z_F9  ((FloatRegister)(   Z_F9_FloatRegisterEnumValue))\n-#define Z_F10 ((FloatRegister)(  Z_F10_FloatRegisterEnumValue))\n-#define Z_F11 ((FloatRegister)(  Z_F11_FloatRegisterEnumValue))\n-#define Z_F12 ((FloatRegister)(  Z_F12_FloatRegisterEnumValue))\n-#define Z_F13 ((FloatRegister)(  Z_F13_FloatRegisterEnumValue))\n-#define Z_F14 ((FloatRegister)(  Z_F14_FloatRegisterEnumValue))\n-#define Z_F15 ((FloatRegister)(  Z_F15_FloatRegisterEnumValue))\n-#endif \/\/ DONT_USE_REGISTER_DEFINES\n+\/\/ The float registers of z\/Architecture.\n+constexpr FloatRegister fnoreg = as_FloatRegister(NOREG_ENCODING);\n+\n+constexpr FloatRegister  Z_F0 = as_FloatRegister( 0);\n+constexpr FloatRegister  Z_F1 = as_FloatRegister( 1);\n+constexpr FloatRegister  Z_F2 = as_FloatRegister( 2);\n+constexpr FloatRegister  Z_F3 = as_FloatRegister( 3);\n+constexpr FloatRegister  Z_F4 = as_FloatRegister( 4);\n+constexpr FloatRegister  Z_F5 = as_FloatRegister( 5);\n+constexpr FloatRegister  Z_F6 = as_FloatRegister( 6);\n+constexpr FloatRegister  Z_F7 = as_FloatRegister( 7);\n+constexpr FloatRegister  Z_F8 = as_FloatRegister( 8);\n+constexpr FloatRegister  Z_F9 = as_FloatRegister( 9);\n+constexpr FloatRegister Z_F10 = as_FloatRegister(10);\n+constexpr FloatRegister Z_F11 = as_FloatRegister(11);\n+constexpr FloatRegister Z_F12 = as_FloatRegister(12);\n+constexpr FloatRegister Z_F13 = as_FloatRegister(13);\n+constexpr FloatRegister Z_F14 = as_FloatRegister(14);\n+constexpr FloatRegister Z_F15 = as_FloatRegister(15);\n@@ -284,1 +225,1 @@\n-\/\/ desired by the macroassembler. A FloatRegister is a number between\n+\/\/ desired by the macroAssembler. A FloatRegister is a number between\n@@ -287,2 +228,2 @@\n-\/\/ the macroassembler to generate an instruction that references, e.g., a\n-\/\/ double fp reg, it passed the bit encoding to the macroassembler via\n+\/\/ the macroAssembler to generate an instruction that references, e.g., a\n+\/\/ double fp reg, it passed the bit encoding to the macroAssembler via\n@@ -298,2 +239,6 @@\n-class SingleFloatRegisterImpl;\n-typedef SingleFloatRegisterImpl *SingleFloatRegister;\n+class SingleFloatRegister {\n+public:\n+  enum {\n+    number_of_registers = 32\n+  };\n+  const SingleFloatRegister* operator->() const { return this; }\n@@ -301,4 +246,2 @@\n-class SingleFloatRegisterImpl {\n- public:\n-  friend FloatRegister as_SingleFloatRegister(int encoding) {\n-    assert(encoding < 32, \"bad single float register encoding\");\n+  inline constexpr friend FloatRegister as_SingleFloatRegister(int encoding) {\n+    assert(encoding < number_of_registers, \"bad single float register encoding\");\n@@ -309,2 +252,2 @@\n-class DoubleFloatRegisterImpl;\n-typedef DoubleFloatRegisterImpl *DoubleFloatRegister;\n+class DoubleFloatRegister {\n+public:\n@@ -312,4 +255,3 @@\n-class DoubleFloatRegisterImpl {\n- public:\n-  friend FloatRegister as_DoubleFloatRegister(int encoding) {\n-    assert(encoding < 32, \"bad double float register encoding\");\n+  const DoubleFloatRegister* operator->() const { return this; }\n+\n+  inline constexpr friend FloatRegister as_DoubleFloatRegister(int encoding) {\n@@ -320,2 +262,7 @@\n-class QuadFloatRegisterImpl;\n-typedef QuadFloatRegisterImpl *QuadFloatRegister;\n+class QuadFloatRegister {\n+public:\n+  enum {\n+    number_of_registers = 32\n+  };\n+\n+  const QuadFloatRegister* operator->() const { return this; }\n@@ -323,4 +270,2 @@\n-class QuadFloatRegisterImpl {\n- public:\n-  friend FloatRegister as_QuadFloatRegister(int encoding) {\n-    assert(encoding < 32 && ((encoding & 2) == 0), \"bad quad float register encoding\");\n+  inline constexpr friend FloatRegister as_QuadFloatRegister(int encoding) {\n+    assert(encoding < QuadFloatRegister::number_of_registers && ((encoding & 2) == 0), \"bad quad float register encoding\");\n@@ -336,4 +281,0 @@\n-\/\/ Use VectorRegister as shortcut\n-class VectorRegisterImpl;\n-typedef VectorRegisterImpl* VectorRegister;\n-\n@@ -342,6 +283,3 @@\n-inline VectorRegister as_VectorRegister(int encoding) {\n-  return (VectorRegister)(long)encoding;\n-}\n-\n-class VectorRegisterImpl: public AbstractRegisterImpl {\n- public:\n+class VectorRegister {\n+  int _encoding;\n+public:\n@@ -353,0 +291,5 @@\n+  constexpr VectorRegister(int encoding = NOREG_ENCODING) : _encoding(encoding) {}\n+  bool operator==(const VectorRegister rhs) const { return _encoding == rhs._encoding; }\n+  bool operator!=(const VectorRegister rhs) const { return _encoding != rhs._encoding; }\n+  const VectorRegister* operator->()        const { return this; }\n+\n@@ -354,1 +297,1 @@\n-  inline friend VectorRegister as_VectorRegister(int encoding);\n+  inline constexpr friend VectorRegister as_VectorRegister(int encoding);\n@@ -356,1 +299,1 @@\n-  inline VMReg as_VMReg();\n+  inline VMReg as_VMReg() const;\n@@ -359,3 +302,2 @@\n-  int encoding() const                                {\n-     assert(is_valid(), \"invalid register\"); return value();\n-  }\n+  constexpr int  encoding()  const { assert(is_valid(), \"invalid register\"); return _encoding; }\n+  VectorRegister successor() const { return VectorRegister((encoding() + 1) & (number_of_registers - 1)); }\n@@ -363,3 +305,5 @@\n-  bool is_valid() const           { return  0 <= value() && value() < number_of_registers; }\n-  bool is_volatile() const        { return true; }\n-  bool is_nonvolatile() const     { return false; }\n+\n+  \/\/ tester\n+  constexpr bool is_valid()       const { return  0 <= _encoding && _encoding < number_of_registers; }\n+  constexpr bool is_volatile()    const { return true; }\n+  constexpr bool is_nonvolatile() const { return false; }\n@@ -377,1 +321,1 @@\n-  int64_t RXB_mask(int pos) {\n+  int64_t RXB_mask(int pos) const {\n@@ -392,2 +336,0 @@\n-\n-  VectorRegister successor() const { return as_VectorRegister(encoding() + 1); }\n@@ -396,72 +338,5 @@\n-\/\/ The Vector registers of z\/Architecture.\n-\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, vnoreg, (-1));\n-\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V0,  (0));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V1,  (1));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V2,  (2));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V3,  (3));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V4,  (4));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V5,  (5));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V6,  (6));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V7,  (7));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V8,  (8));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister,  Z_V9,  (9));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V10, (10));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V11, (11));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V12, (12));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V13, (13));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V14, (14));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V15, (15));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V16, (16));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V17, (17));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V18, (18));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V19, (19));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V20, (20));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V21, (21));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V22, (22));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V23, (23));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V24, (24));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V25, (25));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V26, (26));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V27, (27));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V28, (28));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V29, (29));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V30, (30));\n-CONSTANT_REGISTER_DECLARATION(VectorRegister, Z_V31, (31));\n-\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define vnoreg ((VectorRegister)(vnoreg_VectorRegisterEnumValue))\n-#define Z_V0  ((VectorRegister)(   Z_V0_VectorRegisterEnumValue))\n-#define Z_V1  ((VectorRegister)(   Z_V1_VectorRegisterEnumValue))\n-#define Z_V2  ((VectorRegister)(   Z_V2_VectorRegisterEnumValue))\n-#define Z_V3  ((VectorRegister)(   Z_V3_VectorRegisterEnumValue))\n-#define Z_V4  ((VectorRegister)(   Z_V4_VectorRegisterEnumValue))\n-#define Z_V5  ((VectorRegister)(   Z_V5_VectorRegisterEnumValue))\n-#define Z_V6  ((VectorRegister)(   Z_V6_VectorRegisterEnumValue))\n-#define Z_V7  ((VectorRegister)(   Z_V7_VectorRegisterEnumValue))\n-#define Z_V8  ((VectorRegister)(   Z_V8_VectorRegisterEnumValue))\n-#define Z_V9  ((VectorRegister)(   Z_V9_VectorRegisterEnumValue))\n-#define Z_V10 ((VectorRegister)(  Z_V10_VectorRegisterEnumValue))\n-#define Z_V11 ((VectorRegister)(  Z_V11_VectorRegisterEnumValue))\n-#define Z_V12 ((VectorRegister)(  Z_V12_VectorRegisterEnumValue))\n-#define Z_V13 ((VectorRegister)(  Z_V13_VectorRegisterEnumValue))\n-#define Z_V14 ((VectorRegister)(  Z_V14_VectorRegisterEnumValue))\n-#define Z_V15 ((VectorRegister)(  Z_V15_VectorRegisterEnumValue))\n-#define Z_V16 ((VectorRegister)(  Z_V16_VectorRegisterEnumValue))\n-#define Z_V17 ((VectorRegister)(  Z_V17_VectorRegisterEnumValue))\n-#define Z_V18 ((VectorRegister)(  Z_V18_VectorRegisterEnumValue))\n-#define Z_V19 ((VectorRegister)(  Z_V19_VectorRegisterEnumValue))\n-#define Z_V20 ((VectorRegister)(  Z_V20_VectorRegisterEnumValue))\n-#define Z_V21 ((VectorRegister)(  Z_V21_VectorRegisterEnumValue))\n-#define Z_V22 ((VectorRegister)(  Z_V22_VectorRegisterEnumValue))\n-#define Z_V23 ((VectorRegister)(  Z_V23_VectorRegisterEnumValue))\n-#define Z_V24 ((VectorRegister)(  Z_V24_VectorRegisterEnumValue))\n-#define Z_V25 ((VectorRegister)(  Z_V25_VectorRegisterEnumValue))\n-#define Z_V26 ((VectorRegister)(  Z_V26_VectorRegisterEnumValue))\n-#define Z_V27 ((VectorRegister)(  Z_V27_VectorRegisterEnumValue))\n-#define Z_V28 ((VectorRegister)(  Z_V28_VectorRegisterEnumValue))\n-#define Z_V29 ((VectorRegister)(  Z_V29_VectorRegisterEnumValue))\n-#define Z_V30 ((VectorRegister)(  Z_V30_VectorRegisterEnumValue))\n-#define Z_V31 ((VectorRegister)(  Z_V31_VectorRegisterEnumValue))\n-#endif \/\/ DONT_USE_REGISTER_DEFINES\n+inline constexpr VectorRegister as_VectorRegister(int encoding) {\n+  assert(encoding == NOREG_ENCODING ||\n+        (encoding >= 0 && encoding < VectorRegister::number_of_registers), \"bad vector register encoding\");\n+  return VectorRegister(encoding);\n+}\n@@ -469,0 +344,35 @@\n+\/\/ The Vector registers of z\/Architecture.\n+constexpr VectorRegister vnoreg = as_VectorRegister(NOREG_ENCODING);\n+\n+constexpr VectorRegister  Z_V0 = as_VectorRegister( 0);\n+constexpr VectorRegister  Z_V1 = as_VectorRegister( 1);\n+constexpr VectorRegister  Z_V2 = as_VectorRegister( 2);\n+constexpr VectorRegister  Z_V3 = as_VectorRegister( 3);\n+constexpr VectorRegister  Z_V4 = as_VectorRegister( 4);\n+constexpr VectorRegister  Z_V5 = as_VectorRegister( 5);\n+constexpr VectorRegister  Z_V6 = as_VectorRegister( 6);\n+constexpr VectorRegister  Z_V7 = as_VectorRegister( 7);\n+constexpr VectorRegister  Z_V8 = as_VectorRegister( 8);\n+constexpr VectorRegister  Z_V9 = as_VectorRegister( 9);\n+constexpr VectorRegister Z_V10 = as_VectorRegister(10);\n+constexpr VectorRegister Z_V11 = as_VectorRegister(11);\n+constexpr VectorRegister Z_V12 = as_VectorRegister(12);\n+constexpr VectorRegister Z_V13 = as_VectorRegister(13);\n+constexpr VectorRegister Z_V14 = as_VectorRegister(14);\n+constexpr VectorRegister Z_V15 = as_VectorRegister(15);\n+constexpr VectorRegister Z_V16 = as_VectorRegister(16);\n+constexpr VectorRegister Z_V17 = as_VectorRegister(17);\n+constexpr VectorRegister Z_V18 = as_VectorRegister(18);\n+constexpr VectorRegister Z_V19 = as_VectorRegister(19);\n+constexpr VectorRegister Z_V20 = as_VectorRegister(20);\n+constexpr VectorRegister Z_V21 = as_VectorRegister(21);\n+constexpr VectorRegister Z_V22 = as_VectorRegister(22);\n+constexpr VectorRegister Z_V23 = as_VectorRegister(23);\n+constexpr VectorRegister Z_V24 = as_VectorRegister(24);\n+constexpr VectorRegister Z_V25 = as_VectorRegister(25);\n+constexpr VectorRegister Z_V26 = as_VectorRegister(26);\n+constexpr VectorRegister Z_V27 = as_VectorRegister(27);\n+constexpr VectorRegister Z_V28 = as_VectorRegister(28);\n+constexpr VectorRegister Z_V29 = as_VectorRegister(29);\n+constexpr VectorRegister Z_V30 = as_VectorRegister(30);\n+constexpr VectorRegister Z_V31 = as_VectorRegister(31);\n@@ -477,2 +387,2 @@\n-      (RegisterImpl::number_of_registers +\n-      FloatRegisterImpl::number_of_registers)\n+      (Register::number_of_registers +\n+      FloatRegister::number_of_registers)\n@@ -488,31 +398,14 @@\n-REGISTER_DECLARATION(Register,      Z_EXC_OOP, Z_R2);\n-REGISTER_DECLARATION(Register,      Z_EXC_PC,  Z_R3);\n-REGISTER_DECLARATION(Register,      Z_RET,     Z_R2);\n-REGISTER_DECLARATION(Register,      Z_ARG1,    Z_R2);\n-REGISTER_DECLARATION(Register,      Z_ARG2,    Z_R3);\n-REGISTER_DECLARATION(Register,      Z_ARG3,    Z_R4);\n-REGISTER_DECLARATION(Register,      Z_ARG4,    Z_R5);\n-REGISTER_DECLARATION(Register,      Z_ARG5,    Z_R6);\n-REGISTER_DECLARATION(Register,      Z_SP,     Z_R15);\n-REGISTER_DECLARATION(FloatRegister, Z_FRET,    Z_F0);\n-REGISTER_DECLARATION(FloatRegister, Z_FARG1,   Z_F0);\n-REGISTER_DECLARATION(FloatRegister, Z_FARG2,   Z_F2);\n-REGISTER_DECLARATION(FloatRegister, Z_FARG3,   Z_F4);\n-REGISTER_DECLARATION(FloatRegister, Z_FARG4,   Z_F6);\n-\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define Z_EXC_OOP         AS_REGISTER(Register,  Z_R2)\n-#define Z_EXC_PC          AS_REGISTER(Register,  Z_R3)\n-#define Z_RET             AS_REGISTER(Register,  Z_R2)\n-#define Z_ARG1            AS_REGISTER(Register,  Z_R2)\n-#define Z_ARG2            AS_REGISTER(Register,  Z_R3)\n-#define Z_ARG3            AS_REGISTER(Register,  Z_R4)\n-#define Z_ARG4            AS_REGISTER(Register,  Z_R5)\n-#define Z_ARG5            AS_REGISTER(Register,  Z_R6)\n-#define Z_SP              AS_REGISTER(Register, Z_R15)\n-#define Z_FRET            AS_REGISTER(FloatRegister, Z_F0)\n-#define Z_FARG1           AS_REGISTER(FloatRegister, Z_F0)\n-#define Z_FARG2           AS_REGISTER(FloatRegister, Z_F2)\n-#define Z_FARG3           AS_REGISTER(FloatRegister, Z_F4)\n-#define Z_FARG4           AS_REGISTER(FloatRegister, Z_F6)\n-#endif\n+constexpr Register       Z_EXC_OOP = Z_R2;\n+constexpr Register       Z_EXC_PC  = Z_R3;\n+constexpr Register       Z_RET     = Z_R2;\n+constexpr Register       Z_ARG1    = Z_R2;\n+constexpr Register       Z_ARG2    = Z_R3;\n+constexpr Register       Z_ARG3    = Z_R4;\n+constexpr Register       Z_ARG4    = Z_R5;\n+constexpr Register       Z_ARG5    = Z_R6;\n+constexpr Register       Z_SP      = Z_R15;\n+constexpr FloatRegister  Z_FRET    = Z_F0;\n+constexpr FloatRegister  Z_FARG1   = Z_F0;\n+constexpr FloatRegister  Z_FARG2   = Z_F2;\n+constexpr FloatRegister  Z_FARG3   = Z_F4;\n+constexpr FloatRegister  Z_FARG4   = Z_F6;\n@@ -524,1 +417,1 @@\n-REGISTER_DECLARATION(Register, Z_tos,         Z_R2);\n+constexpr Register      Z_tos          = Z_R2;\n@@ -526,1 +419,1 @@\n-REGISTER_DECLARATION(FloatRegister, Z_ftos,   Z_F0);\n+constexpr FloatRegister Z_ftos         = Z_F0;\n@@ -528,1 +421,1 @@\n-REGISTER_DECLARATION(Register, Z_esp,         Z_R7);\n+constexpr Register      Z_esp          = Z_R7;\n@@ -530,1 +423,1 @@\n-REGISTER_DECLARATION(Register, Z_thread,      Z_R8);\n+constexpr Register      Z_thread       = Z_R8;\n@@ -532,1 +425,1 @@\n-REGISTER_DECLARATION(Register, Z_method,      Z_R9);\n+constexpr Register      Z_method       = Z_R9;\n@@ -534,1 +427,1 @@\n-REGISTER_DECLARATION(Register, Z_inline_cache,Z_R9);\n+constexpr Register      Z_inline_cache = Z_R9;\n@@ -537,1 +430,1 @@\n-REGISTER_DECLARATION(Register, Z_fp,          Z_R9);\n+constexpr Register      Z_fp           = Z_R9;\n@@ -539,1 +432,1 @@\n-REGISTER_DECLARATION(Register, Z_locals,      Z_R12);\n+constexpr Register      Z_locals       = Z_R12;\n@@ -541,1 +434,1 @@\n-REGISTER_DECLARATION(Register, Z_bcp,         Z_R13);\n+constexpr Register      Z_bcp          = Z_R13;\n@@ -543,13 +436,1 @@\n-REGISTER_DECLARATION(Register, Z_bytecode,    Z_R14);\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define Z_tos             AS_REGISTER(Register, Z_R2)\n-#define Z_ftos            AS_REGISTER(FloatRegister, Z_F0)\n-#define Z_esp             AS_REGISTER(Register, Z_R7)\n-#define Z_thread          AS_REGISTER(Register, Z_R8)\n-#define Z_method          AS_REGISTER(Register, Z_R9)\n-#define Z_inline_cache    AS_REGISTER(Register, Z_R9)\n-#define Z_fp              AS_REGISTER(Register, Z_R9)\n-#define Z_locals          AS_REGISTER(Register, Z_R12)\n-#define Z_bcp             AS_REGISTER(Register, Z_R13)\n-#define Z_bytecode        AS_REGISTER(Register, Z_R14)\n-#endif\n+constexpr Register      Z_bytecode     = Z_R14;\n@@ -558,1 +439,1 @@\n-\/\/ the nonvolatiles because the call stub has saved them.\n+\/\/ the nonvolatile ones because the call stub has saved them.\n@@ -560,10 +441,4 @@\n-REGISTER_DECLARATION(Register, Z_tmp_1,  Z_R10);\n-REGISTER_DECLARATION(Register, Z_tmp_2,  Z_R11);\n-REGISTER_DECLARATION(Register, Z_tmp_3,  Z_R12);\n-REGISTER_DECLARATION(Register, Z_tmp_4,  Z_R13);\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define Z_tmp_1      AS_REGISTER(Register, Z_R10)\n-#define Z_tmp_2      AS_REGISTER(Register, Z_R11)\n-#define Z_tmp_3      AS_REGISTER(Register, Z_R12)\n-#define Z_tmp_4      AS_REGISTER(Register, Z_R13)\n-#endif\n+constexpr Register Z_tmp_1 =  Z_R10;\n+constexpr Register Z_tmp_2 =  Z_R11;\n+constexpr Register Z_tmp_3 =  Z_R12;\n+constexpr Register Z_tmp_4 =  Z_R13;\n@@ -572,9 +447,3 @@\n-REGISTER_DECLARATION(Register, Z_R0_scratch, Z_R0);\n-REGISTER_DECLARATION(Register, Z_R1_scratch, Z_R1);\n-REGISTER_DECLARATION(FloatRegister, Z_fscratch_1, Z_F1);\n-#ifndef DONT_USE_REGISTER_DEFINES\n-#define Z_R0_scratch  AS_REGISTER(Register, Z_R0)\n-#define Z_R1_scratch  AS_REGISTER(Register, Z_R1)\n-#define Z_fscratch_1  AS_REGISTER(FloatRegister, Z_F1)\n-#endif\n-\n+constexpr Register      Z_R0_scratch = Z_R0;\n+constexpr Register      Z_R1_scratch = Z_R1;\n+constexpr FloatRegister Z_fscratch_1 = Z_F1;\n","filename":"src\/hotspot\/cpu\/s390\/register_s390.hpp","additions":224,"deletions":355,"binary":false,"changes":579,"status":"modified"},{"patch":"@@ -635,1 +635,1 @@\n-\/\/ up to RegisterImpl::number_of_registers are the 64-bit integer registers.\n+\/\/ up to Register::number_of_registers are the 64-bit integer registers.\n@@ -671,2 +671,2 @@\n-  assert(RegisterImpl::number_of_arg_registers == z_num_iarg_registers, \"iarg reg count mismatch\");\n-  assert(FloatRegisterImpl::number_of_arg_registers == z_num_farg_registers, \"farg reg count mismatch\");\n+  assert(Register::number_of_arg_registers == z_num_iarg_registers, \"iarg reg count mismatch\");\n+  assert(FloatRegister::number_of_arg_registers == z_num_farg_registers, \"farg reg count mismatch\");\n@@ -785,2 +785,2 @@\n-  assert(RegisterImpl::number_of_arg_registers == z_num_iarg_registers, \"iarg reg count mismatch\");\n-  assert(FloatRegisterImpl::number_of_arg_registers == z_num_farg_registers, \"farg reg count mismatch\");\n+  assert(Register::number_of_arg_registers == z_num_iarg_registers, \"iarg reg count mismatch\");\n+  assert(FloatRegister::number_of_arg_registers == z_num_farg_registers, \"farg reg count mismatch\");\n@@ -1464,1 +1464,1 @@\n-  int total_save_slots = RegisterImpl::number_of_arg_registers * VMRegImpl::slots_per_word;\n+  int total_save_slots = Register::number_of_arg_registers * VMRegImpl::slots_per_word;\n@@ -1595,3 +1595,3 @@\n-  bool reg_destroyed[RegisterImpl::number_of_registers];\n-  bool freg_destroyed[FloatRegisterImpl::number_of_registers];\n-  for (int r = 0; r < RegisterImpl::number_of_registers; r++) {\n+  bool reg_destroyed[Register::number_of_registers];\n+  bool freg_destroyed[FloatRegister::number_of_registers];\n+  for (int r = 0; r < Register::number_of_registers; r++) {\n@@ -1600,1 +1600,1 @@\n-  for (int f = 0; f < FloatRegisterImpl::number_of_registers; f++) {\n+  for (int f = 0; f < FloatRegister::number_of_registers; f++) {\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -29,4 +29,1 @@\n-inline VMReg RegisterImpl::as_VMReg() {\n-  if (this == noreg) {\n-    return VMRegImpl::Bad();\n-  }\n+inline VMReg Register::as_VMReg() const {\n@@ -36,1 +33,1 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() {\n+inline VMReg FloatRegister::as_VMReg() const {\n@@ -40,1 +37,1 @@\n-inline VMReg ConditionRegisterImpl::as_VMReg() {\n+inline VMReg ConditionRegister::as_VMReg() const {\n","filename":"src\/hotspot\/cpu\/s390\/vmreg_s390.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"}]}