{"files":[{"patch":"@@ -102,0 +102,22 @@\n+    \/**\n+     * {@return if present, a label identifying the connection on which the\n+     * response was received}\n+     * <p>\n+     * The format of the string is opaque, but the value is fixed and unique\n+     * for any connection in the scope of the associated {@link HttpClient}\n+     * instance.\n+     *\n+     * @implSpec\n+     * The default implementation of this method returns\n+     * {@link Optional#empty() Optional.empty()}.\n+     *\n+     * @implNote\n+     * Instances of {@code HttpResponse} returned by the JDK built-in\n+     * implementation of {@code HttpClient} always return a non-empty value.\n+     *\n+     * @since 25\n+     *\/\n+    default Optional<String> connectionLabel() {\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpResponse.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -77,2 +77,3 @@\n-                               String[] alpn) {\n-        super(addr, client);\n+                               String[] alpn,\n+                               String label) {\n+        super(addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AbstractAsyncSSLConnection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,3 +47,4 @@\n-                       String[] alpn) {\n-        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn);\n-        plainConnection = new PlainHttpConnection(addr, client);\n+                       String[] alpn,\n+                       String label) {\n+        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n+        plainConnection = new PlainHttpConnection(addr, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLConnection.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-                             ProxyHeaders proxyHeaders)\n+                             ProxyHeaders proxyHeaders,\n+                             String label)\n@@ -52,2 +53,2 @@\n-        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn);\n-        this.plainConnection = new PlainTunnelingConnection(addr, proxy, client, proxyHeaders);\n+        super(addr, client, Utils.getServerName(addr), addr.getPort(), alpn, label);\n+        this.plainConnection = new PlainTunnelingConnection(addr, proxy, client, proxyHeaders, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AsyncSSLTunnelConnection.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.net.http.HttpResponse;\n@@ -42,0 +43,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -79,0 +81,2 @@\n+    private static final AtomicLong LABEL_COUNTER = new AtomicLong();\n+\n@@ -83,0 +87,4 @@\n+\n+    \/**\n+     * A unique identifier that provides a total order among instances.\n+     *\/\n@@ -85,1 +93,11 @@\n-    HttpConnection(InetSocketAddress address, HttpClientImpl client) {\n+    \/**\n+     * A label to identify the connection.\n+     * <p>\n+     * This label helps with associating multiple components participating in a\n+     * connection. For instance, an {@link AsyncSSLConnection} and the\n+     * {@link PlainHttpConnection} it wraps will share the same label.\n+     * <\/p>\n+     *\/\n+    private final String label;\n+\n+    HttpConnection(InetSocketAddress address, HttpClientImpl client, String label) {\n@@ -90,0 +108,13 @@\n+        this.label = label;\n+    }\n+\n+    private static String nextLabel() {\n+        return \"\" + LABEL_COUNTER.incrementAndGet();\n+    }\n+\n+    \/**\n+     * {@return a label identifying the connection to facilitate\n+     * {@link HttpResponse#connectionLabel() HttpResponse::connectionLabel}}\n+     *\/\n+    public final String label() {\n+        return label;\n@@ -306,0 +337,1 @@\n+        String label = nextLabel();\n@@ -308,1 +340,2 @@\n-                                                proxyTunnelHeaders(request));\n+                                                proxyTunnelHeaders(request),\n+                                                label);\n@@ -310,1 +343,1 @@\n-            return new AsyncSSLConnection(addr, client, alpn);\n+            return new AsyncSSLConnection(addr, client, alpn, label);\n@@ -384,0 +417,1 @@\n+        String label = nextLabel();\n@@ -386,1 +420,2 @@\n-                                                proxyTunnelHeaders(request));\n+                                                proxyTunnelHeaders(request),\n+                                                label);\n@@ -389,1 +424,1 @@\n-            return new PlainHttpConnection(addr, client);\n+            return new PlainHttpConnection(addr, client, label);\n@@ -391,1 +426,1 @@\n-            return new PlainProxyConnection(proxy, client);\n+            return new PlainProxyConnection(proxy, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    private final String connectionLabel;\n@@ -62,0 +63,1 @@\n+        this.connectionLabel = connectionLabel(exch).orElse(null);\n@@ -73,0 +75,7 @@\n+    private static Optional<String> connectionLabel(Exchange<?> exchange) {\n+        return Optional.ofNullable(exchange)\n+                .map(e -> e.exchImpl)\n+                .map(ExchangeImpl::connection)\n+                .map(HttpConnection::label);\n+    }\n+\n@@ -78,0 +87,5 @@\n+    @Override\n+    public Optional<String> connectionLabel() {\n+        return Optional.ofNullable(connectionLabel);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpResponseImpl.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -313,2 +313,2 @@\n-    PlainHttpConnection(InetSocketAddress addr, HttpClientImpl client) {\n-        super(addr, client);\n+    PlainHttpConnection(InetSocketAddress addr, HttpClientImpl client, String label) {\n+        super(addr, client, label);\n@@ -338,1 +338,1 @@\n-            tube = new SocketTube(client(), chan, Utils::getBuffer);\n+            tube = new SocketTube(client(), chan, Utils::getBuffer, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-    PlainProxyConnection(InetSocketAddress proxy, HttpClientImpl client) {\n-        super(proxy, client);\n+    PlainProxyConnection(InetSocketAddress proxy, HttpClientImpl client, String label) {\n+        super(proxy, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainProxyConnection.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,3 @@\n-                                       ProxyHeaders proxyHeaders) {\n-        super(addr, client);\n+                                       ProxyHeaders proxyHeaders,\n+                                       String label) {\n+        super(addr, client, label);\n@@ -61,1 +62,1 @@\n-        delegate = new PlainHttpConnection(proxy, client);\n+        delegate = new PlainHttpConnection(proxy, client, label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.util.concurrent.atomic.AtomicLong;\n@@ -62,1 +61,0 @@\n-    static final AtomicLong IDS = new AtomicLong();\n@@ -71,1 +69,1 @@\n-    private final long id = IDS.incrementAndGet();\n+    private final String connectionLabel;\n@@ -74,1 +72,2 @@\n-                      Supplier<ByteBuffer> buffersFactory) {\n+                      Supplier<ByteBuffer> buffersFactory,\n+                      String connectionLabel) {\n@@ -78,1 +77,1 @@\n-\n+        this.connectionLabel = connectionLabel;\n@@ -1346,1 +1345,1 @@\n-        return \"SocketTube(\"+id+\")\";\n+        return \"SocketTube(\"+ connectionLabel +\")\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,444 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies `HttpResponse::connectionLabel`\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ *\n+ * @comment `othervm` usage is intentional since this test uses `ForkJoinPool.commonPool()`\n+ * @comment Use a higher idle timeout to increase the chances of the same connection being used for sequential HTTP requests\n+ * @run junit\/othervm -Djdk.httpclient.keepalive.timeout=120 HttpResponseConnectionLabelTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.Charset;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+class HttpResponseConnectionLabelTest {\n+\n+    private static final Logger LOGGER =\n+            Utils.getDebugLogger(HttpResponseConnectionLabelTest.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    private static final Charset CHARSET = US_ASCII;\n+\n+    private static final String CONNECTION_KEY_HEADER_NAME = \"X-Connection-Key\";\n+\n+    private static final String SERVER_ID_HEADER_NAME = \"X-Server-Id\";\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    \/\/ Start with a fresh client having no connections in the pool\n+    private final HttpClient client = HttpClient.newBuilder().sslContext(SSL_CONTEXT).proxy(NO_PROXY).build();\n+\n+    \/\/ Primary server-client pairs\n+\n+    private static final ServerRequestPair PRI_HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false);\n+\n+    private static final ServerRequestPair PRI_HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true);\n+\n+    private static final ServerRequestPair PRI_HTTP2 = ServerRequestPair.of(Version.HTTP_2, false);\n+\n+    private static final ServerRequestPair PRI_HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    \/\/ Secondary server-client pairs\n+\n+    private static final ServerRequestPair SEC_HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false);\n+\n+    private static final ServerRequestPair SEC_HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true);\n+\n+    private static final ServerRequestPair SEC_HTTP2 = ServerRequestPair.of(Version.HTTP_2, false);\n+\n+    private static final ServerRequestPair SEC_HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private record ServerRequestPair(\n+            HttpTestServer server,\n+            HttpRequest request,\n+            boolean secure,\n+            CountDownLatch[] serverResponseLatchRef) {\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        private static final AtomicInteger SERVER_RESPONSE_COUNTER = new AtomicInteger();\n+\n+        private ServerRequestPair {\n+            try {\n+                server.start();\n+            } catch (Exception serverException) {\n+                throw new RuntimeException(\"failed closing server\", serverException);\n+            }\n+        }\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String handlerPath = \"\/\" + \/* salting the path: *\/ HttpResponseConnectionLabelTest.class.getSimpleName();\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            URI requestUri = URI.create(requestUriScheme + \":\/\/\" + server.serverAuthority() + handlerPath);\n+\n+            \/\/ Register the request handler\n+            String serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            CountDownLatch[] serverResponseLatchRef = new CountDownLatch[1];\n+            server.addHandler(\n+                    (exchange) -> {\n+                        String responseBody = \"\" + SERVER_RESPONSE_COUNTER.getAndIncrement();\n+                        String connectionKey = exchange.getConnectionKey();\n+                        try (exchange) {\n+\n+                            \/\/ Participate in the latch count down\n+                            if (serverResponseLatchRef[0] != null) {\n+                                serverResponseLatchRef[0].countDown();\n+                                LOGGER.log(\n+                                        \"Server[%s] is waiting for the latch... (connectionKey=%s, responseBody=%s)\",\n+                                        serverId, connectionKey, responseBody);\n+                                serverResponseLatchRef[0].await();\n+                            }\n+\n+                            \/\/ Write the response\n+                            LOGGER.log(\n+                                    \"Server[%s] is responding... (connectionKey=%s, responseBody=%s)\",\n+                                    serverId, connectionKey, responseBody);\n+                            exchange.getResponseHeaders().addHeader(CONNECTION_KEY_HEADER_NAME, connectionKey);\n+                            exchange.getResponseHeaders().addHeader(SERVER_ID_HEADER_NAME, serverId);\n+                            byte[] responseBodyBytes = responseBody.getBytes(CHARSET);\n+                            exchange.sendResponseHeaders(200, responseBodyBytes.length);\n+                            exchange.getResponseBody().write(responseBodyBytes);\n+\n+                        } catch (IOException ioe) {\n+                            String message = \"Server[%s] has failed! (connectionKey=%s, responseBody=%s)\"\n+                                    .formatted(serverId, connectionKey, responseBody);\n+                            throw new RuntimeException(message, ioe);\n+                        } catch (InterruptedException _) {\n+                            Thread.currentThread().interrupt(); \/\/ Restore the interrupt\n+                        }\n+                    },\n+                    handlerPath);\n+\n+            \/\/ Create the client and the request\n+            HttpRequest request = HttpRequest.newBuilder(requestUri).version(version).build();\n+\n+            \/\/ Create the pair\n+            return new ServerRequestPair(server, request, secure, serverResponseLatchRef);\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                return HttpTestServer.create(version, sslContext, ForkJoinPool.commonPool());\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String version = server.getVersion().toString();\n+            return secure ? version.replaceFirst(\"_\", \"S_\") : version;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void closeServers() {\n+        Exception[] exceptionRef = {null};\n+        Stream\n+                .of(PRI_HTTP1, PRI_HTTPS1, PRI_HTTP2, PRI_HTTPS2, SEC_HTTP1, SEC_HTTPS1, SEC_HTTP2, SEC_HTTPS2)\n+                .forEach(pair -> {\n+                    try {\n+                        pair.server.stop();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server-request pairs\", exceptionRef[0]);\n+        }\n+    }\n+\n+    @AfterEach\n+    void closeClient() {\n+        client.close();\n+    }\n+\n+    static ServerRequestPair[] testParallelRequestsToSameServer() {\n+        return new ServerRequestPair[]{\n+                PRI_HTTP1,\n+                PRI_HTTPS1,\n+                PRI_HTTP2,\n+                PRI_HTTPS2\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testParallelRequestsToSameServer\")\n+    void testParallelRequestsToSameServer(ServerRequestPair pair) throws Exception {\n+\n+        \/\/ There is no implementation-agnostic reliable way to force admission\n+        \/\/ of multiple connections targeting the same server to an HTTP\/2 pool.\n+        if (Version.HTTP_2.equals(pair.server.getVersion())) {\n+            return;\n+        }\n+\n+        \/\/ Configure a synchronization point for 4 events:\n+        \/\/\n+        \/\/ 1. client --(req1)--> server\n+        \/\/ 2. server --(res1)--> client\n+        \/\/ 3. client --(req2)--> server\n+        \/\/ 4. server --(res2)--> client\n+        \/\/\n+        \/\/ This effectively will ensure:\n+        \/\/\n+        \/\/ - Server waits for the rendezvous before responding.\n+        \/\/   Hence, client won't be able to reuse the connection, but create a new one.\n+        \/\/\n+        \/\/ - Client waits for the rendezvous before consuming responses.\n+        CountDownLatch latch = pair.serverResponseLatchRef[0] = new CountDownLatch(4);\n+\n+        \/\/ Fire requests\n+        LOGGER.log(\"Firing request 1...\");\n+        CompletableFuture<HttpResponse<String>> response1Future =\n+                client.sendAsync(pair.request, BodyHandlers.ofString(CHARSET));\n+        LOGGER.log(\"Firing request 2...\");\n+        CompletableFuture<HttpResponse<String>> response2Future =\n+                client.sendAsync(pair.request, BodyHandlers.ofString(CHARSET));\n+\n+        \/\/ Release latches to allow the server handlers to proceed\n+        latch.countDown();\n+        latch.countDown();\n+\n+        \/\/ Wait for all parties to be ready\n+        LOGGER.log(\"Client is waiting for the latch...\");\n+        latch.await();\n+        LOGGER.log(\"Client is continuing...\");\n+\n+        \/\/ Collect responses\n+        HttpResponse<String> response1 = response1Future.get();\n+        HttpResponse<String> response2 = response2Future.get();\n+\n+        \/\/ Verify successful responses\n+        assertEquals(200, response1.statusCode());\n+        assertEquals(200, response2.statusCode());\n+\n+        \/\/ Verify that connection keys differ; that is, requests are served through different connections\n+        String connectionKey1 = response1.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        String connectionKey2 = response2.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        assertNotEquals(connectionKey1, connectionKey2);\n+\n+        \/\/ Verify that server IDs match; that is, both requests targeted the same server.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int serverId1 = Integer.parseInt(response1.headers().firstValue(SERVER_ID_HEADER_NAME).get());\n+        int serverId2 = Integer.parseInt(response2.headers().firstValue(SERVER_ID_HEADER_NAME).get());\n+        assertEquals(serverId1, serverId2);\n+\n+        \/\/ Verify that response bodies differ.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int body1 = Integer.parseInt(response1.body());\n+        int body2 = Integer.parseInt(response2.body());\n+        assertNotEquals(body1, body2);\n+\n+        \/\/ Verify that connection labels differ; that is, requests are served through different connections\n+        String label1 = response1.connectionLabel().orElse(null);\n+        assertNotNull(label1);\n+        LOGGER.log(\"connection label 1: %s\", label1);\n+        String label2 = response2.connectionLabel().orElse(null);\n+        assertNotNull(label2);\n+        LOGGER.log(\"connection label 2: %s\", label2);\n+        assertNotEquals(label1, label2);\n+\n+    }\n+\n+    static Stream<Arguments> testParallelRequestsToDifferentServers() {\n+        return Stream\n+                .of(PRI_HTTP1, PRI_HTTPS1, PRI_HTTP2, PRI_HTTPS2)\n+                .flatMap(source -> Stream\n+                        .of(SEC_HTTP1, SEC_HTTPS1, SEC_HTTP2, SEC_HTTPS2)\n+                        .map(target -> Arguments.of(source, target)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testParallelRequestsToDifferentServers\")\n+    void testParallelRequestsToDifferentServers(ServerRequestPair pair1, ServerRequestPair pair2) throws Exception {\n+\n+        \/\/ Configure a synchronization point for 4 events:\n+        \/\/\n+        \/\/ 1. client  --> server1\n+        \/\/ 2. server1 --> client\n+        \/\/ 3. client  --> server2\n+        \/\/ 4. server2 --> client\n+        \/\/\n+        \/\/ This effectively will ensure:\n+        \/\/\n+        \/\/ - Server waits for the rendezvous before responding.\n+        \/\/   Hence, client won't be able to reuse the connection, but create a new one.\n+        \/\/\n+        \/\/ - Client waits for the rendezvous before consuming responses.\n+        CountDownLatch latch = pair1.serverResponseLatchRef[0] = pair2.serverResponseLatchRef[0] = new CountDownLatch(4);\n+\n+        \/\/ Fire requests\n+        LOGGER.log(\"Firing request 1...\");\n+        CompletableFuture<HttpResponse<String>> response1Future =\n+                client.sendAsync(pair1.request, BodyHandlers.ofString(CHARSET));\n+        LOGGER.log(\"Firing request 2...\");\n+        CompletableFuture<HttpResponse<String>> response2Future =\n+                client.sendAsync(pair2.request, BodyHandlers.ofString(CHARSET));\n+\n+        \/\/ Release latches to allow the server handlers to proceed\n+        latch.countDown();\n+        latch.countDown();\n+\n+        \/\/ Wait for all parties to be ready\n+        LOGGER.log(\"Client is waiting for the latch...\");\n+        latch.await();\n+        LOGGER.log(\"Client is continuing...\");\n+\n+        \/\/ Collect responses\n+        HttpResponse<String> response1 = response1Future.get();\n+        HttpResponse<String> response2 = response2Future.get();\n+\n+        \/\/ Verify successful responses\n+        assertEquals(200, response1.statusCode());\n+        assertEquals(200, response2.statusCode());\n+\n+        \/\/ Verify that connection keys differ; that is, requests are served through different connections\n+        String connectionKey1 = response1.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        String connectionKey2 = response2.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        assertNotEquals(connectionKey1, connectionKey2);\n+\n+        \/\/ Verify that server IDs differ.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int serverId1 = response1.headers().firstValue(SERVER_ID_HEADER_NAME).map(Integer::parseInt).get();\n+        int serverId2 = response2.headers().firstValue(SERVER_ID_HEADER_NAME).map(Integer::parseInt).get();\n+        assertNotEquals(serverId1, serverId2);\n+\n+        \/\/ Verify that response bodies differ.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int body1 = Integer.parseInt(response1.body());\n+        int body2 = Integer.parseInt(response2.body());\n+        assertNotEquals(body1, body2);\n+\n+        \/\/ Verify that connection labels differ; that is, requests are served through different connections\n+        String label1 = response1.connectionLabel().orElse(null);\n+        assertNotNull(label1);\n+        LOGGER.log(\"connection label 1: %s\", label1);\n+        String label2 = response2.connectionLabel().orElse(null);\n+        assertNotNull(label2);\n+        LOGGER.log(\"connection label 2: %s\", label2);\n+        assertNotEquals(label1, label2);\n+\n+    }\n+\n+    static Stream<ServerRequestPair> testSerialRequestsToSameServer() {\n+        return Stream.of(PRI_HTTP1, PRI_HTTPS1, PRI_HTTP2, PRI_HTTPS2);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testSerialRequestsToSameServer\")\n+    void testSerialRequestsToSameServer(ServerRequestPair pair) throws Exception {\n+\n+        \/\/ Disarm the synchronization point\n+        pair.serverResponseLatchRef[0] = null;\n+\n+        \/\/ Fire requests\n+        LOGGER.log(\"Firing request 1...\");\n+        HttpResponse<String> response1 = client.send(pair.request, BodyHandlers.ofString(CHARSET));\n+        LOGGER.log(\"Firing request 2...\");\n+        HttpResponse<String> response2 = client.send(pair.request, BodyHandlers.ofString(CHARSET));\n+\n+        \/\/ Verify successful responses\n+        assertEquals(200, response1.statusCode());\n+        assertEquals(200, response2.statusCode());\n+\n+        \/\/ Verify that connection keys match; that is, requests are served through the same connection\n+        String connectionKey1 = response1.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        String connectionKey2 = response2.headers().firstValue(CONNECTION_KEY_HEADER_NAME).get();\n+        assertEquals(connectionKey1, connectionKey2);\n+\n+        \/\/ Verify that server IDs match.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int serverId1 = response1.headers().firstValue(SERVER_ID_HEADER_NAME).map(Integer::parseInt).get();\n+        int serverId2 = response2.headers().firstValue(SERVER_ID_HEADER_NAME).map(Integer::parseInt).get();\n+        assertEquals(serverId1, serverId2);\n+\n+        \/\/ Verify that response bodies differ.\n+        \/\/ (Using `parseInt` to validate the content.)\n+        int body1 = Integer.parseInt(response1.body());\n+        int body2 = Integer.parseInt(response2.body());\n+        assertNotEquals(body1, body2);\n+\n+        \/\/ Verify that connection labels match; that is, requests are served through the same connection\n+        String label1 = response1.connectionLabel().orElse(null);\n+        assertNotNull(label1);\n+        LOGGER.log(\"connection label 1: %s\", label1);\n+        String label2 = response2.connectionLabel().orElse(null);\n+        assertNotNull(label2);\n+        LOGGER.log(\"connection label 2: %s\", label2);\n+        assertEquals(label1, label2);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseConnectionLabelTest.java","additions":444,"deletions":0,"binary":false,"changes":444,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -462,1 +462,1 @@\n-            super(address, impl);\n+            super(address, impl, \"testConn-\" + IDS.incrementAndGet());\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}