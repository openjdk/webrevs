{"files":[{"patch":"@@ -31,0 +31,1 @@\n+ *        SystemDiagnosticsCollector\n@@ -32,1 +33,0 @@\n- * @comment `othervm` usage is intentional since this test uses `ForkJoinPool.commonPool()`\n@@ -37,0 +37,2 @@\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n@@ -50,0 +52,1 @@\n+import java.lang.System.Logger.Level;\n@@ -57,0 +60,1 @@\n+import java.time.Duration;\n@@ -59,1 +63,2 @@\n-import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -61,0 +66,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -71,2 +77,15 @@\n-    private static final Logger LOGGER =\n-            Utils.getDebugLogger(HttpResponseConnectionLabelTest.class.getSimpleName()::toString, Utils.DEBUG);\n+    private static final boolean DIAGNOSTICS_ENABLED = false;\n+\n+    static {\n+        if (DIAGNOSTICS_ENABLED) {\n+            HttpServerAdapters.enableServerLogging();\n+        }\n+    }\n+\n+    private static final SystemDiagnosticsCollector DIAGNOSTICS_COLLECTOR = DIAGNOSTICS_ENABLED\n+            ? new SystemDiagnosticsCollector(HttpResponseConnectionLabelTest.class, Duration.ofSeconds(5))\n+            : null;\n+\n+    private static final String CLASS_NAME = HttpResponseConnectionLabelTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n@@ -115,0 +134,1 @@\n+            ExecutorService executor,\n@@ -117,1 +137,1 @@\n-            CountDownLatch[] serverResponseLatchRef) {\n+            AtomicReference<CountDownLatch> serverResponseLatchRef) {\n@@ -123,8 +143,0 @@\n-        private ServerRequestPair {\n-            try {\n-                server.start();\n-            } catch (Exception serverException) {\n-                throw new RuntimeException(\"failed closing server\", serverException);\n-            }\n-        }\n-\n@@ -135,2 +147,4 @@\n-            HttpTestServer server = createServer(version, sslContext);\n-            String handlerPath = \"\/\" + \/* salting the path: *\/ HttpResponseConnectionLabelTest.class.getSimpleName();\n+            String serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            ExecutorService[] executorRef = {null};\n+            HttpTestServer server = createServer(version, secure, sslContext, serverId, executorRef);\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n@@ -138,1 +152,1 @@\n-            URI requestUri = URI.create(requestUriScheme + \":\/\/\" + server.serverAuthority() + handlerPath);\n+            URI requestUri = URI.create(\"%s:\/\/%s%sx\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n@@ -141,36 +155,2 @@\n-            String serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n-            CountDownLatch[] serverResponseLatchRef = new CountDownLatch[1];\n-            server.addHandler(\n-                    (exchange) -> {\n-                        String responseBody = \"\" + SERVER_RESPONSE_COUNTER.getAndIncrement();\n-                        String connectionKey = exchange.getConnectionKey();\n-                        try (exchange) {\n-\n-                            \/\/ Participate in the latch count down\n-                            if (serverResponseLatchRef[0] != null) {\n-                                serverResponseLatchRef[0].countDown();\n-                                LOGGER.log(\n-                                        \"Server[%s] is waiting for the latch... (connectionKey=%s, responseBody=%s)\",\n-                                        serverId, connectionKey, responseBody);\n-                                serverResponseLatchRef[0].await();\n-                            }\n-\n-                            \/\/ Write the response\n-                            LOGGER.log(\n-                                    \"Server[%s] is responding... (connectionKey=%s, responseBody=%s)\",\n-                                    serverId, connectionKey, responseBody);\n-                            exchange.getResponseHeaders().addHeader(CONNECTION_KEY_HEADER_NAME, connectionKey);\n-                            exchange.getResponseHeaders().addHeader(SERVER_ID_HEADER_NAME, serverId);\n-                            byte[] responseBodyBytes = responseBody.getBytes(CHARSET);\n-                            exchange.sendResponseHeaders(200, responseBodyBytes.length);\n-                            exchange.getResponseBody().write(responseBodyBytes);\n-\n-                        } catch (IOException ioe) {\n-                            String message = \"Server[%s] has failed! (connectionKey=%s, responseBody=%s)\"\n-                                    .formatted(serverId, connectionKey, responseBody);\n-                            throw new RuntimeException(message, ioe);\n-                        } catch (InterruptedException _) {\n-                            Thread.currentThread().interrupt(); \/\/ Restore the interrupt\n-                        }\n-                    },\n-                    handlerPath);\n+            AtomicReference<CountDownLatch> serverResponseLatchRef = new AtomicReference<>();\n+            server.addHandler(createServerHandler(serverId, serverResponseLatchRef), handlerPath);\n@@ -182,1 +162,9 @@\n-            return new ServerRequestPair(server, request, secure, serverResponseLatchRef);\n+            ServerRequestPair pair = new ServerRequestPair(\n+                    server,\n+                    executorRef[0],\n+                    request,\n+                    secure,\n+                    serverResponseLatchRef);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n@@ -186,1 +174,6 @@\n-        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+        private static HttpTestServer createServer(\n+                Version version,\n+                boolean secure,\n+                SSLContext sslContext,\n+                String serverId,\n+                ExecutorService[] executorRef) {\n@@ -188,1 +181,12 @@\n-                return HttpTestServer.create(version, sslContext, ForkJoinPool.commonPool());\n+                \/\/ Only create a dedicated executor for HTTP\/1.1, because\n+                \/\/\n+                \/\/ - Only the HTTP\/1.1 test server gets wedged when running\n+                \/\/   tests involving parallel request handling.\n+                \/\/\n+                \/\/ - The HTTP\/2 test server creates its own sufficiently sized\n+                \/\/   executor, and the thread names used there makes it easy to\n+                \/\/   find which server they belong to.\n+                executorRef[0] = Version.HTTP_1_1.equals(version)\n+                        ? createExecutor(version, secure, serverId)\n+                        : null;\n+                return HttpTestServer.create(version, sslContext, executorRef[0]);\n@@ -194,0 +198,52 @@\n+        private static ExecutorService createExecutor(Version version, boolean secure, String serverId) {\n+            return Executors.newThreadPerTaskExecutor(runnable -> {\n+                String name = \"%s-%s-%c-%s\".formatted(\n+                        CLASS_NAME, version, secure ? 's' : 'c', serverId);\n+                Thread thread = new Thread(runnable, name);\n+                thread.setDaemon(true);     \/\/ Avoid blocking the JVM exit\n+                return thread;\n+            });\n+        }\n+\n+        private static HttpTestHandler createServerHandler(\n+                String serverId,\n+                AtomicReference<CountDownLatch> serverResponseLatchRef) {\n+            return (exchange) -> {\n+                String responseBody = \"\" + SERVER_RESPONSE_COUNTER.getAndIncrement();\n+                String connectionKey = exchange.getConnectionKey();\n+                LOGGER.log(\"Server[%d] has received request (connectionKey=%s)\", serverId, connectionKey);\n+                try (exchange) {\n+\n+                    \/\/ Participate in the latch count down\n+                    CountDownLatch serverResponseLatch = serverResponseLatchRef.get();\n+                    if (serverResponseLatch != null) {\n+                        serverResponseLatch.countDown();\n+                        LOGGER.log(\n+                                \"Server[%s] is waiting for the latch... (connectionKey=%s, responseBody=%s)\",\n+                                serverId, connectionKey, responseBody);\n+                        serverResponseLatch.await();\n+                    }\n+\n+                    \/\/ Write the response\n+                    LOGGER.log(\n+                            \"Server[%s] is responding... (connectionKey=%s, responseBody=%s)\",\n+                            serverId, connectionKey, responseBody);\n+                    exchange.getResponseHeaders().addHeader(CONNECTION_KEY_HEADER_NAME, connectionKey);\n+                    exchange.getResponseHeaders().addHeader(SERVER_ID_HEADER_NAME, serverId);\n+                    byte[] responseBodyBytes = responseBody.getBytes(CHARSET);\n+                    exchange.sendResponseHeaders(200, responseBodyBytes.length);\n+                    exchange.getResponseBody().write(responseBodyBytes);\n+\n+                } catch (Exception exception) {\n+                    String message = \"Server[%s] has failed! (connectionKey=%s, responseBody=%s)\"\n+                            .formatted(serverId, connectionKey, responseBody);\n+                    LOGGER.log(Level.ERROR, message, exception);\n+                    if (exception instanceof InterruptedException) {\n+                        \/\/ Restore the interrupt\n+                        Thread.currentThread().interrupt();\n+                    }\n+                    throw new RuntimeException(message, exception);\n+                }\n+            };\n+        }\n+\n@@ -203,1 +259,6 @@\n-    static void closeServers() {\n+    static void closeResources() {\n+        closeServers();\n+        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.close(); }\n+    }\n+\n+    private static void closeServers() {\n@@ -207,1 +268,4 @@\n-                .forEach(pair -> {\n+                .flatMap(pair -> Stream.<Runnable>of(\n+                        pair.server::stop,\n+                        () -> { if (pair.executor != null) { pair.executor.shutdownNow(); } }))\n+                .forEach(terminator -> {\n@@ -209,1 +273,1 @@\n-                        pair.server.stop();\n+                        terminator.run();\n@@ -219,1 +283,1 @@\n-            throw new RuntimeException(\"failed closing one or more server-request pairs\", exceptionRef[0]);\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n@@ -260,1 +324,2 @@\n-        CountDownLatch latch = pair.serverResponseLatchRef[0] = new CountDownLatch(4);\n+        CountDownLatch latch = new CountDownLatch(4);\n+        pair.serverResponseLatchRef.set(latch);\n@@ -263,0 +328,1 @@\n+        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.dumpDiagnostics(); }\n@@ -271,0 +337,1 @@\n+        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.dumpDiagnostics(); }\n@@ -307,1 +374,1 @@\n-        LOGGER.log(\"connection label 1: %s\", label1);\n+        LOGGER.log(\"Connection label 1: %s\", label1);\n@@ -310,1 +377,1 @@\n-        LOGGER.log(\"connection label 2: %s\", label2);\n+        LOGGER.log(\"Connection label 2: %s\", label2);\n@@ -340,1 +407,3 @@\n-        CountDownLatch latch = pair1.serverResponseLatchRef[0] = pair2.serverResponseLatchRef[0] = new CountDownLatch(4);\n+        CountDownLatch latch = new CountDownLatch(4);\n+        pair1.serverResponseLatchRef.set(latch);\n+        pair2.serverResponseLatchRef.set(latch);\n@@ -387,1 +456,1 @@\n-        LOGGER.log(\"connection label 1: %s\", label1);\n+        LOGGER.log(\"Connection label 1: %s\", label1);\n@@ -390,1 +459,1 @@\n-        LOGGER.log(\"connection label 2: %s\", label2);\n+        LOGGER.log(\"Connection label 2: %s\", label2);\n@@ -404,1 +473,1 @@\n-        pair.serverResponseLatchRef[0] = null;\n+        pair.serverResponseLatchRef.set(null);\n@@ -436,1 +505,1 @@\n-        LOGGER.log(\"connection label 1: %s\", label1);\n+        LOGGER.log(\"Connection label 1: %s\", label1);\n@@ -439,1 +508,1 @@\n-        LOGGER.log(\"connection label 2: %s\", label2);\n+        LOGGER.log(\"Connection label 2: %s\", label2);\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseConnectionLabelTest.java","additions":137,"deletions":68,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.lang.management.ManagementFactory;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.stream.Stream;\n+\n+import static java.lang.System.Logger.Level.ERROR;\n+import static java.lang.System.Logger.Level.TRACE;\n+\n+\/**\n+ * A troubleshooting utility to continuously collect system's network and thread dump information.\n+ *\/\n+public final class SystemDiagnosticsCollector implements AutoCloseable {\n+\n+    private static final Logger LOGGER =\n+            Utils.getDebugLogger(SystemDiagnosticsCollector.class.getSimpleName()::toString, Utils.DEBUG);\n+\n+    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();\n+\n+    private static final String[] NETSTAT_COMMAND = findOsSpecificNetstatCommand();\n+\n+    private static String[] findOsSpecificNetstatCommand() {\n+        return Stream\n+                .of(\n+                        new String[]{\"netstat\", \"-an\"},\n+                        new String[]{\"lsof\", \"-nPi\"})\n+                .filter(SystemDiagnosticsCollector::commandSucceeds)\n+                .findFirst()\n+                .orElseGet(() -> {\n+                    LOGGER.log(ERROR, \"failed to find a command to collect system's network information\");\n+                    return null;\n+                });\n+    }\n+\n+    private static boolean commandSucceeds(String[] command) {\n+        try {\n+            LOGGER.log(TRACE, \"checking for command: %s\", Arrays.asList(command));\n+            int exitStatus = new ProcessBuilder(command)\n+                    .redirectErrorStream(true)\n+                    .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n+                    .start()\n+                    .waitFor();\n+            return exitStatus == 0;\n+        } catch (InterruptedException _) {\n+            Thread.currentThread().interrupt();     \/\/ Restore the interrupt\n+            return false;\n+        } catch (IOException _) {\n+            return false;\n+        }\n+    }\n+\n+    private final Logger logger;\n+\n+    private final Duration pollDuration;\n+\n+    private final Thread thread;\n+\n+    private volatile boolean running = true;\n+\n+    public SystemDiagnosticsCollector(Class<?> clazz, Duration pollDuration) {\n+        String className = clazz.getSimpleName();\n+        this.logger = Utils.getDebugLogger(className::toString, Utils.DEBUG);\n+        this.pollDuration = pollDuration;\n+        this.thread = startThread(className);\n+    }\n+\n+    private Thread startThread(String className) {\n+        String threadName = \"%s-%s-%d\".formatted(\n+                SystemDiagnosticsCollector.class.getSimpleName(),\n+                className,\n+                INSTANCE_COUNTER.incrementAndGet());\n+        Thread thread = new Thread(this::dumpDiagnosticsContinuously, threadName);\n+        thread.setDaemon(true);    \/\/ Avoid blocking JVM exit\n+        thread.start();\n+        return thread;\n+    }\n+\n+    private void dumpDiagnosticsContinuously() {\n+        logger.log(\"starting diagnostics collector\");\n+        while (running) {\n+            try {\n+                dumpDiagnostics();\n+                LockSupport.parkNanos(pollDuration.toNanos());\n+            } catch (Exception exception) {\n+                logger.log(ERROR, \"diagnostics collection has failed\", exception);\n+                if (exception instanceof InterruptedException) {\n+                    Thread.currentThread().interrupt();     \/\/ Restore the interrupt\n+                    if (running) {\n+                        logger.log(\"stopping diagnostics collector due to unexpected interrupt\", exception);\n+                    }\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void dumpDiagnostics() throws IOException, InterruptedException {\n+        String fileNameTimestamp = Instant.now().toString().replaceAll(\"[-:]\", \"\");\n+        logger.log(\"dumping diagnostics... (fileNameTimestamp=%s)\", fileNameTimestamp);\n+        dumpNetwork(fileNameTimestamp);\n+        dumpThreads(fileNameTimestamp);\n+    }\n+\n+    private void dumpNetwork(String fileNameTimestamp) throws IOException, InterruptedException {\n+        if (NETSTAT_COMMAND == null) {\n+            return;\n+        }\n+        Path path = createPath(\"dump-%s-net.txt\", fileNameTimestamp);\n+        new ProcessBuilder(NETSTAT_COMMAND)\n+                .redirectOutput(path.toFile())\n+                .redirectErrorStream(true)\n+                .start()\n+                .waitFor();\n+    }\n+\n+    private static void dumpThreads(String fileNameTimestamp) throws IOException {\n+        Path path = createPath(\"dump-%s-thread.txt\", fileNameTimestamp);\n+        try (Writer writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8)) {\n+            Arrays\n+                    .stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n+                    .forEach(threadInfo -> {\n+                        try {\n+                            writer.write(threadInfo.toString());\n+                        } catch (IOException ioe) {\n+                            String message = \"failed dumping threads to `%s`\".formatted(path);\n+                            new RuntimeException(message, ioe).printStackTrace(System.err);\n+                        }\n+                    });\n+        }\n+    }\n+\n+    private static Path createPath(String fileNameFormatPattern, Object... fileNameFormatArgs) {\n+        String fileName = fileNameFormatPattern.formatted(fileNameFormatArgs);\n+        \/\/ Using `Path.of(\".\")` to ensure that the created files will be packaged as a part of test results\n+        return Path.of(\".\").resolve(fileName);\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+        if (running) {\n+            running = false;\n+            thread.interrupt();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/SystemDiagnosticsCollector.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"}]}