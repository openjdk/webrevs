{"files":[{"patch":"@@ -31,1 +31,0 @@\n- *        SystemDiagnosticsCollector\n@@ -37,1 +36,0 @@\n-import jdk.httpclient.test.lib.common.HttpServerAdapters;\n@@ -60,1 +58,0 @@\n-import java.time.Duration;\n@@ -77,12 +74,0 @@\n-    private static final boolean DIAGNOSTICS_ENABLED = false;\n-\n-    static {\n-        if (DIAGNOSTICS_ENABLED) {\n-            HttpServerAdapters.enableServerLogging();\n-        }\n-    }\n-\n-    private static final SystemDiagnosticsCollector DIAGNOSTICS_COLLECTOR = DIAGNOSTICS_ENABLED\n-            ? new SystemDiagnosticsCollector(HttpResponseConnectionLabelTest.class, Duration.ofSeconds(5))\n-            : null;\n-\n@@ -259,6 +244,1 @@\n-    static void closeResources() {\n-        closeServers();\n-        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.close(); }\n-    }\n-\n-    private static void closeServers() {\n+    static void closeServers() {\n@@ -328,1 +308,0 @@\n-        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.dumpDiagnostics(); }\n@@ -337,1 +316,0 @@\n-        if (DIAGNOSTICS_ENABLED) { DIAGNOSTICS_COLLECTOR.dumpDiagnostics(); }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpResponseConnectionLabelTest.java","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.internal.net.http.common.Logger;\n-import jdk.internal.net.http.common.Utils;\n-\n-import java.io.IOException;\n-import java.io.Writer;\n-import java.lang.management.ManagementFactory;\n-import java.nio.charset.StandardCharsets;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Arrays;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.stream.Stream;\n-\n-import static java.lang.System.Logger.Level.ERROR;\n-import static java.lang.System.Logger.Level.TRACE;\n-\n-\/**\n- * A troubleshooting utility to continuously collect system's network and thread dump information.\n- *\/\n-public final class SystemDiagnosticsCollector implements AutoCloseable {\n-\n-    private static final Logger LOGGER =\n-            Utils.getDebugLogger(SystemDiagnosticsCollector.class.getSimpleName()::toString, Utils.DEBUG);\n-\n-    private static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger();\n-\n-    private static final String[] NETSTAT_COMMAND = findOsSpecificNetstatCommand();\n-\n-    private static String[] findOsSpecificNetstatCommand() {\n-        return Stream\n-                .of(\n-                        new String[]{\"netstat\", \"-an\"},\n-                        new String[]{\"lsof\", \"-nPi\"})\n-                .filter(SystemDiagnosticsCollector::commandSucceeds)\n-                .findFirst()\n-                .orElseGet(() -> {\n-                    LOGGER.log(ERROR, \"failed to find a command to collect system's network information\");\n-                    return null;\n-                });\n-    }\n-\n-    private static boolean commandSucceeds(String[] command) {\n-        try {\n-            LOGGER.log(TRACE, \"checking for command: %s\", Arrays.asList(command));\n-            int exitStatus = new ProcessBuilder(command)\n-                    .redirectErrorStream(true)\n-                    .redirectOutput(ProcessBuilder.Redirect.DISCARD)\n-                    .start()\n-                    .waitFor();\n-            return exitStatus == 0;\n-        } catch (InterruptedException _) {\n-            Thread.currentThread().interrupt();     \/\/ Restore the interrupt\n-            return false;\n-        } catch (IOException _) {\n-            return false;\n-        }\n-    }\n-\n-    private final Logger logger;\n-\n-    private final Duration pollDuration;\n-\n-    private final Thread thread;\n-\n-    private volatile boolean running = true;\n-\n-    public SystemDiagnosticsCollector(Class<?> clazz, Duration pollDuration) {\n-        String className = clazz.getSimpleName();\n-        this.logger = Utils.getDebugLogger(className::toString, Utils.DEBUG);\n-        this.pollDuration = pollDuration;\n-        this.thread = startThread(className);\n-    }\n-\n-    private Thread startThread(String className) {\n-        String threadName = \"%s-%s-%d\".formatted(\n-                SystemDiagnosticsCollector.class.getSimpleName(),\n-                className,\n-                INSTANCE_COUNTER.incrementAndGet());\n-        Thread thread = new Thread(this::dumpDiagnosticsContinuously, threadName);\n-        thread.setDaemon(true);    \/\/ Avoid blocking JVM exit\n-        thread.start();\n-        return thread;\n-    }\n-\n-    private void dumpDiagnosticsContinuously() {\n-        logger.log(\"starting diagnostics collector\");\n-        while (running) {\n-            try {\n-                dumpDiagnostics();\n-                LockSupport.parkNanos(pollDuration.toNanos());\n-            } catch (Exception exception) {\n-                logger.log(ERROR, \"diagnostics collection has failed\", exception);\n-                if (exception instanceof InterruptedException) {\n-                    Thread.currentThread().interrupt();     \/\/ Restore the interrupt\n-                    if (running) {\n-                        logger.log(\"stopping diagnostics collector due to unexpected interrupt\", exception);\n-                    }\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    public void dumpDiagnostics() throws IOException, InterruptedException {\n-        String fileNameTimestamp = Instant.now().toString().replaceAll(\"[-:]\", \"\");\n-        logger.log(\"dumping diagnostics... (fileNameTimestamp=%s)\", fileNameTimestamp);\n-        dumpNetwork(fileNameTimestamp);\n-        dumpThreads(fileNameTimestamp);\n-    }\n-\n-    private void dumpNetwork(String fileNameTimestamp) throws IOException, InterruptedException {\n-        if (NETSTAT_COMMAND == null) {\n-            return;\n-        }\n-        Path path = createPath(\"dump-%s-net.txt\", fileNameTimestamp);\n-        new ProcessBuilder(NETSTAT_COMMAND)\n-                .redirectOutput(path.toFile())\n-                .redirectErrorStream(true)\n-                .start()\n-                .waitFor();\n-    }\n-\n-    private static void dumpThreads(String fileNameTimestamp) throws IOException {\n-        Path path = createPath(\"dump-%s-thread.txt\", fileNameTimestamp);\n-        try (Writer writer = Files.newBufferedWriter(path, StandardCharsets.UTF_8)) {\n-            Arrays\n-                    .stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n-                    .forEach(threadInfo -> {\n-                        try {\n-                            writer.write(threadInfo.toString());\n-                        } catch (IOException ioe) {\n-                            String message = \"failed dumping threads to `%s`\".formatted(path);\n-                            new RuntimeException(message, ioe).printStackTrace(System.err);\n-                        }\n-                    });\n-        }\n-    }\n-\n-    private static Path createPath(String fileNameFormatPattern, Object... fileNameFormatArgs) {\n-        String fileName = fileNameFormatPattern.formatted(fileNameFormatArgs);\n-        \/\/ Using `Path.of(\".\")` to ensure that the created files will be packaged as a part of test results\n-        return Path.of(\".\").resolve(fileName);\n-    }\n-\n-    @Override\n-    public synchronized void close() {\n-        if (running) {\n-            running = false;\n-            thread.interrupt();\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/SystemDiagnosticsCollector.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"}]}