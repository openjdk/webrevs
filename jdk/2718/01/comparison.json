{"files":[{"patch":"@@ -661,0 +661,2 @@\n+  } else if (tag.is_unresolved_klass_in_error()) {\n+    return ciConstant();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,0 +236,5 @@\n+  bool is_unresolved_klass_in_error() const {\n+    constantTag tag = get_constant_pool_tag(get_klass_index());\n+    return tag.is_unresolved_klass_in_error();\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -724,11 +724,10 @@\n-  BasicType basic_type = con.basic_type();\n-  if (basic_type == T_ILLEGAL) {\n-    \/\/ OutOfMemoryError in the CI while loading constant\n-    push_null();\n-    outer()->record_failure(\"ldc did not link\");\n-    return;\n-  }\n-  if (is_reference_type(basic_type)) {\n-    ciObject* obj = con.as_object();\n-    if (obj->is_null_object()) {\n-      push_null();\n+  if (con.is_valid()) {\n+    BasicType basic_type = con.basic_type();\n+    if (is_reference_type(basic_type)) {\n+      ciObject* obj = con.as_object();\n+      if (obj->is_null_object()) {\n+        push_null();\n+      } else {\n+        assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n+        push_object(obj->klass());\n+      }\n@@ -736,2 +735,1 @@\n-      assert(obj->is_instance() || obj->is_array(), \"must be java_mirror of klass\");\n-      push_object(obj->klass());\n+      push_translate(ciType::make(basic_type));\n@@ -740,1 +738,8 @@\n-    push_translate(ciType::make(basic_type));\n+    if (str->is_unresolved_klass_in_error()) {\n+      trap(str, NULL, Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n+                                                        Deoptimization::Action_none));\n+    } else {\n+      \/\/ OutOfMemoryError in the CI while loading constant\n+      push_null();\n+      outer()->record_failure(\"ldc did not link\");\n+    }\n@@ -2171,0 +2176,2 @@\n+      return str.is_unresolved_klass_in_error();\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1961,0 +1961,1 @@\n+int java_lang_Throwable::_cause_offset;\n@@ -1968,0 +1969,1 @@\n+  macro(_cause_offset,         k, \"cause\",         throwable_signature,               false); \\\n@@ -2008,0 +2010,3 @@\n+oop java_lang_Throwable::cause(oop throwable) {\n+  return throwable->obj_field(_cause_offset);\n+}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -502,0 +502,1 @@\n+  static int _cause_offset;\n@@ -519,0 +520,1 @@\n+  static oop cause(oop throwable);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\/\/ add new entry to the table\n+\/\/ create new error entry\n@@ -39,1 +39,2 @@\n-                                     Symbol* error, Symbol* message)\n+                                     Symbol* error, Symbol* message,\n+                                     Symbol* cause, Symbol* cause_msg)\n@@ -44,1 +45,8 @@\n-  ResolutionErrorEntry* entry = new_entry(hash, pool(), cp_index, error, message);\n+  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool());\n+  entry->set_cp_index(cp_index);\n+  entry->set_error(error);\n+  entry->set_message(message);\n+  entry->set_nest_host_error(NULL);\n+  entry->set_cause(cause);\n+  entry->set_cause_msg(cause_msg);\n+\n@@ -48,1 +56,1 @@\n-\/\/ add new entry to the table\n+\/\/ create new nest host error entry\n@@ -56,1 +64,8 @@\n-  ResolutionErrorEntry* entry = new_entry(hash, pool(), cp_index, message);\n+  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool());\n+  entry->set_cp_index(cp_index);\n+  entry->set_nest_host_error(message);\n+  entry->set_error(NULL);\n+  entry->set_message(NULL);\n+  entry->set_cause(NULL);\n+  entry->set_cause_msg(NULL);\n+\n@@ -90,2 +105,5 @@\n-void ResolutionErrorEntry::set_nest_host_error(const char* message) {\n-  _nest_host_error = message;\n+void ResolutionErrorEntry::set_cause(Symbol* c) {\n+  _cause = c;\n+  if (_cause != NULL) {\n+    _cause->increment_refcount();\n+  }\n@@ -94,12 +112,5 @@\n-\/\/ create new error entry\n-ResolutionErrorEntry* ResolutionErrorTable::new_entry(int hash, ConstantPool* pool,\n-                                                      int cp_index, Symbol* error,\n-                                                      Symbol* message)\n-{\n-  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool);\n-  entry->set_cp_index(cp_index);\n-  entry->set_error(error);\n-  entry->set_message(message);\n-  entry->set_nest_host_error(NULL);\n-\n-  return entry;\n+void ResolutionErrorEntry::set_cause_msg(Symbol* c) {\n+  _cause_msg = c;\n+  if (_cause_msg != NULL) {\n+    _cause_msg->increment_refcount();\n+  }\n@@ -108,11 +119,2 @@\n-\/\/ create new nest host error entry\n-ResolutionErrorEntry* ResolutionErrorTable::new_entry(int hash, ConstantPool* pool,\n-                                                      int cp_index, const char* message)\n-{\n-  ResolutionErrorEntry* entry = (ResolutionErrorEntry*)Hashtable<ConstantPool*, mtClass>::new_entry(hash, pool);\n-  entry->set_cp_index(cp_index);\n-  entry->set_nest_host_error(message);\n-  entry->set_error(NULL);\n-  entry->set_message(NULL);\n-\n-  return entry;\n+void ResolutionErrorEntry::set_nest_host_error(const char* message) {\n+  _nest_host_error = message;\n@@ -129,0 +131,6 @@\n+  if (entry->cause() != NULL) {\n+    entry->cause()->decrement_refcount();\n+  }\n+  if (entry->cause_msg() != NULL) {\n+    entry->cause_msg()->decrement_refcount();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,3 @@\n+private:\n+  void free_entry(ResolutionErrorEntry *entry);\n+\n@@ -47,6 +50,0 @@\n-  ResolutionErrorEntry* new_entry(int hash, ConstantPool* pool, int cp_index,\n-                                  Symbol* error, Symbol* message);\n-  ResolutionErrorEntry* new_entry(int hash, ConstantPool* pool, int cp_index,\n-                                  const char* message);\n-  void free_entry(ResolutionErrorEntry *entry);\n-\n@@ -67,1 +64,2 @@\n-                 const constantPoolHandle& pool, int which, Symbol* error, Symbol* message);\n+                 const constantPoolHandle& pool, int which, Symbol* error, Symbol* message,\n+                 Symbol* cause, Symbol* cause_msg);\n@@ -102,0 +100,2 @@\n+  Symbol*           _cause;\n+  Symbol*           _cause_msg;\n@@ -116,0 +116,6 @@\n+  Symbol*            cause() const              { return _cause; }\n+  void               set_cause(Symbol* c);\n+\n+  Symbol*            cause_msg() const          { return _cause_msg; }\n+  void               set_cause_msg(Symbol* c);\n+\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1986,1 +1986,2 @@\n-                                            Symbol* error, Symbol* message) {\n+                                            Symbol* error, Symbol* message,\n+                                            Symbol* cause, Symbol* cause_msg) {\n@@ -1991,1 +1992,4 @@\n-    resolution_errors()->add_entry(index, hash, pool, which, error, message);\n+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);\n+    if (entry == NULL) {\n+      resolution_errors()->add_entry(index, hash, pool, which, error, message, cause, cause_msg);\n+    }\n@@ -2002,1 +2006,1 @@\n-                                                Symbol** message) {\n+                                                Symbol** message, Symbol** cause, Symbol** cause_msg) {\n@@ -2010,0 +2014,2 @@\n+      *cause = entry->cause();\n+      *cause_msg = entry->cause_msg();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-                                   Symbol* message);\n+                                   Symbol* message, Symbol* cause = NULL, Symbol* cause_msg = NULL);\n@@ -283,1 +283,1 @@\n-                                       Symbol** message);\n+                                       Symbol** message, Symbol** cause, Symbol** cause_msg);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -538,0 +538,1 @@\n+  template(throwable_signature,                       \"Ljava\/lang\/Throwable;\")                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-                                   bool save_resolution_error, TRAPS) {\n+                                   TRAPS) {\n@@ -497,3 +497,5 @@\n-  Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (klass != NULL) {\n-    return klass;\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    if (klass != NULL) {\n+      return klass;\n+    }\n@@ -538,11 +540,7 @@\n-    if (save_resolution_error) {\n-      save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n-      \/\/ If CHECK_NULL above doesn't return the exception, that means that\n-      \/\/ some other thread has beaten us and has resolved the class.\n-      \/\/ To preserve old behavior, we return the resolved class.\n-      klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n-      assert(klass != NULL, \"must be resolved if exception was cleared\");\n-      return klass;\n-    } else {\n-      return NULL;  \/\/ return the pending exception\n-    }\n+    save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);\n+    \/\/ If CHECK_NULL above doesn't return the exception, that means that\n+    \/\/ some other thread has beaten us and has resolved the class.\n+    \/\/ To preserve old behavior, we return the resolved class.\n+    Klass* klass = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(klass != NULL, \"must be resolved if exception was cleared\");\n+    return klass;\n@@ -555,0 +553,1 @@\n+\n@@ -560,1 +559,13 @@\n-  this_cp->release_tag_at_put(which, JVM_CONSTANT_Class);\n+  \/\/ We also need to CAS to not overwrite an error from a racing thread.\n+\n+  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(which),\n+                                  (jbyte)JVM_CONSTANT_UnresolvedClass,\n+                                  (jbyte)JVM_CONSTANT_Class);\n+\n+  \/\/ We need to recheck exceptions from racing thread and return the same.\n+  if (old_tag == JVM_CONSTANT_UnresolvedClassInError) {\n+    \/\/ Remove klass.\n+    Atomic::release_store(adr, (Klass*)NULL);\n+    throw_resolution_error(this_cp, which, CHECK_NULL);\n+  }\n+\n@@ -575,2 +586,3 @@\n-  Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n-  if (k != NULL) {\n+  if (this_cp->tag_at(which).is_klass()) {\n+    Klass* k = this_cp->resolved_klasses()->at(resolved_klass_index);\n+    assert(k != NULL, \"should be resolved\");\n@@ -578,0 +590,2 @@\n+  } else if (this_cp->tag_at(which).is_unresolved_klass_in_error()) {\n+    return NULL;\n@@ -770,1 +784,1 @@\n-Symbol* ConstantPool::exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n+Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception) {\n@@ -802,0 +816,19 @@\n+static void add_resolution_error(const constantPoolHandle& this_cp, int which,\n+                                 constantTag tag, oop pending_exception) {\n+\n+  Symbol* error = pending_exception->klass()->name();\n+  oop cause = java_lang_Throwable::cause(pending_exception);\n+\n+  \/\/ Also dig out the exception cause, if present.\n+  Symbol* cause_sym = NULL;\n+  Symbol* cause_msg = NULL;\n+  if (cause != NULL) {\n+    cause_sym = cause == NULL ? NULL : cause->klass()->name();\n+    cause_msg = java_lang_Throwable::detail_message(cause);\n+  }\n+\n+  Symbol* message = exception_message(this_cp, which, tag, pending_exception);\n+  SystemDictionary::add_resolution_error(this_cp, which, error, message, cause_sym, cause_msg);\n+}\n+\n+\n@@ -803,0 +836,1 @@\n+  ResourceMark rm(THREAD);\n@@ -804,1 +838,3 @@\n-  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message);\n+  Symbol* cause = NULL;\n+  Symbol* cause_msg = NULL;\n+  Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &message, &cause, &cause_msg);\n@@ -806,0 +842,2 @@\n+  const char* cause_str = cause_msg != NULL ? cause_msg->as_C_string() : NULL;\n+\n@@ -808,2 +846,7 @@\n-    ResourceMark rm;\n-    THROW_MSG(error, message->as_C_string());\n+    char* msg = message->as_C_string();\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_MSG_CAUSE(error, msg, h_cause);\n+    } else {\n+      THROW_MSG(error, msg);\n+    }\n@@ -811,1 +854,6 @@\n-    THROW(error);\n+    if (cause != NULL) {\n+      Handle h_cause = Exceptions::new_exception(THREAD, cause, cause_str);\n+      THROW_CAUSE(error, h_cause);\n+    } else {\n+      THROW(error);\n+    }\n@@ -819,1 +867,0 @@\n-  Symbol* error = PENDING_EXCEPTION->klass()->name();\n@@ -830,2 +877,1 @@\n-    Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);\n-    SystemDictionary::add_resolution_error(this_cp, which, error, message);\n+    add_resolution_error(this_cp, which, tag, PENDING_EXCEPTION);\n@@ -950,1 +996,1 @@\n-      Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);\n+      Klass* resolved = klass_at_impl(this_cp, index, CHECK_NULL);\n@@ -1039,1 +1085,1 @@\n-      Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);\n+      Klass* callee = klass_at_impl(this_cp, callee_index, CHECK_NULL);\n@@ -2339,7 +2385,1 @@\n-\n-        Klass* klass = resolved_klasses()->at(resolved_klass_index);\n-        if (klass != NULL) {\n-          klass->print_value_on(st);\n-        } else {\n-          symbol_at(name_index)->print_value_on(st);\n-        }\n+        symbol_at(name_index)->print_value_on(st);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":75,"deletions":35,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -421,7 +421,1 @@\n-    return klass_at_impl(h_this, which, true, THREAD);\n-  }\n-\n-  \/\/ Version of klass_at that doesn't save the resolution error, called during deopt\n-  Klass* klass_at_ignore_error(int which, TRAPS) {\n-    constantPoolHandle h_this(THREAD, this);\n-    return klass_at_impl(h_this, which, false, THREAD);\n+    return klass_at_impl(h_this, which, THREAD);\n@@ -889,2 +883,1 @@\n-  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which,\n-                              bool save_resolution_error, TRAPS);\n+  static Klass* klass_at_impl(const constantPoolHandle& this_cp, int which, TRAPS);\n@@ -906,1 +899,0 @@\n-  static Symbol* exception_message(const constantPoolHandle& this_cp, int which, constantTag tag, oop pending_exception);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1823,1 +1823,1 @@\n-    Klass* tk = constant_pool->klass_at_ignore_error(index, THREAD);\n+    Klass* tk = constant_pool->klass_at(index, THREAD);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.*;\n+\n+public class AsmClasses implements Opcodes {\n+\n+    \/\/ class B extends A {}\n+    public static byte[] dumpB() throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"B\", null, \"A\", null);\n+\n+        classWriter.visitSource(\"B.java\", null);\n+        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        methodVisitor.visitCode();\n+        Label label0 = new Label();\n+        methodVisitor.visitLabel(label0);\n+        methodVisitor.visitLineNumber(24, label0);\n+        methodVisitor.visitVarInsn(ALOAD, 0);\n+        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"A\", \"<init>\", \"()V\", false);\n+        methodVisitor.visitInsn(RETURN);\n+        methodVisitor.visitMaxs(1, 1);\n+        methodVisitor.visitEnd();\n+        classWriter.visitEnd();\n+\n+        return classWriter.toByteArray();\n+    }\n+\n+    \/\/ public class A extends C {\n+    \/\/     public A(boolean okSuper) {\n+    \/\/        System.out.println(\"A extends C\");\n+    \/\/        if (okSuper) {\n+    \/\/            throw new RuntimeException(\"Should not call this\");\n+    \/\/        }\n+    \/\/     }\n+    \/\/ }\n+    public static byte[] dumpA() throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"A\", null, \"C\", null);\n+\n+        classWriter.visitSource(\"A.java\", null);\n+\n+        {\n+        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"(Z)V\", null, null);\n+        methodVisitor.visitCode();\n+        Label label0 = new Label();\n+        methodVisitor.visitLabel(label0);\n+        methodVisitor.visitLineNumber(25, label0);\n+        methodVisitor.visitVarInsn(ALOAD, 0);\n+        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"C\", \"<init>\", \"()V\", false);\n+        Label label1 = new Label();\n+        methodVisitor.visitLabel(label1);\n+        methodVisitor.visitLineNumber(26, label1);\n+        methodVisitor.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n+        methodVisitor.visitLdcInsn(\"A extends C\");\n+        methodVisitor.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false);\n+        Label label2 = new Label();\n+        methodVisitor.visitLabel(label2);\n+        methodVisitor.visitLineNumber(27, label2);\n+        methodVisitor.visitVarInsn(ILOAD, 1);\n+        Label label3 = new Label();\n+        methodVisitor.visitJumpInsn(IFEQ, label3);\n+        Label label4 = new Label();\n+        methodVisitor.visitLabel(label4);\n+        methodVisitor.visitLineNumber(28, label4);\n+        methodVisitor.visitTypeInsn(NEW, \"java\/lang\/RuntimeException\");\n+        methodVisitor.visitInsn(DUP);\n+        methodVisitor.visitLdcInsn(\"Should not call this\");\n+        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/RuntimeException\", \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        methodVisitor.visitInsn(ATHROW);\n+        methodVisitor.visitLabel(label3);\n+        methodVisitor.visitLineNumber(30, label3);\n+        methodVisitor.visitFrame(Opcodes.F_FULL, 2, new Object[] {\"A\", Opcodes.INTEGER}, 0, new Object[] {});\n+        methodVisitor.visitInsn(RETURN);\n+        methodVisitor.visitMaxs(3, 2);\n+        methodVisitor.visitEnd();\n+        }\n+        classWriter.visitEnd();\n+\n+        return classWriter.toByteArray();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/AsmClasses.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class ClassLoadingThread extends Thread {\n+\n+    private ClassLoader ldr = null;\n+    private Object thread_sync = null;\n+    private boolean okSuper = false;\n+\n+    \/** Debug messages printing *\/\n+    private static void println(String s) {\n+        System.out.println(Thread.currentThread().getName() + \": \" + s);\n+        System.out.flush();\n+    }\n+\n+    public ClassLoadingThread(ClassLoader loader, Object sync, boolean super_is_ok) {\n+        ldr = loader;\n+        thread_sync = sync;\n+        okSuper = super_is_ok;\n+    }\n+\n+    private boolean success = true;\n+    public boolean report_success() { return success; }\n+\n+    public void run() {\n+        try {\n+            println(\"Starting...\");\n+            \/\/ Initiate class loading using specified type\n+            Class<?> a = Class.forName(\"ClassInLoader\", true, ldr);\n+            Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n+\n+        } catch (Throwable e) {\n+            println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = false;\n+        } finally {\n+            println(\"Finished\");\n+            synchronized (thread_sync) {\n+                thread_sync.notify();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+class MyLoader extends ClassLoader {\n+    static {\n+        registerAsParallelCapable();\n+    }\n+\n+    public Class loadClass(String name) throws ClassNotFoundException {\n+        synchronized(getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c != null) return c;\n+\n+            byte[] b = loadClassData(name);\n+            if (b != null) {\n+                return defineClass(name, b, 0, b.length);\n+            } else {\n+                return super.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static boolean waitForSuper = false;\n+    private static boolean concurrent = false;\n+    private static boolean okSuper = false;\n+    private static boolean first = true;\n+    private Object sync = new Object();\n+    private Object thread_sync = new Object();\n+\n+    private void makeThreadWait() {\n+         first = false;  \/\/ second thread gets a different A\n+         if (waitForSuper) {\n+            \/\/ Wake up the first thread here.\n+            synchronized (thread_sync) {\n+                thread_sync.notify();\n+            }\n+        }\n+        if (isRegisteredAsParallelCapable()) {\n+            synchronized(sync) {\n+                try {\n+                    System.out.println(\"t1 waits parallelCapable loader\");\n+                    sync.wait(100);  \/\/ Give up lock after request to load B\n+                } catch (InterruptedException e) {}\n+             }\n+         } else {\n+             try {\n+                System.out.println(\"t1 waits non-parallelCapable loader\");\n+                wait(100);  \/\/ Give up lock after request to load B\n+              } catch (InterruptedException e) {}\n+         }\n+    }\n+\n+    private byte[] loadClassData(String name) {\n+        \/\/ load the class data from the connection\n+        if (name.equals(\"A\")) {\n+            if (first) {\n+                System.out.println(\"loading A extends B\");\n+                return getClassData(\"A\");\n+            } else {\n+                System.out.println(\"loading A extends C\");\n+                byte[] data;\n+                try {\n+                    data = AsmClasses.dumpA();\n+                } catch (Exception e) {\n+                    data = null;\n+                }\n+                return data;\n+            }\n+        } else if (name.equals(\"B\")) {\n+            byte[] data;\n+            if (okSuper) {\n+                data = getClassData(\"B\");\n+            } else {\n+                try {\n+                    data = AsmClasses.dumpB();\n+                } catch (Exception e) {\n+                    data = null;\n+                    e.printStackTrace();\n+                }\n+            }\n+            if (first) makeThreadWait();\n+            return data;\n+        } else if (name.equals(\"C\")) {\n+            byte[] data = getClassData(\"C\");\n+            makeThreadWait();\n+            return data;\n+        } else {\n+            return getClassData(name);\n+        }\n+    }\n+\n+    byte[] getClassData(String name) {\n+        try {\n+           String TempName = name;\n+           String currentDir = System.getProperty(\"test.classes\");\n+           String filename = currentDir + File.separator + TempName + \".class\";\n+\n+           FileInputStream fis = new FileInputStream(filename);\n+           byte[] b = new byte[5000];\n+           int cnt = fis.read(b, 0, 5000);\n+           byte[] c = new byte[cnt];\n+           for (int i=0; i<cnt; i++) c[i] = b[i];\n+             return c;\n+        } catch (IOException e) {\n+           return null;\n+        }\n+    }\n+\n+    ClassLoadingThread[] threads = new ClassLoadingThread[2];\n+    private boolean success = true;\n+\n+    public boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+            if (!threads[i].report_success()) success = false;\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    void startLoading() {\n+\n+        for (int i = 0; i < 2; i++) {\n+            threads[i] = new ClassLoadingThread(this, thread_sync, okSuper);\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+            \/\/ wait to start the second thread if not concurrent\n+            if (!concurrent && i == 0) {\n+                synchronized(thread_sync) {\n+                    try {\n+                        System.out.println(\"t2 waits\");\n+                        thread_sync.wait();\n+                    } catch (InterruptedException e) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    MyLoader(boolean load_in_parallel, boolean wait_for_super, boolean load_different_super) {\n+       concurrent = load_in_parallel;\n+       waitForSuper = wait_for_super;\n+       okSuper = load_different_super;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test MyLoaderTest\n+ * @bug 8262046\n+ * @summary Call handle_parallel_super_load, loading parallel threads that throw CCE\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @compile -XDignore.symbol.file AsmClasses.java\n+ * @compile classfiles\/ClassInLoader.java classfiles\/A.java classfiles\/B.java classfiles\/C.java\n+ * @run main\/othervm MyLoaderTest\n+ * @run main\/othervm MyLoaderTest -waitForSuper\n+ * @run main\/othervm MyLoaderTest -parallelCapable\n+ * @run main\/othervm MyLoaderTest -waitForSuper -parallelCapable\n+ * @run main\/othervm MyLoaderTest -okSuper\n+ * @run main\/othervm MyLoaderTest -waitForSuper -okSuper\n+ * @run main\/othervm MyLoaderTest -waitForSuper -parallelCapable -okSuper\n+ * @run main\/othervm MyLoaderTest -concurrent\n+ * @run main\/othervm MyLoaderTest -concurrent -parallelCapable\n+ *\/\n+\n+public class MyLoaderTest {\n+    public static void main(java.lang.String[] args) throws Exception {\n+        boolean concurrent = false;\n+        boolean waitForSuper = false;\n+        boolean okSuper = false;\n+        boolean parallelCapable = false;\n+        boolean success = true;\n+        for (int i = 0; i < args.length; i++) {\n+            try {\n+                \/\/ Don't print debug info\n+                if (args[i].equals(\"-concurrent\")) {\n+                    concurrent = true;\n+                } else if (args[i].equals(\"-okSuper\")) {\n+                    okSuper = true;\n+                } else if (args[i].equals(\"-parallelCapable\")) {\n+                    parallelCapable = true;\n+                } else if (args[i].equals(\"-waitForSuper\")) {\n+                    waitForSuper = true;\n+                } else {\n+                    System.out.println(\"Unrecognized \" + args[i]);\n+                }\n+            } catch (NumberFormatException e) {\n+                System.err.println(\"Invalid parameter: \" + args[i - 1] + \" \" + args[i]);\n+            }\n+        }\n+        if (parallelCapable) {\n+            MyLoader ldr = new MyLoader(concurrent, waitForSuper, okSuper);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        } else {\n+            MyNonParallelLoader ldr = new MyNonParallelLoader(concurrent, waitForSuper, okSuper);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        }\n+        if (success) {\n+            System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoaderTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class MyNonParallelLoader extends MyLoader {\n+    \/\/ This loader isn't parallel capable because it's not registered in the static\n+    \/\/ initializer as such.  parallelCapable is not an inheritable attribute.\n+    MyNonParallelLoader(boolean load_in_parallel, boolean wait_for_super, boolean load_different_super2) {\n+       super(load_in_parallel, wait_for_super, load_different_super2);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyNonParallelLoader.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class A extends B {\n+    public A(boolean okSuper) {\n+       System.out.println(\"A extends B\");\n+       if (!okSuper) {\n+           throw new RuntimeException(\"Should throw CCE here\");\n+       }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/A.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class B { public B() { System.out.println(\"B\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/B.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class C { public C() { System.out.println(\"C\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/C.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Create a class to load inside the loader instance, that will load\n+\/\/ A through a constant pool reference.\n+\/\/ Through 2 different constant pool references\n+class CP1 {\n+  void foo(boolean okSuper) throws Exception {\n+      System.out.println(\"CP1.foo()\");\n+      try {\n+          Class<?> a = A.class;\n+          Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n+          if (!okSuper) {\n+              throw new RuntimeException(\"Should throw CCE here\");\n+          }\n+      } catch (Throwable e) {\n+          System.out.println(\"Exception is caught: \" + e);\n+          if (okSuper || !(e instanceof java.lang.ClassCircularityError)) {\n+              throw new RuntimeException(\"Unexpected exception\");\n+          }\n+      }\n+  }\n+}\n+\n+\/\/ This class has a constant pool reference to A also but will load\n+\/\/ the second version of the class if CCE is thrown while loading the\n+\/\/ first version of the class.  Otherwise if okSuper, will load A extends B\n+\/\/ Due to timing, thread 1 might still be loading class A with CCE so this\n+\/\/ could get CCE also.\n+class CP2 {\n+  void foo(boolean okSuper) throws Exception {\n+      System.out.println(\"CP2.foo()\");\n+      try {\n+          Class<?> a = A.class;\n+          Object obj = a.getConstructor(boolean.class).newInstance(okSuper);\n+      } catch (Throwable e) {\n+          System.out.println(\"Exception is caught: \" + e);\n+      }\n+  }\n+}\n+\n+public class ClassInLoader {\n+  public ClassInLoader(boolean okSuper) throws Exception {\n+    System.out.println(\"ClassInLoader\");\n+    CP1 c1 = new CP1();\n+    c1.foo(okSuper);\n+    CP2 c2 = new CP2();\n+    c2.foo(okSuper);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/classfiles\/ClassInLoader.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}