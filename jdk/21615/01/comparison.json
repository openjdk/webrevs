{"files":[{"patch":"@@ -547,0 +547,10 @@\n+#ifndef MUSL_LIBC\n+  \/\/ Add XMM registers + MXCSR. Note that C2 uses XMM to spill GPR values including pointers.\n+  st->cr();\n+  st->cr();\n+  for (int i = 0; i < 16; ++i) {\n+    const int64_t* xmm_val_addr = (int64_t*)&(uc->uc_mcontext.fpregs->_xmm[i]);\n+    st->print_cr(\"XMM[%d]=\" INTPTR_FORMAT \" \" INTPTR_FORMAT, i, xmm_val_addr[1], xmm_val_addr[0]);\n+  }\n+  st->print(\"  MXCSR=\" UINT32_FORMAT_X_0, uc->uc_mcontext.fpregs->mxcsr);\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -440,0 +440,9 @@\n+  \/\/ Add XMM registers + MXCSR. Note that C2 uses XMM to spill GPR values including pointers.\n+  st->cr();\n+  st->cr();\n+  for (int i = 0; i < 16; ++i) {\n+    const uint64_t *xmm = ((const uint64_t*)&(uc->Xmm0)) + 2 * i;\n+    st->print_cr(\"XMM[%d]=\" INTPTR_FORMAT \" \" INTPTR_FORMAT,\n+                 i, xmm[1], xmm[0]);\n+  }\n+  st->print(\"  MXCSR=\" UINT32_FORMAT_X_0, uc->MxCsr);\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -728,1 +728,1 @@\n-#if defined(LINUX) && defined(PPC64)\n+#if defined(LINUX)\n@@ -731,0 +731,1 @@\n+#if defined(PPC64)\n@@ -732,0 +733,3 @@\n+#elif defined(AMD64)\n+  *((void**) &g_stored_assertion_context.uc_mcontext.fpregs) = &(g_stored_assertion_context.uc_mcontext.fpregs);\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}