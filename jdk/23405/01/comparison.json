{"files":[{"patch":"@@ -117,0 +117,1 @@\n+      ::shutdown(_socket, SHUT_RDWR);\n@@ -135,1 +136,1 @@\n-  \/\/ called after writing all data\n+\n@@ -137,1 +138,0 @@\n-    ::shutdown(_socket, SHUT_RDWR);\n@@ -147,0 +147,3 @@\n+  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n+  }\n+\n@@ -149,1 +152,2 @@\n-  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n+  virtual ReplyWriter* get_reply_writer() override {\n+      return &_socket_channel;\n@@ -153,1 +157,1 @@\n-    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n+    return _socket_channel.read_request(this, &_socket_channel);\n@@ -321,5 +325,0 @@\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  write_reply(&_socket_channel, result, st);\n-\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+      FlushFileBuffers(_hPipe);\n@@ -126,2 +127,2 @@\n-        log_error(attach)(\"pipe write error (%d)\", GetLastError());\n-        return -1;\n+      log_error(attach)(\"pipe write error (%d)\", GetLastError());\n+      return -1;\n@@ -133,2 +134,0 @@\n-    assert(opened(), \"must be\");\n-    FlushFileBuffers(_hPipe);\n@@ -154,1 +153,1 @@\n-    return AttachOperation::read_request(&_pipe, &_pipe);\n+    return _pipe.read_request(this, &_pipe);\n@@ -159,0 +158,4 @@\n+\n+  virtual ReplyWriter* get_reply_writer() override {\n+    return &_pipe;\n+  }\n@@ -435,5 +438,0 @@\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n-\n-  write_reply(&_pipe, result, result_stream);\n-\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -50,0 +51,111 @@\n+\n+\/\/ Stream for printing attach operation results.\n+\/\/ Supports buffered and streaming output for commands which can produce lengthy reply.\n+\/\/\n+\/\/ A platform implementation supports streaming output if it implements AttachOperation::get_reply_writer().\n+\/\/ Streaming is enabled if the allow_streaming in the constructor is set to true.\n+\/\/\n+\/\/ Initially attachStream works in buffered mode.\n+\/\/ To switch to the streaming mode attach command handler need to call attachStream::set_result().\n+\/\/ The method flushes buffered output and consequent printing goes directly to ReplyWriter.\n+class attachStream : public bufferedStream {\n+  AttachOperation::ReplyWriter* _reply_writer;\n+  bool _allow_streaming;\n+  jint _result;\n+  bool _result_set;\n+  bool _result_written;\n+  bool _error;\n+\n+  enum : size_t {\n+    INITIAL_BUFFER_SIZE = 1 * M,\n+    MAXIMUM_BUFFER_SIZE = 3 * G,\n+  };\n+\n+  bool is_streaming() const {\n+    return _result_set && _allow_streaming;\n+  }\n+\n+  void flush_reply() {\n+    if (_error) {\n+      return;\n+    }\n+\n+    if (!_result_written) {\n+      if (_reply_writer->write_reply(_result, this)) {\n+        _result_written = true;\n+        reset();\n+      } else {\n+        _error = true;\n+        return;\n+      }\n+    } else {\n+      _error = !_reply_writer->write_fully(base(), (int)size());\n+      reset();\n+    }\n+  }\n+\n+public:\n+  attachStream(AttachOperation::ReplyWriter* reply_writer, bool allow_streaming)\n+    : bufferedStream(INITIAL_BUFFER_SIZE, MAXIMUM_BUFFER_SIZE),\n+      _reply_writer(reply_writer),\n+      _allow_streaming(reply_writer == nullptr ? false : allow_streaming),\n+      _result(JNI_OK), _result_set(false), _result_written(false),\n+      _error(false)\n+    {}\n+\n+  virtual ~attachStream() {}\n+\n+  void set_result(jint result) {\n+    if (!_result_set) {\n+      _result = result;\n+      _result_set = true;\n+      if (_allow_streaming) {\n+        \/\/ switch to streaming mode\n+        flush_reply();\n+      }\n+    }\n+  }\n+\n+  jint get_result() const {\n+    return _result;\n+  }\n+\n+  bufferedStream* get_buffered_stream() {\n+    return this;\n+  }\n+\n+  \/\/ Called after the operation is completed.\n+  \/\/ If reply_writer is provided, writes the results.\n+  void complete() {\n+    flush_reply();\n+  }\n+\n+  virtual void write(const char* str, size_t len) override {\n+    if (is_streaming()) {\n+      if (!_error) {\n+        _error = !_reply_writer->write_fully(str, (int)len);\n+      }\n+    } else {\n+      bufferedStream::write(str, len);\n+    }\n+  }\n+\n+  virtual void flush() override {\n+    \/\/ flush if streaming output is enabled\n+    if (_allow_streaming) {\n+      flush_reply();\n+    } else {\n+      bufferedStream::flush();\n+    }\n+  }\n+};\n+\n+\/\/ Attach operation handler.\n+typedef void(*AttachOperationFunction)(AttachOperation* op, attachStream* out);\n+\n+struct AttachOperationFunctionInfo {\n+    const char* name;\n+    AttachOperationFunction func;\n+};\n+\n+\n@@ -54,0 +166,3 @@\n+\/\/ Default is false (if jdk.attach.vm.streaming property is not set).\n+bool AttachListener::_default_streaming_output = false;\n+\n@@ -98,1 +213,1 @@\n-static jint get_properties(AttachOperation* op, outputStream* out, Symbol* serializePropertiesMethod) {\n+static void get_properties(AttachOperation* op, attachStream* out, Symbol* serializePropertiesMethod) {\n@@ -108,1 +223,2 @@\n-    return JNI_ERR;\n+    out->set_result(JNI_ERR);\n+    return;\n@@ -126,1 +242,2 @@\n-    return JNI_ERR;\n+    out->set_result(JNI_ERR);\n+    return;\n@@ -134,0 +251,2 @@\n+  out->set_result(JNI_OK);\n+\n@@ -138,2 +257,0 @@\n-\n-  return JNI_OK;\n@@ -143,1 +260,1 @@\n-static jint load_agent(AttachOperation* op, outputStream* out) {\n+static void load_agent(AttachOperation* op, attachStream* out) {\n@@ -163,0 +280,1 @@\n+      out->set_result(JNI_ERR);\n@@ -165,1 +283,1 @@\n-      return JNI_ERR;\n+      return;\n@@ -169,0 +287,1 @@\n+  out->set_result(JNI_OK);\n@@ -174,1 +293,0 @@\n-  return JNI_OK;\n@@ -179,1 +297,1 @@\n-static jint get_system_properties(AttachOperation* op, outputStream* out) {\n+static void get_system_properties(AttachOperation* op, attachStream* out) {\n@@ -184,2 +302,2 @@\n-static jint get_agent_properties(AttachOperation* op, outputStream* out) {\n-  return get_properties(op, out, vmSymbols::serializeAgentPropertiesToByteArray_name());\n+static void get_agent_properties(AttachOperation* op, attachStream* out) {\n+  get_properties(op, out, vmSymbols::serializeAgentPropertiesToByteArray_name());\n@@ -195,1 +313,2 @@\n-static jint data_dump(AttachOperation* op, outputStream* out) {\n+static void data_dump(AttachOperation* op, attachStream* out) {\n+  out->set_result(JNI_OK);\n@@ -203,1 +322,0 @@\n-  return JNI_OK;\n@@ -209,1 +327,1 @@\n-static jint thread_dump(AttachOperation* op, outputStream* out) {\n+static void thread_dump(AttachOperation* op, attachStream* out) {\n@@ -223,0 +341,2 @@\n+  out->set_result(JNI_OK);\n+\n@@ -230,2 +350,0 @@\n-\n-  return JNI_OK;\n@@ -236,1 +354,1 @@\n-static jint jcmd(AttachOperation* op, outputStream* out) {\n+static void jcmd(AttachOperation* op, attachStream* out) {\n@@ -238,0 +356,1 @@\n+\n@@ -240,1 +359,30 @@\n-  DCmd::parse_and_execute(DCmd_Source_AttachAPI, out, op->arg(0), ' ', THREAD);\n+\n+  \/\/ Overridden DCmd::Executor to switch output to \"streaming\" mode\n+  \/\/ before execute the command.\n+\n+  bool allow_streaming_output = true;\n+  \/\/ Special case for ManagementAgent.start and ManagementAgent.start_local commands\n+  \/\/ used by HotSpotVirtualMachine.startManagementAgent and startLocalManagementAgent.\n+  \/\/ The commands report error if the agent failed to load, so we need to disable streaming output.\n+  const char jmx_prefix[] = \"ManagementAgent.\";\n+  if (strncmp(op->arg(0), jmx_prefix, strlen(jmx_prefix)) == 0) {\n+    allow_streaming_output = false;\n+  }\n+\n+  class Executor: public DCmd::Executor {\n+  private:\n+    attachStream* _attach_stream;\n+    bool _allow_streaming_output;\n+  public:\n+    Executor(DCmdSource source, attachStream* out, bool allow_streaming_output)\n+        : DCmd::Executor(source, out), _attach_stream(out), _allow_streaming_output(allow_streaming_output) {}\n+  protected:\n+    virtual void execute(DCmd* command, TRAPS) override {\n+      if (_allow_streaming_output) {\n+          _attach_stream->set_result(JNI_OK);\n+      }\n+      DCmd::Executor::execute(command, CHECK);\n+    }\n+  } executor(DCmd_Source_AttachAPI, out, allow_streaming_output);\n+\n+  executor.parse_and_execute(op->arg(0), ' ', THREAD);\n@@ -242,0 +390,5 @@\n+    \/\/ We can get an exception during command execution.\n+    \/\/ In the case _attach_stream->set_result() is already called and operation result code is send\n+    \/\/ to the client.\n+    \/\/ Repeated out->set_result() is a no-op, just report exception message.\n+    out->set_result(JNI_ERR);\n@@ -245,1 +398,0 @@\n-    return JNI_ERR;\n@@ -247,1 +399,0 @@\n-  return JNI_OK;\n@@ -257,1 +408,1 @@\n-static jint dump_heap(AttachOperation* op, outputStream* out) {\n+static void dump_heap(AttachOperation* op, attachStream* out) {\n@@ -260,0 +411,1 @@\n+    out->set_result(JNI_ERR);\n@@ -261,21 +413,10 @@\n-  } else {\n-    bool live_objects_only = true;   \/\/ default is true to retain the behavior before this change is made\n-    const char* arg1 = op->arg(1);\n-    if (arg1 != nullptr && (strlen(arg1) > 0)) {\n-      if (strcmp(arg1, \"-all\") != 0 && strcmp(arg1, \"-live\") != 0) {\n-        out->print_cr(\"Invalid argument to dumpheap operation: %s\", arg1);\n-        return JNI_ERR;\n-      }\n-      live_objects_only = strcmp(arg1, \"-live\") == 0;\n-    }\n-\n-    const char* num_str = op->arg(2);\n-    uint level = 0;\n-    if (num_str != nullptr && num_str[0] != '\\0') {\n-      if (!Arguments::parse_uint(num_str, &level, 0)) {\n-        out->print_cr(\"Invalid compress level: [%s]\", num_str);\n-        return JNI_ERR;\n-      } else if (level < 1 || level > 9) {\n-        out->print_cr(\"Compression level out of range (1-9): %u\", level);\n-        return JNI_ERR;\n-      }\n+    return;\n+  }\n+\n+  bool live_objects_only = true;   \/\/ default is true to retain the behavior before this change is made\n+  const char* arg1 = op->arg(1);\n+  if (arg1 != nullptr && (strlen(arg1) > 0)) {\n+    if (strcmp(arg1, \"-all\") != 0 && strcmp(arg1, \"-live\") != 0) {\n+      out->set_result(JNI_ERR);\n+      out->print_cr(\"Invalid argument to dumpheap operation: %s\", arg1);\n+      return;\n@@ -283,0 +424,2 @@\n+    live_objects_only = strcmp(arg1, \"-live\") == 0;\n+  }\n@@ -284,5 +427,12 @@\n-    \/\/ Request a full GC before heap dump if live_objects_only = true\n-    \/\/ This helps reduces the amount of unreachable objects in the dump\n-    \/\/ and makes it easier to browse.\n-    HeapDumper dumper(live_objects_only \/* request GC *\/);\n-    dumper.dump(path, out, level);\n+  const char* num_str = op->arg(2);\n+  uint level = 0;\n+  if (num_str != nullptr && num_str[0] != '\\0') {\n+    if (!Arguments::parse_uint(num_str, &level, 0)) {\n+      out->set_result(JNI_ERR);\n+      out->print_cr(\"Invalid compress level: [%s]\", num_str);\n+      return;\n+    } else if (level < 1 || level > 9) {\n+      out->set_result(JNI_ERR);\n+      out->print_cr(\"Compression level out of range (1-9): %u\", level);\n+      return;\n+    }\n@@ -290,1 +440,7 @@\n-  return JNI_OK;\n+\n+  out->set_result(JNI_OK);\n+  \/\/ Request a full GC before heap dump if live_objects_only = true\n+  \/\/ This helps reduces the amount of unreachable objects in the dump\n+  \/\/ and makes it easier to browse.\n+  HeapDumper dumper(live_objects_only \/* request GC *\/);\n+  dumper.dump(path, out, level);\n@@ -300,1 +456,1 @@\n-static jint heap_inspection(AttachOperation* op, outputStream* out) {\n+static void heap_inspection(AttachOperation* op, attachStream* out) {\n@@ -308,0 +464,1 @@\n+      out->set_result(JNI_ERR);\n@@ -309,1 +466,1 @@\n-      return JNI_ERR;\n+      return;\n@@ -328,0 +485,1 @@\n+      out->set_result(JNI_ERR);\n@@ -330,1 +488,1 @@\n-      return JNI_ERR;\n+      return;\n@@ -335,0 +493,2 @@\n+  out->set_result(JNI_OK);\n+\n@@ -341,1 +501,0 @@\n-  return JNI_OK;\n@@ -345,1 +504,1 @@\n-static jint set_flag(AttachOperation* op, outputStream* out) {\n+static void set_flag(AttachOperation* op, attachStream* out) {\n@@ -349,0 +508,1 @@\n+    out->set_result(JNI_ERR);\n@@ -350,1 +510,1 @@\n-    return JNI_ERR;\n+    return;\n@@ -357,0 +517,1 @@\n+    out->set_result(JNI_ERR);\n@@ -362,1 +523,1 @@\n-    return JNI_ERR;\n+    return;\n@@ -364,1 +525,1 @@\n-  return JNI_OK;\n+  out->set_result(JNI_OK);\n@@ -369,1 +530,1 @@\n-static jint print_flag(AttachOperation* op, outputStream* out) {\n+static void print_flag(AttachOperation* op, attachStream* out) {\n@@ -372,0 +533,1 @@\n+    out->set_result(JNI_ERR);\n@@ -373,1 +535,1 @@\n-    return JNI_ERR;\n+    return;\n@@ -377,0 +539,1 @@\n+    out->set_result(JNI_OK);\n@@ -380,0 +543,1 @@\n+    out->set_result(JNI_ERR);\n@@ -382,1 +546,0 @@\n-  return JNI_OK;\n@@ -386,1 +549,2 @@\n-static jint get_version(AttachOperation* op, outputStream* out) {\n+static void get_version(AttachOperation* op, attachStream* out) {\n+  out->set_result(JNI_OK);\n@@ -388,1 +552,6 @@\n-  return JNI_OK;\n+\n+  const char* arg0 = op->arg(0);\n+  if (strcmp(arg0, \"options\") == 0) {\n+      \/\/ print supported options: \"option1,option2...\"\n+      out->print(\" streaming\");\n+  }\n@@ -422,0 +591,6 @@\n+  AttachListener::set_default_streaming(\n+      get_bool_sys_prop(\"jdk.attach.vm.streaming\",\n+                        AttachListener::get_default_streaming(),\n+                        thread));\n+  log_debug(attach)(\"default streaming output: %d\", AttachListener::get_default_streaming() ? 1 : 0);\n+\n@@ -426,0 +601,1 @@\n+\n@@ -436,8 +612,1 @@\n-    \/\/ jcmd output can get lengthy. As long as we miss jcmd continuous streaming output\n-    \/\/ and instead just send the output in bulk, make sure large command output does not\n-    \/\/ cause asserts. We still retain a max cap, but dimensioned in a way that makes it\n-    \/\/ highly unlikely we should ever hit it under normal conditions.\n-    constexpr size_t initial_size = 1 * M;\n-    constexpr size_t max_size = 3 * G;\n-    bufferedStream st(initial_size, max_size);\n-    jint res = JNI_OK;\n+    attachStream st(op->get_reply_writer(), op->streaming_output());\n@@ -461,0 +630,3 @@\n+        log_debug(attach)(\"executing command %s, streaming output: %d\",\n+                         op->name(),\n+                         (op->get_reply_writer() != nullptr && op->streaming_output()) ? 1 : 0);\n@@ -462,1 +634,4 @@\n-        res = (info->func)(op, &st);\n+        info->func(op, &st);\n+        \/\/ If the operation handler hasn't set result, set it to JNI_OK now.\n+        \/\/ If the result is already set, this is no-op.\n+        st.set_result(JNI_OK);\n@@ -464,0 +639,1 @@\n+        st.set_result(JNI_ERR);\n@@ -465,1 +641,0 @@\n-        res = JNI_ERR;\n@@ -467,0 +642,1 @@\n+      st.complete();\n@@ -469,2 +645,1 @@\n-    \/\/ operation complete - send result and output to client\n-    op->complete(res, &st);\n+    op->complete(st.get_result(), st.get_buffered_stream());\n@@ -562,1 +737,1 @@\n-bool AttachOperation::read_request_data(AttachOperation::RequestReader* reader,\n+bool AttachOperation::RequestReader::read_request_data(AttachOperation* op,\n@@ -571,1 +746,1 @@\n-    int n = reader->read(buffer + off, left);\n+    int n = read(buffer + off, left);\n@@ -603,2 +778,11 @@\n-  \/\/ Command name is the 1st string.\n-  set_name(buffer);\n+  \/\/ Arguments start at 2nd string. Save it now (option parser can modify 1st argument).\n+  char* arguments = strchr(buffer, '\\0') + 1;\n+  \/\/ The first string contains command name and (possibly) options.\n+  char* end_of_name = strchr(buffer, ' ');\n+\n+  if (end_of_name != nullptr) {\n+    parse_options(op, end_of_name + 1);\n+    \/\/ zero-terminate command name\n+    *end_of_name = '\\0';\n+  }\n+  op->set_name(buffer);\n@@ -609,1 +793,1 @@\n-  for (char* cur = strchr(buffer, '\\0') + 1; cur < end; cur = strchr(cur, '\\0') + 1) {\n+  for (char* cur = arguments; cur < end; cur = strchr(cur, '\\0') + 1) {\n@@ -611,1 +795,1 @@\n-    append_arg(cur);\n+    op->append_arg(cur);\n@@ -619,2 +803,42 @@\n-bool AttachOperation::read_request(RequestReader* reader, ReplyWriter* error_writer) {\n-  int ver = reader->read_uint(true); \/\/ do not log error if this is \"empty\" connection\n+void AttachOperation::RequestReader::parse_options(AttachOperation* op, char* str) {\n+  while (*str != '\\0') {\n+    char *name, *value;\n+    str = get_option(str, &name, &value);\n+    log_debug(attach)(\"option: %s, value: %s\", name, value);\n+\n+    \/\/ handle known options\n+    if (strcmp(name, \"streaming\") == 0) {\n+      if (strcmp(value, \"1\") == 0) {\n+        op->set_streaming_output(true);\n+      } else if (strcmp(value, \"0\") == 0) {\n+        op->set_streaming_output(false);\n+      }\n+    }\n+  }\n+}\n+\n+char* AttachOperation::RequestReader::get_option(char* src, char** name, char** value) {\n+  static char empty[] = \"\";\n+  \/\/ \"option1=value1,option2=value2...\"\n+  *name = src;\n+  char* end_of_option = strchr(src, ',');\n+  if (end_of_option != nullptr) {\n+    \/\/ terminate the option\n+    *end_of_option = '\\0';\n+    \/\/ set to next option\n+    src = end_of_option + 1;\n+  } else {\n+    src = empty;\n+  }\n+  char* delim = strchr(*name, '=');\n+\n+  if (delim != nullptr) {\n+    \/\/ terminate option name\n+    *delim = '\\0';\n+  }\n+  *value = delim == nullptr ? empty : (delim + 1);\n+  return src;\n+}\n+\n+bool AttachOperation::RequestReader::read_request(AttachOperation* op, ReplyWriter* error_writer) {\n+  int ver = read_uint(true); \/\/ do not log error if this is \"empty\" connection\n@@ -638,1 +862,1 @@\n-        write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"v2 is unsupported or disabled\");\n+        error_writer->write_reply(ATTACH_ERROR_BADVERSION, \"v2 is unsupported or disabled\");\n@@ -643,1 +867,1 @@\n-    buffer_size = reader->read_uint();\n+    buffer_size = read_uint();\n@@ -660,1 +884,1 @@\n-    write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"unknown version\");\n+    error_writer->write_reply(ATTACH_ERROR_BADVERSION, \"unknown version\");\n@@ -664,1 +888,1 @@\n-  bool result = read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+  bool result = read_request_data(op, buffer_size, min_str_count, min_read_size);\n@@ -668,1 +892,1 @@\n-    if (strlen(name()) > AttachOperation::name_length_max) {\n+    if (strlen(op->name()) > AttachOperation::name_length_max) {\n@@ -672,2 +896,2 @@\n-    for (int i = 0; i < arg_count(); i++) {\n-      if (strlen(arg(i)) > AttachOperation::arg_length_max) {\n+    for (int i = 0; i < op->arg_count(); i++) {\n+      if (strlen(op->arg(i)) > AttachOperation::arg_length_max) {\n@@ -695,1 +919,1 @@\n-bool AttachOperation::write_reply(ReplyWriter * writer, jint result, const char* message, int message_len) {\n+bool AttachOperation::ReplyWriter::write_reply(jint result, const char* message, int message_len) {\n@@ -701,1 +925,1 @@\n-  if (!writer->write_fully(buf, (int)strlen(buf))) {\n+  if (!write_fully(buf, (int)strlen(buf))) {\n@@ -704,1 +928,1 @@\n-  if (!writer->write_fully(message, message_len)) {\n+  if (!write_fully(message, message_len)) {\n@@ -707,1 +931,0 @@\n-  writer->flush();\n@@ -711,2 +934,2 @@\n-bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n-  return write_reply(writer, result, result_stream->base(), (int)result_stream->size());\n+bool AttachOperation::ReplyWriter::write_reply(jint result, bufferedStream* result_stream) {\n+  return write_reply(result, result_stream->base(), (int)result_stream->size());\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":317,"deletions":94,"binary":false,"changes":411,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-\n@@ -50,7 +49,0 @@\n-typedef jint (*AttachOperationFunction)(AttachOperation* op, outputStream* out);\n-\n-struct AttachOperationFunctionInfo {\n-  const char* name;\n-  AttachOperationFunction func;\n-};\n-\n@@ -71,0 +63,7 @@\n+jdk25 update: client may specify additional options in the attach operation request.\n+  The options are passed as part of the operation command name: \"command option1,option2,option3\".\n+  \"getversion\" command with \"options\" argument returns list of comma-separated options\n+  supported by the target VM.\n+  Option \"streaming\":\n+    - \"streaming=1\" turns on streaming output. Output data are sent as they become available.\n+    - \"streaming=0\" turns off streaming output. Output is buffered and sent after the operation is complete.\n@@ -113,0 +112,2 @@\n+  static bool _default_streaming_output;\n+\n@@ -117,0 +118,7 @@\n+  static void set_default_streaming(bool value) {\n+    _default_streaming_output = value;\n+  }\n+  static bool get_default_streaming() {\n+    return _default_streaming_output;\n+  }\n+\n@@ -179,0 +187,1 @@\n+  bool _streaming; \/\/ streaming output is requested\n@@ -201,2 +210,1 @@\n-      static char empty_str[] = \"\";\n-      return empty_str;\n+      return \"\";\n@@ -217,0 +225,7 @@\n+  bool streaming_output() const {\n+    return _streaming;\n+  }\n+  void set_streaming_output(bool value) {\n+    _streaming = value;\n+  }\n+\n@@ -218,1 +233,1 @@\n-  AttachOperation(const char* name) : _name(nullptr) {\n+  AttachOperation(const char* name) : _name(nullptr), _streaming(AttachListener::get_default_streaming()) {\n@@ -225,1 +240,1 @@\n-  AttachOperation() : _name(nullptr) {\n+  AttachOperation() : _name(nullptr), _streaming(AttachListener::get_default_streaming()) {\n@@ -253,0 +268,14 @@\n+\n+\n+    \/\/ Reads standard operation request (v1 or v2), sets properties of the provided AttachOperation.\n+    \/\/ Some errors known by clients are reported to error_writer.\n+    bool read_request(AttachOperation* op, ReplyWriter* error_writer);\n+\n+  private:\n+    bool read_request_data(AttachOperation* op, int buffer_size, int min_str_count, int min_read_size);\n+    \/\/ Parses options.\n+    \/\/ Note: the buffer is modified to zero-terminate option names and values.\n+    void parse_options(AttachOperation* op, char* str);\n+    \/\/ Gets option name and value.\n+    \/\/ Returns pointer to the next option.\n+    char* get_option(char* src, char** name, char** value);\n@@ -255,3 +284,0 @@\n-  \/\/ Reads standard operation request (v1 or v2).\n-  \/\/ Some errors known by clients are reported to error_writer.\n-  bool read_request(RequestReader* reader, ReplyWriter* error_writer);\n@@ -267,1 +293,0 @@\n-  };\n@@ -269,3 +294,4 @@\n-  \/\/ Writes standard operation reply (to be called from 'complete' method).\n-  bool write_reply(ReplyWriter* writer, jint result, const char* message, int message_len = -1);\n-  bool write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream);\n+    \/\/ Writes standard operation reply.\n+    bool write_reply(jint result, const char* message, int message_len = -1);\n+    bool write_reply(jint result, bufferedStream* result_stream);\n+  };\n@@ -273,2 +299,4 @@\n-private:\n-  bool read_request_data(AttachOperation::RequestReader* reader, int buffer_size, int min_str_count, int min_read_size);\n+  \/\/ Platform implementation needs to implement the method to support streaming output.\n+  virtual ReplyWriter* get_reply_writer() {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":50,"deletions":22,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -382,2 +382,1 @@\n-void DCmd::parse_and_execute(DCmdSource source, outputStream* out,\n-                             const char* cmdline, char delim, TRAPS) {\n+void DCmd::Executor::parse_and_execute(const char* cmdline, char delim, TRAPS) {\n@@ -390,1 +389,1 @@\n-    if(source == DCmd_Source_MBean && count > 0) {\n+    if (_source == DCmd_Source_MBean && count > 0) {\n@@ -411,1 +410,1 @@\n-      DCmd* command = DCmdFactory::create_local_DCmd(source, line, out, CHECK);\n+      DCmd* command = DCmdFactory::create_local_DCmd(_source, line, _out, CHECK);\n@@ -415,1 +414,1 @@\n-      command->execute(source, CHECK);\n+      execute(command, CHECK);\n@@ -421,0 +420,9 @@\n+void DCmd::Executor::execute(DCmd* command, TRAPS) {\n+  command->execute(_source, CHECK);\n+}\n+\n+void DCmd::parse_and_execute(DCmdSource source, outputStream* out,\n+                             const char* cmdline, char delim, TRAPS) {\n+  Executor(source, out).parse_and_execute(cmdline, delim, CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,0 +281,13 @@\n+  \/\/ helper class to invoke the framework\n+  class Executor : public StackObj {\n+    DCmdSource _source;\n+    outputStream* _out;\n+  public:\n+    Executor(DCmdSource source, outputStream* out): _source(source), _out(out) {}\n+\n+    void parse_and_execute(const char* cmdline, char delim, TRAPS);\n+\n+  protected:\n+    virtual void execute(DCmd* command, TRAPS);\n+  };\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n+    private OperationProperties props = new OperationProperties(VERSION_1); \/\/ updated in ctor\n@@ -127,1 +127,1 @@\n-            ver = detectVersion();\n+            props = getDefaultProps();\n@@ -181,1 +181,1 @@\n-            writeCommand(writer, ver, cmd, args);\n+            writeCommand(writer, props, cmd, args);\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n+    private OperationProperties props = new OperationProperties(VERSION_1); \/\/ updated in ctor\n@@ -112,1 +112,1 @@\n-            ver = detectVersion();\n+            props = getDefaultProps();\n@@ -164,1 +164,0 @@\n-        \/\/ <ver> <cmd> <args...>\n@@ -167,1 +166,1 @@\n-            writeCommand(writer, ver, cmd, args);\n+            writeCommand(writer, props, cmd, args);\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -60,0 +62,1 @@\n+    private static final boolean ALLOW_STREAMING_OUTPUT;\n@@ -63,0 +66,3 @@\n+        \/\/ For now the default is false.\n+        String s2 = VM.getSavedProperty(\"jdk.attach.allowStreamingOutput\");\n+        ALLOW_STREAMING_OUTPUT = \"\".equals(s2) || Boolean.parseBoolean(s2);\n@@ -65,0 +71,2 @@\n+    private final boolean selfAttach;\n+\n@@ -77,0 +85,1 @@\n+        selfAttach = pid == 0 || pid == CURRENT_PID;\n@@ -79,1 +88,1 @@\n-        if (!ALLOW_ATTACH_SELF && (pid == 0 || pid == CURRENT_PID)) {\n+        if (!ALLOW_ATTACH_SELF && selfAttach) {\n@@ -334,0 +343,26 @@\n+    \/\/ Attach operation properties.\n+    protected static class OperationProperties {\n+        public final static String STREAMING = \"streaming\";\n+\n+        private int ver;\n+        private Map<String, String> options = new HashMap<>();\n+\n+        OperationProperties(int ver) {\n+            this.ver = ver;\n+        }\n+\n+        int version() {\n+            return ver;\n+        }\n+\n+        void setOption(String name, String value) {\n+            options.put(name, value);\n+        }\n+\n+        String options() {\n+            return options.entrySet().stream()\n+                          .map(e -> e.getKey() + \"=\" + e.getValue())\n+                          .collect(Collectors.joining(\",\"));\n+        }\n+    }\n+\n@@ -335,1 +370,1 @@\n-     * Detects Attach API version supported by target VM.\n+     * Detects Attach API properties supported by target VM.\n@@ -337,1 +372,1 @@\n-    protected int detectVersion() throws IOException {\n+    protected OperationProperties getDefaultProps() throws IOException {\n@@ -339,1 +374,1 @@\n-            InputStream reply = execute(\"getversion\");\n+            InputStream reply = execute(\"getversion\", \"options\");\n@@ -342,5 +377,18 @@\n-            try {\n-                int supportedVersion = Integer.parseUnsignedInt(message);\n-                \/\/ we expect only VERSION_2\n-                if (supportedVersion == VERSION_2) {\n-                    return VERSION_2;\n+\n+            \/\/ Reply is \"<ver> option1,option2...\".\n+            int delimPos = message.indexOf(' ');\n+            String ver = delimPos < 0 ? message : message.substring(0, delimPos);\n+\n+            int supportedVersion = Integer.parseUnsignedInt(ver);\n+\n+            \/\/ VERSION_2 supports options.\n+            if (supportedVersion == VERSION_2) {\n+                OperationProperties result = new OperationProperties(supportedVersion);\n+                \/\/ Parse known options, ignore unknown.\n+                String options = delimPos < 0 ? \"\" : message.substring(delimPos + 1);\n+                String[] parts = options.split(\",\");\n+                for (String s: parts) {\n+                    if (OperationProperties.STREAMING.equals(s)) {\n+                        result.setOption(OperationProperties.STREAMING,\n+                                         (isStreamingEnabled() ? \"1\" : \"0\"));\n+                    }\n@@ -348,2 +396,1 @@\n-            } catch (NumberFormatException nfe) {\n-                \/\/ bad reply - fallback to VERSION_1\n+                return result;\n@@ -353,0 +400,2 @@\n+        } catch (NumberFormatException nfe) {\n+            \/\/ bad version number - fallback to VERSION_1\n@@ -354,1 +403,1 @@\n-        return VERSION_1;\n+        return new OperationProperties(VERSION_1);\n@@ -365,0 +414,11 @@\n+    \/*\n+     * Streaming output.\n+     *\/\n+    protected boolean isStreamingEnabled() {\n+        \/\/ Disable streaming for self-attach.\n+        if (selfAttach) {\n+            return false;\n+        }\n+        return ALLOW_STREAMING_OUTPUT;\n+    }\n+\n@@ -481,3 +541,9 @@\n-    protected void writeCommand(AttachOutputStream writer, int ver, String cmd, Object ... args) throws IOException {\n-        writeString(writer, ver);\n-        if (ver == VERSION_2) {\n+    protected void writeCommand(AttachOutputStream writer, OperationProperties props,\n+                                String cmd, Object ... args) throws IOException {\n+        writeString(writer, props.version());\n+        if (props.version() == VERSION_2) {\n+            \/\/ add options to the command name (if specified)\n+            String options = props.options();\n+            if (!options.isEmpty()) {\n+                cmd += \" \" + options;\n+            }\n@@ -493,1 +559,1 @@\n-        int argNumber = ver == VERSION_1 ? 3 : args.length;\n+        int argNumber = props.version() == VERSION_1 ? 3 : args.length;\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":83,"deletions":17,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n+    private OperationProperties props = new OperationProperties(VERSION_1); \/\/ updated in ctor\n@@ -58,1 +58,1 @@\n-                ver = detectVersion();\n+                props = getDefaultProps();\n@@ -91,1 +91,1 @@\n-            hPipe = createPipe(ver, pipename);\n+            hPipe = createPipe(props.version(), pipename);\n@@ -96,1 +96,1 @@\n-            hPipe = createPipe(ver, pipename);\n+            hPipe = createPipe(props.version(), pipename);\n@@ -108,2 +108,2 @@\n-            if (ver == VERSION_1) {\n-                enqueue(hProcess, stub, ver, cmd, pipename, args);\n+            if (props.version() == VERSION_1) {\n+                enqueue(hProcess, stub, props.version(), cmd, pipename, args);\n@@ -112,1 +112,1 @@\n-                enqueue(hProcess, stub, ver, null, pipename);\n+                enqueue(hProcess, stub, props.version(), null, pipename);\n@@ -120,1 +120,1 @@\n-            if (ver == VERSION_2) {\n+            if (props.version() == VERSION_2) {\n@@ -124,1 +124,1 @@\n-                    writeCommand(writer, ver, cmd, args);\n+                    writeCommand(writer, props, cmd, args);\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Sanity test for streaming output support\n+ * @bug 8319055\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/sun.tools.attach\n+ *\n+ * @run main\/othervm -Djdk.attach.allowStreamingOutput=true StreamingOutputTest\n+ * @run main\/othervm -Djdk.attach.allowStreamingOutput=false StreamingOutputTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import sun.tools.attach.HotSpotVirtualMachine;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class StreamingOutputTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean clientStreaming = System.getProperty(\"jdk.attach.allowStreamingOutput\").equals(\"true\");\n+        test(clientStreaming, false);\n+        test(clientStreaming, true);\n+    }\n+\n+    private static void test(boolean clientStreaming, boolean vmStreaming) throws Exception {\n+        System.out.println(\"Testing: clientStreaming=\" + clientStreaming + \", vmStreaming=\" + vmStreaming);\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp(\"-Xlog:attach=trace\",\n+                                       \"-Djdk.attach.vm.streaming=\" + String.valueOf(vmStreaming));\n+            attach(app, clientStreaming, vmStreaming);\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+\n+        verify(clientStreaming, vmStreaming, app.getProcessStdout());\n+\n+        System.out.println(\"Testing: end\");\n+        System.out.println();\n+    }\n+\n+    private static void attach(LingeredApp app, boolean clientStreaming, boolean vmStreaming) throws Exception {\n+        HotSpotVirtualMachine vm = (HotSpotVirtualMachine)VirtualMachine.attach(String.valueOf(app.getPid()));\n+        try {\n+            try (BufferedReader replyReader = new BufferedReader(\n+                    new InputStreamReader(vm.setFlag(\"HeapDumpPath\", \"the_path\")))) {\n+                System.out.println(\"vm.setFlag reply:\");\n+                String line;\n+                while ((line = replyReader.readLine()) != null) {\n+                    System.out.println(\"setFlag reply: \" + line);\n+                }\n+            }\n+        } finally {\n+            vm.detach();\n+        }\n+    }\n+\n+    private static void verify(boolean clientStreaming, boolean vmStreaming, String out) throws Exception {\n+        System.out.println(\"Target VM output:\");\n+        System.out.println(out);\n+        String expected = \"executing command setflag, streaming output: \" + (clientStreaming ? \"1\" : \"0\");\n+        if (!out.contains(expected)) {\n+            throw new Exception(\"VM did not logged expected '\" + expected + \"'\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachAPIv2\/StreamingOutputTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @bug 8225388\n@@ -41,2 +42,3 @@\n-        executor.execute(\"Compiler.CodeHeap_Analytics all 0\").shouldHaveExitValue(1);\n-        executor.execute(\"Compiler.CodeHeap_Analytics all k\").shouldHaveExitValue(1);\n+        \/\/ invalid argument should report exception, and don't crash\n+        executor.execute(\"Compiler.CodeHeap_Analytics all 0\").shouldContain(\"IllegalArgumentException\");\n+        executor.execute(\"Compiler.CodeHeap_Analytics all k\").shouldContain(\"IllegalArgumentException\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CodeHeapAnalyticsParams.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}