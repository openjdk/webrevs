{"files":[{"patch":"@@ -39,3 +39,0 @@\n-  \/\/ Passive runs with max speed for allocation, because GC is always STW\n-  SHENANDOAH_ERGO_DISABLE_FLAG(ShenandoahPacing);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-  out->print_cr(\"tune GC heuristics, set more aggressive pacing delay, or lower allocation rate\");\n+  out->print_cr(\"tune GC heuristics, or lower allocation rate\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-    if (ShenandoahVerify || ShenandoahPacing) {\n+    if (ShenandoahVerify) {\n@@ -632,3 +632,1 @@\n-  if (ShenandoahPacing) {\n-    heap->pacer()->setup_for_reset();\n-  }\n+\n@@ -746,3 +744,0 @@\n-  if (ShenandoahPacing) {\n-    heap->pacer()->setup_for_mark();\n-  }\n@@ -809,3 +804,0 @@\n-      if (ShenandoahPacing) {\n-        heap->pacer()->setup_for_evac();\n-      }\n@@ -1139,3 +1131,0 @@\n-  if (ShenandoahPacing) {\n-    heap->pacer()->setup_for_update_refs();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n@@ -72,3 +71,0 @@\n-    \/\/ This control loop iteration has seen this much allocation.\n-    const size_t allocs_seen = reset_allocs_seen();\n-\n@@ -207,3 +203,0 @@\n-      if (ShenandoahPacing) {\n-        heap->pacer()->flush_stats_to_cycle();\n-      }\n@@ -218,3 +211,0 @@\n-          if (ShenandoahPacing) {\n-            heap->pacer()->print_cycle_on(&ls);\n-          }\n@@ -229,10 +219,0 @@\n-\n-      \/\/ GC is over, we are at idle now\n-      if (ShenandoahPacing) {\n-        heap->pacer()->setup_for_idle();\n-      }\n-    } else {\n-      \/\/ Report to pacer that we have seen this many words allocated\n-      if (ShenandoahPacing && (allocs_seen > 0)) {\n-        heap->pacer()->report_alloc(allocs_seen);\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,8 +32,0 @@\n-void ShenandoahController::pacing_notify_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"should only call when pacing is enabled\");\n-  Atomic::add(&_allocs_seen, words, memory_order_relaxed);\n-}\n-\n-size_t ShenandoahController::reset_allocs_seen() {\n-  return Atomic::xchg(&_allocs_seen, (size_t)0, memory_order_relaxed);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  volatile size_t _allocs_seen;\n-  shenandoah_padding(1);\n@@ -44,1 +42,1 @@\n-  shenandoah_padding(2);\n+  shenandoah_padding(1);\n@@ -58,1 +56,0 @@\n-    _allocs_seen(0),\n@@ -79,8 +76,0 @@\n-  \/\/ This is called for every allocation. The control thread accumulates\n-  \/\/ this value when idle. During the gc cycle, the control resets it\n-  \/\/ and reports it to the pacer.\n-  void pacing_notify_alloc(size_t words);\n-\n-  \/\/ Zeros out the number of allocations seen since the last GC cycle.\n-  size_t reset_allocs_seen();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1266,4 +1266,0 @@\n-  if (remainder != 0) {\n-    \/\/ Record this remainder as allocation waste\n-    _heap->notify_mutator_alloc_words(ShenandoahHeapRegion::region_size_words() - remainder, true);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n@@ -64,1 +63,0 @@\n-  const int64_t wait_ms = ShenandoahPacing ? ShenandoahControlIntervalMin : 0;\n@@ -68,3 +66,0 @@\n-    \/\/ This control loop iteration has seen this much allocation.\n-    const size_t allocs_seen = reset_allocs_seen();\n-\n@@ -80,5 +75,0 @@\n-    } else {\n-      \/\/ Report to pacer that we have seen this many words allocated\n-      if (ShenandoahPacing && (allocs_seen > 0)) {\n-        _heap->pacer()->report_alloc(allocs_seen);\n-      }\n@@ -93,1 +83,1 @@\n-        ml.wait(wait_ms);\n+        ml.wait();\n@@ -312,5 +302,0 @@\n-  \/\/ GC is over, we are at idle now\n-  if (ShenandoahPacing) {\n-    _heap->pacer()->setup_for_idle();\n-  }\n-\n@@ -334,3 +319,0 @@\n-  if (ShenandoahPacing) {\n-    _heap->pacer()->flush_stats_to_cycle();\n-  }\n@@ -350,3 +332,0 @@\n-      if (ShenandoahPacing) {\n-        _heap->pacer()->print_cycle_on(&ls);\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.hpp\"\n@@ -130,3 +129,0 @@\n-      if (ShenandoahPacing) {\n-        _heap->pacer()->report_evac(r->used() >> LogHeapWordSize);\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -842,1 +842,0 @@\n-          \/\/ Don't bother to report pacing progress in this case.\n@@ -860,4 +859,0 @@\n-      if (region_progress && ShenandoahPacing) {\n-        _heap->pacer()->report_update_refs(pointer_delta(update_watermark, r->bottom()));\n-      }\n-\n@@ -919,4 +914,0 @@\n-\n-        if (ShenandoahPacing) {\n-          _heap->pacer()->report_update_refs(pointer_delta(end_of_range, start_of_range));\n-        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n@@ -473,5 +472,0 @@\n-  if (ShenandoahPacing) {\n-    _pacer = new ShenandoahPacer(this);\n-    _pacer->setup_for_idle();\n-  }\n-\n@@ -561,1 +555,0 @@\n-  _pacer(nullptr),\n@@ -719,2 +712,1 @@\n-\/\/ * Mutator allocations are used to compute an allocation rate. They are also\n-\/\/   sent to the Pacer for those purposes.\n+\/\/ * Mutator allocations are used to compute an allocation rate.\n@@ -741,3 +733,0 @@\n-    \/\/ notify pacer of both actual size and waste\n-    notify_mutator_alloc_words(req.actual_size(), req.waste());\n-\n@@ -778,9 +767,0 @@\n-void ShenandoahHeap::notify_mutator_alloc_words(size_t words, size_t waste) {\n-  if (ShenandoahPacing) {\n-    control_thread()->pacing_notify_alloc(words);\n-    if (waste > 0) {\n-      pacer()->claim_for_alloc<true>(waste);\n-    }\n-  }\n-}\n-\n@@ -968,1 +948,0 @@\n-  intptr_t pacer_epoch = 0;\n@@ -973,4 +952,0 @@\n-    if (ShenandoahPacing) {\n-      pacer()->pace_for_alloc(req.size());\n-      pacer_epoch = pacer()->epoch();\n-    }\n@@ -1051,9 +1026,0 @@\n-\n-    if (req.is_mutator_alloc()) {\n-      \/\/ If we requested more than we were granted, give the rest back to pacer.\n-      \/\/ This only matters if we are in the same pacing epoch: do not try to unpace\n-      \/\/ over the budget for the other phase.\n-      if (ShenandoahPacing && (pacer_epoch > 0) && (requested > actual)) {\n-        pacer()->unpace_for_alloc(pacer_epoch, requested - actual);\n-      }\n-    }\n@@ -1209,4 +1175,0 @@\n-      if (ShenandoahPacing) {\n-        _sh->pacer()->report_evac(r->used() >> LogHeapWordSize);\n-      }\n-\n@@ -2491,3 +2453,0 @@\n-        if (ShenandoahPacing) {\n-          _heap->pacer()->report_update_refs(pointer_delta(update_watermark, r->bottom()));\n-        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/shenandoah\/shenandoahPacer.inline.hpp\"\n@@ -138,3 +137,0 @@\n-  if (ShenandoahPacing) {\n-    ShenandoahHeap::heap()->pacer()->report_mark(s);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,341 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPacer.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/javaThread.inline.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/threadSMR.hpp\"\n-\n-\/*\n- * In normal concurrent cycle, we have to pace the application to let GC finish.\n- *\n- * Here, we do not know how large would be the collection set, and what are the\n- * relative performances of the each stage in the concurrent cycle, and so we have to\n- * make some assumptions.\n- *\n- * For concurrent mark, there is no clear notion of progress. The moderately accurate\n- * and easy to get metric is the amount of live objects the mark had encountered. But,\n- * that does directly correlate with the used heap, because the heap might be fully\n- * dead or fully alive. We cannot assume either of the extremes: we would either allow\n- * application to run out of memory if we assume heap is fully dead but it is not, and,\n- * conversely, we would pacify application excessively if we assume heap is fully alive\n- * but it is not. So we need to guesstimate the particular expected value for heap liveness.\n- * The best way to do this is apparently recording the past history.\n- *\n- * For concurrent evac and update-refs, we are walking the heap per-region, and so the\n- * notion of progress is clear: we get reported the \"used\" size from the processed regions\n- * and use the global heap-used as the baseline.\n- *\n- * The allocatable space when GC is running is \"free\" at the start of phase, but the\n- * accounted budget is based on \"used\". So, we need to adjust the tax knowing that.\n- *\/\n-\n-void ShenandoahPacer::setup_for_mark() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t live = update_and_get_progress_history();\n-  size_t free = _heap->free_set()->available();\n-  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n-\n-  size_t non_taxable = free * ShenandoahPacingCycleSlack \/ 100;\n-  size_t taxable = free - non_taxable;\n-  taxable = MAX2<size_t>(1, taxable);\n-\n-  double tax = 1.0 * live \/ taxable; \/\/ base tax for available free space\n-  tax *= 1;                          \/\/ mark can succeed with immediate garbage, claim all available space\n-  tax *= ShenandoahPacingSurcharge;  \/\/ additional surcharge to help unclutter heap\n-\n-  restart_with(non_taxable, tax);\n-\n-  log_info(gc, ergo)(\"Pacer for Mark. Expected Live: %zu%s, Free: %zu%s, \"\n-                     \"Non-Taxable: %zu%s, Alloc Tax Rate: %.1fx\",\n-                     byte_size_in_proper_unit(live),        proper_unit_for_byte_size(live),\n-                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),\n-                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),\n-                     tax);\n-}\n-\n-void ShenandoahPacer::setup_for_evac() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t used = _heap->collection_set()->used();\n-  size_t free = _heap->free_set()->available();\n-  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n-\n-  size_t non_taxable = free * ShenandoahPacingCycleSlack \/ 100;\n-  size_t taxable = free - non_taxable;\n-  taxable = MAX2<size_t>(1, taxable);\n-\n-  double tax = 1.0 * used \/ taxable; \/\/ base tax for available free space\n-  tax *= 2;                          \/\/ evac is followed by update-refs, claim 1\/2 of remaining free\n-  tax = MAX2<double>(1, tax);        \/\/ never allocate more than GC processes during the phase\n-  tax *= ShenandoahPacingSurcharge;  \/\/ additional surcharge to help unclutter heap\n-\n-  restart_with(non_taxable, tax);\n-\n-  log_info(gc, ergo)(\"Pacer for Evacuation. Used CSet: %zu%s, Free: %zu%s, \"\n-                     \"Non-Taxable: %zu%s, Alloc Tax Rate: %.1fx\",\n-                     byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),\n-                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),\n-                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),\n-                     tax);\n-}\n-\n-void ShenandoahPacer::setup_for_update_refs() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t used = _heap->used();\n-  size_t free = _heap->free_set()->available();\n-  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n-\n-  size_t non_taxable = free * ShenandoahPacingCycleSlack \/ 100;\n-  size_t taxable = free - non_taxable;\n-  taxable = MAX2<size_t>(1, taxable);\n-\n-  double tax = 1.0 * used \/ taxable; \/\/ base tax for available free space\n-  tax *= 1;                          \/\/ update-refs is the last phase, claim the remaining free\n-  tax = MAX2<double>(1, tax);        \/\/ never allocate more than GC processes during the phase\n-  tax *= ShenandoahPacingSurcharge;  \/\/ additional surcharge to help unclutter heap\n-\n-  restart_with(non_taxable, tax);\n-\n-  log_info(gc, ergo)(\"Pacer for Update Refs. Used: %zu%s, Free: %zu%s, \"\n-                     \"Non-Taxable: %zu%s, Alloc Tax Rate: %.1fx\",\n-                     byte_size_in_proper_unit(used),        proper_unit_for_byte_size(used),\n-                     byte_size_in_proper_unit(free),        proper_unit_for_byte_size(free),\n-                     byte_size_in_proper_unit(non_taxable), proper_unit_for_byte_size(non_taxable),\n-                     tax);\n-}\n-\n-\/*\n- * In idle phase, we have to pace the application to let control thread react with GC start.\n- *\n- * Here, we have rendezvous with concurrent thread that adds up the budget as it acknowledges\n- * it had seen recent allocations. It will naturally pace the allocations if control thread is\n- * not catching up. To bootstrap this feedback cycle, we need to start with some initial budget\n- * for applications to allocate at.\n- *\/\n-\n-void ShenandoahPacer::setup_for_idle() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t initial = _heap->max_capacity() \/ 100 * ShenandoahPacingIdleSlack;\n-  double tax = 1;\n-\n-  restart_with(initial, tax);\n-\n-  log_info(gc, ergo)(\"Pacer for Idle. Initial: %zu%s, Alloc Tax Rate: %.1fx\",\n-                     byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial),\n-                     tax);\n-}\n-\n-\/*\n- * There is no useful notion of progress for these operations. To avoid stalling\n- * the allocators unnecessarily, allow them to run unimpeded.\n- *\/\n-\n-void ShenandoahPacer::setup_for_reset() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t initial = _heap->max_capacity();\n-  restart_with(initial, 1.0);\n-\n-  log_info(gc, ergo)(\"Pacer for Reset. Non-Taxable: %zu%s\",\n-                     byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial));\n-}\n-\n-size_t ShenandoahPacer::update_and_get_progress_history() {\n-  if (_progress == -1) {\n-    \/\/ First initialization, report some prior\n-    Atomic::store(&_progress, (intptr_t)PACING_PROGRESS_ZERO);\n-    return (size_t) (_heap->max_capacity() * 0.1);\n-  } else {\n-    \/\/ Record history, and reply historical data\n-    _progress_history->add(_progress);\n-    Atomic::store(&_progress, (intptr_t)PACING_PROGRESS_ZERO);\n-    return (size_t) (_progress_history->avg() * HeapWordSize);\n-  }\n-}\n-\n-void ShenandoahPacer::restart_with(size_t non_taxable_bytes, double tax_rate) {\n-  size_t initial = (size_t)(non_taxable_bytes * tax_rate) >> LogHeapWordSize;\n-  STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));\n-  Atomic::xchg(&_budget, (intptr_t)initial, memory_order_relaxed);\n-  Atomic::store(&_tax_rate, tax_rate);\n-  Atomic::inc(&_epoch);\n-\n-  \/\/ Shake up stalled waiters after budget update.\n-  _need_notify_waiters.try_set();\n-}\n-\n-template<bool FORCE>\n-bool ShenandoahPacer::claim_for_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  intptr_t tax = MAX2<intptr_t>(1, words * Atomic::load(&_tax_rate));\n-\n-  intptr_t cur = 0;\n-  intptr_t new_val = 0;\n-  do {\n-    cur = Atomic::load(&_budget);\n-    if (cur < tax && !FORCE) {\n-      \/\/ Progress depleted, alas.\n-      return false;\n-    }\n-    new_val = cur - tax;\n-  } while (Atomic::cmpxchg(&_budget, cur, new_val, memory_order_relaxed) != cur);\n-  return true;\n-}\n-\n-template bool ShenandoahPacer::claim_for_alloc<true>(size_t words);\n-template bool ShenandoahPacer::claim_for_alloc<false>(size_t words);\n-\n-void ShenandoahPacer::unpace_for_alloc(intptr_t epoch, size_t words) {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  if (Atomic::load(&_epoch) != epoch) {\n-    \/\/ Stale ticket, no need to unpace.\n-    return;\n-  }\n-\n-  size_t tax = MAX2<size_t>(1, words * Atomic::load(&_tax_rate));\n-  add_budget(tax);\n-}\n-\n-intptr_t ShenandoahPacer::epoch() {\n-  return Atomic::load(&_epoch);\n-}\n-\n-void ShenandoahPacer::pace_for_alloc(size_t words) {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  \/\/ Fast path: try to allocate right away\n-  bool claimed = claim_for_alloc<false>(words);\n-  if (claimed) {\n-    return;\n-  }\n-\n-  \/\/ Threads that are attaching should not block at all: they are not\n-  \/\/ fully initialized yet. Blocking them would be awkward.\n-  \/\/ This is probably the path that allocates the thread oop itself.\n-  \/\/\n-  \/\/ Thread which is not an active Java thread should also not block.\n-  \/\/ This can happen during VM init when main thread is still not an\n-  \/\/ active Java thread.\n-  JavaThread* current = JavaThread::current();\n-  if (current->is_attaching_via_jni() ||\n-      !current->is_active_Java_thread()) {\n-    claim_for_alloc<true>(words);\n-    return;\n-  }\n-\n-  jlong const start_time = os::javaTimeNanos();\n-  jlong const deadline = start_time + (ShenandoahPacingMaxDelay * NANOSECS_PER_MILLISEC);\n-  while (!claimed && os::javaTimeNanos() < deadline) {\n-    \/\/ We could instead assist GC, but this would suffice for now.\n-    wait(1);\n-    claimed = claim_for_alloc<false>(words);\n-  }\n-  if (!claimed) {\n-    \/\/ Spent local time budget to wait for enough GC progress.\n-    \/\/ Force allocating anyway, which may mean we outpace GC,\n-    \/\/ and start Degenerated GC cycle.\n-    claimed = claim_for_alloc<true>(words);\n-    assert(claimed, \"Should always succeed\");\n-  }\n-  ShenandoahThreadLocalData::add_paced_time(current, (double)(os::javaTimeNanos() - start_time) \/ NANOSECS_PER_SEC);\n-}\n-\n-void ShenandoahPacer::wait(size_t time_ms) {\n-  \/\/ Perform timed wait. It works like like sleep(), except without modifying\n-  \/\/ the thread interruptible status. MonitorLocker also checks for safepoints.\n-  assert(time_ms > 0, \"Should not call this with zero argument, as it would stall until notify\");\n-  assert(time_ms <= LONG_MAX, \"Sanity\");\n-  MonitorLocker locker(_wait_monitor);\n-  _wait_monitor->wait(time_ms);\n-}\n-\n-void ShenandoahPacer::notify_waiters() {\n-  if (_need_notify_waiters.try_unset()) {\n-    MonitorLocker locker(_wait_monitor);\n-    _wait_monitor->notify_all();\n-  }\n-}\n-\n-void ShenandoahPacer::flush_stats_to_cycle() {\n-  double sum = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    sum += ShenandoahThreadLocalData::paced_time(t);\n-  }\n-  ShenandoahHeap::heap()->phase_timings()->record_phase_time(ShenandoahPhaseTimings::pacing, sum);\n-}\n-\n-void ShenandoahPacer::print_cycle_on(outputStream* out) {\n-  MutexLocker lock(Threads_lock);\n-\n-  double now = os::elapsedTime();\n-  double total = now - _last_time;\n-  _last_time = now;\n-\n-  out->cr();\n-  out->print_cr(\"Allocation pacing accrued:\");\n-\n-  size_t threads_total = 0;\n-  size_t threads_nz = 0;\n-  double sum = 0;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-    double d = ShenandoahThreadLocalData::paced_time(t);\n-    if (d > 0) {\n-      threads_nz++;\n-      sum += d;\n-      out->print_cr(\"  %5.0f of %5.0f ms (%5.1f%%): %s\",\n-              d * 1000, total * 1000, d\/total*100, t->name());\n-    }\n-    threads_total++;\n-    ShenandoahThreadLocalData::reset_paced_time(t);\n-  }\n-  out->print_cr(\"  %5.0f of %5.0f ms (%5.1f%%): <total>\",\n-          sum * 1000, total * 1000, sum\/total*100);\n-\n-  if (threads_total > 0) {\n-    out->print_cr(\"  %5.0f of %5.0f ms (%5.1f%%): <average total>\",\n-            sum \/ threads_total * 1000, total * 1000, sum \/ threads_total \/ total * 100);\n-  }\n-  if (threads_nz > 0) {\n-    out->print_cr(\"  %5.0f of %5.0f ms (%5.1f%%): <average non-zero>\",\n-            sum \/ threads_nz * 1000, total * 1000, sum \/ threads_nz \/ total * 100);\n-  }\n-  out->cr();\n-}\n-\n-void ShenandoahPeriodicPacerNotifyTask::task() {\n-  assert(ShenandoahPacing, \"Should not be here otherwise\");\n-  _pacer->notify_waiters();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":0,"deletions":341,"binary":false,"changes":341,"status":"deleted"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHPACER_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHPACER_HPP\n-\n-#include \"gc\/shenandoah\/shenandoahNumberSeq.hpp\"\n-#include \"gc\/shenandoah\/shenandoahPadding.hpp\"\n-#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/task.hpp\"\n-\n-class ShenandoahHeap;\n-class ShenandoahPacer;\n-\n-\n-\/\/ Periodic task to notify blocked paced waiters.\n-class ShenandoahPeriodicPacerNotifyTask : public PeriodicTask {\n-private:\n-  ShenandoahPacer* const _pacer;\n-public:\n-  explicit ShenandoahPeriodicPacerNotifyTask(ShenandoahPacer* pacer) :\n-    PeriodicTask(PeriodicTask::min_interval),\n-    _pacer(pacer) { }\n-\n-  void task() override;\n-};\n-\n-\n-#define PACING_PROGRESS_UNINIT (-1)\n-#define PACING_PROGRESS_ZERO   ( 0)\n-\n-\/**\n- * ShenandoahPacer provides allocation pacing mechanism.\n- *\n- * Currently it implements simple tax-and-spend pacing policy: GC threads provide\n- * credit, allocating thread spend the credit, or stall when credit is not available.\n- *\/\n-class ShenandoahPacer : public CHeapObj<mtGC> {\n-private:\n-  ShenandoahHeap* _heap;\n-  double _last_time;\n-  TruncatedSeq* _progress_history;\n-  Monitor* _wait_monitor;\n-  ShenandoahSharedFlag _need_notify_waiters;\n-  ShenandoahPeriodicPacerNotifyTask _notify_waiters_task;\n-\n-  \/\/ Set once per phase\n-  volatile intptr_t _epoch;\n-  volatile double _tax_rate;\n-\n-  \/\/ Heavily updated, protect from accidental false sharing\n-  shenandoah_padding(0);\n-  volatile intptr_t _budget;\n-  shenandoah_padding(1);\n-\n-  \/\/ Heavily updated, protect from accidental false sharing\n-  shenandoah_padding(2);\n-  volatile intptr_t _progress;\n-  shenandoah_padding(3);\n-\n-public:\n-  explicit ShenandoahPacer(ShenandoahHeap* heap) :\n-          _heap(heap),\n-          _last_time(os::elapsedTime()),\n-          _progress_history(new TruncatedSeq(5)),\n-          _wait_monitor(new Monitor(Mutex::safepoint-1, \"ShenandoahWaitMonitor_lock\", true)),\n-          _notify_waiters_task(this),\n-          _epoch(0),\n-          _tax_rate(1),\n-          _budget(0),\n-          _progress(PACING_PROGRESS_UNINIT) {\n-    _notify_waiters_task.enroll();\n-  }\n-\n-  void setup_for_idle();\n-  void setup_for_mark();\n-  void setup_for_evac();\n-  void setup_for_update_refs();\n-\n-  void setup_for_reset();\n-\n-  inline void report_mark(size_t words);\n-  inline void report_evac(size_t words);\n-  inline void report_update_refs(size_t words);\n-\n-  inline void report_alloc(size_t words);\n-\n-  template<bool FORCE>\n-  bool claim_for_alloc(size_t words);\n-\n-  void pace_for_alloc(size_t words);\n-  void unpace_for_alloc(intptr_t epoch, size_t words);\n-\n-  void notify_waiters();\n-\n-  intptr_t epoch();\n-\n-  void flush_stats_to_cycle();\n-  void print_cycle_on(outputStream* out);\n-\n-private:\n-  inline void report_internal(size_t words);\n-  inline void report_progress_internal(size_t words);\n-\n-  inline void add_budget(size_t words);\n-  void restart_with(size_t non_taxable_bytes, double tax_rate);\n-\n-  size_t update_and_get_progress_history();\n-\n-  void wait(size_t time_ms);\n-};\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHPACER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHPACER_INLINE_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHPACER_INLINE_HPP\n-\n-#include \"gc\/shenandoah\/shenandoahPacer.hpp\"\n-\n-#include \"runtime\/atomic.hpp\"\n-\n-inline void ShenandoahPacer::report_mark(size_t words) {\n-  report_internal(words);\n-  report_progress_internal(words);\n-}\n-\n-inline void ShenandoahPacer::report_evac(size_t words) {\n-  report_internal(words);\n-}\n-\n-inline void ShenandoahPacer::report_update_refs(size_t words) {\n-  report_internal(words);\n-}\n-\n-inline void ShenandoahPacer::report_alloc(size_t words) {\n-  report_internal(words);\n-}\n-\n-inline void ShenandoahPacer::report_internal(size_t words) {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-  add_budget(words);\n-}\n-\n-inline void ShenandoahPacer::report_progress_internal(size_t words) {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-  STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));\n-  Atomic::add(&_progress, (intptr_t)words, memory_order_relaxed);\n-}\n-\n-inline void ShenandoahPacer::add_budget(size_t words) {\n-  STATIC_ASSERT(sizeof(size_t) <= sizeof(intptr_t));\n-  intptr_t inc = (intptr_t) words;\n-  intptr_t new_budget = Atomic::add(&_budget, inc, memory_order_relaxed);\n-\n-  \/\/ Was the budget replenished beyond zero? Then all pacing claims\n-  \/\/ are satisfied, notify the waiters. Avoid taking any locks here,\n-  \/\/ as it can be called from hot paths and\/or while holding other locks.\n-  if (new_budget >= 0 && (new_budget - inc) < 0) {\n-    _need_notify_waiters.try_set();\n-  }\n-}\n-\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHPACER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.inline.hpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -284,11 +284,0 @@\n-  out->print_cr(\"  Pacing delays are measured from entering the pacing code till exiting it. Therefore,\");\n-  out->print_cr(\"  observed pacing delays may be higher than the threshold when paced thread spent more\");\n-  out->print_cr(\"  time in the pacing code. It usually happens when thread is de-scheduled while paced,\");\n-  out->print_cr(\"  OS takes longer to unblock the thread, or JVM experiences an STW pause.\");\n-  out->cr();\n-  out->print_cr(\"  Higher delay would prevent application outpacing the GC, but it will hide the GC latencies\");\n-  out->print_cr(\"  from the STW pause times. Pacing affects the individual threads, and so it would also be\");\n-  out->print_cr(\"  invisible to the usual profiling tools, but would add up to end-to-end application latency.\");\n-  out->print_cr(\"  Raise max pacing delay with care.\");\n-  out->cr();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -411,34 +411,0 @@\n-  product(bool, ShenandoahPacing, true, EXPERIMENTAL,                       \\\n-          \"Pace application allocations to give GC chance to start \"        \\\n-          \"and complete before allocation failure is reached.\")             \\\n-                                                                            \\\n-  product(uintx, ShenandoahPacingMaxDelay, 10, EXPERIMENTAL,                \\\n-          \"Max delay for pacing application allocations. Larger values \"    \\\n-          \"provide more resilience against out of memory, at expense at \"   \\\n-          \"hiding the GC latencies in the allocation path. Time is in \"     \\\n-          \"milliseconds. Setting it to arbitrarily large value makes \"      \\\n-          \"GC effectively stall the threads indefinitely instead of going \" \\\n-          \"to degenerated or Full GC.\")                                     \\\n-                                                                            \\\n-  product(uintx, ShenandoahPacingIdleSlack, 2, EXPERIMENTAL,                \\\n-          \"How much of heap counted as non-taxable allocations during idle \"\\\n-          \"phases. Larger value makes the pacing milder when collector is \" \\\n-          \"idle, requiring less rendezvous with control thread. Lower \"     \\\n-          \"value makes the pacing control less responsive to out-of-cycle \" \\\n-          \"allocs. In percent of total heap size.\")                         \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  product(uintx, ShenandoahPacingCycleSlack, 10, EXPERIMENTAL,              \\\n-          \"How much of free space to take as non-taxable allocations \"      \\\n-          \"the GC cycle. Larger value makes the pacing milder at the \"      \\\n-          \"beginning of the GC cycle. Lower value makes the pacing less \"   \\\n-          \"uniform during the cycle. In percent of free space.\")            \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  product(double, ShenandoahPacingSurcharge, 1.1, EXPERIMENTAL,             \\\n-          \"Additional pacing tax surcharge to help unclutter the heap. \"    \\\n-          \"Larger values makes the pacing more aggressive. Lower values \"   \\\n-          \"risk GC cycles finish with less memory than were available at \"  \\\n-          \"the beginning of it.\")                                           \\\n-          range(1.0, 100.0)                                                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- *      -XX:-UseDynamicNumberOfGCThreads -XX:-ShenandoahPacing\n+ *      -XX:-UseDynamicNumberOfGCThreads\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestConcurrentEvac.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @requires vm.gc.Shenandoah\n- *\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:-ShenandoahPacing -Xmx128m TestPacing\n- * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:+ShenandoahPacing -Xmx128m TestPacing\n- *\/\n-\n-public class TestPacing {\n-    static final long TARGET_MB = Long.getLong(\"target\", 1000); \/\/ 1 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 16;\n-        for (long c = 0; c < count; c++) {\n-            sink = new Object();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestPacing.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"}]}